/* REXX */
interpret "retcode = INJ"||"STUB('"arg(1)"')" /*invisible to INJECTOR*/
if rexxname <> '?'
   then
     do   /* submitted by TSO */
     ZISPFRC = retcode
     "ISPEXEC VPUT (ZISPFRC)"
     exit retcode
     end
   else
     do   /* submitted by injector */
     return retcode
     end

/* ================================================================ */
/*          INJECTOR STUB                                           */
/* ================================================================ */
INJSTUB_NA : procedure
parse source . . rexxname  . rexxlib  .
rcode = PARM_VALIDATION(arg(1))
if word(rcode,1) <> 0
  then
    return 8
  else
    do
    msg_level = word(rcode,2)
    return INJREXX(rexxname rexxlib msg_level arg(1))
    end
/* ================================================================ */
/*          PARAMETER VALIDATION                                    */
/* ================================================================ */
/* == User may change parsing of parameter of his application.   == */
/* == But MSG_LEVEL at return should be in interval <1,10>       == */
/* ================================================================ */
PARM_VALIDATION : procedure
parse arg timeout percent system_response msg_level .
upper msg_level
if datatype(msg_level) <> "NUM" & msg_level <> "ALL" & msg_level <> ''
  then
    do
    say "MESSAGE LEVEL should be NULL, ALL or in interval 1-10"
    say "please correct the parameter and resubmit"
    return 8
    end
if msg_level = ''
  then
    msg_level=1
if msg_level = "ALL"
  then
    msg_level=10
return 0 msg_level

/* ================================================================ */
/*          MAIN PROCEDURE                                          */
/* ================================================================ */
SUMRX_MAIN : procedure expose msg_level HEAP.
COPYLIB='SUMRX.APPL.COPY'
SUMRXLIB='SUMRX.V201.FWLIB'
INJRDY='SUMRX.COMPLED.LIB(SPWCHDOG)'
/* copylib & sumrxlib   */
if copylib = "COPYLIB"
  then
    copylib  = 'SUMRX.APPL.COPY'
if sumrxlib = "SUMRXLIB"
  then
    sumrxlib  = 'SUMRX.V201.FWLIB'
injstm.APPLARR = "MSGARRAY"
injstm.TRCHLPR = "TRCDATA"
injstm.SERVICE = "SRVCDMY"

parse arg timeout percent system_response .
token_num = 0
RC=MSG(1) /* SPOOL WATCHDOG started */
RC=MSG(2,"         TIMEOUT (sec):",timeout)
RC=MSG(2,"   SPOOL THRESHOLD (%):",percent)
RC=MSG(2,"SYSTEM REPONSED (sec%):",system_response)
RC=MSG(2,"         MESSAGE LEVEL:",msg_level)


Address TSO
"CONSPROF SOLDISPLAY(NO) SOLNUM(400)"
"CONSOLE ACTIVATE NAME(CONS0001)"

do forever     /* loop to control sppol percentage */
token_num = token_num + 1
if token_num > 9999
  then
   token_num = 1

token = "SPMF" || right(token_num,4,'0')

cmd = "$DS(*ACS,*ACD,*AONI),SPL=(%>"percent")"
RC=MSG(3,cmd) /* Command  will be issued via CONSOLE */
Address TSO
"CONSOLE SYSCMD("cmd") CART("token")"
RC=MSG(4)  /* Call GETALLMSGS() to merge all GETMSG chunks */
retcode = GETALLMSGS()

RC=MSG(5)    /* Create <JOBS,%> candidate list  */
call CREATE_CANDIDATES_ARRAY

/* loop over all candidates array */
if stmjob.0 > 0
  then
    do
      /* loop over all candidates and stop them */
      do i = 1 to stmjob.0
      parse var stmjob.i jobname job_percent  .
      l = length(jobname)
      postfix = substr(jobname,l-2,3)
      if postfix = "ONI"
        then
          postfix = "AONI"
      parse var jobname prefix (postfix) .
      cmd = "P" prefix || "GATE"
     RC=MSG(3,cmd)  /* Command  will be issued via CONSOLE */
      Address TSO
      "CONSOLE SYSCMD("cmd")"
      end
    /* let system stop all candidates and then clear queues */
    call SLEEP(system_response)
    cmd = "$P O JOBQ,ALL"
   RC=MSG(3,cmd)  /* Command  will be issued via CONSOLE */
    "CONSOLE SYSCMD("cmd")"
    cmd = "$C O JOBQ,ALL"
   RC=MSG(3,cmd)  /* Command  will be issued via CONSOLE */
    "CONSOLE SYSCMD("cmd")"
    end

call SLEEP(timeout)
end     /* loop to control sppol percentage */
return 0

/***********************************************************/
/* this crestes array of jobs candidates to be stopped.    */
/* JESOUT. contains the quesy jes2 output                  */
/* STMJOB. is created stem to have <jobname-percent> pairs */
/***********************************************************/
CREATE_CANDIDATES_ARRAY : procedure expose jesout. stmjob. HEAP.

RC=MSG(6,"JESOUT",jesout.0) /* STEM created with ... lines */
 call TRACE_STEM  "jesout"

 j = 0
 stmjob.0 = 0
 if jesout.0  > 0
  then
    do  /* Create STMJOB */
     do i = 1 to jesout.0   /* loop over jes output */
     k = i + 1
     if wordindex(jesout.i,2) = 11          &  ,
        word(jesout.k,1) = word(jesout.i,1) &  ,
        word(jesout.k,2) = word(jesout.i,2)
         then
           do   /* new item */
            job = ''
            k = i
            i = i + 1
            temp =  word(jesout.i,2)
            parse var temp "JOB(" job ")" .
            if job = ''
             then
               iterate
             do i = k+1 to jesout.0 /* loop within item related lines */
             l = i + 1
             if wordindex(jesout.l,2) = 11          &  ,
                word(jesout.l,2) <> job
                 then /* unexpectedly found new item before PERCENT= */
                   do
                  RC=MSG(8,job) /* Can't collect data for job */
                   job = ''
                   i = l -1
                   leave
                   end
             if pos("PERCENT=",jesout.l) > 0
              then
                do /* found PERCENT= */
                parse var jesout.l "PERCENT=" job_percent ")" .
                j = j + 1
                stmjob.j = job job_percent
                stmjob.0 = j
                leave
                end
             end         /* loop within item related lines */
           end /* new item */
     end   /* loop over jes output */
   RC=MSG(6,"STMJOB",stmjob.0) /* STEM created with ... lines */
    call TRACE_STEM  "stmjob"
    end   /* Create STMJOB */
  else
    do
   RC=MSG(7,"STMJOB")   /* STEM ... will not be created */
    end
 return

/*********************************************************/
/* this call GETMSG service recursively and builds       */
/* JESOUT. stem.  Such tecnique is used due to a bug     */
/* of JES2 when workin with the CONSOLE interface        */
/*********************************************************/
GETALLMSGS : procedure expose token jesout. HEAP.
retcode = getmsg('TEMP.','sol',token,,3)
if retcode <> 0
  then
    return 0

/* 1st time , when not recursive call,  arg(1) = '' */
if arg(1) = ''
 then
   jesout.0 = 0

do i = 1 to temp.0
k = jesout.0 + i
jesout.k = temp.i
end
jesout.0 = k
return GETALLMSGS("N")


/* sleep seconds defined in arg(1)  */
SLEEP : procedure
ADDRESS SYSCALL "sleep" arg(1)
return
MSGARRAY : procedure expose SPIX.
/*      DOPTF                                                        */
SPIX.1   = "1I  SPOOL WATCHDOG started                                "
SPIX.2   = "1I  $$P1 $$P2                                             "
SPIX.3   = "1I  Command $$P1 will be issued via CONSOLE               "
SPIX.4   = "1I  Call GETALLMSGS() to merge all GETMSG chunks          "
SPIX.5   = "1I  Create <JOBS,%> candidate list                        "
SPIX.6   = "1I  Stem $$P1 created, $$P2 lines                         "
SPIX.7   = "1I  Stem $$P1 will not be created                         "
SPIX.8   = "1E  Cant  collect data for job $$P1                       "
SPIX.9   = "008 Cant  collect data for job $$P1                       "
SPIX.0   =  9
return
/********************************************************/
/* INJECTED ROUTINES                                    */
/********************************************************/
/* pipemode routine                                     */
/********************************************************/
PIPEMODE : procedure
PIPEMODE_PIPE_INJECTED=1
return PIPEMODE_PIPE_INJECTED
/********************************************************/
/* message routine                                      */
/* called with ether one or two + parameters:           */
/* One : the paramter is message data from appl         */
/* Two : 1st parameter indicates FW called the routine  */
/*     :  - H, heap                                     */
/*     :  - T, TCP/IP                                   */
/*     :  - D, 3270                                     */
/*     :  - L, LIB                                      */
/*     :  - F, File System                              */
/*     :  - C, Common Layer of Framework                */
/*     : 2nd parameter is message data/index of FW      */
/*     : + , additional parameteres for substitution    */
/********************************************************/
MSG  : procedure expose HEAP.
APPLPFX  = "SPIX"
FWPFX    = "SMRX"
/* only NEW fashion messages need HEAP */
if datatype(arg(1))  = "NUM"                  | ,
   (arg() > 1  &  datatype(arg(2))  = "NUM")
   then
    do      /* NEW FASHION MESSAGE */
    lock_name = "START_MSGS"
    /* This  will filter messages until HEAP is fully ready. */
    /* If MSG_RDY is not STA or STO (no MSG arrays yet       */
    /*  built) then entering                                 */
    /* If HEAP is not allocated we call HEAP API "Set var    */
    /*  MSG_RDY to STA" to cause HEAP allocation             */
    /* If HEAP is allocated we call HEAP API "Set var        */
    /*  MSG_RDY to STA" external to prevent HEAP messaging   */
    /* Setting MSG_RDY to STA by either abov method will     */
    /*  reject any incoming message !!!                      */
    /* During HEAP allocation a HEAP message may come (no    */
    /*  main stream) and it's filtered if HEAP is not ready  */
    /* Main stream after setting MSG_RDY to STA - at this    */
    /*  time HEAP ia already READY - loads message arrays    */
    /* Afte the message arrays loeded we call "Set var       */
    /*  MSG_RDY to FIN" to accept incoming nessages          */
    /*                                                       */

    /* if MSGARRAY & FRMARRAY are not started to load - load them */

    msg_ready_value =  GET_VARIABLE_VALUE_EXT("MSG_RDY")

    if msg_ready_value  <> "STA"  & ,
       msg_ready_value  <> "FIN"
      then
       do             /* Load MSGARRAY & FRMARRAY */
        /* reject if it's locked */
        if IS_HEAP_LOCK_SET_EXT(lock_name) = 1
          then
            return 0
        /* set lock */
        call SET_HEAP_LOCK_EXT(lock_name)

        if IS_HEAP_ALLOC_EXT() <> 0    /* heap not allocated ? */
         then
          do                    /* set MSG_RDY will allocate HEAP */
          retcode = CLSMNGR("set","variable","MSG_RDY","STA")
          if word(retcode,1) <> 0
           then
             do
             say "Set MSG_RDY API to STA failed. Terminating"
             exit 8
             end
          end                   /* set MSG_RDY will allocate HEAP */
         else
          do                    /* set MSG_RDY external */
           if SET_VARIABLE_VALUE_EXT("MSG_RDY","STA") <> 0
            then
              do
               say "Set MSG_RDY EXT API to STA failed. Terminating"
               exit 8
               end
          end                   /* set MSG_RDY external */

        /* unset lock */
        call UNSET_HEAP_LOCK_EXT(lock_name)

        call FRMARRAY       /* prepare stem of FW messages   */
        if FILL_MSG_STORAGE("FW",FWPFX) <> 0
          then
            exit 8
        call MSGARRAY       /* prepare stem of appl messages */
        if FILL_MSG_STORAGE("APPL",APPLPFX) <> 0
          then
            exit 8

        CALL SAY_OK  "Message storage has been successfully created"

        /* set MSGARRAY & FRMARRAY  loaded */
        if  SET_VARIABLE_VALUE_EXT("MSG_RDY","FIN") <> 0
         then
           do
            SAY "HEAP failure at setting MSG_RDY to FIN"
            exit 8
            end
       end            /* Load MSGARRAY & FRMARRAY */
    end     /* NEW FASHION MESSAGE */

 /* For both OLD and NEW fashions :                          */
 /* - When NO HEAP it will not filter OLD FASHION MSG        */
 /* - When HEAP it locks NEW FASHION messages until          */
 /*   MSG ARRAY LOADER completed                             */
 msg_ready_value =  GET_VARIABLE_VALUE_EXT("MSG_RDY")
 /* filter NEW messages until MSGARRAY & FRMARARY load finished */
 if (symbol('HEAP.0') = "VAR" & msg_ready_value <> "FIN")           & ,
    (datatype(arg(1)) = "NUM" | (arg() > 1 & datatype(arg(2)) = "NUM"))
   then
     return 0


/* possible message types : OLD & NEW                               */
/* OLD : message level as periods with or without FW name byte      */
/* NEW : 1st byte is message level                                  */
/*     : 2nd byte is message seveity : I/W/E                        */
/*     : 3rd byte is th action : T- terminate                       */
/*     : data since 5th byte. With parms in format $$P<i> to        */
/*       substitue from function arguments                          */

msg_id = 0
msg_type = 'I'
msg_data_explain = ''
if arg() = 1
  then  /* old or new fashion message with no parm */
    do
    args = 0
    FW = ''
    fw_eye_catcher = ' '
    PFX = APPLPFX
    if datatype(arg(1))  = "NUM"
     then
       do  /* new fasion messages kept in HEAP */
       msg_data = GET_MSG_FROM_HEAP_ELEMENT(FW,arg(1))
       fashion    = "NEW"
       msg_id     = arg(1)
       msg_type   = substr(msg_data,2,1)
       msg_action = substr(msg_data,3,1)
       warning = CHECK_PARMS_SIGNATURE(msg_id,msg_data,args)
       if warning <> 0
          then
            call PRINT_ARGS_WARNING warning
       if msg_type = 'W' | msg_type = 'E'
        then
         msg_data_explain = GET_MSG_EXPLAIN(FW,msg_id,msg_data,args)
       end
     else
       do
       msg_data = arg(1)
       fashion = "OLD"
       msg_action = ''
       end
    end
  else  /* a number of arguments */
  if datatype(arg(1))  = "NUM"
   then
     do  /* new fashion messages kept in HEAP, no prefix */
     PFX = APPLPFX
     FW = ''
     fw_eye_catcher = ' '
     msg_data = GET_MSG_FROM_HEAP_ELEMENT(FW,arg(1))
     fashion    = "NEW"
     args       = arg() - 1
     msg_id     = arg(1)
     msg_type   = substr(msg_data,2,1)
     msg_action = substr(msg_data,3,1)
     warning = CHECK_PARMS_SIGNATURE(msg_id,msg_data,args)
     if warning <> 0
       then
         call PRINT_ARGS_WARNING warning
       else
        do
        msg_data=INJECT_VALS(msg_data,arg(2),arg(3),arg(4),arg(5))
        if msg_type = 'W' | msg_type = 'E'
         then
          msg_data_explain = GET_MSG_EXPLAIN(FW,msg_id,msg_data,args,  ,
                                        arg(2),arg(3),arg(4),arg(5))
        end
     end
   else
     do  /* old & new fashion messages , with FW prefix */
     FW = arg(1)
     if FW <> "C"
       then
          do
          fw_eye_catcher = " <" || FW || "> "
          end
       else
          do
          fw_eye_catcher = ' '
          end
     PFX = FWPFX
     if datatype(arg(2))  = "NUM"
      then /* new fashion type  message */
        do
        msg_data = GET_MSG_FROM_HEAP_ELEMENT(FW,arg(2))
        fashion    = "NEW"
        args       = arg() - 2
        msg_id     = arg(2)
        msg_type   = substr(msg_data,2,1)
        msg_action = substr(msg_data,3,1)
        warning = CHECK_PARMS_SIGNATURE(msg_id,msg_data,args)
        if warning <> 0
         then
          call PRINT_ARGS_WARNING warning
         else
          do
          msg_data=INJECT_VALS(msg_data,arg(3),arg(4),arg(5),arg(6))
          if msg_type = 'W' | msg_type = 'E'
           then
             msg_data_explain = GET_MSG_EXPLAIN(FW,msg_id,msg_data, ,
                                args,arg(3),arg(4),arg(5),arg(6))
          end
        end
      else /* old fashion type  message */
        do
        msg_data = arg(2)
        fashion = "OLD"
        args = arg() - 1
        msg_action = ''
        end
     end

MSG_MESSAGES_TRACE_SESSION=''
 if  ESTIMATE_PUT_ELIGIBILITY(fashion,msg_data) = 1
     then
       do
       TIMESTAMP = DATE('E') substr(TIME('L'),1,12)
       message = TIMESTAMP                                       || ,
                 fw_eye_catcher                                  || ,
                 PFX || right(msg_id,4,0) || msg_type  || ' '    || ,
                 MSG_MESSAGES_TRACE_SESSION                      || ,
                 strip(MSG_2_PRT(fashion,msg_data),'L','.')

       call PUT_MSG_TO_LOG  message , msg_action
       if msg_data_explain <> ''
        then
         do
         message = TIMESTAMP                                       || ,
                   fw_eye_catcher                                  || ,
                   PFX || right(msg_id_ex,4,0) || msg_type || ' '  || ,
                   MSG_MESSAGES_TRACE_SESSION                      || ,
                   strip(MSG_2_PRT(fashion,msg_data_explain),'L','.')
         call PUT_MSG_TO_LOG  message , "EXPL"
         end
       end

 /* stop application if that's required by the message prefix */
 if substr(msg_data,2,2) = "ET"  & fashion = "NEW" & ,
    datatype(substr(msg_data,1,1)) = "NUM"
   then
     do
     /* do HEAP serialization */
     rcode = POST_MAIN(8)
     exit 8
     end
 return 0

/*****************************************************************/
/* Put message to the appropriate log                            */
/* PARM : message                                                */
/*      : message type : action,"A" means print to appl SYSTSPRT */
/*                     : EXPL - exlain message print to SYSEXPRT */
/*****************************************************************/
PUT_MSG_TO_LOG : procedure expose FW
messages.0 = 1
messages.1 = arg(1)
MSG_MESSAGES_TRACE_MODE=BATCH
 /* if ONLINE : it will include FW 3270 + APPL messages */
 if MSG_MESSAGES_TRACE_MODE="ONLINE"
   then
     "EXECIO 1 DISKW TRM3270 ( stem messages.) "
   else
   /* in TSO FG all msgs except 3270                      => SYSTSPRT */
   /* in TSO BG : application msgs (fw=''  & arg(2)<>EXPL => SYSTSPRT */
   /*           : framework   msgs (fw<>'' & arg(2)=A     => SYSTSPRT */
   /*           : framework   msgs (fw<>'' & arg(2)=''    => SYSFWPRT */
   /*           : explanation msgs (arg(2)='EXPL')        => SYSEXPRT */
     if sysvar('SYSENV')  = "FORE"
       then
         say arg(1)
       else
         IF FW = '' & arg(2) <> 'EXPL'
           then
             say arg(1)
           else
             IF FW <> '' & arg(2) = 'A'
               then
                 say arg(1)
               else
                 if fw <> '' & arg(2) = ''
                  then
                    "EXECIO 1 DISKW SYSFWPRT ( stem messages.) "
                  else
                    if arg(2) = "EXPL"
                     then
                       "EXECIO 1 DISKW SYSEXPRT ( stem messages.) "
 return

/*                                                             */
/* returns 1 if the current message should be printed to log   */
/*                                                             */
ESTIMATE_PUT_ELIGIBILITY : procedure
fashion  = arg(1)
msg_data = arg(2)
MSG_MESSAGES_TRACE_LEVEL=3

/* print only those messages which have number of periods */
/* less or equal to  lvl)                                 */
if fashion = "OLD "
  then
    do
    prefix=left(".",MSG_MESSAGES_TRACE_LEVEL,".")
    if prefix <> substr(msg_data,1,MSG_MESSAGES_TRACE_LEVEL) | ,
       (prefix = substr(msg_data,1,MSG_MESSAGES_TRACE_LEVEL) & ,
        substr(msg_data,MSG_MESSAGES_TRACE_LEVEL+1,1) <> "." )
      then
        put_eligibility = 1
      else
        put_eligibility = 0
     end
  else
    do
    if substr(msg_data,1,1) <= MSG_MESSAGES_TRACE_LEVEL
      then
        put_eligibility = 1
      else
        put_eligibility = 0
    if substr(msg_data,2,1) = "W" | substr(msg_data,2,1) = "E"
      then
        put_eligibility = 1
    end
 return put_eligibility
/*                                                             */
/* returns message data to print                               */
/*                                                             */
MSG_2_PRT  : procedure
fashion  = arg(1)
msg_data = arg(2)
if fashion = "OLD"
  then
    return  msg_data
  else
    return  substr(msg_data,5)

/*                                      */
/* returns message from HEAP            */
/* PARM : byte of framework or blank    */
/*        message number                */
/*                                      */
GET_MSG_FROM_HEAP_ELEMENT : procedure expose APPLPFX FWPFX PFX HEAP.
FW      = strip(arg(1))
msg_num = arg(2)
if FW=''
  then
    PFX  = APPLPFX
  else
    PFX  = FWPFX

 call GET_DATA_BY_ELEMENT_NAME_EXT PFX||msg_num
 if STMXDATA.0 = 0
   then
     return ''
   else
     return STMXDATA.1

/*                           */
/* check that inline parms   */
/* number matches free args  */
/* arg1 - msg ID             */
/* arg3 - msg data           */
/* arg4 - free args          */
/*  0 - OK, othee - NOK      */
CHECK_PARMS_SIGNATURE : procedure EXPOSE PFX
ID        = arg(1)
msg_data  = arg(2)
args      = arg(3)
i = 0
do forever
  j = pos("$$P",msg_data)
  if j > 0
    then
      do
      i = i + 1
      msg_data = substr(msg_data,j+2)
      end
  else
    leave
end
if i > args
  then
    do
    return "MSGHNDLR:W Insufficient args for" PFX"."ID ,
           "ARGS="args  "MUST="i
    end
if i < args
  then
    do
    return "MSGHNDLR:W Exceeded args for " PFX"."ID ,
           "ARGS="args  "MUST="i
    end
return 0
/*                                       */
/*   Message handler warnings            */
/*                                       */
PRINT_ARGS_WARNING : procedure
CALL SAY_OK  DATE('E') substr(TIME('L'),1,12) arg(1)
return
/*                                       */
/*   Inject parameter values             */
/*                                       */
/*  parms : 1 messageg data              */
/*          2 $$P1 value                 */
/*          3 $$P2 value                 */
/*          4 $$P3 value                 */
/*          5 $$P4 value                 */
/*                                       */
INJECT_VALS : procedure
  msg_data = arg(1)
  p.1      = arg(2)
  p.2      = arg(3)
  p.3      = arg(4)
  p.4      = arg(5)
  i = 1
  do forever
    j = pos("$$P",msg_data)
    if j > 0
      then
        do
        msg_data = substr(msg_data,1,j-1)  || ,
                   p.i                     || ,
                   substr(msg_data,j+4)
        i = i + 1
        end
      else
        leave
  end
 return msg_data

/***************************************/
/* Create and fill list & map of msgs  */
/* PARM   :  REQUEST APPL or FW        */
/*           PREFIX OF MESSAGE         */
/* RETURN : 0 or 8                     */
/*                                     */
FILL_MSG_STORAGE : procedure expose SPIX. SMRX. HEAP.
request = arg(1)
PFX     = arg(2)
 if request = "APPL"
  then
    do
    listn = "APPLLST"
    mapn  = GET_MAP_NAME(request)
    stem  = "SPIX"
    end
  else
   if request = "FW"
    then
      do
      listn = "FWLST"
      mapn  = GET_MAP_NAME(request)
      stem  = "SMRX"
      end
    else
      return 8

 interpret "arr_size  = "stem".0"
 do i = 1 to arr_size
 interpret "item_data = strip("stem"."i")"
 parse var item_data pfx_data msg_data
 if datatype(pfx_data) <> "NUM"
   then
     do
     if FILL_MSG_LIST(listn,PFX||i,item_data) <> 0
       then
         return 8
     end
   else
     do
     keyname = PFX || strip(pfx_data,'L','0')
     if FILL_MSG_MAP(mapn,keyname,PFX||i,msg_data) <> 0
       then
         return 8
     end
 end
 return 0

/***************************************/
/* Create and fill list of msgs        */
/* PARM   :  LIST name                 */
/*           ELEMENT name              */
/*           MESSAGE data              */
/* RETURN : 0 or 8                     */
/*                                     */
FILL_MSG_LIST : procedure expose HEAP.
LISTN   = arg(1)
ELNAME  = arg(2)
MSGDATA = arg(3)

/* create list for first message */
if IS_LIST_READY_EXT(LISTN) <> 0
 then
   do
    stmxdata.0 = 0
    parse value CLSMNGR("create","list",listn) with retc retref .
    if retc <> 0
      then
        do
        say "LIST" listn "creation failed with RC="retc
        return 8
        end
      else
        do
        CALL SAY_OK "LIST" listn "created successfully,reference="retref
        end
   end

  /* Add message to list */
  stmxdata.NAME = ELNAME
  stmxdata.0 = 1
  stmxdata.1 = MSGDATA
  parse value CLSMNGR("add","list",listn) with retc .
  if retc <> 0
    then
      do
      say "LIST" listn "ADD failed with RC="retc
      return 8
      end
  return 0

/***************************************/
/* Create and fill map of msgs         */
/* PARM   :  MAP name                  */
/*           KEY     name              */
/*           ELEMENT name              */
/*           MESSAGE data              */
/* RETURN : 0 or 8                     */
/*                                     */
FILL_MSG_MAP : procedure expose HEAP.
MAPN    = arg(1)
KEYNAME = arg(2)
ELNAME  = arg(3)
MSGDATA = arg(4)

/* create map for first message */
if IS_MAP_READY_EXT(MAPN) <> 0
 then
   do
    stmxdata.0 = 0
    parse value CLSMNGR("create","map",mapn) with retc retref .
    if retc <> 0
      then
        do
        say "MAP" mapn "creation failed with RC="retc
        return 8
        end
      else
        do
        CALL SAY_OK "MAP" mapn "created successfully,reference="retref
        end
   end
  /*  add item to MAP */
  stmxdata.NAME=ELNAME
  stmxdata.0 = 1
  stmxdata.1 = MSGDATA
  parse value CLSMNGR("add","map",mapn,KEYNAME) with retc .
  if retc <> 0
    then
      do
      say "MAP" mapn "ADD failed with RC="retc
      return 8
      end
 return 0

/***************************************/
/* Return MAP name by request name     */
/* PARM   :  REQUEST name              */
/* RETURN :  MAP name                  */
/*                                     */
GET_MAP_NAME : procedure
if arg(1)  = "APPL"
  then
    return "APPLMAP"
  else
   if arg(1)  = "FW"
     then
        return "FWMAP"
     else
        return ''

/**********************************************************/
/*  This gets explanation message , checks parameter      */
/*  signature and replace the parameters in the message   */
/*  data.  Returns data ready to print                    */
/*  PARM : FRAMEWORK byte                                 */
/*         MSG ID                                         */
/*         MSG DATA                                       */
/*         Number of actual arguments                     */
/*         arguments                                      */
/*   RET : message or ''                                  */
/**********************************************************/
GET_MSG_EXPLAIN : procedure expose PFX msg_id_ex HEAP.
 FW       = arg(1)
 msg_id   = arg(2)
 msg_data = arg(3)
 args     = arg(4)

 if strip(FW) = ''
   then
     request = "APPL"
   else
     request = "FW"

 mapn = GET_MAP_NAME(request)

 keyname = PFX || strip(msg_id,'L','0')
 parse value CLSMNGR("find","map",mapn,keyname) ,
                                     with retc elhash msg_name_ex
 if retc <> 0
   then
     msg_data_explain = ''
   else
     do
     call GET_DATA_BY_ELEMENT_NAME_EXT msg_name_ex
     parse var msg_name_ex (PFX) msg_id_ex .
     msg_data_explain = STMXDATA.1
     end

 if msg_data_explain = ''
   then
    do
    warning = "MSGHNDLR:E for msg <"FW","msg_id">" ,
              "no explanation message found"
    call PRINT_ARGS_WARNING warning
    end
   else
    do
    msg_data_explain = substr(msg_data,1,3) msg_data_explain
    warning = CHECK_PARMS_SIGNATURE(msg_id_ex,msg_data_explain,args)
    if warning <> 0
     then
      do
      call PRINT_ARGS_WARNING warning
      msg_data_explain = ''
      end
     else
      msg_data_explain = ,
          INJECT_VALS(msg_data_explain,arg(5),arg(6),arg(7),arg(8))
    end
return msg_data_explain

/* this is for quiet messaging in 3270 mode */
SAY_OK : procedure
MSG_MESSAGES_TRACE_MODE=BATCH
if MSG_MESSAGES_TRACE_MODE <> "ONLINE"
 then
   SAY ARG(1)
return
/*  TSO FS  interface                                            */
FSMNGR : procedure  expose (alc_parm) fsattr. HEAP.
 ADDRESS TSO
 action=arg(1)
 filename=arg(2)
 model=arg(3)
 attr=arg(3)


 d_action=action
 upper d_action

 call FMSG 33,d_action    /*  __________REQUEST : */
 call FMSG 34,filename    /*  _________FILENAME : */
 call FMSG 35,model       /*  ____________MODEL : */
 call fMSG 36,attr        /*  _____________ATTR : */


 select
   /* query file attributes */
   when action='qfile' then do
                     call FMSG 37,filename    /* query attributes */
                     return exqfile(filename)
                     end
   /* query file specific attribute */
   when action='qfilesattr' then do
                     call FMSG 38,attr        /* query spec attr */
                     return exqfilesattr(filename,attr)
                     end
   /* allocate file with attributes of model */
   when action='alcbymod' then do
                     call FMSG 39,filename     /* alloc by model */
                     return exalcmod(filename,model)
                     end
   /* allocate file with specific attributes */
   when action='alcnfile' then do
                     call FMSG 40,filename    /* allocate new file */
                     return exalcnfile(filename,file_tp,rec_fm)
                     end
   /* check file state */
   when action='qfileste' then do
                     call FMSG 41,filename  /* check file existence */
                     return exqfileste(filename)
                     end
   /* delete file  */
   when action='delfile'  then do
                     call FMSG 42,filename    /* delete file */
                     return exdelfile(filename)
                     end
   otehrwise call FMSG 43  /* parameter selection failed */ ; return -1;
 end

/* query specific attribute of file  */
exqfilesattr : procedure expose fsattr. HEAP.
 if exqfile(arg(1)) <> 0
     then
       return 8
 return FA(arg(2))

/* query file attributes  */
exqfile : procedure expose fsattr. HEAP.
if PIPEMODE() = 1       /* INJECTED FUNCTION */
 then
  do
   rcode=fscmd(                                                       ,
               lpipe() "  listdsi " arg(1) " directory            " ||,
                       "| specs  2-*                              " ||,
                       "| specs ws = w1 1 /=/ n /'/ n w2 n /'/ n  " ||,
                       "| change //fsattr./                       " ||,
                       "| stem rxcmds.                            "   ,
               )
  end
 else
  do
  if fscmd("rc=GET_FILE_ATTRIBUTES("arg(1)")") <> 0
   then
     return 8
  end

 do i = 1 to rxcmds.0
  parse var rxcmds.i  . "."  ndx "=" .
  fsattr.0 = i
  fsattr.i = ndx
  interpret rxcmds.i
 end

 return 0

/* check file existence */
exqfileste: procedure expose action HEAP.
    return fscmd("rc=SYSDSN("arg(1)"); if rc='OK' then rc=0;")

/* allocate file by model */
exalcmod: procedure expose action HEAP.
 if exqfileste(arg(1)) = 0
     then
      return 0

 /* guery model file for all attributes */
 if exqfile(arg(2)) <> 0
     then
       return 8

 return ( g2b(fscmd(                   ,
                    "allocate"         ,
                    "da("arg(1)")"     ,
                     FA(DSORG)         ,
                     FA(SPACE)         ,
                     FA(LRECL)         ,
                     FA(BLKSIZE)       ,
                    "like("arg(2)")"   ,
                    )                  ,
             )                         ,
                                         |,
          g2b(fscmd(                   ,
                    "free"             ,
                    "da("arg(1)")"     ,
                    )                  ,
               )                       ,
        ) * 8


/* allocate new file  */
exalcnfile: procedure expose action (alc_parm) HEAP.
 if exqfileste(arg(1)) = 0
   then
      return 0
 /* strip quotes and double quotes */
 fname = strip(strip(arg(1),,"'"),,'"')
 /* lpipe() "  var fname         " ||,  */
 /*         "| strip anyof X7D7F " ||,  */
 /*         "| var fname         "      */

 /* create model name */
 /* !!! you should change GETMODNM routine to provide  !!! */
 /* !!! your model name for the requested file name    !!! */
 model_name = GETMODNM(fname)
 if model_name = ''
  then
    do
    if pos(pfx_wrk,fname) > 0
        then pfx_env = pfx_wrk
        else pfx_env = pfx_pkg
     parse var fname  .  (parm_ccid) '.'  short_fname
     model_name = pfx_dev || "." || short_fname
    end
 return exalcmod(arg(1),model_name)


/* delete existing file */
exdelfile:  procedure expose action HEAP.
 if exqfileste(arg(1)) = 0
   then
      return fscmd("delete" arg(1) "scratch nonvsam")
   else
      return 0


/* Return DSN attributes                                 */
/* The following mnemonics used in request name :        */
/* 1.SYSxxxx means the field value returned as is        */
/* 2.PROCxxx means the elaborated value is returned      */
/* 3.Otherwise values returned in the format match TSO   */
/*   ALLOCATE command                                    */
/*                                                       */
FA      : procedure expose  fsattr. HEAP.
what = arg(1)
upper what
if what = "BLKSIZE"
  then
    return "blksize("fsattr.SYSBLKSIZE")"

if what = "LRECL"
  then
    return "lrecl("fsattr.SYSLRECL")"

if what = "DSORG"
  then
     return "dsorg("fsattr.SYSDSORG")"

if what = "RECFM"
   then
     do
      rd = "recfm("
      do i = 1 to length(fsattr.SYSRECFM)
       if i = length(fsattr.SYSRECFM)
        then
           dlmtr=")"
        else
           dlmtr=","
       rd = rd || substr(fsattr.SYSRECFM,i,1) || dlmtr
      end
       return rd
     end

if what = "SPACE"
   then
     do
     space_units =  "space("fsattr.SYSPRIMARY","fsattr.SYSSECONDS")" ,
                     fsattr.SYSUNITS
     if fsattr.SYSUNITS = "TRACK" & fsattr.SYSPRIMARY = "1"
       then
          space_units = "space(10,10) cylinders"
     if datatype(fsattr.SYSADIRBLK) <> 'NUM'
        then
          space_dsntype = "dsntype(LIBRARY)"
        else
          space_dsntype  = "dsntype(PDS)"
     return space_units space_dsntype
     end

if what = "PROCDSNTYPE"
   then
     do
     if fsattr.SYSDSORG='PO' & datatype(fsattr.SYSADIRBLK) <> 'NUM'
       then
          return "LIBRARY"
     if fsattr.SYSDSORG='PO' & datatype(fsattr.SYSADIRBLK) = 'NUM'
       then
          return "PDS"
     return fsattr.SYSDSORG
     end

if substr(what,1,3) = "SYS"
   then
     do
     interpret "val=fsattr."what
     return val
     end

return -1


/* execute command with log */
fscmd   : procedure expose fsattr. rxcmds. action HEAP.
 call FMSG 44,'"'arg(1)'"'    /* FSCMD requested */
 if word(arg(1),1) = lpipe()
    then
      do
      b=substr(arg(1),wordindex(arg(1),2))
      lpipe() "var b | runpipe "
      end
    else
      if substr(arg(1),1,3)="rc="
        then
          interpret arg(1)
        else
           interpret '"'arg(1)'"'



 retcode=rc
 if retcode <> 0
      then do
           call fsshowerr left(arg(1),32,' ') , retcode
           return retcode
           end

call FMSG 45            /* FSCMD Retcode=0 */
if action="qfile"
   then
     do
      do i = 1 to rxcmds.0
      interpret rxcmds.i
      end
     end
return 0

fsshowerr : procedure expose HEAP.
/* FSCMD:Failure on CMD=<$$P1>,RC=$$P2 */
call FMSG 46,'"'arg(1)'"','"'arg(2)'"'
return

GET_FILE_ATTRIBUTES : procedure expose fsattr. rxcmds.
fn = arg(1)
 x=listdsi(fn directory)
 rxcmds.1  =  "fsattr.SYSDSNAME='"SYSDSNAME"'"
 rxcmds.2  =  "fsattr.SYSVOLUME='"SYSVOLUME"'"
 rxcmds.3  =  "fsattr.SYSUNIT='"SYSUNIT"'"
 rxcmds.4  =  "fsattr.SYSDSORG='"SYSDSORG"'"
 rxcmds.5  =  "fsattr.SYSRECFM='"SYSRECFM"'"
 rxcmds.6  =  "fsattr.SYSLRECL='"SYSLRECL"'"
 rxcmds.7  =  "fsattr.SYSBLKSIZE='"SYSBLKSIZE"'"
 rxcmds.8  =  "fsattr.SYSKEYLEN='"SYSKEYLEN"'"
 rxcmds.9  =  "fsattr.SYSALLOC='"SYSALLOC"'"
 rxcmds.10 =  "fsattr.SYSUSED='"SYSUSED"'"
 rxcmds.11 =  "fsattr.SYSPRIMARY='"SYSPRIMARY"'"
 rxcmds.12 =  "fsattr.SYSSECONDS='"SYSSECONDS"'"
 rxcmds.13 =  "fsattr.SYSUNITS='"SYSUNITS"'"
 rxcmds.14 =  "fsattr.SYSEXTENTS='"SYSEXTENTS"'"
 rxcmds.15 =  "fsattr.SYSCREATE='"SYSCREATE"'"
 rxcmds.16 =  "fsattr.SYSREFDATE='"SYSREFDATE"'"
 rxcmds.17 =  "fsattr.SYSEXDATE='"SYSEXDATE"'"
 rxcmds.18 =  "fsattr.SYSPASSWORD='"SYSPASSWORD"'"
 rxcmds.19 =  "fsattr.SYSRACFA='"SYSRACFA"'"
 rxcmds.20 =  "fsattr.SYSUPDATED='"SYSUPDATED"'"
 rxcmds.21 =  "fsattr.SYSTRKSCYL='"SYSTRKSCYL"'"
 rxcmds.22 =  "fsattr.SYSBLKSTRK='"SYSBLKSTRK"'"
 rxcmds.23 =  "fsattr.SYSADIRBLK='"SYSADIRBLK"'"
 rxcmds.24 =  "fsattr.SYSUDIRBLK='"SYSUDIRBLK"'"
 rxcmds.25 =  "fsattr.SYSMEMBERS='"SYSMEMBERS"'"
 rxcmds.26 =  "fsattr.SYSREASON='"SYSREASON"'"
 rxcmds.0  = 26
 return 0

/***********************************************/
/* provides message interface with a variable  */
/* number of arguments. Suitable with injector */
/***********************************************/
FMSG : procedure expose HEAP.
fw_pfx = 'F'
l = arg()
parms  = '("'fw_pfx'",'
do i = 1 to l
if i = l
  then finc = ")"
  else finc = ","
p = arg(i)
if strip(p) = ''
  then
    p = "'"p"'"
parms = parms || p || finc
end
function="MSG"
interpret "rc="function||parms
return

/*********************************************/
/* provides model name for a filename passed */
/* in arg(1)                                 */
/*********************************************/
GETMODNM : procedure expose HEAP.
/*  if arg(1) = ????       */
/*    then return  !!!!    */
return ''
/*  ISPF LM interface with library                               */
LMMNGR : procedure  expose member. memstat. HEAP.
 action = arg(1)
 lib    = arg(2)
 libto  = arg(3)
 item   = arg(4)

 d_action = action
 upper d_action

 call LMSG 47,d_action     /*   __________REQUEST : */
 call LMSG 48,lib          /*   _________LIB FROM : */
 call LMSG 49,libto        /*   ___________LIB TO : */
 call LMSG 50,item         /*   _____________ITEM : */


 select
   when action='reclen'    then do;enq="SHR";    opt="INPUT";  end
   when action='memlist'   then do;enq="SHR";    opt="INPUT";  end
   when action='memread'   then do;enq="SHR";    opt="INPUT";  end
   when action='memadd'    then do;enq="SHRW";   opt="INPUT";  end
   when action='memupd'    then do;enq="SHRW";   opt="INPUT";  end
   when action='movemem'   then do;enq="SHR";    opt="INPUT";  end
   when action='copymem'   then do;enq="SHR";    opt="INPUT";  end
   when action='copymemnr' then do;enq="SHR";    opt="INPUT";  end
   when action='delonem'   then do;enq="EXCLU";  opt="OUTPUT"; end
   when action='delallm'   then do;enq="EXCLU";  opt="OUTPUT"; end
   when action='eraselib'  then do;enq="EXCLU";  opt="OUTPUT"; end
   when action='compress'  then do;enq="EXCLU";  opt="OUTPUT"; end
   otehrwise call LMSG 51  /* Parameter selection failed */; return -1;
 end

 ISPEXEC "CONTROL ERRORS RETURN"

 ADDRESS ISPEXEC

 if libcmd("lminit dataid(ccid) dataset('"lib"') ENQ(&enq)") <> 0
    then
       return 8

 if action <> 'compress'
   then  do
         if libcmd("lmopen  dataid(&ccid) option(&opt)") <> 0
            then do
                 call libcmd("lmfree  dataid(&ccid)")
                 return 8
                 end
         end

 select
    when action='reclen'
     then do
          reclen=right('0'x,8,'0'x)
          data=qreclen(reclen)
          end

    when action='memlist'
     then do
          data=exmemlist()
          end

    when action='memread'
     then do
          data=exmemread(item)
          end

    when action='memadd'
     then do
          data=exmemact(item,"add")
          end

    when action='memupd'
     then do
          data=exmemact(item,"rep")
          end

    when action='movemem'
     then
       do
       if libcmd("lminit dataid(ccidto) dataset('"libto"') ENQ(SHR)")<>0
         then do
              call libcmd("lmclose dataid(&ccid)")
              call libcmd("lmfree  dataid(&ccid)")
              return 8
              end
       data=exmove(item)
       call libcmd("lmfree  dataid(&ccidto)")
       end

    when action='copymem'
     then
       do
       if libcmd("lminit dataid(ccidto) dataset('"libto"') ENQ(SHR)")<>0
         then do
              call libcmd("lmclose dataid(&ccid)")
              call libcmd("lmfree  dataid(&ccid)")
              return 8
              end
       data=excopy(item)
       call libcmd("lmfree  dataid(&ccidto)")
       end
    when action='copymemnr'
     then
       do
       if libcmd("lminit dataid(ccidto) dataset('"libto"') ENQ(SHR)")<>0
         then do
              call libcmd("lmclose dataid(&ccid)")
              call libcmd("lmfree  dataid(&ccid)")
              return 8
              end
       data=excopynr(item)
       call libcmd("lmfree  dataid(&ccidto)")
       end

    when action='delonem'
     then do
          data=exdelonem(item)
          end

    when action='delallm'
     then do
          data=exdelallm()
          end

    when action='eraselib'
     then do
          data=exeraselib(lib)
          end

    when action='compress'
     then do
          data=excompress()
          end

    otehrwise  call LMSG 52  /* Function selection failed' */; return -1
 end

 if action <> 'compress'
   then
     call libcmd("lmclose dataid(&ccid)")

 call libcmd("lmfree  dataid(&ccid)")

 return data

/**********************************************/
/*     R O U T I N E S                        */
/**********************************************/

exmemlist : procedure expose ccid memstat. HEAP.
 memname = ' '
 i = 0
 memstat.0 = 0
 do forever
 "lmmlist DATAID(&ccid) option(LIST) member(memname) stats(YES)"
 if rc = 0
   then
     do
     i = i + 1
     memstat.i = memname ZLC4DATE ZLM4DATE substr(ZLUSER,1,8)
     memstat.0 = i
     end
   else
     leave
 end
 return 0


exmemread : procedure expose ccid  member. HEAP.
  mem = arg(1)
  i = 0
  member.0 = 0
  retcode=libcmd("lmmfind DATAID(&ccid) member("mem") stats(YES)")
  if retcode  <> 0
    then
      return 8

  call LMSG 53   /* Some trace records suppressed for LMGET OP */
  do forever
  retcode = libcmd("lmget dataid(&ccid) mode(invar)"                   ,
                   "dataloc(recdata) datalen(reclen) maxlen(800)")

  if retcode = 8 /* EOD ? */
    then
     return 0

  if retcode <> 0
    then
      return retcode
     else
      do
      i = i + 1
      member.i = recdata
      member.0 = i
      end
  end

 return 0  /* unreachable !!!  */


exmemact: procedure expose ccid  member. ZERRMSG ZERRLM ZERRSM HEAP.
if (member.0 > 0)
  then
    do
     retcode=libcmd("lmmfind DATAID(&ccid) member("arg(1)") stats(YES)")
     if retcode <> 0 & arg(2) = "rep"
       then
        return retcode

     if retcode =  0 & arg(2) = "add"
      then
       do
       call LMSG 54,arg(1) /* EXMEMACT : Member found. Add failed */
       return 8
       end

     call LMSG 55  /* EXMEMACT : reopen target library for OUTPUT */
     call libcmd("lmclose dataid(&ccid)")
     if libcmd("lmopen  dataid(&ccid) option(OUTPUT)") <> 0
       then do
            call libcmd("lmfree  dataid(&ccid)")
            return 8
            end

     reclen=right('0'x,8,'0'x)
     recl=qreclen(reclen)

     call LMSG 56  /* Some trace records suppressed for LMPUT OP */
     do i = 1 to member.0
     line=member.i
      rc=libcmd("lmput DATAID(&ccid) mode(invar) DATALOC(line) "  ||,
                "DATALEN("recl")" )
      if rc <> 0
        then
          return rc
     end
     if (strip(ZLCDATE) = '') | arg(2) = "add"
       then do
            ZLCDATE=date('o')
            end
     ZLMDATE=date('o')
     ZLMTIME=time()
     ZLUSER=userid()
     ZLCNORC=member.0
     rc=libcmd("lmm"arg(2) "dataid(&ccid) member("arg(1)") stats(YES)")
     return rc
    end
 return 8

exmove  : procedure expose ccid ccidto                         ,
                    ZERRMSG ZERRLM ZERRSM HEAP.
     rc=libcmd("lmmfind DATAID(&ccid) member("arg(1)")")
     if rc <> 0
       then
          return rc

      rc=libcmd("lmmove FROMID("ccid") FROMMEM("arg(1)")       "  ||,
                "TODATAID("ccidto") REPLACE " )

     return rc
/* copy replace */
excopy  : procedure expose ccid ccidto                          ,
                    ZERRMSG ZERRLM ZERRSM HEAP.
     rc=libcmd("lmmfind DATAID(&ccid) member("arg(1)")")
     if rc <> 0
       then
          return rc

      call LMSG 57,arg(1) /* EXCOPY: member is being added/replaced */
      rc=libcmd("lmcopy FROMID("ccid") FROMMEM("arg(1)")       "  ||,
                "TODATAID("ccidto") REPLACE " )

     return rc

/* copy no replace */
excopynr: procedure expose ccid ccidto opt                      ,
                    ZERRMSG ZERRLM ZERRSM HEAP.
     rc=libcmd("lmmfind DATAID(&ccid) member("arg(1)")")
     /* check the member exists in FROM library */
     if rc <> 0
       then
          return rc

     /* open TO library                               */
     if libcmd("lmopen  dataid(&ccidto) option(&opt)") <> 0
         then do
               call libcmd("lmfree  dataid(&ccidto)")
               return 8
               end
     /* check the member does not exist in TO library */
     retc=libcmd("lmmfind DATAID(&ccidto) member("arg(1)")")
     call libcmd("lmclose dataid(&ccidto)")
     if retc = 0
       then
          do
          call LMSG 58,arg(1) /* EXCOPYNR: member is not replaced */
          return 0 /* exists . do not override it */
          end

      call LMSG 59,arg(1) /* EXCOPYNR: member is being added */
      rc=libcmd("lmcopy FROMID("ccid") FROMMEM("arg(1)")       "  ||,
                "TODATAID("ccidto")" )

     return rc
qreclen : procedure expose ccid ZERRMSG ZERRLM ZERRSM HEAP.
    reclen = libcmd("lmquery dataid(&ccid) LRECL(reclen)",'reclen')
    return  reclen

exdelonem : procedure expose ccid ZERRMSG ZERRLM ZERRSM HEAP.
    return libcmd("lmmdel dataid(&ccid) member("arg(1)") noenq")

exdelallm : procedure expose ccid ZERRMSG ZERRLM ZERRSM HEAP.
    return libcmd("lmmdel dataid(&ccid) member(*) noenq")

exeraselib : procedure expose ccid ZERRMSG ZERRLM ZERRSM HEAP.
    return libcmd("lmerase dataset('"arg(1)"')")

excompress : procedure expose ccid ZERRMSG ZERRLM ZERRSM HEAP.
    return libcmd("lmcomp dataid(&ccid)")

/************************************************************/
/*   U T I L I T I E S                                      */
/************************************************************/
libcmd  : procedure expose ccid ccidto enq opt line recdata reclen     ,
          ZERRMSG ZERRLM ZLCDATE ZLMDATE ZLMTIME ZLUSER ZLCNORC ZERRSM ,
          memname HEAP.

lmcmd  = word(arg(1),1)
UPPER lmcmd

if  lmcmd <> 'LMPUT' & lmcmd <> 'LMGET'
  then
    call LMSG 60,'"'arg(1)'"' /* Executing request */

 interpret "'"arg(1)"'"
 retcode=rc

 if retcode = 8 & lmcmd = 'LMGET' /* EOD ? */
   then
     return 8

 if retcode  <> 0
  then
    do
    call lmshowerr lmcmd , retcode
    return retcode
    end

if  lmcmd <> 'LMPUT' & lmcmd <> 'LMGET'
  then
    call LMSG 61  /* lmcmd completed with RC=0 */

 if (arg(2) <> '')    /* RECLEN */
   then
     do
     outdata=arg(2)
     interpret 'return' outdata
     end
   else
     return 0

lmshowerr : procedure expose ZERRMSG ZERRLM ZERRSM HEAP.
call LMSG 62,arg(1),arg(2)         /* request completed with code */
call LMSG 63,arg(1),ZERRMSG,ZERRSM /* request error messages */
return

/***********************************************/
/* provides message interface with a variable  */
/* number of arguments. Suitable with injector */
/***********************************************/
LMSG : procedure expose HEAP.
fw_pfx = 'L'
l = arg()
parms  = '("'fw_pfx'",'
do i = 1 to l
if i = l
  then finc = ")"
  else finc = ","
p = arg(i)
if strip(p) = ''
  then
    p = "'"p"'"
parms = parms || p || finc
end
function="MSG"
interpret "rc="function||parms
return
/*  TSO Common functions collection                          */

/********************************************************/
/* trace stem content                                   */
/********************************************************/
TRACE_STEM : procedure  expose HEAP.                                 ,
                              stmjob. jesout.

MODE = "TRACE"
ILEN=14
HLEN=ILEN+10
stem = arg(1)
obj_ref = arg(2)
interpret "loop_bndry="stem".0"
if translate(stem)  = "HEAP"
  then
    do    /* HEAP object */
    VLEN = HLEN
    lena = 0
    if symbol('HEAP.0') <> "LIT"
     then
       do
       if obj_ref <> ''
         then
           do
           /* trace of HEAP item by reference */
           call CMSG 2,arg(2)
           objhash = GET_HASH_BY_REFERENCE(obj_ref)
           call HEAP_DETAIL objhash
           return
           end
         else
           do
           /* Trace of whole HEAP */
           call CMSG 3
           end
       end
    end   /* HEAP object */
  else
    do   /* just stem */
    VLEN = ILEN
    lena = length(arg(1))+1
    end  /* just stem */

if datatype(loop_bndry)="NUM"
  then
   do                             /* normalized stem */
    interpret "cnt="stem".0"
    call PATH_DETAIL left(stem'.0',VLEN+lena,' '),strip(cnt,'trailing')
    do j = 1 to  loop_bndry       /* loop over stem structure */
    interpret "el="stem"."j
    call PATH_DETAIL left(stem'.'j,VLEN+lena,' '),strip(el,'trailing')
    el_ndx=stem"."el".0"
    if datatype(el,'S') = 1
     then
      do
      interpret "el_ndx="el_ndx
      if symbol(stem'.'el) = "LIT" & datatype(el_ndx,'S') <> 1
        then
          iterate
        else
          if datatype(el_ndx) <> "NUM"
           then
             iterate
      end
     else
      iterate

    if translate(stem)  = "HEAP"
      then
        do
        if length(el) > 8
          then
            do   /* reference */
            path = el
            path_o = "HEAP." || path
            interpret "val = " path_o
            call PATH_DETAIL path_o,val
            iterate
            end  /* reference */
          else
            do
            clsname = word(HEAP.el,2)
            el      = clsname"_"el
            end
        end

    interpret  "sst_len="stem"."el".0"
    if datatype(sst_len)="NUM"    /* normalized 2nd level */
      then
         do
           call PATH_DETAIL stem"."left(el'.0',VLEN,' '),sst_len
           do k = 1 to sst_len
           interpret "sst_el="stem"."el"."k
           call PATH_DETAIL stem"."left(el'.'k,VLEN,' '),sst_el
           end
         end
      else
         do                     /* not normalized 2nd level */
          if translate(stem) <> "HEAP"
            then
              do
               interpret  "stm_val="stem"."el
               call PATH_DETAIL stem"."left(el,VLEN,' '),stm_val
               iterate
              end

         parse upper var el clsname "_"  objhash  .
         call HEAP_DETAIL objhash
         end                    /* not normalized 2nd level */
    end /* loop over stem structure */
   end /* normalized stem */
return


/********************************************************/
/* TRACE/GC/SRLZ HEAP item content                      */
/********************************************************/
HEAP_DETAIL: procedure expose HLEN MODE FILE_TO_PERSIST                ,
                       SRLZ_REC SRLZ_FLAG HEAP.                        ,
                       hash_lstfields stm_lstfields                    ,
                       hash_objfields stm_objfields                    ,
                       hash_elmfields stm_elmfields                    ,
                       hash_mapfields stm_mapfields                    ,
                              stmjob. jesout.

/* For HEAP trace only               */
if symbol('HEAP.0') = "LIT"
  then
    return

/* do not allow detail entrance for serialization  */
if MODE = "SRLZ" & symbol('SRLZ_FLAG') = "LIT"
  then
    return
drop SRLZ_FLAG

if symbol('hash_lstfields') = "LIT"
  then      /* set control variables from HEAP */
   do
   hash_lstfields = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#LSTFIELDS")
   stm_lstfields  = "HEAP."hash_lstfields
   hash_objfields = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#OBJFIELDS")
   stm_objfields  = "HEAP."hash_objfields
   hash_elmfields = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#ELMFIELDS")
   stm_elmfields  = "HEAP."hash_elmfields
   hash_mapfields = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#MAPFIELDS")
   stm_mapfields  = "HEAP."hash_mapfields
   end

  objhash          = arg(1)

  if MODE = "SRLZ"
   then
     do
     /* put header for hash or anchor for reference */
     call PATH_DETAIL "HEAP."objhash , HEAP.objhash
     if length(objhash) > 8  /* REFERENCE ? */
       then
        return
     end

  clsname          = GET_CLSNAME_BY_HEADER(HEAP.objhash)
  object_reference = GET_REFERENCE_BY_HEADER(HEAP.objhash)
  objname          = GET_NAME_BY_HEADER(HEAP.objhash)
  if objhash <> '' & object_referennce = ''
    then
      do
      /* Heap reference not found */
      call CMSG 1,arg(2)
      return
      end

  if clsname  = "LIST"
    then
     do /* LIST */
     /* loop through the list fields and trace them */
     interpret "first  = HEAP." || objhash || "_FIRST"

     /* detail all elements of list */
     next =  first
      do while next <> ''         /* loop over linked list */
       /* Heap ELEMENT */
       call CMSG 4,"LIST ELEMENT"
       /* loop through the list elements */
       elhash = GET_INSTANCE_BY_HEADER(next)
       interpret "next = HEAP." || elhash || "_NEXT"
       call HEAP_DETAIL elhash
      end                         /* loop over linked list */

     /* remove list hash from index  */
     call HEAP_UPDATE_INDEX_AND_STATS objhash

     /* loop through the list fields */
     /* Heap LIST */
     call CMSG 4,"LIST"
     path = objhash
     interpret "loop_bndry_lst = "stm_lstfields".0"
       do l = 1 to loop_bndry_lst
       interpret "tmp_lstfields = "stm_lstfields"."l
       parse var tmp_lstfields trailer value .
       path_o = "HEAP." || path  || "_" || trailer
       if trailer = "<HEAD>"
         then
           do
           interpret "val = HEAP."path
           path_o = "<"path_o
           end
          else
            do
            if value = "<clslist"
              then
                do
                val = clsname
                path_o = "<"path_o
                end
              else
                interpret "val = " path_o
           end
       call PATH_DETAIL path_o,val
       end
     end /* LIST */
    else
     if clsname  = "MAP"
      then
        do /* MAP */
        /* Heap MAP */
        call CMSG 4,"MAP"

        /* loop through the MAP fields and trace them */
        path_m = objhash
        interpret "size_arr = HEAP."path_m"_SIZE"
        do  i = 1 to size_arr  /* loop over map internal stem */
        interpret "map_index = HEAP."path_m"_"i
        path_o = "HEAP."path_m"_"i
        call PATH_DETAIL path_o,map_index
        path_o = "HEAP."path_m"_"map_index
        interpret "map_data = HEAP."path_m"_"map_index
        call PATH_DETAIL path_o,map_data
        elhash = word(map_data,2)
        /* Heap ELEMENT */
        call CMSG 4,"MAP ELEMENT"
        call HEAP_DETAIL elhash
        end                    /* loop over map internal stem */

        /* remove map hash from index  */
        call HEAP_UPDATE_INDEX_AND_STATS objhash

        interpret "loop_bndry_map = "stm_mapfields".0"
          do l = 1 to loop_bndry_map
          interpret "tmp_mapfields = "stm_mapfields"."l
          parse var tmp_mapfields trailer value .
          path_o = "HEAP." || path_m || "_" || trailer
          if trailer = "<HEAD>"
            then
              do
              interpret "val = HEAP."path_m
              path_o = "<"path_o
              end
             else
               do
               if value = "<clsmap"
                 then
                   do
                   val = clsname
                   path_o = "<"path_o
                   end
                 else
                   interpret "val = " path_o
              end
          call PATH_DETAIL path_o,val
          end
        end /* MAP */
      else
       if clsname  = "ELEMENT"
        then
          do  /* ELEMENT */
          /* remove element hash from index  */
          call HEAP_UPDATE_INDEX_AND_STATS objhash
          path   = objhash

          interpret "loop_bndry = HEAP."path".0"
          call PATH_DETAIL "HEAP."path".0",loop_bndry
           do k = 1 to loop_bndry
           interpret "#value=HEAP."path".k"
           call PATH_DETAIL "HEAP."path"."k,#value
           end

          /* get type of SUPER Container */
          interpret "ref_super = HEAP."path"_SUPER"
          hdr  = GET_HEADER_BY_REFERENCE(ref_super)
          clsn = GET_CLSNAME_BY_HEADER(hdr)
          interpret "loop_bndry_elm = "stm_elmfields".0"
            do l = 1 to loop_bndry_elm
            interpret "tmp_elmfields = "stm_elmfields"."l
            parse var tmp_elmfields trailer value .
            path_o = "HEAP." || path  || "_" || trailer
            if trailer = "<HEAD>"
              then
                do
                interpret "val = HEAP."path
                path_o = "<"path_o
                end
               else
                do
                if value = "<clsel"
                 then
                   do
                   interpret "hdr = HEAP."path
                   val = GET_CLSNAME_BY_HEADER(hdr)
                   path_o = "<"path_o
                   end
                 else
                  if (clsn = "LIST" & (trailer = "NEXT" |    ,
                      trailer = "PREV"))                    |,
                     (trailer <> "NEXT" & trailer <> "PREV")
                     then
                       interpret "val = " path_o
                     else
                       val = ''
                end
            call PATH_DETAIL path_o,val
            end
          end /* ELEMENT */
        else
         do   /* OBJECT */
         /* remove object hash from index  */
         call HEAP_UPDATE_INDEX_AND_STATS objhash
         path   = objhash
         /* Heap Object */
         call CMSG 4,"OBJECT"
         interpret "loop_bndry = HEAP."path".0"
         call PATH_DETAIL "HEAP."path".0",loop_bndry
         do k = 1 to loop_bndry
         interpret "#value=HEAP."path".k"
         call PATH_DETAIL "HEAP."path"."k,#value
         end

         interpret "loop_bndry_obj = "stm_objfields".0"
         do l = 1 to loop_bndry_obj
         interpret "tmp_objfields = "stm_objfields"."l
         parse var tmp_objfields trailer value .
         path_o = "HEAP." || path  || "_" || trailer
         if trailer = "<HEAD> "
           then
             do
             interpret "val = HEAP."path
             path_o = "<"path_o
             end
            else
              do
              if substr(value,1,1) = "<"
                then
                  do
                  interpret "val = " clsname
                  path_o = "<"path_o
                  end
                else
                  interpret "val = " path_o
             end
         call PATH_DETAIL path_o,val
         end
        end /* OBJECT */
 return

/**********************************************************************/
/*     TRACE/GC/SRLZ PATH with VALUE                                  */
/**********************************************************************/
HEAP_UPDATE_INDEX_AND_STATS: procedure expose MODE HEAP.
objhash = arg(1)
objname = GET_REFERENCE_BY_HEADER(HEAP.objhash)
clsname = GET_CLSNAME_BY_HEADER(HEAP.objhash)
 if MODE = "GC"
   then
      do
      if clsname = "ELEMENT"
        then
          do
          interpret "ref_super = HEAP."objhash"_SUPER"
          super_hash = GET_HEAP_HASH_FOR_REFERENCE(ref_super)
          super_clsname = GET_CLSNAME_BY_HEADER(HEAP.super_hash)
          pseudo_rtn = super_clsname || "_DELETE"
          call EXTRACT_DATA_TO_STEM objhash
          rc = COLLECT_STATISTICS(pseudo_rtn)
          end
      if clsname <> "LIST" & clsname <> "MAP" & clsname <> "ELEMENT"
        then
          do /* OBJECT */
          pseudo_rtn = "OBJECT_DESTROY"
          call EXTRACT_DATA_TO_STEM objhash
          rc = COLLECT_STATISTICS(pseudo_rtn)
          end
      /* remove object hash and object reference from HEAP index */
      index_hash     = GET_HEAP_INDEX_BY_HEADER(HEAP.objhash)
      object_reference = GET_REFERENCE_BY_HEADER(HEAP.objhash)
      call REMOVE_HASH_FROM_HEAP_INDEX  objhash   index_hash
      index_ref        = GET_HEAP_INDEX_FOR_REFERENCE(object_reference)
      call REMOVE_HASH_FROM_HEAP_INDEX  object_reference index_ref
      call HMSG "....GC freed object" objhash "name" objname          ,
                "class" clsname
      end
 return

/**********************************************************************/
/*     Extract data from Element or Object to STMXDATA                */
/*     PARM : hash                                                    */
/**********************************************************************/
EXTRACT_DATA_TO_STEM : procedure expose STMXDATA. HEAP.
path = arg(1)
interpret "loop_bndry = HEAP."path".0"
 do k = 0 to loop_bndry
 interpret "STMXDATA."k "= HEAP."path"."k
 end
return
/**********************************************************************/
/*     TRACE/GC/SRLZ PATH with VALUE                                  */
/**********************************************************************/
PATH_DETAIL : procedure expose MODE HLEN FILE_TO_PERSIST SRLZ_REC HEAP.
 path = arg(1)
 val  = arg(2)
 if MODE = "TRACE"
   then
     do
     if substr(path,1,1) = "<"
      then
       path  =  substr(path,2)
     /* < > virtual field */
     /* real field, but not for print */
     if val = ''
       then
         return
     if substr(path,1,5) = "HEAP."
       then
        RC=MSG("....."left(path,HLEN,' ')":"val)
       else
        RC=MSG("....."path":"val)
     end
   else
    if MODE = "SRLZ"
     then
       do
       if substr(path,1,1) = "<"
        then
         return
       SRLZ_REC = SRLZ_REC + 1
       record.0 = 1
       record.1 = path||'="'||val||'"'
       if symbol('FILE_TO_PERSIST') = "LIT" | FILE_TO_PERSIST = ''
         then
          say record.1
         else
          do
          "EXECIO 1 DISKW" FILE_TO_PERSIST "(STEM record."
          end
       end
     else
      if MODE = "GC"
       then
         do
         if substr(path,1,1) = "<"
          then
           return
         drop (path)
         end
 return

/**********************************************************************/
/*     evaluate existence of a library member : 0-true , <>0 - false  */
/**********************************************************************/
EXISTM : procedure expose fspc fdir vspc vdir uspc udir HEAP.
  retcode  = FSMNGR("qfileste","'"arg(1)"("arg(2)")'")
  /* Check lib member existence  */
  call CMSG 5,arg(1),arg(2),retcode
  return retcode

/**********************************************************************/
/*     State file existence                                           */
/**********************************************************************/
DOSTATE : procedure expose HEAP.
  retcode = FSMNGR('qfileste',"'"arg(1)"'")
  /* Check file existence */
  call CMSG 6,arg(1),retcode
  return retcode

/**********************************************************************/
/*     Allocate file by name                                          */
/**********************************************************************/
DOALLOC : procedure expose  parm_ccid pfx_dev pfx_wrk pfx_pkg HEAP.
  alc_parm = 'parm_ccid pfx_dev pfx_wrk pfx_pkg'
  retcode =  FSMNGR('alcnfile',"'"arg(1)"'")
  /* Allocate file */
  call CMSG 7,arg(1),retcode
  return retcode

/**********************************************************************/
/*     Delete file by name                                            */
/**********************************************************************/
DODEL   : procedure expose HEAP.
  retcode =  FSMNGR('delfile',"'"arg(1)"'")
  /* Delete existing file */
  call CMSG 8,arg(1),retcode
  return retcode

/**********************************************************************/
/*     Query specific file attribute                                  */
/* arg1=file arg2=attribute name                                      */
/**********************************************************************/
QSATTR  : procedure expose HEAP.
  retcode = FSMNGR('qfilesattr',arg(1),arg(2))
  /* query file attribute */
  call CMSG 9,arg(1),arg(2),retcode
  return retcode

/**********************************************************************/
/*     Get library member list                                        */
/* arg1=lib                                                           */
/**********************************************************************/
LIBMLIST  : procedure expose  memstat. HEAP.
  retcode = LMMNGR('memlist',arg(1))
  /* Get library member */
  call CMSG 10,arg(1),retcode
  return retcode

/**********************************************************************/
/*     READ a member from library                                     */
/*  arg1=lib  arg2=member                                             */
/**********************************************************************/
LIBMREAD : procedure expose  member. HEAP.
  retcode = LMMNGR('memread',arg(1),0,arg(2))
  /* Read member from library */
  call CMSG 11,arg(1),arg(2),retcode
  return retcode

/**********************************************************************/
/*     Move a library member to another library                       */
/*  arg1=from , arg2=to, arg3=member                                  */
/**********************************************************************/
LIBMMEM: procedure expose HEAP.
  retcode =  LMMNGR('movemem',arg(1),arg(2),arg(3))
  /* Move member to other lib */
  call CMSG 12,arg(1),arg(2),arg(3),retcode
  return retcode

/**********************************************************************/
/*     Copy a library member to another library with REPLACE          */
/*  arg1=from , arg2=to, arg3=member                                  */
/**********************************************************************/
LIBCMEM: procedure expose HEAP.
  retcode = LMMNGR('copymem',arg(1),arg(2),arg(3))
  /* CopyRepl member */
  call CMSG 13,arg(1),arg(2),arg(3),retcode
  return retcode

/**********************************************************************/
/*     Copy a library member to another library no REPLACE            */
/*  arg1=from , arg2=to, arg3=member                                  */
/**********************************************************************/
LIBCMEMNR: procedure expose HEAP.
  retcode =  LMMNGR('copymemnr',arg(1),arg(2),arg(3))
  /* CopyNoRepl member */
  call CMSG 14,arg(1),arg(2),arg(3),retcode
  return retcode

/**********************************************************************/
/*     Delete a library member                                        */
/*  arg1=lib  , arg2=member                                           */
/**********************************************************************/
LIBDMEM: procedure expose HEAP.
  retcode = LMMNGR('delonem',arg(1),0,arg(2))
  /* Delete library member */
  call CMSG 15,arg(1),arg(2),retcode
  return retcode

/**********************************************************************/
/*     Erase  a library                                               */
/*  arg1=lib                                                          */
/**********************************************************************/
LIBERASE: procedure expose HEAP.
  retcode = LMMNGR('eraselib',arg(1))
  /* Erase library */
  call CMSG 16,arg(1),retcode
  return retcode

/**********************************************************************/
/*     ADD a member to library                                        */
/*  arg1=lib  arg2=member                                             */
/**********************************************************************/
LIBAMEM: procedure expose  member. HEAP.
  retcode = LMMNGR('memadd',arg(1),0,arg(2))
  /* Add member to lib */
  call CMSG 17,arg(1),arg(2),retcode
  return retcode

/**********************************************************************/
/*     Update a library member                                        */
/*  arg1=lib  arg2=member                                             */
/**********************************************************************/
LIBUMEM: procedure expose  member. HEAP.
  retcode =  LMMNGR('memupd',arg(1),' ',arg(2))
  /* Update library member */
  call CMSG 18,arg(1),arg(2),retcode
  return retcode

/**********************************************************************/
/*     Delete all library members                                     */
/*  arg1=lib                                                          */
/**********************************************************************/
LIBDALL: procedure expose HEAP.
  retcode =  LMMNGR('delallm',arg(1))
  /* Delete all library members */
  call CMSG 19,arg(1),retcode
  return retcode

/**********************************************************************/
/*     Compress library                                               */
/*  arg1=lib                                                          */
/**********************************************************************/
LIBCOMPR: procedure expose HEAP.
  retcode = LMMNGR('compress',arg(1))
  /* Compress library */
  call CMSG 20,arg(1),retcode
  return retcode


/**********************************************************************/
/*     Floor                                                          */
/**********************************************************************/
FLOOR: procedure expose HEAP.
parse arg F
return TRUNC(F) - (F < 0) * (F <> TRUNC(F))

/**********************************************************************/
/*     Ceiling                                                        */
/**********************************************************************/
CEILING: procedure expose HEAP.
parse arg C
return TRUNC(C) + (C > 0) * (C <> TRUNC(C))

/**********************************************************************/
/*  this routine converts numeric values to boolean values            */
/**********************************************************************/
g2b   : procedure
if arg(1) = 0
   then return (1<0)
   else return (0<1)

/****************************************************/
/*  Routine compares reply with a string            */
/*  Capital letter means mandatory character        */
/*  Letter  means not mandatory but right character */
/*  Returns 0 if compared, 1 if not compared        */
/****************************************************/
COMPARE_REPLY : procedure expose HEAP.
rpl = arg(1)
str = arg(2)
upper_number = 0
if length(rpl) > 0
  then
   do
    do i = 1 to length(str)
    if datatype(substr(str,i,1),'U') = 1
     then
       do
       upper_number = upper_number + 1
       if translate(substr(rpl,i,1)) = substr(str,i,1)
        then
          iterate /* compared, check next char of rpl */
        else
          return 1 /* appropriate rpl and str chars not compared */
       end
     else
       leave
    end
    if upper_number > 0
     then
       return 0   /* str has U chars compared */
     else
       return 1   /* no U chars in str */
  end
 else
  return 1   /* rpl is empty */
return 0

/***********************************************/
/* provides message interface with a variable  */
/* number of arguments. Suitable with injector */
/***********************************************/
CMSG : procedure expose MODE HEAP.
/* allow MSG for COMMON routines and TRACE mode of HEAP */
if symbol('MODE') <> "LIT" & MODE <> "TRACE"
  then
    return

fw_pfx = 'C'
l = arg()
parms  = '("'fw_pfx'",'
do i = 1 to l
if i = l
  then finc = ")"
  else finc = ","
p = '"'strip(arg(i))'"'
parms = parms || p || finc
end
function="MSG"
interpret "rc="function||parms
return
/* TODO LIST  :                                     */
/*  12.03.2019                                      */
/* LOW level :                                      */
/* 1.heap self-initialization.                    + */
/* 2.allow no-named lists , element and objects   + */
/*   use HEAP #||hash as the name in this case      */
/* 3.Add LIST functionality - INSERT, DELETE, SORT, */
/*            etc.                                  */
/* 4.add search by reference                      + */
/* 5.add LIST iterator & OPEN, NEXT , PREV          */
/* 6.add TRACE item by reference - LIST,          + */
/*       ELEMENT, OBJECT                            */
/* HIGH level :                                     */
/* 1.add providers support                          */
/* 2.add temporary LIST support for :               */
/*  - keeping results                               */
/*  - subsequent processsing                        */
/* 3.add temp LIST GC by request and automatic      */
/* 4.write provider with DB2                        */
/* 5.Provide collecting results from temp LIST :    */
/*  - by iteration                                  */
/*  - by pipe "stem st.Function(parms)              */
/* 6.Provide function of RETRIEVE STMXDATA. to a    */
/*           stem                                   */
/* INJECTOR :                                       */
/*  - inject <List-name>_ methods                   */
/*  - Consider HMSG messages of HEAP                */
/*  - Consider <LAMBDA> functionality               */
/*     1. Tags                                      */
/*     2. Internal heap routine - find              */
/*        foreach , etc                             */
/*     3. Have API to work with hashes as well      */
/*  Create PPT of the HEAP logic  & routines        */
/*  04.03.2020                                      */
/*  External APIs , without MSG requests            */
/*  1. Get list element by name                     */
/*  2. Query HEAP allocated                         */
/*  3. Query HEAP readiness                         */
/*  4. External getter/setter                       */
/*                                                  */


CLSMNGR : procedure expose HEAP. STMXDATA.
action   = translate(NORMALIZE_NAME(arg(1)))
clsname  = translate(NORMALIZE_NAME(arg(2)))
objname  = translate(NORMALIZE_NAME(arg(3)))
parm1val = translate(NORMALIZE_NAME(arg(4)))
parm2val = translate(NORMALIZE_NAME(arg(5)))

/* care of #INTERNAL List - 1st external call HEAP API */
if GET_HEAP_HASH_FOR_REFERENCE("NAME_LST_#INTERNAL") = '' & ,
   objname <> "#INTERNAL"                                 & ,
   objname <> "#SERVICES"
  then
    /* self HEAP initializing */
    if HEAPINIT() <> 0
      then
       return 8

/* If HEAP initialization completed and external HEAP API CALL */
if GET_HEAP_HASH_FOR_REFERENCE("NAME_LST_#INTERNAL") <> '' & ,
   objname <> "#INTERNAL"                                  & ,
   objname <> "#SERVICES"
    then
      do
       if length(action) > 8
         then
           do
           call HMSG ".Length of ACTION may not be greater than 8",
                action
           return 8
           end
       if length(clsname) > 8
         then
           do
           call HMSG ".Length of CLASS NAME may not be greater than 8",
                clsname
           return 8
           end
       if length(objname) > 8  &  substr(objname,1,1) <> '#'
         then
           do
           call HMSG ".Length of OBJECT NAME may not be greater than 8",
                objname
           return 8
           end
       if  length(objname) > 0  & substr(objname,1,1) = '#'
         then
           do
           call HMSG ".OBJECT NAME may not start with #" ,
                objname
           return 8
           end
       if  datatype(clsname) = 'NUM' | datatype(objname)= 'NUM'
         then
           do
           call HMSG ".CLASS and OBJECT may not be numeric" ,
                clsname objname
           return 8
           end
      end

/* take care of no-name objects */
if objname = ''
  then
    objname = '#'


RTN=GET_ROUTINE_NAME(clsname,action,objname)
if RTN = ''
    then
      do
      call HMSG ".Invalid request detected"
      return 8
      end

/***********************************************************/
/*    L I S T / E L E M E N T / S E R V I C E  CONTROL     */
/***********************************************************/
if clsname = "LIST"
  then
     return HEAP_RTN(RTN,objname,clsname,parm1val,parm2val)

if clsname = "MAP"
  then
     do
     if  datatype(parm1val) = 'NUM'
       then
         do
         call HMSG ".KEYNAME for MAP may not be numeric" ,
              parm1val
         return 8
         end
     return HEAP_RTN(RTN,objname,clsname,parm1val)
     end

if clsname = "SERVICE"
  then
     return HEAP_RTN(RTN,objname)

if clsname = "VARIABLE"
  then
     return HEAP_RTN(RTN,objname,parm1val)

/***********************************************************/
/*    O B J E C T       C O N T R O L S                    */
/***********************************************************/
if action = "CREATE"
  then
     do
     object_reference = GET_ITEM_REFERENCE(clsname,objname)
     if objname <> '#' & CHECK_HASH(object_reference) = 1
       then
         do
         call HMSG ".....OBJECT" objname "already exists"
         return 8
         end


     objhash  = GET_HASH()

     /* allow no named object  */
     if objname = '#'
       then
         do
         objname = '#' || objhash
         list_reference = GET_ITEM_REFERENCE(clsname,objname)
         end

     HEAP.objhash  = objhash clsname

     path_o   = objhash
     interpret "HEAP."path_o"_NAME="object_reference
     if datatype(STMXDATA.0) = "NUM"
      then
        do
         do i = 0 to STMXDATA.0
         interpret "HEAP."path_o"."i"="STMXDATA.I
         end
       end


     if ADD_HASH(object_reference,objhash) <> 0
       then
          return 8

     call HMSG "...CLSFW: object hash:"objhash "added"
     return  HEAP_RTN(RTN,objname,clsname) object_reference
     end

if action = "DESTROY"
  then
     do
     object_reference = GET_ITEM_REFERENCE(clsname,objname)
     objhash = GET_HASH_BY_REFERENCE(object_reference)
     parse value GETOBJ(objhash) with rc objname clsname
     if rc <> 0
       then
         do
         call HMSG ".CLSFW:object hash:"objhash "not found"
         return 8
         end
     rc = HEAP_RTN(RTN,objname,clsname)
     if rc = 0
       then
         do
         /* delete object only if physical deletion was successful */
         CALL GC objhash
         call HMSG "...CLSFW:object hash:"objhash "deleted"
         end
     return rc object_reference
     end

if action = "QUERY"
  then
     do
     object_reference = GET_ITEM_REFERENCE(clsname,objname)
     objhash = GET_HASH_BY_REFERENCE(object_reference)
     parse value GETOBJ(objhash) with rc objname clsname
     if rc <> 0
       then
         do
         call HMSG ".CLSFW:object hash:"objhash "not found"
         return 8
         end
     call HMSG "...CLSFW:object hash:"objhash "extracted"
     if datatype(HEAP.objhash.0) = "NUM"
      then
        do
         do i = 0 to HEAP.objhash.0
         interpret "STMXDATA."i" = HEAP."objhash"."i
         end
       end
     return  HEAP_RTN(RTN,objname,clsname) object_reference
     end

return  rc


/**********************************************/
/* S U B R O U T I N E S                      */
/**********************************************/
/*  Execute request                          **/
/*  PARM : routine name                      **/
/*       : objname                           **/
/*       : clsname                           **/
/*       : parm1val                          **/
/*       : parm2val                          **/
/*  RET  : 0 or 8                            **/
/**********************************************/
HEAP_RTN : procedure expose STMXDATA. HEAP.
 rtn     = arg(1)
 obj     = arg(2)
 clsname = arg(3)
 v1      = arg(4)
 v2      = arg(5)

 interpret "rcode="rtn"("obj","clsname","v1","v2")"
 if word(rcode,1) <> 0
  then
    return rcode

 if obj = "#INTERNAL"  & translate(STMXDATA.NAME)="#LSTANCHOR"
   then
     return rcode

 parse var rtn cls "_" .

 if cls <> "LIST" & cls <> "MAP" & cls <> "ELEMENT" & cls <> "VARIABLE"
  then
   do
   cls = "OBJECT"
   parse var rtn . "_" action .
   rtn = cls"_"action
   end

 /* filtering those requests that already came from GC with STMXDATA */
 if rtn = "LIST_DELETE" | rtn = "MAP_DELETE" | rtn = "OBJECT_DESTROY"
   then
     return rcode

 rc = COLLECT_STATISTICS(rtn)
 return rcode

/*********************************************************/
/*  Collect statistics                                  **/
/*  PARM : routine name                                 **/
/*  RET  : 0                                            **/
/*********************************************************/
/* It gains control from :                              **/
/* 1. Command processor after CREATE/ADD request OR     **/
/* 2. From GC before the HEAP object DESTROY/DELETE     **/
/*                                                      **/
/* The command ORDER is built by HPCMD , where :        **/
/* +/- mean add or free resource (lists,elements,etc.)  **/
/* L,E,M,V,O - list,element,map,variable,object         **/
/* It aslo may be 3d symbol in order meaning the super  **/
/* container of the element                             **/
/* Examples :                                           **/
/* Create list: +L                                      **/
/* Destroy map: -M                                      **/
/* Delete  map element: -EM                             **/
/* Create list with elemrnt : +L +EL   Two orders !!!   **/
/*                                                      **/
/* HPITM contains size of each type in serialized form, **/
/* i.e. how many lines needed                           **/
/*                                                      **/
/* VARs recalculated each time from scratch while other **/
/* types use increment/decrement logic.                 **/
/* VARs number initial value is -1, since when the 1st  **/
/* VAR is created , the VAR anchor is created too.      **/
/* For statistics report -1 means 0.                    **/
/*                                                      **/
/* Elements and objects are followed by STMXDATA to let **/
/* calculate the needed memory used                     **/
/*                                                      **/
/* Calculations of memory and disk space :              **/
/* TN - number of metadata lines                        **/
/* IN - number of user data lines (of STMXDATA entries) **/
/* DN - use data size                                   **/
/* TN+IN is the size of serialized HEAP                 **/
/*                                                      **/
/*********************************************************/
COLLECT_STATISTICS : procedure expose STMXDATA. HEAP.
 rtn = arg(1)
 hash_lstanchor = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#LSTANCHOR")
 interpret "stats = HEAP."hash_lstanchor".2"

 if strip(stats) = ''
   then
     do
     say "Internal HEAP error 1024 in Get Statistics"
     exit 1024
     end

 /* stat primary : L 1 M 0 O 0 E 1 V 0 T 9 I 3 D 100 S 1 */
 parse var stats "L" ln "M" mn "O" on "E" en "V" vn           ,
                 "T" tn "I" in "D" dn "S" sp .

 HPCMD.LIST_CREATE    =  "+L"
 HPCMD.LIST_DESTROY   =  "-L"
 HPCMD.LIST_ADD       =  "+EL"
 HPCMD.LIST_INSERT    =  "+EL"
 HPCMD.LIST_DELETE    =  "-EL"
 HPCMD.MAP_CREATE     =  "+M"
 HPCMD.MAP_DESTROY    =  "-M"
 HPCMD.MAP_ADD        =  "+EM"
 HPCMD.MAP_DELETE     =  "-EM"
 HPCMD.ELEMENT_DELETE =  "-E"
 HPCMD.ELEMENT_ADD    =  "+E"
 HPCMD.VARIABLE_SET   =  "+V"
 HPCMD.VARIABLE_DEL   =  "-V"
 HPCMD.OBJECT_CREATE  =  "+O"
 HPCMD.OBJECT_DESTROY =  "-O"

 /* Each element contains number of lines serializing the heap object.*/
 /* HEAP.index for hash, HEAP.index for reference, HEAP.reference are */
 /* considered as well                                                */

 HPITM.L              =  9
 HPITM.M              =  7
 HPITM.E              =  9
 HPITM.V              =  1
 HPITM.O              =  6
 t_len = 40       /* title lparm len , T and t_len together */
 d_len = 25       /* data  lparm len , I and D together */
 /* create order sequence */
 interpret "OS = HPCMD."rtn
 if substr(OS,1,5) = "HPCMD"
  then
    return 0
 if datatype(STMXDATA.0) = "NUM" & STMXDATA.0 > 0   &     ,
    (OS = "+L" | OS = "+M")
    then
      OS  = OS "+E"||substr(OS,2,1)

 /* loop over orders */
 do i = 1 to words(OS)
 order = word(OS,i)
 interpret "hi_size = HPITM."substr(order,2,1)   /* heap item lines # */
 stat_field = substr(order,2,1) || "n"
 interpret "stat_sign = "substr(order,1,1) || "1"
 /* calculations */
 interpret  stat_field "=" stat_field "+" stat_sign * 1
 if substr(order,2,1) <> "V"
   then
     tn = tn + stat_sign * hi_size         /* update title items */
   else
     do /* variables */
     /* restore "at entrance" value of VN */
     interpret  stat_field "=" stat_field "-" stat_sign * 1
     path = "VAR_GLOBAL"
     /* update VAR size */
     interpret "vn_new = HEAP."path".0"
     if vn = -1
       then
         tn = tn + hi_size + 2 * vn_new
       else
         tn = tn + 2 * (vn_new - vn)
     vn = vn_new
     end  /* variables */
 if substr(order,2,1) = "E" | substr(order,2,1) = "O"
   then
     do
     parse value ESTIMATE_DATA_AMOUNT() with items data .
     in = in + stat_sign * items        /* data items */
     dn = dn + stat_sign * data
     end
 if substr(order,3,1) = "M"
   then
     do
     tn = tn + stat_sign * 2
     end
 end

/* calculate number of traks needed to serialize HEAP */
sp_wrk = (tn * t_len + in * d_len + dn) * 1.15 / 55996 + 1
parse var sp_wrk sp "." .
sp = sp + 1

stats  =  "L" strip(ln) "M" strip(mn) "O" strip(on)  "E" strip(en) ,
          "V" strip(vn) "T" strip(tn) "I" strip(in)  "D" strip(dn) ,
          "S" strip(sp)
/* update sttistics */
interpret "HEAP."hash_lstanchor".2='"stats"'"

 return 0
/**********************************************/
/* returns number of data items and data size */
/**********************************************/
ESTIMATE_DATA_AMOUNT : procedure expose order STMXDATA.
 if substr(order,1,1) = '+'
   then
    do
    data = 0
    items = 0
    /* data = length(STMXDATA.NAME) */
    /* items = 1                    */
    end
   else
    do
    data = 0
    items = 0
    end

 if datatype(STMXDATA.0) <> "NUM"
   then
     do
     say "SUMRX: INTERNAL ERROR found in ESTIMATE_DATA:"order STMXDATA.0
     return 0 0
     end

 do i = 0 to STMXDATA.0
 data = data + length(STMXDATA.i)
 end

 items = STMXDATA.0 + 1 + items
 return items data

/**********************************************/
/* returns routine's name for request & class */
/**********************************************/
GET_ROUTINE_NAME : procedure expose HEAP.
 clsname  = arg(1)
 action   = arg(2)
 objname  = arg(3)

 if clsname = "LIST" & (objname = "#INTERNAL" | objname = "#SERVICES")
    then
      return "LIST_"action

 if clsname = "LIST"
    then
      do
      if FIND_ACTION_IN_STEM("lstrtnact",action) = 0
       then
        do
        call HMSG ".LIST action" action "is invalid"
        return ''
        end
       else
        return TRANSLATE(clsname"_"action)
      end

 if clsname = "MAP"
    then
      do
      if FIND_ACTION_IN_STEM("maprtnact",action) = 0
       then
        do
        call HMSG ".MAP action" action "is invalid"
        return ''
        end
       else
        return TRANSLATE(clsname"_"action)
      end

 if clsname = "SERVICE"
    then
      do
      if FIND_ACTION_IN_STEM("srvrtnact",action) = 0
       then
         do
         call HMSG ".SERVICE action" action "is invalid"
         return ''
         end
       else
         return TRANSLATE(clsname"_"action)
      end

 if clsname = "VARIABLE"
    then
      do
      if  FIND_ACTION_IN_STEM("varrtnact",action) = 0
       then
        do
        call HMSG ".VARIABLE action" action "is invalid"
        return ''
        end
       else
         return TRANSLATE(clsname"_"action)
      end

 if FIND_ACTION_IN_STEM("objrtnact",action) = 0
    then
      do
      call HMSG ".OBJECT action" action "is invalid"
      return ''
      end
     else
      return TRANSLATE(clsname"_"action)

/**********************************************/
/* returns index of element in stem           */
/**********************************************/
FIND_ACTION_IN_STEM : procedure expose HEAP.

hash = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#"translate(arg(1)))
element = arg(2)
stemname = "HEAP."hash
interpret "loop_bndry = "stemname".0"
do i = 1 to loop_bndry
interpret "val = "stemname"."i
if element = val
  then
    return i
end
return 0


/* ===========================================================  */
/* ==   V A R I A B L E    METHODS                          ==  */
/* ===========================================================  */

/* ===========================================================  */
/* ==   V A R I A B L E    S E T T E R                      ==  */
/* ==   PARMS : variable name                               ==  */
/* ==         : variable value                              ==  */
/* ==  RETURN : 0 - OK , 8 - NOK                            ==  */
/* ===========================================================  */
VARIABLE_SET : procedure expose HEAP.
if HEAP.0 = 0  | symbol('HEAP.0') = "LIT"
 then
   return 8
var_name   = arg(1)
var_value  = arg(2)
path = "VAR_GLOBAL"
var_path = path || "_" || var_name
if symbol('HEAP.'var_path) = "LIT"
  then
    do         /* the variable is not in use yet */
    if symbol('HEAP.'path'.0') = "LIT"
       then
         do   /* no yet variables */
         interpret "HEAP."path".0 = 0"
         end
    interpret "ndx = 1 + HEAP."path".0"
    interpret "HEAP."path".0 =" ndx
    interpret "HEAP."path"."ndx "=" var_name
    interpret "HEAP."var_path "=" ndx var_value
    end
  else
    do         /* the variable is in use  */
    interpret "temp = HEAP."var_path
    parse var temp ndx .
    interpret "HEAP."var_path "=" ndx var_value
    end
return  0

/* ===========================================================  */
/* ==   V A R I A B L E    G E T T E R                      ==  */
/* ==   PARMS : variable name                               ==  */
/* ==   RET   : "0 variable_value" or 8 if not found        ==  */
/* ===========================================================  */
VARIABLE_GET : procedure expose HEAP.
var_name   = arg(1)

path = "VAR_GLOBAL"
var_path = path || "_" || var_name
if HEAP.0 = 0  | symbol('HEAP.'var_path) = "LIT"
 then
   return 8
 else
   do
   interpret "val = HEAP."var_path
   parse var val . var_value
   return '0' var_value
   end

/* ===========================================================  */
/* ==   V A R I A B L E    D E L E T E                      ==  */
/* ==   PARMS : variable name                               ==  */
/* ==   RET   : 0 or 8 (variable not found)                 ==  */
/* ===========================================================  */
VARIABLE_DEL : procedure expose HEAP.
var_name   = arg(1)

path = "VAR_GLOBAL"
var_path = path || "_" || var_name
if symbol('HEAP.'var_path) = "LIT"
 then
   return 8
 else
   do
   interpret "deleted_val = HEAP."var_path
   /* get back index of deleted value */
   parse var deleted_val ndx .

   /* delete variable reference */
   path_v = "HEAP."var_path
   drop (path_v)

   interpret "array_len = HEAP."path".0"
   /* shrink array  */
   interpret "HEAP."path".0 = " array_len - 1
   if array_len <>  ndx
     then
       do  /* delete not last in array - replace it with the last */
       /* change back reference in the replacing element */
       interpret "last_el = HEAP."path"."array_len
       parse var last_el .  last_el_value
       interpret "HEAP."path"."ndx "= HEAP."path"."array_len
       interpret "last_ref = HEAP."path"."ndx
       interpret "HEAP."last_ref "=" ndx last_el_value
       end
   /* delete last array element index */
   path_l = "HEAP."path"."array_len
   drop (path_l)
   return 0
   end

/* ===========================================================  */
/* ==   V A R I A B L E    L I S T                          ==  */
/* ==   PARMS :                                             ==  */
/* ==   RET   : STMXDATA.tem with names and values          ==  */
/* ===========================================================  */
VARIABLE_LIST : procedure expose HEAP. STMXDATA.
 path = "VAR_GLOBAL"
 interpret "var_count = HEAP."path".0"
 if symbol('HEAP.'path'.0') = "LIT"
   then
     stmxdata.0 = 0
   else
     do
     interpret "loop_bndry = HEAP."path".0"
     if loop_bndry > 0
       then
        do
         stmxdata.0 = loop_bndry
         do i = 1  to loop_bndry
         interpret "var_ref   = HEAP."path"."i
         interpret "var_data  = HEAP."path"_"var_ref
         parse var var_data . var_value
         stmxdata.i = var_ref var_value
         end
        end
     end
 return 0
/* ===========================================================  */
/* ==   L I S T / E L E M E N T       METHODS               ==  */
/* ===========================================================  */
/* ===========================================================  */
/* == CREATE   : can ceate an empty list or list with element   */
/* == STMXDATA : is a normalized stem containing the element    */
/* ===========================================================  */

/* ===========================================================  */
/* ==   C R E A T E    LIST                                 ==  */
/* ===========================================================  */
LIST_CREATE : procedure expose STMXDATA. HEAP.
     objname  = arg(1)
     clsname  = arg(2)

     list_reference = GET_ITEM_REFERENCE(clsname,objname)
     if objname <> '#' &  CHECK_HASH(list_reference) = 1
       then
         do
         call HMSG ".L_CREATE: LIST" objname "already exists"
         return 8
         end

     objhash  = GET_HASH()
     /* allow no named list */
     if objname = '#'
       then
         do
         objname = '#' || objhash
         list_reference = GET_ITEM_REFERENCE(clsname,objname)
         end

     HEAP.objhash  = objhash "LIST"

     if ADD_HASH(list_reference,objhash) <> 0
       then
          return 8

     path_l   = objhash
     interpret "HEAP."path_l"_NAME="list_reference
     interpret "HEAP."path_l"_SORTED=NO"
     interpret "HEAP."path_l"_FIRST=''"
     interpret "HEAP."path_l"_LAST=''"
     call HMSG ".....LIST" objname "created, hash" objhash

     if datatype(STMXDATA.0) <> "NUM" | STMXDATA.0 = 0
     then
       return "0" list_reference

     call HMSG ".....L_CREATE: Adding element to LIST" objname
     STMXDATA.NAME = NORMALIZE_NAME(STMXDATA.NAME)


     return "0" list_reference LIST_ADD(objname,clsname)

/* ===========================================================  */
/* == ADD,INSERT,DELETE,EXHANGE : operations on LIST        ==  */
/* == STMXDATA :is a normalized stem containing the element == */
/* ===========================================================  */

/* ===========================================================  */
/* ==   A D D  E L E M E N T  T O   L I S T                 ==  */
/* ==   PARMS :                                             ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ===========================================================  */
LIST_ADD    : procedure expose HEAP. STMXDATA.

 if SET_ELEMENT_TO_LIST("ADD",arg(1),arg(2)) <> 0
   then
     return 8

 return "0" element_reference

/* ===========================================================  */
/* ==  I N S E R T  E L E M E N T  T O   L I S T  A F T E R ==  */
/* ==   PARMS :                                             ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ==         reference of element  "after"                 ==  */
/* ==              0 - insert before first, 1 - insert last ==  */
/* ===========================================================  */
LIST_INSERT : procedure expose HEAP. STMXDATA.
/* it tries to replace INSERT by ADD :                  */
/* 1. when the list is empty                            */
/* 2. when it's requested to INSERT after LAST ELEMENT  */
/* 3. when it's requested to INSERT TO THE END          */

 objname  = arg(1)
 clsname  = arg(2)
 eltoref  = arg(3)

 action = "INSERT"

 eltohash = GET_HEAP_HASH_FOR_REFERENCE(eltoref)

 if eltoref <> 0 & eltoref <> 1
  then
   do
   if IS_ELEMENT_VALID("INSERT",objname,clsname,eltoref) <> 1
     then
       return 8

    parse value FIND_LIST(objname,clsname) with rc_find objhash    ,
                                                 list_reference
    interpret "last_el  = HEAP."objhash"_LAST"
    if GET_INSTANCE_BY_HEADER(last_el) = eltohash
       then
        do
        eltohash = 0
        action = "ADD"
        end
   end
  else
   do
   eltohash = eltoref
   if IS_LIST_EMPTY(objname,clsname) = 1
    then
      do
      eltohash = 0
      action = "ADD"
      end
   end


 if SET_ELEMENT_TO_LIST(action,objname,clsname,eltohash) <> 0
   then
     return 8

 return "0" element_reference

/* ===========================================================  */
/* ==  D E L E T E  E L E M E N T  F R O M   L I S T        ==  */
/* ==   PARMS :                                             ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ==         reference of element to delete                ==  */
/* ===========================================================  */
LIST_DELETE : procedure expose HEAP.

 objname  = arg(1)
 clsname  = arg(2)
 elref    = arg(3)

 if IS_ELEMENT_VALID("DELETE",objname,clsname,elref) <> 1
     then
       return 8

 elhash = GET_HEAP_HASH_FOR_REFERENCE(elref)
 if REMOVE_ELEMENT_FROM_LIST(objname,clsname,elhash) <> 0
   then
     return 8

 return  0
/* ============================================================= */
/* == E X C H A N G E  T W O  E L E M E N T S  I N  L I S T   == */
/* == Assumed that element #1 is closer to the head of list   == */
/* ==   PARMS :                                               == */
/* ==   when  ARG(5)=''                                       == */
/* ==         list name                                       == */
/* ==         class name                                      == */
/* ==         reference of element #1                         == */
/* ==         reference of element #2                         == */
/* ==   when  ARG(5)<>''                                      == */
/* ==         list hash                                       == */
/* ==         class name                                      == */
/* ==         hash of element #1                              == */
/* ==         hash of element #2                              == */
/* ============================================================= */
LIST_EXCHANGE : procedure expose HEAP.
 if arg(5) = ''
  then
   do   /* call from API */
    call HMSG "......LIST_EXCHANGE API requested"
    objname   = arg(1)
    clsname   = arg(2)
    el1ref    = arg(3)
    el2ref    = arg(4)

    if el1ref  =  el2ref
     then
      do
      call HMSG "...Attempt to self exchange element ,reference="el1ref
      return 0
      end

    if IS_ELEMENT_VALID("EXCH-1",objname,clsname,el1ref) <> 1
     then
       return 8

    if IS_ELEMENT_VALID("EXCH-2",objname,clsname,el2ref) <> 1
     then
      return 8

    parse value FIND_LIST(objname,clsname) with rc_find objhash    ,
                                                list_reference
    if rc_find <> 0
     then
      return 8
    el1hash = GET_HEAP_HASH_FOR_REFERENCE(el1ref)
    el2hash = GET_HEAP_HASH_FOR_REFERENCE(el2ref)
   end   /* call from API */
  else
   do   /* internal call */
    call HMSG "......LIST_EXCHANGE INTERNAL requested for hashes"   ,
                              arg(3) arg(4)
    objhash   = arg(1)
    clsname   = arg(2)
    el1hash   = arg(3)
    el2hash   = arg(4)
   end  /* internal call */

 path_l  = objhash

 exch_el_neighbors = EXCHANGED_ELEMENTS_NEIGHBORS(el1hash,el2hash)
 /* not neighbors or 1st element is closer to head of list */
 if exch_el_neighbors = 1  | exch_el_neighbors = 0
   then
     do
     left_hash   = el1hash
     right_hash  = el2hash
     end
   else
     do
     left_hash   = el2hash
     right_hash  = el1hash
     end

 interpret "left_prev   = HEAP."left_hash"_PREV"
 if left_prev   = ''
  then
    left_prev_next_path   = "HEAP."path_l"_FIRST"
  else
    do
    interpret "left_prev_header = HEAP."left_hash"_PREV"
    left_prev_hash   = GET_INSTANCE_BY_HEADER(left_prev_header)
    left_prev_next_path   = "HEAP."left_prev_hash"_NEXT"
    end
 interpret "left_next   = HEAP."left_hash"_NEXT"
 if left_next   = ''
  then
    left_next_prev_path   = "HEAP."path_l"_LAST"
  else
    do
    interpret "left_next_header = HEAP."left_hash"_NEXT"
    left_next_hash   = GET_INSTANCE_BY_HEADER(left_next_header)
    left_next_prev_path   = "HEAP."left_next_hash"_PREV"
    end

 interpret "right_prev = HEAP."right_hash"_PREV"
 if right_prev = ''
  then
    right_prev_next_path = "HEAP."path_l"_FIRST"
  else
    do
    interpret "right_prev_header = HEAP."right_hash"_PREV"
    right_prev_hash = GET_INSTANCE_BY_HEADER(right_prev_header)
    right_prev_next_path = "HEAP."right_prev_hash"_NEXT"
    end
 interpret "right_next = HEAP."right_hash"_NEXT"
 if right_next = ''
  then
    right_next_prev_path = "HEAP."path_l"_LAST"
  else
    do
    interpret "right_next_header = HEAP."right_hash"_NEXT"
    right_next_hash = GET_INSTANCE_BY_HEADER(right_next_header)
    right_next_prev_path = "HEAP."right_next_hash"_PREV"
    end

 interpret "temp_left_prev_path = HEAP."left_hash"_PREV"
 interpret "temp_left_next_path = HEAP."left_hash"_NEXT"
 if exch_el_neighbors = 0
  then
    do
    /*  set links between exchange  elements */
    interpret "HEAP."left_hash"_PREV = HEAP."right_hash"_PREV"
    interpret "HEAP."left_hash"_NEXT = HEAP."right_hash"_NEXT"
    interpret "HEAP."right_hash"_PREV = temp_left_prev_path"
    interpret "HEAP."right_hash"_NEXT = temp_left_next_path"
    /*  set links of exchanges elements to-from the list */
    interpret  left_prev_next_path    "= HEAP."right_hash
    interpret  left_next_prev_path    "= HEAP."right_hash
    interpret  right_prev_next_path   "= HEAP."left_hash
    interpret  right_next_prev_path   "= HEAP."left_hash
    end
  else
    do
    /*  set links between exchange  elements */
    interpret "HEAP."left_hash"_PREV = HEAP."right_hash
    interpret "HEAP."left_hash"_NEXT = HEAP."right_hash"_NEXT"
    interpret "HEAP."right_hash"_PREV = temp_left_prev_path"
    interpret "HEAP."right_hash"_NEXT = HEAP."left_hash
    /*  set links of exchanges elements to-from the list */
    interpret  left_prev_next_path    "= HEAP."right_hash
    interpret  right_next_prev_path   "= HEAP."left_hash
    end

 return  0
                                                                       c
/* ===========================================================  */
/* == S O R T  L I S T                                      ==  */
/* ==   PARMS :                                             ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ===========================================================  */
LIST_SORT  : procedure expose HEAP.
 objname   = arg(1)
 clsname   = arg(2)
 parse value FIND_LIST(objname,clsname) with rc_find objhash    ,
                                             list_reference
 if rc_find <> 0
   then
     return 8

 first_el_hash   = LIST_FIRST_ELEMENT(objhash)
 last_el_hash    = LIST_LAST_ELEMENT(objhash)
 if first_el_hash   = last_el_hash
    then
      return 0

 call HMSG "....=== SORT list" objname "started"
 main_loop_last_el = LIST_LAST_ELEMENT(objhash)
 do forever    /* main */
 sub_loop_curr_el  = LIST_FIRST_ELEMENT(objhash)
 sub_loop_next_el  = LIST_NEXT_ELEMENT(sub_loop_curr_el)
 call HMSG "......:ML_LAST"                                   ,
              GET_REFERENCE_BY_HEADER(HEAP.main_loop_last_el) ,
              "hash" main_loop_last_el
  do forever   /* sub */
  call HMSG "......-SL_CURR"                                           ,
              GET_REFERENCE_BY_HEADER(HEAP.sub_loop_curr_el)           ,
              "hash" sub_loop_curr_el
  call HMSG "......-SL_NEXT"                                           ,
              GET_REFERENCE_BY_HEADER(HEAP.sub_loop_next_el)           ,
              "hash" sub_loop_next_el
  compare_result=LIST_COMPARE(objname,sub_loop_curr_el,sub_loop_next_el)
  if compare_result = 1
    then
      do
      /* standard LIST EXCHANGE API with valisity check               */
      /* if LIST_EXCHANGE(objname, clsname  ,                       , */
      /*        GET_REFERENCE_BY_HEADER(HEAP.sub_loop_curr_el),     , */
      /*        GET_REFERENCE_BY_HEADER(HEAP.sub_loop_next_el) ) <> 0 */

      /* fast exchange with no validity check.This is internal call   */
      if LIST_EXCHANGE(objhash,clsname,                                ,
                        sub_loop_curr_el,sub_loop_next_el,'.') <> 0
        then
          return 8
      /* scope shrunk implicitly when exchanging !!!               */
      if LIST_ELEMENTS_EQUAL(LIST_PREV_ELEMENT(sub_loop_curr_el),   ,
                         main_loop_last_el) = 1
         then
          leave
      end
    else
     if compare_result = 0
      then
        do
        sub_loop_curr_el = sub_loop_next_el
        if LIST_ELEMENTS_EQUAL(sub_loop_curr_el,                      ,
                           main_loop_last_el) = 1
           then
            do
            /* shrink scope explicitly                            */
            main_loop_last_el = LIST_PREV_ELEMENT(main_loop_last_el)
            leave
            end
        end
      else
        return 8

  sub_loop_next_el= LIST_NEXT_ELEMENT(sub_loop_curr_el)
  call HMSG "......+SL_CURR"                                           ,
            GET_REFERENCE_BY_HEADER(HEAP.sub_loop_curr_el)             ,
            "hash" sub_loop_curr_el
  call HMSG "......+SL_NEXT"                                           ,
            GET_REFERENCE_BY_HEADER(HEAP.sub_loop_next_el)             ,
            "hash" sub_loop_next_el
  call HMSG "......+ML_LAST"                                           ,
            GET_REFERENCE_BY_HEADER(HEAP.main_loop_last_el)            ,
            "hash" main_loop_last_el
  end           /* sub */
 if LIST_ELEMENTS_EQUAL(main_loop_last_el,             ,
                        LIST_FIRST_ELEMENT(objhash)) = 1
   then
     leave
 end            /* main */
 call HMSG "....=== SORT list" objname "completed"
return 0

/* ===========================================================  */
/* == E X C H A N G E D  E L E M E N T S  N E I G H B O R S ==  */
/* ==   PARMS :                                             ==  */
/* ==         first element hash                            ==  */
/* ==         second element hash                           ==  */
/* ==  RETURNc :                                            ==  */
/* ==         0  -  not neighbors                           ==  */
/* ==         1  -  1st element is closer to the list head  ==  */
/* ==        -1  -  2nd element is closer to the list head  ==  */
/* ===========================================================  */
EXCHANGED_ELEMENTS_NEIGHBORS : procedure expose HEAP.
 el1hash =  arg(1)
 el2hash =  arg(2)
 interpret "first_next_header = HEAP."el1hash"_NEXT"
 interpret "first_prev_header = HEAP."el1hash"_PREV"
 if GET_INSTANCE_BY_HEADER(first_next_header) = el2hash
   then
     return 1
 if GET_INSTANCE_BY_HEADER(first_prev_header) = el2hash
   then
     return -1
 return 0

/* ===========================================================  */
/* ==  S E T  E L E M E N T  T O   L I S T                  ==  */
/* ===========================================================  */
SET_ELEMENT_TO_LIST: procedure expose HEAP. STMXDATA. element_reference

 action    = arg(1)
 objname   = arg(2)
 clsname   = arg(3)
 eltohash  = arg(4)


 parse value FIND_LIST(objname,clsname) with rc_find objhash    ,
                                             list_reference
 parse value PREPARE_ELEMENT() with rc_prep element_reference elhash .
 if rc_find <> 0 | rc_prep <> 0
   then
     return 8

 path_l    = objhash
 path_e    = elhash
 path_elto = eltohash

 HEAP.elhash = elhash "ELEMENT"

 /* set element reference                       */
 interpret "HEAP."path_e"_NAME="element_reference
 if ADD_HASH(element_reference,elhash) <> 0
   then
      return 8

 /* set linked list name to the element */
 interpret "HEAP."path_e"_SUPER="list_reference

 if action = "INSERT"
   then
     do
     if path_elto = 0
       then
         do   /*  will be first in the list */
         prev_next_path   = "HEAP."path_l"_FIRST"
         interpret "next_header = "prev_next_path
         next_hash  = GET_INSTANCE_BY_HEADER(next_header)
         next_prev_path   = "HEAP."next_hash"_PREV"
         prev_hash  = ''
         end
       else
         do   /*  will have 2 neighbors     */
         prev_next_path   = "HEAP."path_elto"_NEXT"
         interpret "next_header = "prev_next_path
         next_hash  = GET_INSTANCE_BY_HEADER(next_header)
         next_prev_path   = "HEAP."next_hash"_PREV"
         interpret "prev_hash  = HEAP."path_elto
         end

     interpret prev_next_path "= HEAP."path_e
     interpret next_prev_path "= HEAP."path_e
     interpret "HEAP."path_e"_NEXT = HEAP."next_hash
     interpret "HEAP."path_e"_PREV = "prev_hash
     end
   else
     do /* ADD */
     /* set LIST element NEXT and PREV              */
     interpret "HEAP."path_e"_NEXT=''"
     interpret "HEAP."path_e"_PREV=HEAP."path_l"_LAST"
     /* set NEXT in PREV                            */
     interpret "prev = HEAP."path_e"_PREV"
     if prev <> ''
       then
         do
         prev  = "HEAP." || GET_INSTANCE_BY_HEADER(prev)
         prev_next = prev"_NEXT"
         interpret prev_next"=HEAP."path_e
         end
     /* set LIST FIRST and LAST */
     interpret "first_ptr = HEAP."path_l"_FIRST"
     if  first_ptr = ''
      then
          interpret "HEAP."path_l"_FIRST=HEAP."path_e
     interpret "HEAP."path_l"_LAST=HEAP."path_e
     end

 /* put data in the element */
 do i  = 0 to  STMXDATA.0
 interpret "HEAP."path_e"."i"='"STMXDATA.i"'"
 end

 call HMSG "....ELEMEMT" element_reference  action"ED to LIST" ,
                 list_reference "hash" objhash


 return 0
/* ===========================================================  */
/* ==  R E M O V E  E L E M E N T  F R O M   L I S T        ==  */
/* ===========================================================  */
REMOVE_ELEMENT_FROM_LIST: procedure expose HEAP.

 objname   = arg(1)
 clsname   = arg(2)
 elhash    = arg(3)


 element_reference = GET_REFERENCE_BY_HEADER(HEAP.elhash)
 parse value FIND_LIST(objname,clsname) with rc_find objhash    ,
                                             list_reference
 if rc_find <> 0
   then
     return 8

 path_l    = objhash
 path_e    = elhash

 interpret "prev_header = HEAP."path_e"_PREV"
 prev_hash = GET_INSTANCE_BY_HEADER(prev_header)
 if prev_hash = ''
   then
     do
     prev_next_path = "HEAP."path_l"_FIRST"
     prev_path      = ''
     end
   else
     do
     prev_next_path = "HEAP."prev_hash"_NEXT"
     prev_path      = "HEAP."prev_hash
     end
 interpret "next_header = HEAP."path_e"_NEXT"
 next_hash = GET_INSTANCE_BY_HEADER(next_header)
 if next_hash = ''
   then
     do
     next_prev_path = "HEAP."path_l"_LAST"
     next_path      = ''
     end
   else
     do
     next_prev_path = "HEAP."next_hash"_PREV"
     next_path      = "HEAP."next_hash
     end


 interpret prev_next_path "=" next_path
 interpret next_prev_path "=" prev_path

 call HMSG "....ELEMEMT" element_reference  "removed from LIST" ,
                 list_reference "hash" objhash
    call GC elhash

 return 0
/* ===========================================================  */
/* ==   F I N D    L I S T                                  ==  */
/* ===========================================================  */
FIND_LIST : procedure expose HEAP.
  objname  = arg(1)
  clsname  = arg(2)
  list_reference = GET_ITEM_REFERENCE(clsname,objname)
  objhash = GET_HASH_BY_REFERENCE(list_reference)
  if CHECK_HASH(objhash) = 0
  then
    do
    call HMSG ".L_CHECK: LIST " objname "is not found"
    return 8
    end

  if translate(word(HEAP.objhash,2)) <> "LIST"
  then
    do
    call HMSG ".L_CHECK: Hash" objhash "is not of a LIST instance"
    return 8
    end
 return 0 objhash list_reference

/* ===========================================================  */
/* ==   O P E N    L I S T                                  ==  */
/* ==  PARMS : list name                                    ==  */
/* ==        : class name                                   ==  */
/* ==        : F(orward) or B(ackward)                      ==  */
/* ==  RET   : "0 listhash" or 8                            ==  */
/* ===========================================================  */
LIST_OPEN : procedure expose HEAP. STMXDATA.
 parse value  FIND_LIST(arg(1),"LIST") with  rc objhash .
 if rc = 0
   then
     do
     if substr(arg(3),1,1) = "F"
      then
       do
        elhash = LIST_FIRST_ELEMENT(objhash)
        call GET_LIST_ELEMENT_DATA(elhash)
        return 0 elhash
       end
      else
       do
        elhash = LIST_LAST_ELEMENT(objhash)
        call GET_LIST_ELEMENT_DATA(elhash)
        return 0 elhash
       end
     end
   else
     return 8

/* ===========================================================  */
/* ==   G E T   N E X T   I N   L I S T                     ==  */
/* ==  PARMS : list name                                    ==  */
/* ==        : class name                                   ==  */
/* ==        : hash of current eleemnt of list              ==  */
/* ==  RET   : "0 element_hash" or 8                        ==  */
/* ===========================================================  */
LIST_NEXT : procedure expose HEAP. STMXDATA.
 lname  = arg(1)
 elhash = arg(3)
 if IS_ELEMENT_VALID("GETNEXT",lname,"LIST",                      ,
                     GET_REFERENCE_BY_HEADER(HEAP.elhash))  <> 1
    then
      return 8
 elnext  = LIST_NEXT_ELEMENT(elhash)
 call GET_LIST_ELEMENT_DATA(elnext)
 return 0 elnext

/* ===========================================================  */
/* ==   G E T   P R E V   I N   L I S T                     ==  */
/* ==  PARMS : list name                                    ==  */
/* ==        : class name                                   ==  */
/* ==        : hash of current eleemnt of list              ==  */
/* ==  RET   : "0 element_hash" or 8                        ==  */
/* ===========================================================  */
LIST_PREV : procedure expose HEAP. STMXDATA.
 lname  = arg(1)
 elhash = arg(3)
 if IS_ELEMENT_VALID("GETPREV",lname,"LIST",                      ,
                     GET_REFERENCE_BY_HEADER(HEAP.elhash))  <> 1
    then
      return 8
 elprev  = LIST_PREV_ELEMENT(elhash)
 call GET_LIST_ELEMENT_DATA(elprev)
 return 0 elprev

/* ===========================================================  */
/* ==  G E T   L I S T   E L E M E N T  D A T A             ==  */
/* ==  PARMS : element hash                                 ==  */
/* ===========================================================  */
 GET_LIST_ELEMENT_DATA : procedure expose HEAP. STMXDATA.
 elhash = arg(1)
 parse value GET_REFERENCE_BY_HEADER(HEAP.elhash)  with  ,
             "NAME_ELM_" stmxdata.NAME
 stmxdata.0 = 0
 if datatype(HEAP.elhash.0) = "NUM"
  then
    do
     do i = 0 to HEAP.elhash.0
     interpret "STMXDATA."i" = HEAP."elhash"."i
     end
   end
 return

/* ===========================================================  */
/* ==   C H E C K   L I S T  E M P T Y                      ==  */
/* ===========================================================  */
IS_LIST_EMPTY : procedure expose HEAP.
  objname  = arg(1)
  clsname  = arg(2)
  list_reference = GET_ITEM_REFERENCE(clsname,objname)
  objhash = GET_HASH_BY_REFERENCE(list_reference)
  interpret "first = HEAP."objhash"_FIRST"
  if first = ''
    then
      return 1
    else
      return 0

/* ===========================================================  */
/* ==  D E S T R O Y  L I S T                               ==  */
/* ==   PARMS :                                             ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ===========================================================  */
LIST_DESTROY: procedure expose HEAP. STMXDATA.

 objname  = arg(1)
 clsname  = arg(2)

 parse value FIND_LIST(objname,clsname) with rc_find objhash    ,
                                             list_reference
 if rc_find <> 0
   then
     return 8

 call GC objhash
 return 0

/********************************************************/
/*  L I S T  U T I L I T I E S                          */
/********************************************************/
LIST_FIRST_ELEMENT : procedure expose HEAP.
 interpret "first_el_header = HEAP."arg(1)"_FIRST"
 return GET_INSTANCE_BY_HEADER(first_el_header)

LIST_LAST_ELEMENT : procedure expose HEAP.
 interpret "last_el_header = HEAP."arg(1)"_LAST"
 return GET_INSTANCE_BY_HEADER(last_el_header)

LIST_NEXT_ELEMENT: procedure expose HEAP.
  elhash  = arg(1)
  interpret "next_el_header = HEAP."elhash"_NEXT"
  return GET_INSTANCE_BY_HEADER(next_el_header)

LIST_PREV_ELEMENT : procedure expose HEAP.
  elhash  = arg(1)
  interpret "prev_el_header = HEAP."elhash"_PREV"
  return GET_INSTANCE_BY_HEADER(prev_el_header)


LIST_ELEMENTS_EQUAL : procedure
  if arg(1) = arg(2)
   then
     return 1
   else
     return 0

LIST_COMPARE : procedure expose HEAP.
  objname = arg(1)
  el1hash = arg(2)
  el2hash = arg(3)

   /*  return 1 or 0 to test */

  el1name = GET_NAME_BY_HEADER(HEAP.el1hash)
  interpret "data1.0 = HEAP."el1hash".0"
  do i = 1 to data1.0
  interpret "data1."i " = HEAP."el1hash"."i
  end

  el2name = GET_NAME_BY_HEADER(HEAP.el2hash)
  interpret "data2.0 = HEAP."el2hash".0"
  do i = 1 to data2.0
  interpret "data2."i " = HEAP."el2hash"."i
  end
  /* USER_COPMPARE routine should receive :   */
  /* PARMS :                                  */
  /*   List name                              */
  /*   Element #1 name                        */
  /*   Element #2 name                        */
  /*   Stem DATA1 via procedure expose        */
  /*   Stem DATA2 via procedure expose        */
  /* RET  : 1-  exchange , 0 - no exchange    */


  parse value VARIABLE_GET("#srv_provider") with rc srv_provider .
  if srv_provider  = ''
    then
       do
       call HMSG ".Error : no value found for var #srv_provider"
       return 8
       end
  comp_rtn = srv_provider || "_COMPARE"
  interpret "rc="comp_rtn"("objname","el1name","el2name")"
  return rc

/* ===========================================================  */
/* ==   M A P                         METHODS               ==  */
/* ===========================================================  */
/* ===========================================================  */
/* == CREATE   : can ceate an empty map or map with element     */
/* == STMXDATA : is a normalized stem containing the element    */
/* ===========================================================  */

/* ===========================================================  */
/* ==   C R E A T E    M A P                                ==  */
/* ==   PARMS :  MAP NAME                                   ==  */
/* ==            CLASS NAME                                 ==  */
/* ==            KEY NAME  , optional                       ==  */
/* ===========================================================  */
MAP_CREATE : procedure expose STMXDATA. HEAP.
     objname  = arg(1)
     clsname  = arg(2)
     keyname  = arg(3)

     map_reference = GET_ITEM_REFERENCE(clsname,objname)
     if objname <> '#' &  CHECK_HASH(map_reference) = 1
       then
         do
         call HMSG ".M_CREATE: MAP" objname "already exists"
         return 8
         end

     objhash  = GET_HASH()
     /* allow no named map */
     if objname = '#'
       then
         do
         objname = '#' || objhash
         map_reference = GET_ITEM_REFERENCE(clsname,objname)
         end

     HEAP.objhash  = objhash "MAP"

     if ADD_HASH(map_reference,objhash) <> 0
       then
          return 8

     path_m   = objhash
     interpret "HEAP."path_m"_NAME="map_reference
     interpret "HEAP."path_m"_SIZE="0
     call HMSG ".....MAP" objname "created, hash" objhash

     if datatype(STMXDATA.0) <> "NUM" | STMXDATA.0 = 0
     then
       return "0" map_reference

     call HMSG ".....M_CREATE: Adding element to MAP" objname
     STMXDATA.NAME = NORMALIZE_NAME(STMXDATA.NAME)


     return "0" map_reference MAP_ADD(objname,clsname,keyname)

/* ===========================================================  */
/* == ADD,DELETE : operations on MAP                        ==  */
/* == STMXDATA :is a normalized stem containing the element == */
/* ===========================================================  */

/* ===========================================================  */
/* ==   A D D  E L E M E N T  T O   M A P                   ==  */
/* ==   PARMS :                                             ==  */
/* ==         map  name                                     ==  */
/* ==         class name                                    ==  */
/* ==         key   name                                    ==  */
/* ==   RET   : 0 ELREF or 8                                ==  */
/* ===========================================================  */
MAP_ADD    : procedure expose HEAP. STMXDATA.

 /* if no element requested */
 if STMXDATA.0 = 0
  then
    return 8

 if ADD_ELEMENT_TO_MAP_BY_KEY(arg(1),arg(2),arg(3)) <> 0
   then
     return 8

 return "0" element_reference

/* ===========================================================  */
/* ==  D E L E T E  E L E M E N T  F R O M   M A P          ==  */
/* ==   PARMS :                                             ==  */
/* ==         map  name                                     ==  */
/* ==         class name                                    ==  */
/* ==         keyname                                       ==  */
/* ==   RET   :  0 or 8                                     ==  */
/* ===========================================================  */
MAP_DELETE : procedure expose HEAP.

 objname  = arg(1)
 clsname  = arg(2)
 keyname  = arg(3)

 if REMOVE_ELEMENT_FROM_MAP_BY_KEY(objname,clsname,keyname) <> 0
   then
     return 8

 return  0

/* ===========================================================  */
/* ==  F I N D  E L E M E N T  I N   M A P                  ==  */
/* ===========================================================  */
/* ==  PARM : MAP NAME                                      ==  */
/* ==       : CLASS NAME                                    ==  */
/* ==       : KEYNAME                                       ==  */
/* ==  RET  : 0 FNDHASH FNDNAME or 8                        ==  */
/* ===========================================================  */
MAP_FIND: procedure expose HEAP. STMXDATA.
 objname = arg(1)
 clsname = arg(2)
 keyname = arg(3)

 /* check map valid */
 parse value FIND_MAP(objname,clsname) with rc_find path_m     ,
                                              map_reference
 if rc_find <> 0
   then
     return 8

 parse value FIND_ELEMENT_IN_MAP_BY_KEY(objname,keyname)      ,
                            with rc_find ndx_el path_e elname .
 if rc_find <> 0
   then
     return 8

 interpret "el_bndry = HEAP."path_e".0"
 /* get data from element  */
 do i  = 0 to  el_bndry
 interpret "STMXDATA."i" = HEAP."path_e"."i
 end

 return 0 path_e elname

/* ===========================================================  */
/* ==  A D D  E L E M E N T  T O   M A P                    ==  */
/* ===========================================================  */
/* ==  PARM : MAP NAME                                      ==  */
/* ==       : CLASS NAME                                    ==  */
/* ==       : KEY   NAME                                    ==  */
/* ==  RET  : 0 - OK, 8 - FAIL                              ==  */
/* ===========================================================  */
ADD_ELEMENT_TO_MAP_BY_KEY: procedure expose HEAP. STMXDATA.      ,
                                     element_reference

 objname   = arg(1)
 clsname   = arg(2)
 keyname   = arg(3)
 elname    = NORMALIZE_NAME(STMXDATA.NAME)

 /* check map valid */
 parse value FIND_MAP(objname,clsname) with rc_find objhash    ,
                                              map_reference
 if rc_find <> 0
   then
     return 8

 /* check element is not in map */

 parse value FIND_ELEMENT_IN_MAP_BY_KEY(objname,keyname)  ,
                                         with rc_find .
 if rc_find = 0
   then   /* already in map */
     return 8

 parse value PREPARE_ELEMENT() with rc_prep element_reference elhash .
 if rc_prep <> 0
   then
     return 8

 path_m    = objhash
 path_e    = elhash

 HEAP.elhash = elhash "ELEMENT"

 /* set element reference                       */
 interpret "HEAP."path_e"_NAME="element_reference
 if ADD_HASH(element_reference,elhash) <> 0
   then
      return 8

 /* set map name to the element */
 interpret "HEAP."path_e"_SUPER="map_reference
 /* advance map size        */
 interpret "map_size = HEAP."path_m"_SIZE"
 map_size = map_size + 1
 interpret "HEAP."path_m"_SIZE =" map_size

 interpret "HEAP."path_m"_"map_size "=" keyname
 interpret "HEAP."path_m"_"keyname "=" map_size path_e elname
 /* put data in the element */
 do i  = 0 to  STMXDATA.0
 interpret "HEAP."path_e"."i"='"STMXDATA.i"'"
 end

 call HMSG "....ELEMEMT" elname "by KEY" keyname             ,
               "added to MAP" map_reference "hash" objhash
 return 0

/* ===========================================================  */
/* ==  R E M O V E  E L E M E N T  F R O M   M A P          ==  */
/* ===========================================================  */
/* ==  PARM : MAP NAME                                      ==  */
/* ==       : CLASS   NAME                                  ==  */
/* ==       : KEYNAME                                       ==  */
/* ==  RET  : 0 - OK, 8 - FAIL                              ==  */
/* ===========================================================  */
REMOVE_ELEMENT_FROM_MAP_BY_KEY : procedure expose HEAP.

 objname   = arg(1)
 clsname   = arg(2)
 keyname   = arg(3)

 parse value FIND_MAP(objname,clsname) with rc_find objhash    ,
                                              map_reference
 if rc_find <> 0
   then
     return 8

 path_m    = objhash

 parse value FIND_ELEMENT_IN_MAP_BY_KEY(objname,keyname) with  ,
                                                       rc_find ndx_el .
 if rc_find = 0
   then
     do
     interpret "map_size = HEAP."path_m"_SIZE"
     interpret "map_index_del = HEAP."path_m"_"ndx_el
     interpret "HEAP."path_m"_"ndx_el "= HEAP."path_m"_"map_size

     /* set proper back index to data of moved element */
     interpret "map_index_max = HEAP."path_m"_"map_size
     interpret "map_data_max = HEAP."path_m"_"map_index_max
     map_data_max = ndx_el word(map_data_max,2) word(map_data_max,3)
     interpret "HEAP."path_m"_"map_index_max "=" map_data_max

     interpret "map_data_del = HEAP."path_m"_"map_index_del
     elhash = word(map_data_del,2)
     elname = word(map_data_del,3)
     call GC elhash

     path_o = "HEAP."path_m"_"map_size
     drop (path_o)
     path_o = "HEAP."path_m"_"map_index_del
     drop (path_o)

     map_size = map_size - 1
     interpret "HEAP."path_m"_SIZE =" map_size
     call HMSG "....ELEMEMT" elname "by KEY" keyname             ,
               "removed from MAP" map_reference "hash" objhash
     return 0
     end
 return 8
/* ===========================================================  */
/* ==  F I N D  E L E M E N T  B Y  K E Y                   ==  */
/* ===========================================================  */
/* ==  PARM : MAP NAME                                      ==  */
/* ==       : KEYNAME                                       ==  */
/* ==  RET  : 0 INDEX ELHASH ELNAME , 8 - FAIL              ==  */
/* ===========================================================  */
FIND_ELEMENT_IN_MAP_BY_KEY :  procedure expose HEAP. STMXDATA.

 objname   = arg(1)
 keyname   = arg(2)

 parse value FIND_MAP(objname,"MAP") with rc_find path_m .
 if rc_find <> 0
   then
     return 8

 interpret "map_size = HEAP."path_m"_SIZE"

 elpath     = "HEAP."path_m"_"keyname
 if symbol(elpath) = "LIT"
  then
   do
   call HMSG ".......No ELEMEMT found by key" keyname "in MAP" objname
   return 8
   end
 interpret "map_data = HEAP."path_m"_"keyname
 path_e = word(map_data,2)
 elname = word(map_data,3)
 interpret "loop_bndry = HEAP."path_e".0"
 /* fill STMXDATA from element */
 STMXDATA.NAME = elname
 do i  = 0 to  loop_bndry
 interpret "STMXDATA."i" = HEAP."path_e"."i
 end

 call HMSG ".......ELEMEMT" elname "found by key" keyname       ,
           "in MAP" objname
 return 0 map_data
/* ===========================================================  */
/* ==  D E S T R O Y  M A P                                 ==  */
/* ==   PARMS :                                             ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ===========================================================  */
MAP_DESTROY: procedure expose HEAP. STMXDATA.

 objname  = arg(1)
 clsname  = arg(2)

 parse value FIND_MAP(objname,clsname) with rc_find objhash    ,
                                             list_reference
 if rc_find <> 0
   then
     return 8

 call GC objhash
 return 0

/* ===========================================================  */
/* ==   F I N D    M A P                                    ==  */
/* ===========================================================  */
/* ==   PARM : MAP NAME                                     ==  */
/* ==          CLASS NAME                                   ==  */
/* ==   RET  : 0 MAPHASH MAPREF, 8 - FAIL                   ==  */
/* ===========================================================  */
/* ===========================================================  */
FIND_MAP : procedure expose HEAP.
  objname  = arg(1)
  clsname  = arg(2)
  map_reference = GET_ITEM_REFERENCE(clsname,objname)
  objhash = GET_HASH_BY_REFERENCE(map_reference)
  if CHECK_HASH(objhash) = 0
  then
    do
    call HMSG ".M_CHECK: MAP " objname "is not found"
    return 8
    end

  if translate(word(HEAP.objhash,2)) <> "MAP"
  then
    do
    call HMSG ".M_CHECK: Hash" objhash "is not of a MAP instance"
    return 8
    end
 return 0 objhash map_reference

/* ===========================================================  */
/* ==  I S  E L E M E N T  V A L I D                        ==  */
/* ==   PARMS :                                             ==  */
/* ==         action of the caller                          ==  */
/* ==         list name                                     ==  */
/* ==         class name                                    ==  */
/* ==         reference of element                          ==  */
/* ===========================================================  */
IS_ELEMENT_VALID : procedure expose HEAP.
 action   = arg(1)
 objname  = arg(2)
 clsname  = arg(3)
 elref    = arg(4)

 elhash = GET_HEAP_HASH_FOR_REFERENCE(elref)
 if elhash   = ''
   then
     do
     call HMSG "....Error at "action": reference"  elref            ,
                               "does not point to an element"
     return 0
     end
 interpret "list_ref = HEAP."elhash"_SUPER"
 if list_ref <> GET_ITEM_REFERENCE(clsname,objname)
   then
     do
     call HMSG "....Error at "action": element" elref               ,
                                "does not belong to" objname
     return 0
     end

 return 1
/* ===========================================================  */
/* ==   C H E C K  U S E R  D A T A   V A L I D I T Y       ==  */
/* ===========================================================  */
PREPARE_ELEMENT : procedure expose HEAP. STMXDATA.
  if datatype(STMXDATA.0) <> "NUM" | STMXDATA.0 = 0
   then
    do
    call HMSG ".STMXDATA is not normalized for adding to LIST" objhash
    return 8
    end
  STMXDATA.NAME = NORMALIZE_NAME(STMXDATA.NAME)
  element_reference = GET_ITEM_REFERENCE("ELEMENT",STMXDATA.NAME)
  if  STMXDATA.NAME <> '' &   CHECK_HASH(element_reference) = 1
   then
    do
    call HMSG ".....C_USER_DATA: ELEMENT" STMXDATA.NAME "already exists"
    return 8
    end
  elhash   = GET_HASH()
  /* allow no named elements */
  if STMXDATA.NAME = ''
    then
     do
     STMXDATA.NAME = '#' || elhash
     element_reference = GET_ITEM_REFERENCE("ELEMENT",STMXDATA.NAME)
     end
 return 0 element_reference elhash
/* ===========================================================  */
/* == Garbage collector - Main                              ==  */
/* ===========================================================  */
GC :  procedure expose HEAP.
MODE = "GC"
HLEN=24
call HEAP_DETAIL arg(1)
return

/* ===========================================================  */
/* == Serialization - Main                                  ==  */
/* == PARM : HEAP sharing : SHR or CPY                      ==  */
/* ==      : FILENAME of DD to persist or ''                ==  */
/* ===========================================================  */
HEAP_SRLZ :  procedure expose SRLZ_REC HEAP.
HEAP_SHR        = arg(1)
FILE_TO_PERSIST = arg(2)

if HEAP_SHR = "DRP"
  then
   drop HEAP.
  else
   if HEAP_SHR = "SHR"
     then
       do
       call HEAP_SRLZ_TO_FILE FILE_TO_PERSIST
       drop HEAP.
       end
     else
      if HEAP_SHR = "CPY"
        then
          do
          call HEAP_SRLZ_TO_FILE FILE_TO_PERSIST
          end
return 0

/* ===========================================================  */
/* == Serialization                                         ==  */
/* == PARM : FILENAME of DD to persist or ''                ==  */
/* ===========================================================  */
HEAP_SRLZ_TO_FILE : procedure expose SRLZ_REC HEAP.
FILE_TO_PERSIST = arg(1)
HLEN=24
MODE = "SRLZ"
SRLZ_REC = 0 /* serialized records number */

/* serialize lists, maps, elements ,objects */
do i = 0 to HEAP.0
/* SRLZ_FLAG is dropped in HEAP_DETAIL,it should be restored here */
SRLZ_FLAG = 1
call PATH_DETAIL "HEAP."i , HEAP.i
objhash = HEAP.i
if i > 0
  then
    do
    call HEAP_DETAIL objhash
    end
end

/* serialize variables */
vpath = "VAR_GLOBAL"
if symbol('HEAP.'vpath'.0') = "LIT"
   then
     return
interpret "loop_bndry = HEAP."vpath".0"
do i = 0 to loop_bndry
path = "HEAP."vpath"."i
interpret "val = HEAP."vpath"."i
call PATH_DETAIL path,val
if i > 0
  then
    do
    path_curr = "HEAP."vpath || "_" || val
    interpret "val_curr = "path_curr
    call PATH_DETAIL path_curr,val_curr
    end
end

return

/* ===========================================================  */
/* == Garbage collector - Routines                          ==  */
/* ===========================================================  */
/**************************************************/
/* GC : remove hash from index                    */
/**************************************************/
REMOVE_HASH_FROM_HEAP_INDEX : procedure expose HEAP.
 parse arg objhash index .
 call SHRINK_HEAP_INDEX index
 var = "HEAP."objhash  ;  drop (var)

 if index > HEAP.0
   then
     return

 /* update back index in anchor pointed by the moved index */
 hash   =  HEAP.index

 if length(hash) > 8
   then   /* REFERENCE */
     do
     interpret "ref_val = HEAP."hash
     HEAP.hash= word(ref_val,1) index
     end
   else   /* HASH */
     interpret "HEAP."hash"_HEAPIX="index

 return

/**************************************************/
/* GC : shrink heap index                         */
/**************************************************/
SHRINK_HEAP_INDEX : procedure expose HEAP.
 index = arg(1)
 max_index  = HEAP.0
 HEAP.index = HEAP.max_index
 var = "HEAP."max_index ; drop (var)
 HEAP.0 = max_index - 1
 return

/* ===========================================================  */
/* == HEAP routines                                         ==  */
/* ===========================================================  */

/*********************************************/
/* HEAP initiating routine                   */
/* ADD #INTERNAL or #SERVICES lists elements */
/* to be used in GC, TRACE and dynamic calls */
/*********************************************/
HEAPINIT: procedure expose HEAP.
 HEAP.0 = 0
 call HMSG "..=== HEAP initialization started"
 /*******************************************/
 /* USED FOR DEBUG AND GC                   */
 /* LSTFIELDS , ELMFIELDS and OBJFIELDS     */
 /* define the fields of LIST , ELEMENT     */
 /* OBBJECT , MAP  be                       */
 /* traced and GC-ed.                       */
 /* Special cases <HEAD> and <TYPE>         */
 /* These vars do not exist,only traced :   */
 /*  <HEAD> means to trace HEAP.path        */
 /*  <TYPE> <clslist - class name type      */
 /*  <TYPE> <clsel - class name from header */
 /*  <TYPE> <clsobj- class name from header */
 /*                  not in use - bug !!!   */
 /*  <TYPE> <clsmap- class name from header */
 /*                                         */
 /*******************************************/

 stmxdata.NAME="#lstanchor"
 stmxdata.0 = 2
 stmxdata.1 = "SUMRX V2.01,2018-07,gennady.lapidus@sailpoint.com"
 stmxdata.2 = "L 1 M 0 O 0 E 1 V -1 T 19 I 3 D 100 S 1"
 if word(CREATE_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#lstfields"
 stmxdata.0 = 7
 stmxdata.1 = "<HEAD>  ...."
 stmxdata.2 = "NAME    NAME"
 stmxdata.3 = "<TYPE>  <clslist"
 stmxdata.4 = "HEAPIX  HEAPIX"
 stmxdata.5 = "SORTED  SORTED"
 stmxdata.6 = "FIRST   FIRST"
 stmxdata.7 = "LAST    LAST"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#elmfields"
 stmxdata.0 = 7
 stmxdata.1 = "<HEAD>  ...."
 stmxdata.2 = "NAME    NAME"
 stmxdata.3 = "SUPER   SUPER"
 stmxdata.4 = "<TYPE>  <clsel"
 stmxdata.5 = "HEAPIX  HEAPIX"
 stmxdata.6 = "NEXT    NEXT"
 stmxdata.7 = "PREV    PREV"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#objfields"
 stmxdata.0 = 4
 stmxdata.1 = "<HEAD>  ...."
 stmxdata.2 = "NAME    NAME"
 stmxdata.3 = "<TYPE>  <clsobj"
 stmxdata.4 = "HEAPIX  HEAPIX"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#mapfields"
 stmxdata.0 = 5
 stmxdata.1 = "<HEAD>  ...."
 stmxdata.2 = "NAME    NAME"
 stmxdata.3 = "<TYPE>  <clsmap"
 stmxdata.4 = "HEAPIX  HEAPIX"
 stmxdata.5 = "SIZE    SIZE"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8
 /***************************************/
 /* USED FOR dynamic routine call       */
 /* LSTRTNACT OBJRTNACT SRVRTNACT and   */
 /* VARRTNACT are                       */
 /* actions to proceed on LIST ,        */
 /* OBJECT ,SERVICE VARIABLE and MAP    */
 /* respectively.                       */
 /***************************************/

 stmxdata.NAME="#lstrtnact"
 stmxdata.0  = 11
 stmxdata.1  = "CREATE"
 stmxdata.2  = "ADD"
 stmxdata.3  = "INSERT"
 stmxdata.4  = "DELETE"
 stmxdata.5  = "EXCHANGE"
 stmxdata.6  = "OPEN"
 stmxdata.7  = "NEXT"
 stmxdata.8  = "PREV"
 stmxdata.9  = "CLOSE"
 stmxdata.10 = "SORT"
 stmxdata.11 = "DESTROY"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8


 stmxdata.NAME="#objrtnact"
 stmxdata.0 = 3
 stmxdata.1 = "CREATE"
 stmxdata.2 = "QUERY"
 stmxdata.3 = "DESTROY"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#srvrtnact"
 stmxdata.0 = 2
 stmxdata.1 = "START"
 stmxdata.2 = "STOP"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#varrtnact"
 stmxdata.0 = 4
 stmxdata.1 = "SET"
 stmxdata.2 = "GET"
 stmxdata.3 = "DEL"
 stmxdata.4 = "LIST"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

 stmxdata.NAME="#maprtnact"
 stmxdata.0 = 5
 stmxdata.1 = "CREATE"
 stmxdata.2 = "DESTROY"
 stmxdata.3 = "ADD"
 stmxdata.4 = "DELETE"
 stmxdata.5 = "FIND"
 if word(ADD_TO_UTILITY_LIST("#INTERNAL"),1) <> 0
   then
     return 8

usr_services.0 = 0
 stmxdata.0 = 0

 if datatype(usr_services.0) = "NUM" & usr_services.0  > 0
   then
    do
    if word(CREATE_UTILITY_LIST("#SERVICES"),1) <> 0
     then
       return 8

     do i = 1 to usr_services.0
     parse var usr_services.i srv_name srv_provider srv_objtype   ,
                              srv_objname srv_sort
     stmxdata.NAME="#" || srv_name
     stmxdata.0 = 4
     stmxdata.1 = srv_provider
     stmxdata.2 = srv_objtype
     stmxdata.3 = srv_objname
     stmxdata.4 = srv_sort       /* YES/NO */
     if word(ADD_TO_UTILITY_LIST("#SERVICES"),1) <> 0
       then
         return 8
     end
    end

 if VARIABLE_SET("HEAP_READY","YES") <> 0
   then
    call HMSG "=== HEAP initialization failed"
 call HMSG "..=== HEAP initialization completed"
 return 0

/*********************************************/
/* Create internal list with an element      */
/* PARMS  : list name                        */
/*********************************************/
CREATE_UTILITY_LIST : procedure expose HEAP. STMXDATA.
return  CLSMNGR_ACTION(arg(1),"CREATE")

/*********************************************/
/* Add element to utility list               */
/* PARMS  : list name                        */
/*********************************************/
ADD_TO_UTILITY_LIST : procedure expose HEAP. STMXDATA.
   return  CLSMNGR_ACTION(arg(1),"INSERT")
/* return  CLSMNGR_ACTION(arg(1),"ADD") */


/*********************************************/
/* Executing Create/Add on a list            */
/* PARMS  : list name                        */
/*        : action                           */
/*********************************************/
CLSMNGR_ACTION : procedure expose HEAP. STMXDATA.
list   = arg(1)
action = arg(2)
return CLSMNGR(action,"LIST",list,0)

/*********************************************/
/* START service                             */
/* PARMS  : service name                     */
/*   RET  : 0 objtype objname  or 8          */
/*********************************************/
SERVICE_START : procedure expose HEAP. STMXDATA.
 objhash = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#"translate(arg(1)))
 if objhash = ''
   then
    do
    call HMSG ".....Service not found:"arg(1)
    return 8
    end

 if datatype(HEAP.objhash.0) = "NUM"
  then
    do              /* correct service definition */
    interpret "srv_provider = HEAP."objhash".1"
    interpret "srv_objtype  = HEAP."objhash".2"
    interpret "srv_objname  = HEAP."objhash".3"
    interpret "srv_sort     = HEAP."objhash".4"
    if srv_objtype = "LIST"
      then
       do   /* LIST class */
        parse value FIND_LIST(srv_objname,"LIST") with rc .
        if rc <> 0
         then
          start_provider_needed = 1
         else
          start_provider_needed = 0
       end /* LIST class */
    if start_provider_needed = 1
     then
      do /* service provider has to run */
      call HMSG "...."srv_objtype srv_objname "does not exist"
      call HMSG "....Starting provider" srv_provider
      if VARIABLE_SET("#srv_provider",srv_provider) <> 0
        then
          do /* set current service */
          call HMSG ".Error at setting #srv_provider to" srv_provider
          return 8
          end /* set current service */
      interpret "rc="srv_provider"("srv_objname")"
      if rc <> 0
        then
          do   /* service provider failed */
          call HMSG ".Error found when running  provider" srv_provider
          return 8
          end  /* service provider failed */
        else
          do   /* service provider succeeded */
          if translate(srv_sort) = "YES"
           then
            do /* sort requested */
            if LIST_SORT(srv_objname,"LIST") <> 0
             then
              do   /* sort failed */
              call HMSG ".Error ecountered at sorting list"        ,
                        srv_objname "provider" srv_provider
              return 8
              end  /* sort failed */
            end /* sort requested */
          if translate(srv_sort) = "YES"
           then
             call HMSG "....List" srv_objname "sorted  successfully"
          call HMSG "....Provider" srv_provider "completed successfully"
          end   /* service provider succeeded */
      end /* service provider has to run */
     else
      do  /* service provider does not have to run */
      call HMSG "...."srv_objtype srv_objname "found exists"
      call HMSG "....Provider" srv_provider "was not started"
      end /* service provider does not have to run */
    end
  else
    do   /* not correct service definition */
    call HMSG ".Service definition error:"arg(1)
    return 8
    end /* not correct service definition */

  return 0 srv_objtype srv_objname

/*********************************************/
/* STOP service                              */
/* PARMS  : service name                     */
/*   RET  : 0 or 8                           */
/*********************************************/
SERVICE_STOP : procedure expose HEAP. STMXDATA.
 objhash = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#"translate(arg(1)))
 parse value VARIABLE_DEL("#srv_provider") with rc .
 if rc <> 0
   then
     call HMSG "...Warning : variable #srv_provider not found"
 if datatype(HEAP.objhash.0) = "NUM"
  then
    do
    interpret "srv_provider = HEAP."objhash".1"
    interpret "srv_objtype  = HEAP."objhash".2"
    interpret "srv_objname  = HEAP."objhash".3"
    interpret "srv_sort     = HEAP."objhash".4"
    if srv_objtype = "LIST"
      then
       do
        parse value FIND_LIST(srv_objname,"LIST") with rc .
        if rc <> 0
         then
          object_not_found = 1
         else
          object_not_found = 0
       end
    if object_not_found = 0
      then
        do
        call HMSG "....Destroying" srv_objtype srv_objname
        if LIST_DESTROY(srv_objname,srv_objtype) <> 0
          then
           do
           call HMSG ".Error at destroying list" srv_objname
           return 8
           end
        return 0
        end
      else
        do
        call HMSG ".Error:"srv_objtype srv_objname "not found"
        return 8
        end

/********************************************/
/* header is <objhash    classname>         */
/********************************************/
GET_HEAP_INDEX_BY_HEADER : procedure expose HEAP.
parse arg hash  .
interpret "index=HEAP."hash"_HEAPIX"
return index

/*************************************************/
/* this searches index which is the path to      */
/* header (reference) - used to remove reference */
/*************************************************/
GET_HEAP_INDEX_FOR_REFERENCE : procedure expose HEAP.
object_reference = arg(1)
if symbol('HEAP.'object_reference) = "LIT"
  then
    return ''
header_path      = HEAP.object_reference
return word(header_path,2)

/***********************************************/
/* this searches index which is the path to    */
/* header (reference) - used for quick search  */
/***********************************************/
GET_HEAP_HASH_FOR_REFERENCE : procedure expose HEAP.
object_reference = arg(1)
if symbol('HEAP.'object_reference) = "LIT"
  then
    return ''
header_path      = HEAP.object_reference
return word(header_path,1)

/***********************************************/
/* returns hash of the HEAP item from header   */
/***********************************************/
GET_INSTANCE_BY_HEADER : procedure expose HEAP.
 parse arg hash .
 return hash

/***********************************************/
/* returns classname from header               */
/***********************************************/
GET_CLSNAME_BY_HEADER : procedure expose HEAP.
 parse arg . clsname .
 return clsname

/***********************************************/
/* returns reference from header path          */
/***********************************************/
GET_REFERENCE_BY_HEADER : procedure expose HEAP.
 parse arg hash .
 interpret "name=HEAP."hash"_NAME"
 return name

/***********************************************/
/* returns item name from its reference        */
/***********************************************/
GET_NAME_BY_REFERENCE : procedure expose HEAP.
 hash = GET_HEAP_HASH_FOR_REFERENCE(arg(1))
 return  GET_NAME_BY_HEADER(HEAP.hash)

/***********************************************/
/* returns item name from header path          */
/***********************************************/
GET_NAME_BY_HEADER : procedure expose HEAP.
 parse arg hash .
 reference_reversed = REVERSE(GET_REFERENCE_BY_HEADER(hash))
 parse var reference_reversed name '_' .
 return REVERSE(name)

/**********************************************/
/* creates reference for the HEAP item        */
/**********************************************/
GET_ITEM_REFERENCE : procedure expose HEAP.
NAMEELM = "NAME_ELM_"
NAMELST = "NAME_LST_"
NAMEOBJ = "NAME_OBJ_"
NAMEMAP = "NAME_MAP_"
clsname  = translate(arg(1))
elname   = translate(arg(2))

if strip(elname) = ''
  then
    return ''

if clsname = "LIST"
  then
    pfx = NAMELST
  else
    if clsname = "ELEMENT"
      then
        pfx = NAMEELM
      else
        if clsname = "MAP"
          then
            pfx = NAMEMAP
          else
            pfx = NAMEOBJ || clsname || "_"
return pfx || elname

/**********************************************/
/*                                            */
/*   E X T E R N A L  R O U T I N E S         */
/*                                            */
/**********************************************/
/**********************************************/
/*  GET HEAP Statistics                       */
/*  RET  : statistics data                    */
/**********************************************/
GET_HEAP_STATISTICS_EXT:  procedure expose st. HEAP.
  stats =  GET_HEAP_ANCHOR_EXT(2)
 /* L 5 M 2 O 0 E 97 V 3 T 972 I 244 D 3699 S 2 */
 parse var stats 'L' st.l ,
                 'M' st.m ,
                 'O' st.o ,
                 'E' st.e ,
                 'V' st.v ,
                 'T' st.t ,
                 'I' st.i ,
                 'D' st.d ,
                 'S' st.s
 st.l = strip(st.l)
 st.m = strip(st.m)
 st.o = strip(st.o)
 st.e = strip(st.e)
 st.v = strip(st.v) ; if st.v = -1 then st.v = 0 ;
 st.t = strip(st.t)
 st.i = strip(st.i)
 st.d = strip(st.d)
 st.s = strip(st.s)
 return stats
/**********************************************/
/*  PUT HEAP Statistics                       */
/*  PARM : statistics data                    */
/*  RET  : 0 or 8                             */
/**********************************************/
PUT_HEAP_STATISTICS_EXT:  procedure expose HEAP.
  return PUT_HEAP_ANCHOR_EXT(2,arg(1))
/**********************************************/
/*  GET HEAP ANCHOR  ITEM                     */
/**********************************************/
/*  PARM : index of array of #LSTANCHOR       */
/*  RET  : ANCHOR item or ''                  */
/**********************************************/
GET_HEAP_ANCHOR_EXT:  procedure expose HEAP.
 if GET_VARIABLE_VALUE_EXT("HEAP_READY") = "YES"
   then
    do
    hash_lstanchor = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#LSTANCHOR")
    interpret "anchor = HEAP."hash_lstanchor"."arg(1)
    return anchor
    end
 return ''
/**********************************************/
/*  PUT HEAP ANCHOR  ITEM                     */
/**********************************************/
/*  PARM : index of array of #LSTANCHOR       */
/*       : ANCHOR item data                   */
/*  RET  : 0 or 8                             */
/*       : this is a dummy routine right now  */
/**********************************************/
PUT_HEAP_ANCHOR_EXT:  procedure expose HEAP.
 return 0

 if GET_VARIABLE_VALUE_EXT("HEAP_READY") = "YES"
   then
    do
    hash_lstanchor = GET_HEAP_HASH_FOR_REFERENCE("NAME_ELM_#LSTANCHOR")
    interpret "HEAP."hash_lstanchor"."arg(1) "=" arg(2)
    return 0
    end
 return 8
/**********************************************/
/* HEAP serialization                         */
/**********************************************/
/*  PARM : HEAP sharing : SHR , CPY , DRP     */
/*       : FILENAME of DD to persist or ''    */
/*  RET  : 0 or 8                             */
/**********************************************/
HEAP_SERIALIZE_EXT:  procedure expose SRLZ_REC HEAP.
 if GET_VARIABLE_VALUE_EXT("HEAP_READY") = "YES"
   then
    return HEAP_SRLZ(arg(1),arg(2))
 return 8
/**********************************************/
/* Query HEAP allocated                       */
/**********************************************/
/*  RET  : 0 - OK, 8 - NOK                    */
IS_HEAP_ALLOC_EXT:  procedure expose HEAP.
 if symbol('HEAP.0') <> "LIT"
   then
    return 0
   else
    return 8
/**********************************************/
/* Query HEAP initialized                     */
/**********************************************/
/*  RET  : 0 - OK, 8 - NOK                    */
/**********************************************/
IS_HEAP_READY_EXT:  procedure expose HEAP.
 if GET_VARIABLE_VALUE_EXT("HEAP_READY") = "YES"
   then
    return 0
   else
    return 8

/**********************************************/
/* Query LIST exists                          */
/**********************************************/
/*  PARM : LIST NAME                          */
/*  RET  : 0 - OK, 8 - NOK                    */
/**********************************************/
IS_LIST_READY_EXT:  procedure expose HEAP.
objname = arg(1)
if IS_HEAP_READY_EXT() <> 0
  then
    return 8
list_reference = GET_ITEM_REFERENCE("LIST",objname)
if  CHECK_HASH(list_reference) = 1
  then
    return 0
  else
    return 8
/**********************************************/
/* Query MAP exists                           */
/**********************************************/
/*  PARM : MAP NAME                           */
/*  RET  : 0 - OK, 8 - NOK                    */
/**********************************************/
IS_MAP_READY_EXT:  procedure expose HEAP.
objname = arg(1)
if IS_HEAP_READY_EXT() <> 0
  then
    return 8
map_reference = GET_ITEM_REFERENCE("MAP",objname)
if  CHECK_HASH(map_reference) = 1
  then
    return 0
  else
    return 8
/**********************************************/
/* Set HEAP lock                              */
/* PARM : LOCK NAME                           */
/**********************************************/
/* PARM  : LOCK NAME                          */
SET_HEAP_LOCK_EXT:  procedure expose HEAP.
 interpret "HEAP."arg(1)"=0"
 return

/**********************************************/
/* Is lock set                                */
/* PARM  : LOCK NAME                          */
/*  RET  : 1 - LOCKED, 0 - UNLOCKED           */
/**********************************************/
IS_HEAP_LOCK_SET_EXT:  procedure expose HEAP.
 path  = "HEAP."arg(1)
 interpret "sym = symbol('"path"')"
 if sym = "LIT"
   then
     return 0
   else
     return 1
/**********************************************/
/* Set HEAP unlock                            */
/* PARM  : LOCK NAME                          */
/**********************************************/
UNSET_HEAP_LOCK_EXT:  procedure expose HEAP.
 path  = "HEAP."arg(1)
 drop (path)
 return

/**********************************************/
/* SET variable value - EXTERNAL              */
/**********************************************/
/*  ARGS : variable name                      */
/*       : variable value                     */
/*  RET  : 0 - OK, 8 - NOK                    */
SET_VARIABLE_VALUE_EXT:  procedure expose HEAP.
rc = VARIABLE_SET(arg(1),arg(2))
return COLLECT_STATISTICS("VARIABLE_SET")

/**********************************************/
/* GET variable value - EXTERNAL              */
/**********************************************/
/*  ARGS : variable name                      */
/*  returns : value                           */
/*                                            */
GET_VARIABLE_VALUE_EXT:  procedure expose HEAP.
 parse value VARIABLE_GET(arg(1)) with rc var_val
 return strip(var_val)

/**********************************************/
/* returns element data by name - EXTERNAL    */
/**********************************************/
/*  ARGS : element reference name             */
/*  returns : STMXDATA. sructure              */
/*                                            */
GET_DATA_BY_ELEMENT_NAME_EXT:  procedure expose HEAP. STMXDATA.
STMXDATA.0 = 0
if HEAP.0 = 0   | symbol('HEAP.0') =  "LIT"
  then
    return
elref = GET_ITEM_REFERENCE("ELEMENT",arg(1))
elhash  = GET_HASH_BY_REFERENCE(elref)
if datatype(HEAP.elhash.0) = "NUM"
 then
   do
    do i = 0 to HEAP.elhash.0
    interpret "STMXDATA."i" = HEAP."elhash"."i
    end
   end
return

/**********************************************/
/*                                            */
/*   I N T E R N A L  R O U T I N E S         */
/*                                            */
/**********************************************/
/* returns normalized name                    */
/**********************************************/
NORMALIZE_NAME : procedure
 return strip(arg(1))

/**********************************************/
/* returns hash of HEAP item by its reference */
/* PARM : OBJ REFERENCE                       */
/*  RET : HASH                                */
/**********************************************/
GET_HASH_BY_REFERENCE : procedure expose HEAP.
header = GET_HEADER_BY_REFERENCE(arg(1))
return GET_INSTANCE_BY_HEADER(header)

/************************************************/
/* returns header of HEAP item by its reference */
/* PARM : OBJ REFERENCE                         */
/*  RET : HEADER  (HASH CLASS)                  */
/************************************************/
GET_HEADER_BY_REFERENCE : procedure expose HEAP.
object_reference = arg(1)
hash = word(HEAP.object_reference,1)
return HEAP.hash

/************************************************/
/* extract object from HEAP                     */
/* PARM : OBJ HASH                              */
/*  RET : 0 OBJNAME CLSNAME or 8                */
/************************************************/
GETOBJ : procedure expose HEAP. STMXDATA.
 objhash  = arg(1)
 if CHECK_HASH(objhash) = 0
   then
     return 8

 header  = HEAP.objhash
 objname = GET_REFERENCE_BY_HEADER(header)
 clsname = GET_CLSNAME_BY_HEADER(header)

 return '0' objname clsname

/********************************************/
/* H A S H      R O U T I N E S             */
/********************************************/

/********************************************/
/* checks whether the hash is used (1)      */
/********************************************/
CHECK_HASH : procedure expose HEAP.
 hash   = arg(1)
 if symbol('HEAP.'hash) = "LIT"
   then
     return 0
   else
     return 1

/********************************************/
/* add pre-generated pseudo hash to HEAP    */
/* Used for references                      */
/********************************************/
ADD_HASH : procedure expose HEAP.
 hash     = arg(1)
 hdr_path =  arg(2)
 if symbol('HEAP.'hash) = "LIT"
   then
     do
     call SET_NEW_HASH hash , hdr_path
     return 0
     end
   else
     do
     call HMSG ".The identical item was found in heap, hash" hash
     return 8
     end
/********************************************/
/* provides message interface suitable with */
/* injector                                 */
/********************************************/
HMSG : procedure expose HEAP.
RC=MSG('H',arg(1))
 return

/********************************************/
/* generates new hash which is not in use   */
/* yet                                      */
/********************************************/
GET_HASH : procedure expose HEAP.
 in = '000102030405060708090A0B0C0D0E0F'x  ||,
      '101112131415161718191A1B1C1D1E1F'x  ||,
      '202122232425262728292A2B2C2D2E2F'x  ||,
      '303132333435363738393A3B3C3D3E3F'x  ||,
      '404142434445464748494A4B4C4D4E4F'x  ||,
      '505152535455565758595A5B5C5D5E5F'x  ||,
      '606162636465666768696A6B6C6D6E6F'x  ||,
      '707172737475767778797A7B7C7D7E7F'x  ||,
      '808182838485868788898A8B8C8D8E8F'x  ||,
      '909192939495969798999A9B9C9D9E9F'x  ||,
      'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'x  ||,
      'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'x  ||,
      'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'x  ||,
      'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'x  ||,
      'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'x  ||,
      'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'x
 out ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef'   ||,
      'ghijklmnopqrstuvwxyz0123456789@#'   ||,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef'   ||,
      'ghijklmnopqrstuvwxyz0123456789@#'   ||,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef'   ||,
      'ghijklmnopqrstuvwxyz0123456789@#'   ||,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef'   ||,
      'ghijklmnopqrstuvwxyz0123456789@#'

 /* initialize stem for first time */
 if symbol('HEAP.0')      = "LIT"
   then
      HEAP.0 = 0

 loop = 1
 do while loop=1
   a = random(32768,99999) * random(1024,9999)
   b = d2c(a)
   c = random(32768,99999) * random(1024,9999)
   d = d2c(c)
   hash = translate(b||d,out,in)
   /* convert hash to uppercase. REXX is not case sensitive */
   hash = translate(hash)
   /* check that hash is not in use and then add it to stem */
   if symbol('HEAP.'hash)  = "LIT" |  hash <> "INTERNAL"
     then
       do
       call SET_NEW_HASH hash
       loop = 0
       end
 end
 return hash

/*********************************************/
/* add hash to the HEAP index and initialize */
/* the item header for either :              */
/* 1. Regular hashes                         */
/* 2. Pseudo hashes (refereces)              */
/* For both they set index back to itself    */
/* in the element HEAPIX or in the path to   */
/* header                                    */
/*********************************************/
SET_NEW_HASH : procedure expose HEAP.
 hash = arg(1)
 j = HEAP.0 + 1
 HEAP.0 = j
 HEAP.j = hash
 if ARG() = 1   /* regular hash */
    then
      do  /* create link to the new added header */
      HEAP.hash = hash                   /* set anchor */
      interpret "HEAP."hash"_HEAPIX="j   /* set heap index */
      end
 if ARG() = 2 /* pseudo, reference */
    then
      HEAP.hash = arg(2) j       /* set path to header & index back */
 return
FRMARRAY : procedure expose SMRX.
/*        CFHELPER                                                   */
SMRX.1   = "3EA HEAP Reference:$$P1 not found                         "
SMRX.2   = "5IA :::Trace of HEAP item by reference:$$P1               "
SMRX.3   = "6IA :::Trace of whole HEAP                                "
SMRX.4   = "5IA =======  HEAP $$P1  ===========                       "
SMRX.5   = "3I  Check lib member existence $$P1 $$P2 ,rc=$$P3         "
SMRX.6   = "3I  Check file existence $$P1 ,rc=$$P2                    "
SMRX.7   = "3I  Allocate file $$P1 ,rc=$$P2                           "
SMRX.8   = "3I  Delete file $$P1 ,rc=$$P2                             "
SMRX.9   = "3I  Query file attribute $$P1 $$P2 ,rc=$$P3               "
SMRX.10  = "3I  Get library member list $$P1 ,rc=$$P2                 "
SMRX.11  = "3I  Read member from library $$P1 $$P2 ,rc=$$P3           "
SMRX.12  = "3I  Move member to other lib $$P1 $$P2 $$P3 ,rc=$$P4      "
SMRX.13  = "3I  CopyRepl member to other lib $$P1 $$P2 $$P3 ,rc=$$P4  "
SMRX.14  = "3I  CopyNoRepl item to other lib $$P1 $$P2 $$P3 ,rc=$$P4  "
SMRX.15  = "3I  Delete library member $$P1 $$P2 ,rc=$$P3              "
SMRX.16  = "3I  Erase library $$P1 ,rc=$$P1                           "
SMRX.17  = "3I  Add member to library $$P1 $$P2 ,rc=$$P3              "
SMRX.18  = "3I  Update library member $$P1 $$P2 ,rc=$$P3              "
SMRX.19  = "3I  Delete all library members $$P1 ,rc=$$P2              "
SMRX.20  = "3I  Compress library $$P1 ,rc=$$P2                        "
/*        GIMHLPR                                                    */
SMRX.21  = "3I  SMPEMNGR REQUEST :$$P1                                "
SMRX.22  = "3I  ____________ZONE :$$P1                                "
SMRX.23  = "3I  ______ENTRY TYPE :$$P1                                "
SMRX.24  = "3I  __________FILTER :$$P1                                "
SMRX.25  = "3E  At enntrance to $$P1                                  "
SMRX.26  = "4I  SMPEMNGR:SMPEAPI started $$P1                         "
SMRX.27  = "4I  SMPEMNGR:SMPEAPI returned from GIMAPI                 "
SMRX.28  = "4I  SMPEMNGR:SMPEAPI result file is empty                 "
SMRX.29  = "4W  SMPEMNGR:SMPEAPI GIMAPI failed with ER                "
SMRX.30  = "4E  SMPEMNGR:SMPEAPI GIMAPI EOF marker not found          "
SMRX.31  = "4I  SMPEMNGR:SMPEAPI GIMAPI successfully comleted         "
SMRX.32  = "4E  SMPEMNGR:Parameter selection failed                   "
/*        FSHELPER                                                   */
SMRX.33  = "4I  __________REQUEST : $$P1                              "
SMRX.34  = "4I  _________FILENAME : $$P1                              "
SMRX.35  = "4I  ____________MODEL : $$P1                              "
SMRX.36  = "4I  _____________ATTR : $$P1                              "
SMRX.37  = "4I  Qeury attributes of file $$P1                         "
SMRX.38  = "4I  Qeury specific file attr $$P1                         "
SMRX.39  = "4I  Allocate file $$P1 by model                           "
SMRX.40  = "4I  Allocate new file $$P1                                "
SMRX.41  = "4I  Check existence of $$P1                               "
SMRX.42  = "4I  Delete file $$P1                                      "
SMRX.43  = "4E  FSMNGR:Parameter selection failed                     "
SMRX.44  = "4I  FSCMD requested $$P1                                  "
SMRX.45  = "4I  FSCMD Retcode=0                                       "
SMRX.46  = "4W  FSCMD:Failure on CMD=<$$P1>,RC=$$P2                   "
/*     LMHELPER                                                      */
SMRX.47  = "4I  __________REQUEST : $$P1                              "
SMRX.48  = "4I  _________LIB FROM : $$P1                              "
SMRX.49  = "4I  ___________LIB TO : $$P1                              "
SMRX.50  = "4I  _____________ITEM : $$P1                              "
SMRX.51  = "4E  LMMNGR:Parameter selection failed                     "
SMRX.52  = "4E  LMMNGR:Function selection failed                      "
SMRX.53  = "4W  Some trace records suppressed for LMGET OP            "
SMRX.54  = "4W  EXMEMACT : Member $$P1 found. Add failed              "
SMRX.55  = "4I  EXMEMACT : reopen target library for OUTPUT           "
SMRX.56  = "4W  Some trace records suppressed for LMPUT OP            "
SMRX.57  = "4I  EXCOPY: member $$P1 Is being added/replaced           "
SMRX.58  = "4I  EXCOPYNR: member $$P1 is not replaced                 "
SMRX.59  = "4I  EXCOPYNR: member $$P1 is being added                  "
SMRX.60  = "4I  Executing $$P1                                        "
SMRX.61  = "4I  LMCMD completed with RC=0                             "
SMRX.62  = "4W  $$P1 completed with RC=$$P2                           "
SMRX.63  = "4I  $$P1 error message: $$P1 $$P2                         "
/*     SETENVV                                                       */
SMRX.64  = "1I  Overriden $$P1 : $$P2                                 "
SMRX.65  = "1I  Default $$P1 : $$P2                                   "
/*  HARD ERROR MESSAGE                                               */
SMRX.66  = "1E  Unrecoverable error detected                          "
SMRX.67  = "1E  Unexpected RETURN CODE $$P1 from APPL $$P2            "
SMRX.68  = "                                                          "
SMRX.69  = "                                                          "
SMRX.70  = "                                                          "
/*                                                                   */
SMRX.71  = "001 Could not find HEAP reference  $$P1                   "
SMRX.72  = "025 SMPEMNGR detected error at entrance of $$P1           "
SMRX.73  = "029 SMPEMNGR:SMPEAPI GIMAPI failed with internal error ER "
SMRX.74  = "030 SMPEMNGR:SMPEAPI GIMAPI failed with internal error EOF"
SMRX.75  = "032 SMPEMNGR:SMPEAPI Wrong parameter required             "
SMRX.76  = "043 FSHELPER:Wrong parameter required                     "
SMRX.77  = "046 FSHELPER:Failure on CMD=<$$P1>,RC=$$P2                "
SMRX.78  = "051 LMHELPER:Wrong parameter required                     "
SMRX.79  = "052 LMHELPER:Wrong function required                      "
SMRX.80  = "053 LMHELPER:few messages suppressed for LMGET Operation  "
SMRX.81  = "054 LMHELPER:Add member $$P1 failed                       "
SMRX.82  = "056 LMHELPER:few messages suppressed for LMPUT Operation  "
SMRX.83  = "062 LMHELPER:Request $$P1 commpleted with code $$P2       "
SMRX.84  = "066 Unrecoverable error detected. Terminating             "
SMRX.85  = "067 Unexpected RETURN CODE $$P1 from APPL $$P2            "

SMRX.0  =  85
return
GETPROLOG : PROCEDURE expose prolog.
prolog.1 = "COPYLIB='SUMRX.APPL.COPY'"
prolog.2 = "SUMRXLIB='SUMRX.V201.FWLIB'"
prolog.3 = "INJRDY='SUMRX.COMPLED.LIB(SPWCHDOG)'"
prolog.0=3
return
INJREXX : PROCEDURE EXPOSE how_parm
/* REXX */
/********************************************************/
/*  It serves as a source code binder . It :            */
/*  1. Builds a program from library members as parts.  */
/*     Each such part referred by ++INC . Nesting is    */
/*     supported.                                       */
/*  2. Injects dynamic values of current source lib ,   */
/*     message level and external parms from SYSTSIN.   */
/*  3. Since pipe stage/cmd REXX destroys ISPF env.     */
/*     it builds a program aside in a temporary file    */
/*     and then EXECs it from the file.                 */
/*  4. Appends itself to the called program as routine  */
/*     in order to call it from the current REXX and    */
/*     pass regular and external parms to the higher    */
/*     level REXX by prepending them to the 2nd+ LVL    */
/*     program.                                         */
/*  5. Supports dynamic external parameters from  DD    */
/*     SYSTGIN. It passes them to 2nd+ level routines   */
/*     by creating GETPROLOG routine with parameters    */
/*     assignments dynamically on-the-fly.              */
/*                                                      */
/*  How it works :                                      */
/*  We should distinguish between the 1st level program */
/*  that is called by TSO EXEC and the 2nd and hiigher  */
/*  (2nd+) levels program that called form the 1st or   */
/*  lower level program.                                */
/*  1st LVL :  the program entered and then calls       */
/*             injector (INJREXX). INJREXX performs     */
/*             the above written actions.The program    */
/*             immediately exits after injector return. */
/*             HOW_PARM is not passed via EXPOSE        */
/*             ad it's set to LIT ,since INJREXX called */
/*             as external routine                      */
/*                                                      */
/*  2nd+ LVL:  It's called via CALLEXEC routine. This   */
/*             routine directly calls injector and it   */
/*             prepares the 2nd+ LVL program to run as  */
/*             written in above (1-4).                  */
/*             HOW_PARM passed via EXPOSE will contain  */
/*             the proper value                         */
/*                                                      */
/*  1st LVL can get external parameters from SYSTSIN.   */
/*  It passes them to the 2nd level injector in arg(2). */
/*  External parameters are supported in TSO BACKGROUND */
/*  only.                                               */
/*  sysvar('SYSENV') is used to query the TSO run in    */
/*         FOREGROUND or BACKGROUND                     */


/*  Consider invocation method       */
if symbol('how_parm') = "LIT"
  then do       /* 1st LVL */
       parse source . . . . . . how_parm .
       end      /* 1st LVL */
if how_parm = 'TSO'
  then
    CMDPIPE_CONSTANT="PIPE"
  else
    CMDPIPE_CONSTANT="CALLPIPE"

parms = arg(1)
parse var parms rexxname  rexxlib  msg_level  exec_parm

injector  = "INJREXX"

exec_file_mode = "PERM"   /* keep the built source in disk        */
exec_file_mode = "TEMP"   /* do not keep the built source in disk */

pipemode = 1
if pipemode = 1
  then
    say "SUMRX v201 INJECTOR started in PIPE mode"
  else
    say "SUMRX v201 INJECTOR started in NOPIPE mode"

/* REXX PROGRAM can be traced by either one of the following :     */
/*   1. by REXX SAY command to TSO TERMINAL in FOREGROUND.         */
/*   2. by REXX SAY command to TSO SYSTSPRT DD in BACKGROUND.      */
/*   3. We added an option for 3270 screen application             */
/*      to be traced into TSO DD TRM3270. For that we use the 2nd  */
/*      parameter of INJECTOR which was already in use earlier.    */
/* In earlier phases of the development the 2nd PARM of INJECTOR   */
/* was used to pass EXTERNAL PARMS to subsequent REXX calls with   */
/* the INJECTOR (so-called 2nd+ call level).                       */
/* Now we overcharged 2ND PARM to have also indicate trace to      */
/* TSO DD TRM3270.                                                 */
/* Thus, 2nd INJECTOR parameter finally will serve to either one:  */
/* 1.Pass EXTERNAL PARMS from SYSTGIN or to 2nd+ level via stem    */
/*   PROLOG by GETPROLOG routine.                                  */
/*   Used only in TSO BAKGROUND MODE.                              */
/* 2.Pass trace mode BATCH or ONLINE to the INJECTOR.              */
/*   Used only in TSO FOREGROUND mode.                             */
/*   EXTERNAL PARMS do not have meaning in FOREGROUND mode !!!     */
/* 3.Since SUMRX 2.01 2nd Parm possible values                     */
/*   In word 1 :                                                   */
/*   - 3270 ,   1st level of 3270 application                      */
/*   - ONLINE , 2nd level of 3270 application                      */
/*   - not either of 2 above , 2nd level of BATCH application      */
/*   In word 2 :                                                   */
/*   - "heap share mode"_"heap image filename"                     */
/*   Possible cases :                                              */
/*   SHR_<filename>    -  levels share HEAP                        */
/*   SEP_<filename>    -  levels have separate HEAPs               */
/*   CPY_<filename>    -  changes made in callee not visible to    */
/*                        caller                                   */
/*                                                                 */

mode = "BATCH"
if arg(2) <> ""
  then   /* BG-FG 2nd+ level or FG 1st level 3270 */
    do
    if sysvar('SYSENV')  = "BACK"
      then      /* External parameter in BATCH */
         do
         run_level = 2
         HEAP_SHR   = GET_HEAP_SHARE_MODE(arg(2))
         HEAP_IMAGE = GET_HEAP_IMAGE_FILE(arg(2))
         call GETPROLOG
         end
      else      /* ONLINE mode or 2nd level BATCH FG */
         do
         prolog.0 = 0
         if word(arg(2),1) = "3270"
          then  /* 3270 1st level */
           do
           mode = "ONLINE"
           run_level = 1
           end
          else
           if word(arg(2),1) = "ONLINE"
            then  /* 3270 2nd level */
             do
             mode = "ONLINE"
             run_level = 2
             HEAP_SHR   = GET_HEAP_SHARE_MODE(arg(2))
             HEAP_IMAGE = GET_HEAP_IMAGE_FILE(arg(2))
             end
            else  /* BATCH FG 2nd Level */
             do
             mode = "BATCH"
             run_level = 2
             HEAP_SHR   = GET_HEAP_SHARE_MODE(arg(2))
             HEAP_IMAGE = GET_HEAP_IMAGE_FILE(arg(2))
             end
         end
     /* store parms in routine for next nesting call */
     call INJ_FILL_PROLOG_SOURCE
    end
  else   /* 1st LVL */
   do
    HEAP_IMAGE = "NO_HEAP_IMAGE"
    /* prepare command from TSO SYSTSIN file  */
    if sysvar('SYSENV')  = "BACK"
      then   /* BG , get external parameters */
       do
       run_level = 1
       "EXECIO * DISKR SYSTGIN (STEM prolog. FINIS"
       if prolog.0 <> 0
        then
         do
          do i = 1 to prolog.0
          prolog.i = substr(prolog.i,1,72)
          end
         end
       end
      else   /* FG , no external parameters */
        do
        run_level = 1
        prolog.0 = 0
        end

     /* store parms in routine for 1st nesting call */
     call INJ_FILL_PROLOG_SOURCE
   end

if run_level = 1
 then do
g=' '
say g
g='SummeRx framework for REXX in z/OS, ver 2.01. Sailpoint Technologies'
say g
g='--------------------------------------------------------------------'
say g
g='Copyright 2018-2020. Gennady Lapidus, summerexx@gmail.com           '
say g
g='This program is free software: you can redistribute it and/or modify'
say g
g='it under the terms of the GNU General Public License as published by'
say g
g='the Free Software Foundation, either version 3 of the License, or   '
say g
g='(at your option) any later version.                                 '
say g
g='This program is distributed in the hope that it will be useful,     '
say g
g='but WITHOUT ANY WARRANTY; without even the implied warranty of      '
say g
g='MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       '
say g
g='GNU General Public License for more details.                        '
say g
g='You should have received a copy of the GNU General Public License   '
say g
g='along with this program. If not, see <http://www.gnu.org/licenses/>.'
say g
g=' '
say g
end

/* enable both invoke methods: EXEC from FORE and BACKGROUND */
if rexxlib="?"
   then do
        'PROFILE NOPREFIX'
        RET = LISTDSI('SYSEXEC' ' FILE')
  /*    rexxlib = "'"SYSDSNAME"'" */
        rexxlib =    SYSDSNAME
        end

/* get name of user search library COPYLIB */
copylib   = INJ_GET_VAR_FROM_SETBASE('COPYLIB',rexxlib,rexxname)
if copylib = ''
   then
     copylib = rexxlib

/* get name of user search library SUMRXLIB */
sumrxlib = INJ_GET_VAR_FROM_SETBASE('SUMRXLIB',rexxlib,rexxname)
if sumrxlib = ''
   then
     sumrxlib = copylib

/* reset ALTLIB to COPYLIB at 1st level of FG */
if sysvar('SYSENV')  = "FORE" &  run_level = 1
 then
   do
   "ALTLIB reset"
    x =  outtrap('stats.')
    address tso "listalc status"
    x =  outtrap('OFF')
   /* check if copylib is in SYSEXEC */
   copylib_found_in_list = 0
   do i = 1 to stats.0
   line = stats.i
   if word(line,1) = "SYSEXEC"
      then
        do
        i = i + 1
        line = stats.i
        if word(line,1) = copylib
         then
           do
           copylib_found_in_list = 1
           leave
           end
        end
   end

   if copylib <> rexxlib & copylib_found_in_list = 0
     then
      "altlib activate appl(exec) da("copylib")"
   end


/* resolve ++INC dependencies  */
if INJ_RESOLVE_INC() <> 0
  then
    return 8

/* care of 3270 session if requested  */
if mode = "ONLINE" /* 3270 session ? */
   then
     do /* 3270 */
     /* prepare 3270 session */
     if INJ_PREPARE_3270() <> 0
       then
         return 8
     end /* 3270 */
   else
     do  /* not 3270 */
     if sysvar('SYSENV')  = "BACK"
      then
       do
       x = outtrap(hole.)
       "ALLOCATE DD(SYSFWPRT) SYSOUT"
       "ALLOCATE DD(SYSEXPRT) SYSOUT"
       x = outtrap("OFF")
       end
     insert_trc_pl =""
     end /* not 3270 */


 /* inject code dynamically */
 if INJ_INS_CODE() <> 0
   then
     return 8

 /* get value of parameter INJRDY */
 INJRDY   = INJ_GET_VAR_FROM_SETBASE('INJRDY',rexxlib,rexxname)
 if  symbol('INJRDY')  <> "LIT"    & ,
     INJRDY            <> "INJRDY" & ,
     translate(INJRDY) <> "NO"     & ,
     strip(INJRDY)     <> ''
   then   /* save ready source in file */
     do
     retcode = INJ_SAVE_REXX_IN_FILE(INJRDY)
     return retcode
     end
   else   /* execute created source  */
     do
     /* execute created REXX program from stem CONTENT. */
     retcode=INJ_EXEC_REXX_FROM_STEM(exec_parm)

     if mode <> "ONLINE"
       then
         say "=== User REXX "rexxname" Completed with code" retcode

    /* the injected program returns control */
    if mode = "ONLINE"
       then
         do
          if INJ_DESTROY_3270() <> 0
            then
              return 8
         end
    /* INJECTOR returns control to the caller */
    return retcode
    end



/***********************************************************/
/*                                                         */
/*  Resolve ++INC dependencies and suppress call INJECTOR  */
/*                                                         */
/***********************************************************/
INJ_RESOLVE_INC : procedure expose rexxlib copylib sumrxlib prolog.    ,
                                   rexxname injector content. pipemode ,
                                   exec_file_mode
fw_anchor = GET_SMRX_ANCHOR_HELPER_NAME()
setbase = strip(INJ_FIND_SETBASE(rexxlib,rexxname))
if setbase = ''
  then
    do
    say "SUMRX: Could not find base configuration element"
    exit 8
    end

if pipemode = 1
 then
   do /* pipemode on */
    source_start= "  members"  rexxlib  rexxname            ||,
                  "| drop last 1                          " ||,
                  "| change /INJ"||"STUB/INJ"||"STUB_NA/  " ||,
                  "| append literal ++INC" fw_anchor        ||,
                  "| l:nlocate w2 /"setbase",ENV/         " ||,
                  "| f:faninany                           " ||,
                  "| s:fanout                             " ||,
                  "| hole                                 " ||,
                  "?"                                       ||,
                  "l:"                                      ||,
                  "| specs                                " ||,
                  "   /callpipe (stagesep $ endchar @)/ 1 " ||,
                  "     /  stem prolog./               nw " ||,
                  "     /$ append literal/ nw w1-* nw     " ||,
                  "     /$ *.output:/                  nw " ||,
                  "| pipcmd                               " ||,
                  "| f:                                   " ||,
                  "?"                                       ||,
                  "s:"
    source_cont = " stem content_copy. "

    source_eyecatcher = source_start
    /* resolve ++INC */
    /* search of ++INC members in order REXXLIB COPYLIB SUMRXLIB  */
    do forever   /*  loop until all ++INC are resolved */
    inccount=0
    LPIPE() "(endchar ?)                                          " ||,
            source_eyecatcher                                       ||,
            "| chop 72                                            " ||,
            "| a: not locate w1 /++INC/                           " ||,
            "| m: faninany                                        " ||,
            "| stem content.                                      " ||,
            "? "                                                    ||,
            "a:"                                                    ||,
            "| b:count lines                                      " ||,
            "| change /,ENV//                                     " ||,
            "| specs w2 1  /'/ 16  w2 17  /'/ 25                  " ||,
            "| ndyn:find &"                                         ||,
            "| specs 2-* 1                                        " ||,
            "| xlate upper                                        " ||,
            "| specs /callpipe (stagesep $ endchar @)/ 1          " ||,
            "        /  members "rexxlib  setbase"/            nw " ||,
            "        /$ drop last 1/                           nw " ||,
            "        /$ append literal 'output'/               nw " ||,
            "           /injstm./ nw w1 n w1 nw                   " ||,
            "        /$ append literal EXIT/                   nw " ||,
            "        /$ append literal MSG: PROCEDURE/         nw " ||,
            "        /$ append literal RETURN 0/               nw " ||,
            "        ,$ literal /* REXX */,                    nw " ||,
            "        /$ change 1.4 ,MSG(, MSG(,/               nw " ||,
            "        /$ change     , MSG(,RC=MSG(,/            nw " ||,
            "        /$ not locate w1 ,++INC,/                 nw " ||,
            "        /$ chop 72/                               nw " ||,
            "        /$ rexx *:/                               nw " ||,
            "        /$ *.output:/                             nw " ||,
            "| pipcmd                                             " ||,
            "| dyn:fanout                                         " ||,
            "| hole                                               " ||,
            "? "                                                    ||,
            "fan:"                                                  ||,
            "  faninany                                           " ||,
            "| proc:fanout                                        " ||,
            "| hole                                               " ||,
            "? "                                                    ||,
            "ndyn:"                                                 ||,
            "| fan:                                               " ||,
            "? "                                                    ||,
            "dyn:"                                                  ||,
            "| prt:fanout                                         " ||,
            "| specs w1 1  /'/ 16  w1 17  /'/ 25                  " ||,
            "| fan:                                               " ||,
            "? "                                                    ||,
            "prt:"                                                  ||,
            "| spec /:: = Var &/ 1 w2 n /substituted by/ nw w1 nw " ||,
            "| terminal                                           " ||,
            "? "                                                    ||,
            "proc:"                                                 ||,
            "| specs /callpipe (stagesep $ endchar @)/ 1          " ||,
             /*  If member is found in REXXLIB read it and  :       */,
             /*  - issue messsage about REXXLIB stream              */,
             /*  - close GATE GRC to prevent streaming from COPYLIB */,
             /*  - close GATE GRS (via rs:) to prevent streaming    */,
             /*    from SUMRXLIB                                    */,
             "        /  listpds "rexxlib"/                    nw " ||,
             "        /$ chop 8          /                     nw " ||,
             "        /$ pick w1 ==/  nw /,/ nw w1 n /,/ n        " ||,
             "        /$ members "rexxlib"/                    nw " ||,
             "        /$ chop 72/                              nw " ||,
             "        /$ drop last 1/                          nw " ||,
             "        /$ r:fanout/                             nw " ||,
             "        /$ count lines/                          nw " ||,
             "        /$ pick f1 \== ,0,/                      nw " ||,
             "        /$ specs/ nw /,/ nw /:: Member/ n 16-25 nw  " ||,
             "          /loaded from "rexxlib"/ nw /,/ n /1/ nw   " ||,
             "        /$ change ,',,/                          nw " ||,
             "        /$ terminal/                             nw " ||,
             "        /$ rs:fanout/                            nw " ||,
             "        /$ GRC:gate /                            nw " ||,
             /*  read member from COPYLIB                           */,
             "        /@ /                                     nw " ||,
             "        /  listpds "copylib"/                    nw " ||,
             "        /$ chop 8          /                     nw " ||,
             "        /$ pick w1 ==/  nw /,/ nw w1 n /,/ n        " ||,
             "        /$ members "COPYLIB"/                    nw " ||,
             "        /$ chop 72/                              nw " ||,
             "        /$ drop last 1/                          nw " ||,
             "        /$ c:fanout/                             nw " ||,
             "        /$ hole  /                               nw " ||,
             /*  read member from SUMRXLIB                          */,
             "        /@ /                                     nw " ||,
             "        /  listpds "sumrxlib"/                   nw " ||,
             "        /$ chop 8          /                     nw " ||,
             "        /$ pick w1 ==/  nw /,/ nw w1 n /,/ n        " ||,
             "        /$ members "sumrxlib"/                   nw " ||,
             "        /$ chop 72/                              nw " ||,
             "        /$ drop last 1/                          nw " ||,
             "        /$ s:fanout/                             nw " ||,
             "        /$ hole  /                               nw " ||,
             /*  collect read member content and yield it           */,
             "        /@ /                                     nw " ||,
             "        /  o:fanin 1 2 3/                        nw " ||,
             "        /$ *.output:/                            nw " ||,
             /*  try streaming COPYLIB through GATE GRC             */,
             "        /@ /                                     nw " ||,
             "        /c:/                                     nw " ||,
             "        /$ c1:fanout/                            nw " ||,
             "        /$ GRC:/                                 nw " ||,
             "        /$ c2:fanout/                            nw " ||,
             "        /$ o:/                                   nw " ||,
             /*  routing REXXLIB stream to out                      */,
             "        /@ /                                     nw " ||,
             "        /r:/                                     nw " ||,
             "        /$ r1:fanout/                            nw " ||,
             "        /$ buffer/                               nw " ||,
             "        /$ o:/                                   nw " ||,
             /*  evaluate total size of all streams                 */,
             "        /@ /                                     nw " ||,
             "        /  count:faninany/                       nw " ||,
             "        /$ count lines /                         nw " ||,
             "        /$ h:pick f1 == ,0,/                     nw " ||,
             "        /$ specs/ nw /,/ nw /** Error: Member/ n    " ||,
             "           16-25 nw /not found/ nw /,/ n /1/ nw     " ||,
             "        /$ change ,',,/                          nw " ||,
             "        /$ terminal/                             nw " ||,
             "        /@ /                                     nw " ||,
             "        /h:/                                     nw " ||,
             "        /$ hole/                                 nw " ||,
             /*  routing COPYLIB stream to size evaluation          */,
             "        /@ /                                     nw " ||,
             "        /c1:/                                    nw " ||,
             "        /$ count:/                               nw " ||,
             /*  COPYLIB stream passed through GATE GRC of REXXLIB  */,
             /*  If this stream is not empty :                      */,
             /*      - issue messsage about COPYLIB stream          */,
             /*      - close GATE GCS to prevent SUMRXLIB stream    */,
             "        /@ /                                     nw " ||,
             "        /c2:/                                    nw " ||,
             "        /$ count lines /                         nw " ||,
             "        /$ pick f1 \== ,0,/                      nw " ||,
             "        /$ specs/ nw /,/ nw /:: Member/ n 16-25 nw  " ||,
             "          /loaded from "copylib"/ nw /,/ n /1/ nw   " ||,
             "        /$ change ,',,/                          nw " ||,
             "        /$ terminal/                             nw " ||,
             "        /$ GCS:gate/                             nw " ||,
             /*  routing REXXLIB stream to size evaluation          */,
             "        /@ /                                     nw " ||,
             "        /r1:/                                    nw " ||,
             "        /$ count:/                               nw " ||,
             /*  Not empty REXXLIB stream closes GATE GRS here to   */,
             /*  prevent SUMRXLIB streaming                         */,
             "        /@ /                                     nw " ||,
             "        /rs:/                                    nw " ||,
             "        /$ GRS:gate/                             nw " ||,
             /*  routing SUMRXLIB stream to out only if member      */,
             /*  was not found in either REXXLIB or COPYLIB         */,
             /*  Notice that SUMRXLIB stream is locked by 2 gates:  */,
             /*  - GRS , by REXXLIB                                 */,
             /*  - GCS , by COPYLIB                                 */,
             "        /@ /                                     nw " ||,
             "        /s:/                                     nw " ||,
             "        /$ s1:fanout/                            nw " ||,
             "        /$ GRS:/                                 nw " ||,
             "        /$ GCS:/                                 nw " ||,
             "        /$ s2:fanout/                            nw " ||,
             "        /$ o:/                                   nw " ||,
             /*  routing SUMRXLIB stream to size evaluation         */,
             "        /@ /                                     nw " ||,
             "        /s1:/                                    nw " ||,
             "        /$ count:/                               nw " ||,
             /*  if SUMRXLIB strem is not empty, issue message      */,
             "        /@ /                                     nw " ||,
             "        /s2:/                                    nw " ||,
             "        /$ count lines /                         nw " ||,
             "        /$ pick f1 \== ,0,/                      nw " ||,
             "        /$ specs/ nw /,/ nw /:: Member/ n 16-25 nw  " ||,
             "         /loaded from "sumrxlib"/ nw /,/ n /1/ nw   " ||,
             "        /$ change ,',,/                          nw " ||,
             "        /$ terminal/                             nw " ||,
            "| pipcmd                                             " ||,
            "| m:                                                 " ||,
            "? "                                                    ||,
            "b:"                                                    ||,
            "| var  inccount                                      "

    if inccount=0
      then
        leave
    /* work with copy of stem between iterations  */
     LPIPE() " (endchar ?)                       " || ,
             "  stem content.                    " || ,
             "| stem content_copy.               "

    source_eyecatcher = source_cont
    end  /*  loop until all ++INC are resolved */
   end   /* pipemode on */
 else
   do  /* pipemode off */
    /* check existence of main program */
    dsname = rexxlib"("rexxname")"
    rc=SYSDSN(dsname); if rc='OK' then rc=0;
    if rc <> 0
     then
       return 8

    /* here we set CONTENT. = <REXX>  with  appended   */
    /* to it cards of :                                */
    /* "++INC REXXNAME"                                */

    content.1 = "/* REXX */"
    /* when calling recursive injector ++INC card should be last */
    /* and index of CONTENT array should point to -1 place of it */
    content.2  = "++INC" rexxname
    content.0  = 2
    if INJ_RECURSIVE_INC(1) <> 0
      then
        return 8

    /* Insert SUMRX Anchor                             */
    /* "++INC FW_ANCHOR"                               */
    /* when calling recursive injector ++INC card should be last */
    /* and index of CONTENT array should point to -1 place of it */
    content.0 = content.0 + 1
    ix_fwan = content.0
    interpret "content."ix_fwan " = '++INC "fw_anchor"'"
    if INJ_RECURSIVE_INC(content.0 - 1) <> 0
      then
        return 8

   end /* pipemode off */


return 0

/***********************************************************/
/*                                                         */
/*  Inject code dynamically                                */
/*                                                         */
/***********************************************************/
INJ_INS_CODE: procedure expose insert_trc_pl exec_parm content. dsn   ,
                               injector rexxlib prolog_source.        ,
                               copylib sumrxlib                       ,
                               msg_level mode pipemode INJ@327X       ,
                               CMDPIPE_CONSTANT HEAP_IMAGE HEAP_SHR
 /* here we append the injector code after all changes done. */
 /* this gurantees the injector code will not be changed.    */

if pipemode = 1
 then
   do /* pipemode on */
   LPIPE() "(endchar ?)                                      " ||,
           /*  the script code with expanded ++INCs            */,
           "  stem content.                                  " ||,
           "| change 1.4 /MSG(/ MSG(/                        " ||,
           "| change / MSG(/RC=MSG(/                         " ||,
           "| change /MSG_MESSAGES_TRACE_LEVEL=INJDATA"        ||,
                    "/MSG_MESSAGES_TRACE_LEVEL="msg_level"/"   ||,
           "| change /MSG_MESSAGES_TRACE_MODE=INJMODE"         ||,
                    "/MSG_MESSAGES_TRACE_MODE="mode"/"         ||,
           "| change /PIPEMODE_PIPE_INJECTED=INJDATA"          ||,
                    "/PIPEMODE_PIPE_INJECTED="pipemode"/"      ||,
            insert_trc_pl                                      ||,
           "| f:fanin                                        " ||,
           "| pad  100                                       " ||,
           "| chop 100                                       " ||,
           "| stem content_copy.                             " ||,
           /*  creating GETPROLOG routine and appending it     */,
           "? "                                                ||,
           "  stem prolog_source.                            " ||,
           "| chop 72                                        " ||,
           "| literal GETPROLOG : PROCEDURE expose prolog.   " ||,
           "| append literal return                          " ||,
           "| f:                                             " ||,
           /*  appending INJECTOR routine with right LIB name  */,
           "? "                                                ||,
           "  members" sumrxlib injector                       ||,
           "| drop last 1                                    " ||,
           "| chop 72                                        " ||,
           "| literal "injector" : PROCEDURE EXPOSE how_parm " ||,
           "| change /SOURCE_LIB_DYN="||"INJDATA"              ||,
                    "/SOURCE_LIB_DYN='"rexxlib"'/"             ||,
           "| change /CMDPIPE_VAR="||"INJDATA"                 ||,
                    "/CMDPIPE_VAR="CMDPIPE_CONSTANT"/"         ||,
           "| change /HEAP_IMAGE_FILE="||"INJDATA"             ||,
                    "/HEAP_IMAGE_FILE='"HEAP_IMAGE"'/"         ||,
           "| change /HEAP_SHARE="||"INJDATA"                  ||,
                    "/HEAP_SHARE='"HEAP_SHR"'/"                ||,
           "| f:                                             "

    LPIPE() " (endchar ?)                       " || ,
            "  stem content_copy.               " || ,
            "| stem content.                    "
   end /* pipemode on */
 else
  do  /* pipemode off */
   /* make changes in the main stream */
   do i = 1 to content.0
   content.i = INJ_STR_REPL(content.i,"MSG("," MSG(",1)
   content.i = INJ_STR_REPL(content.i," MSG(","RC=MSG(")
   content.i =                                                         ,
            INJ_STR_REPL(content.i,"MSG_MESSAGES_TRACE_LEVEL=INJDATA", ,
                               "MSG_MESSAGES_TRACE_LEVEL="msg_level)
   content.i =                                                         ,
            INJ_STR_REPL(content.i,"MSG_MESSAGES_TRACE_MODE=INJMODE",  ,
                               "MSG_MESSAGES_TRACE_MODE="mode)
   content.i =                                                         ,
            INJ_STR_REPL(content.i,"PIPEMODE_PIPE_INJECTED=INJDATA",   ,
                               "PIPEMODE_PIPE_INJECTED="pipemode)
   if insert_trc_pl <> ""
    then
     content.i =                                                       ,
            INJ_STR_REPL(content.i,"MSG_MESSAGES_TRACE_SESSION=''",    ,
                               "MSG_MESSAGES_TRACE_SESSION=."INJ@327X)
   end

   /* append GETPROLOG procedure */
   k = content.0 + 1
   content.k = "GETPROLOG : PROCEDURE expose prolog."
   do i = 1 to prolog_source.0
   k = content.0 + 1 + i
   content.k = prolog_source.i
   end
   k = content.0 + 1 + prolog_source.0 + 1
   content.k = "RETURN"

   /* append INJECTOR code itself */
   k = k + 1
   content.k = injector" : PROCEDURE EXPOSE how_parm"
   dsname = sumrxlib"("injector")"
   k = k + 1
   content.0 = k
   call INJ_INSERT_MEMBER dsname , k
   do i = k to content.0
   content.i = substr(content.i,1,72)
   content.i = INJ_STR_REPL(content.i,"SOURCE_LIB_DYN="||"INJDATA",   ,
                                      "SOURCE_LIB_DYN='"rexxlib"'")
   content.i = INJ_STR_REPL(content.i,"CMDPIPE_VAR="||"INJDATA",      ,
                                      "CMDPIPE_VAR="CMDPIPE_CONSTANT)
   content.i = INJ_STR_REPL(content.i,"HEAP_IMAGE_FILE="||"INJDATA",   ,
                                      "HEAP_IMAGE_FILE='"HEAP_IMAGE"'")
   content.i = INJ_STR_REPL(content.i,"HEAP_SHARE="||"INJDATA",   ,
                                      "HEAP_SHARE='"HEAP_SHR"'")
   end
  end /* pipemode off */

 return 0

/***********************************************************/
/*                                                         */
/*  Prepare 3270 session                                   */
/*                                                         */
/***********************************************************/
INJ_PREPARE_3270 : procedure expose insert_trc_pl INJ@327X pipemode
 /* support a number of logical ISPF sessions */
 varlist = "INJ@327X"
 "ISPEXEC VGET (&varlist) PROFILE"
 /* INJ@327X kept across TSO sessions due to PROFILE spool */
 /* So, for the 1st time in new TSO session it may happen  */
 /* that INJ@327X is numeric but TRM3270 is not allocated  */
 RET = LISTDSI('TRM3270' ' FILE')
 if SYSREASON <> 3      /* RET is always 16 due to SYSOUT */
    then   /* not allocated to sysout */
      do
      INJ@327X = "NO"   /* any no NUM type value */
      end

 if datatype(INJ@327X) <> "NUM"
   then
     do   /* first 3270 consumer */
      X = OUTTRAP(STM.)
      /* force delete DD TRM3270 */
      "FREE DD(TRM3270) DELETE"
      /* allocate new spool file TRM3270 under TSO */
      "ALLOCATE DD(TRM3270) SYSOUT"
      X = OUTTRAP("OFF")
      INJ@327X = 1
     end  /* first 3270 cinsumer */
   else
     do   /* not first 3270 consumer */
      INJ@327X = INJ@327X + 1
     end  /* not first 3270 consumer */
 /* update ISPF sessions number */
 "ISPEXEC VPUT (&varlist) PROFILE"
 if pipemode = 1
   then
     insert_trc_pl ="| change /MSG_MESSAGES_TRACE_SESSION=''" ||,
                    "/MSG_MESSAGES_TRACE_SESSION=."INJ@327X"/"
   else
     do
     insert_trc_pl =""
     end
 return 0


/***********************************************************/
/*                                                         */
/*  Destroy 3270 session                                   */
/*                                                         */
/***********************************************************/
INJ_DESTROY_3270 : procedure expose INJ@327X
 /* support a number of logical ISPF sessions */
 varlist = "INJ@327X"
 if datatype(INJ@327X) <> "NUM"
   then
     do   /* internal error */
     say injector": TRM3270 logical error encountered"
     end
   else
    do   /* TRM3270 active  */
    "ISPEXEC VGET (&varlist) PROFILE"
    INJ@327X = INJ@327X - 1
    if INJ@327X = 0
      then
        do
         /* erase ISPF sessions number */
         "ISPEXEC VERASE (&varlist) PROFILE"
         /* reset vars        */
         drop (varlist)
         drop (INJ@327X)
        end
      else
       do
       /* update ISPF sessions number */
       "ISPEXEC VPUT (&varlist) PROFILE"
       end
    end  /* TRM3270 active */
return 0

/********************************************************************/
/* This routine returns value of desired VAR which is set in member */
/* <mem> of preprocessor directive "++INC <mem>,ENV"                */
/* Before executing it converts member <mem> to a REXX roitine in   */
/* SAFE mode : MSG and ++INC directives are ignored                 */
/********************************************************************/
INJ_GET_VAR_FROM_SETBASE: procedure expose prolog. pipemode injector ,
                                    exec_file_mode setbase
 varname  = arg(1)
 rexxlib  = arg(2)
 rexxname = arg(3)
 uservar  = ''

 setbase = INJ_FIND_SETBASE(rexxlib,rexxname)
 if setbase = ''
   then
     return ''


mem = strip(setbase)
if pipemode = 1
 then
   do  /* pipemode on */
   LPIPE() "(endchar ?)                       " ||,
           "  members "rexxlib mem              ||,
           "| drop last 1                     " ||,
           "| f:fanin 1 0                     " ||,
           "| append literal 'output'" varname  ||,
           "| append literal EXIT             " ||,
           "| append literal MSG: PROCEDURE   " ||,
           "| append literal RETURN 0         " ||,
           "| change 1.4 /MSG(/ MSG(/         " ||,
           "| change     / MSG(/RC=MSG(/      " ||,
           "| not locate w1 /++INC/           " ||,
           "| chop 72                         " ||,
           "| rexx *:                         " ||,
           "| var uservar                     " ||,
           "?"                                  ||,
           "  stem prolog.                    " ||,
           "| literal /* REXX */              " ||,
           "| f:                              "
   end /* pipemode on */
 else
   do  /* pipemode off */
   /* insert PROLOG. */
   content.1 = "/* REXX */"
   content.0 = 1
   if prolog.0 > 0
    then
      do
       do i = 1 to prolog.0
       k = i + 1
       content.k =  prolog.i
       end
       content.0 = prolog.0 + 1
     end
    /* insert <mem> */
    dsname = rexxlib"("mem")"
    content.0 = content.0  + 1
    rc=SYSDSN(dsname); if rc='OK' then rc=0;
    if rc = 0
      then
       call INJ_INSERT_MEMBER dsname , content.0
    /* convert to valid REXX program code */
    k = content.0
    k=k+1; content.k = "INJUVAR ="varname;
    k=k+1; content.k = 'varlist = "INJUVAR"'
    k=k+1; content.k = '"ISPEXEC VPUT (&varlist) PROFILE"'
    k=k+1; content.k = "RETURN 0"        ;
    k=k+1; content.k = "MSG : PROCEDURE" ;
    k=k+1; content.k = "RETURN 0"        ;
    content.0 = k
    /* suppress ++INC and make MSG dummy  */
    do i = 1 to content.0
    content.i = substr(content.i,1,72)
    if substr(content.i,1,5) = "++INC"
      then
        content.i = " "
    content.i = INJ_STR_REPL(content.i,"MSG(","RC=MSG(")
    end
    rc=INJ_EXEC_REXX_FROM_STEM()
    varlist = "INJUVAR"
    "ISPEXEC VGET (&varlist) PROFILE"
    uservar = INJUVAR
       "ISPEXEC VERASE (&varlist) PROFILE"
   end /* pipemode off */
 return uservar

/********************************************************************/
/* This routine returns base configuration element                  */
/********************************************************************/
INJ_FIND_SETBASE : procedure
 rexxlib  = arg(1)
 rexxname = arg(2)
 /* find "++INC <setbase>,ENV" and extract <setbase> */
 setbase = ''
 dsname = rexxlib"("rexxname")"
 content.0 = 1
 content.1 = " "
 rc=SYSDSN(dsname); if rc='OK' then rc=0;
 if rc = 0
   then
    call INJ_INSERT_MEMBER dsname , content.0
 do i = 1 to content.0
 if substr(content.i,1,5) = "++INC"
   then
     do
     parse var content.i "++INC" setbase "," type .
     if translate(type) = "ENV"
       then
          leave
       else
          setbase = ''
     end
 end
 drop content.
 return setbase

/********************************************************************/
/* This routine saves REXX in a file                                */
/* PARM   : dataset name                                            */
/* RETURN : return code of the execution                            */
/********************************************************************/
INJ_SAVE_REXX_IN_FILE : procedure expose content. rexxname
 dataset   = arg(1)
 "ALLOCATE  DA('"dataset"')"
 filename = INJ_GET_FILENAME_ALLOC_DSN(dataset)
 "EXECIO * DISKW" filename "(STEM content. OPEN FINIS"
 retcode = rc
 "FREE FI("filename")"
 if retcode = 0
   then
    say "INJ: save READY" rexxname "successful in file" dataset
   else
    say "INJ: save READY" rexxname "in  file" dataset "failed"
 return retcode

/********************************************************************/
/* This routine executes REXX from stem CONTENT.                    */
/* PARM   : exec paramteter                                         */
/* RETURN : return code of the execution                            */
/********************************************************************/
INJ_EXEC_REXX_FROM_STEM : procedure expose content. injector ,
                                    exec_file_mode rexxname
 exec_parm = arg(1)

 if exec_file_mode = "TEMP"
   then
     do
     dsn_yc = injector
     cmd_sfx = "DELETE"
     end
   else
     do
     dsn_yc = rexxname
     cmd_sfx = ""
     end

 /* calculate space */
 wtrk = (content.0 * 100 / 55996 + 1) * 1.15
 parse var wtrk TRKS "." .
 TRKS = TRKS + 1
 wtrk =  TRKS/16
 parse var wtrk TRKS_SEC "." .
 TRKS_SEC = TRKS_SEC + 1

 dsn =  INJ_GENERATE_TEMP_DSNAME(dsn_yc)
 /* allocate new file and store CONTENT in it */
 "ALLOCATE NEW UNIT(SYSDA) RECFM(F B) LRECL(100) DA('"dsn"')"    ,
           "BLKSIZE(5000) SPACE("TRKS","TRKS_SEC") TRACKS" cmd_sfx
 filename = INJ_GET_FILENAME_ALLOC_DSN(dsn)
 "EXECIO * DISKW" filename "(STEM content. OPEN FINIS"

 /* execute created REXX program from the file    */
 exec "'"dsn"'"   "'"exec_parm"'"
 retcode = rc
 "FREE DATASET('"dsn"')"
 return retcode

/*********************************************************************/
/* This routine creates PROLOG_SOURCE stem filled with REXX code and */
/* ready to be used as a routine GETPROLOG()                         */
/*********************************************************************/
INJ_FILL_PROLOG_SOURCE : procedure expose prolog. prolog_source.
 /* This is the REXX code to KEEP stem PROLOG. values */
 prolog_source.0 = prolog.0 + 1
  do i = 1 to prolog.0
  if pos("'",prolog.i) > 0
     then
       do
       prolog_source.i = "prolog."i "="  """"strip(prolog.i)""""
       end
     else
       do
       prolog_source.i = 'prolog.'i '=' ''''strip(prolog.i)''''
       end
  end
 i = prolog.0 + 1
 prolog_source.i = 'prolog.0=' ||  prolog.0

 return

/**********************************************************************/
/*     TSO EXEC of requested REXX with parameters                     */
/*     SOURCLE_LIB_DYN is for INJREXX injection                       */
/*                                                                    */
/*  PARMS : heap_share_mode                                           */
/*        : program_name appl_parm                                    */
/*                                                                    */
/*  How it works .                                                    */
/*       CALLER                      |         CALLEE                 */
/* APPL:INJ_CALLEXEC HEAP_SHR,PARM   |                                */
/* INJ_CALLEXEC :                    |                                */
/* -SERIALIZE_HEAP_TO_FILE(HEAP_SHR) |                                */
/* -Set 2nd word of 2nd parm to      |                                */
/*     HEAP_SHARE||"_"||HEAP_IMAGE   |                                */
/* -CALL INJREXX P1,P2               |                                */
/*                                   | INJECTOR :                     */
/*                                   | -Extracts from 2nd PARM        */
/*                                   |     HEAP_SHARE & HEAP_IMAGE    */
/*                                   |     and injects to INJSTUB     */
/*                                   | -DESERIALIZE_HEAP_FROM_FILE(   */
/*                                   |                 HEAP_IMAGE)    */
/*                                   | -CALL SUMRX_MAIN(P1)           */
/*                                   | -SERIALIZE_HEAP_TO_FILE(       */
/*                                   |                 HEAP_SHARE)    */
/*                                   |        and returns HEAP_IMAGE  */
/* -DESERIALIZE_HEAP_FROM_FILE(      |                                */
/*               HEAP_IMAGE)         |                                */
/* -Returns to APPL                  |                                */
/**********************************************************************/
INJ_CALLEXEC : procedure expose rexxlib msg_level HEAP.
SOURCE_LIB_DYN='SUMRX.APPL.EXEC'

HEAP_SHR =  translate(arg(1))
PARM2 = arg(2)
parse var PARM2 PROGRAM PARAMETER

parse value SERIALIZE_HEAP_TO_FILE(HEAP_SHR) with rcode HEAP_IMAGE .
if rcode <> 0
  then
    do
    say "SUMRX : Error detected during HEAP serialization"
    return 16
    end

/* 2nd parm is a clue to injector it's called on 2nd+ level in BG */
if sysvar('SYSENV')  = "BACK"
  then  /* BG */
   INJECT_DYN_CMD="*" SET_HEAP_MODE_FILE(HEAP_SHR,HEAP_IMAGE)
  else  /* FG */
   do
   varlist = "INJ@327X"
   "ISPEXEC VGET (&varlist) PROFILE"
   if datatype(INJ@327X) = "NUM"
    then
      INJECT_DYN_CMD="ONLINE" SET_HEAP_MODE_FILE(HEAP_SHR,HEAP_IMAGE)
    else
      INJECT_DYN_CMD="*" SET_HEAP_MODE_FILE(HEAP_SHR,HEAP_IMAGE)
   end

/* "exec '"SOURCE_LIB_DYN"("PROGRAM")' '"PARAMETER"'" */
/* address TSO */
p1 = PROGRAM SOURCE_LIB_DYN msg_level PARAMETER
p2 = INJECT_DYN_CMD
rc = INJREXX(p1,p2)

varlist = "INJACTRC"
"ISPEXEC VGET (&varlist) PROFILE"

parse var INJACTRC appl_code rcode HEAP_IMAGE .

"ISPEXEC VERASE (&varlist) PROFILE"

if rcode <> 0 | strip(HEAP_IMAGE) = ''
  then
    return appl_code

rc = DESERIALIZE_HEAP_FROM_FILE(HEAP_IMAGE)

return appl_code

/***********************************************************/
/* SUMRX will CHECK return code of the application whether */
/* APPL forgot to set it. For example : RETURN ''          */
/***********************************************************/
INJ_CHKCODE : procedure
  if datatype(arg(1)) <> "NUM"
    then
      do
      say "SUMRX ERROR: Unexpected APPLICATION CODE returned"
      RC=MSG('F',67,arg(1),arg(2)) /*Unexpected return code from appl*/
      return 8
      end
  return arg(1)

/***********************************************************/
/* Serialize heap to file                                  */
/* PARMS : heap share mode                                 */
/*   RET : 0 serialized_filename OR 8                      */
/***********************************************************/
SERIALIZE_HEAP_TO_FILE : procedure expose HEAP.
HEAP_SHR = arg(1)

if HEAP_SHR <> "SHR" & HEAP_SHR <> "SEP" & HEAP_SHR <> "CPY"  &  ,
   HEAP_SHR <> "DRP"
  then
    do
    say "SUMRX : Error in HEAP serialization request. Terminating"
    return 8
    end

if HEAP.0 = 0  | symbol('HEAP.0') = "LIT"
 then
   HEAP_SHR = "SEP"

if HEAP_SHR = "SEP"
  then
    return 0

return DO_HEAP_SERIALIZATION(HEAP_SHR)

/*********************************************************************/
/* Deserialize HEAP from file                                        */
/* PARM : file name                                                  */
/*  RET : 0                                                          */
/*********************************************************************/
DESERIALIZE_HEAP_FROM_FILE : procedure expose HEAP.
HEAP_IMAGE_FILE=arg(1)

SAY "SUMRX: HEAP deserialization started from filename" HEAP_IMAGE_FILE
 num_read = 0
 do while (1=1)
  "EXECIO 1 DISKR" HEAP_IMAGE_FILE "(STEM heap_item."
  if rc <> 0
    then
      do
      "EXECIO 0 DISKR" HEAP_IMAGE_FILE "(FINIS"
      "FREE FI("HEAP_IMAGE_FILE")"
      leave
      end
  num_read = num_read + 1
  interpret heap_item.1
 end
 SAY "SUMRX: HEAP has been deserialized from" num_read "records"
 return 0

/***********************************************************/
/* HEAP serialization                                      */
/* PARMS : heap share mode                                 */
/*   RET : 0 serialized_filename OR 8                      */
/***********************************************************/
DO_HEAP_SERIALIZATION : procedure expose HEAP.
HEAP_SHR = arg(1)

parse value GET_AND_PRINT_HEAP_STATISTICS(HEAP_SHR) with TRKS TRKS_SEC .

if HEAP_SHR <> "DRP"
 then
  do
  dsn_heap_image =  INJ_GENERATE_TEMP_DSNAME("HEAP")
  "ALLOCATE NEW UNIT(SYSDA) RECFM(V B) DA('"dsn_heap_image"')"  ,
            "BLKSIZE(5000) SPACE("TRKS","TRKS_SEC") TRACKS DELETE"

  /* find filename in LISTALC output */
  HEAP_IMAGE = INJ_GET_FILENAME_ALLOC_DSN(dsn_heap_image)
  say "SUMRX: HEAP serialization in" HEAP_SHR "mode started"
  end
 else
  do
  HEAP_IMAGE = ''
  end

/* serialize HEAP */
if HEAP_SERIALIZE_EXT(HEAP_SHR,HEAP_IMAGE) = 0
  then
    do
    if HEAP_IMAGE <> ''
     then
       do
       "EXECIO 0 DISKW" HEAP_IMAGE "(FINIS"
        say "SUMRX: HEAP has been serialized," SRLZ_REC "records added",
             "to file" HEAP_IMAGE
       end
     else
        say "SUMRX: HEAP has been dropped"
    return 0 HEAP_IMAGE
    end
  else
    do
    say "SUMRX: HEAP serialization failed"
    return 8
    end

/***********************************************************/
/* Get and print HEAP statistics                           */
/* PARM : HEAP SHARE mode                                  */
/*  RET : tracks tracks_secondary for SRLZ file alloc      */
/***********************************************************/
GET_AND_PRINT_HEAP_STATISTICS : procedure expose HEAP.
HEAP_SHR = arg(1)
rc =  GET_HEAP_STATISTICS_EXT()
if HEAP_SHR = "SHR" | HEAP_SHR = "CPY"
 then
  do
  st.l = right(st.l,4)        || ' '
  st.m = right(st.m,4)        || ' '
  st.o = right(st.o,4)        || '     '
  st.e = right(st.e,4)
  st.v = right(st.v,4)
  st.t = right(st.t,5)
  st.i = left(st.i,5)
  st.d = right(st.d,7)        || '  '
  st.s = right(st.s,4)        || ' '
  say "SumRx HEAP Statistics"
  say "+==============================================================="
  say "|                                   Meta/Appl            SRLZ  |"
  say "| Lists  Maps  Objs  Elements Vars    lines    Data(b)   trks  |"
  say "| .....  .... ...... ........ .... ........... .......   ....  |"
  say "| " st.l  st.m  st.o    st.e   st.v  st.t"/"st.i st.d    st.s "|"
  say "|                                                              |"
  say "+==============================================================="
  end
/* calculate space */
TRKS = st.s
wtrk = TRKS/16
parse var wtrk TRKS_SEC "." .
TRKS_SEC = TRKS_SEC + 1
return TRKS TRKS_SEC

/***********************************************************/
/* Routines used in no-pipe mode                           */
/***********************************************************/

/***********************************************************/
/*                                                         */
/*  Resolve ++INC recursively                              */
/*  PARMS  : start position to look over content           */
/*                                                         */
/***********************************************************/
INJ_RECURSIVE_INC : procedure expose content. line copylib sumrxlib   ,
                            exec_file_mode injector rexxlib rexxname  ,
                            setbase prolog.
 start_pos  = arg(1)
 inc_loop_bndry  = content.0
 do line = start_pos to inc_loop_bndry /* loop over content */
 content.line = substr(content.line,1,72)
 /* insert PROLOG. before base configuration element */
 j = line + 1
 if pos(setbase",ENV",translate(content.j)) > 0
   then
     do   /* BCE found */
      if prolog.0 > 0
       then
         do  /* prolog exists */
          l = j                      /* last  to move */
          k = content.0              /* first to move */
          content.0 = content.0 + prolog.0
          /* widening array to insert prolog */
          n = 0
          do i = k to l by -1
          n = n + 1
          m = content.0 + 1 - n      /* dest pos */
          content.m = content.i
          end
          /* insert prolog */
          do i = 1 to prolog.0
          k = j - 1 + i
          content.k = prolog.i
          end
         end /* prolog exists */
     inc_loop_bndry  = content.0
     line = line + prolog.0
     end  /* BCE found */

 if substr(content.line,1,5) = "++INC"
   then
     do   /* care ++INC */
     content.line = INJ_STR_REPL(content.line,",ENV","")
     mem_name = word(content.line,2)
     if substr(mem_name,1,1) = '&'
       then
         do
         new_name = INJ_GET_VAR_FROM_SETBASE(,
                   'injstm.'substr(mem_name,2),rexxlib,rexxname)
         say "++ = Var" mem_name "substituted by" new_name
         mem_name = new_name
         end
     dsname = rexxlib"("mem_name")"
     rc=SYSDSN(dsname); if rc='OK' then rc=0;
     if rc = 0
       then
         do   /* member found in rexxlib */
         num_before_member = content.0
         call INJ_INSERT_MEMBER dsname , line
         num_after_member = content.0
         /* deprecate INJSTUB procedure in REXXNAME */
         if mem_name = rexxname
           then
             do
              do mm = num_before_member to num_after_member
              content.mm = INJ_STR_REPL(content.mm,"INJ"||"STUB",  ,
                                                   "INJ"||"STUB_NA")
              end
             end
         say  "++ Member" left(mem_name,8,' ') "found in" rexxlib
         if INJ_RECURSIVE_INC(line) <> 0
           then
             return 8
         end  /* member found in rexxlib */
       else
         do   /* not rexxlib */
         dsname = copylib"("mem_name")"
         rc=SYSDSN(dsname); if rc='OK' then rc=0;
         if rc = 0
          then
           do   /* member found in copylib */
           call INJ_INSERT_MEMBER dsname , line
           say  "++ Member" left(mem_name,8,' ') "found in" copylib
           if INJ_RECURSIVE_INC(line) <> 0
             then
               return 8
           end  /* member found in copylib */
          else
           do /* not rexxlib & not copylib */
           dsname = sumrxlib"("mem_name")"
           rc=SYSDSN(dsname); if rc='OK' then rc=0;
           if rc = 0
            then
             do   /* member found in sumrxlib */
             call INJ_INSERT_MEMBER dsname , line
             say  "++ Member" left(mem_name,8,' ') "found in" sumrxlib
             if INJ_RECURSIVE_INC(line) <> 0
              then
                return 8
             end  /* member found in sumrxlib */
            else
             do
             say  "++ Member" left(mem_name,8,' ') "not found"
             end  /* member not found */
           end /* not rexxlib & not copylib */
         end /* not rexxlib */
    end /* care ++INC */
 end                         /* loop over content */
 return 0
/***********************************************************/
/*                                                         */
/*  Insert ++INC member into stem  at "i" position         */
/*                                                         */
/***********************************************************/
INJ_INSERT_MEMBER : procedure expose content. inc_loop_bndry
 dsn  = arg(1)
 ipos = arg(2)
 if INJ_GET_FILE_CONTENT("file",dsn,' ',"S") <> 0
   then
     return 8

 /* array of elements from ipos+1 to the end */
 k = 0
 do i = ipos  to content.0
 if i = ipos /* to avoid endless loop at the last element */
   then
    iterate
 k = k + 1
 interpret "cont."k "= content."i
 end
 cont.0 = k

 do i = ipos to content.0+mem_content.0-1
 if i >= ipos  &  i < ipos + mem_content.0
   then
     do
     k = i - ipos + 1
     content.i = mem_content.k
     end
 if i >= ipos + mem_content.0 & cont.0 > 0
   then
     do
     k = i - (ipos + mem_content.0) + 1
     content.i = cont.k
     end
 end

 content.0      = content.0 + mem_content.0  - 1
 inc_loop_bndry = content.0
 return

/********************************************************************/
/* This routine returns content of sequential file or lib member    */
/* PARM                                                             */
/*     type     : FILE or LIB                                       */
/*     dsn      : FILE/LIB name                                     */
/*     member   : member name if type=LIB                           */
/*     stemname : put stem name , default is CONTENT.               */
/*              : whatever character means MEM_CONTENT.             */
/* routine returns data in stem CONTENT. or MEM_CONTENT.            */
/********************************************************************/
INJ_GET_FILE_CONTENT: procedure expose content. mem_content.
 type   = translate(arg(1))
 dsn    = translate(arg(2))
 member = translate(arg(3))
 if arg(4) = ''
   then
     stmname = CONTENT
   else
     stmname = MEM_CONTENT

 if type = "FILE"
   then
     file = dsn
 if type = "LIB"
   then
     file = dsn"("member")"

 "ALLOCATE DA('"file"') SHR"
 /* find filename in LISTALC output */
 filename = INJ_GET_FILENAME_ALLOC_DSN(file)
 if filename = ''
   then
     return 8

 interpret "'EXECIO * DISKR" filename "(STEM" stmname". FINIS'"
 "FREE DA('"file"')"

 return 0

/*********************************************************************/
/* Routine returns filename of TSO allocated dataset                 */
/*********************************************************************/
INJ_GET_FILENAME_ALLOC_DSN : procedure
file = arg(1)
 x = outtrap(out.)
 "listalc status sysnames"
 x = outtrap("off")

 do i = 1 to out.0
 if pos(file,out.i) > 0
   then
     do
     i = i + 1
     return word(out.i,1)
     end
 end
 return ''

/*********************************************************************/
/* Returns temporary dataset name based on current timestamp         */
/*********************************************************************/
INJ_GENERATE_TEMP_DSNAME : procedure
 name = arg(1)
 MS = TIME("L")
 MS = substr(MS,length(MS)-1,2)
 return  userid()                               || ,
         ".INJREXX"                             || ,
         "."name                                || ,
         ".D"||strip(substr(DATE('B'),1,7))     || ,
         ".T"||strip(substr(TIME('S')||MS,1,7))

/*********************************************************************/
/* Find a source substring in string and replace it by target string */
/*********************************************************************/
/* PARMS : string                                                    */
/*         source substring                                          */
/*         target string                                             */
/*         source location (optional)                                */
/* Tests :                                                           */
/* say INJ_STR_REPL("1 msg(aaa) /* sss */","msg(","-msg(",3)         */
/* say INJ_STR_REPL("msg(aaa) /* sss */","msg("," msg(",1)           */
/* say INJ_STR_REPL(" msg(aaa) /* sss */","msg(","+msg(",2)          */
/* say INJ_STR_REPL(" msg(aaa) /* sss */"," msg("," x=msg(")         */
/* say INJ_STR_REPL("applmsg(aaa) /* sss */"," msg("," x=msg(")      */
/* say INJ_STR_REPL("applmsg(aaa) /* sss */","msg("," x=msg(")       */
/* say INJ_STR_REPL("mem,ENV      /* sss */",",ENV",'')              */

INJ_STR_REPL : procedure
str    = arg(1)
src    = arg(2)
trg    = arg(3)
loc    = arg(4)

idx = pos(src,str)
if idx = 0
   then
     return str
   else
   do   /* source found in string */
   /* if char preceding source in string is not one from exception    */
   /* array and the 1st char of source string is also such , then     */
   /* do nothing                                                      */
   if idx > 1
     then
      if IS_SIGN_EXCEPTION(substr(str,idx-1,1)) = 0 & ,
         IS_SIGN_EXCEPTION(substr(str,idx,1)) = 0
       then
        return str
   if loc <> ''
    then
     do
     interpret "parse var str . " loc  "(src)  sfx"
     parse var str pfx (src) (sfx)
     return pfx || trg || sfx
     end
    else
     do
     parse var str pfx (src)  sfx
     return pfx || trg || sfx
     end
   end  /* source found in string */

/*********************************************************************/
/* This checks arg(1) with elements in SE array                      */
/* RET : 1 - compared with either, 0 - not compared with any         */
/*********************************************************************/
IS_SIGN_EXCEPTION: procedure
 se.0 = 4
 se.1 = ';'
 se.2 = '.'
 se.3 = ','
 se.4 = ' '
 do i = 1 to se.0
 if arg(1) = se.i
   then
     return 1
 end
 return 0

/*********************************************************************/
/* This sets the pipe routine name to use inside INJECTOR            */
/*********************************************************************/
LPIPE : procedure
 return "PIPE"
/*********************************************************************/
/* This sets the pipe routine name to use in application             */
/*********************************************************************/
PIPEC : procedure
CMDPIPE_VAR=PIPE
 return CMDPIPE_VAR
/*********************************************************************/
/* This returns framework anchor helper name                         */
/*********************************************************************/
GET_SMRX_ANCHOR_HELPER_NAME : procedure
 return "FWHELPER"
/*********************************************************************/
/* return heap image file name from 2nd word of argument             */
/* PARM : second argument of 2nd+ level call                         */
/* EXAMPLE : * CPY_FILE0123                                          */
/*********************************************************************/
GET_HEAP_IMAGE_FILE : procedure
tok = word(arg(1),2)
parse var tok  . '_' image_file .
return strip(image_file)
/*********************************************************************/
/* return heap sharing mode from second word of argument             */
/* PARM : second argument of 2nd+ level call                         */
/* EXAMPLE : * CPY_FILE0123                                          */
/*********************************************************************/
GET_HEAP_SHARE_MODE : procedure
tok = word(arg(1),2)
parse var tok share_mode '_' .
return strip(share_mode)
/*********************************************************************/
/* set heap mode and heap file to word                               */
/* PARM : heap mode                                                  */
/*      : heap file                                                  */
/* RET  : word containing both they                                  */
/*********************************************************************/
SET_HEAP_MODE_FILE : procedure
if strip(arg(2)) = ''
  then
    return ''
  else
    return arg(1)||"_"||arg(2)
/*********************************************************************/
/* This routine will replace INJSTUB routine in user application     */
/* PARM : exec parameter of application                              */
/*  RET : appl_RC and ISPF VAR INJACTRC : appl_RC srlz_RC HEAP_IMAGE */
/*********************************************************************/
INJSTUB : procedure expose HEAP.
HEAP_IMAGE_FILE='NO_HEAP_IMAGE'
HEAP_SHARE='HEAP_SHR'

signal on syntax  name INJ_EXP_SYNTAX
signal on failure name INJ_EXP_FAILURE
/* signal on error   name INJ_EXP_ERROR */

/* there are 2 different situations here :                            */
/* 1. INJSTUB called in 1st lvl                                       */
/*    At this point HEAP does not exist yet, so it's filtered         */
/* 2. INJSTUB called in 2nd lvl                                       */
/*    At this point HEAP already exists and call will deserialize it  */
/*                                                                    */

/* In 1st level INJECTOR will set NO_HEAP_IMAGE to HEAP_IMAGE_FILE */
/* In SEP mode HEAP_IMAGE_FILE is NULL                             */
if HEAP_IMAGE_FILE <> "NO_HEAP_IMAGE" & strip(HEAP_IMAGE_FILE) <> ''
  then
    rcode = DESERIALIZE_HEAP_FROM_FILE(HEAP_IMAGE_FILE)

rcode = PARM_VALIDATION(arg(1))
if word(rcode,1) <> 0
  then
    return 8
  else
    do
    msg_level = word(rcode,2)
    end

/* call main routine */
appl_ret = SUMRX_MAIN(arg(1))
appl_ret = INJ_CHKCODE(appl_ret,"SUMRX_MAIN")
rcode = POST_MAIN(appl_ret)
return appl_ret

/*********************************************************************/
/* This routine work after SUMRX_MAIN completion or exception        */
/* PARM : SUMRX_MAIN return code OR 16 if exception                  */
/*  RET : appl_RC and ISPF VAR INJACTRC : appl_RC srlz_RC HEAP_IMAGE */
/*********************************************************************/
POST_MAIN : procedure expose HEAP.
HEAP_IMAGE_FILE='NO_HEAP_IMAGE'
HEAP_SHARE='HEAP_SHR'
appl_ret = arg(1)

/* for HEAP_SHARE=CPY drop HEAP before return to caller */
if HEAP_SHARE = "CPY" | HEAP_SHARE = "SEP"
  then
   HEAP_SHARE = "DRP"

INJACTRC = 0
if HEAP_SHARE = "SHR"  | HEAP_SHARE = "DRP"
  then
    INJACTRC = appl_ret SERIALIZE_HEAP_TO_FILE(HEAP_SHARE)
  else
    INJACTRC = appl_ret

/* do not use ISPF var in first level */
if HEAP_IMAGE_FILE = "NO_HEAP_IMAGE"
  then
   return appl_ret

/* return completion code via ISPF var */
varlist = "INJACTRC"
"ISPEXEC VPUT (&varlist) PROFILE"
return appl_ret

/*********************************************************************/
/* This routine/labels is called upon exception                      */
/* PARM :                                                            */
/*  RET : 16                                                         */
/*********************************************************************/
INJ_HANDLE_LABELS : procedure
INJ_EXP_SYNTAX:
 return INJ_ERROR_HANDLE("SYNTAX",SIGL)
INJ_EXP_ERROR:
 return INJ_ERROR_HANDLE("ERROR",SIGL)
INJ_EXP_FAILURE:
 return INJ_ERROR_HANDLE("FAILURE",SIGL)

/*********************************************************************/
/* This handles exception and calls POST_MAIN to survive HEAP !!!    */
/* PARM :                                                            */
/*  RET : 16                                                         */
/*********************************************************************/
INJ_ERROR_HANDLE : procedure expose HEAP.
reason = arg(1)
signum = arg(2)

/* Unrecoverable error detected */
call CMSG 66

say "REASON of failure:" reason

from_int  = 25
total_num = 50

 say "SUMRX : failure" reason "detected in line" signum
if datatype(signum) = "NUM"
 then
  do
  parse source . . . file_name dsn .
  skip_num = signum - from_int
  if skip_num < 1
   then
     skip_num = 0
  "EXECIO" skip_num  "DISKR" file_name "(OPEN SKIP )"
  "EXECIO" total_num "DISKR" file_name "(STEM fail. FINIS)"
  if datatype(fail.0) = "NUM"
   then
     do i = 1 to fail.0
     if strip(substr(fail.i,1,72)) = ''
       then
         iterate
     if skip_num + i = signum
      then
         say '==>' substr(strip(fail.i),1,70)
      else
         say ':::' substr(strip(fail.i),1,70)
     end
  end
/* do HEAP serialization */
rcode = POST_MAIN(16)
exit 16
