/**************************************************************
*                                                             *
* Title            : Get User information (ACF2)              *
*                                                             *
* File Name        : ctsbgus.c                                *
*                                                             *
* Author           : Yishay Yovel                             *
*                                                             *
* Creation Date    : 20/05/97                                 *
*                                                             *
* Description      : Gets User information from the Logonid   *
*                    Database of ACF2                         *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/****************************************************************
* Mod.Id   Who      When     Description                        *
* -------- -------- -------- --------------------------------   *
* PS0214   Guy      18/09/97 Null padding fix                   *
* BS2300   Guy      06/10/97 Null padding fix                   *
* WS2300   Guy      29/10/97 Check PSWD-VIO,PASSLMT (revoke)    *
* PS0223   Guy      05/11/97 If EMULATE dont call cts2lmt       *
* BS2313   Guy      11/11/97 Send correct userid                *
* PS0235   Guy      14/01/98 Fix multi-prefixes problem         *
* PS0236   Guy      26/01/98 Fix global sync problem            *
* WS2337   Guy      08/10/98 Added Multi Valued Fields support  *
* PS0321   Guy      28/10/98 Added UIDX field (MULTI VALUE)     *
* WS2338   Guy      02/11/98 Group support of MUL.VALUE fields  *
* PS0338   Guy      25/11/98 Added some debug messages          *
* PS0364   Guy      24/12/98 Remove EMULATE stuff               *
* PS0471   Michael  20/06/01 Support Revoke_type-Cancel/Suspend *
* ws2370   RamiK    01/01/02 add support for specific user      *
*                            profiles                           *
* BS2556   AvnerL   14/10/02 send acf2 original error msg       *
* BS2586   AvnerL   16/02/03 fix diag level mismatch            *
* IS10005  AvnerL   08/05/07 Support RU_LOCKED & RU_SUSPENDED.  *
* WS10005  AvnerL   17/07/07 Add diags                          *
* SAS2IBMT SeligT   09/10/16 SAS/C to IBM C Conversion Project  *
* CIQ#6    SeligT   19/03/17 Account Aggr includes Connections  *
* IS10147A SeligT   20/06/17 Add support for password phrase    *
* BS10061  SeligT   24/08/17 Resolving full aggregation         *
*                            performance problem after CIQ#6    *
* IS10156  SeligT   13/09/17 Allocate ADDINFO Size Correctly -  *
*                            just changing ADDINFO-dump diag    *
*                            level from 7 to 6 in 5 places      *
* WS10070  NuritY   25/03/18 Ignore connection attributes       *
*                            request.                           *
* IS10175  SeligT   26/08/18 Improve ACF2 Account Aggregation   *
*                            Performance (by returning          *
*                            max_users accounts during each     *
*                            GET_ALL_USERS call instead of 1    *
*                            account at a time)                 *
* IS10177  SeligT   12/12/18 Enhance ACF2 Account Aggregation   *
*                            Performance (by modifying CTSBGCN  *
*                            and the GET_USERS_CONNS_FAST call  *
*                            to it from this module)            *
* IS10181  SeligT   03/06/19 Display Message When ADDINFO Value *
*                            Is Too Large                       *
* IS10182  AvnerL   17/07/19 S0C4/S0C1 due to DIAG vsprintf     *
* WS10075  SeligT   21/11/19 Manage Permissions as Account and  *
*                            Group Attributes                   *
* WS10078T ThomaS   01/03/20 Support Roles in accounts          *
* WS10078N NuritY   23/04/20 Support sources in accounts        *
* WS10078KM KailasP 06/06/20 Add isIncomplete attribute in      *
*                            addinfo if truncated               *
* BS10105  NuritY   28/06/20 EOF is not handled correctly for   *
*                            permission, roles and sources.     *
* BS10108  NuritY   09/09/20 1. move user xref handing routines *
*                               from CTSBPHR.                   *
*                            2. When no roles, permissins are   *
*                               not retrieved.                  *
* BS10108T ThomaS   01/10/20 1.If Xref_Block_Build failes, issue*
*                             a message and continue normally.  *
*                             Set the pointer to the xref block *
*                             to INACT_BLOCK.                   *
*                             When the pointer has this value   *
*                             don't call:                       *
*                             Xref_Block_Build                  *
*                             Get_User_XSGP/XROL                *
*                            2.If no permissions at all issue   *
*                             CTS3891I for the user             *
* BS10110T ThomaS   15/11/20 Remove CTS3891I and issue a diag   *
* BS10110N NuritY   15/11/20 Do not fail the trnasaction when   *
*                            thre is a problem with sources.    *
* WS10079A AvnerL   17/12/20 JPMC phase2                        *
* WS10079T ThomaS   10/01/21 JPMC phase2                        *
* BS10111  NuritY   16/12/20 Support ruob above the bar.        *
* BS10115  AvnerL   25/08/21 Fix locked account issue.          *
* WS10084  ThomaS   19/06/23 Replace ACFRPTRX                   *
* WS10082N NuritY   03/12/23 Dealloc only if pointer nul HULL.  *
* BS10138  NuritY   25/08/24 Support many Sources & SourceGroups*
* BS10140  ThomaS   08/09/24 No X-ROL roles should be ok        *
* IS10189  AvnerL   05/11/24 Free correct storage               *
****************************************************************/

 /*
  *   Standard include files
  */

 #include   <globs.h>
 #include   STDIO
 #include   STDLIB
 #include   STRING
 #include   <dynit.h>           /* BS10108 - from CTSBPHR  - WS10078N */

 /*
  *   ESA include files
  */

 #include   ESA_API
 #include   ESA_DIAG
 #include   ESA_CTSAMSG
 #include   ESA_API_CODES

 #include   MVS_COMP
 #include   MVS_CODES                                      /* BS10108 */

 #include <ctest.h>                                        /* WS10084 */
 #include   API_ADDINFO
 #include   API_AUTH

 #include   ACF2_CODES
 #include   ACF2

 ASM_RTN_TYP           cts2ver;                           /* WS10078T */

 /* SAS2IBMT prototype changed for IBM C
 void cts2lmt(int *,                                      // WS2300 //
              int *);                                     // WS2300 */
 void cts2lmt();                                          /* SAS2IBMT */
 extern  int ctsaldm();                                   /* BS10108 */

 /*
  *   Handle strcuture for Get User processing
  */

 typedef struct {
   USER_typ                     Current_User;
   int                          Initial_Wild;
   int                          Current_In_User;
   LID_PERM_handle_rec_typ    * lid_perm_handle;          /* WS10075 */
   ADDINFO_rec_ptr              laddinfo;
   /*XBhandle_rec_typ           * XBhandle;                 *WS10079A*/
   } ACF2_Get_Users_Handle;

 typedef struct {                                         /*WS10079A*/
   XBhandle_rec_typ           * XBhandle;                 /*WS10079A*/
   void                       * acf2_get_xref_handle;     /*WS10079A*/
   } Get_User_XROL_handle;                                /*WS10079A*/

 typedef struct {                                         /*WS10079A*/
   XBhandle_rec_typ           * XBhandle;                 /*WS10079A*/
   void                       * acf2_get_xref_handle;     /*WS10079A*/
   } Get_User_XSGP_handle;                                /*WS10079A*/

 /* WS10084 DSECT of the input
 XROLE    ACDEF &DSECT
 XRLEYE   DS   CL4'XRBS'            EYECATCHER
 XRLLEN   DS   F                    LENGTH OF CONTROL BLOCK
 *
 XRLVER   DS   X                    VERSION
 XRLVER01 EQU  X'01'                VERSION 1 OF PARM LIST
 XRLVCUR  EQU  XRLVER01             CURRENT VERSION OF PARM LIST
 *
          DS   X                    RESERVED
 XRLFUNC  DS   X                    FUNCTION
 XRLRETG  EQU  X'01'    RETURN LIST OF GROUPS FOR USER (XRLSRCID)
 XRLRETU  EQU  X'02'    RETURN LIST OF USERS FOR GROUP (XRLSRCID)
 XRLRETE  EQU  X'03'                Return list of roles usr exclTA9326B
 XRLMAXF  EQU  XRLRETE              MAXIMUM FUNCTION CODE        TA9326B
 *
 XRLFLAG  DS   X                    FLAGS                        TA9158B
 XRLNOGRP EQU  X'80'                DO NOT RETURN GROUPS OF      TA9158B
 *                                  GROUPS (XRLFUNC = XRLRETG)   TA9158B
 XRLINGRP EQU  X'40'                Input value is a group       TA9202B
 XRLRETRL EQU  X'20'                Return list of roles under   TA9422B
 *                                    the input role             TA9422B
 *                                                               TA8783B
 XRLWORKA DS   A                    ADDR OF OPTION WORKAREA -    TA8783B
 *                                  1ST FULLWORD WILL CONTAIN    TA8783B
 *                                  THE WORKAREA LENGTH          TA8783B
 *                                                               TA8783B
 XRLSRCLN DS   F                    LENGTH OF SOURCE (XRLSRCID)
 XRLSRCID DS   A                    ADDRESS OF 8 BYTE SOURCE IDENTIFIER
 XRLSUBPL DS   A                    SUBPOOL FOR TABLE TO RETURN NAMES
 XRLSYSID DS   A                    ADDRESS OF AN 8 BYTE INPUT SYSID
 XRLTHDR@ DS   A                    RESERVED FOR INTERNAL USE    TA8783B
 XRLROLES DS   A                    Returned address -> table of TA9422B
 *                                    roles under the input role TA9422B
 *                                    - XRLRETRL must be set on  TA9422B
          DS   4F                   RESERVED                     TA9422B
          DS   0D                   ROUND TO DOUBLE WORD
 XRLLN    EQU  *-XROLE              LENGTH OF CONTROL BLOCK
          MEND
    WS10084 */
 /* WS10084 start */
 typedef  struct _RBS_INP_BLK
  {
    char    eyec[4];       /* XRLEYE     */
    int     len;           /* XRLLEN     */
    char    ver;           /* XRLVER     */
    char    res1;
    char    func;          /* XRLFUNC    */
    char    flag;          /* XRLFLAG    */
    char   *wa;            /* XRLWORKA   */
    int     usrlen;        /* XRLSRCLN   */
    char   *usr;           /* XRLSRCID   */
    int     subpool;       /* XRLSUBPL   */
    char   *sysid;         /* XRLSYSID   */
    int     res2;          /* XRLTHDR@   */
    int    *table;         /* XRLROLES   */  /* ->returned table */
    int     res3[4];
  }  ACF00RBS_inp_block_typ,  *ACF00RBS_inp_block_ptr;
 /* WS10084 end   */
 /* WS10084 DSECT of the returned block
 XROLTB   ACDEF &DSECT
 XRLTBEYE   DS   CL4'XRLT'  EYECATCHER
 XRLTBLN    DS   H          LENGTH OF THE TABLE
            DS   XL2        RESERVED
 XRLTBVER   DS   X          VERSION
 XRLTBVER01 EQU  X'01'      VERSION 1 OF PARM LIST
 XRLTBVCUR  EQU  XRLTBVER01 CURRENT VERSION OF PARM LIST
            DS   X          RESERVED
 XRLTBSP    DS   X          TABLE SUBPOOL
            DS   XL3        RESERVED
 XRLTBENTLN DS   X          ENTRY LENGTH
            DS   X          RESERVED
 XRLTBFLG   DS   X          FLAGS
 XRLTBFULL  EQU  X'80'      TABLE FULL
 XRLTBGRP   EQU  X'02'      INPUT SOURCE IS A GROUP
 XRLTBNOG   EQU  X'01'      DO NOT RETURN GROUPS OF GROUPS
 XRLTBFLG2  DS   X          RESERVED
 XRLTB#ENT  DS   H          RETURNED NUMBER OF ENTRIES IN TABLE
 XRLTBFLN   DS   F          LENGTH OF THE TABLE (SET XRLTBLN TO
 *                            X'FFFF') WHEN USING THIS FIELD)
 XRLTBRSRV  DS   6F         RESERVED AREA
 XRLTBDATA  DS   0D         BEGINNING OF DATA
 XRLTBHDL   EQU  *-XROLTB   LENGTH OF HEADER PORTION OF TABLE ENTRY
          MEND
    WS10084 */
 /* WS10084 start */
 typedef  struct _RBS_RET_BLK
  {
    char    eyec[4];       /* XRLTBEYE   */
    short   len;           /* XRLTBLN    */
    char    res1[2];
    char    ver;           /* XRLTBVER   */
    char    res2;
    char    subpool;       /* XRLTBSP    */
    char    res3[3];
    char    entlen;        /* XRLTBENTLN */
    char    res4;
    char    flags;         /* XRLTBFLG   */
    char    res5;          /* XRLTBFLG2  */
    short   ret_num;       /* XRLTB#ENT  */
    int     tablen;        /* XRLTBLN    */
    int     res6[6];       /* XRLTBRSRV  */
    char    role[8];
  }  ACF00RBS_ret_block_typ,  *ACF00RBS_ret_block_ptr;

 typedef  struct _PARM
  {
    char                   *func;
    ACF00RBS_inp_block_ptr  inp;
    ACF00RBS_ret_block_ptr *ret@;
    void                  **rbs@;
    int                    *dbglvl;
    int                     retlen;
    int                     retsp;
  }  CTS2RBS_parm_typ,   *CTS2RBS_parm_ptr;

 static  int            want_diag          = FALSE;
 /* WS10084 end   */
 /*=====================================
  *   Internal Functions
  *===================================== */

 /*
  *   Check Admin indicators of ACF2 User Record
  */
 static int Check_If_Admin(ADDINFO_rec_ptr laddinfo);

 /*
  *   Check Admin indicators of ACF2 User Record
  */
 static int Check_If_Auditor(ADDINFO_rec_ptr laddinfo);

 /*
  *   Build User Structure from ACF2 Data
  */
 static ESA_RC Build_User_Object(
                        USER_typ              user      ,
                        USER_PARAMS_rec_ptr   user_params,
                        ADDINFO_rec_ptr       addinfo,
                        ADDINFO_rec_ptr       laddinfo,
                        LID_PERM_handle_rec_typ    * lph,
                        CTSAMSG_HANDLE_rec_typ     * msgs,
                        CTSAMSG_DEST_TABLE_rec_typ * dest,
                        ADMIN_PARAMS_rec_typ * admin_params, /*IS10005*/
                        ERR_STRUCT_rec_typ   * err,          /* CIQ#6 */
                        GET_USER_MODE         mode);       /* BS10061 */
 /*      start WS10078T                                               */
 static  ESA_RC Get_User_XREFAndPermissions(char      * LID,
                              LID_PERM_handle_rec_typ * lid_perm_handle,
                              ADDINFO_rec_ptr           addinfo,
                              char                    * call_type,
                              ADMIN_PARAMS_rec_typ    * admin_params);
 /*      End   WS10078T                                               */
 /*
  *   Set FLAG addinfo fields to "N" if not set by ACF2 Get User API
  *
  *   (This is an ESS requirement, not to return NULL values for
  *    checkboxes (either N for 0, or Y for 1)
  */
 static void Complete_ADDINFO_Fields(ADDINFO_rec_ptr addinfo);

 /*
  *   Perform Cleanup of UDB before Get All Users
  */
 static ACF2_API_Return_Codes ACF2_Clean_UDB(void);

 /*
  *   Perform Cleanup up of handle information and other dynamically
  *   allocated areas.
  */
 static void Cleanup(ACF2_Get_Users_Handle *h,
                     void **handle,
                     ADMIN_PARAMS_rec_typ * admin_params,
                     ERR_STRUCT_rec_typ   * err);

 /* BS10108 - Define routies moved from CTSBPHR as static */
 /*
  *   Get X(SGP) connections.
  */
 static ESA_RC Get_User_XSGP(
          char                         Function[9],   /*WS10079A*/
          char                       * inputLID,
          LID_PERM_handle_rec_typ    * lid_perm_handle, /* WS10079T */
          /*WS10079A XREF_REC_BLK_rec_typ       * XREFBlk, */
          Get_User_XSGP_handle      ** GUXhandle,     /*WS10079A*/
          ADDINFO_rec_ptr              addinfo,
          ADMIN_PARAMS_rec_typ       * admin_params);

 /*
  *   Get X(ROL) connections
  */
 static ESA_RC Get_User_XROL(
          char                         Function[9],   /*WS10079A*/
          char                       * inputLID,
    /*    Get_Rule_Rec_Handle       ** get_rule_record_handle,  */
          LID_PERM_handle_rec_typ    * lid_perm_handle,
          /*WS10079A XREF_REC_BLK_rec_typ       * XREFBlk,      */
          Get_User_XROL_handle      ** GUXhandle,     /*WS10079A*/
          ADDINFO_rec_ptr              addinfo,
          ADMIN_PARAMS_rec_typ       * admin_params);

 /* BS10108 - end of static definitins.

 static  ASM_RTN_TYP * p_acf00rbs = NULL;      /* WS10084  */
 static  ASM_RTN_TYP * p_CTS2RBS  = NULL;      /* WS10084  */
 static  void        * ptr_rbs    = NULL;      /* WS10084  */
 void cts2sys();                               /* WS10084  */
 /* BS10108 - The definitins below were moved from CTSBPHR  */
 static  ASM_RTN_TYP * p_acf00ssl = NULL;      /* WS10078N */
 static  ASM_RTN_TYP * p_ctsaath = NULL;       /* WS10078N */
 /* BS10108 - end of moved section                         */

 static char component[]="GTUSERS";
 static int  debug = 0;
 static int  user_count = 0;
 static char get_connection;                                /* CIQ#6 */
 static void * handleFP = (void *)NULL;                   /* BS10061 */
 static int  UDB_Opened = FALSE;

/****************************************************
 * Procedure Name: CTSGetUsers
 * Description   : Get one, two, many or all users
 * Input         : mode         - ALL,
 *                                MANY (or one),
 *                                WILD (wildcard - currently
 *                                unimplemented)
 *                 max_users    - # of elements in user_params,
 *                                objs_exist and addinfo arrays
 *                 num_users_in - # of elements in user_params_in
 *                 user_params_in- array of num_users_in, filled with
 *                                users requested.
 *                 get_conn     - get connection - 'Y'/'N'/'P'
 *                 admin_params -
 * Output        : actual_num   - # of users returned
 *                 have_more    - HAVE_MORE if more users, else NO_MORE
 *                 err          - error indication, message, etc.
 *                 objs_exist   - array of max_users:
 *                                OBJ_EXIST if user exists, else
 *                                OBJ_NOT_EXIST.
 *                 user_params  - array of max_users:
 *                                callee fills with users returned
 *  Input/Output : addinfo      - array of max_users pointers:
 *                                add.info per user, Caller puts
 *                                requested keywords, callee returns
 *                                actual add.info.
 *                 handle       - NULL on first call, filled by callee,
 *                                used by callee to keep track.
 *                                Freed by caller.
 * Return Value  : ESA_RC
 * Side Effects  : Function may allocate memory, return pointer in
 *                 *handle; Caller MUST free when done.
 *
 * Comments      : Caller must reset I/O params to their initial values
 *                 when using subsequent calls (if HAVE_MORE).
 *
 *                 Logic is designed to return SINGLE object every call
 *                 where applicable (in GET_MANY multiple specific
 *                 objects must be returned in single call).
 ******************************************************************/

 ESA_RC CTSGetUsers (GET_USER_MODE         mode,
                     OE_typ                oe,
                     short                 max_users,
                     short               * actual_num,
                     HAVE_MORE_typ       * have_more,
                     void               ** handle,
                     short                 num_users_in,
                     USER_PARAMS_rec_typ   user_params_in[1],
                     USER_PARAMS_rec_typ   user_params[1],
                     ADDINFO_rec_ptr       addinfo[1],
                     OBJ_EXISTS_typ        objs_exist[1],
                     ADMIN_PARAMS_rec_typ * admin_params,
                     ERR_STRUCT_rec_typ   * err,
                     char                   get_conn)       /* CIQ#6 */
 {

 static char func[]="CTSGetUsers";

/*
 *   Local Variables
 */

 ESA_RC                     rc = ESA_OK ;
 ACF2_Get_Users_Handle * h;
 int                        i  ;
 int                        Iterate = FALSE;
 char                       msg[256] = "";
 char                       errmsg[256] = "";
 USER_typ                   user_to_refresh;              /* BS2313 */
 CTSAMSG_HANDLE_rec_typ     * msgs;
 CTSAMSG_DEST_TABLE_rec_typ * dest;
 USER_typ                   current_lid;
 ONE_FIELD_rec_ptr          pair;
 short                      actual       = 0;             /* BS10061 */
 HAVE_MORE_typ              have_moreFP;                  /* BS10061 */
 UG_typ                     * ugs_in     = NULL;          /* BS10061 */
 USER_typ                   users_in     [1];             /* BS10061 */
 U2UG_PARAMS_rec_typ        u2ug_out     [1];             /* BS10061 */
 ADDINFO_rec_ptr            addinfo_u2ug [1];             /* BS10061 */
 OBJ_EXISTS_typ             objs_existFP [1];             /* BS10061 */
 int                        rcc = ESA_OK;                 /* BS10061 */
 int                        rc_asm=0;                     /* WS10078T */
 char                       acf_version[5]="";            /* WS10078T */
 /* changing initialization value from NULL_CHAR to 'N'      WS10078T
    and roles_ver_okto acf2_ver_ok_for_xref
 char                       roles=NULL_CHAR;              /* WS10078T //
 char                       roles_ver_ok=NULL_CHAR;       /* WS10078T //
 char                       uid_permissions=NULL_CHAR;    /* WS10078T //
 char                       role_permissions=NULL_CHAR;   /* WS10078T //
 char                       sources = NULL_CHAR;          /* WS10078T */
 char                       roles='N';                    /* WS10078T */
 char                     acf2_ver_ok_for_xref=NULL_CHAR; /* WS10078T */
 char                       uid_permissions='N';          /* WS10078T */
 char                       role_permissions='N';         /* WS10078T */
 char                       sources ='N';                 /* WS10078T */
 int                        dbg_lvl=0;                    /* WS10078T */
/*
 *  Initialize
 */

 ESA_DIAG_enter(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT, func );

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 if (get_conn EQ 'P')                                    /* WS10070 */
   get_connection = 'Y';                                 /* WS10070 */
 else                                                    /* WS10070 */
   get_connection = get_conn;                             /* CIQ#6 */

 /*----------------------------------------------------------------*/
 /* Initialization Logic                                           */
 /*----------------------------------------------------------------*/
 /* - Set returned varaibles to default: return 1 object, more     */
 /* - Initialize Handle (if not initialized and not "free handle"  */
 /*   call.                                                        */
 /*----------------------------------------------------------------*/

 *actual_num = 1;
 *have_more  = HAVE_MORE;

 ESA_DIAG_printf(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT,
     "Mode=%d, Num Users=%d, User(1)=(%s), get_conn=%c, max_users=%d",
     mode, num_users_in, user_params_in[0].user, get_connection, max_users);
                        /* added display of get_conn parameter CIQ#6 */
                        /* added display of max_users parm   IS10175 */

 /*----------------------------------------------------------------*/
 /* Allocate Handle (One time processing for every API cycle of    */
 /*                  user(s) information retrieval)                */
 /*----------------------------------------------------------------*/
 /* - Allocate handle                                              */
 /* - Allocate temporary additional info object (ACF2_ADDINFO size)*/
 /*----------------------------------------------------------------*/
 if ((*handle EQ NULL) AND (mode NE GET_FREE_HANDLE_USERS)) {
   user_count = 0;
   *handle=(void *) calloc(1,sizeof(ACF2_Get_Users_Handle));/*WS10079A*/
   if (*handle EQ NULL)                                   /* WS10075 */
   {                                                      /* WS10075 */
      CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,         /* WS10075 */
                    "Get_Users handle",                   /* WS10075 */
                    sizeof(ACF2_Get_Users_Handle));       /* WS10075 */
      rc = ESA_FATAL;                                     /* WS10075 */
      goto exit;                                          /* WS10075 */
   };                                                     /* WS10075 */
   h = (ACF2_Get_Users_Handle *) *handle;
   if (ADDINFO_alloc(func, ACF2_ADDINFO, &(h->laddinfo), dest, msgs)
                      NE ESA_OK)
    {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
               "laddinfo alloc failed", 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
    };

   if (Global_UDB_Active() EQ TRUE)
    {
     UDB_Set_Mode(UDB_ReadWrite,admin_params,err);
     UDB_Opened = TRUE;
    };

   /*  start WS10078T */
   /*  Support roles only in ACF2 16 or higher                     */
   roles = 'N';
   if   (ADDINFO_search(
                    "Roles",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)
   {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,"Roles=Y");
     roles = 'Y';                   /* Roles are requested         */
   }  /*WS10078T */

      /*WS10078T  sources check moved here from below for ver check*/
      sources = 'N';                 /* assume sources not requested*/
   if (ADDINFO_search(
                    "Sources",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)
   {
      sources = 'Y';                   /* sources requested          */
      ESA_DIAG_printf(PLT_COMP_XREF,6,"sources=Y");    /*WS10078A*/
   }

   if (roles EQ 'Y' /*OR sources EQ 'Y' WS10079T*/ )   /* WS10078T */
   {                                                   /* WS10078T */
     /* WS10078T roles_ver_ok = 'N' ;  assume bad version of ACF2  */
     acf2_ver_ok_for_xref = 'N'; /* assume bad acf2 ver  WS10078T  */

     if ((int)ESA_DIAG_get_debug_level(ESA_COMP_GTUSERS) GE 6)
       /* DEBUG_SHOW_IMPORTANT) dropped by Avner */
        dbg_lvl=1;

     rc_asm=cts2ver(&dbg_lvl, acf_version);
     acf_version[3]=NULL_CHAR;
     ESA_DIAG_printf(PLT_COMP_XREF, 6,"ACF2 ver=<%s>",acf_version);
     /*WS10078A if (  strlen(acf_version) EQ 3 )
     {*/

     if (strcmp(acf_version,"160") GE 0) /* ACF2 ver must be >= 160 */
         /*WS10078T roles_ver_ok = 'Y' ; ACF2 ver is ok for roles*/
         acf2_ver_ok_for_xref = 'Y'; /* ACF2 ver ok for xref WS10078T */
     /*WS10078A};*/

     /*WS10078T if ( roles_ver_ok EQ 'N' )  Is ACF2 ver ok for rules?*/
     if ( acf2_ver_ok_for_xref EQ 'N' ) /* ver ok for xref?  WS10078T */
     {
      ESA_DIAG_printf(PLT_COMP_XREF, 6,"bad ACF2 ver");
     /* issue an error message about unsupported ver for xref  */
      CTSAMSG_print(ACF2_MIN_VER,
                msgs, NULL, dest,"16.0","Roles","Roles"); /* WS10079T */
                /*  msgs, NULL, dest,"16.0","XREF","XREF");  WS10079T */
     }
   }                                                   /* WS10078T */
   /*WS10078A}; */

   /*  Are any role permissions requested?                           */
   role_permissions  = 'N';      /* assume no rule perms requested */
   if ( roles EQ 'Y' AND acf2_ver_ok_for_xref EQ 'Y' )    /* WS10078T */
     {                                                    /* WS10078T */
      if ( (ADDINFO_search(
                    "AccountRoleDirectPermissions",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL) OR
           (ADDINFO_search(
                    "AccountRoleIndirectPermissions",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)  )
         {
           role_permissions  = 'Y';  /* role permissions requested */
           ESA_DIAG_printf(PLT_COMP_XREF,6,
                        "role_permission=Y"); /*WS10078A*/
           /*       (PLT_COMP_XREF, 6,"ACF2 ver=<%s>",acf_version);   */
         }
     }                                                    /* WS10078T */
   /* } WS10078T //WS10078A end of Roles */

   /*  The following moved above for ver check               WS10078T
   /*  Are any sources requested ?                                   //
      sources = 'N';                 /* assume sources not requested//
   if (ADDINFO_search(
                    "Sources",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)
   {
      sources = 'Y';                   /* sources requested          //
      ESA_DIAG_printf(PLT_COMP_XREF,6,"sources=Y");    /*WS10078A//
   }                                                        WS10078T */
   if (ADDINFO_search(
                    "SourceGroups",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)
       if  (sources EQ 'Y')
       {
        sources = 'A';                /* ALL sources requested   */
        ESA_DIAG_printf(PLT_COMP_XREF,6,"sources=A");    /*WS10078A*/
       }
       else
       {
        sources = 'N'; /* sources must be req.    for sourcegroups*/
        /*  issue an error message about missing SOURCES attribute  */
        /*  and that sources info will not be provided              */
        ESA_DIAG_printf(PLT_COMP_XREF,6,"sources=N");    /*WS10078A*/
        CTSAMSG_print(PRE_REQ_ATTRIBUTE,
           msgs, NULL, dest,"Sources","Sources","Account Aggregation");
       };

   /*  If roles groups or role permissions are requested then */
   /*  roles must be requested too.                           */
   if  (roles EQ 'N')
       {
       if ( (ADDINFO_search(
                    "RoleGroups",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL) OR
            (ADDINFO_search(
                    "AccountRoleDirectPermissions",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL) OR
            (ADDINFO_search(
                    "AccountRoleIndirectPermissions",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)  )
          /*(role_permissions EQ 'Y') )                 WS10078T     */
          {
        ESA_DIAG_printf(PLT_COMP_XREF,6,"Role is missing");/*WS10078A*/
   /*  issue an error message about missing role attr.               */
   /*  and that role info will not be provided                       */
        CTSAMSG_print(PRE_REQ_ATTRIBUTE,
           msgs, NULL, dest,"Roles","Roles","Account Aggregation");
          };
       };
   /*  end   WS10078T */
   /* * * * * * * * WS10075 Start * * * * * * */

   if ( (ADDINFO_search("ACCOUNTDIRECTPERMISSIONS",
                        ACF_ADDINFO_KWD_LEN,
                        addinfo[0]->pair,
                        addinfo[0]->num_pairs) NE NULL) OR
        (ADDINFO_search("ACCOUNTINDIRECTPERMISSIONS",
                        ACF_ADDINFO_KWD_LEN,
                        addinfo[0]->pair,
                        addinfo[0]->num_pairs) NE NULL) )
      {                                                    /* WS10078T */
      /*  save for later whether any uid permission requested WS10078T */
        uid_permissions = 'Y';                             /* WS10078T */
        ESA_DIAG_printf(PLT_COMP_XREF,6,"uid_permissoions=Y");
      }                                                    /* WS10078T */
   else                                                    /* WS10078T */
      {                                                    /* WS10078T */
        uid_permissions = 'N';                             /* WS10078T */
        ESA_DIAG_printf(PLT_COMP_XREF,6,"uid_permissoions=N");
      };                                                   /* WS10078T */
                                                           /* WS10078T */
   /*  lid permissions is needed only when roles are          WS10078T */
   /*  requested (and ACF2 ver is ok) OR when uid             WS10078T */
   /*  permissions are requested.                             WS10078T */
   /*  WS10078T                                           /* WS10078T //
   if  ( (  (roles EQ 'Y') AND (roles_ver_ok EQ 'Y')  )   /* WS10078T //
            OR (uid_permissions EQ 'Y')                   /* WS10078T //
            OR (sources         NE 'N') )                 /* WS10078T */
   /* WS10079T
   if ( (roles EQ 'Y' OR sources NE 'N')                  /@ WS10078T @/
        AND                                               /@ WS10078T @/
        (acf2_ver_ok_for_xref EQ 'Y')                     /@ WS10078T @/
        OR                                                /@ WS10078T @/
        (uid_permissions EQ 'Y')  )                       /@ WS10078T @/
      WS10079T  */
   if (((roles EQ 'Y') AND (acf2_ver_ok_for_xref EQ 'Y')) /* WS10079T */
            OR (uid_permissions EQ 'Y')                   /* WS10079T */
            OR (sources         NE 'N') )                 /* WS10079T */
   {
      h->lid_perm_handle = (LID_PERM_handle_rec_typ *)
                           calloc (1, sizeof(LID_PERM_handle_rec_typ));

      if (h->lid_perm_handle EQ NULL)
      {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                       "LID_PERM handle", sizeof(LID_PERM_handle_rec_typ));
         rc = ESA_FATAL;
         goto exit;
      }
      else
      {
         /*WS10079A h->lid_perm_handle->RolesBlk = NULL;*/
         /*WS10079A h->lid_perm_handle->SourcesBlk = NULL;*/
         /* h->lid_perm_handle->lidra_vec  = NULL;   WS10084 */
         h->lid_perm_handle->PB_Req       = NULL; /* WS10084 */
         h->lid_perm_handle->get_user_xrol_handle = NULL;
         h->lid_perm_handle->get_user_xsgp_handle = NULL;
         h->lid_perm_handle->Role_error   = FALSE; /*WS10079A*/
         h->lid_perm_handle->Source_error = FALSE; /*WS10079A*/
         h->lid_perm_handle->Role_nf      = FALSE; /*WS10079N*/
         h->lid_perm_handle->Source_nf    = FALSE; /*WS10079N*/
      };

      if ( (mode EQ GET_MANY_USERS) AND (num_users_in EQ 1) )
         strcpy(h->lid_perm_handle->lid, user_params_in[0].user);
      else
         strcpy(h->lid_perm_handle->lid, "*");

      /*  start WS10078T */

      /*  set RequiredPermissions to the requested permission types  */
/* WS10078S With account aggregation, we will always set the
            RequiredPermissions field to PERM_TYPE_LID.  The
            Get_user_permissions routine will handle all requested
            permissions based on the appropriate ADDINFO fields
            and the ACFRPTRX output.
      h->lid_perm_handle->RequiredPermissions = NULL_CHAR;
      if ( (uid_permissions EQ 'Y' ) AND (role_permissions EQ 'Y' ) )
         h->lid_perm_handle->RequiredPermissions = PERM_TYPE_ALL ;
      else
      {
         if (  uid_permissions EQ 'Y' )
            h->lid_perm_handle->RequiredPermissions = PERM_TYPE_UID ;
         if (  role_permissions EQ 'Y' )
            h->lid_perm_handle->RequiredPermissions = PERM_TYPE_ROLE;
      };                                                             */
      if ( (uid_permissions EQ 'Y' ) OR (role_permissions EQ 'Y' ) )
                                                        /* WS10078TG */
         h->lid_perm_handle->RequiredPermissions = PERM_TYPE_LID;
                                                         /* WS10078S */
      else                                              /* WS10078TG */
         h->lid_perm_handle->RequiredPermissions = NULL_CHAR;
                                                        /* WS10078TG */
      /*  set RequiredRoles to which role types are requested */
      h->lid_perm_handle->RequiredRoles = NULL_CHAR ;
   /* if  (  (roles EQ 'Y') AND (roles_ver_ok EQ 'Y')  )      WS10078T*/
      if((roles EQ 'Y') AND (acf2_ver_ok_for_xref EQ 'Y'))
          {
            h->lid_perm_handle->RequiredRoles = XREF_REC_TYPE_ROLE;
            if (ADDINFO_search(
                    "RoleGroups",
                    ACF_ADDINFO_KWD_LEN,
                    addinfo[0]->pair,
                    addinfo[0]->num_pairs) NE NULL)
               h->lid_perm_handle->RequiredRoles = XREF_REC_TYPE_ALL ;
          };

      /*  set RequiredSources to which source types are requested */
      if (sources EQ 'N')
         h->lid_perm_handle->RequiredSources = NULL_CHAR ;
      else
         h->lid_perm_handle->RequiredSources = sources;
      /*  end   WS10078T */
   } /*WS10078A end of (roles EQ 'Y') AND (roles_ver_ok EQ 'Y')..*/

   /* * * * * * * * WS10075 End * * * * * * * */

  }; /* end of (*handle EQ NULL) AND (mode NE GET_FREE_HANDLE_USERS)*/

 h = (ACF2_Get_Users_Handle *) *handle;

 /*----------------------------------------------------------------*/
 /* Select processing mode ...                                     */
 /*----------------------------------------------------------------*/

 switch(mode)
  {

 /*----------------------------------------------------------------*/
 /* Get ALL Users mode (each iteration returnes one user)          */
 /*----------------------------------------------------------------*/
  case GET_ALL_USERS   :

      /* The following logic is no longer in use.  This has  WS10075
      /* been true for several years.                        WS10075
      //-------------------------------------------------------//
      // Handle Download Restart Logic                         //
      //-------------------------------------------------------//

      if ( (h->Current_User[0] EQ NULL_CHAR) AND (num_users_in EQ 1) )
          strcpy(h->Current_User,user_params_in[0].user);            */

      /*-------------------------------------------------------*/
      /* For a full download, clean UDB first                  */
      /*-------------------------------------------------------*/
      if (h->Current_User[0] EQ NULL_CHAR)
       ACF2_Clean_UDB();

      *actual_num = 0;                                    /* IS10175 */

   for (i = 0; i < max_users; i++) {                      /* IS10175 */

      ADDINFO_empty(h->laddinfo);

      /*-------------------------------------------------------*/
      /* Fetch Next ACF2 User                                  */
      /* --------------------                                  */
      /* Get Next Logic is derived from the h->Current_User    */
      /* (see function documentation).                         */
      /*-------------------------------------------------------*/
      rc = ACF2_Get_User("********",
                         ACF2_Object_is_Masked,
                         "",
                         h->Current_User,
                         ACF2_GetUser_Get_Fields,
                         "",
                         h->laddinfo,
                         ACF2_Return_Multi_UIDs,          /* PS0321 */
                         errmsg,
                         admin_params);                   /*bs2556*/
      switch(rc)
       {
        case ACF2_OK:;
             ESA_DIAG_printf(PLT_COMP_XREF, 6 ,          /* WS10078T */
                      "Current_User: %8s",               /* WS10078T */
                      h->Current_User);                  /* WS10078T */
             /* start of WS2370 */
             pair = ADDINFO_search("LID", ACF_ADDINFO_KWD_LEN,
                                   h->laddinfo->pair,
                                   h->laddinfo->num_pairs);
             if (pair NE NULL) {
                strcpy(current_lid,pair->value);
             }
             else {
              sprintf(errmsg,"retrieving LID for User Profiles failed");
               CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                             func, errmsg, 16,__LINE__);
              rc = ESA_FATAL;
              goto exit;
             }

             rc = ACF2_Get_all_specific_user_profiles
                                 (current_lid,
                                  func, h->laddinfo, errmsg,
                                  ESA_COMP_GTUSERS, msgs,dest);
             break;

        case ACF2_Not_Found:
             /* IS10175
             goto No_More_Users;                                     */
             goto No_More_Users_All;                      /* IS10175 */

        default:
          sprintf(msg,"GET_ALL: GetUser Fail User=%s, rc=%d msg=%s",
                  h->Current_User,rc,errmsg);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                   msg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
       };

      /*-------------------------------------------------------*/
      /* Build Resulting User object from ACF2 and ESS info    */
      /*-------------------------------------------------------*/
     ESA_DIAG_printf(PLT_COMP_XREF, 6 ,                  /* WS10084 */
          "ACF2_Refresh_User_UID User: %8s",             /* WS10084 */
                      h->Current_User);                  /* WS10084 */
     if (ACF2_Refresh_User_UID(h->Current_User,
                           OBJ_EXIST,
                           h->laddinfo) NE ACF2_OK)
      {
        sprintf(errmsg,"Refresh of (%s) UID failed",h->Current_User);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                     errmsg, 16,__LINE__);
      };

     rc = Build_User_Object(h->Current_User,
                /* IS10175  &(user_params[0]),                       */
                            &(user_params[i]),            /* IS10175 */
                /* IS10175  addinfo[0],                              */
                            addinfo[i],                   /* IS10175 */
                            h->laddinfo,
                            h->lid_perm_handle,           /* WS0075 */
                            msgs,
                            dest,
                            admin_params,                 /*IS10005*/
                            err,                          /* CIQ#6 */
                            mode);                      /* BS10061 */

     /*-------------------------------------------------------*/
     /* Build Resulting User object from ACF2 and ESS info    */
     /*-------------------------------------------------------*/

     if (rc NE ESA_OK)
      {
        sprintf(msg,"GET_ALL: Build_User_Object failed for %s",
                     h->Current_User);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                 msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
      };

      objs_exist[i] = OBJ_EXIST;                          /* IS10175 */
      (*actual_num)++;                                    /* IS10175 */
      user_count++;                                       /* IS10175 */
      ESA_DIAG_printf(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT,
                      "User returned: %s (# %d)",         /* IS10175 */
                      user_params[i].user, user_count);   /* IS10175 */
   } /* for (i = 0; i < max_users; i++)                      IS10175 */

     /*-------------------------------------------------------*/
     /* Complete Single User Returned, More to come           */
     /* After IS10175, we just completed returning max_users  */
     /* accounts. There is probably more to come.             */
     /*-------------------------------------------------------*/
     /* IS10175
     *actual_num = 1;                                                */
     *have_more = HAVE_MORE;
     /* IS10175
     objs_exist[0] = OBJ_EXIST;
     break;                                                          */

     ESA_DIAG_printf(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT,
                     "actual_num = %d", *actual_num);     /* IS10175 */
     rc = ESA_OK;                                         /* IS10175 */
     goto exit;                                           /* IS10175 */

 /*----------------------------------------------------------------*/
 /* Get multiple specific USERS according to input (one shot)      */
 /*----------------------------------------------------------------*/
 case GET_MANY_USERS:

   for(i=0; i<num_users_in; i++)
    {
     objs_exist[i] = OBJ_EXIST;

     h->Current_User[0] = NULL_CHAR;
     ADDINFO_empty(h->laddinfo);

     /*---------------------------------------------------------*/
     /* ACF2 Get User: - Specific User                            */
     /*                - User is not masked                       */
     /*                - No UIDMASK filter                        */
     /*                - Current user ignored                     */
     /*---------------------------------------------------------*/
     rc = ACF2_Get_User(user_params_in[i].user,
                        ACF2_Object_is_Not_Masked,
                        "",
                        h->Current_User,
                        ACF2_GetUser_Get_Fields,
                        "",
                        h->laddinfo,
                        ACF2_Return_Multi_UIDs,           /* PS0321 */
                        errmsg,
                        admin_params);                   /*bs2556*/

     switch(rc)
      {
        case ACF2_OK:

         /*-----------------------------*/
         /* getting user profiles       */
         /*-----------------------------*/
         /*start of ws2370*/
         rc = ACF2_Get_all_specific_user_profiles
                                (user_params_in[i].user, func,
                                 h->laddinfo, errmsg,
                                 ESA_COMP_GTUSERS, msgs,dest);
         /*-----------------------------*/
         /* Build Resulting User Object */
         /*-----------------------------*/
         strcpy(user_to_refresh, h->Current_User);        /* BS2313 */

         rc = Build_User_Object(h->Current_User,
                           &(user_params[i]),addinfo[i],h->laddinfo,
                           h->lid_perm_handle,           /* WS0075 */
                           msgs,dest,
                           admin_params,                 /*IS10005*/
                           err,                          /* CIQ#6 */
                           mode);                      /* BS10061 */

         if (rc NE ESA_OK)
          {
            sprintf(msg,"GET_MANY: Build_User_Object failed for %s",
                        h->Current_User);
           CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                   msg, 16,__LINE__);
            rc = ESA_FATAL;
            goto exit;
          };
         break;

        case ACF2_Not_Found:
          objs_exist[i] = OBJ_NOT_EXIST;
          strcpy(user_params[i].user, user_params_in[i].user);
                                                          /* PS0236 */

          strcpy(user_to_refresh, user_params_in[i].user);
                                                          /* BS2313 */
          break;

        default:
          sprintf(msg,"GET_MANY: Get User fail user=%s rc=%d msg=%s",
                      h->Current_User, rc, errmsg);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                 msg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
      };
     if (ACF2_Refresh_User_UID(user_to_refresh,           /* BS2313 */
                           objs_exist[i],
                           h->laddinfo) NE ACF2_OK)
      {
        sprintf(errmsg,"Refresh of (%s) UID failed",user_to_refresh);
                                                          /* BS2313 */
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                     errmsg, 16,__LINE__);
      };

    };

     *actual_num = num_users_in;
     *have_more = NO_MORE;
     break;

 /*----------------------------------------------------------------*/
 /* Get multiple Users by prefix vector (one user per iteration)   */
 /*----------------------------------------------------------------*/
 case GET_WILD_USERS:

   do /* Iterate */
    {
     /*---------------------------------------------------------*/
     /* Process Next Prefix: Reset get_next logic of ACF2 by    */
     /* reseting of Current_User field.                         */
     /*---------------------------------------------------------*/

     Iterate = FALSE;                                     /* PS0235 */

     if (h->Initial_Wild EQ 0)
      {
       h->Initial_Wild = 1;
       h->Current_User[0] = NULL_CHAR;
      };

     ADDINFO_empty(h->laddinfo);

     /*---------------------------------------------------------*/
     /* ACF2 Get User: - User Prefix                              */
     /*                - User is masked (prefix will be appended  */
     /*                                  with '*')                */
     /*                - No UIDMASK filter                        */
     /*                - Current User reflects Current Prefix     */
     /*                  ACF2 Processing location                 */
     /*---------------------------------------------------------*/
     rc = ACF2_Get_User(user_params_in[h->Current_In_User].user,
                   ACF2_Object_is_Masked,
                   "",
                   h->Current_User,
                   ACF2_GetUser_Get_Fields,
                   "",
                   h->laddinfo,
                   ACF2_Return_Multi_UIDs,                /* PS0321 */
                   errmsg,
                   admin_params);                   /*bs2556*/
     switch(rc)
      {
         /*-----------------------------*/
         /* Build Resulting User Object */
         /*-----------------------------*/
        case ACF2_OK:
         /*-----------------------------*/
         /* getting user profiles       */
         /*-----------------------------*/
         /*start of ws2370*/
         pair = ADDINFO_search("LID", ACF_ADDINFO_KWD_LEN,
                               h->laddinfo->pair,
                               h->laddinfo->num_pairs);
         if (pair NE NULL) {
          strcpy(current_lid,pair->value);
         }
         else {
           sprintf(errmsg,"retrieving LID for User Profiles failed");
           CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                         func, errmsg, 16,__LINE__);
           rc = ESA_FATAL;
           goto exit;
         }

         rc = ACF2_Get_all_specific_user_profiles
                             (current_lid,
                              func, h->laddinfo, errmsg,
                              ESA_COMP_GTUSERS, msgs,dest);
         if (ACF2_Refresh_User_UID(h->Current_User,
                                   OBJ_EXIST,
                                   h->laddinfo) NE ACF2_OK)
           {
           sprintf(errmsg,"Refresh of (%s) UID failed",h->Current_User);
           CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                         errmsg, 16,__LINE__);
            };

         rc = Build_User_Object(h->Current_User,
                           &(user_params[0]),
                           addinfo[0],
                           h->laddinfo,
                           h->lid_perm_handle,           /* WS0075 */
                           msgs,
                           dest,
                           admin_params,                 /*IS10005*/
                           err,                          /* CIQ#6 */
                           mode);                      /* BS10061 */
         if (rc NE ESA_OK)
          {
            sprintf(msg,"GET_WILD: Build_User_Object failed for %s",
                        h->Current_User);
           CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                   msg, 16,__LINE__);
            rc = ESA_FATAL;
            goto exit;
          };
         break;

        /*-----------------------------*/
        /* Process next User Prefix    */
        /*-----------------------------*/
        case ACF2_Not_Found:
          h->Initial_Wild = 0;
          (h->Current_In_User)++;
          if (h->Current_In_User GE num_users_in)
            goto No_More_Users;
          Iterate = TRUE; /* No user found for current prefix,      */
                          /* but there are more prefixes to process */
          break;

        /*-----------------------------*/
        /* Bad RC - Error              */
        /*-----------------------------*/
        default:
          sprintf(msg,"GET_WILD: Get User fail user=%s rc=%d msg=%s",
                      h->Current_User, rc, errmsg);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                 msg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
      }
   } while (Iterate EQ TRUE);

   *actual_num = 1;
   *have_more = HAVE_MORE;
   objs_exist[0] = OBJ_EXIST;
   break;

 /*----------------------------------------------------------------*/
 /* Get Subtree Users (not supported)                              */
 /*----------------------------------------------------------------*/
 case GET_SUBTREE_USERS:
   rc = ESA_NOT_SUPP;
   goto exit;

 /*----------------------------------------------------------------*/
 /* Free handle and local addinfo                                  */
 /*----------------------------------------------------------------*/
 case GET_FREE_HANDLE_USERS :
   Cleanup(h,handle,admin_params,err);
   rc = ESA_OK;
   goto exit;

 default:;
 }

/*
 *  Finish
 */

 user_count++;
 ESA_DIAG_printf(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT,
                 "User returned: %s (# %d)", user_params[0].user,
                 user_count);

 rc = ESA_OK;
 goto exit;

 No_More_Users:
   user_count = 0;
   *actual_num = 0;
 No_More_Users_All:                                       /* IS10175 */
   ESA_DIAG_printf(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT,/* IS10175 */
                  "CTSGetUsers routine returned %d users",/* IS10175 */
                  user_count);                            /* IS10175 */
   *have_more  = NO_MORE;
   rc = ESA_OK;

 exit :;

 /* * * * BS10061 start * * */
 if ( (get_connection EQ 'Y') AND
      (mode EQ GET_ALL_USERS) AND
      (handleFP)              AND
      (*have_more EQ NO_MORE)    )
 {
    rcc = CTSGetConns (GET_FREE_HANDLE_CONNS,
                                        1, &actual,
                                        &have_moreFP, &handleFP,
                                        0, 0,
                                        ugs_in, users_in,
                                        u2ug_out,
                                        addinfo_u2ug,
                                        objs_existFP,
                                        admin_params,
                                        err);
    ESA_DIAG_printf(ESA_COMP_GTUSERS, 2,
        "Just called CTSGetConns to free handleFP. rcc = %d)", rcc);
 }
 /* * * * BS10061 end * * */

 if ( (rc NE ESA_OK) OR (*have_more EQ NO_MORE) )
  Cleanup(h,handle,admin_params,err);

 ESA_DIAG_exit(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT, func, rc);

 return rc ;

}

/******************************************************************
 * Procedure Name: Build_User_Object
 ******************************************************************
 * Description   : Build User Structure to return to Caller
 *
 * Input         : user_ent     - user id
 *                 laddinfo     - addinfo retrieved from ACF2
 *                 CTSAMSG stuff
 *
 * Output        : user_params  - Target USER_PARAMS object
 *
 * Input/Output  : addinfo      - Caller ADDINFO to set with ACF2
 *                                values
 * Return Value  : ESA_RC
 ******************************************************************/
 static ESA_RC Build_User_Object(
                        USER_typ              user_ent   ,
                        USER_PARAMS_rec_ptr   user_params,
                        ADDINFO_rec_ptr       addinfo,
                        ADDINFO_rec_ptr       laddinfo,
                        LID_PERM_handle_rec_typ    * lph,
                        CTSAMSG_HANDLE_rec_typ     * msgs,
                        CTSAMSG_DEST_TABLE_rec_typ * dest,
                        ADMIN_PARAMS_rec_typ * admin_params, /*IS10005*/
                        ERR_STRUCT_rec_typ   * err,          /* CIQ#6 */
                        GET_USER_MODE         mode)        /* BS10061 */
  {

  static char func[]="Build_User_Object";

  int    rc = ESA_OK;
  int                passlmt, pswdvio, cts2lmt_rc = 0;    /* WS2300 */
  int                pwpvio = 0;                         /* IS10147A */
  ONE_FIELD_rec_ptr  pairp;                              /* IS10147A */
  ONE_FIELD_rec_ptr  pair;
  ONE_FIELD_rec_ptr  gpair = NULL;                        /* WS10084 */
  USER_typ           temp_user_ent;                       /* PS0214 */
  int    revtype_suspend = 0;                             /* PS0471 */
  int    revtype_cancel  = 0;                             /* PS0471 */
  ACF2_PARAMS_rec_typ * params_ptr = NULL;                /* IS10005 */
  short                 at_least_one = 0;                   /* CIQ#6 */
  short                 actual       = 0;                   /* CIQ#6 */
  void                * handle = (void *)NULL;              /* CIQ#6 */
  HAVE_MORE_typ         have_more;                          /* CIQ#6 */
  short                 num_users_in = 1;                   /* CIQ#6 */
  short                 num_ug_in    = 0;                   /* CIQ#6 */
  UG_typ              * ugs_in       = NULL;                /* CIQ#6 */
  USER_typ              users_in     [1];                   /* CIQ#6 */
  U2UG_PARAMS_rec_typ   u2ug_out     [1];                   /* CIQ#6 */
  ADDINFO_rec_ptr       addinfo_u2ug [1];                   /* CIQ#6 */
  OBJ_EXISTS_typ        objs_exist   [1];                   /* CIQ#6 */
  char                  msg[256] = "";                      /* CIQ#6 */
  FUNC_PTR_rec_typ      func_struct;                        /* CIQ#6 */
  int                   rcc = ESA_OK;                     /* BS10061 */
  int                   already = 0;                      /* IS10181 */
  UG_typ                groupuser = "";                   /* IS10181 */

  ESA_DIAG_enter(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT, func );

 /*
  *  Set USER_PARAMS defaults
  */

  strcpy(temp_user_ent, user_ent);                        /* PS0214 */
  strcpy(user_params->user, Trim(temp_user_ent));         /* PS0214 */
  user_params->passwd_life   = PASS_LIFE_IGNORED;
  user_params->def_ug_action = OLD_DEF_UG_ACT_IGNORED;
  user_params->def_group[0]  = NULL_CHAR;
  user_params->parent_oe[0]  = NULL_CHAR;
  user_params->rev_status    = USER_STAT_ACTIVE;
  user_params->user_admin    = USER_ADM_NONE;

 /*
  *  Set user revoke status
  */
                                              /* Start PS0471 */
 /*
  * Set value of Revoke_Type according to keywords used in ACF2.
  * Possible values are CANCEL/SUSPEND/BOTH
  */

  revtype_suspend = 0;
  revtype_cancel  = 0;

  pair = ADDINFO_search("SUSPEND", ACF_ADDINFO_KWD_LEN,
                        laddinfo->pair,
                        laddinfo->num_pairs);
  if (pair NE NULL)
    if ( strcmp(pair->value,KWD_FLAG_ON) EQ 0 )
        revtype_suspend = 1;
                                                          /*debug*/
  if (pair NE NULL)                                       /*debug*/
     ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,     /*debug*/
             "revtype_suspend=%d, SUSPEND value=%d",      /*debug*/
              revtype_suspend, pair->value);              /*debug*/
  else                                                    /*debug*/
     ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,     /*debug*/
             "SUSPEND keyword not found in ACF2.");       /*debug*/
                                                          /*debug*/
                                                          /*debug*/

  pair = ADDINFO_search("CANCEL", ACF_ADDINFO_KWD_LEN,
                        laddinfo->pair,
                        laddinfo->num_pairs);
  if (pair NE NULL)
    if ( strcmp(pair->value,KWD_FLAG_ON) EQ 0 )
        revtype_cancel = 1;

                                                          /*debug*/
  if (pair NE NULL)                                       /*debug*/
     ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,     /*debug*/
             "revtype_cancel=%d, CANCEL value=%d",        /*debug*/
              revtype_cancel, pair->value);               /*debug*/
  else                                                    /*debug*/
     ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,     /*debug*/
             "CANCEL keyword not found in ACF2.");        /*debug*/

  /***********************************************************/
  /***** IS10005 RU_LOCKED default value is N part 1 starts ***/
  /***********************************************************/
  pair = ADDINFO_search("RU_LOCKED", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
  if (pair NE NULL)
   {
    ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
                    "User %s RU_LOCKED is set to N as default.",
                    user_params->user);
    ADDINFO_updval(KWD_FLAG_OFF,
                   ACF_ADDINFO_VAL_LEN,
                   pair);
   }
  /*****  IS10005 RU_LOCKED default value is N part 1 ends ****/
  /************************************************************/
  /*****  IS10005 RU_SUSPENDED default value is N starts  *****/
  /************************************************************/
  pair = ADDINFO_search("RU_SUSPENDED", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
  if (pair NE NULL)
   {
    ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
                    "User %s RU_SUSPENDED is set to N as default.",
                    user_params->user);
    ADDINFO_updval(KWD_FLAG_OFF,
                   ACF_ADDINFO_VAL_LEN,
                   pair);
   }
  /*****  IS10005 RU_SUSPENDED default value is N ends    *****/

  /* If the user has SUSPEND or CANCEL,update rev_status      */
  /* in user_param, and update REVOKE_TYPE keyword in addinfo */
  /* to send back to the agent                                */

  if (revtype_suspend || revtype_cancel)
  {
    params_ptr = admin_params->apiinit_handle;               /*IS10005*/
   /*admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_GTUSERS,3,*IS10005*/
    ESA_DIAG_printf(ESA_COMP_GTUSERS,3,             /*IS10082 *IS10005*/
      "SUSPEND_IS_LOCKED=<%s> ",
      params_ptr->rssparm_SUSPEND_IS_LOCKED);

    user_params->rev_status = USER_STAT_REVOKED;
       /* Point to the entry we will return value in  */
  } /* end of (revtype_suspend || revtype_cancel) */
  pair = ADDINFO_search("REVOKE_TYPE", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs );

  if (pair NE NULL)                                       /*IS10005*/
  {
   ESA_DIAG_printf(ESA_COMP_GTUSERS,3,                    /*IS10005*/
         "REVOKE_TYPE exists.");
   if (revtype_suspend && revtype_cancel)
   {
       ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,   /*debug*/
         "Return REVOKE_TYPE BOTH to IIQ/IDN.");          /*debug*/
                                                          /*debug*/
       /*IS10005 if (pair NE NULL) - no need to test now         */
       ADDINFO_updval("BOTH",
                      ACF_ADDINFO_VAL_LEN,
                      pair);
   }
   else if (revtype_suspend)
   {
       ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,   /*debug*/
         "Return REVOKE_TYPE SUSPEND to IIQ/IDN.");       /*debug*/
                                                          /*debug*/
       /* IS10005 if (pair NE NULL) no need to test now.         */
       ADDINFO_updval("SUSPEND",
                      ACF_ADDINFO_VAL_LEN,
                      pair);
   }
   else if (revtype_cancel)
   {
       ESA_DIAG_printf(ESA_COMP_GTUSERS,DEBUG_SHOW_ALL,   /*debug*/
         "Return REVOKE_TYPE CANCEL to IIQ/IDN.");       /*debug*/
                                                          /*debug*/
       /* IS10005 if (pair NE NULL) no need to test now.         */
       ADDINFO_updval("CANCEL",
                      ACF_ADDINFO_VAL_LEN,
                      pair);
   }
  } /* end of if (pair NE NULL)                             IS10005*/
                                                  /* End PS0471 */

  /******************** IS10005 part 4 starts *******************/
  /* set RU_SUSPENDED & RU_LOCKED based on:
   * - user's LID in ACF2 SUSPEND & CANCEL values.
   * - SUSPEND_IS_LOCKED parm value in RSSPARM.
   *************************************************************/
  if (revtype_suspend)
   {
    if (params_ptr->rssparm_SUSPEND_IS_LOCKED[0]=='N')
     {
      pair = ADDINFO_search("RU_SUSPENDED", ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
       if (pair NE NULL)
        {
          ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
                         "User %s has SUSPEND, RU_SUSPENDED is set.",
                         user_params->user);
          ADDINFO_updval(KWD_FLAG_ON,
                        ACF_ADDINFO_VAL_LEN,
                        pair);
        }
     }
    else /*params_ptr->rssparm_SUSPEND_IS_LOCKED[0]=='Y'  */
     {
      pair = ADDINFO_search("RU_LOCKED", ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
       if (pair NE NULL)
        {
          ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
                         "User %s has SUSPEND, RU_LOCKED is set.",
                         user_params->user);
          ADDINFO_updval(KWD_FLAG_ON,
                        ACF_ADDINFO_VAL_LEN,
                        pair);
        }
     }
   } /* end of "if (revtype_suspend)" */
  if (revtype_cancel)
   {
      pair = ADDINFO_search("RU_SUSPENDED", ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
       if (pair NE NULL)
        {
          ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
                         "User %s has CANCEL, RU_SUSPENDED is set.",
                         user_params->user);
          ADDINFO_updval(KWD_FLAG_ON,
                        ACF_ADDINFO_VAL_LEN,
                        pair);
        }
   } /* end of "if (revtype_cancel)" */
  /******************** WS10005 part 4 ends ********************/

 /* **WS2300 START** */

 /* User can also be revoked if his PSWD-VIO >= PASSLMT */

  /* SAS2IBMT
  cts2lmt(&passlmt,                                                  */
  (*(ASM_RTN_TYP *)&cts2lmt)                              /* SAS2IBMT */
         (&passlmt,
          &cts2lmt_rc);

  if (cts2lmt_rc NE 0)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
      "Could not retrieve PASSLMT", 16,__LINE__);
     rc = ESA_FATAL;
     goto exit;
   };

  pair = ADDINFO_search("PSWD_VIO", ACF_ADDINFO_KWD_LEN,
                        laddinfo->pair,
                        laddinfo->num_pairs);

  pairp = ADDINFO_search("PWP_VIO", ACF_ADDINFO_KWD_LEN, /* IS10147A */
                        laddinfo->pair,                  /* IS10147A */
                        laddinfo->num_pairs);            /* IS10147A */

  if (pairp NE NULL)                                     /* IS10147A */
   {
     pwpvio = atoi(pairp->value);                        /* IS10147A */
     ESA_DIAG_printf(ESA_COMP_GTUSERS, 3,                /* IS10147A */
         "PWP_VIO = %d and passlmt = %d",                /* IS10147A */
                     pwpvio, passlmt);                   /* IS10147A */
   }
  /************************** BS10115 start **************************
   * When either of PSWD-VIO or PWP-VIO is used, we should check     *
   * whether the sum of these two is greater then GSO's PASSLMT.     *
   * If yes, it means that the user is locked.                       */
  if (pair NE NULL)
   {
     pswdvio = atoi(pair->value);
     ESA_DIAG_printf(ESA_COMP_GTUSERS, 3,
        "PSWD_VIO = %d and passlmt = %d",pswdvio, passlmt);
   }

  if ((pair NE NULL) OR (pairp NE NULL))
  /*WS10115 if (pair NE NULL) use a wider condition as above         */
  /************************** BS10115 end   **************************/
   {
     /*BS10115 pswdvio = atoi(pair->value);                          */
     /* IS10147A if (pswdvio GE passlmt)                             */
     /*BS10115 if((pswdvio GE passlmt)OR(pwpvio GE passlmt))/*IS10147A*/
     if ((pswdvio + pwpvio) GE passlmt)                   /* BS10115 */
      {                                                   /*IS10005*/
       ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
       /* IS10147A     "PSWD_VIO = (%d) GE passlmt = (%d)", //IS10005//
                       pswdvio,passlmt);                             */
        /*BS10115"PSWD_VIO(%d)orPWP_VIO(%d)GE passlmt (%d)",/*IS10147A*/
          "PSWD_VIO (%d) + PWP_VIO (%d) GE passlmt (%d)",   /*BS10115*/
          pswdvio, pwpvio, passlmt);                        /*IS10147A*/
       user_params->rev_status = USER_STAT_REVOKED;
       /****************************************************/
       /*******    IS10005 RU_LOCKED part starts     *******/
       /****************************************************/
       /* search in addinfo where we return values */
       pair = ADDINFO_search("RU_LOCKED", ACF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs);
       if (pair NE NULL)
        {
         ESA_DIAG_printf(ESA_COMP_GTUSERS,3,
                         "User %s is locked, RU_LOCKED is set.",
                         user_params->user);
         ADDINFO_updval(KWD_FLAG_ON,
                        ACF_ADDINFO_VAL_LEN,
                        pair);
        }
      } /* end of if (pswdvio GE passlmt) */
       /*******    IS10005 RU_LOCKED part ends       *******/
   }; /* end of if ((pair NE NULL) OR (pairp NE NULL))     IS10005*/

 /* **WS2300 END** */

 /*
  *  Set user admin status
  */
  if (Check_If_Admin(laddinfo) EQ TRUE)
   {
     ESA_DIAG_printf(ESA_COMP_GTUSERS,1, "User %s is Admin",
                     user_params->user);
     user_params->user_admin = USER_ADM_ADMIN;
   }
  else
   {
     ESA_DIAG_printf(ESA_COMP_GTUSERS,1, "User %s is NOT ADMIN",
                     user_params->user);
     user_params->user_admin = USER_ADM_NONE;
   };

 /*
  *  Set user audit status
  */
  if (Check_If_Auditor(laddinfo) EQ TRUE)
   if ( user_params->user_admin EQ USER_ADM_NONE )
    {
      ESA_DIAG_printf(ESA_COMP_GTUSERS,1,
                      "User %s is Audit",user_params->user);
      user_params->user_admin = USER_ADM_AUDIT;
     }
   else
    {
      ESA_DIAG_printf(ESA_COMP_GTUSERS,1,
                    "User %s is Audit and Admin",user_params->user);
      user_params->user_admin = USER_ADM_ALL;
    };

 /* * * * CIQ#6 start * * * */
 if (ESA_DIAG_get_debug_level(ESA_COMP_GTUSERS) EQ 6)     /* IS10156 */
  {
    ESA_DIAG_printf(ESA_COMP_GTUSERS,6, "Printing laddinfo from ACF2");
    ADDINFO_dump(laddinfo,1);
    ESA_DIAG_printf(ESA_COMP_GTUSERS,6, "Printing addinfo from caller");
    ADDINFO_dump(addinfo,1);
  };
 /*
  *  If CTSGetUsers was called with get_conn = 'Y' (account aggregation
  *  includes group connections), then do the following:
  *  Call CTSGetConns in a 'have_more' loop in order to get the user's
  *  group connections.  CTSGetConns will either return with data or
  *  not. If yes, each time through the 'have_more' loop, we add the
  *  group connection to the 'groups' ADDINFO field. When 'have_more'
  *  == 'NO_MORE' we are done with this user and we continue.
  *  Please note: We are calling CTSGetConns with a single user so each
  *  call returns, at most, a single group connection.
  */
 /* * * * BS10061 start * * *
  *
  *  QA discovered a major performance problem when doing full
  *  aggregation with get_connection = 'Y'.  The problem was
  *  introduced with the CIQ#6 fix. The problem is related to the
  *  specific call to the CTSGetConns routine. The problem is that
  *  between each new user, we allocate / free the handle, the
  *  UIDs_List area, and the local ADDINFO area, and we open / close
  *  the UCB and GDB files. Our new approach is to create a new
  *  CTSGetConns calling mode, GET_USERS_CONNS_FAST, which is similar
  *  to the pre-existing GET_USERS_CONNS calling mode but it does not
  *  do the aforementioned allocates/frees and opens/closes for each
  *  new user. Instead, the allocates and opens are done once when
  *  CTSGetConns is first called, and the frees and closes are done
  *  once at the end, after all users have been processed.
  *
  * * * * BS10061 end * * * */

  if (get_connection EQ 'Y') {
     strcpy (users_in[0], user_params->user);

     have_more = HAVE_MORE;
     while (have_more EQ HAVE_MORE) {

        ESA_DIAG_printf(ESA_COMP_GTUSERS, 6,
                 "Calling CTSGetConns - num = %d, user %s",
                 num_users_in, users_in[0]);

        if (mode EQ GET_ALL_USERS)                        /* BS10061 */
           /* * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
           /* IS10177 start                                          */
           /* * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
           {
           if (ADDINFO_alloc(func, ACF2_ADDINFO, &(addinfo_u2ug[0]),
               dest, msgs) NE ESA_OK)
              {
                CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                              dest, component, func,
                              "addinfo_u2ug alloc failed", 16,__LINE__);
                rc = ESA_FATAL;
                goto exit;
              }
           ADDINFO_empty(addinfo_u2ug[0]);
           pair = ADDINFO_search("UIDX", ACF_ADDINFO_KWD_LEN,
                                 laddinfo->pair,
                                 laddinfo->num_pairs);
           if (pair NE NULL)
              {
              if (ADDINFO_insert(TYPE_1B, "UIDX",
                                 pair->value,
                                 addinfo_u2ug[0],
                                 ACF_ADDINFO_KWD_LEN,
                                 ACF_ADDINFO_VAL_LEN,
                                 UNIQUE) NE ESA_OK)
                 {
                 sprintf(msg, "UIDX |%s| insert not successful - rc=%d",
                         pair->value, rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                               component, func, msg, 16, __LINE__);
                 rc = ESA_FATAL;
                 goto exit;
                 }
              }
           pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                                 laddinfo->pair,
                                 laddinfo->num_pairs);
           if (pair NE NULL)
              {
              if (ADDINFO_insert(TYPE_1A, "UID",
                                 pair->value,
                                 addinfo_u2ug[0],
                                 ACF_ADDINFO_KWD_LEN,
                                 ACF_ADDINFO_VAL_LEN,
                                 UNIQUE) NE ESA_OK)
                 {
                 sprintf(msg, "UID |%s| insert not successful - rc=%d",
                         pair->value, rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                               component, func, msg, 16, __LINE__);
                 rc = ESA_FATAL;
                 goto exit;
                 }
              }
           /* * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
           /* IS10177 end                                            */
           /* * * * * * * * * * * * * * * * * * * * * * * * * * * * **/
           rc = CTSGetConns (GET_USERS_CONNS_FAST,        /* BS10061 */
                                         1, &actual,
                                         &have_more,
                                         &handleFP,       /* BS10061 */
                                         num_ug_in, num_users_in,
                                         ugs_in, users_in,
                                         u2ug_out,
                                         addinfo_u2ug,
                                         objs_exist,
                                         admin_params,
                                         err);
           ADDINFO_free(&addinfo_u2ug[0]);                /* IS10177 */
           }                                              /* IS10177 */
        else                                              /* BS10061 */
           rc = CTSGetConns (GET_USERS_CONNS,
                                         1, &actual,
                                         &have_more, &handle,
                                         num_ug_in, num_users_in,
                                         ugs_in, users_in,
                                         u2ug_out,
                                         addinfo_u2ug,
                                         objs_exist,
                                         admin_params,
                                         err);

        if (rc NE ESA_OK) {
           sprintf(msg, "CTSGetConns call for %s returned with rc = %d",
                   user_params->user, rc);
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                         func, msg, 16, __LINE__);
           rc = ESA_FATAL;
           goto exit;
        }
        else {
           if (actual GT 0) {
              /*
               * If a group connection was found, we do an
               * ADDINFO_search for "groups" and we add the group
               * connection to the ADDINFO value.  We keep doing
               * this until CTSGetConns returns with no other group
               * connections.
               */
              at_least_one = 1;
              pair = ADDINFO_search("groups", ACF_ADDINFO_KWD_LEN,
                                    addinfo->pair,
                                    addinfo->num_pairs);
              if (pair NE NULL) {
                ESA_DIAG_printf(ESA_COMP_GTUSERS, 6,
                         "CTSGetConns returned with group %s",
                         u2ug_out[0].group);
                /* IS10181 catch return code so we can display error message
                ADDINFO_addval (u2ug_out[0].group,                  */
                rcc = ADDINFO_addval (u2ug_out[0].group, /* IS10181 */
                                ACF_ADDINFO_VAL_LEN,
                                ADDINFO_LIST_ENTRY,
                                pair, dest, msgs);
                /* * * * * * * IS10181 Start * * * * * * */
                /* WS10082N if ( (rcc EQ ESA_EOF) AND (already EQ 0) )*/
                if ( (rcc NE ESA_OK) AND (already EQ 0) ) /* WS10082N */
                {
                   strcpy (groupuser, u2ug_out[0].group);
                   strcat (groupuser, " user=");
                   strcat (groupuser, user_params->user);
/* WS10078ST       CTSAMSG_print(MSG_KWD_VALUE_TRUNCATED, msgs, NULL,
                                 dest, pair->keyword, groupuser);    */
                   CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        */
/* WS10078ST */                  pair->keyword,
/* WS10078ST */                  user_params->user,
/* WS10078ST */                  u2ug_out[0].group,
/* WS10078ST */                  strlen(u2ug_out[0].group),
/* WS10078ST */                  pair->vallen,
/* WS10078ST */                  "groups");
                   already = 1;
/* WS10078KM - Start  Add isIncomplete attribute in addinfo */
               rcc = ESA_OK;
               pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
               if (pair NE NULL)
               {
                  if( pair->value[0] NE 'Y')
                     rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                          pair);
                  if (rcc NE ESA_OK)
                  {
                     /* WS10082N sprintf(msg,
                             "Insert <%s> keyword failed. rc=%d",
                             "isIncomplete",rc);   */
                     /* WS10082N - start */
                     sprintf(msg,
                          "Update <isIncomplete> keyword failed. rc=%d",
                           rc);
                     /* WS10082N - end   */
                     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                                   component,func, msg, 16,__LINE__);
                  }
               }
/* WS10078KM - Ends */
                }
                /* * * * * * * IS10181 End * * * * * * */
              }
              else {
                ESA_DIAG_printf(ESA_COMP_GTUSERS, 1,
                         "No ADDINFO entry found for groups - user %s",
                         user_params->user);
                goto ciq_exit;
              }
           }
           if ((actual EQ 0) AND (at_least_one EQ 0))
              ESA_DIAG_printf(ESA_COMP_GTUSERS, 1,
                       "No groups or connections found for user %s",
                       user_params->user);
        } /* (rc EQ ESA_OK) */
     } /* while we have_more */
  } /* this is done if get_connection EQ 'Y' */
  ciq_exit:
 /* * * * CIQ#6 end * * * */

 /*
  *  Update Requested fields by caller with ACF2-retrieved fields
  */
  ADDINFO_masupd(addinfo,laddinfo,ADDINFO_masupd_NoMerge,dest,msgs);

  /* * * * * * * * WS10075 Start * * * * * * */
  if (lph NE NULL)
     if (lph->error EQ FALSE)
     {
        ESA_DIAG_printf(PLT_COMP_XREF, 6,                 /* WS10084  */
        "Before Get_User_XREFAndPermissions LID = %s",    /* WS10084  */
        user_ent);                                        /* WS10084  */
        rcc = Get_User_XREFAndPermissions(                /* WS10078T */
                 user_ent, lph, addinfo, "GET",           /* WS10078T */
                 admin_params);                           /* WS10078T */
     /* rcc = Get_user_permissions(user_ent, lph, addinfo, "GET",
                                   admin_params);            WS10078T */
        ESA_DIAG_printf(PLT_COMP_XREF, 1,                 /* WS10078T */
        "Get_User_XREFAndPermissions ended with rc = %d", /* WS10078T */
                   rcc);                                  /* WS10078T */
        if (rcc NE ESA_OK)
          if (rcc NE 1)                                   /* WS10084 */
        {
           sprintf(msg,                                   /* WS10078T */
        "Get_User_XREFAndPermissions ended with rc = %d", /* WS10078T */
                   rcc);
     /*    sprintf(msg, "Get_user_permissions returned with rc = %d",
                   rcc);                                     WS10078T */
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                         func, msg, 16, __LINE__);
        }
     }

  /* * * * * * * * WS10075 End * * * * * * * */

 /* * * * CIQ#6 start * * * */
 if (ESA_DIAG_get_debug_level(ESA_COMP_GTUSERS) EQ 6)     /* IS10156 */
  {
    ESA_DIAG_printf(ESA_COMP_GTUSERS, 6, "Printing merged addinfo");
    ADDINFO_dump(addinfo,1);
  };
 /* * * * CIQ#6 end * * * */
 /*
  *  Set all FLAG fields to "N" for fields not returned from ACF2
  */
  Complete_ADDINFO_Fields(addinfo);

  exit:;

 /* * * * BS10061 start * * */
  if ((get_connection EQ 'Y') AND (mode NE GET_ALL_USERS) AND (handle)){
     /* BS10061 if (handle) free (handle);                   // CIQ#6 */
     rcc = CTSGetConns (GET_FREE_HANDLE_CONNS,
                                         1, &actual,
                                         &have_more, &handle,
                                         num_ug_in, num_users_in,
                                         ugs_in, users_in,
                                         u2ug_out,
                                         addinfo_u2ug,
                                         objs_exist,
                                         admin_params,
                                         err);
     ESA_DIAG_printf(ESA_COMP_GTUSERS, 6,
         "Just called CTSGetConns to free handle. rcc = %d)", rcc);
  }
 /* * * * BS10061 end * * */

  ESA_DIAG_exit(ESA_COMP_GTUSERS, DEBUG_SHOW_IMPORTANT, func ,rc);
  return rc;
}

/******************************************************************
 * Procedure Name: Check_If_Admin
 ******************************************************************
 * Description   : Check if user id administrator. In this ACF2 API we
 *                 define user as administrator if he has any special
 *                 admin authority like: Leader, Consult, Security etc.
 *
 *
 * Input         : addinfo      - fields retrieved from ACF2
 *
 * Return Value  : TRUE     - ADMIN
 *                 FALSE    - NOT ADMIN
 ******************************************************************/

static int Check_If_Admin(ADDINFO_rec_ptr laddinfo)
{

  typedef struct {
   char *attr;
  } ACF2_User_Attribute;

  static ACF2_User_Attribute Admin_Attributes[] = {
   "SECURITY",
   "ACCOUNT",
   "CONSULT",
   "LEADER",
   ""
   };

  ONE_FIELD_rec_ptr pair = NULL;
  int i;

  for(i=0;Admin_Attributes[i].attr[0] NE NULL_CHAR;i++)
   {
    pair = ADDINFO_search(Admin_Attributes[i].attr, ACF_ADDINFO_KWD_LEN,
                          laddinfo->pair,
                          laddinfo->num_pairs );
    if (pair NE NULL)
       if ( strcmp(pair->value,KWD_FLAG_ON) EQ 0 )
         return TRUE;
   };

  return FALSE;
}

/******************************************************************
 * Procedure Name: Check_If_Auditor
 ******************************************************************
 * Description   : Check if user is auditor. That is, ACF2 returned
 *                 AUDIT indication for the user.
 *
 * Input         : addinfo      - fields retrieved from ACF2
 *
 * Return Value  : TRUE     - Auditor
 *                 FALSE    - Not Auditor
 ******************************************************************/
static int Check_If_Auditor(ADDINFO_rec_ptr laddinfo)
{
    ONE_FIELD_rec_ptr pair = NULL;

    pair = ADDINFO_search("AUDIT", ACF_ADDINFO_KWD_LEN,
                          laddinfo->pair,
                          laddinfo->num_pairs );
    if (pair NE NULL)
      if ( strcmp(pair->value,KWD_FLAG_ON) EQ 0 )
        return TRUE;

  return FALSE;
}

/******************************************************************
 * Procedure Name: Complete_ADDINFO_Fields
 ******************************************************************
 * Description   : For all FLAG fields requested, set OFF_FLAG for
 *                 fields not returned by ACF2 (which means they have
 *                 zero bit value).
 *
 * Input         : addinfo      - fields retrieved from ACF2
 *
 * Return Value  : None.
 ******************************************************************/
static void Complete_ADDINFO_Fields(ADDINFO_rec_ptr addinfo)
{
  static  char    func[]="Complete_ADDINFO_Fields";

  ONE_FIELD_rec_ptr pair = NULL;
  ESA_RC rc = ESA_OK;
  char field_type = ' ', field_rw = ' ';
  char field_multi = ' ';                                 /* WS2337 */
  int  i, field_length = 0, field_offset = 0;
  int  field_mvmax = 0;                                   /* WS2337 */

  ESA_DIAG_enter(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,func);

  Convert_Keyword_Chars(addinfo,'_','-');

  for(i=0;i LT addinfo->num_pairs;i++)
   {
    pair = ADDINFO_get_next(addinfo,pair);
    field_type = ' ';
    rc = ACF2_Get_Field_Information(pair->keyword,
                                    &field_type,
                                    &field_rw,
                                    &field_length,
                                    &field_offset,
                                    &field_multi,         /* WS2337 */
                                    &field_mvmax);        /* WS2337 */

    if ( (field_type EQ 'B') AND (pair->value[0] EQ NULL_CHAR) )
      ADDINFO_updval(KWD_FLAG_OFF,
                     ACF_ADDINFO_VAL_LEN,
                     pair);

   };

  Convert_Keyword_Chars(addinfo,'-','_');

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, ESA_OK);
}


/******************************************************************
 * Procedure Name: ACF2_Refresh_User_UID
 ******************************************************************
 * Description   : Refresh User-UID pairs in UDB (if changed)
 *
 * Input         : lid          - Current User
 *                 obj_exist    - Notificatiion type: User Deleted
 *                                                    User Exist
 *                 addinfo      - User's addinfo (UIDs inside)
 *
 * Return Value  : ACF2_OK - Refresh Done
 *                 other   - Refresh Failed
 ******************************************************************/
ACF2_API_Return_Codes ACF2_Refresh_User_UID(LID lid,
                                            OBJ_EXISTS_typ obj_exist,
                                            ADDINFO_rec_ptr addinfo)
{
  static char func[] = "ACF2_Refresh_User_UID";

  ACF2_API_Return_Codes ACF2_rc = ACF2_OK;
  UDB_Codes UDB_rc;
  URID temp_urid, curr_urid;                              /* WS2338 */
  UID uid,temp_uid;
  LID temp_lid;                                           /* PS0214 */
  LID temp_lid2;                                          /* WS2338 */
  ONE_FIELD_rec_ptr pair;
  int uid_is_multi;                                       /* WS2338 */
  char multi_field_name[20]="";                           /* WS2338 */
  int multi_field_offset = 0;                             /* WS2338 */
  int got_UIDX;                                           /* WS2338 */
  int urid_num;                                           /* WS2338 */
  char uids_list[9600]="";                                /* WS2338 */
  char *current_uid = NULL;                               /* WS2338 */
  char entry_sep[2];                                      /* WS2338 */

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func);

  entry_sep[0] = ADDINFO_LIST_ENTRY;                      /* WS2338 */
  entry_sep[1] = NULL_CHAR;                               /* WS2338 */

  memset(temp_urid,0X00,sizeof(temp_urid));               /* WS2338 */
  memset(temp_lid,0X00,sizeof(temp_lid));                 /* BS2300 */
  memset(temp_lid2,0X00,sizeof(temp_lid2));               /* WS2338 */
  memset(temp_uid,0X00,sizeof(temp_uid));                 /* BS2300 */
  memset(uid,0X00,sizeof(uid));                           /* BS2300 */

  strcpy(temp_lid,lid);                                   /* PS0214 */
  strcpy(temp_urid,"0001");                               /* WS2338 */

  Trim(temp_lid);                                         /* PS0214 */

  uid_is_multi = UID_Contains_MULTI(multi_field_name,
                                    &multi_field_offset); /* WS2338 */

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                  "UID is multi=(%d)", uid_is_multi);     /* PS0338 */

 /*---------------------------------------------------------------*
  * Skip processing if UDB is not operational                     *
  *---------------------------------------------------------------*/

  if (Global_UDB_Active() EQ FALSE)
   goto exit;

 /*---------------------------------------------------------------*
  * Get UIDs from addinfo                                         *
  *---------------------------------------------------------------*/
  got_UIDX = FALSE;                                       /* WS2338 */

  if (uid_is_multi)                                       /* WS2338 */
  {
    pair = ADDINFO_search("UIDX", ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

    if (pair EQ NULL)
    {
      ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                      "UIDX not found. Search for UID");  /* PS0338 */

      pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
      if (pair NE NULL)
       strcpy(uid,pair->value);
      else
       strcpy(uid,"")         ;
    }
    else
    {
      got_UIDX = TRUE;
      ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                      "Found UIDX keyword");              /* PS0338 */
    };
  }
  else
  {
    pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);
    if (pair NE NULL)
     strcpy(uid,pair->value);
    else
     strcpy(uid,"")         ;
  };

 /*---------------------------------------------------------------*
  * Check Refresh Operation required:                             *
  * ---------------------------------                             *
  * OBJ_EXIST: Insert/Update User-UID pairs                       *
  * OBJ_NOT_EXIST: Delete User-UID pairs                          *
  *---------------------------------------------------------------*/
 switch(obj_exist)
  {
   case OBJ_EXIST:
    /*
     * Locate User in UDB
     */
   /* WS2338 - Replaced
    UDB_rc = UDB_Locate(temp_lid,UDB_Exact_Locate);
   */
    ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                    "Calling UDB_Locate with lid=|%s| urid=|%s|",
                    temp_lid, temp_urid);
    UDB_rc = UDB_Locate(temp_urid,
                        temp_lid,
                        UDB_Exact_Locate);                /* WS2338 */

    ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                    "UDB_Locate rc=(%d)", UDB_rc);        /* PS0338 */

    /* WS2338 - Added logic                                    */
    /* If user is found:                                       */
    /* - If UID contains MULTI VALUED field, delete all user's */
    /*   LID-UID pairs and insert new updated ones.            */
    /*                                                         */
    /* - Else, just update the user's LID-UID pair (only one). */
    /*                                                         */
    switch(UDB_rc)
     {
      case UDB_OK:
       if (uid_is_multi)
       {
         ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                         "User records found. Delete all records");
                                                          /* PS0338 */
         UDB_rc = UDB_GetNext(temp_urid,
                              temp_lid2,
                              temp_uid);

         ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                         "UDB_GetNext rc=(%d)", UDB_rc);  /* PS0338 */

         /* Delete all user's LID-UID pairs */
         while (UDB_rc NE UDB_EOF)
         {
           ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                           "cLID(%s) cURID(%s) cUID(%s)",
                           temp_lid2, temp_urid, temp_uid);
                                                          /* PS0338 */
           /* Stop if we reached a different user's 1st record */
           if ( (strcmp (temp_urid, "0001") EQ 0) AND
                (strcmp (temp_lid2, temp_lid) NE 0) )
             break;

           UDB_rc = UDB_Delete();

           ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                           "UDB_Delete rc=(%d)", UDB_rc); /* PS0338 */

           if (UDB_rc NE UDB_OK)
           {
            ACF2_rc = ACF2_Internal_Error;
            goto exit;
           };

           UDB_rc = UDB_GetNext(temp_urid,
                                temp_lid2,
                                temp_uid);

           ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                           "UDB_GetNext loop rc=(%d)", UDB_rc);
                                                          /* PS0338 */
         };

         /* Insert new updated LID-UID pair/s */
         if (got_UIDX)
         {
           strcpy (uids_list, pair->value);
           current_uid = strtok (uids_list, entry_sep);
           urid_num = 1;

           /* Loop to insert all user LID-UID pairs */
           while (current_uid NE NULL)
           {
             sprintf (curr_urid, "%04d", urid_num);

             /* UIDs in UIDX are blank padded. Remove the blanks. */
             strcpy (temp_uid, current_uid);              /* PS0338 */
             Trim (temp_uid);                             /* PS0338 */

             UDB_rc = UDB_Insert(curr_urid,temp_lid,temp_uid);
                                                          /* PS0338 */
             if (UDB_rc NE UDB_OK)
             {
               ACF2_rc = ACF2_Internal_Error;
               goto exit;
             };
             current_uid = strtok (NULL, entry_sep);
             urid_num = urid_num + 1;
           };
           goto exit;
         }
         else
         {
           UDB_rc = UDB_Insert(temp_urid,temp_lid,uid);
           if (UDB_rc NE UDB_OK)
            ACF2_rc = ACF2_Internal_Error;
           goto exit;
         };
       }
       else
       {
         /* Update existing LID-UID pair */
         UDB_rc = UDB_GetNext(temp_urid,                  /* WS2338 */
                              temp_lid,
                              temp_uid);

         if (strcmp(temp_uid,uid) NE 0)
          {
           UDB_rc = UDB_Update(temp_urid,temp_lid,uid);   /* WS2338 */
           if (UDB_rc NE UDB_OK)
            ACF2_rc = ACF2_Internal_Error;
          };
         goto exit;
       };

       break;

      /*
       * If User not found, Insert new pair/s to UDB
       */
      case UDB_Not_Found:
       if (uid_is_multi)                                  /* WS2338 */
       {
         if (got_UIDX)
         {
           strcpy (uids_list, pair->value);

           ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                   "UIDS list=(%s)", uids_list);          /* PS0338 */

           current_uid = strtok (uids_list, entry_sep);
           urid_num = 1;

           /* Loop to insert all user LID-UID pairs */
           while (current_uid NE NULL)
           {
             ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                     "Current UID=(%s)", current_uid);    /* PS0338 */

             sprintf (curr_urid, "%04d", urid_num);

             /* UIDs in UIDX are blank padded. Remove the blanks. */
             strcpy (temp_uid, current_uid);              /* PS0338 */
             Trim (temp_uid);                             /* PS0338 */

             UDB_rc = UDB_Insert(curr_urid,temp_lid,temp_uid);
                                                          /* PS0338 */
             if (UDB_rc NE UDB_OK)
             {
               ACF2_rc = ACF2_Internal_Error;
               goto exit;
             };
             current_uid = strtok (NULL, entry_sep);
             urid_num = urid_num + 1;
           };
           goto exit;
         }
         else
         {
           UDB_rc = UDB_Insert(temp_urid,temp_lid,uid);
           if (UDB_rc NE UDB_OK)
            ACF2_rc = ACF2_Internal_Error;
           goto exit;
         };
       }
       else
       {
         UDB_rc = UDB_Insert(temp_urid,temp_lid,uid);
         if (UDB_rc NE UDB_OK)
          ACF2_rc = ACF2_Internal_Error;
         goto exit;
       };
       break;

      default:;
       ACF2_rc = ACF2_Internal_Error;
     };
    break;

   /*
    * Process "User does not exist" event
    */
   case OBJ_NOT_EXIST:

   /* WS2338 - Replaced
    UDB_rc = UDB_Locate(temp_lid,UDB_Exact_Locate);
   */
    UDB_rc = UDB_Locate(temp_urid,
                        temp_lid,
                        UDB_Exact_Locate);                /* WS2338 */

    if (UDB_rc EQ UDB_OK)
     {
       /* WS2338 - Delete all LID-UID pairs of current user */
       UDB_rc = UDB_GetNext(temp_urid,
                            temp_lid2,
                            temp_uid);                    /* WS2338 */

       /* WS2338 */
       while (UDB_rc NE UDB_EOF)
       {
         /* Stop if we reached a different user's 1st record */
         if ( (strcmp (temp_urid, "0001") EQ 0) AND
              (strcmp (temp_lid2, temp_lid) NE 0) )
           break;

         UDB_rc = UDB_Delete();
         if (UDB_rc NE UDB_OK)
         {
          ACF2_rc = ACF2_Internal_Error;
          goto exit;
         };

         UDB_rc = UDB_GetNext(temp_urid,
                              temp_lid2,
                              temp_uid);
       };
     };
    goto exit;

   default:;
    ACF2_rc = ACF2_Internal_Error;
  };

  exit:;

  /* BS2586 set same diag level for exit as enter */
  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func, ACF2_rc);
  return ACF2_rc;
}

/******************************************************************
 * Procedure Name: ACF2_Clean_UDB
 ******************************************************************
 * Description   : Delete all entries from UDB (when GET_ALL_USERS)
 *
 * Input         : None
 * Return Value  : None
 ******************************************************************/
static ACF2_API_Return_Codes ACF2_Clean_UDB(void)
{
  static char func[] = "ACF2_Clean_UDB";

  ACF2_API_Return_Codes ACF2_rc = ACF2_OK;
  UDB_Codes UDB_rc = UDB_OK;
  URID urid;                                              /* WS2338 */
  UID uid;
  LID lid;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*---------------------------------------------------------------*
  * Skip processing if UDB is not operational                     *
  *---------------------------------------------------------------*/

  if (Global_UDB_Active() EQ FALSE)
   goto exit;

 /*---------------------------------------------------------------*
  * Check Refresh Operation required:                             *
  * ---------------------------------                             *
  * OBJ_EXIST: Insert/Update User-UID pair                        *
  * OBJ_NOT_EXIST: Delete User-UID pair                           *
  *---------------------------------------------------------------*/
 while(UDB_rc EQ UDB_OK)
  {
    UDB_rc = UDB_GetNext(urid,lid,uid);                   /* WS2338 */
    if (UDB_rc EQ UDB_OK)
     UDB_rc = UDB_Delete();
   };

  if (UDB_rc NE UDB_Not_Found)
   ACF2_rc = ACF2_Internal_Error;

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, ACF2_rc);
  return ACF2_rc;
}

/******************************************************************
 * Procedure Name: Cleanup
 ******************************************************************
 * Description   : Perform API Handle cleanup
 *
 * Input         : h            - handle strcuture pointer
 *                 handle       - API handle paramter
 *
 * Return Value  : None.
 ******************************************************************/
static void Cleanup(ACF2_Get_Users_Handle *h,
                    void **handle,
                    ADMIN_PARAMS_rec_typ * admin_params,
                    ERR_STRUCT_rec_typ   * err)
{
  int rcc = ESA_OK;                                       /* WS10075 */

  /* Set API Handle paramter to NULL */

  *handle = NULL;

  /* Free Handle Structure  */
  if (h NE NULL)
   {
    if (h->laddinfo NE NULL)
        ADDINFO_free(&(h->laddinfo));

    /* * * * * * * * WS10075 Start * * * * * * */

    if (h->lid_perm_handle NE NULL)
    {
    /* rcc = Get_user_permissions("", h->lid_perm_handle,  WS10078T */
       rcc = Get_User_XREFAndPermissions("",            /* WS10078T */
                          h->lid_perm_handle,           /* WS10078T */
                          NULL, "TERM", admin_params);

       free(h->lid_perm_handle);
    }

    /* * * * * * * * WS10075 End * * * * * * * */

    free(h);
   };

  if (UDB_Opened EQ TRUE)
   {
    UDB_Set_Mode(UDB_Closed,admin_params,err);
    UDB_Opened = FALSE;
   };


  /* Reset User Count */

  user_count = 0;
}
/*             Start WS10078T                                    */
/******************************************************************
 * Procedure Name: Get_User_XREFAndPermissions
 ******************************************************************
 * Description   : Call the Get_Rule_Record routine to read records
 *                 from ACFRPTRX output (from memory) and copy all
 *                 direct and indirect permissions to addinfo.
 *                 This routine is called for account aggregation
 *                 and for SYNC user processing.
 *
 * Input         : LID
 *                 pointer to LID permissions handle
 *                 addinfo
 *                 call type: GET or TERM
 * Output        : addinfo - permissions are copied here
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_EOF   - end_of_file reached
 ******************************************************************/
static ESA_RC Get_User_XREFAndPermissions(char        * LID,
                              LID_PERM_handle_rec_typ * lid_perm_handle,
                              ADDINFO_rec_ptr           addinfo,
                              char                    * call_type,
                              ADMIN_PARAMS_rec_typ    * admin_params)
{
  static char func[] = "Get_User_XREFAndPermissions";

  ESA_RC     rc = ESA_OK;
  ESA_RC     rcc = ESA_OK;
  PB_Build_Request_typ   * PB_Req = NULL;                /* WS10084 */
  char     * from = NULL;
  char     * to = NULL;
  int        i = 0, first_time = 0, lid_found = 0, len = 0;
  int        perms_exist = FALSE;                        /* BS10108T */
  int        issue_no_permissions_message = TRUE;        /* BS10108T */
  char       resource_type[4] = "";
  char       type[4] = "";
  char       lid[ACF2_LID_SIZE] = "";
  char       inputLID[ACF2_LID_SIZE] = "";
  char       formatted_permission[ACF2_MAX_PERMISSN_SIZE] = "";
  char       rule_record[ACF2_MAX_PERMISSN_SIZE] = "";
  char       errmsg[125] = "";
  char       function[10];
  Permission_Record_Type   requested_record_type;
  Permission_Record_Type   returned_record_type;
  /* BS10111 GET_LINE_PTR             get_line_ptr;                  */
  /*WS10082AL ONE_FIELD_rec_ptr        direct_pair   = NULL; */
  /*WS10082AL ONE_FIELD_rec_ptr        indirect_pair = NULL; */
  RULE_TYPE_PERM_rec_typ * rule_type_perm_vec;
  /* BS10111 IDB_GETRUOBLINE_rec_typ   input_desc_block;             */

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "strlen of LID = %d",strlen(LID));

  strcpy(inputLID, LID);
  ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "Pre-trim  LID/inputLID = |%.8s|/|%.8s| ",
                     LID,inputLID);
  Trim(inputLID);
  ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "Post-trim LID/inputLID = |%.8s|/|%.8s| ",
                     LID,inputLID);


  /* WS10084
  if (strcmp(inputLID,"#RQ") EQ 0)
     want_diag = TRUE;
  else
     want_diag = FALSE;

     WS10084       */
  /* BS10111 get_line_ptr = &ESA_CLI_get_RUOB_line;  */

  if (strcmp(call_type, "TERM") EQ 0)
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Processing TERM request");

   if (lid_perm_handle NE NULL)
    {
     /* WS10084
     for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
     {
        rc = Get_Rule_Record(
               "TERM",
               &(lid_perm_handle->lidra_vec[i].get_rule_record_handle),
    /* BS10111 get_line_ptr,  @/
    /* BS10111 &input_desc_block, @/
               lid_perm_handle->lidra_vec[i].lidra,       /* BS10111 @/
               requested_record_type,
               sizeof(rule_record),
               "ACFRPTRX",
               &returned_record_type,
               rule_record,
               resource_type,
               admin_params);

        ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "Get_Rule_Record TERM i = %d rc = %d",
                     i,rc);

     }

     /*WS10078A rc = ACF2_get_LID_rules("TERM", @/
     rc = ACF2_Get_ACFRPTRX_Report("TERM",            /*WS10078A@/
                             lid_perm_handle,
                             admin_params);

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "ACF2_Get_ACFRPTRX_Report TERM rc = %d",/*WS10078A@/
                    rc);
       WSRPTRC */

     /*WS10079A if (lid_perm_handle->SourcesBlk  NE NULL)
       if (lid_perm_handle->SourcesBlk  NE INACT_BLOCK)    * BS10108T */
     if (NOT lid_perm_handle->Source_error)               /*WS10079A*/
        {
          /*WS10079A replace with Get_User_XSGP
          rc = XREF_Block_Build(
              "TERM",
              &(lid_perm_handle->SourcesBlk),
              NULL,
              XREF_REC_TYPE_SGP,
              admin_params); ***/
          if(lid_perm_handle->get_user_xsgp_handle NE NULL){/*WS10079A*/
            rc = Get_User_XSGP("TERM",                     /*WS10079A*/
               inputLID,
               lid_perm_handle,                            /* WS10079T*/
               (Get_User_XSGP_handle **)
               &(lid_perm_handle->get_user_xsgp_handle),
               addinfo,
               admin_params);

            ESA_DIAG_printf(PLT_COMP_XREF, 6,
            /*WS10079A "XREF_Block_Build TERM SourcssBlk rc = %d",*/
             "Get_User_XSGP TERM rc = %d",rc);         /*WS10079A*/
          }                                            /*WS10079A*/
        }

     /*WS10079A if (lid_perm_handle->RolesBlk  NE NULL)
       if (lid_perm_handle->RolesBlk  NE INACT_BLOCK)     * BS10108T */
     if (NOT lid_perm_handle->Role_error)                 /*WS10079A*/
        {
          /*WS10079A rc = XREF_Block_Build(
              "TERM",
              &(lid_perm_handle->RolesBlk),
              NULL,
              XREF_REC_TYPE_ROLE,
              admin_params); replace with below calls */
          if(lid_perm_handle->get_user_xrol_handle NE NULL){/*WS10079A*/
          /*ctrace("Before Get_User_XROL( TERM");          /@ WS10084 */
            rc = Get_User_XROL("TERM",                     /*WS10079A*/
                  inputLID,                                /*WS10079A*/
                  lid_perm_handle,
                  /*WS10079A    lid_perm_handle->RolesBlk, */
                  (Get_User_XROL_handle **)                /*WS10079A*/
                  &(lid_perm_handle->get_user_xrol_handle),/*WS10079A*/
                  addinfo,
                  admin_params);

            ESA_DIAG_printf(PLT_COMP_XREF, 6,
             /*WS10079A "XREF_Block_Build TERM RolesBlk rc = %d",*/
             "Get_User_XROL TERM rc = %d",rc);         /*WS10079A*/
          }
        }
    /* free(lid_perm_handle->rule_type_perm_vec);           WS10084 */
    /* WS10084 start */
     PB_Req = lid_perm_handle->PB_Req;
     if (PB_Req NE NULL)
     {
       ESA_DIAG_printf(PLT_COMP_XREF, 6,
             "Before Permissions_block_Build FREE");
       rc = Permissions_block_Build("FREE",
                                  PB_Req,
                                  PLT_COMP_PERMISSION,
                                  admin_params);

       if (rc NE ESA_OK)
         {sprintf(errmsg,
               "Permissions_Block_Build FREE ended with rc = %d",rc);

          CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                     func, errmsg, 16, __LINE__);
         }
      if (PB_Req->Users_PBhandle_ptr NE NULL)
          free(PB_Req->Users_PBhandle_ptr);
      if (PB_Req->Groups_PBhandle_ptr NE NULL)
          free(PB_Req->Groups_PBhandle_ptr);
       free(PB_Req);
       PB_Req = NULL;
       if (lid_perm_handle NE NULL)
         lid_perm_handle->PB_Req = NULL;
    }
    /* WS10084 end   */
    };
     goto exit;
  };

  if (strcmp(call_type, "GET") NE 0)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "invalid input function parameter",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  /*----------------------------------------------------------*/
  /* process the get request                                  */
  /*----------------------------------------------------------*/

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "Processing GET request for LID/inputLID = |%.8s|/|%.8s| ",
                     LID,inputLID);

  memset (function, 0X00, sizeof(function));
  if (lid_perm_handle EQ NULL)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
             func, "LID Permissions handle pointer NULL",
             16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }

  if (lid_perm_handle->error EQ TRUE)
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "LID Permissions handle error indicator on");
     rc = ESA_OK;
     goto exit;
  }
  /* WS10084 start */
  ESA_DIAG_printf(PLT_COMP_XREF, 2,
         "Processing GET request for LID = |%.8s|",
                     inputLID);
  PB_Req = lid_perm_handle->PB_Req;
  if (PB_Req EQ NULL)
  {
    PB_Req = calloc (1, sizeof(PB_Build_Request_typ));

    if (NOT PB_Req)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
               "PB_Req", sizeof(PB_Build_Request_typ));
       rc = ESA_FATAL;
       goto exit;
    }
    lid_perm_handle->PB_Req = PB_Req;
    first_time = TRUE;
    PB_Req->Groups_PBhandle_ptr = NULL;
    PB_Req->Users_PBhandle_ptr  = NULL;
    PB_Req->Roles_XBhandle_ptr  = NULL;
    PB_Req->lid[0]              = NULL_CHAR;
    PB_Req->GroupDirect         = FALSE;
    PB_Req->AccountDirect       = FALSE;
    PB_Req->AccountIndirect     = FALSE;
    PB_Req->AccountRoleDirect   = FALSE;
    PB_Req->AccountRoleIndirect = FALSE;
    PB_Req->RoleDirect          = FALSE;
    PB_Req->PB_rules_nf         = FALSE;
    PB_Req->PB_xref_nf          = FALSE;
    PB_Req->PBbldErr            = FALSE;
    PB_Req->PBErr               = FALSE;
    PB_Req->RequiredRoles       = lid_perm_handle->RequiredRoles;
  }


  /* WS10084 end   */

  /* WS10079T start
  if (
        (
          (lid_perm_handle->RequiredRoles NE NULL_CHAR)
          AND
          (lid_perm_handle->RolesBlk      EQ NULL)
        )
       OR
        (
          (lid_perm_handle->RequiredSources  NE NULL_CHAR)
          AND
          (lid_perm_handle->SourcesBlk    EQ NULL)
        )
       OR
        (
          (lid_perm_handle->RequiredPermissions  NE NULL_CHAR)
          AND
          (lid_perm_handle->lidra_vec            EQ NULL)
        )
     )

     {
        /@ if sources required call to XREF_Block_Build
           for sources  @/

        if ( (lid_perm_handle->RequiredSources  NE NULL_CHAR)
            AND
             (lid_perm_handle->SourcesBlk    EQ NULL) )
           {
             rc = XREF_Block_Build(
                 "BLDSHORT",
                 &(lid_perm_handle->SourcesBlk),
                 NULL,
                 XREF_REC_TYPE_SGP,
                 admin_params);

             ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "XREF_Block_Build BLDSHORT SourcesBlk rc = %d",
                     rc);

             if (rc EQ ESA_FATAL)
                /@ BS10108T -   start  @/
                {
                  lid_perm_handle->SourcesBlk      = INACT_BLOCK;
                  CTSAMSG_print(WARN_INT1, msgs, NULL, dest,
                      component,func,
                      "Account Source connections are not provided. "
                      "They do not exist or cannot be retrieved due "
                      "to internal error",
                      16, __LINE__);
                  rc = ESA_OK;
                }
                /@ goto exit;   @/
                /@ BS10108T -   end    @/
           }

        if ( (lid_perm_handle->RequiredRoles NE NULL_CHAR)
            AND
             (lid_perm_handle->RolesBlk      EQ NULL) )
           {
             rc = XREF_Block_Build(
                 "BLDSHORT",
                 &(lid_perm_handle->RolesBlk),
                 NULL,
                 XREF_REC_TYPE_ROLE,
                 admin_params);

             ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "XREF_Block_Build BLDSHORT RolesBlk rc = %d",
                     rc);

             if (rc EQ ESA_FATAL)
                /@ BS10108T -   start  @/
                {
                  lid_perm_handle->RolesBlk      = INACT_BLOCK;
                  CTSAMSG_print(WARN_INT1, msgs, NULL, dest,
                      component,func,
                      "Account Role connections are not provided. "
                      "They do not exist or cannot be retrieved due "
                      "to internal error",
                      16, __LINE__);
                  rc = ESA_OK;
                }
                /@ goto exit;   @/
                /@ BS10108T -   end    @/

             if (lid_perm_handle->RolesBlk      NE NULL)
              if (lid_perm_handle->RolesBlk              /@ BS10108T @/
                                   NE INACT_BLOCK)       /@ BS10108T @/
                lid_perm_handle->lidra_vec_num = 1;
           }
        WS10079T end */
  /*  WS10079T start */
  /* WS10084
  if  ( ((lid_perm_handle->RequiredPermissions  NE NULL_CHAR)  OR
         (lid_perm_handle->RequiredRoles NE NULL_CHAR))
          AND
         (lid_perm_handle->lidra_vec            EQ NULL)  )
     {
        if (lid_perm_handle->RequiredRoles NE NULL_CHAR)   /*WS10079T@/
                lid_perm_handle->lidra_vec_num = 1;        /*WS10079T@/

        if (lid_perm_handle->RequiredPermissions  NE NULL_CHAR)
                lid_perm_handle->lidra_vec_num = 0;

        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "Processing GET request for LID |%s|", inputLID);

        ESA_DIAG_printf(PLT_COMP_XREF, 6,
                  "Processing GET request for LID |%.8s|", inputLID);

        /*WS10078A rc = ACF2_get_LID_rules("GET", @/
        rc = ACF2_Get_ACFRPTRX_Report("GET",      /*WS10078A@/
                             lid_perm_handle,
                             admin_params);

        ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "ACF2_Get_ACFRPTRX_Report GET rc = %d",
                     rc);

        if (rc NE ESA_OK)
        {
           lid_perm_handle->error = TRUE;
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "ACF2_Get_ACFRPTRX_Report not successful",
                   16, __LINE__);
           rc = ESA_FATAL;
           goto exit;
        }

        ESA_DIAG_printf(PLT_COMP_XREF, 6,               /* WS10079T @/
                     "lid_perm_handle->lidra_vec = %p", /* WS10079T @/
                     lid_perm_handle->lidra_vec);       /* WS10079T @/
        rule_type_perm_vec = lid_perm_handle->rule_type_perm_vec ;


        ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "1: rule_type_perm_vec = <%p>",
                      rule_type_perm_vec);

        if (NOT lid_perm_handle->rule_type_perm_vec)
            rule_type_perm_vec = (RULE_TYPE_PERM_rec_typ *)
                     calloc (lid_perm_handle->lidra_vec_num,
                                   sizeof(RULE_TYPE_PERM_rec_typ));
        if (NOT rule_type_perm_vec)
        {
           CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                         "RULE_TYPE_PERM handle vector",
                                   sizeof(RULE_TYPE_PERM_rec_typ));
           rc = ESA_FATAL;
           goto exit;
        };

        lid_perm_handle->rule_type_perm_vec = rule_type_perm_vec;

        for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
        {
           strcpy (rule_type_perm_vec[i].rules_type,
                   lid_perm_handle->lidra_vec[i].rules_type);
        };
     };

     rule_type_perm_vec = lid_perm_handle->rule_type_perm_vec ;

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "2: rule_type_perm_vec = <%p>",
                      rule_type_perm_vec);

       WS10084 */

     if (lid_perm_handle->RequiredSources NE NULL_CHAR)
    /*if (lid_perm_handle->SourcesBlk NE INACT_BLOCK)   /@ BS10108T @/
                                                           WS10079T */
        /* WS10079N
        if (lid_perm_handle->Source_error NE TRUE)    /@ BS10110N @/ */
        if ( (lid_perm_handle->Source_error NE TRUE)    /* WS10079N */
               AND                                      /* WS10079N */
             (lid_perm_handle->Source_nf NE TRUE) )     /* WS10079N */
        {
  /* WS10078N  rc = Get_User_XSGP(inputLID,   */
          rc = Get_User_XSGP("GET",                    /* WS10079A */
                   LID,                                /* WS10078N */
                   lid_perm_handle,                    /*bWS10079T */
                   /*WS10079A lid_perm_handle->SourcesBlk,         */
                   (Get_User_XSGP_handle **)             /*WS10079A*/
                   &(lid_perm_handle->get_user_xsgp_handle),/*WS10079A*/
                   addinfo,
                   admin_params);
          ESA_DIAG_printf(PLT_COMP_XREF, 6,               /* WS10079N */
             "Get_User_XSGP rc = %d   Error = %d   nf = %d",/*WS10079N*/
                  rc, lid_perm_handle->Source_error,      /* WS10079N */
                  lid_perm_handle->Source_nf);            /* WS10079N */
          if (rc EQ ESA_ERR)                              /* WS10079N */
          {                                               /* WS10079N */
            if (lid_perm_handle->Source_nf EQ TRUE)       /* WS10079N */
            {                                             /* WS10079N */
              CTSAMSG_print(ACF2_XREF_STOPPED_NF,         /* WS10079N */
                            msgs, NULL, dest,             /* WS10079N */
                            "Sources", "X(SGP)");         /* WS10079N */
            }                                             /* WS10079N */
          }                                               /* WS10079N */
          else                                            /* WS10079N */
          /* WS10079T start */
          if ( (rc EQ ESA_FATAL)
             AND (lid_perm_handle->Source_error) )
            {
               /*
               CTSAMSG_print(WARN_INT1, msgs, NULL, dest,
                   component,func,
                   "Account Source connections are not provided. "
                   "They do not exist or cannot be retrieved due "
                   "to internal error",
                   4, __LINE__);
               */
            CTSAMSG_print(ACF2_ACCT_XREF_CONS_NOT_PRVD,
                          msgs, NULL, dest, "Source");
               rc = ESA_OK;
            }
          /* WS10079T end   */
          if (rc EQ ESA_FATAL)
          {                                               /* BS10110N */
            /* BS10110N goto exit;                            */
            lid_perm_handle->Source_error = TRUE;         /* BS10110N */
            CTSAMSG_print(ACF2_XREF_STOPPED, msgs,        /* BS10110N */
                          NULL, dest,                     /* BS10110N */
                         "Sources");                      /* BS10110N */
          }                                               /* BS10110N */
        }

  /* WS10084
  lid_found = FALSE;

  /*----------------------------------------------------------@/
  /* Outermost loop: Loop through LID rule area vector (same  @/
  /* index used for rule type permissions handle vector).     @/
  /*----------------------------------------------------------@/

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "About to start outer loop");

  for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
  {
     /* BS10105  - start @/
     /*
     if ( (rule_type_perm_vec[i].permError_indicator
                                                           EQ TRUE) OR
          (lid_perm_handle->lidra_vec[i].IOError_indicator EQ TRUE) OR
          (lid_perm_handle->lidra_vec[i].EOF_indicator     EQ TRUE) ) @/

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "i=%d: prm_error = %d  io_error = %d   EOF = %d",
          i, rule_type_perm_vec[i].permError_indicator,
          lid_perm_handle->lidra_vec[i].IOError_indicator,
          lid_perm_handle->lidra_vec[i].EOF_indicator);

     if ( (rule_type_perm_vec[i].permError_indicator
                                                           EQ TRUE) OR
          (lid_perm_handle->lidra_vec[i].IOError_indicator EQ TRUE) )
     /* BS10105  - end   @/
        continue;

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "1: i=%d inputLID=<%s> last_read=<%s> last_processed=<%s>",
          i,inputLID,rule_type_perm_vec[i].last_lid_read,
          rule_type_perm_vec[i].last_lid_processed);

     if ( (rule_type_perm_vec[i].last_lid_read[0] NE NULL_CHAR)

          AND
          (strcmp(rule_type_perm_vec[i].last_lid_read,
                  rule_type_perm_vec[i].last_lid_processed) LT 0) )
     {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
               func, "last LID read less than last LID processed",
               16, __LINE__);
       rule_type_perm_vec[i].permError_indicator = TRUE;
       continue;
     }

     /* BS10105  - start */
     /* if we reached EOF and now need to process a role which is
        higher than the role that was processed, we have nothing
        to do becasue this role do not have permissions.           @/
     if ( (lid_perm_handle->lidra_vec[i].EOF_indicator EQ TRUE)
          AND
           (strcmp(inputLID,
                   rule_type_perm_vec[i].last_lid_processed) GT 0) )
       continue;
     /* BS10105  - end   @/

     /* BS10111
     /@----------------------------------------------------------@/
     /@ Initialize the input descriptor block (for the           @/
     /@ Get_Rule_Record routine) and get to work.                @/
     /@----------------------------------------------------------@/
     input_desc_block.blk = lid_perm_handle->lidra_vec[i].lidra;
     @/

     /*----------------------------------------------------------@/
     /* If last_lid_read is empty . . .                          @/
     /*    If input_LID LE last_lid_processed . . .              @/
     /*----------------------------------------------------------@/

     if (rule_type_perm_vec[i].last_lid_read[0] EQ NULL_CHAR)

     {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "Last lid read is empty");
        requested_record_type = LID_LINE;
        if (strcmp(inputLID,
                   rule_type_perm_vec[i].last_lid_processed) LE 0)
           strcpy(function, "GETFIRST");
        else
           strcpy(function, "GETNEXT");
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17, /*WS10078A@/
                        "function=<%s>",function);
     }

     else
     {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                 "Last lid read is |%s|",
                  rule_type_perm_vec[i].last_lid_read);
        if (strcmp(inputLID, rule_type_perm_vec[i].last_lid_read) EQ 0)
        {
           lid_found = TRUE;
           ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "inputLID=<%s> found(last_read)",inputLID);
           memset(rule_type_perm_vec[i].last_lid_read, 0X00,
                  sizeof(rule_type_perm_vec[i].last_lid_read));
        }
        else if (strcmp(inputLID,
                 rule_type_perm_vec[i].last_lid_read) GT 0)
        {
           requested_record_type = LID_LINE;
           strcpy(function, "GETNEXT");
           memset(rule_type_perm_vec[i].last_lid_read, 0X00,
                  sizeof(rule_type_perm_vec[i].last_lid_read));
        }
        else if (strcmp(inputLID,
                        rule_type_perm_vec[i].last_lid_read) LT 0)
        {
           if (strcmp(inputLID,
                      rule_type_perm_vec[i].last_lid_processed) LT 0)
           {
              requested_record_type = LID_LINE;
              strcpy(function, "GETFIRST");
              memset(rule_type_perm_vec[i].last_lid_read, 0X00,
                     sizeof(rule_type_perm_vec[i].last_lid_read));
           }
           else /* input_LID GE last_lid_processed @/
           {
              continue;
           }
        }
     }; /* If last_lid_read is not empty . . . */

     /* BS10105  - start */
     /*
      *   If function is GETFIRST clear the EOF flag because we
      *   are not at the end of the report any more...
      @/
     if (strcmp(function, "GETFIRST") EQ 0)
       lid_perm_handle->lidra_vec[i].EOF_indicator = FALSE;
     /* BS10105  - end   */

     /*----------------------------------------------------------@/
     /* Set the last_lid_processed (with the input_LID) and      @/
     /* clear the last_lid_read                                  @/
     /*----------------------------------------------------------@/

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "Setting last lid processed to |%s|", inputLID);

     strcpy(rule_type_perm_vec[i].last_lid_processed, inputLID);
     memset(rule_type_perm_vec[i].last_lid_read, 0X00,
            sizeof(rule_type_perm_vec[i].last_lid_read));

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "2: i=%d inputLID=<%s> last_read=<%s> last_processed=<%s>",
          i,inputLID,rule_type_perm_vec[i].last_lid_read,
          rule_type_perm_vec[i].last_lid_processed);

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "requested_record_type=<%d>",requested_record_type);
     if (lid_found EQ FALSE)
      {
        do
        {
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Calling Get_Rule_Record requesting :LID line");

         rc = Get_Rule_Record(
              function,
              &(lid_perm_handle->lidra_vec[i].get_rule_record_handle),
   /* BS10111 get_line_ptr, @/
   /* BS10111 &input_desc_block, @/
              lid_perm_handle->lidra_vec[i].lidra,        /* BS10111 @/
              requested_record_type,
              sizeof(rule_record),
              "ACFRPTRX",
              &returned_record_type,
              rule_record,
              resource_type,
              admin_params);

         ESA_DIAG_printf(PLT_COMP_XREF, 6,
           "Get_Rule_Record GET LID Line i = %d rc = %d recType=<%d>",
            i,rc,returned_record_type);

         if (rc NE ESA_OK)
         {
           if (rc EQ ESA_WARN) /* end_of_user indication @/
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                              "end of user condition encountered");
              rc = ESA_OK;
              break;
           }
           else if (rc EQ ESA_EOF)  /* end_of_file indication @/
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                              "end of file condition encountered");
              lid_perm_handle->lidra_vec[i].EOF_indicator = TRUE;
              rc = ESA_OK;
              break;
           }
       /*  else if (rc EQ ESA_SKIP)
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "permission output area not large enough");
              rc = ESA_OK;
              continue;
           }    @/
           else
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "serious Get_Rule_Record error encountered");
              lid_perm_handle->lidra_vec[i].IOError_indicator = TRUE;
              break;
           }
         }  /* end rc NE ESA_OK  @/

         strcpy(function, "GETNEXT");

         if (returned_record_type EQ LID_LINE)
         {
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Get_Rule_Record returned a :LID line");
            from = strstr(rule_record, "LID: ");
            from += 5;                   /* point to start of lid @/
            to = strchr(from, ' ');             /* look for blank @/
            len = to - from;                /* calc length of lid @/
            memset (lid, 0X00, sizeof(lid));   /* clear lid field @/
            strncpy (lid, from, len);     /* copy lid from record @/
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  ":LID line for lid |%s|", lid);
            if (strcmp (lid, inputLID) EQ 0)
            {
                strcpy(rule_type_perm_vec[i].last_lid_processed,
                       inputLID);
                lid_found = TRUE ;
                ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "inputLID=<%s> found",inputLID);

           ESA_DIAG_printf(PLT_COMP_XREF,6,
             "3: i=%d inputLID=<%s> last_read=<%s> last_processed=<%s>",
              i,inputLID,rule_type_perm_vec[i].last_lid_read,
              rule_type_perm_vec[i].last_lid_processed);

            }
            else
            if (strcmp (lid, inputLID) LT 0)
               continue;
            else if (strcmp (lid, inputLID) GT 0)
            {
               strcpy(rule_type_perm_vec[i].last_lid_read, lid);
               rc = ESA_WARN; /* end_of_user indication @/
            }
         }
         else
         {
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Get_Rule_Record returned unrequested line");
            rule_type_perm_vec[i].permError_indicator = TRUE;
            rc = ESA_FATAL;
            break;
         }
        } while ( (rc EQ ESA_OK) AND (lid_found EQ FALSE) );

        ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "Get_Rule_Record while loop rc = %d",rc);
      }

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "lid=<%s> inputLID=<%s>",lid,inputLID);     /*WS10078A@/

     if (rc EQ ESA_SKIP)
        rc = ESA_OK;

     if (rc EQ ESA_FATAL)
     {
       sprintf(errmsg,"Error while processing LID %s", inputLID);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func, errmsg, 16, __LINE__);
       lid_perm_handle->lidra_vec[i].IOError_indicator = TRUE;
       break;
     }

     if (strcmp (lid, inputLID) EQ 0)
     {
     /*       if roles required call Get_User_XROL for roles
              (only for first ldra)                          @/

        if (  (i EQ 0)
               AND
               /* WS10079T start
              (lid_perm_handle->RolesBlk NE NULL)        /@ BS10108T @/
               AND                                       /@ BS10108T @/
              (lid_perm_handle->RolesBlk NE INACT_BLOCK) /@ BS10108T @/
                       WS10079T end @/
              WS10084 */
              /* WS10084 start
        ESA_DIAG_printf(PLT_COMP_XREF, 0,
         "Before Get_User_XROL lid_perm_handle->Role_nf = %d \n",
                  lid_perm_handle->Role_nf);
        ESA_DIAG_printf(PLT_COMP_XREF, 0,
         "Before Get_User_XROL lid_perm_handle->Role_error = %d \n",
                  lid_perm_handle->Role_error);
        ESA_DIAG_printf(PLT_COMP_XREF, 0,
     "Before Get_User_XROL lid_perm_handle->RequiredRoles = %c \n",
                  lid_perm_handle->RequiredRoles);
                 WS10084 end   */
        if (                                             /* WS10084 */
              (NOT lid_perm_handle->Role_error)          /* WS10079T */
               AND                                       /* WS10079N */
              (NOT lid_perm_handle->Role_nf)             /* WS10079N */
               AND                                       /* BS10108T */
              (lid_perm_handle->RequiredRoles NE NULL_CHAR) )
           {
             /* WS10084  START
             if (want_diag)
                ESA_DIAG_printf(PLT_COMP_XREF, 0,
                "Before Get_User_XROL");
                WS10084  */

             rc = Get_User_XROL("GET",                   /*WS10079A*/
                   inputLID,                             /*WS10079A*/
                   lid_perm_handle,
                   /*WS10079A    lid_perm_handle->RolesBlk, */
                   (Get_User_XROL_handle **)             /*WS10079A*/
                   &(lid_perm_handle->get_user_xrol_handle),/*WS10079A*/
                   addinfo,
                   admin_params);
             /* WS10084  START
             if (want_diag)
             ESA_DIAG_printf(PLT_COMP_XREF, 0,
             "Get_User_XROL rc = %d Error = %d nf = %d",
                  rc, lid_perm_handle->Role_error,
                  lid_perm_handle->Role_nf);
                WS10084  */
             /* WS10079N ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "Get_User_XROL rc = %d",rc);           */
             ESA_DIAG_printf(PLT_COMP_XREF, 6,            /* WS10079N */
             "Get_User_XROL rc = %d   Error = %d   nf = %d",/*WS10079N*/
                  rc, lid_perm_handle->Role_error,        /* WS10079N */
                  lid_perm_handle->Role_nf);              /* WS10079N */
             if (rc EQ ESA_ERR)                           /* WS10079N */
             {                                            /* WS10079N */
               if (lid_perm_handle->Role_nf EQ TRUE)      /* WS10079N */
               {                                          /* WS10079N */
                 CTSAMSG_print(ACF2_XREF_STOPPED_NF,      /* WS10079N */
                               msgs, NULL, dest,          /* WS10079N */
                               "Roles", "X(ROL)");        /* WS10079N */
               }                                          /* WS10079N */
             }                                            /* WS10079N */
             else                                         /* WS10079N */
               /* WS10079T start */
               if ( (rc EQ ESA_FATAL)
                  AND (lid_perm_handle->Role_error) )
                 {
                    /*
                    CTSAMSG_print(WARN_INT1, msgs, NULL, dest,
                        component,func,
                        "Account Role connections are not provided. "
                        "They do not exist or cannot be retrieved due "
                        "to internal error",
                        4, __LINE__);
                    */
                    CTSAMSG_print(ACF2_ACCT_XREF_CONS_NOT_PRVD,
                          msgs, NULL, dest, "Role");
                    rc = ESA_OK;
                 }
             /* WS10079T end   */
             if (rc EQ ESA_FATAL)  {
             lid_perm_handle->Role_error = TRUE;        /* WS10079T */
             CTSAMSG_print(ACF2_XREF_STOPPED, msgs,     /* WS10079T */
                          NULL, dest,                   /* WS10079T */
                         "Roles");                      /* WS10079T */
             }                                          /* WS10079T */
             /* goto exit;                                 WS10079T */

             /* WS10084
             ESA_DIAG_printf(PLT_COMP_XREF, 0,
             "lid_perm_handle->get_user_xrol_handle->XBhandle = %p",
              lid_perm_handle->get_user_xrol_handle->XBhandle);
                WS10084 end   */
           }

  /* WS10084  start */
  if (first_time)
  {
    first_time = FALSE;
    if (strcmp(lid_perm_handle->lid, "*") EQ 0)
       PB_Req->SingleUser       = FALSE;
    else
    {
       strcpy(PB_Req->lid,inputLID);
       PB_Req->SingleUser       = TRUE;
       ESA_DIAG_printf(ESA_COMP_GTUSERS,6,
       "A request for a single user = %s \n", PB_Req->lid);
    }

    /* Prepare Users PB if needed */

    if (ADDINFO_search("ACCOUNTDIRECTPERMISSIONS",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs) NE NULL)
       PB_Req->AccountDirect       = TRUE;

    if (ADDINFO_search("AccountRoleDirectPermissions",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs) NE NULL)
       PB_Req->AccountRoleDirect = TRUE;

    if (ADDINFO_search("AccountRoleIndirectPermissions",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs) NE NULL)
       PB_Req->AccountRoleIndirect = TRUE;

    if (PB_Req->AccountDirect OR PB_Req->AccountRoleDirect)
    {
      PB_Req->Users_PBhandle_ptr = calloc (1, sizeof(PBhandle_typ));

      if (NOT PB_Req->Users_PBhandle_ptr)
      {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                 "Users PBhandle", sizeof(PBhandle_typ));
         /* Do we need both Errs below? */
         PB_Req->PBbldErr = TRUE;
         PB_Req->PBErr   = TRUE;
         rc = ESA_FATAL;
         goto exit;
      }
      /* Set uid to "*" or specific LID */
      strcpy (PB_Req->Users_PBhandle_ptr->uid, lid_perm_handle->lid);
      PB_Req->Users_PBhandle_ptr->WithPermissions = 'Y';
    }

    if (ESA_DIAG_get_debug_level(ESA_COMP_GTUSERS) EQ 6)
    {
      ESA_DIAG_printf(ESA_COMP_GTUSERS,6, "Printing addinfo again");
      ADDINFO_dump(addinfo,1);
    }

    /* Prepare Groups PB if needed */

    if (ADDINFO_search("ACCOUNTINDIRECTPERMISSIONS",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs) NE NULL)
    {
      PB_Req->AccountIndirect     = TRUE;
      PB_Req->Groups_PBhandle_ptr = calloc (1, sizeof(PBhandle_typ));

      if (NOT PB_Req->Groups_PBhandle_ptr)
      {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                 "Groups PBhandle", sizeof(PBhandle_typ));
         /* Do we need both Errs below? */
         PB_Req->PBbldErr = TRUE;
         PB_Req->PBErr   = TRUE;
         rc = ESA_FATAL;
         goto exit;
      }
      strcpy (PB_Req->Groups_PBhandle_ptr->uid, "*");
      PB_Req->Groups_PBhandle_ptr->WithPermissions = 'Y';
    }

    /* Prepare Roles PB if needed */

    if ( (ADDINFO_search("AccountRoleIndirectPermissions",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs) NE NULL)
          AND
         (lid_perm_handle NE NULL)
          AND
         (lid_perm_handle->get_user_xrol_handle NE NULL)  )
    {
       PB_Req->AccountRoleIndirect = TRUE;
       PB_Req->Roles_XBhandle_ptr = (XBhandle_rec_typ *)
       ((Get_User_XROL_handle *)
        (lid_perm_handle->get_user_xrol_handle))->XBhandle;
    }


    /* WS10084
    if (want_diag)                                 /@ WS10084 @/
       ESA_DIAG_printf(PLT_COMP_XREF, 0,           /@ WS10084 @/
         "Before Permissions_block_Build  BUILD"); /@ WS10084 @/
       WS10084 */

    rc = Permissions_block_Build("BUILD",
                                  PB_Req,
                                  PLT_COMP_PERMISSION,
                                  admin_params);
    /* WS10084
    if (want_diag)                                 /@ WS10084 @/
       ESA_DIAG_printf(PLT_COMP_XREF, 0,           /@ WS10084 @/
         "After Permissions_block_Build  BUILD");  /@ WS10084 @/
       WS10084 */


    if (rc NE ESA_OK)
      {sprintf(errmsg,
            "Permissions_Block_Build ended with rc = %d",rc);

       CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                  func, errmsg, 16, __LINE__);
      }
  }
  perms_exist = FALSE;

  /* WS10084   START
  if (want_diag)
     ESA_DIAG_printf(PLT_COMP_XREF, 0,
       "Before Get_user_permissions");
     WS10084 */

  rcc = Get_user_permissions(
          inputLID,
          PB_Req,
          addinfo,
          "GET",
          &perms_exist,
          admin_params);

  /* WS10084 START
  if (want_diag)
     ESA_DIAG_printf(PLT_COMP_XREF, 0,
       "After Get_user_permissions");
     WS10084 */


  if (perms_exist EQ TRUE)
     issue_no_permissions_message = FALSE;


  ESA_DIAG_printf(PLT_COMP_XREF, 6,
      "Get_user_Permissions  rc = %d; perms_exist = %d",
       rcc,perms_exist);

  if (rcc NE ESA_OK)
    {sprintf(errmsg,
          "Get_user_Permissions for %s ended with rc = %d",inputLID,rcc);

     CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                func, errmsg, 16, __LINE__);
    }

  if (issue_no_permissions_message EQ TRUE)
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 3,
       "No permissions for LID=%s",
          inputLID);


  /* WS10084  end   */
  /* WS10084
     /* if permissions are required call Get_User_Permission @/
        if (lid_perm_handle NE NULL)
           if ( (lid_perm_handle->RequiredPermissions NE NULL_CHAR)
                AND
                (lid_perm_handle->error EQ FALSE) )
             {
              perms_exist = FALSE;                       /* BS10108T @/
              rcc = Get_user_permissions(
                      inputLID,lid_perm_handle, addinfo, "GET",
                      i,
                      &perms_exist,                      /* BS10108T @/
                      admin_params);

              if (perms_exist EQ TRUE)                   /* BS10108T @/
                 issue_no_permissions_message = FALSE;   /* BS10108T @/

              /*  BS10108T - start @/
              ESA_DIAG_printf(PLT_COMP_XREF, 6,
                 "Get_user_Permissions  rc = %d; perms_exist = %d",
                  rcc,perms_exist);
              /*  BS10108T - end   @/

              /* ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "Get_user_Permissions  rc = %d",rcc);  BS10108T @/

              if (rcc NE ESA_OK)
                {
                 sprintf(errmsg,
                      "Get_user_Permissions ended with rc = %d",rcc);

                 CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                            func, errmsg, 16, __LINE__);
                }
             }
     }
  lid_found=FALSE; /*WS10078A added 20APR2020@/
  } /* for (i=0; i LT lid_perm_handle->lidra_vec_num; i++) outer loop @/

  /*  BS10108T - start @/
  if (issue_no_permissions_message EQ TRUE)
    {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 3,             /*BS10110T@/
       "No permissions for LID=%s, maybe due to NOUIDALL",/*BS10110T@/
          inputLID);                                      /*BS10110T@/
      /* BS10110T CTSAMSG_print(ACF2_NO_PERMISSION, msgs, NULL, dest,
                    "User",inputLID);                      BS10110T @/
    }
  /*  BS10108T - end   @/

     WS10084 */
  exit:

  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;

}
/*             End   WS10078T                                    */

/* BS10108 - Get_User_XROL and Get_User_XSGP are moved here
             from CTSBPHR.                                       */
/*                 Start WS10078T                                */
/******************************************************************
 * Procedure Name: Get_User_XROL   (based on Get_User_XSGP)
 ******************************************************************
 * Description   : Returns all LID's role connections.
 *                 Calls Get_Rule_Record to get all Roles as connections
 *                 based on RUOB/ACFRPTRX output.
 *                 Role names are returned in one string (with a null
 *                 terminator at the end) separated by a ';' delimiter
 *                 between role names.
 *                 For each role name in the returned string:
 *                 If previous role name was not a RoleGroup, call
 *                 ACF2_Get_Xref   to look for the Role in the XREF
 *                 block and get its type (group or not group) and
 *                 its SYSID if needed (scope=ALL).
 *                 else (previous role name was a RoleGroup), we know
 *                 it's a RoleGroup as well. So, if scope NE ALL, we
 *                 may stop calling ACF2_Get_Xref.
 *                 Add the role name to Roles or RoleGroups addinfo per
 *                 its type.
 * Called by:      Get_User_XREFAndPermissions
 *
 * Input         : inputLID  - LID name ptr
 *                 lid_perm_handle
 *                 XREFBlk  - XREF_Block address
 * Output        : addinfo  - where to update Roles and/or RoleGroups
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_ERR   - Error processing Roles.
 *                 ESA_FATAL - fatal error
 ******************************************************************/
/* BS10108 ESA_RC Get_User_XROL(                                */
static ESA_RC Get_User_XROL(                              /* BS10108 */
          char                         Function[9],   /*WS10079A*/
          char                       * inputLID,
    /*    Get_Rule_Rec_Handle       ** get_rule_record_handle,  */
          LID_PERM_handle_rec_typ    * lid_perm_handle,
          /*WS10079A XREF_REC_BLK_rec_typ       * XREFBlk,      */
          Get_User_XROL_handle      ** GUXhandle,     /*WS10079A*/
          ADDINFO_rec_ptr              addinfo,
          ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char func[] = "Get_User_XROL";

  ESA_RC                   rc = ESA_OK, rcc = ESA_OK; /* WS10078KM */
  ONE_FIELD_rec_ptr        r_pair = NULL;        /* Role */
  ONE_FIELD_rec_ptr        rg_pair = NULL;       /* Role Groups */
  ONE_FIELD_rec_ptr        pair = NULL;
  /* BS10111 GET_LINE_PTR             get_line_ptr;                  */
  /* BS10111 IDB_GETRUOBLINE_rec_typ  input_desc_block;              */
  /*IS10189 ACF00RBS_inp_block_typ * rbs_inp_block;     * WS10084 */
  ACF00RBS_inp_block_typ * rbs_inp_block = NULL;       /* IS10189 */
  ACF00RBS_ret_block_typ * rbs_ret_block = NULL;       /* WS10084 */
  CTS2RBS_parm_typ         parm;                       /* WS10084 */
  char                     call[5] = "CALL";           /* WS10084 */
  char                     free_func[5] = "FREE";      /* WS10084 */
  int                      dbglvl = 0;                 /* WS10084 */
  char                     LID8[9]  = "12345678";      /* WS10084 */
  char                     BLNK8[9] = "        ";      /* WS10084 */

  Permission_Record_Type   returned_record_type;
  RULE_TYPE_PERM_rec_typ * rule_type_perm_vec = NULL;
  char                     resource_type[4] = "";
  char                     ent_type[20] = "";    /* WS10078ST */
  char                   * role_name;
  char                     role_str[9] = "";
  char                     is_group = NULL_CHAR;
  int                      i;
  int                      int_rc;
  int                      group_found = FALSE;
  int                      r_full = FALSE;
  int                      rg_full = FALSE;
  char                     errmsg[100] = "";
  #define MAX_ROLES_AREA_SIZE   16384            /* for user  */
  char       role_record[MAX_ROLES_AREA_SIZE] = "";
  char       * role_record_end ;
  char  *space_pos;                               /* WS10078A */
  XBhandle_rec_typ       * XBhandle;              /* WS10078A */
  ACF2_PARAMS_rec_typ * params_ptr = NULL;          /*WS10079A*/
  char       block_read ;   /*2b set by ACF2_Get_XREF WS10079A*/
  char       xrefname_out[19] = "";                 /*WS10079A*/
  char       role_type;                             /*WS10079A*/

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);
  params_ptr = admin_params->apiinit_handle;              /* WS10079N */

 /********************** WS10079A start 1 *******************/
 ESA_DIAG_printf(PLT_COMP_XREF, 6,                          /* WS10084 */
     "function = %s ", Function);                           /* WS10084 */

 if(strcmp(Function,"TERM") EQ 0) {
   if(*GUXhandle EQ NULL) {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
       "Function=TERM but *GUXhandle is NULL. Nothing to do");
     goto get_user_xrol_exit;
   }
   XBhandle = (*GUXhandle)->XBhandle ;             /* WS10079T */
   rc = ACF2_Get_Xref("TERM",
          XBhandle,
          &((*GUXhandle)->acf2_get_xref_handle),
          NULL_CHAR,
          NULL,
          NULL,
          NULL,
          addinfo,
          PLT_COMP_XREF,
          admin_params);
   ESA_DIAG_printf(PLT_COMP_XREF, 6,
       "ACF2_Get_Xref TERM rc<%d>",rc);

   if((*GUXhandle)->XBhandle NE NULL) {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
     "going to free *GUXhandle->XBhandle<%p>",(*GUXhandle)->XBhandle);
     free((*GUXhandle)->XBhandle);
     (*GUXhandle)->XBhandle = NULL;
   }

   ESA_DIAG_printf(PLT_COMP_XREF, 6,
     "going to free *GUXhandle<%p>",*GUXhandle);
   free(*GUXhandle);
   *GUXhandle = NULL;
 } /* end (strcmp(Function,"TERM") EQ 0) */

 if(strcmp(Function,"GET") EQ 0) {
   /*
    *  Verify we have Roles and/or RoleGroups in addinfo
    */

   r_pair  = ADDINFO_search("Roles",
                            ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
   rg_pair = ADDINFO_search("RoleGroups",
                            ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
   if (r_pair EQ NULL   AND   rg_pair EQ NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, "No Roles/RoleGroups in addinfo",
         16, __LINE__);
     rc = ESA_FATAL;
     goto get_user_xrol_exit;
   };


 /* allocate Get_User_XROL_handle & XBhandle if needed */
 if (*GUXhandle EQ NULL) {
   *GUXhandle = (Get_User_XROL_handle *)
                calloc(1,sizeof(Get_User_XROL_handle));
   if (*GUXhandle EQ NULL) {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "Get_User_XROL_handle", sizeof(Get_User_XROL_handle));
     rc = ESA_FATAL;
     goto get_user_xrol_exit;
   }
   lid_perm_handle->get_user_xrol_handle=(void *)*GUXhandle;
   XBhandle =  calloc(1,sizeof(XBhandle_rec_typ));
   if (XBhandle EQ NULL) {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "XBhandle", sizeof(XBhandle_rec_typ));
     rc = ESA_FATAL;
     goto get_user_xrol_exit;
   }
   /*** initalize Get_User_XREF_handle ***/
   (*GUXhandle)->XBhandle = XBhandle;
   (*GUXhandle)->acf2_get_xref_handle = NULL;
   /*** initalize XBhandle ***/
   /* if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a')             WS10084 */
   /* WS10084 start */
   if ( (params_ptr->XREF_SYSID_SCOPE[0] EQ 'a')
         OR
        (ADDINFO_search("AccountRoleIndirectPermissions",
                        ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs) NE NULL) )
   /* WS10084 end   */
     strcpy(XBhandle->request_type,"XREFNGRP");
   else strcpy(XBhandle->request_type,"ONLYSHRT");

   strcpy(XBhandle->xrefname,"-");
   XBhandle->PB_type = 'R';
   XBhandle->active_request = 'C';
   XBhandle->need_rec_YN = 'N';
   XBhandle->bld_err = FALSE;
   XBhandle->bld_nf  = FALSE;                            /* WS10079N */
   XBhandle->XB_err = FALSE;
 }
 else {                                                  /* WS10079T */
   XBhandle = (*GUXhandle)->XBhandle ;                   /* WS10079T */
   if ( (XBhandle->bld_err EQ TRUE) OR                   /* WS10079T */
        (XBhandle->XB_err EQ TRUE) )                     /* WS10079T */
       goto get_user_xrol_exit;                          /* WS10079T */
 }
 /********************* WS10079A end 1 ********************/

  /* WS10084 start */

  parm.func = call;
  parm.ret@ = &rbs_ret_block;
  parm.rbs@ = (void *)&ptr_rbs;
  parm.dbglvl = &dbglvl;

  dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_XREF);
  if ( dbglvl GT 0)
    dbglvl = 1;

  if (p_CTS2RBS EQ NULL)
  {
    /*   Load CTS2RBS    */
    int_rc = (*(ASM_RTN_TYP *)&ctsaldm)
                              ("CTS2RBS ", "        ", &p_CTS2RBS);
    ESA_DIAG_printf(PLT_COMP_XREF, 3,
              "Loading CTS2RBS:   rc = %d  addr = %p \n",
              int_rc, &p_CTS2RBS);
    if (int_rc NE 0)
    {
     CTSAMSG_print(DYNAMIC_LOAD_FAILED, msgs,
                   NULL, dest, "CTS2RBS");
     rc = ESA_FATAL;
     goto get_user_xrol_exit;

    };
  };

  /*
   *   Prepare ACF00RBS parameters
   */


 rbs_inp_block = (ACF00RBS_inp_block_typ *)
                 calloc(1,sizeof(ACF00RBS_inp_block_typ));
 if (rbs_inp_block EQ NULL)
 {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "rbs_inp_block", sizeof(ACF00RBS_inp_block_typ));
    rc = ESA_ERR;
    goto get_user_xrol_exit;
 };
  memcpy(LID8,BLNK8,8);
  memcpy(LID8,inputLID,strlen(inputLID));
  parm.inp  = rbs_inp_block;
  strncpy(rbs_inp_block->eyec,"XRBS",4);
  rbs_inp_block->len  = sizeof(ACF00RBS_inp_block_typ);
  rbs_inp_block->ver  = 0X01;
  rbs_inp_block->func = 0X01;
  rbs_inp_block->flag = 0X00;
  /* rbs_inp_block->usr  = inputLID;*/
  rbs_inp_block->usr  = LID8;
  rbs_inp_block->usrlen  = 8;
  rbs_inp_block->subpool = 8;

  /*
   *   Call ACF00RBS via CTS2RBS
   */

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
     "Before calling CTS2RBS");

  int_rc = (*p_CTS2RBS)(&parm);

  if (int_rc NE 0)
  {
    sprintf(errmsg,
       "ACF00RBS for %s failed with a return code of %d",
        inputLID,int_rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                  errmsg, 16, __LINE__);
    rc = ESA_ERR;
    goto get_user_xrol_exit;

  };

  if (rbs_ret_block EQ NULL)                                      /* BS10140 */
  goto freeinp;                                                   /* BS10140 */
  /* BS10140
  if (rbs_ret_block EQ NULL)
  {
    sprintf(errmsg,
       "ACF00RBS for %s output is NULL \n", inputLID);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                  errmsg, 16, __LINE__);
    rc = ESA_ERR;
    goto get_user_xrol_exit;
  };
     BS10140 */

  if (ESA_DIAG_get_debug_level(PLT_COMP_XREF) GE 1)
  {
    role_name = rbs_ret_block->role;
    for (i = 0; i LT rbs_ret_block->ret_num; i++, role_name+=8)
    {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "From RBS: role(%d):  <%.8s> \n", i+1, role_name);
    }
  }

  /* WS10084 end   */
  /* BS10111 - 2 lines are removed
  get_line_ptr = &ESA_CLI_get_RUOB_line;
  input_desc_block.blk = lid_perm_handle->lidra_vec[0].lidra;
    end of removed lines - BS10111 */

  /* WS10084
  ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "Calling Get_Rule_Record requesting Roles");

  rc = Get_Rule_Record(
       "GETNEXT",
       &(lid_perm_handle->lidra_vec[0].get_rule_record_handle),
 /*    get_rule_record_handle,             @/
 /* BS10111  get_line_ptr,    @/
 /* BS10111  &input_desc_block,  @/
       lid_perm_handle->lidra_vec[0].lidra,               /* BS10111 @/
/* WS10078SG ROLE_LINE,                                              @/
       ROLES_BLOCK,               /* change enum value name WS10078SG@/
       sizeof(role_record),
       "ACFRPTRX",
       &returned_record_type,
       role_record,
       resource_type,
       admin_params);

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
              "Get_Rule_Record GET ROLE Line rc = %d   line = %s",
              rc, role_record);

  if (rc NE ESA_OK)
  {
    if (rc EQ ESA_WARN) /* end_of_user indication @/
    {
       ESA_DIAG_printf(PLT_COMP_XREF, 6,
                       "No user roles encountered");
       rc = ESA_OK;
    }
    goto get_user_xrol_exit;
  }
    WS10084 */


  /* WS10078SG
  if (returned_record_type EQ ROLE_LINE)                             */
  /* WS10084
  if (returned_record_type EQ ROLES_BLOCK)   /* change name WS10078SG@/
  {
      ESA_DIAG_printf(PLT_COMP_XREF, 6,
  /* WS10078SG "Get_Rule_Record returned a :ROLE line");             @/
               "Get_Rule_Record returned a :ROLES block");/*WS10078SG@/
  /*
   *   Copy Role and RoleGroup names to addinfo
   @/
   role_record_end = role_record + strlen(role_record);
   i = 1;

   /* WS10079N
   while ( (role_name NE NULL) AND (role_name LT role_record_end)) @/
   for (role_name = strtok(role_record,";");
        (role_name NE NULL) AND (role_name LT role_record_end);
        role_name = strtok(NULL,";"))
    WS10084 */
   /* WS10084 start */
    if (rbs_ret_block->ret_num GT 0)
    ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "LID = %s, number of roles from RBS = %d \n",
                      inputLID, rbs_ret_block->ret_num);
   role_name = rbs_ret_block->role;
   for (i = 0; i LT rbs_ret_block->ret_num; i++, role_name+=8)
   /* WS10084 end   */
   {

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "role(%d):  %.8s",
                      i,role_name);                     /* WS10084 */
                  /*  i++,role_name);                      WS10084 */

     strncpy(role_str, role_name, 8);
     role_str[8] = NULL_CHAR;
     Trim(role_str);                                     /* WS10084 */
     /*set a null if space at the end... WS10078A start */
     space_pos = strchr(role_str,' '); /*->space if found*/
     if(space_pos NE NULL)               /*space is found*/
     {
      *space_pos = NULL_CHAR;            /*set NULL instead of space*/
      ESA_DIAG_printf(PLT_COMP_XREF, 6,"set NULL at end of role=<%s>",
                      role_str);
     }
     /* WS10078A end */

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "role: <%s> r: %p / %d    rg: %p / %d   group_found = %d",
          role_str, r_pair, r_full, rg_pair, rg_full, group_found);

     /*************************** WS10079A ****************************
      * If RoleGroup is found in the list and scope is not 'a',       *
      * no need to call ACF2_Get_Xref any more as all the other roles *
      * are RoleGroups and we do not need the SYSID.         WS10079A *
      *****************************************************************/
     /*WS10079A if((group_found EQ FALSE) ***/
     if((group_found EQ TRUE) AND                  /*WS10079A*/
        (params_ptr->XREF_SYSID_SCOPE[0] NE 'a')){ /*WS10079A*/
       ESA_DIAG_printf(PLT_COMP_XREF,6,
         "Group found & scope NE ALL,No need 2 call ACF2_Get_Xref");
       strcpy(xrefname_out,role_str);
       role_type = 'G';                                  /* WS10079T */
       goto upd_addinfo;                                 /* WS10079T */
     }

       /*WS10079A rc = XREF_Block_Find(role_str,
                            XREFBlk,
                            &is_group,
                            admin_params); replace with ACF2_get_XREF*/
     xrefname_out[0] = NULL_CHAR;
     ESA_DIAG_printf(PLT_COMP_XREF, 6,                   /* WS10084 */
         "Before ACF2_Get_Xref (GETTHISA) in Short \n"); /* WS10084 */
     rc = ACF2_Get_Xref("GETTHISA",
            XBhandle,
            &((*GUXhandle)->acf2_get_xref_handle),
            'S',
            &block_read,
            role_str,
            xrefname_out,
            NULL,                                         /* WS10079N */
            PLT_COMP_XREF,
            admin_params);
     ESA_DIAG_printf(PLT_COMP_XREF, 6,                    /* WS10084 */
     "After  ACF2_Get_Xref (GETTHISA) in Short rc=%d \n", /* WS10084 */
           rc);                                           /* WS10084 */

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
        /*WS10079A  "XREF_Block_Find for %s - rc = %d is_group = %c"  ,
        rc, is_group); */
        "ACF2_Get_Xref rc<%d> xrefname_out<%s> type<%c>", /*WS10079A*/
        rc, xrefname_out, block_read);                    /*WS10079A*/
     /*WS10079A if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto get_user_xrol_exit;/*  XREF_Block_Find issued a msg *
     }; */
     /* replace Role/RoleGroup decision per ACF2_Get_Xref WS10079A *
     if (is_group EQ 'Y')
       group_found = TRUE; */
     /********************** WS10079A start 2 *************************/
     if (rc EQ ESA_OK) {
       role_type = block_read;
       if(block_read EQ 'G') group_found = TRUE;
       ESA_DIAG_printf(PLT_COMP_XREF,6,
         "Role<%s> found in short <%c>",xrefname_out,role_type);
       goto upd_addinfo;                                 /* WS10079T */
     }
     /******************************************************************
      * Role not found in short list so it should be in the long list. *
      * If XREF_SYSID_SCOPE is ALL_SYSTEMS, call ACF2_Get_Xref again   *
      * to find it in the long list and get its SYSID.                 *
      ******************************************************************/
     if (rc EQ ACF2_Not_Found) {                     /*WS10079A*/
       if (XBhandle->bld_nf EQ TRUE)                      /* WS10079N */
       {                                                  /* WS10079N */
         lid_perm_handle->Role_nf = TRUE;                 /* WS10079N */
         rc = ESA_ERR;                                    /* WS10079N */
         goto get_user_xrol_exit;                         /* WS10079N */
       };                                                 /* WS10079N */

       if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a') {  /*WS10079A*/

       ESA_DIAG_printf(PLT_COMP_XREF, 6,                  /* WS10084 */
         "Before ACF2_Get_Xref (GETTHISA) in Long \n");   /* WS10084 */
        rc = ACF2_Get_Xref("GETTHISA",               /*WS10079A*/
               XBhandle,
               &((*GUXhandle)->acf2_get_xref_handle),
               'L',             /*search in long list        */
               &block_read,
               role_str,                                 /* WS10079T */
               xrefname_out,
               NULL,                                      /* WS10079N */
               PLT_COMP_XREF,
               admin_params);
        ESA_DIAG_printf(PLT_COMP_XREF, 6,                   /* WS10084 */
        "After  ACF2_Get_Xref (GETTHISA) in Long rc=%d \n", /* WS10084 */
           rc);                                             /* WS10084 */
        ESA_DIAG_printf(PLT_COMP_XREF, 6,
          "ACF2_Get_Xref rc<%d> xrefname_out<%s> type<%c>", /*WS10079A*/
          rc, xrefname_out, block_read);                   /*WS10079A*/
        if (rc EQ ESA_OK) {
          role_type = block_read;
          if(block_read EQ 'G') group_found = TRUE;
          ESA_DIAG_printf(PLT_COMP_XREF,6,
            "Role<%s> found in long <%c>",xrefname_out,role_type);
          goto upd_addinfo;                              /* WS10079T */
        }

        if(rc EQ ACF2_Not_Found) {
         /* WS10079T
         sprintf(errmsg,
       "Role<%s> not found in both lists. Continue with next Role (%s)",
           role_str, inputLID);
         CTSAMSG_print(WARN_INT1, msgs, NULL, dest, component, func,
           errmsg, 3, __LINE__);
            WS10079T */
         /*  WS10084 don't issue this when SCOPE is ALL_SYSTEMS
          CTSAMSG_print(ACF2_XREF_NOT_FOUND_FOR_USER,    /* WS10079T @/
            msgs, NULL, dest, "Role",                    /* WS10079T @/
            role_str,inputLID,role_str);                 /* WS10079T @/
         */

         continue;
        }

        if((XBhandle->bld_err EQ TRUE) OR
           (XBhandle->XB_err EQ TRUE)) {
          lid_perm_handle->Role_error = TRUE;
          ESA_DIAG_printf(PLT_COMP_XREF,6,
           "bld_err/XB_err = TRUE, set Role_error=TRUE and rc=FATAL");
          rc = ESA_FATAL;
          goto get_user_xrol_exit;
        }

        sprintf(errmsg,
         "Unexpected rc<%d> from ACF2_Get_XREF Long list", rc);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
           func, errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto get_user_xrol_exit;

       } /*end of if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a') */

       else { /* not found in Short list and SYSID not required */
        block_read = XBhandle->shortest;               /* WS10079T */
        if(block_read EQ 'X') {
          role_type = 'G';
          group_found = TRUE;
        }
        else if(block_read EQ 'G') role_type = 'X';
        strcpy(xrefname_out,role_str);                 /* WS10079T */
        ESA_DIAG_printf(PLT_COMP_XREF,6,               /* WS10079T */
           "role not found in short, sysid not required. "
           "xrefname_out: <%s>, role_type: %c, group_found:%d",
           xrefname_out,role_type,group_found);
        rc = ESA_OK;                                   /* WS10079T */
        goto upd_addinfo;                              /* WS10079T */
       }
     } /* end if (rc EQ ACF2_Not_Found) */

     if((XBhandle->bld_err EQ TRUE) OR
        (XBhandle->XB_err EQ TRUE)) {
       lid_perm_handle->Role_error = TRUE;
       ESA_DIAG_printf(PLT_COMP_XREF,6,
         "bld_err/XB_err = TRUE, set Role_error=TRUE and rc=FATAL");
       rc = ESA_FATAL;
       goto get_user_xrol_exit;
     }

      sprintf(errmsg,
        "Unexpected rc<%d> from ACF2_Get_XREF Short list", rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
             func, errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto get_user_xrol_exit;


     /************************* WS10079A end 2 *******************/

     upd_addinfo:                                        /* WS10079T */
     pair = NULL;
     /*WS10079A if (group_found EQ TRUE) {*If group-add to RolesGroup*/
     if (role_type EQ 'G') { /*If group-add to RolesGroup WS10079A   */
       if (rg_pair NE NULL  AND  rg_full NE TRUE)
          pair = rg_pair;
     }
     else                      /* else - add to Roles */
       if (r_pair NE NULL  AND  r_full NE TRUE)
          pair = r_pair;

     /*  Add name to appropriate addinfo entry */
     if (pair NE NULL)
     {
       /*WS10079A rc = ADDINFO_addval (role_str,     */
       rc = ADDINFO_addval (xrefname_out,              /*WS10079A*/
                            ACF_ADDINFO_VAL_LEN,
                            ADDINFO_LIST_ENTRY,
                            pair, dest, msgs);
       /* WS10082N if (rc EQ ESA_EOF) { /@ No more space in value @/*/
       if (rc NE ESA_OK) { /* No more space in value */   /* WS10082N */
       /*WS10078ST Add the setting of ent_type for message CTS3893W
         if (pair EQ r_pair)  r_full = TRUE;
         else  rg_full = TRUE;                                     */
         if (pair EQ r_pair) {
           r_full = TRUE;
           strcpy (ent_type, "Roles");                 /* WS10078ST */
         }
         else {
           rg_full = TRUE;
           strcpy (ent_type, "RoleGroups");            /* WS10078ST */
         }

 /* WS10078ST Using message CTS3893W instead of CTS1208I
          sprintf(errmsg, "%s user=%s", role_str, inputLID);
          CTSAMSG_print(MSG_KWD_VALUE_TRUNCATED, msgs, NULL, dest,
                          pair->keyword, errmsg);                   */
          CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
 /* WS10078ST */        pair->keyword, inputLID,
 /* WS10079A *         role_str, strlen(role_str), WS10078ST */
                        xrefname_out, strlen(xrefname_out),/*WS10079A*/
 /* WS10078ST */        pair->vallen, ent_type);
 /* WS10078KM - Start  set isIncomplete attribute in addinfo */
                rcc = ESA_OK;
                pair = ADDINFO_search("isIncomplete",
                                      ACF_ADDINFO_KWD_LEN,
                                      addinfo->pair,
                                      addinfo->num_pairs);
                if (pair NE NULL)
                {
                   if( pair->value[0] NE 'Y')
                      rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                           pair);
                   if (rcc NE ESA_OK)
                   {
                      sprintf(errmsg,
                              "Update <%s> keyword failed. rc=%d",
                              "isIncomplete",rcc);
                      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                    dest, component,func,
                                    errmsg, rcc,__LINE__);
                   }
                }
 /* WS10078KM - Ends */
        };
      };

      /*  If both are full  OR                           */
      /*    ( group was found AND                        */
      /*        (groups not req's or groups are full) )  */
      /*  nothing to do - out                            */
      if ( (r_full EQ TRUE  AND  rg_full EQ TRUE)  OR
            (group_found EQ 'Y' AND
               (rg_pair EQ NULL  OR rg_full EQ TRUE) ) )
         {
          rc = ESA_OK;
          break;
         }
      /* WS10079N role_name = strtok(NULL,";");   */
   }  /* end for   */
  /* WS10084
  }
  else
  {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
              "Get_Rule_Record returned unrequested line");
     rule_type_perm_vec = lid_perm_handle->rule_type_perm_vec;
     rule_type_perm_vec[0].permError_indicator=TRUE;

     rc = ESA_FATAL;
     goto get_user_xrol_exit;
  }
    WS10084 */
 } /* end if(strcmp(Function,"GET") EQ 0) WS10079A*/
  get_user_xrol_exit:

  /* WS10084 start */

  if (rbs_ret_block NE NULL)
  {
    parm.func   = free_func;
    parm.retsp  = rbs_ret_block->subpool;
    parm.retlen = rbs_ret_block->len;

    if (rbs_ret_block->len EQ 0Xffff)
      parm.retlen = rbs_ret_block->tablen;
    int_rc = (*p_CTS2RBS)(&parm);

    if (int_rc NE 0)
    {
      sprintf(errmsg,
       "ACF00RBS free of output area failed with rc = %d",
        int_rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                  errmsg, 16, __LINE__);
      rc = ESA_ERR;
    };

    rbs_ret_block = NULL;
  }

  freeinp:                                                     /* BS10140 */
  if (rbs_inp_block NE NULL)
  {
     free(rbs_inp_block);
  }
  /* WS10084 end   */
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;

}

/* WS10078N - start */
/*********************************************************************
 * Procedure Name: Get_User_XSPG
 *********************************************************************
 * Description   : Get XREF source and SourceGroup names for the LID
 *                 and put them in Sources and SourceGroups addinfo
 *                 attributes, if exist in addinfo.
 *
 * Input         : LID
 *                 Source XREF block
 *
 * Output        : addinfo
 *
 * Return Value  : ESA_OK -
 *                 ESA_ERR   - Error retrieveing sources.
 *                 ESA_FATAL - Sources cannot be retrieved.
 *
 * Attention     : ACF00SSL resides in a non-APF library. Therefore,
 *                 we should load and call it while we are non-auth.
 *                 CTSAATH is used to turn APF authorization off
 *                 before loading and calling ACF00SSL, and then back
 *                 on after ACF00SSL returns.
 *                 Care should be taken to always leave this routine
 *                 when authorization is on.
 *
 ********************************************************************/
/* WS10078T no longer static static ESA_RC Get_User_XSGP(           */
/* BS10108 - ESA_RC Get_User_XSGP(                         WS10078T */
static ESA_RC Get_User_XSGP(                            /* BS10108  */
           char                      Function[9],         /*WS10079A*/
           char                    * inputLID,
           LID_PERM_handle_rec_typ * lid_perm_handle,     /*WS10079T*/
           /*WS10079A XREF_REC_BLK_rec_typ    * XREFBlk,*/
           Get_User_XSGP_handle   ** GUXhandle,           /*WS10079A*/
           ADDINFO_rec_ptr           addinfo,
           ADMIN_PARAMS_rec_typ    * admin_params)
{

#define ACF00SSL_MAX_RET_BLOCK_LEN  32767                 /* BS10138 */

 typedef  struct _SSL_RET_BLK
  {
    short   len;
    short   ret_num;
    char    flags;
    char    filler[3];
    char    source[8];
  }  ACF00SSL_ret_block_typ,  *ACF00SSL_ret_block_ptr;

  static char              func[] = "Get_User_XSGP";
  /*WS10078A static char              CAX1LOAD_DD[] = "CAX1LOAD_DD";*/
  static char              CAX1LOAD_DD[] = "CAX1LOAD";/*WS10078A*/
  static char              ACF2_CAX1LOAD_DSN[] = "ACF2_CAX1LOAD_DSN";

  ESA_RC                   rc = ESA_OK, rcc = ESA_OK; /* WS10078KM */
  ACF2_API_Return_Codes    acf2_rc = ACF2_OK;             /* WS10079N */
  ONE_FIELD_rec_ptr        s_pair = NULL;        /* Source */
  ONE_FIELD_rec_ptr        sg_pair = NULL;       /* Source Groups */
  ONE_FIELD_rec_ptr        pair = NULL;
  char                   * source_name;
  char                     source_str[9] = "";
  char                     is_group = NULL_CHAR;
  int                      i;
  int                      int_rc;
  int                      ath_rc;
  char                     cax1load_dsn[45] = "";
  char                     ent_type[20] = "";           /* WS10078ST */
  __dyn_t                  dynalc;
  /* BS10138 ACF00SSL_ret_block_typ * ssl_ret_block; */
  ACF00SSL_ret_block_typ * ssl_ret_block = NULL;          /* BS10138 */

  int    ssl_ret_block_len =  0;
  int    group_found = FALSE;
  int    s_full = FALSE;
  int    sg_full = FALSE;
  char   errmsg[100] = "";
  char  *space_pos;                               /* WS10078A */
  ACF2_PARAMS_rec_typ * params_ptr = NULL;          /*WS10079A*/
  char       block_read ;   /*2b set by ACF2_Get_XREF WS10079A*/
  char       xrefname_out[19] = "";                 /*WS10079A*/
  char       source_type;                           /*WS10079A*/
  XBhandle_rec_typ       * XBhandle;                /* WS10078A */

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  /*
   *   Initialization
   */
  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;
  params_ptr = admin_params->apiinit_handle;;             /* WS10079N */

 /********************** WS10079A start 1 *******************/
 if(strcmp(Function,"TERM") EQ 0) {
   if(*GUXhandle EQ NULL) {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
       "Function=TERM but *GUXhandle is NULL. Nothing to do");
     goto get_user_xsgp_exit;
   }
   XBhandle = (*GUXhandle)->XBhandle ;                   /* WS10079T */
   /* WS10079N rc = ACF2_Get_Xref("TERM",  */
   acf2_rc = ACF2_Get_Xref("TERM",                        /* WS10079N */
          XBhandle,
          &((*GUXhandle)->acf2_get_xref_handle),
          NULL_CHAR,
          NULL,
          NULL,
          NULL,
          addinfo,
          PLT_COMP_XREF,
          admin_params);
   ESA_DIAG_printf(PLT_COMP_XREF, 6,
       "ACF2_Get_Xref TERM rc<%d>",acf2_rc);              /* WS10079N */
       /* WS10079N  "ACF2_Get_Xref TERM rc<%d>",rc);  */

   if((*GUXhandle)->XBhandle NE NULL) {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
     "going to free *GUXhandle->XBhandle<%p>",(*GUXhandle)->XBhandle);
     free((*GUXhandle)->XBhandle);
     (*GUXhandle)->XBhandle = NULL;
   }

   ESA_DIAG_printf(PLT_COMP_XREF, 6,
     "going to free *GUXhandle<%p>",*GUXhandle);
   free(*GUXhandle);
   *GUXhandle = NULL;
 } /* end (strcmp(Function,"TERM") EQ 0) */

 if(strcmp(Function,"GET") EQ 0) {
   /*
    *  Verify we have Sources and/or sourceGroups in addinfo
    */
   s_pair = ADDINFO_search("Sources",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs);
   sg_pair = ADDINFO_search("SourceGroups",
                            ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
   if (s_pair EQ NULL   AND   sg_pair EQ NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, "No Sources/SourceGroups in addinfo",
         16, __LINE__);
     rc = ESA_FATAL;
     goto get_user_xsgp_exit;
   };

 /* allocate Get_User_XSGP_handle & XBhandle if needed */
 if (*GUXhandle EQ NULL) {
   *GUXhandle = (Get_User_XSGP_handle *)
                calloc(1,sizeof(Get_User_XSGP_handle));
   if (*GUXhandle EQ NULL) {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "Get_User_XSGP_handle", sizeof(Get_User_XSGP_handle));
     rc = ESA_FATAL;
     goto get_user_xsgp_exit;
   }
   XBhandle =  calloc(1,sizeof(XBhandle_rec_typ));
   if (XBhandle EQ NULL) {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "XBhandle", sizeof(XBhandle_rec_typ));
     rc = ESA_FATAL;
     goto get_user_xsgp_exit;
   }
   /*** initalize Get_User_XSGP_handle ***/
   (*GUXhandle)->XBhandle = XBhandle;
   (*GUXhandle)->acf2_get_xref_handle = NULL;
   /*** initalize XBhandle ***/
   if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a')
     strcpy(XBhandle->request_type,"XREFNGRP");
   else strcpy(XBhandle->request_type,"ONLYSHRT");

   strcpy(XBhandle->xrefname,"-");
   XBhandle->PB_type = 'S';
   XBhandle->active_request = 'C';
   XBhandle->need_rec_YN = 'N';
   XBhandle->bld_err = FALSE;
   XBhandle->XB_err = FALSE;
 }
 else {                                                  /* WS10079T */
   XBhandle = (*GUXhandle)->XBhandle ;                   /* WS10079T */
   if ( (XBhandle->bld_err EQ TRUE) OR                   /* WS10079T */
        (XBhandle->XB_err EQ TRUE) )                     /* WS10079T */
       goto get_user_xsgp_exit;                          /* WS10079T */
 }                                                       /* WS10079T */
 /********************* WS10079A end 1 ********************/

  /*
   *  Load ACF00SSL if not already loaded
   *
   *  Dynalloc ACF2 library CAX1LOAD using the library name
   *  specified in RSSPARM parameter ACF2_CAX1LOAD_DSN.
   *  Load ACF00SSL from this library and free the library.
   */
  if (p_acf00ssl EQ NULL)
  {
    /*   Load CTSAATH    */
    if (p_ctsaath EQ NULL)
    {
      int_rc = (*(ASM_RTN_TYP *)&ctsaldm)
                                ("CTSAATH ", "       ", &p_ctsaath);
      ESA_DIAG_printf(PLT_COMP_XREF, 3,
                     "Loading CTSAATH:  rc = %d    addr = %p",
                     int_rc, &p_ctsaath);
      if (int_rc NE 0)
      {
        CTSAMSG_print(DYNAMIC_LOAD_FAILED, msgs,
                      NULL, dest, "CTSAATH");
        rc = ESA_FATAL;
        goto get_user_xsgp_exit;

      };
    };

    /*  Take the CAX1LOAD library name */
    rc = admin_params->cs_func.rssprm_get_opt_ptr(
                    admin_params->rss_name,
                    ACF2_CAX1LOAD_DSN,
                    sizeof(cax1load_dsn),
                    cax1load_dsn,
                    OPT_TRUE,
                    OPT_TRUE);
    ESA_DIAG_printf(PLT_COMP_XREF, 3,
                    "%s = <%s> ,rc = <%d> ",
                    ACF2_CAX1LOAD_DSN, cax1load_dsn, rc);

    if (rc NE ESA_OK)
    {
      CTSAMSG_print(NOT_SUP_DUE_TO_RSSP_MISS, msgs, NULL, dest,
                    "Sources/SourceGroups", ACF2_CAX1LOAD_DSN);
      rc = ESA_FATAL;
      goto get_user_xsgp_exit;
    };

    /*   Dynalloc CAX1LOAD   */
    dyninit(&dynalc);

    dynalc.__ddname = CAX1LOAD_DD;
    dynalc.__dsname = cax1load_dsn;
    dynalc.__status = __DISP_SHR;

    int_rc = dynalloc(&dynalc);
    ESA_DIAG_printf(PLT_COMP_XREF, 3,
            "dynalloc for %s(%s):  rcc = %d   err/info = %d / %d",
            dynalc.__ddname, dynalc.__dsname,
            int_rc, dynalc.__errcode, dynalc.__infocode);

    if (int_rc NE 0)
    {
      sprintf(errmsg,
              "dd(%s) dsn(%s)",
              dynalc.__ddname, dynalc.__dsname);

      CTSAMSG_print(DYNAMIC_ALLOC_DEALLOC_FAILED, msgs, NULL, dest,
                    "allocation", errmsg, int_rc,
                    dynalc.__errcode, dynalc.__infocode);
      rc = ESA_FATAL;
      goto get_user_xsgp_exit;
    }

    /*   Load ACF00SSL   */
    ath_rc = (*p_ctsaath)("NON_APF");     /* set auth off.  rc=0 */
    ESA_DIAG_printf(PLT_COMP_XREF, 6, "UnAuth before load");

    int_rc = (*(ASM_RTN_TYP *)&ctsaldm)
                              ("ACF00SSL", CAX1LOAD_DD, &p_acf00ssl);

    ath_rc = (*p_ctsaath)("APF_AUT");     /* set auth on.   rc=0 */
    ESA_DIAG_printf(PLT_COMP_XREF, 6, "ReAuth after load");

    ESA_DIAG_printf(PLT_COMP_XREF, 3,
                   "Loading ACF00SSL:  rc = %d    addr = %p",
                    int_rc, &p_acf00ssl);
    if (int_rc NE 0)
    {
      CTSAMSG_print(DYNAMIC_LOAD_DD_FAILED, msgs, NULL, dest,
                    "ACF00SSL", cax1load_dsn);
      rc = ESA_FATAL;
      goto get_user_xsgp_exit;

    };

    /*   Dealloc CAX1LOAD */
    dyninit(&dynalc);
    dynalc.__ddname = CAX1LOAD_DD;

    int_rc = dynfree(&dynalc);
    ESA_DIAG_printf(PLT_COMP_XREF, 3,
            "Dealloc for <%s>: rc = %d   err/info = %d / %d",
             dynalc.__ddname, int_rc,
             dynalc.__errcode, dynalc.__infocode);
    if (int_rc NE 0)   /* if dealloc failed, msg and continue */
    {
      sprintf(errmsg,
              "dd(%s)", dynalc.__ddname);

      CTSAMSG_print(DYNAMIC_ALLOC_DEALLOC_FAILED, msgs, NULL, dest,
                    "deallocation", errmsg, int_rc,
                    dynalc.__errcode, dynalc.__infocode);
    };
  };

  /*
   *   Prepare ACF00SSL parameters
   */
  /* BS10138 ssl_ret_block_len =  sizeof(ACF00SSL_ret_block_typ) +
                       ACF_ADDINFO_VAL_LEN;  */
  ssl_ret_block_len =  ACF00SSL_MAX_RET_BLOCK_LEN;        /* BS10138 */
  ssl_ret_block = (ACF00SSL_ret_block_typ *)malloc(ssl_ret_block_len);
  if (ssl_ret_block EQ NULL)
  {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                   "ACF00SSL return block",  ssl_ret_block_len);
     rc = ESA_FATAL;
     goto get_user_xsgp_exit;
  };

  ssl_ret_block->len = ssl_ret_block_len;
  ssl_ret_block->ret_num = 0;
  ssl_ret_block->flags = 0X00;

  /*
   *   Call ACF00SSL
   */
  ath_rc = (*p_ctsaath)("NON_APF");     /* set auth off.  rc=0 */
  ESA_DIAG_printf(PLT_COMP_XREF, 6, "UnAuth before call");

  int_rc = (*p_acf00ssl)(inputLID, ssl_ret_block);

  ath_rc = (*p_ctsaath)("APF_AUT");     /* set auth on.   rc=0 */
  ESA_DIAG_printf(PLT_COMP_XREF, 6, "ReAuth after call");

  /* BS10138 ESA_DIAG_printf(PLT_COMP_XREF, 6,
                  "ACF00SSL: rc = %d   source_num = %d   flags = %x",
                  rc, ssl_ret_block->ret_num, ssl_ret_block->flags); */
  /* BS10138 - start */
  ESA_DIAG_printf(PLT_COMP_XREF, 6,
      "ACF00SSL: rc = %d   blklen = %d  source_num = %d   flags = %x",
                  rc, ssl_ret_block->len,
                  ssl_ret_block->ret_num, ssl_ret_block->flags);
  /* BS10138 - end   */
  if (int_rc NE 0)
  {
    /* WS10079N
    sprintf(errmsg, "ACF00SSL failed with a return code of %d",
                    int_rc);   */
    sprintf(errmsg,                                       /* WS10079N */
       "ACF00SSL for %s failed with a return code of %d", /* WS10079N */
       inputLID, int_rc);                                 /* WS10079N */
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                  errmsg, 16, __LINE__);
    rc = ESA_ERR;
    goto get_user_xsgp_exit;
  };

  if (ssl_ret_block->flags EQ 0X80)
  {                                                       /* BS10138 */
    CTSAMSG_print(ACF2_XSGP_INCOMPLETE, msgs, NULL, dest, inputLID);
    /* BS10138 - start */
    /* If not all Sources and SourceGroups were retrieved, set       */
    /* the IsIncomplete flag.                                        */
    pair = ADDINFO_search("isIncomplete",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs);
    if (pair NE NULL)
    {
       if( pair->value[0] NE 'Y')
          rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                pair);
       if (rcc NE ESA_OK)
       {
         sprintf(errmsg,
                 "Update <%s> keyword failed. rc=%d",
                 "isIncomplete",rcc);
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                       dest, component,func,
                       errmsg, rcc,__LINE__);
      }
    }
  }
  /* BS10138 - end   */

  /*
   *   Copy Source and SourceGroup names to addinfo
   */
  source_name = ssl_ret_block->source;
  ESA_DIAG_printf(PLT_COMP_XREF, 6,"ssl sources:<%.50s>",
                  source_name);

  for (i = 0; i LT ssl_ret_block->ret_num; i++, source_name+=8)
  {
    ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "source(%d):  <%.8s>",
                    i+1, source_name);
    strncpy(source_str, source_name, 8);
    source_str[8] = NULL_CHAR;
    /*set a null if space at the end... WS10078A start */
    space_pos = strchr(source_str,' '); /*->space if found*/
    if(space_pos NE NULL)               /*space is found*/
    {
     *space_pos = NULL_CHAR;            /*set NULL instead of space*/
     ESA_DIAG_printf(PLT_COMP_XREF, 6,"set NULL at end of source=<%s>",
                     source_str);
    }
    /* WS10078A end */
    ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "s: %p / %d    sg: %p / %d   group_found = %d",
                    s_pair, s_full, sg_pair, sg_full, group_found);

     /*************************** WS10079A ****************************
      * If SourceGroup is found in the list and scope is not 'a',     *
      * no need to call ACF2_Get_Xref any more as all the other sources
      * are SourceGroups and we do not need the SYSID.       WS10079A *
      *****************************************************************/
     /*WS10079A if((group_found EQ FALSE) ***/
     if((group_found EQ TRUE) AND                  /*WS10079A*/
        (params_ptr->XREF_SYSID_SCOPE[0] NE 'a')){ /*WS10079A*/
       ESA_DIAG_printf(PLT_COMP_XREF,6,
         "Group found & scope NE ALL,No need 2 call ACF2_Get_Xref");
       strcpy(xrefname_out,source_str);
       source_type = 'G';                                /* WS10079T */
       goto upd_addinfo;                                 /* WS10079T */
     }

      /*WS10079A rc = XREF_Block_Find(source_str,
                           XREFBlk,
                           &is_group,
                           admin_params);  */
     xrefname_out[0] = NULL_CHAR;                         /* WS10079N */
     /* WS10079N rc = ACF2_Get_Xref("GETTHISA",  */
     acf2_rc = ACF2_Get_Xref("GETTHISA",                  /* WS10079N */
              XBhandle,
              &((*GUXhandle)->acf2_get_xref_handle),
              'S',
              &block_read,
              source_str,
              xrefname_out,
              NULL,                                       /* WS10079N */
              PLT_COMP_XREF,
              admin_params);
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
        /*WS10079A "XREF_Block_Find for %s - rc = %d   is_group = %c",
                      source_str, rc, is_group); */
        "ACF2_Get_Xref rc<%d> xrefname_out<%s> type<%c>", /*WS10079A*/
        acf2_rc, xrefname_out,block_read);              /* WS10079N */
        /* WS10079N rc, xrefname_out,block_read);      /@WS10079A@/ */
     /*WS10079A if (rc NE ESA_OK)
     {
       rc = ESA_ERR;
       goto get_user_xsgp_exit;/*  XREF_Block_Find issued a msg *
     }; */
     /********************** WS10079A start 2 *************************
     /* replace Source/SourceGroup decision per ACF2_Get_Xref         *
     /*****************************************************************
      if (is_group EQ 'Y')
        group_found = TRUE; */
     /* WS10079N if (rc EQ ESA_OK) { */
     if (acf2_rc EQ ESA_OK)                               /* WS10079N */
     {                                                    /* WS10079N */
       source_type = block_read;
       if(block_read EQ 'G') group_found = TRUE;
       ESA_DIAG_printf(PLT_COMP_XREF,6,
         "Group<%s> found in short <%c>",xrefname_out,source_type);
       goto upd_addinfo;                                 /* WS10079T */
     }
     /******************************************************************
      * Source not found in short list so it should be in the long list*
      * If XREF_SYSID_SCOPE is ALL_SYSTEMS, call ACF2_Get_Xref again   *
      * to find it in the long list and get its SYSID.                 *
      ******************************************************************/
     /* WS10079N if (rc EQ ACF2_Not_Found) {          /@WS10079A@/  */
     if (acf2_rc EQ ACF2_Not_Found)                       /* WS10079N */
     {                                                    /* WS10079N */
       if (XBhandle->bld_nf EQ TRUE)                      /* WS10079N */
       {                                                  /* WS10079N */
         lid_perm_handle->Source_nf = TRUE;               /* WS10079N */
         rc = ESA_ERR;                                    /* WS10079N */
         goto get_user_xsgp_exit;                         /* WS10079N */
       };                                                 /* WS10079N */

       if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a') { /*WS10079A*/

        /* WS10079N rc = ACF2_Get_Xref("GETTHISA",    /@WS10079A@/ */
        acf2_rc = ACF2_Get_Xref("GETTHISA",              /* WS10079N */
               XBhandle,
               &((*GUXhandle)->acf2_get_xref_handle),
               'L',             /*search in long list        */
               &block_read,
               source_str,                            /* WS10079T */
               xrefname_out,
               NULL,                                      /* WS10079N */
               PLT_COMP_XREF,
               admin_params);
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "ACF2_Get_Xref rc<%d> xrefname_out<%s> type<%c>", /*WS10079A*/
        acf2_rc, xrefname_out,block_read);                /* WS10079N */
        /* WS10079N rc, xrefname_out,block_read);      /@WS10079A@/ */

        /* WS10079N if (rc EQ ESA_OK) {  */
        if (acf2_rc EQ ESA_OK)                            /* WS10079N */
        {                                                 /* WS10079N */
          source_type = block_read;
          if(block_read EQ 'G') group_found = TRUE;
          ESA_DIAG_printf(PLT_COMP_XREF,6,
            "Group<%s> found in long <%c>",xrefname_out,source_type);
          goto upd_addinfo;                              /* WS10079T */
        }

        /* WS10079N if(rc EQ ACF2_Not_Found) {  */
        if (acf2_rc EQ ACF2_Not_Found)                    /* WS10079N */
        {                                                 /* WS10079N */
         /* WS10079T
         sprintf(errmsg,
  "Source<%s> not found in both lists. Continue with next Source. (%s)",
           source_str, inputLID);
         CTSAMSG_print(WARN_INT1, msgs, NULL, dest, component, func,
           errmsg, 3, __LINE__);
            WS10079T */
         CTSAMSG_print(ACF2_XREF_NOT_FOUND_FOR_USER,     /* WS10079T */
            msgs, NULL, dest, "Source",                  /* WS10079T */
            source_str,inputLID,source_str);             /* WS10079T */
         continue;
        }

        /* WS10079T start */
        if((XBhandle->bld_err EQ TRUE) OR
           (XBhandle->XB_err EQ TRUE)) {
          lid_perm_handle->Source_error = TRUE;
          ESA_DIAG_printf(PLT_COMP_XREF,6,
            "bld_err/XB_err=TRUE, set Source_error=TRUE and rc=FATAL");
          rc = ESA_FATAL;
          goto get_user_xsgp_exit;
        }
        /* WS10079T end   */

        sprintf(errmsg,
           "Unexpected rc<%d> from ACF2_Get_XREF Long list",
            rc);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                 func, errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto get_user_xsgp_exit;

       } /*end of if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a') */
      else { /* not found in Short list and scope NE 'a' */
        block_read = XBhandle->shortest;               /* WS10079T */
        if(block_read EQ 'X') {
          source_type = 'G';
          group_found = TRUE;
        }
        else if(block_read EQ 'G') source_type = 'X';
        strcpy(xrefname_out,source_str);              /* WS10079T */
        ESA_DIAG_printf(PLT_COMP_XREF,6,               /* WS10079T */
           "source not found in short, sysid not required. "
           "xrefname_out: <%s>, source_type: %c, group_found:%d",
           xrefname_out,source_type,group_found);
        rc = ESA_OK;                                   /* WS10079T */
        goto upd_addinfo;                              /* WS10079T */
      }
    } /* end if (rc EQ ACF2_Not_Found) */

    if((XBhandle->bld_err EQ TRUE) OR
       (XBhandle->XB_err EQ TRUE)) {
      /* WS10079N lid_perm_handle->Role_error = TRUE;  */
      lid_perm_handle->Source_error = TRUE;               /* WS10079N */
      ESA_DIAG_printf(PLT_COMP_XREF,6,
        "bld_err/XB_err = TRUE, set Source_error=TRUE and rc=FATAL");
      /* WS10079N
        "bld_err/XB_err = TRUE, set Role_error=TRUE and rc=FATAL"); */
      rc = ESA_FATAL;
      goto get_user_xsgp_exit;
    }

    sprintf(errmsg,
      "Unexpected rc<%d> from ACF2_Get_XREF Short list", rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
           func, errmsg, 16, __LINE__);
    rc = ESA_FATAL;
    goto get_user_xsgp_exit;

    /************************* WS10079A end 2 *******************/

    upd_addinfo:                                          /* WS10079T */
    pair = NULL;
    /*WS10079A if (group_found EQ TRUE) {*If group-add to SourcesGroup*/
    if (source_type EQ 'G') { /*If group-add to SourceGroup WS10079A */
      if (sg_pair NE NULL  AND  sg_full NE TRUE)
        pair = sg_pair;
    }
    else                      /* else - add to Sources */
      if (s_pair NE NULL  AND  s_full NE TRUE)
        pair = s_pair;

    /*  Add name to appropriate addinfo entry */
    if (pair NE NULL)
    {
      /*WS10079A rc = ADDINFO_addval (source_str, */
      rc = ADDINFO_addval (xrefname_out,           /*WS10079A*/
                           ACF_ADDINFO_VAL_LEN,
                           ADDINFO_LIST_ENTRY,
                           pair, dest, msgs);
      /* WS10082N if (rc EQ ESA_EOF) { /@ No more space in value @/*/
      if (rc NE ESA_OK) { /* No more space in value */    /* WS10082N */
/* WS10078ST Add the setting of ent_type for message CTS3893W
        if (pair EQ s_pair)  s_full = TRUE;
          else  sg_full = TRUE;                                      */
        if (pair EQ s_pair) {
           s_full = TRUE;
           strcpy (ent_type, "Sources");                /* WS10078ST */
        }
        else {
           sg_full = TRUE;
           strcpy (ent_type, "SourceGroups");           /* WS10078ST */
        }
/* WS10078ST Using message CTS3893W instead of CTS1208I
        sprintf(errmsg, "%s user=%s", source_str, inputLID);
        CTSAMSG_print(MSG_KWD_VALUE_TRUNCATED, msgs, NULL, dest,
                        pair->keyword, errmsg);                      */
        CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST */       pair->keyword, inputLID,
/* WS10079A           source_str, strlen(source_str), WS10078ST*/
                      xrefname_out,strlen(source_str), /*WS10079A*/
/* WS10078ST */       pair->vallen, ent_type);
/* WS10078KM - Start  Add isIncomplete attribute in addinfo */
                      rcc = ESA_OK;
                      pair = ADDINFO_search("isIncomplete",
                                      ACF_ADDINFO_KWD_LEN,
                                      addinfo->pair,
                                      addinfo->num_pairs);
                      if (pair NE NULL)
                      {
                         if( pair->value[0] NE 'Y')
                            rcc = ADDINFO_updval("Y",
                                                 ACF_ADDINFO_VAL_LEN,
                                                 pair);
                         if (rcc NE ESA_OK)
                         {
                            sprintf(errmsg,
                                   "Update <%s> keyword failed. rc=%d",
                                   "isIncomplete",rcc);
                            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                          dest, component,func, errmsg,
                                          rcc,__LINE__);
                         }
                      }
/* WS10078KM - Ends */
      };
    };

    /*  If both are full  OR                           */
    /*    ( group was found AND                        */
    /*        (groups not req's or groups are full) )  */
    /*  nothing to do - out                            */
    if ( (s_full EQ TRUE  AND  sg_full EQ TRUE)  OR
          (group_found EQ 'Y' AND
             (sg_pair EQ NULL  OR sg_full EQ TRUE) ) )
      break;
  }
  rc = ESA_OK;
get_user_xsgp_exit:
  if (p_ctsaath NE NULL)
  {
    ath_rc = (*p_ctsaath)("APF_AUT");     /* set auth on.   rc=0 */
    ESA_DIAG_printf(PLT_COMP_XREF, 6, "ReAuth before exit");
  };

  if (ssl_ret_block NE NULL)
    free(ssl_ret_block);

  /* WS10079T
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;
     WS10079T */
 } /* end "GET" */
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;
} /* end Get_User_XSGP */
/*   WS10078N - end  */
/* BS10108 - end of moved routines. */
