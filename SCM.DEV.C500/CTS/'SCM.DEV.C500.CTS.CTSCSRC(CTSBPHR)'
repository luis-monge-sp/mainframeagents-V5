 /**************************************************************
 *                                                             *
 * Title            : Permission Handling Routines (ACF2)      *
 *                                                             *
 * Creation Date    : 11/12/2019                               *
 *                                                             *
 * Description      : This module contains several routines    *
 *                    which manage account and group           *
 *                    permissions. For example, the routines   *
 *                    which build, insert into, and retrieve   *
 *                    from the Permissions Block, all reside   *
 *                    in this module.                          *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 *                                                             *
 * Note:              The common routines and the user-related *
 *                    routines were moved here from CTSBSRV,   *
 *                    and modified as needed because of this   *
 *                    move. Most of these modifications were   *
 *                    not marked with a change id.             *
 *                    The original routines, added by WS10075, *
 *                    can be found as comment in CTSBSRV.      *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When      Description                     *
 * -------  -------  --------  ------------------------------- *
 * WS10076  NuritY   30/12/19  Manage Permissions as Account   *
 *                             and Group Attributes            *
 * BS10103  SeligT   15/01/20  Permissions are set 2 wrong user*
 * WS10076S SeligT   27/01/20  Add more useful info to error   *
 *                             messages in Get_Rule_Record rtn *
 * WS10076K KailasP  20/01/20  Add Permissions_block_Insert    *
 *                   24/01/20  Add Permissions_block_Get and   *
 *                             Permissions_block_GetNextPerm   *
 * WS10078T ThomaS   01/03/20  Support Roles in accounts       *
 * WS10078A AvnerL   29/03/20  Support Roles in accounts       *
 * WS10078S SeligT   02/04/20  Support Roles                   *
 * WS10078N NuritY   05/04/20  Support XREF records.           *
 * WS10078KG KailasP 27/04/20  Redefine prototype for          *
 *                             ACF2_Cmd2Mem and Get_xref_Record*
 * WS10078KM KailasP 06/06/20  Add isIncomplete attribute in   *
 *                             addinfo if truncated            *
 * BS10105  NuritY   28/06/20  get_Rule_Record does not handle *
 *                             GETFIRST correctly.             *
 * BS10108  NuritY   09/09/20  Move GetUser routines to BGUS,  *
 *                             XREF routines and BSRV.         *
 * BS10108T ThomaS   06/10/20  Add perms_exist parameter to    *
 *                             Get_user_permissions.           *
 *                             Set to FALSE instead of message *
 *                             CTS3891I which will be issued   *
 *                             by the caller.                  *
 * BS10110  NuritY   15/11/20  add NOUIDALL to ACFRPTRX parms  *
 * WS10079A AvnerL   18/11/20  Support Role provisioning       *
 * BS10111  NuritY   16/12/20  Support ruob above the bar.     *
 * WS10079N NuritY   20/01/21  Support Role provisioning       *
 * WS10079T ThomaS   09/02/21  JPMC phase2                     *
 * IS10184  NuritY   02/09/21  Improve scripts performance     *
 * WS10084  ThomaS   21/06/23  Replace ACFRPTRX                *
 * BS10126  VaibhaV  30/08/23  Correct Permissions with quote  *
 * WS10082  MauriC   07/11/22  Recompile for new ADDINFO macros*
 * BS10131  ThomaS   30/01/24  Fix 'NULL UID received' in      *
 *                             Permissions_block_GetNextPerm   *
 * BS10133  ThomaS   11/02/24  0C4 due to null pointer         *
 * BS10135  ThomaS   11/03/24  Delete permission of a user's   *
 *                             direct permission fails         *
 * IS10189  AvnerL   05/11/24  Free storage                    *
 **************************************************************/
 #define _ISOC99_SOURCE                                   /* WS10076N*/
 #include   <globs.h>
 #include <ctest.h>                                      /* WS10084 */

 /*
  *   Standard include files
  */

 #include   STDLIB
 #include   STDIO
 #include   STRING
 #include   TIME
 /* BS10108 - moved to CTSBGUS
 #include   <dynit.h>                               /@ WS10078N @/  */

 /*
  *   ESA include files
  */

 #include ESA_DIAG
 #include ESA_API
 #include ESA_API_CODES
 #include API_ADDINFO
 #include ESA_CTSAMSG

 /*
  *   MVS  include files
  */

 #include MVS_COMP
 #include MVS_CODES                                      /* WS10075 */
 #include MVS_OS_MVS                                     /* WS10076 */
 #include MVS_OS_CLI

 /*
  *   ACF2 include files
  */

 #include ACF2_CODES
 #include ACF2

 /*  WS10075 - start */
 extern  int ctsaldm();
 extern  int ctsadlm();
 /*  WS10075 - end  */
 ASM_RTN_TYP  ctsaolt;                                    /* BS10111 */

/* WS10078KG - Start Moved to CTSBACF *
/* structure needed for Get_XREF_Record routine WS10078A start *
typedef struct {
 Get_RUOBline_handle_rec_typ *h_RUOB;
 } Get_XREF_Rec_Handle;
/* WS10078A end *
* WS10078KG - End*/
/* added by WS10084 and remains as comments for future diagnostic ideas:
static  int            want_diag          = FALSE;
static  int            want_diag1         = FALSE;
static  int            want_diag2         = FALSE;
static  int            want_diag4         = FALSE;
static  int            want_diag5         = FALSE;
*/
static  int            want_diag          = FALSE;
static  int            want_diag1         = FALSE;
/* * * * * * * * WS10075S Start * * * * * * */
/* structure needed for Get_Rule_Record routine */

typedef struct {
 void     * get_line_handle;
 char       prev_line_read[150];
 /* WS10076S char       rule_type[2];   * Access or Resource rule * */
 char       rule_type;  /* Access or Resource rule */    /* WS10076S */
 char       res_name [MAX_PERM_KEY_LEN + 1];             /* WS10076S */
 char       res_type [MAX_PERM_RESTYPE_LEN + 1];         /* WS10076S */
 ASM_RTN_TYP    * p_ctsaruh;                             /* BS10111 */
 } Get_Rule_Rec_Handle;

/*         The following moved to CMAC CTSBACF           WS10078T
// structure needed for Get_user_permissions routine //
typedef struct RULE_TYPE_PERM_handle {
 char       rules_type[5];
 char       last_lid_processed[ACF2_LID_SIZE];
 char       last_lid_read[ACF2_LID_SIZE]; // LID record was read
                                             but not processed   //
 int        permError_indicator;
 } RULE_TYPE_PERM_rec_typ,  *RULE_TYPE_PERM_rec_ptr;
//                                                       WS10078T */

/* WS10076N - move into the routine using it.
 * WANTED_PERM_REC - Wanted Permission Record Entry table for accounts*

 static WANTED_PERM_REC_rec_typ PERM_RECORD_accounts[] = {
    {"LID: "     ,  5,  LID_LINE     },
    {"$KEY("     ,  5,  $KEY_LINE    },
    {"$PREFIX("  ,  8,  $PREFIX_LINE },
    {""          ,  0,  0            }
    };
*/

/* * * * * * * * WS10075S End * * * * * * * */


/* * * * * * * * WS10075K Start * * * * * * */
/* WS10076 The following typedef moved to CTSCCLI
typedef struct MEMORY_HANDLE_STRUCT {
  REXX@UTL_output_blk_rec_typ *block;
  int len;
  int iseof;
} Get_rule_memory_handle;                                            */

 /**************************************************************
 * Function types for the Permission_locate_data routine       *
 **************************************************************/
 typedef enum {
  BYKEY_Function = 1,
  PERMDATA_Function,
  RESNAME_Function
 } Permission_locate_data_functions;

 static int    Permission_locate_data (
             Permission_locate_data_functions     data_funcs,
             char                               * rule_record,
             char                               * kwd_to_find,
             char                              ** requested_data,
             ADMIN_PARAMS_rec_typ               * admin_params);

/* * * * * * * * WS10075K End * * * * * * */


 /* WS10084 start */
 typedef struct S_UID_LIST_ELEMENT {
  struct S_UID_LIST_ELEMENT * next_uid;
  UID uid;
  } UID_List_Element;

 typedef struct S_ROLE_LIST_ELEMENT {
  struct S_ROLE_LIST_ELEMENT * next_role;
  char role[XREF_NAME_SIZE];
  } Role_List_Element;
 /* WS10084 end */

 /*  WS10075 - start */
 #define RULE_TYPE_NUM 2

 typedef struct _parm_data {
      char      rule_type[5];
      char      rule_parm[10];
     } RULE_PARM_typ,  * RULE_PARM_ptr;

 /*  DSET should be the first because we think that this is the shorter
     report, so when roles but not permissions are required for
     accounts, we want to produce the shortest only.                  */
 static RULE_PARM_typ  rule_parm_data[RULE_TYPE_NUM] =
           {  "DSET", "" ,                /* Should be the first   */
              "RSRC", ",TYPE(***)" }; /* RSRC */
/* WS10084
#define NOUIDALL ",NOUIDALL"

 typedef  struct _parm {
      short   parm_len;
      /* BS10110 char    parm[30];   @/
      char    parm[50];                                   /* BS10110 @/
     } rptrx_parm_type,  * rptrx_parm_ptr;
   WS10084 */

/* WS10076N - the structure was moved to the routine using it
 *
 *    ignore list for CTS2RXO
 *
 *    the "full" field indicates whether we should ignore a line
 *    containing a specific character only (for example, a line
 *    containing only blanks).
 *    when this is required, len is 1, full is x'ff' and data
 *    contains the character repeated in the line.
 *
 *    the last line of the beable contains len=0.
 *

 static REXX@UTL_output_ignlist_rec_typ ACFRPTRX_output_ignore_list[] ={
               44, 0, "CA ACF2 - ACFRPTRX - LOGONID ACCESS REPORT -",
               5,  0, "DATE ",
               18, 0, "INPUT PARAMETERS: ",
               30, 0, "LID FILE PROCESSING COMPLETE, ",
               31, 0, "RULE FILE PROCESSING COMPLETE, ",
               8,  0, "STORED: ",
               1,  0xFF, " ",
               0,  0,  " ",
              } ;
   end of move */

/* WS10084
#define  RESETRXE(rxe)                                          \
  rxe.rxeerror = 0;                                             \
  rxe.rxepgm[0] = NULL_CHAR;                                    \
  rxe.rxefunc[0] = NULL_CHAR;                                   \
  rxe.rxemsg[0] = NULL_CHAR;                                    \
  rxe.rxedline[0] = NULL_CHAR;                                  \
  rxe.rxeline_ = 0;
   WS10084  */

 /*  WS10075 - end  */

 /* Bs10108 - this structure was moved to CTSBGUS */
 /*
 /@  WS10078N - start 2/
 typedef  struct _SSL_RET_BLK
  {
    short   len;
    short   ret_num;
    char    flags;
    char    filler[3];
    char    source[8];
  }  ACF00SSL_ret_block_typ,  *ACF00SSL_ret_block_ptr;
 /@  WS10078N - end  @/
 */


 /* WS10084 - removed - not used any more
 static  void  GLR_RXE_message(CTS2RX_error_block_rec_typ  * rxe,
                               ADMIN_PARAMS_rec_typ   * admin_params);
    WS10084 */

 /* BS10111 - removed - not used any more
 static  void  GLR_free_all(LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                            int                          LRA_vec_num,
                            ADMIN_PARAMS_rec_typ       * admin_params);
   end of removed code  - BS10111  */

/* WS10084
 static void GLR_print_ACFRPTRX_output(
                          LID_RULE_AREA_vec_rec_typ  * LRA_vec,
            /* BS10111    int                          LRA_vec_num,@/
            /* BS10111 @/ int                          i,
            /* BS10111 @/ char                       * rptrx_parm,
            /* BS10111 @/ ASM_RTN_TYP                * p_ctsaruh,
                          ADMIN_PARAMS_rec_typ       * admin_params);

   WS10084 */
/* WS10078KG - Move prototype to CTSBACF *
/**************** WS10078A ********************************************
 *  prototype for the Get_XREF_Record routine
 *********************************************************************
static  ESA_RC Get_XREF_Record(char              * function,
                   Get_XREF_Rec_Handle          ** handle,
                   REXX@UTL_output_blk_rec_typ   * ruob,
                   char                          * output_area,
                   int                             output_length,
                   ADMIN_PARAMS_rec_typ          * admin_params);
 * WS10078KG - End */

/* BS10108 - XREF_Blokck_Find was changed to be external
/**************** WS10078A ********************************************
 *  prototype for the XREF_Block_Find routine
 ********************************************************************@/
static ESA_RC XREF_Block_Find(
                 char                     * XREFname,
                 XREF_REC_BLK_rec_typ     * XREFBlk,
                 char                     * IsGroup,
                 ADMIN_PARAMS_rec_typ     * admin_params);
*/
/* WS10084 start */
/**********************************************************************
 *  prototype for the Chain_On_Active routine
 *********************************************************************/
static ESA_RC Chain_On_Active(
                    XBhandle_rec_typ      * R_XBhandle,
                    char                  * role,
                    char                  * perm_data,
                    ESA_DIAG_COMP_typ       comp,
                    ADMIN_PARAMS_rec_typ  * admin_params);
/* WS10084 end   */
/**********************************************************************
 *  prototype for the Permission_drop_decision routine                *
 *********************************************************************/
static ESA_RC Permission_Drop_Decision(
                                char                 * rule_record,
                                char                 * ResType,
                                char                 * UID,
                                char                   EntityType,
                                char                   DirIndir,
                                ADMIN_PARAMS_rec_typ * admin_params);

/**********************************************************************
 *  prototype for the Permission_value_builder routine                *
 *********************************************************************/
static ESA_RC Permission_value_builder(
                        char                   * rule_record,
                        char                   * resource_type,
                        char                   * key,
                        char                   * prefix,
                        char                   * uid,
                        char                     is_direct_perm,
                        char                     entity_type,
          /* WS10084 */ char                     user_or_group,
          /* WS10084 */ int                      roleset_permission,
                        int                      permission_attr_len,
                        char                   * permission_attr,
                        ADMIN_PARAMS_rec_typ   * admin_params );

/**********************************************************************
 *  prototype for the Permission_Get_UID routine                      *
 *********************************************************************/
static ESA_RC Permission_Get_UID(char            * rule_record,
                          char                 * User_or_Group_UID,
                          char                ** return_uid,
                          ADMIN_PARAMS_rec_typ * admin_params);

/* * * * WS10078S start * * * */

/**********************************************************************
 *  prototype for the Permission_Get_ROLEUSER routine                 *
 *********************************************************************/
static ESA_RC Permission_Get_ROLEUSER(char     * rule_record,
                          char                ** return_roleuser,
                          ADMIN_PARAMS_rec_typ * admin_params);

/* * * * WS10078S end * * * */

/**********************************************************************
 *  prototype for the Is_This_A_Perm_Line routine                     *
 *********************************************************************/
/* WS10076N
static int Is_This_A_Perm_Line(char                 * get_line_buffer,*/
static ESA_RC Is_This_A_Perm_Line(                        /* WS10076N */
                               char                 * get_line_buffer,
 /* WS10076S char * -> char */ char                   rule_type,
                               char                 * caller_code,
                /* WS10076N */ int                  * is_perm,
                               ADMIN_PARAMS_rec_typ * admin_params);

/**********************************************************************
 *  prototype for the Perm_Continuation_Handler routine               *
 *********************************************************************/
static int Perm_Continuation_Handler(char         * caller_code,
                       /* BS10111    GET_LINE_PTR   get_line_ptr,  */
                       /* BS10111 */ ASM_RTN_TYP  * p_ctsaruh,
                                     char         * function,
                       /* BS10111    void         * inp_desc_blk,  */
                       /* BS10111 */ char         * p_ruob,
                                     void         * get_line_handle,
                                     char         * input_buffer,
                                     char         * prev_line_read,
    /* WS10076S  char * -> char */   char           rule_type,
                                     char         * complete_perm_area,
                                     int       complete_perm_area_size,
                                ADMIN_PARAMS_rec_typ * admin_params);

/* WS10076K- Start */
/*********************************************************************
 * Procedure Name: Permissions_block_Insert
 *********************************************************************/
/*  WS10079T moved to CTSBACF since it is now EXT
static ESA_RC Permissions_block_Insert(
                                 PERM_BLK_HDR_rec_typ * PBheader,
                                 char                 * UID,
                                 char                 * perm_data,
                                 ESA_DIAG_COMP_typ      comp,
                                 ADMIN_PARAMS_rec_typ * admin_params);
*/
/*********************************************************************
 * Procedure Name: Permissions_block_GetNextPerm
 *********************************************************************/
static ESA_RC Permissions_block_GetNextPerm(
                      PBhandle_typ           * PBhandle,
                      char                   * permission_data,
                      int                      permission_buffer_len,
                      ESA_DIAG_COMP_typ        comp,
                      ADMIN_PARAMS_rec_typ   * admin_params);

/*************** Moved to CTSBACF as EXT ------ WS10079A *************
 * Procedure Name: Permissions_Block_updateIndex
 *********************************************************************
static ESA_RC Permissions_block_UpdateIndex(
                      PERM_BLK_HDR_rec_typ    ** PBheader,
                      int                        last_call,
                      ESA_DIAG_COMP_typ          comp,
                      ADMIN_PARAMS_rec_typ     * admin_params);
 WS10079A end /* WS10076K- End */

/* WS10076N- Start */
/**********************************************************************
 *  prototype for the Permission_block_Look4uid routine               *
 *********************************************************************/
static ESA_RC Permission_block_Look4uid(
                              char                     * uid,
                              PERM_BLK_HDR_rec_typ     * PBheader,
                              char                       chk_prev,
                              char                     * ret_code,
                              PERM_BLK_UID_rec_typ    ** ret_uid,
                              ESA_DIAG_COMP_typ          comp,
                              ADMIN_PARAMS_rec_typ     * admin_params);
/* WS10076N- End   */

/************** Move to CTSBACF as EXT ------ WS10079A ****************
 *  prototype for the Permissions_block_Free routine
 *********************************************************************
static ESA_RC Permissions_block_Free(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params);
 **********************************************************************
 *  prototype for the Permissions_block_Print routine
 *********************************************************************
static ESA_RC Permissions_block_Print(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params);
    ******************* WS10079A *****/


/* WS10078KG - Start moved prototype to CTSBACF *******
/**********************************************************************
 *  prototype for the ACF2_Cmd2Mem (used to be ACF2_Get_Rules) routine
 *********************************************************************
 * WS10078A static ESA_RC ACF2_Get_Rules(              *
static ESA_RC ACF2_Cmd2Mem(
  *WS10078A*           char                            * restype,
                       char                            * resname, *
  *WS10078A*           char                            * rectype,
  *WS10078A*           char                            * recparm,
                       REXX@UTL_output_ignlist_rec_typ * ignlist,
                       REXX@UTL_output_blk_rec_typ    ** p_ruob,
                       ESA_DIAG_COMP_typ                 comp,
                       ADMIN_PARAMS_rec_typ            * admin_params);
/* WS10078KG - End   */

 /* WS10084 static  ASM_RTN_TYP * p_ctsaatc = NULL;   */
 /* BS10111 static  ASM_RTN_TYP * p_cts2rxf = NULL;   */
 /* BS10108 - the definitins below were moved to CTSBGUS   */
 /*
 static  ASM_RTN_TYP * p_acf00ssl = NULL;      /@ WS10078N @/
 static  ASM_RTN_TYP * p_ctsaath = NULL;       /@ WS10078N @/
 */
 /* BS10108 - end of moved part                           */

 static   char   component[]="CTSBPHR";

/******************************************************************
 * Procedure Name: Permission_Drop_Decision
 ******************************************************************
 * Description: Decide whether a permission has to be returned to IIQ.
 *              ACCOUNT:
 *              - Direct permissions: - nothing is dropped.
 *              - Indirect permission:
 *                - All UID(*) will be dropped.
 *                - NEXTKEY+PREVENT rules should be dropped.
 *              Group (direct permission):
 *                NEXTKEY+PREVENT permissions will be dropped-see below.
 * Guidelines:  A rule is considerred as PREVENT when:
 *              Resource rule:
 *              - PREVENT appears.
 *              Access Rule:
 *              - No EXEC(A/L) / READ(A/L) / WRITE(A/L) / ALLOC(A/L)
 *              Call Permission_locate_data to locate the required
 *                keywords and their values, when necessary.
 *              Make sure the word we look in the rule record does not
 *                appear inside another parameter data, such as DATA( ).
 *
 * Input:       Rule record - permission line starting with UID(
 *                            or resname i.e. abc.xyz.*
 *              Resource type - (A)ccess / (R)esource
 *              UID from rule record
 *              Entity type (U(ser)/G(roup)) (I)
 *              Direct/Indirect (D/I)
 *
 * Return Value:ESA_OK - send permission
 *              ESA_SKIP - drop permission
 *              ESa_FATAL - error conditions
 ******************************************************************/
static ESA_RC Permission_Drop_Decision(
                                 char                 * rule_record,
                                 char                 * ResType,
                                 char                 * UID,
                                 char                   EntityType,
                                 char                   DirIndir,
                                 ADMIN_PARAMS_rec_typ * admin_params)
{
 static char func[] = "Permission_Drop_Decision";

 ESA_RC        rc = ESA_OK;
 int           int_rc = 0;
 char        * ret_str = NULL;   /* returned pointer from strstr */
 char        * str_a = NULL;
 char        * str_l = NULL;
 char          keyword_to_find[15] = "";
 char        * keyword_found = NULL; /* kw + val */
 char          errmsg[250] = "";
 char          rolename[10] = "";                        /* WS10079T */
 char          ftype       = NULL_CHAR;                  /* WS10079T */
 char          etype       = NULL_CHAR;                  /* WS10079T */
 char        * entity      = NULL;                       /* WS10079T */
 ACF2_PARAMS_rec_typ         * params_ptr = NULL;        /* WS10079T */
 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);
 ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
  "ResType=|%s| EntityType=|%c| DirIndir=|%c| UID=|%s| rule=|%s|",
   ResType, EntityType, DirIndir, UID, rule_record);    /* WS10079T */
  /* *ResType, EntityType, DirIndir, *UID, *rule_record);  WS10079T */

 params_ptr = admin_params->apiinit_handle;              /* WS10079T */
 /********************************************
  * Indirect Groups are not supported (yet). *
  ********************************************/
 if (EntityType EQ 'G' AND
     DirIndir   EQ 'I')
  {
   sprintf(errmsg,"No support for Group-Indirect permissions");
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                 errmsg, 16, __LINE__);
   rc = ESA_FATAL;
   goto exit;
  };

 /********************************************
  * Indirect Users with UID(*) are filterred. *
  ********************************************/

 if (EntityType EQ 'U' AND
     DirIndir   EQ 'I' )
 { /* we have the UID from the rule in UID parameter */
  if ((UID[0] EQ '*' AND
       strlen(UID) EQ 1) OR
      (strncmp(UID,"(-)",3) EQ 0))           /*WS10078A*/
  {
   ESA_DIAG_printf(PLT_COMP_PERMISSION, 20,
   "User with Indirect & UID(*) or ROLE(-)/USER(-) <%s> is filterred");
   rc = ESA_SKIP;
   goto exit;
  }

  /* WS10079T - start */
  if (params_ptr->DROP_ACCT_IND_PERMS[0] NE NULL_CHAR)
  {
     if (UID[0] EQ '(' )    /* role is inside parenthesis */
     {
       etype = 'R';
       strncpy(rolename,UID+1,9);
       strtok(rolename,")");
       entity = rolename;
     }
     else                   /* we have a UID */
     {
       etype = 'U';
       entity = UID;
     }
     ftype = '?';

     if (Drop_Perms_Match(
            "DROP_ACCT_IND_PERMS",
            params_ptr->DROP_ACCT_IND_PERMS,
            entity,
            etype,
            &ftype,
            PLT_COMP_PERMISSION,
            admin_params) EQ ESA_OK)
     {
       if (ftype EQ 'N')
       {
         /* found in filter - drop perms */
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
         "Indirect account permission of %c(%s) is filterred",
         etype,entity);
         rc = ESA_SKIP;
         goto exit;
       }
     }
  }
  /* WS10079T - end   */

 }

 /* WS10079T - strart*/
 if (EntityType EQ 'G' AND
     params_ptr->DROP_GROUP_PERMS[0] NE NULL_CHAR)
 {
    if (UID[0] EQ '(' )     /* role is inside parenthesis */
    {
      etype = 'R';
      strncpy(rolename,UID+1,9);
      strtok(rolename,")");
      entity = rolename;
    }
    else                    /* we have a UID */
    {
      etype = 'U';
      entity = UID;
    }
    ftype = '?';

    if (Drop_Perms_Match(
           "DROP_GROUP_PERMS",
           params_ptr->DROP_GROUP_PERMS,
           entity,
           etype,
           &ftype,
           PLT_COMP_PERMISSION,
           admin_params) EQ ESA_OK)
    {
      if (ftype EQ 'N')
      {
        /* found in filter - drop perms */
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
        "Group permission of %c(%s) is filterred",
        etype,entity);
        rc = ESA_SKIP;
        goto exit;
      }
    }
 }
 /* WS10079T - end   */
 /****************************************************************
  * Indirect Users or Groups with NEXTKEY+PREVENT are filterred. *
  ****************************************************************/
 if ((EntityType EQ 'U' AND
      DirIndir   EQ 'I') OR
      EntityType EQ 'G')
 {

  ret_str = strstr(rule_record," NEXTKEY(");
  /*  WS10079T
  if (ret_str NE NULL)     /@ NEXTKEY in permission @/     WS10079T */
  if ( (ret_str NE NULL) OR  /* NEXTKEY in permission      WS10079T */
       (ftype EQ 'P')   )    /* Filter PREVENT of entity   WS10079T */
  {
   ESA_DIAG_printf(PLT_COMP_PERMISSION, 20,
     /* WS10079T  "NEXTKEY is in permission.");       */
    "NEXTKEY is in permission / PREVENT is in filter.");/* WS10079T */
   if (ResType[0] EQ 'R')            /* Resource rule */
   {                                 /* ********      */
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 20,
      "Resource Rule.");
    ret_str = strstr(rule_record," DATA(");
    if (ret_str EQ NULL) /* No DATA( in permission */
    {                    /* *******                */
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 20,
        "DATA( is not in permission.");
     ret_str = strstr(keyword_to_find," PREVENT ");
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 20,
       "PREVENT found is: |%s|",ret_str);
     if (ret_str NE NULL)   /* NEXTKEY/filter & PREVENT in permission */
     {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
        /* WS10079T
        "User&Indir / Group with NEXTKEY & PREVENT - is filterred.");
                                                          WS10079T */
      "User&Indir / Group with NEXTKEY & PREVENT / PREVENT in filter"
      " - is filterred. Entity = %s", entity);          /* WS10079T */
      rc = ESA_SKIP;
      goto exit;
     }
    }
    else /* DATA( is in permission */
    {
     strcpy(keyword_to_find,"PREVENT");
     int_rc = Permission_locate_data(BYKEY_Function,
                                 rule_record,
                                 keyword_to_find,
                                 &keyword_found,
                                 admin_params);
     if (int_rc EQ 0)      /* PREVENT is in permission */
     {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
        /* WS10079T
        "User&Indir / Group with NEXTKEY & PREVENT - is filterred.");
                                                          WS10079T */
      "User&Indir / Group with NEXTKEY & PREVENT / PREVENT in filter"
      " - is filterred. Entity = %s", entity);          /* WS10079T */
      rc = ESA_SKIP;
      goto exit;
     }
    }
   }
   /****************************************************************
    * For Access rule, check whether any EXEC(A/L) or READ(A/L) or *
    * WRITE(A/L) or ALLOC(A/L). if no, it's PREVENT                *
    ****************************************************************/
   if (ResType[0] EQ 'A')            /* Access rule */
   {
    str_a = strstr(rule_record," EXEC(A) ");
    str_l = strstr(rule_record," EXEC(L) ");
    if (str_a EQ NULL AND str_l EQ NULL)
    {
     str_a = strstr(rule_record," READ(A) ");
     str_l = strstr(rule_record," READ(L) ");
     if (str_a EQ NULL AND str_l EQ NULL)
     {
     str_a = strstr(rule_record," WRITE(A) ");
     str_l = strstr(rule_record," WRITE(L) ");
     if (str_a EQ NULL AND str_l EQ NULL)
     {
      str_a = strstr(rule_record," ALLOC(A) ");
      str_l = strstr(rule_record," ALLOC(L) ");
      if (str_a EQ NULL AND str_l EQ NULL)
      {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
        /* WS10079T
         "User with Indirect & NEXTKEY & no (A)/(L) - is filterred.");

        "User with Indirect / Group & NEXTKEY / PREVENT " /* WS10079T */
        "in filter & no (A)/(L) - is filterred. "         /* WS10079T */
        "Entity = %s",entity);                            /* WS10079T */
        rc = ESA_SKIP;
        goto exit;
       }
      }
     }
    }
   } /* end of access rule */
  }  /* end of NEXTKEY( found */
 }   /* end of User & Indirect or Group */
 exit:;
  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, rc);
  return rc;
}
/* * * * * * * * WS10075A End  * * * * * * */

/* * * * * * * * WS10075S Start * * * * * * */

/******************************************************************
 * Procedure Name: Permission_Get_UID
 ******************************************************************
 * Description   : Get the UID from the rule record and check
 *                 whether it's a User or Group UID.
 *
 * Input         : pointer to rule record
 * Output        : User or Group UID
 *                 Complete UID from rule record in the format UID(uid)
 * Return Value  : ESA_OK or ESA_FATAL
 ******************************************************************/
static ESA_RC Permission_Get_UID(char                 * rule_record,
                          char                 * User_or_Group_UID,
                          char                ** return_uid,
                          ADMIN_PARAMS_rec_typ * admin_params)
{
  static char func[] = "Permission_Get_UID";

  ESA_RC        rc = ESA_OK;
  int           len = 0;
  int           int_rc = 0;
  char        * from;
  char        * to;
  char          uid[ACF2_UID_SIZE] = "";
  char          keyword_to_find[5] = "UID(";
  char          errmsg[125];
  char        * fromw;
  char        * tow;
  int           lenw;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);

  int_rc = Permission_locate_data(BYKEY_Function,
                              rule_record,
                              keyword_to_find,
                              return_uid,
                              admin_params);
  if (int_rc NE 0)
   {
      sprintf(errmsg,"No UID( in rule record");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   };

  RULE_KWD_VALUE_RTRVR (*return_uid,
                        ACF2_UID_SIZE,
                        uid,
                        rc,
                        fromw,
                        tow,
                        lenw);
  if (rc NE ESA_OK)
   {
      sprintf(errmsg,"UID in rule record too large");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   };

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "uid = |%s|", uid);

  if (Is_UIDMASK_User (uid))    /* is the UID a user UID?   */
     *User_or_Group_UID = 'U';  /* yes, a specific user UID */
  else                          /* is the UID a group UID?  */
     *User_or_Group_UID = 'G';  /* yes, a group UID         */

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "User_or_Group_UID = |%c|", *User_or_Group_UID);

  exit:;

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, rc);
  return rc;
}


/******************************************************************
 * Procedure Name: Permission_dsnrsrc_key_prefix_handler
 ******************************************************************
 * Description   : Assemble or disassemble resource_type(resource_name)
 *                 and [key,prefix,UID/ROLE/USER] attributes.
 *
 *                 Assemble (BUILD) - the routine gets the rule
 *                 entry record and the type, key and prefix attributes
 *                 retriebed form the rule header, and creates the
 *                 the resource type(full-name) attribute.
 *
 *                 Disassemble (PARSE) - the routine gets the
 *                 resource type(full-name) and splits it into its
 *                 parts:  type, key, prefix, resource name without
 *                 key or prefix.
 *
 *
 * Parameters    : request:  (I)
 *                 - BUILD - asseble type(name)
 *                 - PARSE - disassemble type(name)
 *               : input:   (I)
 *                 - For BUILD: -> rule record.
 *                 - For PARSE: -> resource type(resource-name)
 *               : resource type - BUILD (I)  PARSE(O)
 *               : key - BUILD (I)  PARSE(O)
 *               : length of Key area: (I)
 *                 - For BUILD: 0 (N/A)
 *                 - For PARSE: key area length
 *               : prefix - BUILD (I)  PARSE(O)
 *               : length of prefix area: (I)
 *                 - For BUILD: 0 (N/A)
 *                 - For PARSE: prefix area length
 *               : resource attribute - (O)
 *                 - For BUILD: -> resource type(full-name)
 *                 - For PARSE: -> resource name without key/prefix
 *               : resource attribute length (I)
 *                 - Length of resource_attr area.
 *               : keyprefix attribute
 *                 - BUILD (O) - [key,prefix]
 *                 - PARSE(I)  - key,prefix
 *               : length of keyprefix attribute area:  (I)
 *                 - For BUILD: keyprefix_attr area length
 *                 - For PARSE: 0 (N/A)
 *
 *
 *               Sample BUILD call:
 *               rc = Permission_dsnrsrc_key_prefix_handler(
 *                                      "BUILD"
 *                                       rule_record,
 *                                       resource_type,
 *                                       key,
 *                                       0,
 *                                       prefix,
 *                                       0,
 *                                       resource_attr.
 *                                       sizeof(resource_attr),
 *                                       keyprefix_attr.
 *                                       sizeof(keyprefix_attr),
 *                                       admin_params);
 *
 *
 *               Sample PARSE call:
 *               rc = Permission_dsnrsrc_key_prefix_handler(
 *                                      "PARSE"
 *                                       full_resource,
 *                                       resource_type,
 *                                       key,
 *                                       sizeof(key),
 *                                       prefix,
 *                                       sizeof(prefix),
 *                                       resource_name,
 *                                       sizeof(resource_name),
 *                                       keyprefix,
 *                                       0,
 *                                       admin_params);
 *
 *  Notes:
 *         1. KPT is Key,Prefix,Type. The type is UID/ROLE.
 *            Currently the Type attribute is not in use so
 *            KPT is actually only key,prefix. We do not expect
 *            to get a value in Type place.
 *            if we use it in a later srage, we will add code and
 *            parameters to support it.
 *
 * Return Value  : ESA_OK or ESA_FATAL
 ******************************************************************/
ESA_RC Permission_dsnrsrc_key_prefix_handler(
                                 char             * request,
                                 char             * input,
                                 char             * resource_type_attr,
                                 char             * key_attr,
                                 int                key_len,
                                 char             * prefix_attr,
                                 int                prefix_len,
                                 char             * resource_attr,
                                 int                resource_attr_len,
                                 char             * keyprefix_attr,
                                 int                keyprefix_attr_len,
               /* WS10084 */     char               is_direct_perm,
               /* WS10084 */     char               user_or_group,
               /* WS10084 */     int                roleset_permission,
                                 ESA_DIAG_COMP_typ  comp,
                                 ADMIN_PARAMS_rec_typ * admin_params)
{
  static char func[] = "Permission_dsnrsrc_key_prefix_handler";

  ESA_RC   rc = ESA_OK;
  int      len = 0;
  int      int_rc = 0;
  char   * from = NULL;
  char   * blank = NULL;
  char   * to = NULL;
  char   * resource = NULL;
  char     res[MAX_RSS_RESTYPE_NAME_LEN+MAX_RSS_RESOURCE_NAME_LEN+2]="";
  char     keypre[(2*ACF2_RESRULE_KEY_SIZE)+3] = "";

  char     type[MAX_RSS_RESTYPE_NAME_LEN] = "";
  char     key[ACF2_RESRULE_KEY_SIZE] = "";
  char     RESMASK[MAX_RSS_RESOURCE_NAME_LEN] = "";
  char     prefix[ACF2_RESRULE_KEY_SIZE] = "";

  char     errmsg[125] = "";
  char   * roleuser_parm    = NULL;                            /* WS10084 */
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(comp, 1, func);

  ESA_DIAG_printf(comp, 6,
             "request = %s   input = %s",
             request, input);

  if (strcmp(request, "BUILD") EQ 0)
  {
     ESA_DIAG_printf(comp, 6,
             "key = %s   prefix = %s",
             key_attr, prefix_attr);
    /******************************************************************/
    /* We will begin with the resource attribute area which will be   */
    /* set to the following:                                          */
    /* resource_type(resource_name)                                   */
    /*                                                                */
    /* where:                                                         */
    /* resource_type is DSN when it's an access rule and the resource */
    /*               type (APL, CKC, JOB, SAF, etc.) when it's a      */
    /*               resource rule                                    */
    /* resource_name is prefix followed by .resmask (if prefix and    */
    /*               resmask were specified) or prefix alone (if      */
    /*               prefix was specified but not resmask) or . . .   */
    /*               key followed by .resmask (if prefix was not      */
    /*               specified but resmask was) or key alone (if both */
    /*               prefix and resmask were not specified) or . . .  */
    /*               just a hard-coded data set name (if the resmask  */
    /*               was surrounded by single quote marks).           */
    /******************************************************************/
    /* Initlalize return areas */
    memset(resource_attr, 0X00, resource_attr_len);
    memset(keyprefix_attr, 0X00, keyprefix_attr_len);

    /* Initlalize work areas */
    memset (res, 0X00, sizeof(res));  /* This enables putting 1-byte */
                                      /* data in the area without    */
                                      /* NULL_CHAR and the string    */
                                      /* remains valid.              */
    memset(keypre, 0X00, sizeof(keypre)); /* Now we can put 1-byte   */
                                      /* data in the area without    */
                                      /* NULL_CHAR and the string    */
                                      /* remains valid.              */

    strcpy (res, resource_type_attr);
    res[strlen(res)] = '(';

    int_rc = Permission_locate_data(RESNAME_Function,
                                input,
                                "RESNAME",
                                &resource,
                                admin_params);
    ESA_DIAG_printf(comp, 6,
             "Permission_locate_data returned: res = |%s|  rc = %d",
             resource, int_rc);

    if (int_rc EQ 8)                 /* no resmask on line */
    {
      if (strlen(prefix_attr) NE 0)  /* take key or prefix   */
         strcat (res, prefix_attr);
      else
         strcat (res, key_attr);
    }
    else
      if (int_rc EQ 0)           /* found resmask on line - take it.*/
      {
        blank = strchr(resource, ' ');  /* point to past the resmask */
        len   = blank - resource;   /* get length of resmask */
        /* BS10126 start
           Removed special handling for resmask w/o quote.
           prefix/key is prefixed for both cases
        if (resource[0] NE QUOTE_CHAR) /* if resmask w/o quote     @/
        {  BS10126 end */
          if (strlen(prefix_attr) NE 0)    /* take key or prefix   */
             strcat (res, prefix_attr);
          else
             strcat (res, key_attr);
          res[strlen(res)] = '.'; /* put '.' after key/prefix     */
        /* BS10126
        };                                              BS10126   */

        strncpy(res+strlen(res), resource, len);  /* copy resmask */
      }
      else
      {
        sprintf(errmsg,
            "Permission_locate_data for RESNAME: rule = %30s  rc = %d",
             input, int_rc);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                      errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      };

    res[strlen(res)] = ')';

    /******************************************************************/
    /* We will now build the keyprefix attribute area which will be   */
    /* set to the following:                                          */
    /* [key,prefix]                                                   */
    /*                                                                */
    /* In phase 2, the 3rd section may be set to ROLE, USER or UID    */
    /******************************************************************/

    keypre[0] = '[';
    strcat (keypre, key_attr);
    /* Append prefix and comma only if there is value to prefix */
    if (strlen(prefix_attr) NE 0)
    {
       keypre[strlen(keypre)] = ',';
       strcat (keypre, prefix_attr);
    }
    /* Appending UID/ROLE/USER will be considered for phase 3 */
    /*
    strcat (keypre, ",");
    strcat (keypre, "UID");
    */

    /* WS10084 start */
    /* If USER() or UID but USER append R or U */
    if (is_direct_perm EQ 'D')
    {
       if (roleset_permission)
       {
          rc = Permission_Get_ROLEUSER(input,
                                       &roleuser_parm,
                                       admin_params);
          if (rc EQ ESA_OK)
             if (roleuser_parm[0] EQ 'U')

                if (strlen(prefix_attr) NE 0)                    /* BS10135 */
                  strcat (keypre, ",R");
                else                                             /* BS10135 */
                  strcat (keypre, ",,R");                        /* BS10135 */
       }
       else /* not a ROLESET */

          if (user_or_group EQ 'U')
                if (strlen(prefix_attr) NE 0)                    /* BS10135 */
                   strcat (keypre, ",U");
                else                                             /* BS10135 */
                   strcat (keypre, ",,U");                       /* BS10135 */
    };
    /* WS10084 end   */

    keypre[strlen(keypre)] = ']';

    /*
     *   Return the data to the caller
     */
    if (resource_attr NE NULL)
    {
      if (strlen(res)+1 LE resource_attr_len)
      {
        strcpy (resource_attr, res);
        ESA_DIAG_printf(comp, 6,
                  "Returned resource attribute = |%s|", resource_attr);
      }
      else
      {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                      "resource attribute area too small",
                      16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }
    };

    if (keyprefix_attr NE NULL)
    {
      if (strlen(keypre)+1 LE keyprefix_attr_len)
      {
        strcpy (keyprefix_attr, keypre);
        ESA_DIAG_printf(comp, 6,
             "Returned key prefix attribute = |%s|", keyprefix_attr);
      }
      else
      {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                      "key prefix attribute area too small",
                      16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }
    };
  }   /*  End of BUILD section   */
  else
    if (strcmp(request, "PARSE") EQ 0)
    {
      ESA_DIAG_printf(comp, 6,
             "keyprefix = %s", keyprefix_attr);

      /* Initlalize return areas */
      memset(resource_type_attr, 0X00, 4);
      memset(key_attr, 0X00, key_len);
      memset(prefix_attr, 0X00, prefix_len);
      memset(resource_attr, 0X00, resource_attr_len);

      /* Initlalize work areas */
      /* This enables putting 1-byte data in the area without    */
      /* NULL_CHAR and the string remains valid.                 */
      memset (res, 0X00, sizeof(res));
      memset (type, 0X00, sizeof(type));
      memset (RESMASK, 0X00, sizeof(RESMASK));
      memset (prefix, 0X00, sizeof(prefix));
      memset (key, 0X00, sizeof(key));

      /****************************************************************/
      /* The resource information is received in following format:    */
      /* resource_type(resource_name)                                 */
      /* 1. If resource_name is enclosed between single quote for     */
      /*    example ('HARD.CODED.NAME') then this value is returned   */
      /*    in resource_attr regardless of the keyprefix_attr         */
      /*    content.                                                  */
      /* 2. If resource name is not enclosed in quote                 */
      /*    2.1 If keyprefix_attr contains prefix then remove the     */
      /*        prefix from the reource name and return it (the       */
      /*        resource name without the peefix) in resource_attr.   */
      /*    2.1 If keyprefix_attr does not contains prefix then       */
      /*        remove the key from the reource name and return it    */
      /*        (the resource name without the key) in resource_attr. */
      /* 3. Return the key from keyprefix in key                      */
      /* 4. If keyprefix contains prefix, return it in prefix.        */
      /*                                                              */
      /* The resource_type and resource_name can not be null.         */
      /* The RESMASK, prefix can be NULL                              */
      /*                                                              */
      /****************************************************************/

      /*  Take the resource type */
      to = strchr(input,'(');
      if ( to EQ NULL )
      {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                      "resource type not found",
                      16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }

      strncpy(type, input, to-input);

      ESA_DIAG_printf(comp, 6,
             "type = %s", type);

      from = to + 1;         /* from -> resource name  */

      /*  Take the resource name */
      to = strchr(input,')');   /* to -> end of resource name */

      if ( to EQ NULL )
      {
        sprintf(errmsg,"Error parsing resource_name");
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                 errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }

      /* Check if the resource_name is enclosed between single quotes */
      if ( from[0] EQ QUOTE_CHAR )
        strncpy( RESMASK, from, to-from); /* it is, copy to resmask */
      else
        strncpy(res, from, to-from);

      ESA_DIAG_printf(comp, 6,
             "RESMASK = %s     res = %s", RESMASK, res);

      /* Take key from KPT - key can not be null */
      from = keyprefix_attr;
      to = strchr(keyprefix_attr,',');

      if ( to EQ NULL )        /* only key */
        len = strlen(keyprefix_attr);
      else
        len = to-from;

      if ( (to NE NULL   AND  len EQ 1)   OR /* first char is "'" */
           (to EQ NULL   AND  len EQ 0) )      /* or empty string */
      {
        sprintf(errmsg,"Key not found in KPT");
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                      errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }

      strncpy(key, from, len);
      ESA_DIAG_printf(comp, 6,
             "key = %s", key);

      /* BS10135 start */
      /* we need to handle the following cases:
         pre  WS10034 triplet: [key] or [key,prefix]
         post WS10034 triplet: [key,U] or [key,prefix,U]
         post BS10135 triplet: [key,,U] or [key,prefix,U]
      */
      /* BS10135 end   */
      /* Take prefix from KPT                                      */
      /*                                                           */
      if ( strlen(keyprefix_attr) GT len)   /*   do we have prefix ? */
      {
        /* we have more than just a key                          BS10135 */
        from = to+1;                       /* after comms          */
        if ( strlen(from) NE 0)            /* do we have prefix ?  */
           /*strcpy(prefix, from);         /@ take prefix  @/ /* BS10135 */
        /* we have a comma after the key + some more             BS10135 */
        {                                                     /* BS10135 */
           /* 2nd comma immediately after the first means that   BS10135 */
           /* we have [key,,..]=empty prefix:post BS10135 format BS10135 */
           if (*from NE ',')         /* if not empty prefix      BS10135 */
           {                                                  /* BS10135 */
             to = strchr(from,',');  /* 2nd comma later?         BS10135 */
             if (to NE NULL)      /* found 2nd comma later       BS10135 */
               strncpy(prefix, from, to-from);  /* copy prefix   BS10135 */
             else                                             /* BS10135 */
             /* we have [key,prefix] or [key,U] : pre BS10135    BS10135 */
             if ( strlen(from) NE 1)   /* it is [key,prefix]     BS10135 */
                 strcpy(prefix, from);                        /* BS10135 */
             else                                             /* BS10135 */
                if (*from NE 'U')      /* it is [key,prefix]     BS10135 */
                   strcpy(prefix, from);                      /* BS10135 */
           }                                                  /* BS10135 */
        }                                                     /* BS10135 */
      }

      ESA_DIAG_printf(comp, 6,
             "prefix = %s", prefix);

      /*  set resmask (resource name as in rule), if empty */
      if (RESMASK[0] EQ NULL_CHAR)
      {
        if ( strlen(prefix) GT 0 )
        {
          if( (strncmp(res, prefix, strlen(prefix)) EQ 0) )
          {
            /* The resourcename contains prefix followed by RESMASK */
            strcpy( RESMASK,(res+(1+strlen(prefix))) );
          }
          else
          {
            sprintf(errmsg,
           "prefix value from KPT (%s)(%i), resource (%s) are not same",
               prefix, strlen(prefix),res);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component,func,
                          errmsg, 16, __LINE__);
            rc = ESA_FATAL;
            goto exit;
          }
        }
        else
        {
          if( (strncmp(res, key, strlen(key)) EQ 0) )
          {
            /* The resourcename contains key followed by RESMASK */
            strcpy( RESMASK,(res+(1+strlen(key))) );
          }
          else
          {
            sprintf(errmsg,
           "key value from KPT (%s)(%i), resource (%s) are not same",
                 key, strlen(key),res);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component,func,
                          errmsg, 16, __LINE__);
            rc = ESA_FATAL;
            goto exit;
          }
        }
      }

      ESA_DIAG_printf(comp, 3,
   "Internal values: restype = %s  key = %s  prefix = %s  RESMASK = %s",
                type, key, prefix, RESMASK);

      if (resource_type_attr NE NULL)
        strcpy(resource_type_attr, type);

      if (key_attr NE NULL)
      {
        if (strlen(key)+1 LE key_len)
          strcpy(key_attr, key);
        else
        {
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                        "key attribute area too small",
                        16, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }
      };

      if(prefix_attr NE NULL)
      {
        if (strlen(prefix)+1 LE prefix_len)
          strcpy(prefix_attr, prefix);
        else
        {
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                        "prefix attribute area too small",
                        16, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }
      };

      if(resource_attr NE NULL)
      {
        if (strlen(RESMASK)+1 LE resource_attr_len)
          strcpy(resource_attr, RESMASK);
        else
        {
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                        "resource attribute area too small",
                        16, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }
      };

      ESA_DIAG_printf(comp, 1,
       "Returned values: restype = %s  key = %s  prefix = %s  res = %s",
                   resource_type_attr, key_attr, prefix_attr,
                   resource_attr);

    }
    else      /* Incorrect request type   */
    {
      sprintf(errmsg,"invalid parameter %s", request);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                    errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    };


  exit:;
  /*
  if (want_diag2)                                 /* WS10084 @/
  ESA_DIAG_exit(comp, 0, func, rc);               /* WS10084 @/
  else                                            /* WS10084 @/
  */
  ESA_DIAG_exit(comp, 1, func, rc);
  return rc;
}

/* BS10108 - the code below was moved to CTSBSRV because it handles
              XREF records and not permissions.
/@***************** WS10078A start ********************************
/@*****************************************************************
 * Procedure Name: XREF_Block_Find
 ******************************************************************
 * Description   : Search the XREFName received as first parameter
 *                 in XREF_Block.
 *                 If found, set the IsGroup output parameter based
 *                 on XREF_Block's type & group (XREFBlk->type,group))
 *                 If not found, we assume it's in the "other" type and
 *                 return the "other" type than the one in XREFBlk->type
 *
 * Input         : XREFName - name of Role/Source to find its type
 *                 XREFBlk  - XREF_Block address
 * Output        : IsGrouop - Y/N (XrefBlk->type is R/S)
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_FATAL - fatal error
 *****************************************************************@/
/@ BS10108 static ESA_RC XREF_Block_Find(                        @/
ESA_RC XREF_Block_Find(                                   /@ BS10108 @/
                 char                     * XREFName,
                 XREF_REC_BLK_rec_typ     * XREFBlk,
                 char                     * IsGroup,
                 ADMIN_PARAMS_rec_typ     * admin_params)
/@ copied from ctsbacf cmac for reference while coding
typedef struct XREF_REC_block {            /@                        *
  char              eyec[4];               /@ xxx_BLOCK_EYEC above   *
  char              type;                  /@ XREF_REC_TYPE_xxx      *
  char              group;                 /@ Y | N                  *
  int               num_names;             /@                        *
  char              names[XREF_NAME_SIZE]; /@                 *
  } XREF_REC_BLK_rec_typ,  *XREF_REC_BLK_rec_ptr; /@          @/
{
  static char func[] = "XREF_Block_Find";

  ESA_RC     rc = ESA_OK;
  int        i_num_names = 0;
  char       * pXREFNames;              /@ cur ptr in XREFBlk->names @/

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);
  ESA_DIAG_printf(PLT_COMP_XREF,6,
    "XREFName=<%s> Blk.type=<%c> Blk.group=<%c> Blk.num_names=<%d>",
    XREFName, XREFBlk->type, XREFBlk->group, XREFBlk->num_names);

  if ((XREFName EQ NULL) OR
      (XREFBlk EQ  NULL) OR
      (IsGroup EQ NULL)) {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                   "NULL parameter is illegal", 16, __LINE__);
     rc = ESA_FATAL;
     goto exit_XREF_Block_Find;
  }

  i_num_names=1;
  pXREFNames = XREFBlk->names;
  while (i_num_names LE XREFBlk->num_names)
  {
   ESA_DIAG_printf(PLT_COMP_XREF,6,
     "pXREFNames=<%s> XREFName=<%s> i_num_names=<%d>",
     pXREFNames, XREFName, i_num_names);

   if (strstr(pXREFNames,XREFName) NE NULL)
     break;
   i_num_names++;
   pXREFNames+=9;
  }

  ESA_DIAG_printf(PLT_COMP_XREF,6,
     "i_num_names=<%d> XREFBlk->num_names=<%d>",
     i_num_names, XREFBlk->num_names);

  if(i_num_names GT XREFBlk->num_names) /@ XREFName not found @/
   if(XREFBlk->group EQ 'N')
          *IsGroup = 'Y';
     else *IsGroup = 'N';
  else /@ XREFName is found @/
   if(XREFBlk->group EQ 'Y')     *IsGroup = 'Y';
                            else *IsGroup = 'N';

  ESA_DIAG_printf(PLT_COMP_XREF,6,
               "XREFName=<%s> *IsGroup = %c",XREFName,*IsGroup);
  exit_XREF_Block_Find:
  ESA_DIAG_exit(PLT_COMP_XREF,1, func, rc);
  return rc;
}
/@ end of XR

/@**********  @/
/@*****************************************************************
 * Procedure Name: Get_XREF_Record
 ******************************************************************
 * Description   : Read the next relevant line via ESA_CLI_get_RUOB_line
 *                 when doing accounts aggregation, collect all lines
 *                 which belong to the same logical record and pass it
 *                 up to the caller (XREF_Block_Build).
 *
 * Input         : function: GETNEXT / TERM
 *                 pointer to handle
 *                 ptr to RUOB containing SET X(ROL)+L LIKE(-) output
 *                 ptr to output area
 *                 output area length
 *                 XREF type (ROL/SGP) - not needed as we collect all
 *                                       lines between "LAST CHANGED"
 *                                       until "TOTAL".
 * Output        : output area is set with the XREF logical record which
 *                   is a full output of a role or source in L LIKE(-)
 *                 output area length
 * Return Value  : ESA_OK    - ended alright and returned next record
 *                 ESA_SKIP  - output area too small
 *                 ESA_WARN  - end-of-user notification
 *                 ESA_FATAL - serious error encountered
 *                 ESA_EOF   - end_of_file reached
 *
 * BackGround:
 * The output of the LIST LIKE(-) command has the following format.
 * Note that after the TOTAL line , there is always a whole spaces line.
 *  TLVB / TSROL1 LAST CHANGED BY TLVTS ON 03/10/20-15:26
 *                       EXCLUDE(TLVTS61 TLVTS62 TLVTS63 TLVTS64
 *                       TLVTS81 TLVTS82 TLVTS83 TLVTS84 TLVTS85
 *                       TLVTS97)
 *                       INCLUDE(TLVTS TLVTS1 TLVTS11 TLVTS12 TLV
 *                       TLVTS31 TLVTS32 TLVTS33 TLVTS34 TLVTS35
 *                       TLVTS6-) ROLE
 * TOTAL RECORD LENGTH= 764 BYTES, 18 PERCENT UTILIZED
 *
 * The keywords appear in alfabeta order:
 * DESCRIPT, EXCLUDE, GROUP, INCLUDE, ROLE
 * The routine calls ESA_CLI_get_RUOB_line which returns one physical
 * line from RUOB , which has the output of the LIST LIKE(-) command.
 * The routine collects all physical lines which belong to one logical
 * record, which is one Role or Source with all its keywords.
 * In the example above there are 7 physical lines belong to one record.
 * Once all lines are collected into one logical record, it is returned
 * to the caller.
 *****************************************************************@/
/@static  ESA_RC Get_XREF_Record(char              * function,
                   REXX@UTL_output_blk_rec_typ  ** handle,
                   IDB_GETRUOBLINE_rec_typ       * ruob,
                   char                          * output_area,
                   int                             output_length,
                   ADMIN_PARAMS_rec_typ          * admin_params);  @/
/@static ESA_RC Get_XREF_Record(char      * function, WS10078KG @/
ESA_RC Get_XREF_Record(char                  * function, /@ WS10078KG@/
                        Get_XREF_Rec_Handle        ** handle,
                        REXX@UTL_output_blk_rec_typ * ruob,
                        char                        * output_buffer,
                        int                           max_output_length,
                        ADMIN_PARAMS_rec_typ        * admin_params)
{
  static char func[] = "Get_XREF_Record";

  /@get_RUOBline_handle_rec_typ *h_RUOB in this routine's handle@/
  IDB_GETRUOBLINE_rec_typ   input_desc_block;
  /@ Get_XREF_Rec_Handle *h = NULL; not needed yet @/
  char        * ret_str = NULL;   /@ returned pointer from strstr @/
  char getfunc[8]="";                                 /@ WS10078T @/
  char physical_line[135];
  int  xref_not_done;
  int  cur_data_len = 0; /@ current data length in output_buffer @/
  char       errmsg[125];
  ESA_RC     rc = ESA_OK;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  int        xref_done = 0;
  int        in_xref_element = 0;
 /@********* end of variables defintion ************@/
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;
  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);
  input_desc_block.blk = ruob;

  if (strncmp(function, "TERM", 4) EQ 0)
  {
   ESA_DIAG_printf(PLT_COMP_XREF, 6, "TERM");            /@ WS10078T @/

     /@*************************************************************@/
     /@ Free all allocated areas.                                   @/
     /@*************************************************************@/
     if (handle NE NULL  AND  *handle NE NULL)           /@ WS10076N @/
     {
      rc = ESA_CLI_get_RUOB_line("TERM",
                        (void*)&input_desc_block,
                                 /@ESA_CLI_get_RUOB_line's handle is @/
                        (void*)&((*handle)->h_RUOB), /@ within
                                         Get_XREF_Record's handle    @/
                                 physical_line,
                                 133,
                                 admin_params);
       free(*handle);
       *handle = NULL;
     };
     goto exit;
  };
     /@ only GETNEXT and TERM are valid function values @/
  if (strcmp(function, "GETNEXT") NE 0)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, "invalid input function parameter",16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  /@*****************************************************************
   * Allocate the handle if first call to routine.                  *
   *****************************************************************@/
  if (handle EQ NULL)   /@ Make sure we have a handle @/
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                   "hanlde parameter is NULL", 16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  else
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "handle address on entry = %8x", *handle);
  if (*handle EQ NULL)      /@ first time ==> allocate the handle @/
  {
   *handle = (void *) calloc (1,sizeof(Get_XREF_Rec_Handle));
    if (*handle EQ NULL)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "Get_XREF_Rec handle",
                     sizeof(Get_Rule_Rec_Handle));
       rc = ESA_FATAL;
       goto exit;
    };
   ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "just allocated Get_XREF_Rec_Handle at(%8x)",*handle);
   strcpy(getfunc,"GETFIRST");                           /@ WS10078T @/
  }
  else                                                   /@ WS10078T @/
   strcpy(getfunc,"GETNEXT");                            /@ WS10078T @/
  ESA_DIAG_printf(PLT_COMP_XREF, 6,
                  "h before starting loop = %8x", *handle);

  /@*****************************************************************
   * LOOP:  Collect all lines from "LAST CHANGED" until "TOTAL".    *
   * data is collected into output_buffer and its length is kept in *
   * output_length.                                                 *
   * Logic:                                                         *
   * Call ESA_CLI_get_RUOB_line to get one physical line.           *
   * Loop until EOF while xref_not_done                             *
   *  If "LAST CHANGED" keep it as first line in output_buffer      *
   *  If "TOTAL" return to caller with output_buffer & output_length*
   *  Append physical line to output_buffer & update output_length. *
   *  Call ESA_CLI_get_RUOB_line to get one physical line.          *
   * End of loop                                                    *
   *****************************************************************@/
  /@ call to read first line from LIST LIKE(-) output @/
  /@ rc = ESA_CLI_get_RUOB_line("GETFIRST",                 WS10078T @/
  rc = ESA_CLI_get_RUOB_line(getfunc,                   /@  WS10078T @/
                      (void*)&input_desc_block,
                             /@ESA_CLI_get_RUOB_line's handle is     @/
                      (void*)&((*handle)->h_RUOB), /@ within
                                     Get_XREF_Record's handle        @/
                             physical_line,
                             133,
                             admin_params);
  xref_done = 0;    /@ role/source is not ready yet 2 return 2 caller@/
  in_xref_element = 0;          /@not within role/source output lines@/

  while((rc NE ESA_EOF) AND (NOT xref_done))
  {
   if (NOT in_xref_element)             /@ if outside role/source ... @/
   {
    ret_str = strstr(physical_line,"LAST CHANGED"); /@xerf 1st line?@/
    if (ret_str NE NULL)                   /@ a new role/source found @/
    {
     in_xref_element = 1;                       /@ inside role/source @/
     if (cur_data_len + 133 LE max_output_length)
     {
      strcpy(output_buffer,physical_line); /@set 1st line 2 b return @/
      cur_data_len += 133 ; /@ update logical record length    @/
      ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "1st line of xref element <%s>", physical_line);
     }
     else
     {
      sprintf(errmsg,"max_output_length is too little = <%d>.",
              max_output_length);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, errmsg,
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
     }
    } /@ end of LAST CHANGED @/
   } /@ end of (NOT in_xref_element) @/

   else if (in_xref_element)        /@ if inside role/source ... @/
   {
    ret_str = strstr(physical_line,"TOTAL RECORD LENGTH=");
    if (ret_str NE NULL)                /@ last line of role/source? @/
    {
     in_xref_element = 0;
     xref_done = 1; /@ xref element is done. return to caller @/
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
       "End of xref lines <%s>", physical_line);
     break; /@ WS10078KG - Stop reading and send record to caller @/
    } /@ end of TOTAL RECORD LENGTH= @/

    else   /@not TOTAL & not 1st xref line ==> inside xref element *
            *so concatenate physical line to logical record.      @/
    {
     /@WS10078AG if (cur_data_len + 133 LE max_output_length)@/
     if (cur_data_len + 111 LE max_output_length) /@WS10078AG@/
     {
      /@WS10078AG strcat(output_buffer,physical_line);@/
      strcat(output_buffer,physical_line+22); /@WS10078AG@/
      /@WS10078AG cur_data_len += 133 ; @/
      cur_data_len += 111 ;                   /@WS10078AG@/
      ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "concatenate <%s>", physical_line);
     }
     else
     {
      sprintf(errmsg,"max_output_length is too little = <%d>.",
              max_output_length);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, errmsg,
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
     }
    }
   } /@ end of in_xref_element @/
  rc = ESA_CLI_get_RUOB_line("GETNEXT",
                      (void*)&input_desc_block,
                             /@ESA_CLI_get_RUOB_line's handle is     @/
                      (void*)&((*handle)->h_RUOB), /@ within
                                     Get_XREF_Record's handle        @/
                             physical_line,
                             133,
                             admin_params);
 } /@ end of while((rc NE ESA_EOF) AND (NOT xref_done)) @/

  if (xref_done) rc = ESA_OK;

  exit:
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;
}
/@************** WS10078A end **************@/
  BS10108 -  end of moved code  */

/******************************************************************
 * Procedure Name: Get_Rule_Record
 ******************************************************************
 * Description   : Read the next relevant line (via ctsaruh) BS10111
 *                 and pass it back to the caller.
 *
 * Input         : function: GETFIRST, GETNEXT, TERM
 *                 pointer to handle
 *                 pointer to first ruob                     BS10111
 *                 pointer to list of records to look for
 *                 requested record type (enum)
 *                 rule record buffer length
 *                 caller code: ACFRPTRX or LIST RULES
 *                 only LIST RULES                           WS10084
 * Output        : returned record type (enum)
 *                 rule record buffer
 *                 resource type
 * Return Value  : ESA_OK    - ended alright and returned next record
 *                 ESA_SKIP  - output area too small
 *                 ESA_WARN  - end-of-user notification
 *                 ESA_FATAL - serious error encountered
 *                 ESA_EOF   - end_of_file reached
 ******************************************************************/
/* WS10078T Get_User_XREFAndPermissions in CTSBGUS calls it now, so
   it is no longer static                                           */
/* static  ESA_RC Get_Rule_Record(char             * function,      */
ESA_RC         Get_Rule_Record(char             * function,
                         void                  ** handle,
/* BS10111               GET_LINE_PTR             get_line_ptr,     */
/* BS10111               void                   * inp_desc_blk, */
                         char                   * p_ruob, /* BS10111 */
/* WS10078S Phased out   WANTED_PERM_REC_rec_ptr  wanted_list,      */
                         Permission_Record_Type   req_rec_type,
/* WS10078S Change name  int                      rule_record_len,  */
/* WS10078S to . . . */  int                      return_buffer_len,
                         char                   * caller_code,
                         Permission_Record_Type * ret_rec_type,
/* WS10078S Change name  char                   * rule_record,      */
/* WS10078S to . . . */  char                   * return_buffer,
                         char                   * resource_type,
                         ADMIN_PARAMS_rec_typ   * admin_params)
{
  static char func[] = "Get_Rule_Record";

  /* WS10076S Get_Rule_Rec_Handle *h;   */
  Get_Rule_Rec_Handle *h = NULL;                         /* WS10076S */
  /*WS10078A char get_line_buffer[ACF2_MAX_PERMISSN_SIZE];5 lines*/
  /*Since we return all roles which appear after the ROLES: line, the
    length of get_line_buffer should be big enough for both Roles and
    permissions. Current value of ACF2_MAX_PERMISSN_SIZE is 666 which
    is enough for about 73 roles of 8 characters.
    Increasing it to 900 so it may be good up to 100 roles. WS10078A*/
  char get_line_buffer[900];                              /*WS10078A*/
  char complete_perm_area[ACF2_MAX_PERMISSN_SIZE]; /*place for 5 lines*/
  /* BS10111 char       errmsg[125];                                 */
  char       errmsg[170];                                 /* BS10111 */
  int        already_have_line = 0;
  /* WS10076N int        rc = ESA_OK;    */
  ESA_RC     rc = ESA_OK;                                 /* WS10076N */
  int        is_perm = FALSE;                             /* WS10076N */
  /* BS10105  int        i, first_time;                             */
  int        i;                                         /* BS10105  */
  int        return_rec_to_caller   = FALSE;
  int        end_of_user_condition  = FALSE;
  int        set_and_break          = FALSE;             /* WS10076S */
  int        processing_roles_block = FALSE;             /* WS10078S */
  /* WS10076S void     * ret;                                        */
  char * ret;                                            /* WS10076S */
  char     * tow = NULL;                                 /* WS10078S */
  int        lnw = 0;                                    /* WS10078S */
  int        return_role_to_caller = FALSE;              /* WS10078S */
  char       get_type[10] = "";                          /* BS10105  */
  int        int_rc = 0;                                  /* BS10111 */
  int        dbglvl = 0;                                  /* BS10111 */

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  /* IS10184 DUMMY_PARAMS_rec_typ * params_ptr = NULL; * BS10111 *   */
  COMMON_PARAMS_rec_typ    * cmnprms = NULL;              /* BS10111 */

  /*
  if (want_diag5)                                   /* WS10084 @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
      "In Get_Rule_Record");
  */
/* WS10076S - start */

#define  END_OF_USER_CHECK                                             \
   if (strncmp (get_line_buffer, "--------------------", 20) EQ 0)     \
   {                                                                   \
      end_of_user_condition = TRUE; /* done processing this LID */     \
      break;                        /* break out of switch      */     \
   }

#define  $KEY_CHECK(setbreak)                                          \
      ret = strchr(get_line_buffer+5, ')');    /* end of $KEY parm */  \
      strncpy(h->res_name, get_line_buffer+5,      /* copy resname */  \
                           ret-get_line_buffer+5);                     \
      if (strncmp(ret+1, " TYPE(", 6) EQ 0) /* check for rule type */  \
      {                                                                \
         h->rule_type = 'R';                      /* resource rule */  \
         strncpy(resource_type, ret+7, 3);         /* copy restype */  \
         resource_type[3] = NULL_CHAR;           /* set terminator */  \
      }                                                                \
      else                                                             \
      {                                                                \
         h->rule_type = 'A';                        /* access rule */  \
         strncpy(resource_type, "DSN", 3);         /* copy restype */  \
         resource_type[3] = NULL_CHAR;           /* set terminator */  \
      }                                                                \
      strcpy(h->res_type, resource_type);          /* save restype */  \
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,                         \
                      "rule type=%c - res name=|%s| - res type=|%s|",  \
                      h->rule_type, h->res_name, resource_type);       \
      if (setbreak EQ TRUE)                                            \
      {                                                                \
         *ret_rec_type = $KEY_LINE;     /* set correct enum value  */  \
         return_rec_to_caller = TRUE;   /* return record to caller */  \
         break;                         /* break out of switch     */  \
      }

#define  $PREFIX_CHECK                                                 \
      *ret_rec_type = $PREFIX_LINE;  /* set correct enum value  */     \
      return_rec_to_caller = TRUE;   /* return record to caller */     \
      break;                         /* break out of switch     */

/* WS10076S - end */

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);

  /*
  if (want_diag5)                                         /* WS10084 @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
      "Enter Get_Rule_Record");
  */
  dbglvl = (int)ESA_DIAG_get_debug_level(                 /* BS10111 */
                                   PLT_COMP_PERMISSION);  /* BS10111 */
  if ( dbglvl GT 0   AND   dbglvl NE 77)                  /* BS10111 */
    dbglvl = 1;                                           /* BS10111 */

  /* WS10076N - moved a bit below
  if (*handle NE NULL)
  {
     h = (Get_Rule_Rec_Handle *) *handle;
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "h when entered = %8x", h);
  }
  end of move  */

  if (strncmp(function, "TERM", 4) EQ 0)
  {
     /***************************************************************/
     /* Free all allocated areas.                                   */
     /***************************************************************/
     /* WS10076N if (h NE NULL)                        * WS10076S *  */
     if (handle NE NULL  AND  *handle NE NULL)           /* WS10076N */
     {                                                   /* WS10076N */
       /*  BS10111 - the code below is replaced by a call
           to ctsaruh with TERMIO
       ESA_DIAG_printf(PLT_COMP_XREF, 6, "TERM");       /@ WS10078T @/
       rc = (get_line_ptr)("TERM",     /@ call ESA_CLI_get_RUOB_line @/
                          inp_desc_blk,
        /@ WS10076N @/    &(((Get_Rule_Rec_Handle *)(*handle))->
        /@ WS10076N @/          get_line_handle),
                          get_line_buffer,
                          sizeof(get_line_buffer),
                          admin_params);
           /@ WS10076N    &(h->get_line_handle),                 @/
       /@ WS10076N free(h);  @/
       ESA_DIAG_printf(PLT_COMP_XREF, 6,"free handle %p", /@ WS10078T@/
                       *handle);                          /@ WS10078T@/
         end of replaced code - BS10111 */

       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6, "TERM");   /* BS10111 */

       h = (Get_Rule_Rec_Handle *) *handle;               /* BS10111 */
       if (h->p_ctsaruh NE NULL)                          /* BS10111 */
       {                                                  /* BS10111 */
         int_rc = (*(h->p_ctsaruh))(CTSARUH_REQ_TERMIO,   /* BS10111 */
                          &(h->get_line_handle),          /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          &dbglvl,                        /* BS10111 */
                          CTSARUH_DBGTYPE_PRTDBG,         /* BS10111 */
                          errmsg,                         /* BS10111 */
                          sizeof(errmsg),                 /* BS10111 */
                          NULL);                          /* BS10111 */

         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,          /* BS10111 */
                         "CTSARUH - %s: rc = %d",         /* BS10111 */
                         CTSARUH_REQ_TERMIO, int_rc);     /* BS10111 */

         if (int_rc NE 0)   /* if not OK - issue error msg   BS10111 */
         {                                                /* BS10111 */
            if (errmsg[0] NE NULL_CHAR)                   /* BS10111 */
              CTSAMSG_print(ERR_TL_STRING,                /* BS10111 */
                            msgs, NULL, dest, errmsg);    /* BS10111 */
            sprintf(errmsg,                               /* BS10111 */
                "CTSARUH - %s failed with rc=%d.",        /* BS10111 */
                 CTSARUH_REQ_TERMIO, int_rc);             /* BS10111 */

            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,      /* BS10111 */
                          dest, component, func, errmsg,  /* BS10111 */
                          int_rc, __LINE__);              /* BS10111 */
         };                                               /* BS10111 */
       };                                                 /* BS10111 */

       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,            /* BS10111 */
                      "free handle %p", *handle);         /* BS10111 */
       free(*handle);                                     /* WS10076N*/
       *handle = NULL;
     };                                                   /* WS10076N*/

     /* WS10076S if (h NE NULL)    */
     /* WS10076S   free(h);        */
     goto exit;
  };

  /* We may have: GET, GETFIRST and GETNEXT, and all are processed */
  /* in the same way, so we just check the function prefix for GET */

  /* BS10105  - start */
  /* No GET call. We have GETFIRST and GETNEXT only */
  /*
  if (strncmp(function, "GET", 3) NE 0)
  {
     sprintf(errmsg, "ivalid input function parameter |%s|",
             function);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "invalid input function parameter",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  */
  /*
  if (want_diag5)                                   /* WS10084 @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
      "function = %s", function);
  */
  if (strcmp(function, "GETFIRST") NE 0  AND
      strcmp(function, "GETNEXT") NE 0)
  {
     sprintf(errmsg, "ivalid input function parameter |%s|",
             function);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, errmsg, 16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }

  /* BS10105  - end   */

  /*** *** *** *** *** *** * WS10076S start * *** *** *** *** *** ***/
  /* WS10084
  if ((strcmp(caller_code, "ACFRPTRX")   NE 0) AND
      (strcmp(caller_code, "LIST RULES") NE 0))               WS10084 */
  if (strcmp(caller_code, "LIST RULES") NE 0)              /* WS10084 */
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "invalid input caller_code parameter",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  /*** *** *** *** *** *** * WS10076S end *** *** *** *** *** *** ***/

  /******************************************************************/
  /* We will allocate the handle if this is the first call to this  */
  /* routine.                                                       */
  /******************************************************************/

  if (handle EQ NULL)   /* Make sure we have a handle      * WS10076N */
  {                                                       /* WS10076N */
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,       /* WS10076N */
                   component, func,                       /* WS10076N */
                   "hanlde parameter is NULL",            /* WS10076N */
                   16, __LINE__);                         /* WS10076N */
     rc = ESA_FATAL;                                      /* WS10076N */
     goto exit;                                           /* WS10076N */
  }                                                       /* WS10076N */
  else                                                    /* WS10076N */
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,             /* WS10076N */
                     "handle address on entry = %8x",     /* WS10076N */
                     *handle);                            /* WS10076N */

  if (*handle EQ NULL)
   {
    /* BS10105      first_time = TRUE;   */
    /*WS10079A *handle=(void *) calloc(sizeof(Get_Rule_Rec_Handle),1);*/
    *handle=(void *) calloc(1,sizeof(Get_Rule_Rec_Handle)); /*WS10079A*/
     if (*handle EQ NULL)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "Get_Rule_Rec handle",
                      sizeof(Get_Rule_Rec_Handle));
        rc = ESA_FATAL;
        goto exit;
     };
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                    "just allocated the Get_Rule_Rec_Handle");
    h = (Get_Rule_Rec_Handle *) *handle;                  /* BS10111 */

    /*                                                     * BS10111 *
     *   Verify that common_params exists and keep         * BS10111 *
     *   its address and CTSARUH address.                  * BS10111 *
     */                                                   /* BS10111 */
    /* IS10184
    GET_P_CTSARUH(params_ptr, cmnprms, h->p_ctsaruh)  * BS10111 *    */
    GET_CMNPRMS_PROG(admin_params, cmnprms, p_ctsaruh,    /* IS10184 */
                     h->p_ctsaruh, rc, errmsg)            /* IS10184 */
    if (rc NE ESA_OK)   /* Emvironmental error ? */       /* BS10111 */
    {                                                     /* IS10184 */
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,      /* IS10184 */
                    component, func, errmsg,              /* IS10184 */
                    rc, __LINE__);                        /* IS10184 */
      goto exit;                                          /* BS10111 */
    };                                                    /* IS10184 */
  }
  /* BS10105
  else
    first_time = FALSE;   */
  else                                                    /* BS10111 */
    h = (Get_Rule_Rec_Handle *) *handle;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "h before starting loop = %8x", h);

  /******************************************************************/
  /* LOOP:  If the line read on previous call(s) is not NULL, copy  */
  /* this line, erase it from the handle, and continue without      */
  /* calling the 'get_line' routine. Otherwise, call the 'get-line' */
  /* routine.                                                       */
  /******************************************************************/

  already_have_line = 0;

  if (strcmp(function, "GETFIRST") NE 0)                /* BS10105  */
  {                                                     /* BS10105  */
    /* BS10105  if (strcmp(h->prev_line_read, "") NE 0)            */
    if (h->prev_line_read[0] NE NULL_CHAR)              /* BS10105  */
    {
      /* BS10105
      memset(get_line_buffer, 0X00, sizeof(get_line_buffer)); */
      strcpy(get_line_buffer, h->prev_line_read);
      /*
      memset(h->prev_line_read, 0X00, sizeof(h->prev_line_read)); */
      h->prev_line_read[0] = NULL_CHAR;                 /* BS10105  */
      already_have_line = 1;
      /*
      if (want_diag5)                                   /* WS10084 @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
              "get_line_buffer from before: |%s|", get_line_buffer);
      */
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
              "get_line_buffer from before: |%s|", get_line_buffer);
    }
  }                                                     /* BS10105  */
  else                                                  /* BS10105  */
    /*  GETFIRST - erase prev. line, if exists             BS10105  */
    h->prev_line_read[0] = NULL_CHAR;                   /* BS10105  */

  strcpy(get_type, function); /* GETFIRST / GETNEXT  */ /* BS10105  */
  memset(get_type+strlen(get_type), ' ',     /* pad...      BS10111 */
         sizeof(get_type)-strlen(get_type)); /* with ' '.   BS10111 */

  while (TRUE)
  {
    if (already_have_line)
    {
       already_have_line = 0;
    }
    else
    {
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                       "h->get_line_handle = %8x", h->get_line_handle);
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                       "h = %8x", h);
       /* WS10078SG Removed for performance purposes
       memset(get_line_buffer, 0X00, sizeof(get_line_buffer));       */
       /* BS10105
       rc = (get_line_ptr)(function,      call ESA_CLI_get_RUOB_line */
       /* BS10111 - replced by call to CTSARUH
       /@ call ESA_CLI_get_RUOB_line @/
       rc = (get_line_ptr)(get_type,                    /@ BS10105  @/
                           inp_desc_blk,
                           &(h->get_line_handle),
                           get_line_buffer,
                           sizeof(get_line_buffer),
                           admin_params);         */
       int_rc = (*(h->p_ctsaruh))(get_type,               /* BS10111 */
                          &(h->get_line_handle),          /* BS10111 */
                          p_ruob,                         /* BS10111 */
                          get_line_buffer,                /* BS10111 */
                          NULL,                           /* BS10111 */
                          sizeof(get_line_buffer),        /* BS10111 */
                          NULL,                           /* BS10111 */
                          &dbglvl,                        /* BS10111 */
                          CTSARUH_DBGTYPE_PRTDBG,         /* BS10111 */
                          errmsg,                         /* BS10111 */
                          sizeof(errmsg),                 /* BS10111 */
                          NULL);                          /* BS10111 */

       /* BS10111 if (rc EQ ESA_EOF)  */
       if (int_rc EQ 4)                                   /* BS10111 */
       {                                                  /* BS10111 */
          rc = ESA_EOF;                                   /* BS10111 */
          goto exit;
       }                                                  /* BS10111 */
       /* BS10111 else if (rc NE ESA_OK)  */
       else if (int_rc GT 4)   /* if not OK or EOF - error  BS10111 */
       {
          /* WS10076S Replace this message with another message
                     that contains more useful information
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                        func, "get_line rtn(GETxxxx) failed",
                        16, __LINE__);                               */
          /* * * * * * * * * * * WS10076S start  * * * * * * * * * * */
          /* Use this new message.  It contains more information.    */
          /* BS10111 - replace with the message returned from ctsaruh
          sprintf(errmsg,
             "resname=%s restype=%s error=%s func=%s comp=%s stmt=%d",
             h->res_name, h->res_type,
             "get_line rtn(GETxxxx) failed", func, component, __LINE__);
          CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);   @/
          /@ * * * * * * * * * *  WS10076S end   * * * * * * * * * * @/
                end of replaced code - BS10111 */

          if (errmsg[0] NE NULL_CHAR)                     /* BS10111 */
            CTSAMSG_print(ERR_TL_STRING,                  /* BS10111 */
                          msgs, NULL, dest, errmsg);
          sprintf(errmsg,                                 /* BS10111 */
              "CTSARUH - %s failed with rc=%d. resname=%s restype=%s",
              get_type, int_rc,                           /* BS10111 */
              h->res_name, h->res_type);                  /* BS10111 */

          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,  /* BS10111 */
                        component, func, errmsg,          /* BS10111 */
                        int_rc, __LINE__);                /* BS10111 */
          rc = ESA_FATAL;
          goto exit;
       };

       ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                "get_line_buffer just read: |%s|", get_line_buffer);

       /**************************************************************/
       /* We ignore all lines of the ACFRPTRX report before the      */
       /* first LID: line. In other words, we begin processing the   */
       /* ACFRPTRX report from the first LID: line, not before that  */
       /* line.                                                      */
       /* Note: As part of this fix, we do the identical    WS10078SG*/
       /*       search for ROLE:.  There will not be a      WS10078SG*/
       /*       LID: line and a ROLE: line in the same      WS10078SG*/
       /*       ACFRPTRX report.                            WS10078SG*/
       /**************************************************************/

       /* WS10078SG The following few lines replaced with the next group
       /* WS10078SG of lines.
       if ((first_time)                                 AND
           (strncmp (get_line_buffer, "LID: ", 5) NE 0) AND
           (strcmp(caller_code, "ACFRPTRX") EQ 0))
       {
          ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                          "3 conditions - continue");
          continue;
       }
       else if ((first_time)                            AND
           (strncmp (get_line_buffer, "LID: ", 5) EQ 0) AND
           (strcmp(caller_code, "ACFRPTRX") EQ 0))
       {
          first_time = FALSE;
          ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                          "reached first LID: line");
       }                                                             */

       /* * * * WS10078SG start * * * */
       /* BS10105  if ( (first_time)               AND
            (strcmp(caller_code, "ACFRPTRX") EQ 0) )   */
       if ( strcmp(function, "GETFIRST") EQ 0 )         /* BS10105  */
       {                                                /* BS10105  */
         /* If the firts line was requested, put           BS10105  */
         /* to GETNEXT in get_type so that if/when we      flrebugs */
         /* need to drop this line and call the next       BS10105  */
         /* we won't read te firat again -> loop.          BS10105  */

         /* BS10111 strcpy(get_type, "GETNEXT");     /@ BS10105  @/ */
         strcpy(get_type, CTSARUH_REQ_GETNEXT);         /* BS10111  */

         /* WS10084
         if ( strcmp(caller_code, "ACFRPTRX") EQ 0 )    /* BS10105  @/
         {
           if ( (strncmp (get_line_buffer, "LID: ",  5) NE 0) AND
                (strncmp (get_line_buffer, "ROLE: ", 6) NE 0) )
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                              "3 conditions - continue");
              continue;
           }
           /* BS10105
           else if ( (strncmp (get_line_buffer, "LID: ",  5) EQ 0) OR
                     (strncmp (get_line_buffer, "ROLE: ", 6) EQ 0) )
           {
              first_time = FALSE;                                @/
           else                                         /* BS10105  @/
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                              "reached first LID:/ROLE: line");
           /* BS10105   } @/
         }
            WS10084 */
       }
       /* * * * WS10078SG end * * * */

    }

  /******************************************************************/
  /* We now check whether the caller requested a specific record    */
  /* type or any record type.                                       */
  /* - If the caller requested a specific record type, we look for  */
  /*   it and, when we find it, we return it to the caller.         */
  /* - If the caller requested any record type, we check whether    */
  /*   the get_line_buffer matches the wanted list ($KEY, $PREFIX,  */
  /*   etc.) entry and we return it to the caller. If it does not   */
  /*   match, we check whether it is a permission line (and if it   */
  /*   is, we return it and all of its continuation lines). If the  */
  /*   line is not on the wanted list and is not a permission line, */
  /*   we simply ignore it and go back up to read another line.     */
  /******************************************************************/

    switch(req_rec_type)
    {
      case LID_LINE:
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "caller requested a :LID line");
        if (strncmp (get_line_buffer, "LID: ", 5) EQ 0)
        {
           *ret_rec_type = LID_LINE;    /* set correct enum value  */
           return_rec_to_caller = TRUE; /* return record to caller */
           break;                       /* break out of switch     */
        }
        else
           continue;                    /* go read the next record */
      /* * * * WS10078SG start * * * */
      case ROLE_LINE:
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "caller requested a :ROLE line");
        if (strncmp (get_line_buffer, "ROLE: ", 6) EQ 0)
        {
           *ret_rec_type = ROLE_LINE;   /* set correct enum value  */
           return_rec_to_caller = TRUE; /* return record to caller */
           break;                       /* break out of switch     */
        }
        else
           continue;                    /* go read the next record */
      /* * * * WS10078SG end * * * */
      case $KEY_LINE:
        /*
        if (want_diag5)                                   /* WS10084 @/
          ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
          "req line is $KEY line");
        */
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "caller requested a $KEY line");
        /* * * * BS10103 Start * * * */
        /* Stop processing this LID when encountering an end_of_user */
        /* indicator                                                 */
        /* SELIG76S Created a macro for these lines:
        if (strncmp (get_line_buffer, "--------------------", 20) EQ 0)
        {
           end_of_user_condition = TRUE; // done processing this LID //
           break;                        // break out of switch      //
        }                                                            */
        END_OF_USER_CHECK;                               /* SELIG76S */
        /* * * * BS10103 End * * * */

        set_and_break = TRUE;                            /* SELIG76S */
        if (strncmp (get_line_buffer, "$KEY(", 5) EQ 0)
        {
        /* SELIG76S Created a macro for these lines:
           ret = strchr(get_line_buffer+5, ')'); // end of $KEY parm //
           strncpy(h->res_name, get_line_buffer+5,       // WS10076S //
                   ret-get_line_buffer+5);               // WS10076S //
           if (strncmp(ret+1, " TYPE(", 6) EQ 0) // chk for rule type//
           {
              // WS10076S strcpy(h->rule_type, "R");                 //
              h->rule_type = 'R';                        // WS10076S //
              strncpy(resource_type, ret+7, 3);
              // WS10076S strcpy(resource_type+3, NULL);             //
              resource_type[3] = NULL_CHAR;              // WS10076S //
           }
           else
           {
              // WS10076S strcpy(h->rule_type, "A");                 //
              h->rule_type = 'A';                        // WS10076S //
              strncpy(resource_type, "DSN", 3);
              // WS10076S strcpy(resource_type+3, NULL);             //
              resource_type[3] = NULL_CHAR;              // WS10076S //
           }
           strcpy(h->res_type, resource_type);           // WS10076S //
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,      // WS10076S //
                  "rule type=|%c| - res name=|%s| - res type=|%s|",
                  h->rule_type, h->res_name, resource_type);
           *ret_rec_type = $KEY_LINE;   // set correct enum value  //
           return_rec_to_caller = TRUE; // return record to caller //
           break;                       // break out of switch     //*/
           $KEY_CHECK(set_and_break);                    /* SELIG76S */
        }
        else
           continue;                    /* go read the next record */
      case $PREFIX_LINE:
        /*
        if (want_diag5)                                   /* WS10084 @/
          ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
          "req line is $PREFIX line");
        */
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "caller requested a $PREFIX line");

        /* * * * BS10103 Start * * * */
        /* Stop processing this LID when encountering an end_of_user */
        /* indicator                                                 */
        /* SELIG76S Created a macro for these lines:
        if (strncmp (get_line_buffer, "--------------------", 20) EQ 0)
        {
           end_of_user_condition = TRUE; // done processing this LID //
           break;                        // break out of switch      //
        }                                                            */
        END_OF_USER_CHECK;                               /* SELIG76S */
        /* * * * BS10103 End * * * */

        if (strncmp (get_line_buffer, "$PREFIX(", 8) EQ 0)
        {
        /* SELIG76S Created a macro for these lines:
           *ret_rec_type = $PREFIX_LINE;  // set correct enum value  //
           return_rec_to_caller = TRUE;   // return record to caller //
           break;                         // break out of switch     */
           $PREFIX_CHECK                                 /* SELIG76S */
        }
        else
           continue;                      /* go read the next record */
      /* * * * WS10078S start * * * */
      /* When caller requests the ROLES block, we concatenate each
         role followed by a ';' followed by the next role followed
         by a ';' etc. until we reach the first non-role line.
         (Before each concatenation we make sure that the next role
         fits into the return_buffer.  If it does not, we print an
         appropriate warning message.)
         When we reach the first non-role line, we save the line in
         h->prev_line_read and we return to the caller with the
         return_buffer filled with the ROLES block.
         If we return to the caller with 1 or more roles, we return
         with ESA_OK. If we return without any roles. we return
         with ESA_WARN (end_of_user).                               */
      /* WS10078SG case ROLE_LINE:                                  */
      /* WS10084 No ROLES block without ACFRPTRX
      case ROLES_BLOCK:          /* change enum value name WS10078SG@/
        ESA_DIAG_printf(PLT_COMP_XREF, 6,
                        "caller requested a ROLES block");
        if (strncmp (get_line_buffer, "ROLES: -", 8) EQ 0)
        {
           if (return_buffer_len GE 1)
              return_buffer[0] = NULL_CHAR;
           ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "ROLES: block found");
           processing_roles_block = TRUE;
           continue;                    /* go read the next record @/
        }
        if ( (strncmp (get_line_buffer, "       ", 7) EQ 0) AND
             (processing_roles_block EQ TRUE) )
        {
           ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "concatenating next ROLE");
           tow = strchr(get_line_buffer+7, ' '); /*tow-> end of role@/
           if (tow EQ NULL)
              lnw = strlen(get_line_buffer) - 7;
           else
              lnw = tow - get_line_buffer+7;
           /* lnw now contains the length of role name @/
           ESA_DIAG_printf(PLT_COMP_XREF, 6,
               "lnw = %d  return_buffer_len = %d  return_buffer = %d",
               lnw, return_buffer_len, strlen(return_buffer));
/*WS10078T if (strlen(return_buffer) + lnw + 1 LE return_buffer_len)@/
/*WS10078T@/ if (strlen(return_buffer) + lnw + 2 LE return_buffer_len)
           {
              strncat(return_buffer, get_line_buffer+7, lnw);
              strcat(return_buffer, ";");
                            /* strcat adds a NULL terminator at the @/
                            /* (current) end of the return_buffer   @/
              ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "ROLES block so far: |%s|", return_buffer);
           }
           else
           {
             sprintf(errmsg,
                "error=%s func=%s comp=%s stmt=%d",
                "Not all ROLES fit into output buffer",
                func, component, __LINE__);
             CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);
/* WS10078SG *ret_rec_type = ROLE_LINE;  /* set correct enum value  @/
             *ret_rec_type = ROLES_BLOCK;               /* WS10078SG@/
             return_role_to_caller = TRUE;/* return roles to caller @/
             processing_roles_block = FALSE;
             break;                      /* break out of switch     @/
           }
           continue;                     /* go read the next record @/
        }
        else if (processing_roles_block EQ TRUE)
        {
           strcpy(h->prev_line_read, get_line_buffer);
           if (strlen(return_buffer) GT 0)
           {
/* WS10078SG *ret_rec_type = ROLE_LINE;  /* set correct enum value  @/
             *ret_rec_type = ROLES_BLOCK;               /* WS10078SG@/
             return_role_to_caller = TRUE;/* return roles to caller @/
             ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "final ROLES block: |%s|", return_buffer);
           }
           else
           {
             end_of_user_condition = TRUE;        /* no ROLES found @/
             ESA_DIAG_printf(PLT_COMP_XREF, 6,
                    "no ROLES found");
           }
           processing_roles_block = FALSE;
           break;                            /* break out of switch @/
        }
        else
           continue;                     /* go read the next record @/
      /* * * * WS10078S end * * * * @/
                                                            WS10084 */
      case KPP_LINE:
        /*
        if (want_diag5)                                   /* WS10084 @/
          ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
          "req line is KPP line");
        */
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "caller requested a KPP line");
        /* SELIG76S Created a macro for these lines:
        if (strncmp (get_line_buffer, "--------------------", 20) EQ 0)
        {
           end_of_user_condition = TRUE; // done processing this LID //
           break;                        // break out of switch      //
        }                                                            */
        END_OF_USER_CHECK;                               /* SELIG76S */

        set_and_break = TRUE;                            /* SELIG76S */
        if (strncmp (get_line_buffer, "$KEY(", 5) EQ 0)
        {
        /* SELIG76S Created a macro for these lines:
           ret = strchr(get_line_buffer+5, ')'); // end of $KEY parm //
           strncpy(h->res_name, get_line_buffer+5,       // WS10076S //
                   ret-get_line_buffer+5);               // WS10076S //
           if (strncmp(ret+1, " TYPE(", 6) EQ 0) // chk for rule type//
           {
              // WS10076S strcpy(h->rule_type, "R");                 //
              h->rule_type = 'R';                        // WS10076S //
              strncpy(resource_type, ret+7, 3);
              // WS10076S strcpy(resource_type+3, NULL);             //
              resource_type[3] = NULL_CHAR;              // WS10076S //
           }
           else
           {
              // WS10076S strcpy(h->rule_type, "A");                 //
              h->rule_type = 'A';                        // WS10076S //
              strncpy(resource_type, "DSN", 3);
              // WS10076S strcpy(resource_type+3, NULL);             //
              resource_type[3] = NULL_CHAR;              // WS10076S //
           }
           strcpy(h->res_type, resource_type);           // WS10076S //
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,      // WS10076S //
                  "rule type=|%c| - res name=|%s| - res type=|%s|",
                  h->rule_type, h->res_name, resource_type);
           *ret_rec_type = $KEY_LINE;     // set correct enum value  //
           return_rec_to_caller = TRUE;   // return record to caller //
           break;                         // break out of switch     */
           $KEY_CHECK(set_and_break);                    /* SELIG76S */
        }
        else if (strncmp (get_line_buffer, "$PREFIX(", 8) EQ 0)
        {
        /* SELIG76S Created a macro for these lines:
           *ret_rec_type = $PREFIX_LINE;  // set correct enum value  //
           return_rec_to_caller = TRUE;   // return record to caller //
           break;                         // break out of switch     */
           $PREFIX_CHECK                                 /* SELIG76S */
        }

  /******************************************************************/
  /*   The get_line_buffer was not a $KEY or $PREFIX line so we now */
  /*   check whether it is a permission line (and if it is, we will */
  /*   return it and all of its continuation lines to the caller).  */
  /*   If it is not a permission line, we simply ignore it and go   */
  /*   back up to read another line.                                */
  /******************************************************************/

        else
        {
          rc = Is_This_A_Perm_Line(get_line_buffer,
                                   h->rule_type,
                                   caller_code,
                                   &is_perm,             /* WS10076N */
                                   admin_params);
          if (rc EQ ESA_FATAL)                           /* WS10076S */
             goto exit;                                  /* WS10076S */
         /* WS10076N if (rc EQ FALSE)  * it is not a permission line */
          if (is_perm EQ FALSE) /* not a permission line *  WS10076N */
          {
             /*
             if (want_diag5)                              /* WS10084 @/
             ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
                             "not a permission line");
             */
             ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                             "not a permission line");
             continue;
          };
          /* WS10076N
          if (rc EQ TRUE)       * it is a permission line so call *
                                * a rtn to get the entire perm'n  *
          { */

           /*  it is a permission line so call */
           /*  a rtn to get the entire perm'n  */
           /*
           if (want_diag5)                                /* WS10084 @/
             ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
                             "Yes a permission line");
           */
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "yes a permission line");
           rc = Perm_Continuation_Handler(caller_code,
                           /* BS10111     get_line_ptr,       */
                                          h->p_ctsaruh,   /* BS10111 */
                           /* BS10105     function,           */
                           /* BS10105  */ get_type,
                           /* BS10111     inp_desc_blk,       */
                                          p_ruob,         /* BS10111 */
                                          &(h->get_line_handle),
                                          get_line_buffer,
                                          h->prev_line_read,
                                          h->rule_type,
                                          complete_perm_area,
                                          sizeof(complete_perm_area),
                                          admin_params);

           /*
           if (want_diag5)                                /* WS10084 @/
             ESA_DIAG_printf(PLT_COMP_PERMISSION,  0,
               "Perm_Continuation_Handler rc = %d", rc);
           */
           if (rc EQ ESA_OK)
           {
             strcpy(get_line_buffer, complete_perm_area);
             *ret_rec_type = PERMISSION_LINE;/* set correct enum value*/
             ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "permission line returned: |%s|", get_line_buffer);
             return_rec_to_caller = TRUE; /* return record to caller */
             break;                       /* break out of switch     */
           }
           else
           {
              /* WS10076S Replace this message with another message
                          that contains more useful information
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,component,
                      func, "Perm_Continuation_Handler rtn error",
                      16, __LINE__);                               */
              /* * * * * * * * * WS10076S start  * * * * * * * * * */
              /* Use this new message.  It contains more info.     */
              sprintf(errmsg,
              "resname=%s restype=%s error=%s func=%s comp=%s stmt=%d",
              h->res_name, h->res_type,
              "Perm_Continuation_Handler rtn error",
              func, component, __LINE__);
              CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);
              /* * * * * * * * * WS10076S end  * * * * * * * * * * */
              rc = ESA_FATAL;
              goto exit;
           }
   /*     }      removed by WS10076N */
        }
      /* WS10078S The ANY_LINE request has been phased out
      case ANY_LINE:
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "caller requested ANY line");
        for (i=0; wanted_list[i].wanted_rec[0] NE NULL_CHAR; i++)
        {
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "i = %d - wanted_rec entry = |%s|",
                           i, wanted_list[i].wanted_rec);
           if (strncmp (get_line_buffer,
                        (char *) wanted_list[i].wanted_rec,
                        wanted_list[i].length) EQ 0)
           {
              set_and_break = FALSE;                     // SELIG76S //
              if (strncmp (get_line_buffer, "$KEY(", 5) EQ 0)
              {
              // SELIG76S Created a macro for these lines:
                 ret = strchr(get_line_buffer+5, ')'); // end of $KEY //
                 strncpy(h->res_name, get_line_buffer+5, // WS10076S //
                         ret-get_line_buffer+5);         // WS10076S //
                 if (strncmp(ret+1, " TYPE(", 6) EQ 0) // rule type?  //
                 {
                    // WS10076S strcpy(h->rule_type, "R");           //
                    h->rule_type = 'R';                  // WS10076S //
                    strncpy(resource_type, ret+7, 3);
                    // WS10076S strcpy(resource_type+3, NULL);       //
                    resource_type[3] = NULL_CHAR;        // WS10076S //
                 }
                 else
                 {
                    // WS10076S strcpy(h->rule_type, "A");           //
                    h->rule_type = 'A';                  // WS10076S //
                    strncpy(resource_type, "DSN", 3);
                    // WS10076S strcpy(resource_type+3, NULL);       //
                    resource_type[3] = NULL_CHAR;        // WS10076S //
                 }
                 strcpy(h->res_type, resource_type);     // WS10076S //
                 ESA_DIAG_printf(PLT_COMP_PERMISSION, 17, //WS10076S //
                  "rule type=|%c| - res name=|%s| - res type=|%s|",
                  h->rule_type, h->res_name, resource_type);         //
                 $KEY_CHECK(set_and_break);              // SELIG76S //
              }
              *ret_rec_type = wanted_list[i].type;
                                           // set correct enum value  //
              return_rec_to_caller = TRUE; // return record to caller //
              break;                       // break out of for loop   //
           }
        }
        if (return_rec_to_caller EQ TRUE)
           break;                          // break out of switch     //

        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "no wanted_list.wanted_rec match");

  ********************************************************************
  **   The get_line_buffer did not match any wanted_list entry. We  **
  **   now check whether it is a permission line (and if it is, we  **
  **   will return it and all of its continuation lines to the      **
  **   caller). If it is not a permission line, we simply ignore it **
  **   and go back up to read another line.                         **
  ********************************************************************

        rc = Is_This_A_Perm_Line(get_line_buffer,
                                 h->rule_type,
                                 caller_code,
                                 &is_perm,             // WS10076N //
                                 admin_params);
        if (rc EQ ESA_FATAL)                           // WS10076S //
           goto exit;                                  // WS10076S //
       // WS10076N if (rc EQ FALSE)  * it is not a permission line //
        if (is_perm EQ FALSE) // not a permission line *  WS10076N //
        {
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "not a permission line");
           continue;
        };
        // WS10076N - this is is not needed
        if (rc EQ TRUE)       * it is a permission line so call *
                              * a rtn to get the entire perm'n  *
        {  //

        // it is a permission line so call //
        // a rtn to get the entire perm'n  //
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                         "yes a permission line");
         memset(h->prev_line_read, 0X00, sizeof(h->prev_line_read));
         rc = Perm_Continuation_Handler(caller_code,
                                        get_line_ptr,
                                        function,
                                        inp_desc_blk,
                                        &(h->get_line_handle),
                                        get_line_buffer,
                                        h->prev_line_read,
                                        h->rule_type,
                                        complete_perm_area,
                                        sizeof(complete_perm_area),
                                        admin_params);

         if (rc EQ ESA_OK)
         {
            strcpy(get_line_buffer, complete_perm_area);
            *ret_rec_type = PERMISSION_LINE;//set right enum value//
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "permission line returned: |%s|", get_line_buffer);
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "prev line read: |%s|", h->prev_line_read);
            return_rec_to_caller = TRUE; // return record to caller //
            break;                       // break out of switch     //
         }
         else
         {
            // WS10076S Replace this message with another message
                        that contains more useful information
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, "Perm_Continuation_Handler rtn error",
                    16, __LINE__);                                 //
            // * * * * * * * * WS10076S start  * * * * * * * * * * //
            // Use this new message.  It contains more info.       //
            sprintf(errmsg,
             "resname=%s restype=%s error=%s func=%s comp=%s stmt=%d",
             h->res_name, h->res_type,
             "Perm_Continuation_Handler rtn error",
             func, component, __LINE__);
            CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);
            // * * * * * * * * WS10076S end  * * * * * * * * * * * //
            rc = ESA_FATAL;
            goto exit;
         }
        //  }   removed by WS10076N + ANY_LINE removed by WS10078S */
      default:
        /* WS10076S Replace this message with another message
                    that contains more useful information
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      func, "req_rec_type incorrect",
                      16, __LINE__);                                 */
        /* * * * * * * * * * * * WS10076S start  * * * * * * * * * * */
        /* Use this new message.  It contains more info.             */
        sprintf(errmsg,
           "resname=%s restype=%s error=%s func=%s comp=%s stmt=%d",
           h->res_name, h->res_type,
           "req_rec_type incorrect", func, component, __LINE__);
        CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);
        /* * * * * * * * * * * * WS10076S end  * * * * * * * * * * * */
        rc = ESA_FATAL;
        goto exit;
    }; /* end of switch */

    if ( (return_rec_to_caller)  OR
       /*(return_role_to_caller) OR                          WS10084 */
         (end_of_user_condition) )
       break;                       /* break out of while(TRUE) loop */

  } /* end of while (TRUE) LOOP */

  if (return_rec_to_caller)
  {
     /* WS10076S Change the following line to the next line
     if (strlen(get_line_buffer) LE rule_record_len)                 */
     /* WS10078S Changed variable name
     if (strlen(get_line_buffer) LT rule_record_len)      // WS10076S*/
     if (strlen(get_line_buffer) LT return_buffer_len)    /* WS10078S*/
     {
        /* WS10078S Changed variable name
        strcpy(rule_record, get_line_buffer);
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "rule record returned: |%s|", rule_record);  */
        strcpy(return_buffer, get_line_buffer);          /* WS10078S */
        /*
        if (want_diag5)                                   /* WS10084 @/
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,          /* WS10084 @/
                        "rule record returned: |%s|", return_buffer);
        */
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,          /* WS10078S */
                        "rule record returned: |%s|", return_buffer);
        rc = ESA_OK;
        goto exit;
     }
     else
     {
        /* WS10076S Replace this message with another message
                    that contains more useful information
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                func, "Get_Rule_Record output buffer too small",
                16, __LINE__);                                       */
        /* * * * * * * * * * * * WS10076S start  * * * * * * * * * * */
        /* Use this new message.  It contains more info.             */
        snprintf(errmsg, sizeof(errmsg)-1,
  "buffer too small name=%s type=%s func=%s comp=%s stmt=%d buffer=%s",
         h->res_name, h->res_type,
         func, component, __LINE__, get_line_buffer);
        CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);
        /* * * * * * * * * * * * WS10076S end  * * * * * * * * * * * */

        rc = ESA_FATAL;
        goto exit;
     }
  }


  /* WS10084
  if (return_role_to_caller)                            /* WS10078S @/
  {                                                     /* WS10078S @/
     ESA_DIAG_printf(PLT_COMP_XREF, 6,                  /* WS10078S @/
              "ROLES returned: |%s|", return_buffer);   /* WS10078S @/
     rc = ESA_OK;                                       /* WS10078S @/
     goto exit;                                         /* WS10078S @/
  }                                                     /* WS10078S @/
    WS10084 */

  if (end_of_user_condition)
  {
     /*
     if (want_diag5)
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,            /* WS10084 @/
                     "end of user encountered");
     */
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "end of user encountered");
     rc = ESA_WARN; /* all done processing this LID */
     goto exit;
  }


  exit:
  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, rc);
  return rc;
}


/******************************************************************
 * Procedure Name: Is_This_A_Perm_Line
 ******************************************************************
 * Description   : This routine decides whether the input line passed
 *                 to it is a permission line or the first one of
 *                 several permission lines.
 *
 * Input         : input line
 *                 rule type ("A" or "R")
 *                 caller code: ACFRPTRX or LIST RULES
 * Output        : is_perm = TRUE / FALSE
 * Return Value  : ESA_OK or ESA_FATAL
 ******************************************************************/
/* WS10076N
static int Is_This_A_Perm_Line(char                 * get_line_buffer,*/
static ESA_RC Is_This_A_Perm_Line(                        /* WS10076N */
                               char                 * get_line_buffer,
 /* WS10076S char * -> char */ char                   rule_type,
                               char                 * caller_code,
                /* WS10076N */ int                  * is_perm,
                               ADMIN_PARAMS_rec_typ * admin_params)
{
  static char func[] = "Is_This_A_PERM_Line";

  /*WS10076N int      This_Is_A_Perm_Line, i;   */
  int      i = 0;                                         /* WS10076N */
  ESA_RC   rc = ESA_OK;
  void   * ptr;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 2, func);

  /* WS10076N This_Is_A_Perm_Line = FALSE;   */

  /*** *** *** *** *** *** * WS10076S start * *** *** *** *** *** ***/
  /* WS10084
  if ((strcmp(caller_code, "ACFRPTRX")   NE 0) AND
      (strcmp(caller_code, "LIST RULES") NE 0))              WS10084  */
  if (strcmp(caller_code, "LIST RULES") NE 0)             /* WS10084  */
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "invalid input caller_code parameter",
                   16, __LINE__);
     /* WS10076N return ESA_FATAL;   */
     rc = ESA_FATAL;                                      /* WS10076N */
     goto exit;                                           /* WS10076N */
  };
  /*** *** *** *** *** *** * WS10076S end *** *** *** *** *** *** ***/

  if (is_perm EQ NULL)                                    /* WS10076N */
  {                                                       /* WS10076N */
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,       /* WS10076N */
                   component, func,                       /* WS10076N */
                   "invalid input is_perm parameter",     /* WS10076N */
                   16, __LINE__);                         /* WS10076N */
     rc = ESA_FATAL;                                      /* WS10076N */
     goto exit;                                           /* WS10076N */
  };                                                      /* WS10076N */

  *is_perm = FALSE;                                       /* WS10076N */

  /******************************************************************/
  /*   Permissions come in several 'flavors' depending on whether   */
  /*   they are access or resource rule permissions, or they come   */
  /*   from ACFRPTRX output or LIST RULE output, or their actual    */
  /*   content. Here are the possibilities (1 & 2 are most common): */
  /*   1) UID(uid) - resource - any output format                   */
  /*   2) resmask UID(uid) - access / resource - any output format  */
  /*   3) resmask hyphen - access / resource - ACFRPTRX             */
  /*   4) resmask vol(vol) UID(uid) - access - any output format    */
  /*   5) resmask vol(vol) hyphen - access - ACFRPTRX               */
  /*                                                                */
  /*   Please note that resmask is required for access rules only   */
  /*   and the volume parameter can only be specified on access     */
  /*   rules.  Also, the hyphen (permission continuation character) */
  /*   only appears on the ACFRPTRX output format.                  */
  /*                                                                */
  /*   When we began supporting Roles, this routine was    WS10078S */
  /*   modified to support the ROLE(role) and USER(user)   WS10078S */
  /*   parameters exactly as we previously supported the   WS10078S */
  /*   UID(uid) parameter.                                 WS10078S */
  /*                                                                */
  /******************************************************************/

  if (strlen(get_line_buffer) LT 7)  /* minimum: bUID(*) */
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "line too small - not perm line");
     goto exit;  /* This_Is_A_Perm_Line field initialized to FALSE */
  }

  /* WS10076S Change the following statement
  if ( (strncmp(get_line_buffer,   " ", 1) NE 0) OR
       (strncmp(get_line_buffer+1, " ", 1) EQ 0) )                   */
  if ( (get_line_buffer[0] NE ' ') OR                    /* WS10076S */
       (get_line_buffer[1] EQ ' ') )                     /* WS10076S */
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "line not b/nb - not perm line");
     goto exit;  /* This_Is_A_Perm_Line field initialized to FALSE */
  }

  /* WS10076N if (strncmp(rule_type, "R", 1) EQ 0)                   */
  if (rule_type EQ 'R')                                  /* WS10076S */
     /* WS10078S The next line replaced with the next 3 lines
     if (strncmp(get_line_buffer+1, "UID(", 4) EQ 0)  // case 1 */
     if ( (strncmp(get_line_buffer+1, "UID(", 4) EQ 0)  OR  /* case 1 */
          (strncmp(get_line_buffer+1, "ROLE(", 5) EQ 0) OR  /* case 1 */
          (strncmp(get_line_buffer+1, "USER(", 5) EQ 0) )   /* case 1 */
     {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "case 1 - yes perm line");
        goto return_true;
     };

  /* WS10076S Change the next statement
  for(i=1;((strncmp(get_line_buffer+i,NULL_CHAR,1) NE 0)//skip resmask//
             AND
           (strncmp(get_line_buffer+i, " ", 1)   NE 0) ); i++);      */
  for(i=1; ( (get_line_buffer[i] NE NULL_CHAR) AND       /* WS10076S */
             (get_line_buffer[i] NE ' ')  ); i++);       /* WS10076S */

  /* WS10076S Change the next statement
  if (strncmp(get_line_buffer+i, " ", 1) EQ 0)                       */
  if (get_line_buffer[i] EQ ' ')                         /* WS10076S */
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "reached blank char - |%s|", get_line_buffer+i);

  /* WS10076S Change the next statement
  if (strncmp(get_line_buffer+i, NULL_CHAR, 1) EQ 0)                 */
  /* WS10076N
  if (get_line_buffer+i EQ NULL_CHAR)                   * WS10076S * */
  if (get_line_buffer[i] EQ NULL_CHAR)                   /* WS10076N */
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "reached null char - not perm line");
     goto exit;  /* This_Is_A_Perm_Line field initialized to FALSE */
  }

  /* WS10078S The next line replaced with the next 3 lines
  if (strncmp(get_line_buffer+i+1, "UID(", 4) EQ 0)  // case 2 */
  if ( (strncmp(get_line_buffer+i+1, "UID(", 4) EQ 0)  OR /* case 2 */
       (strncmp(get_line_buffer+i+1, "ROLE(", 5) EQ 0) OR /* case 2 */
       (strncmp(get_line_buffer+i+1, "USER(", 5) EQ 0) )  /* case 2 */
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "case 2 - yes perm line");
     goto return_true;
  }

  /* WS10084
  if (strcmp(caller_code, "ACFRPTRX") EQ 0)
     if (strncmp(get_line_buffer+i, " -", 2) EQ 0) /* case 3 @/
     {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "case 3 - yes perm line");
        goto return_true;
     }
     WS10084 */

  /* WS10076N if (strcmp(rule_type, "A") EQ 0)   */
  if (rule_type EQ 'A')                                  /* WS10076S */
     if (strncmp(get_line_buffer+i+1, "VOL(", 4) EQ 0)  /* case 4 */
     {
        ptr = strchr(get_line_buffer+i+5,')');
        if ( (strncmp(ptr+1, " UID(", 5) EQ 0)  OR      /* case 4 */
/*WS10078S*/ (strncmp(ptr+1, " ROLE(", 6) EQ 0) OR      /* case 4 */
/*WS10078S*/ (strncmp(ptr+1, " USER(", 6) EQ 0) OR      /* case 4 */
             (strncmp(ptr+1, " - ",   3) EQ 0) )        /* case 5 */
        {
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "case 4 or 5 - yes perm line");
           goto return_true;
        }
     }
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "fell thru - not perm line");
  goto exit;  /* This_Is_A_Perm_Line field initialized to FALSE */

  return_true:
  /*WS10076N This_Is_A_Perm_Line = TRUE;  */
    *is_perm = TRUE;                                      /* WS10076N */

  exit:
    /* WS10076N
    ESA_DIAG_exit(PLT_COMP_PERMISSION, 2, func, This_Is_A_Perm_Line);
    return This_Is_A_Perm_Line;                                       */

    if (rc EQ ESA_OK)                                     /* WS10076N */
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 2,             /* WS10076N */
                      "is_perm = %d", *is_perm);          /* WS10076N */

    ESA_DIAG_exit(PLT_COMP_PERMISSION, 2, func, rc);      /* WS10076N */
    return rc;                                            /* WS10076N */
}


/******************************************************************
 * Procedure Name: Perm_Continuation_Handler
 ******************************************************************
 * Description   : This routine decides whether the input line
 *                 passed (which we know is a permission line)
 *                 has a continuation line, and if it does,
 *                 passes back all continuation lines concatenated
 *                 to each other.
 *
 * Input         : caller code: ACFRPTRX or LIST RULES
 *                 pointer to get_line_rtn
 *                 function: get or free
 *                 pointer to input descriptor block
 *                 get line handle
 *                 input line
 *                 actual line length
 *                 previous line read
 *                 rule type ("A" or "R")
 *                 complete permission area
 *                 complete permission area length
 * Output        : none
 * Return Value  : TRUE or FALSE
 ******************************************************************/
static int Perm_Continuation_Handler(char         * caller_code,
                       /* BS10111    GET_LINE_PTR   get_line_ptr,  */
                       /* BS10111 */ ASM_RTN_TYP  * p_ctsaruh,
                                     char         * function,
                       /* BS10111    void         * inp_desc_blk,  */
                       /* BS10111 */ char         * p_ruob,
                                     void         * get_line_handle,
                                     char         * input_buffer,
                                     char         * prev_line_read,
    /* WS10076S  char * -> char */   char           rule_type,
                                     char         * complete_perm_area,
                                     int       complete_perm_area_size,
                                ADMIN_PARAMS_rec_typ * admin_params)
{
  static char func[] = "Perm_Continuation_Handler";

  int      rc = ESA_OK;
  int      i;
  int      perm_area_too_small = FALSE;                  /* WS10076S */
  int      is_perm = FALSE;                               /* WS10076N */
  char     from[ACF2_MAX_PERMISSN_SIZE]; /* place for 5 (* 133) lines */
  char     get_line_buffer[ACF2_MAX_PERMISSN_SIZE];
  /* BS10111 char     errmsg[125];     */
  char     errmsg[170];                                   /* BS10111 */
  int      dbglvl = 0;                                    /* BS10111 */
  int      int_rc = 0;                                    /* BS10111 */

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 2, func);

  dbglvl = (int)ESA_DIAG_get_debug_level(                 /* BS10111 */
                                 PLT_COMP_PERMISSION);    /* BS10111 */
  if ( dbglvl GT 0   AND   dbglvl NE 77)                  /* BS10111 */
    dbglvl = 1;                                           /* BS10111 */

  /*** *** *** *** *** *** * WS10076S start * *** *** *** *** *** ***/
  /* WS10084
  if ((strcmp(caller_code, "ACFRPTRX")   NE 0) AND
      (strcmp(caller_code, "LIST RULES") NE 0))              WS10084 */
  if (strcmp(caller_code, "LIST RULES") NE 0)             /* WS10084 */
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "invalid input caller_code parameter",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  /*** *** *** *** *** *** * WS10076S end *** *** *** *** *** *** ***/

  /******************************************************************/
  /* The input_buffer field is definitely a permission or the       */
  /* first part of a permission. To determine this and to get the   */
  /* entire permission, we must check whether we are processing the */
  /* ACFRPTRX report or the LIST RULES report.                      */
  /******************************************************************/

  memset(complete_perm_area, 0X00, sizeof(complete_perm_area));

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "caller code: %s", caller_code);

  /* WS10076N if (complete_perm_area_size GE strlen(input_buffer)) */
  if (complete_perm_area_size GT strlen(input_buffer)) /* WS10076N */
     strcpy(complete_perm_area, input_buffer);
  else
     /* WS10076S goto perm_area_too_small;   */
  {                                                      /* WS10076S */
     strncpy(complete_perm_area, input_buffer,           /* WS10076S */
             sizeof(complete_perm_area)-1);              /* WS10076S */
     perm_area_too_small = TRUE;                         /* WS10076S */
     goto exit;                                          /* WS10076S */
  }                                                      /* WS10076S */
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "complete perm area = |%s|", complete_perm_area);
  /* WS10084
  if (strcmp(caller_code, "ACFRPTRX") EQ 0)
  /*****************************************************************@/
  /* Check if the line ends with a ' - '. If not, just return the   @/
  /* permission line to the caller. If yes, get the next line,      @/
  /* concatenate it to the existing permission line, and go back up @/
  /* to the top of the loop.                                        @/
  /*****************************************************************@/
  {
     while (TRUE)
     {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "strlen(complete perm area) = %d",
                        strlen(complete_perm_area));
        for(i=strlen(complete_perm_area)-1;/*stop at last non-blk char@/
                     complete_perm_area[i] EQ ' '; i--);
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                 "reached non-blank char - |%s|", complete_perm_area+i);

        if (complete_perm_area[i] NE '-') /* no cont'n @/
        {
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "no hyphen found");
           goto exit; /* return complete_perm_area to caller @/
        }                                                    @
        else if (complete_perm_area[i] EQ '-') /* yes cont'n @/
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                              "hyphen found");
              /* WS10078SG Removed for performance purposes
              memset(get_line_buffer, 0X00, sizeof(get_line_buffer));@/
              /* BS10111 - replced by call to CTSARUH
              rc = (get_line_ptr)(function,
                                  inp_desc_blk,
                                  get_line_handle,
                                  get_line_buffer,
                                  sizeof(get_line_buffer),
                                  admin_params);  @/
              int_rc = (*(p_ctsaruh))(function,           /* BS10111 @/
                                 get_line_handle,         /* BS10111 @/
                                 p_ruob,                  /* BS10111 @/
                                 get_line_buffer,         /* BS10111 @/
                                 NULL,                    /* BS10111 @/
                                 sizeof(get_line_buffer), /* BS10111 @/
                                 NULL,                    /* BS10111 @/
                                 &dbglvl,                 /* BS10111 @/
                                 CTSARUH_DBGTYPE_PRTDBG,  /* BS10111 @/
                                 errmsg,                  /* BS10111 @/
                                 sizeof(errmsg),          /* BS10111 @/
                                 NULL);                   /* BS10111 @/
              /* BS10111 if (rc EQ ESA_EOF)  @/
              if (int_rc EQ 4)                            /* BS10111 @/
              {                                           /* BS10111 @/
                 rc = ESA_EOF;                            /* BS10111 @/
                 goto exit;
              }                                           /* BS10111 @/
              /* BS10111 else if (rc NE ESA_OK)  @/
              else if (int_rc GT 4)   /* if not OK or EOF BS10111 @/
               {
                  /* WS10076S Replace this message with another message
                              that contains more useful information
                  sprintf(errmsg,"get_line rtn(GETxxxx) failed");
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func, errmsg, 16, __LINE__);    */
                  /* * * * * * * * * * WS10076S start  * * * * * * * */
                  /* Use this new message.  It contains more info.   */
                  /* BS10111  - replace with the message returned from
                                ctsaruh
                  sprintf(errmsg,
                 "get_line rtn(GETxxxx) failed func=%s comp=%s stmt=%d",
                   func, component, __LINE__);
                  CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest,errmsg);
                  /@ * * * * * * * * * WS10076S end  * * * * * * * * @/
                     end of rpelaced code  - BS1011  @/
                 if (errmsg[0] NE NULL_CHAR)              /* BS10111 @/
                   CTSAMSG_print(ERR_TL_STRING,           /* BS10111 @/
                              msgs, NULL, dest, errmsg);  /* BS10111 @/
                 sprintf(errmsg,                          /* BS10111 @/
                      "CTSARUH - %s failed with rc=%d.",  /* BS10111 @/
                      function, int_rc);                  /* BS10111 @/

                 CTSAMSG_print(ERR_INTERNAL2,             /* BS10111 @/
                               msgs, NULL, dest,          /* BS10111 @/
                               component, func, errmsg,   /* BS10111 @/
                               int_rc, __LINE__);         /* BS10111 @/
                  rc = ESA_FATAL;
                  goto exit;
               };
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                       "get_line_buffer: |%s|", get_line_buffer);
              /* WS10076S Replace the next statement
              strncpy(complete_perm_area+i, NULL_CHAR, 1); // change
                                                      hyphen to null @/
              complete_perm_area[i] = NULL_CHAR;         /* WS10076S @/
              /* WS10076S Change next statement
              for(i=0; (strncmp(get_line_buffer+i, " ", 1) EQ 0); i++);
                                                                     @/
              for(i=0; get_line_buffer[i] EQ ' '; i++);  /* WS10076S @/
                                    /* skip to actual continuation @/
              strcpy(from, get_line_buffer+i); /* permission contin'n @/
              /*  WS10076S + WS10076N = start @/
              /*
              if (complete_perm_area_size - strlen(complete_perm_area)
                 GE strlen(from))
                 strcat(complete_perm_area, from);
              else
                 goto perm_area_too_small;
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                              "complete perm area after strcat = |%s|",
                              complete_perm_area);  @/
              if (complete_perm_area_size - strlen(complete_perm_area)
                 GT strlen(from))
              {
                 strcat(complete_perm_area, from);
                 ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                          "complete perm area after strcat = |%s|",
                          complete_perm_area);
              }
              else
              {
                 perm_area_too_small = TRUE;
                 goto exit;
              }
              /*  WS10076S + WS10076N = end   @/
              continue;
           }
     } /* end of while (TRUE) LOOP @/
  } /* end of caller code ACFRPTRX code @/
    WS10084 */


  if (strcmp(caller_code, "LIST RULES") EQ 0)
  /******************************************************************/
  /* Get the next line and call the Is_This_A_Perm_Line routine. If */
  /* it is a permission line, save the line in the prev_line_read   */
  /* field and return the complete_perm_area field to the caller.   */
  /* If it is not a permission line, check if it is a ACF75051      */
  /* line. If it is a ACF75051 line, return the complete_perm_area  */
  /* to the caller. If it is not a ACF75051 line, it is a contin'n  */
  /* line so concatenate it to complete_perm_area field and go back */
  /* up to the top of the loop.                                     */
  /******************************************************************/
  {
     while (TRUE)
     {
        /* WS10078SG Removed for performance purposes
        memset(get_line_buffer, 0X00, sizeof(get_line_buffer));      */
        /*  BS10111  - replace this call with a call to CTSARUH
        rc = (get_line_ptr)(function,
                            inp_desc_blk,
                            get_line_handle,
                            get_line_buffer,
                            sizeof(get_line_buffer),
                            admin_params);
          end of replaced code - BS10111 */
        int_rc = (*(p_ctsaruh))(function,                 /* BS10111 */
                           get_line_handle,               /* BS10111 */
                           p_ruob,                        /* BS10111 */
                           get_line_buffer,               /* BS10111 */
                           NULL,                          /* BS10111 */
                           sizeof(get_line_buffer),       /* BS10111 */
                           NULL,                          /* BS10111 */
                           &dbglvl,                       /* BS10111 */
                           CTSARUH_DBGTYPE_PRTDBG,        /* BS10111 */
                           errmsg,                        /* BS10111 */
                           sizeof(errmsg),                /* BS10111 */
                           NULL);                         /* BS10111 */
        /* BS10111 if (rc EQ ESA_EOF)  */
        if (int_rc EQ 4)                                  /* BS10111 */
        {                                                 /* BS10111 */
           rc = ESA_EOF;                                  /* BS10111 */
           goto exit;
        }                                                 /* BS10111 */
        /* BS10111 else if (rc NE ESA_OK)  */
        else if (int_rc GT 4)   /* if not OK or EOF          BS10111 */
         {
            /* WS10076S Replace this message with another message
                        that contains more useful information
            sprintf(errmsg,"get_line rtn(GETxxxx) failed");
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                          func, errmsg, 16, __LINE__);               */
            /* * * * * * * * * * * * WS10076S start  * * * * * * * * */
            /* Use this new message.  It contains more information.  */
            /* BS10111 - replace with the message returned from ctsaruh
            sprintf(errmsg,
                 "get_line rtn(GETxxxx) failed func=%s comp=%s stmt=%d",
                 func, component, __LINE__);
            CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest,errmsg);
            /@ * * * * * * * * * * * WS10076S end  * * * * * * * * * @/
               end of replaced code   - BS10111 */
            if (errmsg[0] NE NULL_CHAR)                   /* BS10111 */
              CTSAMSG_print(ERR_TL_STRING,                /* BS10111 */
                         msgs, NULL, dest, errmsg);       /* BS10111 */
            sprintf(errmsg,                               /* BS10111 */
                 "CTSARUH - %s failed with rc=%d.",       /* BS10111 */
                 function, int_rc);                       /* BS10111 */

            CTSAMSG_print(ERR_INTERNAL2,                  /* BS10111 */
                          msgs, NULL, dest,               /* BS10111 */
                          component, func, errmsg,        /* BS10111 */
                          int_rc, __LINE__);              /* BS10111 */
            rc = ESA_FATAL;
            goto exit;
         };
  /******************************************************************/
  /* The buffer that was just returned may have a continuation line */
  /* (which will be concatenated to this line shortly). Continue    */
  /* processing this line by checking if this is a permission line, */
  /* etc.                                                           */
  /******************************************************************/
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "get_line_buffer: |%s|", get_line_buffer);

        rc = Is_This_A_Perm_Line(get_line_buffer,
                                 rule_type,
                                 caller_code,
                                 &is_perm,               /* WS10076N */
                                 admin_params);
        if (rc EQ ESA_FATAL)                             /* WS10076S */
          goto exit;                                     /* WS10076S */
        /* WS10076N if (rc EQ TRUE) /* it is a perm'n line so        */
        if (is_perm EQ TRUE) /* it is a perm'n line so   WS10076N    */
                             /* save the line and return the perm'n  */
        {
           strcpy(prev_line_read, get_line_buffer);
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "prev_line_read: |%s|", prev_line_read);
           rc = ESA_OK;
           goto exit; /* return complete_perm_area to caller */
        }
        else /* it is not a permission line */
        {
          if (strncmp(get_line_buffer, "ACF75051", 8) EQ 0)
          {
           rc = ESA_OK;
           goto exit; /* return complete_perm_area to caller */
          }
          else /* it is a permission continuation line */
           /* WS10076S + WS10076N - start */
           /*
           if (complete_perm_area_size - strlen(complete_perm_area) GE
               strlen(get_line_buffer))
             strcat(complete_perm_area, get_line_buffer);
           else
               goto perm_area_too_small;
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                          "complete perm area after strcat = |%s|",
                          complete_perm_area);
           continue;
           */
           if (complete_perm_area_size - strlen(complete_perm_area) GT
               strlen(get_line_buffer))
           {
              strcat(complete_perm_area, get_line_buffer);
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                       "complete perm area after strcat = |%s|",
                       complete_perm_area);
           }
           else
           {
              perm_area_too_small = TRUE;             /* WS10076S */
              goto exit;                              /* WS10076S */
           }
        }
     } /* end of while (TRUE) LOOP */
  } /* end of caller code LIST RULES code */

  goto exit;                                             /* WS10076S */

  /* WS10076S perm_area_too_small:    */
  exit:
  if (perm_area_too_small EQ TRUE)                       /* WS10076S */
  {                                                      /* WS10076S */
     /* WS10076S Replace this message with another message
                 that contains more useful information
     sprintf(errmsg,"Permission area not large enough");
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, errmsg, 16, __LINE__);                      */
     /* * * * * * * * * * * * * WS10076S start   * * * * * * * * * * */
     /* Use this new message.  It contains more info.                */
     snprintf(errmsg, sizeof(errmsg)-1,
          "permission area too small func=%s comp=%s stmt=%d buffer=%s",
          func, component, __LINE__, complete_perm_area);
     CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
         "complete_perm_area when area too small: |%s|",
         complete_perm_area);
     /* * * * * * * * * * * * * WS10076S end * * * * * * * * * * * * */
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
         "get_line_buffer when area too small: |%s|", get_line_buffer);
     rc = ESA_SKIP;
  }                                                      /* WS10076S */
  /* WS10076S goto exit;   */

  /* WS10076S exit:   */
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
        "complete_perm_area upon exit: |%s|", complete_perm_area);
  ESA_DIAG_exit(PLT_COMP_PERMISSION, 2, func, rc);
  return rc;
}

/* BS10108 - the code below was moved to CTSBSRV because it handles
              XREF records and not permissions.
/@                 start WS10078T                                @/
/@*****************************************************************
 * Procedure Name: XREF_Block_Build
 ******************************************************************
 * Description   : Build 2 XREF blocks of roles & role groups  or
 *                 sources & source groups.
 *                 Return either the shorter (BLDSHORT) or both
 *                 (BLD2). BLD2 is for future use.
 *                 This routine is called for account aggregation
 *                 and for SYNC user processing at the start of
 *                 the transaction and the output XREF block is
 *                 used to find out for each role or source
 *                 defined for a user whether it is a basic element
 *                 or a group element.
 * The output of the LIST LIKE(-) command has the following format.
 * Note that after the TOTAL line , there is always a whole spaces line.
 *  TLVB / TSROL1 LAST CHANGED BY TLVTS ON 03/10/20-15:26
 *                       EXCLUDE(TLVTS61 TLVTS62 TLVTS63 TLVTS64
 *                       TLVTS81 TLVTS82 TLVTS83 TLVTS84 TLVTS85
 *                       TLVTS97)
 *                       INCLUDE(TLVTS TLVTS1 TLVTS11 TLVTS12 TLV
 *                       TLVTS31 TLVTS32 TLVTS33 TLVTS34 TLVTS35
 *                       TLVTS6-) ROLE
 * TOTAL RECORD LENGTH= 764 BYTES, 18 PERCENT UTILIZED
 *
 * If the output is a GROUP then the word GROUP will apear after the
 * EXCLUDE(...)
 * Input         : function:  BLDSHORT - return the shorter list
 *                            BLD2     - return both blocks
 *                            TERM     - free the block(s)
 *                 XREFType : R-Roles reqested | S-Sources requested
 * Output        : Pointer to XREFBlk in pXREFBlk1
 *               : Pointer to XREFBlk in pXREFBlk2  (BLD2)
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_WARN  - nothing to return
 *                 ESA_FATAL - fatal error
 *****************************************************************@/
  ESA_RC XREF_Block_Build(
                 char                     * function,
                 XREF_REC_BLK_rec_ptr     * pXREFBlk1,
                 XREF_REC_BLK_rec_ptr     * pXREFBlk2,
                 char                       XREFType,
                 ADMIN_PARAMS_rec_typ     * admin_params)
 #define OUTPUT_AREA_LEN 16384
/@               XREFType is XREF_REC_TYPE_xxx                       @/
{
  static char func[] = "XREF_Block_Build";

  ESA_RC     rc = ESA_OK;
  ESA_RC     rcc = ESA_OK;
  char       errmsg[125];
  char       group = NULL_CHAR;
  char       name[XREF_NAME_SIZE] = "";
  char       rectype[7] = "";
  char       * output_area = NULL;
  char       * p1      = NULL;
  char       * p2      = NULL;
  char       * j       = NULL;
  int        name_size = 0;
  int        ruob_len  = 0;
  int        xref_size = 0;
  int        num_names_group = 0;
  int        num_names_non_group = 0;
  char       * pnext_group = NULL;
  char       * pnext_non_group = NULL;
  int        output_area_len = OUTPUT_AREA_LEN;
  REXX@UTL_output_blk_rec_typ * pruob = NULL;
  Get_XREF_Rec_Handle * h = NULL;
  XREF_REC_BLK_rec_typ    * pXREFBlk_group = NULL;
  XREF_REC_BLK_rec_typ    * pXREFBlk_non_group = NULL;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);

  if (pXREFBlk1 EQ NULL)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
             func, "XREFBlk1 pointer NULL",
             16, __LINE__);
     rc = ESA_FATAL;
     goto xref_bld_exit;
  }

  if (strcmp(function, "TERM") EQ 0)
  {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "Processing TERM request");
     if (
           (strncmp((*pXREFBlk1)->eyec,ROLE_BLOCK_EYEC,4) NE 0)
           AND
           (strncmp((*pXREFBlk1)->eyec,SGP_BLOCK_EYEC,4) NE 0)
        )
     {
        sprintf(errmsg,
            "Invalid XREFBlk eye catcher = %4s",
            (*pXREFBlk1)->eyec);

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component,func,
                      errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     if (*pXREFBlk1 NE NULL)
        free(*pXREFBlk1);
     goto xref_bld_exit;
  }
  else if (strcmp(function, "BLDSHORT") NE 0)
  {
     sprintf(errmsg,
         "Invalid function parameter = %8s", function);

     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                   errmsg, 16, __LINE__);
     rc = ESA_FATAL;
     goto xref_bld_exit;
  }

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
                 "Processing BLDSHORT request. XREFType=%c",
                  XREFType);

  if (XREFType EQ XREF_REC_TYPE_ROLE)
     strcpy(rectype,"X(ROL)");
  else if (XREFType EQ XREF_REC_TYPE_SGP)
     strcpy(rectype,"X(SGP)");
  else
     {
        sprintf(errmsg,
            "Invalid XREFType = %c",
             XREFType);

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component,func,
                      errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto xref_bld_exit;
     };

  rc = ACF2_Cmd2Mem(rectype,
                    "-",
                    NULL,
                    &pruob,
                    PLT_COMP_XREF,
                    admin_params);

  ESA_DIAG_printf(PLT_COMP_XREF,2,
          "ACF2_Cmd2Mem for %s returned rc = %d  ruob = %p",
           rectype,rc, pruob);

  if (rc  NE ESA_OK)
  {
    rc = ESA_FATAL;   /@ Error message was already issued? @/
    goto xref_bld_exit;
  }

  /@   If nothing was returned - error.    @/
  if (pruob EQ NULL)
  {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                  "No output was returned by the ACF2 commands",
                  16, __LINE__);
    rc = ESA_FATAL;
    goto xref_bld_exit;
  }

  /@ allocate 2 XREF blocks          @/

  ruob_len = pruob->ruohdlen;
  xref_size =  sizeof(XREF_REC_BLK_rec_typ) + ruob_len/2;

  pXREFBlk_group = calloc(1, xref_size);

  if (pXREFBlk_group EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Area for XREF block1", xref_size);
    rc = ESA_FATAL;
    goto xref_bld_exit;
  };

  ESA_DIAG_printf(PLT_COMP_XREF,1,
          "Allocated pXREFBlk_group of size = %d at = %p",
           xref_size,pXREFBlk_group);
  pnext_group =   pXREFBlk_group->names;

  pXREFBlk_non_group = calloc(1, xref_size);

  if (pXREFBlk_non_group EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Area for XREF block2", xref_size);
    rc = ESA_FATAL;
    goto xref_bld_exit;
  };

  pnext_non_group =   pXREFBlk_non_group->names;
  ESA_DIAG_printf(PLT_COMP_XREF,1,
          "Allocated pXREFBlk_non_group of size = %d at = %p",
           xref_size,pXREFBlk_non_group);


  /@ initialize the 2 XREF blocks          @/
     pXREFBlk_non_group->group = XREF_REC_group_No;
     pXREFBlk_group->group = XREF_REC_group_Yes;
     pXREFBlk_non_group->num_names = 0;
     pXREFBlk_group->num_names = 0;

  if (XREFType EQ XREF_REC_TYPE_ROLE)
  {
     strncpy(pXREFBlk_group->eyec,ROLE_BLOCK_EYEC,4);
     strncpy(pXREFBlk_non_group->eyec,ROLE_BLOCK_EYEC,4);
     pXREFBlk_group->type = XREF_REC_TYPE_ROLE;
     pXREFBlk_non_group->type = XREF_REC_TYPE_ROLE;
  }
  else
  {
     strncpy(pXREFBlk_group->eyec,SGP_BLOCK_EYEC,4);
     strncpy(pXREFBlk_non_group->eyec,SGP_BLOCK_EYEC,4);
     pXREFBlk_group->type = XREF_REC_TYPE_SGP;
     pXREFBlk_non_group->type = XREF_REC_TYPE_SGP;
  }

  ESA_DIAG_printf(PLT_COMP_XREF, 2,
     "pXREFBlk_non_group -> %5s",pXREFBlk_non_group);


  ESA_DIAG_printf(PLT_COMP_XREF, 2,
     "pXREFBlk_group -> %5s",pXREFBlk_group);

  output_area = calloc(1, output_area_len);

  if (output_area EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Output area for Get_XREF_Record", output_area_len);
    rc = ESA_FATAL;
    goto xref_bld_exit;
  };

  do
   {

    ESA_DIAG_printf(PLT_COMP_XREF, 2,
     "Calling Get_XREF_Record");

     rc = Get_XREF_Record(
                "GETNEXT",
                &h,
                pruob,
                output_area,
                output_area_len,
                admin_params);


     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Get_XREF_Record rc = %d",
           rc);

     if (rc  NE ESA_OK)
     {
       break;
     }


     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Get_XREF_Record output area = %s",
           output_area);

   /@   extract the role|source name                              @/

     p1 = strstr(output_area, " LAST CHANGED");
     if (p1  EQ NULL)
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "LAST CHANGED not found in Get_XREF_Record output area");

        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     p2 = p1 - XREF_NAME_SIZE;
     for (j=p1-1; j GE p2; j--)
          {
            if (*j EQ ' ') break;  /@ break only from this for @/
          };

     if ((*j NE ' ') OR (j EQ (p1-1)) )
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
        "Could not locate a valid name p1=%p p2=%p(%9s) j=%p(%c)",
        p1,p2,p2,j,*j);

        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     name_size = p1 - j -1;

     if (name_size GT (XREF_NAME_SIZE - 1))
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
        "Could not locate a valid name p1=%p p2=%p j=%p name_size=%d",
        p1,p2,j,name_size);

        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     memset (name, 0X00, sizeof(name));
     strncpy(name,++j,name_size);

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "name = %s",
           name);

     p1 = strstr(output_area, " GROUP ");
     if (p1  EQ NULL)
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "GROUP not found, assuming non group");

        strcpy(pnext_non_group,name);
        pnext_non_group+=9 ;
        pXREFBlk_non_group->num_names+= 1;
     }
     else
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "GROUP found");

        strcpy(pnext_group,name);
        pXREFBlk_group->num_names+= 1;
        pnext_group+=9 ;
     }

   } while (rc EQ ESA_OK);

  ESA_DIAG_printf(PLT_COMP_XREF,2,
          "After while rc = %d",
           rc);

  ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Calling Get_XREF_Record TERM");

  rcc = Get_XREF_Record(
             "TERM",
             &h,
             pruob,
             output_area,
             output_area_len,
             admin_params);

  if (rcc NE ESA_OK)
  {
    sprintf(errmsg,
            "Get_XREF_Record TERM returned rc = %d",
            rcc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg, 12, __LINE__);
  };

  /@ * * WS10078S start * * @/

  rcc = ESA_CLI_del_RUOB(pruob,
                         admin_params);
  if (rcc NE ESA_OK)
  {
    sprintf(errmsg,
            "ESA_CLI_del_RUOB returned rc = %d  for ruob = %p",
            rcc, pruob);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg, 12, __LINE__);
  };

  pruob = NULL;


  /@ * * WS10078S end * * @/

  if (output_area NE NULL) free(output_area);
  if (rc EQ ESA_FATAL) goto xref_bld_exit;
  if (pXREFBlk_group EQ NULL) goto xref_bld_exit;
  rc = ESA_OK;

  if (pXREFBlk_non_group->num_names LT pXREFBlk_group->num_names)
  {
   ESA_DIAG_printf(PLT_COMP_XREF,2,
   "Shorter list is non group with pXREFBlk_non_group->num_names=%d",
    pXREFBlk_non_group->num_names);
   *pXREFBlk1 =  pXREFBlk_non_group;
   free(pXREFBlk_group);
  }
  else
  {
   ESA_DIAG_printf(PLT_COMP_XREF,2,
   "Shorter list is group with pXREFBlk_group->num_names=%d names",
    pXREFBlk_group->num_names);

   *pXREFBlk1 =  pXREFBlk_group;
   free(pXREFBlk_non_group);
  }

  xref_bld_exit:

  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;

}
 BS10108 - end of moved code.   */
/* BS10108 - Move Get_User_XROL to CTSBGUS                        */
/*
/@*****************************************************************
 * Procedure Name: Get_User_XROL   (based on Get_User_XSGP)
 ******************************************************************
 * Description   : Returns all LID's role connections.
 *                 Calls Get_Rule_Record to get all Roles as connections
 *                 based on RUOB/ACFRPTRX output.
 *                 Role names are returned in one string (with a null
 *                 terminator at the end) separated by a ';' delimiter
 *                 between role names.
 *                 For each role name in the returned string:
 *                 If previous role name was not a RoleGroup, call
 *                 XREF_Block_Find to look for the Role in the XREF
 *                 block and get its type (group or not group)
 *                 else (previous role name was a RoleGroup), we know
 *                 it's a RoleGroup as well.
 *                 Add the role name to Roles or RoleGroups addinfo per
 *                 its type.
 * Called by:      Get_User_XREFAndPermissions
 *
 * Input         : inputLID  - LID name ptr
 *                 lid_perm_handle
 *                 XREFBlk  - XREF_Block address
 * Output        : addinfo  - where to update Roles and/or RoleGroups
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_FATAL - fatal error
 *****************************************************************@/
ESA_RC Get_User_XROL(
          char                       * inputLID,
    /@    Get_Rule_Rec_Handle       ** get_rule_record_handle,  @/
          LID_PERM_handle_rec_typ    * lid_perm_handle,
          XREF_REC_BLK_rec_typ       * XREFBlk,
          ADDINFO_rec_ptr              addinfo,
          ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char func[] = "Get_User_XROL";

  ESA_RC                   rc = ESA_OK, rcc = ESA_OK; /@ WS10078KM @/
  ONE_FIELD_rec_ptr        r_pair = NULL;        /@ Role @/
  ONE_FIELD_rec_ptr        rg_pair = NULL;       /@ Role Groups @/
  ONE_FIELD_rec_ptr        pair = NULL;
  GET_LINE_PTR             get_line_ptr;
  IDB_GETRUOBLINE_rec_typ  input_desc_block;
  Permission_Record_Type   returned_record_type;
  RULE_TYPE_PERM_rec_typ * rule_type_perm_vec = NULL;
  char                     resource_type[4] = "";
  char                     ent_type[20] = "";           /@ WS10078ST @/
  char                   * role_name;
  char                     role_str[9] = "";
  char                     is_group = NULL_CHAR;
  int                      i;
  int                      int_rc;
  int                      group_found = FALSE;
  int                      r_full = FALSE;
  int                      rg_full = FALSE;
  char                     errmsg[100] = "";
  #define MAX_ROLES_AREA_SIZE   16384            /@ for user     @/
  char       role_record[MAX_ROLES_AREA_SIZE] = "";
  char       * role_record_end ;
  char  *space_pos;                               /@ WS10078A @/

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);

  /@
   *  Verify we have Roles and/or RoleGroups in addinfo
   @/

  r_pair  = ADDINFO_search("Roles",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs);
  rg_pair = ADDINFO_search("RoleGroups",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs);

  if (r_pair EQ NULL   AND   rg_pair EQ NULL)
  {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                 func, "No Roles/RoleGroups in addinfo",
        16, __LINE__);
    rc = ESA_FATAL;
    goto get_user_xrol_exit;
  };

  get_line_ptr = &ESA_CLI_get_RUOB_line;
  input_desc_block.blk = lid_perm_handle->lidra_vec[0].lidra;

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
         "Calling Get_Rule_Record requesting Roles");

  rc = Get_Rule_Record(
       "GETNEXT",
       &(lid_perm_handle->lidra_vec[0].get_rule_record_handle),
 /@    get_rule_record_handle,             @/
       get_line_ptr,
       &input_desc_block,
/@ WS10078SG ROLE_LINE,                                              @/
       ROLES_BLOCK,               /@ change enum value name WS10078SG@/
       sizeof(role_record),
       "ACFRPTRX",
       &returned_record_type,
       role_record,
       resource_type,
       admin_params);

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
              "Get_Rule_Record GET ROLE Linet_ruled rc = %d",
              rc);

  if (rc NE ESA_OK)
  {
    if (rc EQ ESA_WARN) /@ end_of_user indication @/
    {
       ESA_DIAG_printf(PLT_COMP_XREF, 6,
                       "No user roles encountered");
       rc = ESA_OK;
    }
    goto get_user_xrol_exit;
  }


  /@ WS10078SG
  if (returned_record_type EQ ROLE_LINE)                             @/
  if (returned_record_type EQ ROLES_BLOCK)   /@ change name WS10078SG@/
  {
      ESA_DIAG_printf(PLT_COMP_XREF, 6,
  /@ WS10078SG "Get_Rule_Record returned a :ROLE line");             @/
               "Get_Rule_Record returned a :ROLES block");/@WS10078SG@/
  /@
   *   Copy Role and RoleGroup names to addinfo
   @/
   role_record_end = role_record + strlen(role_record);
   i = 1;
   role_name = strtok(role_record,";");
   while ( (role_name NE NULL) AND (role_name LT role_record_end))
    {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "role(%d):  %.8s",
                      i++,role_name);
     strncpy(role_str, role_name, 8);
     role_str[8] = NULL_CHAR;
    /@set a null if space at the end... WS10078A start @/
    space_pos = strchr(role_str,' '); /@->space if found@/
    if(space_pos NE NULL)               /@space is found@/
    {
     *space_pos = NULL_CHAR;            /@set NULL instead of space@/
     ESA_DIAG_printf(PLT_COMP_XREF, 6,"set NULL at end of role=<%s>",
                     role_str);
    }
    /@ WS10078A end @/

     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "r: %p / %d    rg: %p / %d   group_found = %d",
                     r_pair, r_full, rg_pair, rg_full, group_found);

     if (group_found EQ FALSE)
     {
       rc = XREF_Block_Find(role_str,
                            XREFBlk,
                            &is_group,
                            admin_params);
       ESA_DIAG_printf(PLT_COMP_XREF, 6,
                      "XREF_Block_Find for %s - rc = %d   is_group = %c"
                      rc, is_group);
      if (rc NE ESA_OK)
      {
        rc = ESA_FATAL;
        goto get_user_xrol_exit;/@  XREF_Block_Find issued a msg @/
      };

      if (is_group EQ 'Y')
        group_found = TRUE;
     };

     pair = NULL;
     if (group_found EQ TRUE)   /@ If group - add to RolesGroup @/
     {
       if (rg_pair NE NULL  AND  rg_full NE TRUE)
         pair = rg_pair;
     }
     else                      /@ else - add to Roles @/
       if (r_pair NE NULL  AND  r_full NE TRUE)
         pair = r_pair;

     /@  Add name to appropriate addinfo entry @/
     if (pair NE NULL)
     {
       rc = ADDINFO_addval (role_str,
                            ACF_ADDINFO_VAL_LEN,
                            ADDINFO_LIST_ENTRY,
                            pair, dest, msgs);
       if (rc EQ ESA_EOF)  /@ No more space in value @/
       {
/@ WS10078ST Add the setting of ent_type for message CTS3893W
         if (pair EQ r_pair)  r_full = TRUE;
           else  rg_full = TRUE;                                     @/
         if (pair EQ r_pair)
         {
            r_full = TRUE;
            strcpy (ent_type, "Roles");                 /@ WS10078ST @/
         }
         else
         {
            rg_full = TRUE;
            strcpy (ent_type, "RoleGroups");            /@ WS10078ST @/
         }

/@ WS10078ST Using message CTS3893W instead of CTS1208I
         sprintf(errmsg, "%s user=%s", role_str, inputLID);
         CTSAMSG_print(MSG_KWD_VALUE_TRUNCATED, msgs, NULL, dest,
                         pair->keyword, errmsg);                     @/
         CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/@ WS10078ST @/        pair->keyword, inputLID,
/@ WS10078ST @/        role_str, strlen(role_str),
/@ WS10078ST @/        pair->vallen, ent_type);
/@ WS10078KM - Start  set isIncomplete attribute in addinfo @/
               rcc = ESA_OK;
               pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
               if (pair NE NULL)
               {
                  if( pair->value[0] NE 'Y')
                     rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                          pair);
                  if (rcc NE ESA_OK)
                  {
                     sprintf(errmsg,
                             "Update <%s> keyword failed. rc=%d",
                             "isIncomplete",rcc);
                     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                   dest, component,func,
                                   errmsg, rcc,__LINE__);
                  }
               }
/@ WS10078KM - Ends @/
       };
     };

     /@  If both are full  OR                           @/
     /@    ( group was found AND                        @/
     /@        (groups not req's or groups are full) )  @/
     /@  nothing to do - out                            @/
     if ( (r_full EQ TRUE  AND  rg_full EQ TRUE)  OR
           (group_found EQ 'Y' AND
              (rg_pair EQ NULL  OR rg_full EQ TRUE) ) )
        {
         rc = ESA_OK;
         break;
        }

     role_name = strtok(NULL,";");
    }  /@ end while @/
  }

  else
  {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
              "Get_Rule_Record returned unrequested line");
     rule_type_perm_vec = lid_perm_handle->rule_type_perm_vec;
     rule_type_perm_vec[0].permError_indicator=TRUE;

     rc = ESA_FATAL;
     goto get_user_xrol_exit;
  }

  get_user_xrol_exit:
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;

}
/* BS10108 - end of moved routine.                               */
/*                 End   WS10078T                                */
/******************************************************************
 * Procedure Name: Get_user_permissions
 ******************************************************************
 * Description   : Call the Get_Rule_Record routine to read records
 *                 from ACFRPTRX output (from memory) and copy all
 *                 direct and indirect permissions to addinfo.
 *                 This routine is called for account aggregation
 *                 and for SYNC user processing.
 *                 WS10084: the permissions are retrieved now from
 *                          Users/Groups/Roles PBs
 *
 * Input         : entity             changed name from LID WS10078SG
 *                 pointer to LID permissions handle
 *                 addinfo
 *                 call type: GET or TERM
 *                 index - of current lidra_vec             WS10078T
 *                 perms_exist for entity                   BS10108T
 * Output        : addinfo - permissions are copied here
 *                 perms_exist for entity                   BS10108T
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_EOF   - end_of_file reached
 ******************************************************************/
 /* WS10078SG Changing name of first input parameter to entity
 static  ESA_RC Get_user_permissions(char              * LID, /*temp*/

/* WS10084 start */
ESA_RC   Get_user_permissions(char                    * entity,
                              PB_Build_Request_typ    * PB_Req,
                              ADDINFO_rec_ptr           addinfo,
                              char                    * call_type,
                              int                     * perms_exist,
                              ADMIN_PARAMS_rec_typ    * admin_params)
{

  static char func[] = "Get_user_permissions";

  ESA_RC  rc     = ESA_OK;
  ESA_RC  rcc    = ESA_OK;
  ESA_RC  chk_rc = ESA_OK;
  ESA_RC  pb_rc  = ESA_OK;
  int     i                            = 0;
  int     step                         = 0;
  int     cmp                          = 0;
  int     size                         = 0;
  int     issue_no_permissions_message = TRUE;
  int     sort_groups                  = FALSE;
  int     u_is_full                    = FALSE;
  int     r_is_full                    = FALSE;
  int     * is_full                    = NULL;
  int     p_is_full                    = FALSE;
  PBhandle_typ                * G_PBhandle  = NULL;
  PBhandle_typ                * U_PBhandle  = NULL;
  PBhandle_typ                * R_PBhandle  = NULL;
  PBhandle_typ                * RG_PBhandle = NULL;
  XBhandle_rec_typ            * R_XBhandle  = NULL;
  char   perm_data[ACF2_MAX_PERMISSN_SIZE]  = "";
  char   LID[ACF2_LID_SIZE]                 = "";
  char   role[XREF_NAME_SIZE]               = "";
  char   errmsg[125]                        = "";
  char                        * ptr         = NULL;
  char                        * locptr      = NULL;
  UID                           uid         = "";
  UID                           save_prev_uid = "";
  UID_List_Element            * first_uid   = NULL;
  UID_List_Element            * last_uid    = NULL;
  UID_List_Element            * cur_uid     = NULL;
  UID_List_Element            * prev_uid    = NULL;
  UID_List_Element            * next_uid    = NULL;
  UID_List_Element            * uid_element = NULL;
  Role_List_Element           * first_role  = NULL;
  Role_List_Element           * last_role   = NULL;
  Role_List_Element           * cur_role    = NULL;
  Role_List_Element           * prev_role   = NULL;
  Role_List_Element           * next_role   = NULL;
  Role_List_Element           * role_element = NULL;
  ONE_FIELD_rec_ptr           u_pair        = NULL;
  ONE_FIELD_rec_ptr           r_pair        = NULL;
  ONE_FIELD_rec_ptr           g_pair        = NULL;
  ONE_FIELD_rec_ptr           pair          = NULL;
  ONE_FIELD_rec_ptr           xpair         = NULL;
  ONE_FIELD_rec_ptr           roles_pair    = NULL;
  ONE_FIELD_rec_ptr           rgroups_pair  = NULL;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);

  strcpy(LID, entity);
  Trim(LID);
  /*
  if (strcmp(LID,"#RQ") EQ 0)
     want_diag4 = TRUE;
  else
     want_diag4 = FALSE;
  */
  /*
  if (want_diag4)
   ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
     "Get_user_permissions  LID = %s \n",LID);
  */

  G_PBhandle = PB_Req->Groups_PBhandle_ptr;
  U_PBhandle = PB_Req->Users_PBhandle_ptr;
  R_XBhandle = PB_Req->Roles_XBhandle_ptr;
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 2,
                  "LID = %s \n"
                  "Groups_PBhandle_ptr = %p \n"
                  "Users_PBhandle_ptr  = %p \n"
                  "Roles_XBhandle_ptr  = %p \n"    ,
                   LID,
                   G_PBhandle,
                   U_PBhandle,
                   R_XBhandle);
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 2,
                  "GroupDirect         = %i \n"
                  "AccountDirect       = %i \n"
                  "AccountIndirect     = %i \n"
                  "AccountRoleDirect   = %i \n"
                  "AccountRoleIndirect = %i \n"
                  "RoleDirect          = %i \n" ,
                   PB_Req->GroupDirect,
                   PB_Req->AccountDirect,
                   PB_Req->AccountIndirect,
                   PB_Req->AccountRoleDirect,
                   PB_Req->AccountRoleIndirect,
                   PB_Req->RoleDirect);

 /*
 Retrieve permissions from the Users block:
 -------------------------------------------

 Call Permissions_Block_Get with UIDTHISN (new request to start looking for the
 name from the last read record. The first call should be with UIDTHIS),
 to look for the LID in the USERS block. Pass an area for a permission.
 Check the permission type (by checking the U/R at the end of the
 [key,prefix,U/R]  string at the end of the permission) and add it to the
 appropriate attribute:
 U to AccountDirectPermissions,
 R to AccountRoleDirectPermissions.
 Repeat Permissions_Block_Get with PERMNEXT to get all the
 permissions.
 Add the permission to the appropriate attribute using
 ADDINFO_addval(perm_data,...)
 */

  if (U_PBhandle EQ NULL)
     goto handle_groups;
  if (NOT (PB_Req->AccountDirect OR PB_Req->AccountRoleDirect))
     goto handle_groups;

  u_pair = ADDINFO_search("ACCOUNTDIRECTPERMISSIONS",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

  r_pair = ADDINFO_search("AccountRoleDirectPermissions",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

  if ( (u_pair EQ NULL) AND (r_pair EQ NULL) )
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
       "Not any Account Direct Permissions attributes requested \n");
     goto handle_groups;
  }

  U_PBhandle->curUIDinPB = NULL;

  /*
  if (want_diag4)
   ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
     "Handling Users PB  LID = %s \n",LID);
  */

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
      "Retrieving Permissions from User block \n");
  U_PBhandle->PBptr->skip_extYN = 'Y';
  pb_rc = Permissions_block_Get("UIDTHISN",
                              U_PBhandle,
                              LID,
                              NULL,
                              0,
                              PLT_COMP_PERMISSION,
                              admin_params);

  U_PBhandle->PBptr->skip_extYN = 'N';
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
       "Permissions_block_get (UIDTHISN)  rc = %d \n", pb_rc);

  rc = ESA_OK;
  if (pb_rc NE ESA_OK)
  {
    if (pb_rc EQ ESA_KEY_NOT_FOUND)
      goto handle_groups;

     rc = ACF2_Internal_Error;
     goto exit;
  }

  do
  {
    U_PBhandle->PBptr->skip_extYN = 'Y';
    pb_rc = Permissions_block_Get("PERMNEXT",
                                  U_PBhandle,
                                  LID,
                                  perm_data,
                                  sizeof(perm_data),
                                  PLT_COMP_PERMISSION,
                                  admin_params);
    U_PBhandle->PBptr->skip_extYN = 'N';

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
       "Permissions_block_get (PERMNEXT)  rc = %d, |%s| \n",
        pb_rc, perm_data);

    if (pb_rc  EQ  ESA_EOF)
       break;

    if (pb_rc  EQ  ESA_OK)  /* when ok, take the permission */
    {
       issue_no_permissions_message = FALSE;
       ptr = strchr(perm_data,']');
       if (ptr EQ NULL)
       {
          sprintf(errmsg,
                  "Expected ] not found in permission %s \n",
                  perm_data);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                        dest, component,func,
                        errmsg, 16,__LINE__);
          continue;
       }

       pair = NULL;
       ptr = ptr - 1; /* ptr -> U or R */
       if (*ptr EQ 'U')
       {
          pair = u_pair;
          is_full = &u_is_full;
          ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "Adding Permission to ACCOUNTDIRECTPERMISSIONS \n");
       }
       else
       if (*ptr EQ 'R')
       {
          pair = r_pair;
          is_full = &r_is_full;
          ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "Adding Permission to AccountRoleDirectPermissions \n");

       }
       if (pair EQ NULL)
          continue;
       if (*is_full)
          continue;

       rcc = ADDINFO_addval (perm_data,
                             ACF_ADDINFO_VAL_LEN,
                             ADDINFO_LIST_ENTRY,
                             pair, dest, msgs);
       if (rcc EQ ESA_EOF)
       {
         *is_full = TRUE;
         CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
                       pair->keyword, LID, perm_data,
                       strlen(perm_data), pair->vallen,
                       "permissions");

         rcc = ESA_OK;
         pair = ADDINFO_search("isIncomplete",
                               ACF_ADDINFO_KWD_LEN,
                               addinfo->pair,
                               addinfo->num_pairs);
         if (pair NE NULL)
         {
            if( pair->value[0] NE 'Y')
               rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                    pair);
            if (rcc NE ESA_OK)
            {
               sprintf(errmsg,
                       "Insert <%s> keyword failed. rc=%d",
                       "isIncomplete",rc);
               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                             dest, component,func,
                             errmsg, 16,__LINE__);
            }
         }
         pb_rc = ESA_EOF; /* fake EOF        */
       }
    }
  } while (pb_rc EQ ESA_OK  OR    /* While perm was returned or */
           pb_rc EQ ESA_ERR);     /* permission is too long.    */

  handle_groups:

 /*
 Retrieve AccountIndirectPermissions from the Groups block:
 -----------------------------------------------------------

 ADDINFO_list_getnextvalue for each name in the groups attribute
 Permissions_Block_Get for GROUPS block (UIDTHIS)
 For the first group we will call Permissions_Block_Get with UIDTHIS to look
 for the UID and get its first permissions.
 Add the permission to the AccountDirectPermissions attribute using
 ADDINFO_addval(perm_data,...)
 Permissions_Block_Get (PERMNEXT)
 Add the permission to the AccountDirectPermissions attribute using
 ADDINFO_addval(perm_data,...)
 Repeat with PERMNEXT to get all the permissions.
 The Groups PB is sorted but the groups list is NOT sorted when the user
 has multiple UIDX.
 Therefore UIDTHISN can't be used with the groups ASIS.
 Using UIDTHIS will cause us to send duplicate permissions.
 We must (at least for the ACFRPTRX replacement), and only when there are
 multi UIDX entries, sort the groups after we retrieve it from ADDINFO and
 remove duplicates.
 The first call for finding the first group should be with UIDTHIS, then
 for the 2nd group and on we can use UIDTHISN when calling
 Permissions_Block_Get to look for the next group in the Groups block
 and get its first permission.
 When found, we repeat the process as done for the first group.
 */
  /*
  if (want_diag4)
   ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
     "Handling Groups PB  LID = %s \n",LID);
  */

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "handle_groups");

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "G_PBhandle = %p  AccountIndirect = %d \n",
          G_PBhandle, PB_Req->AccountIndirect);

  if (G_PBhandle EQ NULL)
     goto handle_roles;
  if (NOT PB_Req->AccountIndirect)
     goto handle_roles;

  pair = ADDINFO_search("groups", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "groups attribute = %p \n", pair);

  if (pair EQ NULL)
     goto handle_roles;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
      "Retrieving Permissions from Groups block \n");

  g_pair = ADDINFO_search("ACCOUNTINDIRECTPERMISSIONS",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "ACCOUNTINDIRECTPERMISSIONS attribute = %p \n", g_pair);


  if (g_pair EQ NULL)
     goto handle_roles;

  xpair = ADDINFO_search("UIDX", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
  if (xpair NE NULL)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Multivalue UIDs found for user");

    sort_groups = TRUE;
  }


  locptr = NULL;
  do
  {

     chk_rc = ADDINFO_list_getnextvalue(pair, ADDINFO_LIST_ENTRY,
                                        uid, &locptr);
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "getnextvalue: num = %d, uid = |%s| \n",
          size,uid);

     if( uid[0] EQ NULL_CHAR )
          continue;

     size++;

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "next group (UID): num = %d, group = |%s| \n",
          size,uid);

     uid_element = (UID_List_Element *)
                   calloc(1, sizeof(UID_List_Element));

     if (uid_element EQ NULL)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "UID_List_Element",
                      sizeof(UID_List_Element));

        cur_uid = first_uid;
        while (cur_uid NE NULL)
        {
         uid_element = cur_uid->next_uid;
         free(cur_uid);
         cur_uid = uid_element;
        }

        rc = ESA_FATAL;
        goto exit;
     };

     strcpy(uid_element->uid,uid);

     /* chain as last */
     if (first_uid EQ NULL)
     {
       first_uid = uid_element;
       last_uid  = uid_element;
     }
     else
     {
       last_uid->next_uid = uid_element;
       last_uid  = uid_element;
     }

  } while( chk_rc EQ ESA_OK );

 /*
 typedef struct S_UID_LIST_ELEMENT {
  struct S_UID_LIST_ELEMENT * next_uid;
  UID uid;
  } UID_List_Element;

 */

  cur_uid = first_uid;
  while (cur_uid NE NULL)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "group in list =  %s \n",
            cur_uid->uid);
    cur_uid = cur_uid->next_uid;
  }

  if (sort_groups)   /* sort with bubble sort */
  {
    /* loop to access each element */
    for (step = 0; step LT size - 1; ++step)
    {
      prev_uid = NULL;
      cur_uid = first_uid;
      next_uid = first_uid->next_uid;

      /* loop to compare elements */
      for (i = 0; i LT size - step - 1; ++i)
      {

        /* compare two adjacent elements */
        cmp = strcmp(cur_uid->uid, next_uid->uid);
        if (cmp GT 0)   /* cur > next */
        {
          /* swap cur with next */
          if (prev_uid EQ NULL)
             first_uid = next_uid;
          else
             prev_uid->next_uid = next_uid;
          cur_uid->next_uid = next_uid->next_uid;
          next_uid->next_uid = cur_uid;

          prev_uid = next_uid;
          next_uid = cur_uid->next_uid;
          if (i EQ 0)
            first_uid = prev_uid;
          /* if (next_uid EQ NULL)
            last_uid = cur_uid;  we don't really need to update last */
        }
        else
        {
          prev_uid = cur_uid;
          cur_uid = next_uid;
          next_uid = cur_uid->next_uid;
        }
      }
      cur_uid = first_uid;
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "step = %d  i = %d \n",
                   step, i);
      while (cur_uid NE NULL)
      {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "in sort group =  |%s| \n",
                   cur_uid->uid);
        cur_uid = cur_uid->next_uid;
      }

    }
  }


  cur_uid = first_uid;
  while (cur_uid NE NULL)
  {
    /*
    if (want_diag4)
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
           "sorted group from user's groups attribute =  %s \n",
            cur_uid->uid);
    */

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "sorted group from user's groups attribute =  %s \n",
            cur_uid->uid);
    cur_uid = cur_uid->next_uid;
  }

  save_prev_uid[0] = NULL_CHAR;
  cur_uid = first_uid;
  p_is_full = FALSE;
  G_PBhandle->curUIDinPB = NULL;
  while (cur_uid NE NULL)  /* loop over sorted groups from ADDINFO */
  {

    if (p_is_full)
       goto next_uid;
    /* skip duplicates */
    if (strcmp(cur_uid->uid, save_prev_uid) EQ 0)
       goto next_uid;

    strcpy(save_prev_uid,cur_uid->uid);

    G_PBhandle->PBptr->skip_extYN = 'Y';
    pb_rc = Permissions_block_Get("UIDTHISN",
                                G_PBhandle,
                                cur_uid->uid,
                                NULL,
                                0,
                                PLT_COMP_PERMISSION,
                                admin_params);
    G_PBhandle->PBptr->skip_extYN = 'N';

    /*
    if (want_diag4)
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
       "Permissions_block_get (UIDTHISN) rc = %d. uid = |%s| \n",
       pb_rc, cur_uid->uid);
    */
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
       "Permissions_block_get (UIDTHISN) rc = %d. uid = |%s| \n",
       pb_rc, cur_uid->uid);

    rc = ESA_OK;
    if (pb_rc NE ESA_OK)
    {
      if (pb_rc EQ ESA_KEY_NOT_FOUND)
         goto next_uid;

       rc = ACF2_Internal_Error;
       goto exit;
    }

    do    /* retreive all permissions of this group */
    {
      G_PBhandle->PBptr->skip_extYN = 'Y';
      pb_rc = Permissions_block_Get("PERMNEXT",
                                    G_PBhandle,
                                    cur_uid->uid,
                                    perm_data,
                                    sizeof(perm_data),
                                    PLT_COMP_PERMISSION,
                                    admin_params);
      G_PBhandle->PBptr->skip_extYN = 'N';

      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "Permissions_block_get (PERMNEXT)  rc = %d, perm = |%s| \n",
          pb_rc, perm_data);

      if (pb_rc  EQ  ESA_EOF)
         continue;

      if (pb_rc  EQ  ESA_OK)  /* when ok, take the permission */
      {
         issue_no_permissions_message = FALSE;

         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "Adding Permission to ACCOUNTINDIRECTPERMISSIONS \n");

         rcc = ADDINFO_addval (perm_data,
                               ACF_ADDINFO_VAL_LEN,
                               ADDINFO_LIST_ENTRY,
                               g_pair, dest, msgs);
         if (rcc EQ ESA_EOF)
         {
           CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
                         g_pair->keyword, LID, perm_data,
                         strlen(perm_data), g_pair->vallen,
                         "permissions");

           p_is_full = TRUE;
           rcc = ESA_OK;
           pair = ADDINFO_search("isIncomplete",
                                 ACF_ADDINFO_KWD_LEN,
                                 addinfo->pair,
                                 addinfo->num_pairs);
           if (pair NE NULL)
           {
              if( pair->value[0] NE 'Y')
                 rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                      pair);
              if (rcc NE ESA_OK)
              {
                 sprintf(errmsg,
                         "Insert <%s> keyword failed. rc=%d",
                         "isIncomplete",rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                               dest, component,func,
                               errmsg, 16,__LINE__);
              }
           }
           pb_rc = ESA_EOF; /* fake EOF        */
         }
      }
    } while (pb_rc EQ ESA_OK  OR    /* While perm was returned or */
             pb_rc EQ ESA_ERR);     /* permission is too long.    */

    next_uid:
    uid_element = cur_uid;
    cur_uid = cur_uid->next_uid;
    free(uid_element);
  }  /* end of while (cur_uid NE NULL) */

  handle_roles:

 /*
 Retrieve AccountRoleIndirectPermissions from the Roles block:
 --------------------------------------------------------------

 ADDINFO_list_getnextvalue for each name in the Roles attribute
 Permissions_Block_Get for XREF Roles block (UIDTHISN)
 (The first call should be with UIDTHIS)
 Permissions_Block_Get (PERMNEXT)
 ADDINFO_list_getnextvalue for each name in the RoleGroups attribute
 Permissions_Block_Get for XREF Groups block (UIDTHISN)
     (The first call should be with UIDTHIS)
 Permissions_Block_Get (PERMNEXT)


 Add each permission to the AccountRoleIndirectPermissions attribute using
 ADDINFO_addval(perm_data,...)

 The the Roles and RolesGroup attributes are not sorted (we will sort the
 lists before searching)
 */

  /*
  if (want_diag4)
   ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
     "Handling Roles PB  LID = %s \n",LID);
  */


  if (R_XBhandle EQ NULL)
     goto exit;
  if (NOT PB_Req->AccountRoleIndirect)
     goto exit;

  roles_pair = ADDINFO_search("Roles", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  rgroups_pair = ADDINFO_search("RoleGroups", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  if ( (roles_pair  EQ NULL) AND (rgroups_pair EQ NULL) )
     goto exit;

  r_pair = ADDINFO_search("AccountRoleIndirectPermissions",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

  if (r_pair EQ NULL)
     goto exit;

  R_PBhandle  = R_XBhandle->XREF_PB_handle;
  RG_PBhandle = R_XBhandle->Groups_PB_handle;
  ESA_DIAG_printf(PLT_COMP_PERMISSION,6,
               "From XBhandle: \n"
               "XREF_PB_handle      = %p \n"
               "Groups_PB_handle    = %p \n"    ,
                R_PBhandle,
                RG_PBhandle);



  if ( (R_PBhandle  EQ NULL) AND (RG_PBhandle EQ NULL) )
     goto exit;



  /*
  Retrieve Roles from ADDINFO
  The Roles will be added to a list and sorted
  Then each Role will be searched R_PBhandle
  Add each permission to the AccountRoleIndirectPermissions attribute using
  ADDINFO_addval(perm_data,...)
  */

  /**************************
  Retrieve Roles from ADDINFO
  and chain them in a list
  **************************/

  /*
  if (strcmp(LID,"#RQ") EQ 0)
     want_diag = TRUE;
  else
     want_diag = FALSE;
    */

  first_role = NULL;
  size = 0;
  locptr = NULL;
  do
  {

     chk_rc = ADDINFO_list_getnextvalue(roles_pair,ADDINFO_LIST_ENTRY,
                                        role, &locptr);
     if( role[0] EQ NULL_CHAR )
          continue;

     size++;

     strtok(role,"(");
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "next role: num = %d, role = |%s| \n",
          size,role);

     role_element = (Role_List_Element *)
                   calloc(1, sizeof(Role_List_Element));

     if (role_element EQ NULL)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "Role_List_Element",
                      sizeof(Role_List_Element));

        cur_role = first_role;
        while (cur_role NE NULL)
        {
         role_element = cur_role->next_role;
         free(cur_role);
         cur_role = role_element;
        }

        rc = ESA_FATAL;
        goto exit;
     };

     strcpy(role_element->role,role);
     role_element->next_role = NULL;

     /* chain as last */
     if (first_role EQ NULL)
     {
       first_role = role_element;
       last_role  = role_element;
     }
     else
     {
       last_role->next_role = role_element;
       last_role  = role_element;
     }

  } while( chk_rc EQ ESA_OK );


  /**************************
  Print the unsorted roles
  in the list
  **************************/
  cur_role = first_role;
  while (cur_role NE NULL)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "role =  %s \n",
            cur_role->role);
    cur_role = cur_role->next_role;
  }


  /**************************
  Sort the roles in the list
  using bubble sort
  **************************/

  /* loop to access each element */
  for (step = 0; step LT size - 1; ++step)
  {
    prev_role = NULL;
    cur_role = first_role;
    next_role = first_role->next_role;

    /* loop to compare elements */
    for (i = 0; i LT size - step - 1; ++i)
    {

      /* compare two adjacent elements */
      cmp = strcmp(cur_role->role, next_role->role);
      if (cmp GT 0)   /* cur > next */
      {
        /* swap cur with next */
        if (prev_role EQ NULL)
           first_role = next_role;
        else
           prev_role->next_role = next_role;
        cur_role->next_role = next_role->next_role;
        next_role->next_role = cur_role;

        prev_role = next_role;
        next_role = cur_role->next_role;
        if (i EQ 0)
          first_role = prev_role;
        /* if (next_role EQ NULL)
          last_role = cur_role; we don't really need to update last */
      }
      else
      {
        prev_role = cur_role;
        cur_role = next_role;
        next_role = cur_role->next_role;
      }
    }
    cur_role = first_role;
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "step = %d  i = %d \n",
                 step, i);
    while (cur_role NE NULL)
    {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "in sort role =  |%s| \n",
                 cur_role->role);
      cur_role = cur_role->next_role;
    }

  }

  /**************************
  Print the sorted Roles
  in the list
  **************************/
  /*
  if (want_diag)
  {
    cur_role = first_role;
    while (cur_role NE NULL)
    {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
             "role from the user = %s Roles attribute = %s \n",
              LID, cur_role->role);
      cur_role = cur_role->next_role;
    }
  }
    */
  cur_role = first_role;
  while (cur_role NE NULL)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "role from the user's Roles  attribute =  %s \n",
            cur_role->role);
    cur_role = cur_role->next_role;
  }

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
      "Retrieving Permissions from Roles block \n");

  p_is_full = FALSE;
  R_PBhandle->curUIDinPB = NULL;
  cur_role = first_role;
  while (cur_role NE NULL)
  {
    if (p_is_full)
       goto free;

    R_PBhandle->PBptr->skip_extYN = 'Y';
    pb_rc = Permissions_block_Get("UIDTHISN",
                                R_PBhandle,
                                cur_role->role,
                                NULL,
                                0,
                                PLT_COMP_PERMISSION,
                                admin_params);
    R_PBhandle->PBptr->skip_extYN = 'N';
    /*
    if (want_diag)
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
       "Permissions_block_get (UIDTHISN) rc = %d. role = |%s| \n",
       pb_rc, cur_role->role);
      */


    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
       "Permissions_block_get (UIDTHISN) rc = %d. role = |%s| \n",
       pb_rc, cur_role->role);

    rc = ESA_OK;
    if (pb_rc NE ESA_OK)
    {
      if (pb_rc EQ ESA_KEY_NOT_FOUND)
        goto free;

       rc = ACF2_Internal_Error;
       goto exit;
    }

    do
    {
      /*
      if (want_diag)
      {
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
            "ROLE = |%s| before PERMNEXT curUIDinPB = %p \n",
            cur_role->role,R_PBhandle->curUIDinPB);
         SNAP_AREA("curUIDinPB",
                R_PBhandle->curUIDinPB,
                sizeof(PERM_BLK_UID_rec_typ))
         if (R_PBhandle->curUIDinPB->first_perm NE NULL)
          SNAP_AREA("curUIDinPB->first_perm",
                R_PBhandle->curUIDinPB->first_perm,
                strlen(R_PBhandle->curUIDinPB->first_perm->perm))
      }
        */

      R_PBhandle->PBptr->skip_extYN = 'Y';
      pb_rc = Permissions_block_Get("PERMNEXT",
                                    R_PBhandle,
                                    cur_role->role,
                                    perm_data,
                                    sizeof(perm_data),
                                    PLT_COMP_PERMISSION,
                                    admin_params);
      R_PBhandle->PBptr->skip_extYN = 'N';

      /*
      if (want_diag)
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
         "Permissions_block_get (PERMNEXT)  rc = %d, perm = |%s| \n",
          pb_rc, perm_data);
        */

      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "Permissions_block_get (PERMNEXT)  rc = %d, perm = |%s| \n",
          pb_rc, perm_data);

      if (pb_rc  EQ  ESA_EOF)
         continue;

      if (pb_rc  EQ  ESA_OK)  /* when ok, take the permission */
      {
         issue_no_permissions_message = FALSE;

         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "Adding Permission to AccountRoleIndirectPermissions \n");

         rcc = ADDINFO_addval (perm_data,
                               ACF_ADDINFO_VAL_LEN,
                               ADDINFO_LIST_ENTRY,
                               r_pair, dest, msgs);
         /*
         if (want_diag)
           ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
           "ADDINFO_addval to AccountRoleIndirectPermissions rc = %d \n",
           rcc);
           */

         if (rcc EQ ESA_EOF)
         {
           p_is_full = TRUE;
           CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
                         r_pair->keyword, LID, perm_data,
                         strlen(perm_data), r_pair->vallen,
                         "permissions");

           rcc = ESA_OK;
           pair = ADDINFO_search("isIncomplete",
                                 ACF_ADDINFO_KWD_LEN,
                                 addinfo->pair,
                                 addinfo->num_pairs);
           if (pair NE NULL)
           {
              if( pair->value[0] NE 'Y')
                 rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                      pair);
              if (rcc NE ESA_OK)
              {
                 sprintf(errmsg,
                         "Insert <%s> keyword failed. rc=%d",
                         "isIncomplete",rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                               dest, component,func,
                               errmsg, 16,__LINE__);
              }
           }
           pb_rc = ESA_EOF; /* fake EOF        */
         }
      }
    } while (pb_rc EQ ESA_OK  OR    /* While perm was returned or */
             pb_rc EQ ESA_ERR);     /* permission is too long.    */

    free:
    role_element = cur_role;
    cur_role = cur_role->next_role;
    free(role_element);
  }

  /*
  Retrieve RoleGroups from ADDINFO
  The RoleGroups will be added to a list and sorted
  Then each RoleGroup will be searched RG_PBhandle
  Add each permission to the AccountRoleIndirectPermissions attribute using
  ADDINFO_addval(perm_data,...)
  */

  if (p_is_full)
     goto exit;

  first_role = NULL;
  size = 0;
  locptr = NULL;
  do
  {

     chk_rc = ADDINFO_list_getnextvalue(rgroups_pair ,
                                        ADDINFO_LIST_ENTRY,
                                        role, &locptr);
     if( *role EQ NULL_CHAR )
          continue;

     size++;

     strtok(role,"(");
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "next role group: num = %d, role = |%s| \n",
          size,role);

     role_element = (Role_List_Element *)
                   calloc(1, sizeof(Role_List_Element));

     if (role_element EQ NULL)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "Role_List_Element",
                      sizeof(Role_List_Element));

        cur_role = first_role;
        while (cur_role NE NULL)
        {
         role_element = cur_role->next_role;
         free(cur_role);
         cur_role = role_element;
        }

        rc = ESA_FATAL;
        goto exit;
     };

     strcpy(role_element->role,role);
     role_element->next_role = NULL;
     /* chain as last */
     if (first_role EQ NULL)
     {
       first_role = role_element;
       last_role  = role_element;
     }
     else
     {
       last_role->next_role = role_element;
       last_role  = role_element;
     }

  } while( chk_rc EQ ESA_OK );

  cur_role = first_role;
  while (cur_role NE NULL)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "role =  |%s| \n",
            cur_role->role);
    cur_role = cur_role->next_role;
  }

  /* sort the list               */
  /* loop to access each element */
  for (step = 0; step LT size - 1; ++step)
  {
    prev_role = NULL;
    cur_role = first_role;
    next_role = first_role->next_role;

    /* loop to compare elements */
    for (i = 0; i LT size - step - 1; ++i)
    {

      /* compare two adjacent elements */
      cmp = strcmp(cur_role->role, next_role->role);
      if (cmp GT 0)   /* cur > next */
      {
        /* swap cur with next */
        if (prev_role EQ NULL)
           first_role = next_role;
        else
           prev_role->next_role = next_role;
        cur_role->next_role = next_role->next_role;
        next_role->next_role = cur_role;

        prev_role = next_role;
        next_role = cur_role->next_role;
        if (i EQ 0)
          first_role = prev_role;
        /* if (next_role EQ NULL)
          last_role = cur_role; we don't really need to update last */
      }
      else
      {
        prev_role = cur_role;
        cur_role = next_role;
        next_role = cur_role->next_role;
      }
    }
    cur_role = first_role;
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "step = %d  i = %d \n",
                 step, i);
    while (cur_role NE NULL)
    {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "in sort role =  %s \n",
                 cur_role->role);
      cur_role = cur_role->next_role;
    }

  }

  /**************************
  Print the sorted RoleGroups
  in the list
  **************************/
  /*
  if (want_diag)
  {
    cur_role = first_role;
    while (cur_role NE NULL)
    {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
        "role from the user = %s  RoleG attribute = %s \n",
        LID, cur_role->role);
      cur_role = cur_role->next_role;
    }
  }
    */

  cur_role = first_role;
  while (cur_role NE NULL)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "role from the user's Roles  attribute =  %s \n",
            cur_role->role);
    cur_role = cur_role->next_role;
  }


  RG_PBhandle->curUIDinPB = NULL;
  cur_role = first_role;
  while (cur_role NE NULL)
  {

    if (p_is_full)
       goto freeg;
    /*
    if (want_diag)
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
        "Before Permissions_block_Get( UIDTHISN.. "
        "UIDTHISN curUIDinPB = %s ",
         RG_PBhandle->curUIDinPB->uid);
      */

    RG_PBhandle->PBptr->skip_extYN = 'Y';
    pb_rc = Permissions_block_Get("UIDTHISN",
                                RG_PBhandle,
                                cur_role->role,
                                NULL,
                                0,
                                PLT_COMP_PERMISSION,
                                admin_params);
    RG_PBhandle->PBptr->skip_extYN = 'N';

    /*
    if (want_diag)
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
       "Permissions_block_get (UIDTHISN) rc = %d. role group = |%s| \n",
       pb_rc, cur_role->role);
      */

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
       "Permissions_block_get (UIDTHISN) rc = %d. role group = |%s| \n",
       pb_rc, cur_role->role);

    rc = ESA_OK;
    if (pb_rc NE ESA_OK)
    {
      if (pb_rc EQ ESA_KEY_NOT_FOUND)
        goto freeg;

       rc = ACF2_Internal_Error;
       goto exit;
    }

    do
    {
      RG_PBhandle->PBptr->skip_extYN = 'Y';
      pb_rc = Permissions_block_Get("PERMNEXT",
                                    RG_PBhandle,
                                    cur_role->role,
                                    perm_data,
                                    sizeof(perm_data),
                                    PLT_COMP_PERMISSION,
                                    admin_params);
      RG_PBhandle->PBptr->skip_extYN = 'N';

      /*
      if (want_diag)
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
         "Permissions_block_get (PERMNEXT)  rc = %d, perms = |%s| \n",
          pb_rc, perm_data);
        */

      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
         "Permissions_block_get (PERMNEXT)  rc = %d, perms = |%s| \n",
          pb_rc, perm_data);

      if (pb_rc  EQ  ESA_EOF)
         continue;

      if (pb_rc  EQ  ESA_OK)  /* when ok, take the permission */
      {
         issue_no_permissions_message = FALSE;


         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "Adding Permission to AccountRoleIndirectPermissions \n");

         rcc = ADDINFO_addval (perm_data,
                               ACF_ADDINFO_VAL_LEN,
                               ADDINFO_LIST_ENTRY,
                               r_pair, dest, msgs);
         /*
         if (want_diag)
          ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
           "ADDINFO_addval to AccountRoleIndirectPermissions rc = %d \n",
           rcc);
           */

         if (rcc EQ ESA_EOF)
         {
           p_is_full = TRUE;
           CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
                         r_pair->keyword, LID, perm_data,
                         strlen(perm_data), r_pair->vallen,
                         "permissions");

           rcc = ESA_OK;
           pair = ADDINFO_search("isIncomplete",
                                 ACF_ADDINFO_KWD_LEN,
                                 addinfo->pair,
                                 addinfo->num_pairs);
           if (pair NE NULL)
           {
              if( pair->value[0] NE 'Y')
                 rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                      pair);
              if (rcc NE ESA_OK)
              {
                 sprintf(errmsg,
                         "Insert <%s> keyword failed. rc=%d",
                         "isIncomplete",rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                               dest, component,func,
                               errmsg, 16,__LINE__);
              }
           }
           pb_rc = ESA_EOF; /* fake EOF        */
         }
      }
    } while (pb_rc EQ ESA_OK  OR    /* While perm was returned or */
             pb_rc EQ ESA_ERR);     /* permission is too long.    */

    freeg:
    role_element = cur_role;
    cur_role = cur_role->next_role;
    free(role_element);
  }


  exit:
  /*
  if (want_diag4)
    ESA_DIAG_exit(PLT_COMP_PERMISSION, 0, func, rc);
  */

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, rc);
  return rc;
}

/* WS10084 end   */
/* WS10084
ESA_RC   Get_user_permissions(char                    * entity,
                              LID_PERM_handle_rec_typ * lid_perm_handle,
                              ADDINFO_rec_ptr           addinfo,
                              char                    * call_type,
     /* WS10078T @/           int                       index,
     /* BS10108T @/           int                     * perms_exist,
                              ADMIN_PARAMS_rec_typ    * admin_params)
{
  /* WS10076S Moved these 2 definitions to CTSBACF
  #define MAX_PERM_KEY_LEN  64 // max current size: 40 //
  #define MAX_PERM_PREFIX_LEN  64      // max current size: 40 @/
  static char func[] = "Get_user_permissions";

  ESA_RC     rc = ESA_OK;
  ESA_RC     rcc = ESA_OK;
  char     * from = NULL;
  char     * to = NULL;
  int        i = 0, first_time = 0, found = 0, len = 0;
  char       user_or_group = NULL_CHAR;
  char       res_type[2] = "";
  char       direct_or_indirect = NULL_CHAR;
  char       resource_type[4] = "";
  char       type[4] = "";
  char       key[MAX_PERM_KEY_LEN] = "";
  char       prefix[MAX_PERM_PREFIX_LEN] = "";
  char     * uid_parm = NULL;
  char     * tempRoleUser;                 /* WS10078A @/
  char       only_uid[ACF2_UID_SIZE] = ""; /* uid itself    @/
  char       full_uid[ACF2_UID_SIZE+6] = "";
  char       lid[ACF2_LID_SIZE] = "";
/* WS10078SG Changing name of this variable to trimmed_entity
  char       inputLID[ACF2_LID_SIZE] = "";                           @/
  char       trimmed_entity[ACF2_LID_SIZE] = "";         /* WS10078SG@/
  char       formatted_permission[ACF2_MAX_PERMISSN_SIZE] = "";
  char       rule_record[ACF2_MAX_PERMISSN_SIZE] = "";
  char       errmsg[125] = "";
  int        direct_perm_addinfo_full   = FALSE;
  int        indirect_perm_addinfo_full = FALSE;
  char       function[10];
  char     * fromw = NULL;
  char     * tow = NULL;
  int        lenw = 0;
  int        roleset_permission = FALSE;                /* WS10078S @/
  char       req_line[15] = "";                         /* WS10078S @/
  char       full_roleuser[16] = "";                    /* WS10078S @/
  char       only_roleuser[16] = "";                    /* WS10078SG@/
  char     * roleuser_parm = NULL;                      /* WS10078S @/
  int        role_direct_perm_addinfo_full   = FALSE;   /* WS10078S @/
  int        role_indirect_perm_addinfo_full = FALSE;   /* WS10078S @/
  int        role_direct_group_addinfo_full  = FALSE;   /* WS10078SG@/
  ONE_FIELD_rec_ptr        role_direct_pair   = NULL;   /* WS10078S @/
  ONE_FIELD_rec_ptr        role_indirect_pair = NULL;   /* WS10078S @/
  ONE_FIELD_rec_ptr        role_direct_group_pair=NULL; /* WS10078SG@/
  Permission_Record_Type   requested_record_type;
  Permission_Record_Type   returned_record_type;
  /* BS10111 GET_LINE_PTR             get_line_ptr;   @/
  ONE_FIELD_rec_ptr        direct_pair   = NULL;
  ONE_FIELD_rec_ptr        indirect_pair = NULL;
  ONE_FIELD_rec_ptr        pair = NULL;                 /* WS10078KM @/
  RULE_TYPE_PERM_rec_typ * rule_type_perm_vec;
  /* BS10111 IDB_GETRUOBLINE_rec_typ   input_desc_block;  @/

 /* WS10076N - moved here from top of member @/
 /* Wanted Permission Record Entry table @/

 /* WS10078SG This block not needed. It was used for ANY_LINE function.
  static WANTED_PERM_REC_rec_typ PERM_RECORD_accounts[] = {
    {"LID: "     ,  5,  LID_LINE     },
    {"$KEY("     ,  5,  $KEY_LINE    },
    {"$PREFIX("  ,  8,  $PREFIX_LINE },
    {""          ,  0,  0            }
    };                                                               @/
  /* Ws10076N - end of move @/

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);

  /* WS10084 i = index ;                                /@ WS10078T @/
  /* WS10078SG Changing the names of these variables
  strcpy(inputLID, LID);
  Trim(inputLID);                                                    @/
  strcpy(trimmed_entity, entity);                        /* WS10078SG@/
  Trim(trimmed_entity);                                  /* WS10078SG@/

  /* WS10076 Changed the name of the routine
  get_line_ptr = &Get_rule_line_from_memory;                         */
  /* BS10111 get_line_ptr = &ESA_CLI_get_RUOB_line;   /@ WS10076 @/  */

  /* The following few lines were cleaned up a bit.         WS10078SG*/
  /*-----------------------------------------------------------------*/
  /* Check whether addinfo contains ACCOUNTDIRECTPERMISSIONS,        */
  /* ACCOUNTINDIRECTPERMISSIONS, AccountRoleDirectPermissions,       */
  /* AccountRoleIndirectPermissions, and/or RoleDirectPermissions.   */
  /* If none of the ADDINFO fields exist, return to the caller.      */
  /*-----------------------------------------------------------------*/

  /* WS10084
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,                /* WS10078SG@/
                  "Required permissions = %c",           /* WS10078SG@/
                  lid_perm_handle->RequiredPermissions); /* WS10078SG@/

  if (lid_perm_handle->RequiredPermissions EQ            /* WS10078SG@/
                                          PERM_TYPE_LID) /* WS10078SG@/
  {                                                      /* WS10078SG@/
     direct_pair = ADDINFO_search("ACCOUNTDIRECTPERMISSIONS",
                                  ACF_ADDINFO_KWD_LEN,
                                  addinfo->pair,
                                  addinfo->num_pairs);
     indirect_pair = ADDINFO_search("ACCOUNTINDIRECTPERMISSIONS",
                                    ACF_ADDINFO_KWD_LEN,
                                    addinfo->pair,
                                    addinfo->num_pairs);
    /*   Start WS10078T  @/
    if (lid_perm_handle->RequiredRoles NE NULL_CHAR)
     {
     role_direct_pair =
                   ADDINFO_search("AccountRoleDirectPermissions",
                                  ACF_ADDINFO_KWD_LEN,
                                  addinfo->pair,
                                  addinfo->num_pairs);
     role_indirect_pair =
                     ADDINFO_search("AccountRoleIndirectPermissions",
                                    ACF_ADDINFO_KWD_LEN,
                                    addinfo->pair,
                                    addinfo->num_pairs);
    /*   End   WS10078T  @/
     }
  }                                                      /* WS10078SG@/
  else if (lid_perm_handle->RequiredPermissions EQ       /* WS10078SG@/
                                         PERM_TYPE_ROLE) /* WS10078SG@/
     role_direct_group_pair =                            /* WS10078SG@/
                   ADDINFO_search("RoleDirectPermissions",/*WS10078SG@/
                                  ACF_ADDINFO_KWD_LEN,   /* WS10078SG@/
                                  addinfo->pair,         /* WS10078SG@/
                                  addinfo->num_pairs);   /* WS10078SG@/

  if ( (direct_pair            EQ NULL) AND
       (indirect_pair          EQ NULL) AND
       (role_direct_pair       EQ NULL) AND
       (role_indirect_pair     EQ NULL) AND
       (role_direct_group_pair EQ NULL) )                /* WS10078SG@/
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,  /*(B)@/
             func, "No permissions requested in addinfo",
             16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
    WS10084 */
  /*  WS10078T following code moved with changes to
  Get_User_XREFAndPermissions

  if (strcmp(call_type, "TERM") EQ 0)
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Processing TERM request");

     for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
     {
        rc = Get_Rule_Record(
               "TERM",
               &(lid_perm_handle->lidra_vec[i].get_rule_record_handle),
               get_line_ptr,
               &input_desc_block,
               PERM_RECORD_accounts,
               requested_record_type,
               sizeof(rule_record),
               "ACFRPTRX",
               &returned_record_type,
               rule_record,
               resource_type,
               admin_params);
  }

     rc = ACF2_get_LID_rules("TERM",
                             lid_perm_handle,
                             admin_params);

     free(lid_perm_handle->rule_type_perm_vec);

     goto exit;
  }

  if (strcmp(call_type, "GET") NE 0)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "invalid input function parameter",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }

  /*----------------------------------------------------------//
  /* process the get request                                  //
  /*----------------------------------------------------------//
  memset (function, 0X00, sizeof(function));
  if (lid_perm_handle EQ NULL)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, /*(A)//
             func, "LID Permissions handle pointer NULL",
             16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }

  if (lid_perm_handle->error EQ TRUE)
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "LID Permissions handle error indicator on");
     rc = ESA_OK;
     goto exit;
  }

  /*----------------------------------------------------------//
  /* Check whether addinfo contains ACCOUNTDIRECTPERMISSIONS  //
  /* and/or ACCOUNTINDIRECTPERMISSIONS. If neither, return to //
  /* caller immediately.                                      //
  /*----------------------------------------------------------//

  direct_pair = ADDINFO_search("ACCOUNTDIRECTPERMISSIONS",
                               ACF_ADDINFO_KWD_LEN,
                               addinfo->pair,
                               addinfo->num_pairs);
  indirect_pair = ADDINFO_search("ACCOUNTINDIRECTPERMISSIONS",
                                 ACF_ADDINFO_KWD_LEN,
                                 addinfo->pair,
                                 addinfo->num_pairs);
  if ( (direct_pair   EQ NULL) AND
       (indirect_pair EQ NULL) )
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,  /*(B)//
             func, "No direct/indirect permissions in addinfo",
             16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }

  /*----------------------------------------------------------//
  /* Check whether the pointer to the LID rule area vector is //
  /* NULL.  If it is NULL, call ACF2_get_LID_rules and        //
  /* allocate/initialize the rule type permissions handle     //
  /* vector.  If it is not NULL, verify that the pointer to   //
  /* the rule type permissions handle vector is not NULL.     //
  /*----------------------------------------------------------//

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "Processing GET request for LID |%s|", inputLID);

  if (lid_perm_handle->lidra_vec EQ NULL)
  {
     rc = ACF2_get_LID_rules("GET",
                             lid_perm_handle,
                             admin_params);
     if (rc NE ESA_OK)
     {
        lid_perm_handle->error = TRUE;
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                func, "ACF2_get_LID_rules not successful",  /*(C)(D)//
                16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }

     rule_type_perm_vec = (RULE_TYPE_PERM_rec_typ *)
                  calloc (lid_perm_handle->lidra_vec_num,
                                   sizeof(RULE_TYPE_PERM_rec_typ));
     if (NOT rule_type_perm_vec)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "RULE_TYPE_PERM handle vector",
                                      sizeof(RULE_TYPE_PERM_rec_typ));
        rc = ESA_FATAL;
        goto exit;
     };

     lid_perm_handle->rule_type_perm_vec = rule_type_perm_vec;

     for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
     {
     /* strcpy (lid_perm_handle->rule_type_perm_vec[i].rules_type, //
        strcpy (rule_type_perm_vec[i].rules_type,
                lid_perm_handle->lidra_vec[i].rules_type);
     };
  }
  else
  {
     if (lid_perm_handle->rule_type_perm_vec EQ NULL)
     {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, /*(E)//
               func, "no ptr to rule_type_permisssion handle vector",
               16, __LINE__);
       rc = ESA_FATAL;
       goto exit;
     }
     rule_type_perm_vec = lid_perm_handle->rule_type_perm_vec;

  }

  found = FALSE;

  /*----------------------------------------------------------//
  /* Outermost loop: Loop through LID rule area vector (same  //
  /* index used for rule type permissions handle vector).     //
  /*----------------------------------------------------------//

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "About to start outer loop");

  for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
  {
     if ( (rule_type_perm_vec[i].permError_indicator
                                                           EQ TRUE) OR
          (lid_perm_handle->lidra_vec[i].IOError_indicator EQ TRUE) OR
          (lid_perm_handle->lidra_vec[i].EOF_indicator     EQ TRUE) )
        continue;

     /* WS10076S Change the following if phrase
     if ( (strcmp(rule_type_perm_vec[i].last_lid_read,
                                                NULL_CHAR) NE 0) AND //
     if ( (rule_type_perm_vec[i].last_lid_read[0] NE NULL_CHAR)
                                                            /*WS10076S//
          AND                                               /*WS10076S//
          (strcmp(rule_type_perm_vec[i].last_lid_read,
                  rule_type_perm_vec[i].last_lid_processed) LT 0) )
     {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, /*(F)//
               func, "last LID read less than last LID processed",
               16, __LINE__);
       rule_type_perm_vec[i].permError_indicator = TRUE;
       continue;
     }

     /*----------------------------------------------------------//
     /* Initialize the input descriptor block (for the           //
     /* Get_Rule_Record routine) and get to work.                //
     /*----------------------------------------------------------//

     /* WS10076 input_desc_block.LID_rule_area =
                            lid_perm_handle->lidra_vec[i].lidra;  //
     /* WS10076 //
     input_desc_block.blk = lid_perm_handle->lidra_vec[i].lidra;

     /*----------------------------------------------------------*/
     /* If last_lid_read is empty . . .                          */
     /*    If input_LID LE last_lid_processed . . .              */
     /*----------------------------------------------------------*/

     /* WS10076S Change the following if phrase
     if (strcmp(rule_type_perm_vec[i].last_lid_read, NULL_CHAR) EQ 0)//
     if (rule_type_perm_vec[i].last_lid_read[0] EQ NULL_CHAR)
                                                           /*WS10076S//
     {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                        "Last lid read is empty");
        requested_record_type = LID_LINE;
        if (strcmp(inputLID,
                   rule_type_perm_vec[i].last_lid_processed) LE 0)
           strcpy(function, "GETFIRST");
        else
           strcpy(function, "GETNEXT");
     }

     /*----------------------------------------------------------//
     /* If last_lid_read is not empty . . .                      //
     /*    If input_LID EQ last_lid_read . . .                   //
     /*    If input_LID GT last_lid_read . . .                   //
     /*    If input_LID LT last_lid_read . . .                   //
     /*       If input_LID LT last_lid_processed . . .           //
     /*       else if input_LID GE last_lid_processed . . .      //
     /*----------------------------------------------------------//

     /* WS10076S Change the following if phrase
     else if (strcmp(rule_type_perm_vec[i].last_lid_read, NULL_CHAR) NE
              0)            //
     else                                                 /* WS10076S //
      if (rule_type_perm_vec[i].last_lid_read[0] NE NULL_CHAR)
                                                            /*WS10076S//
      {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                 "Last lid read is |%s|",
                  rule_type_perm_vec[i].last_lid_read);
        if (strcmp(inputLID, rule_type_perm_vec[i].last_lid_read) EQ 0)
        {
           requested_record_type = KPP_LINE;
           strcpy(function, "GETNEXT");
           memset(rule_type_perm_vec[i].last_lid_read, 0X00,
                  sizeof(rule_type_perm_vec[i].last_lid_read));
        }
        else if (strcmp(inputLID,
                 rule_type_perm_vec[i].last_lid_read) GT 0)
        {
           requested_record_type = LID_LINE;
           strcpy(function, "GETNEXT");
           memset(rule_type_perm_vec[i].last_lid_read, 0X00,
                  sizeof(rule_type_perm_vec[i].last_lid_read));
        }
        else if (strcmp(inputLID,
                        rule_type_perm_vec[i].last_lid_read) LT 0)
        {
           if (strcmp(inputLID,
                      rule_type_perm_vec[i].last_lid_processed) LT 0)
           {
              requested_record_type = LID_LINE;
              strcpy(function, "GETFIRST");
              memset(rule_type_perm_vec[i].last_lid_read, 0X00,
                     sizeof(rule_type_perm_vec[i].last_lid_read));
           }
           else /* input_LID GE last_lid_processed //
           {
              continue;
           }
        }
      }; /* If last_lid_read is not empty . . . //

     //----------------------------------------------------------//
     // Set the last_lid_processed (with the input_LID) and      //
     // clear the last_lid_read                                  //
     //----------------------------------------------------------//

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "Setting last lid processed to |%s|", inputLID);

     strcpy(rule_type_perm_vec[i].last_lid_processed, inputLID);
     memset(rule_type_perm_vec[i].last_lid_read, 0X00,
            sizeof(rule_type_perm_vec[i].last_lid_read));

                end of WS10078T   */

     /*----------------------------------------------------------*/
     /* Innermost loop: Call the Get_Rule_Record routine and     */
     /* process the line that is returned by the routine.        */
     /*----------------------------------------------------------*/
     /* WS10084
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "About to start inner loop");
     rule_type_perm_vec =                               /* WS10078T @/
               lid_perm_handle->rule_type_perm_vec;     /* WS10078T @/

     requested_record_type = $KEY_LINE;                 /* WS10078T @/
     strcpy(function, "GETNEXT");                       /* WS10078T @/
     /*WS10078A adding next command 20APR2020@/
     /* BS10111
     input_desc_block.blk = lid_perm_handle->lidra_vec[i].lidra; @/
     do
     {
        req_line[0] = NULL_CHAR;                        /* WS10078S @/
        switch(requested_record_type)
        {
          case LID_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
  /* WS10078T@/ "Unexpected Get_Rule_Record requesting :LID line");
  /* WS10078T   "Calling Get_Rule_Record requesting :LID line");   @/
  /*        break;                                        WS10078T @/
            rule_type_perm_vec[i].permError_indicator = TRUE;
            rc = ESA_FATAL;
            continue;                                 /*  WS10078T @/
          /* * * * WS10078SG start * * * @/
          case ROLE_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Unexpected Get_Rule_Record requesting :ROLE line");
            rule_type_perm_vec[i].permError_indicator = TRUE;
            rc = ESA_FATAL;
            continue;
            /* * * * WS10078SG end * * * @/
          case $KEY_LINE:
            strcpy(req_line, "$KEY");                   /* WS10078S @/
            /* WS10078S Moved to the end of the switch
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Calling Get_Rule_Record requesting $KEY line");    @/
            break;
          case $PREFIX_LINE:
            strcpy(req_line, "$PREFIX");                /* WS10078S @/
            /* WS10078S Moved to the end of the switch
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Calling Get_Rule_Record requesting $PREFIX line"); @/
            break;
          case KPP_LINE:
            strcpy(req_line, "KPP");                    /* WS10078S @/
            /* WS10078S Moved to the end of the switch
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Calling Get_Rule_Record requesting KPP line");     @/
            break;
          /* WS10078S The ANY_LINE request has been phased out
          case ANY_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Calling Get_Rule_Record requesting ANY line");
            break;                                                 @/
          case PERMISSION_LINE:
            strcpy(req_line, "PERMISSION");            /* WS10078S @/
            /* WS10078S Moved to the end of the switch
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
             "Calling Get_Rule_Record requesting PERMISSION line");@/
            break;
          default:
            strcpy(req_line, "????");                  /* WS10078S @/
            /* WS10078S Moved to the end of the switch
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "Calling Get_Rule_Record requesting ???? line");   @/
            break;
        }
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,         /* WS10078S @/
            "Calling Get_Rule_Record requesting %s line", req_line);

        rc = Get_Rule_Record(
               function,
               &(lid_perm_handle->lidra_vec[i].get_rule_record_handle),
   /* BS10111  get_line_ptr,       @/
   /* BS10111  &input_desc_block,  @/
               lid_perm_handle->lidra_vec[i].lidra,      /* BS10111 @/
/* WS10078S    PERM_RECORD_accounts,                                @/
               requested_record_type,
               sizeof(rule_record),
               "ACFRPTRX",
               &returned_record_type,
               rule_record,
               resource_type,
               admin_params);

        if (rc NE ESA_OK)
        {
           if (rc EQ ESA_WARN) /* end_of_user indication @/
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                              "end of user condition encountered");
              rc = ESA_OK;
              break;
           }
           else if (rc EQ ESA_EOF)  /* end_of_file indication @/
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                              "end of file condition encountered");
              lid_perm_handle->lidra_vec[i].EOF_indicator = TRUE;
              rc = ESA_OK;
              break;
           }
           else if (rc EQ ESA_SKIP) /* permission o/p area too small @/
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "permission output area not large enough");
              rc = ESA_OK;
              continue;
           }
           else
           {
              ESA_DIAG_printf(PLT_COMP_PERMISSION, 6, /*(G)@/
                  "serious Get_Rule_Record error encountered");
            lid_perm_handle->lidra_vec[i].IOError_indicator = TRUE;
              break;
           }
        }

        strcpy(function, "GETNEXT");

        switch(returned_record_type)
        {
          case LID_LINE:
        /*  WS10078T start
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Get_Rule_Record returned a :LID line");
            if (requested_record_type EQ LID_LINE)
            {
               from = strstr(rule_record, "LID: ");
               from += 5;                   /* point to start of lid //
               to = strchr(from, ' ');             /* look for blank //
               len = to - from;                /* calc length of lid //
               memset (lid, 0X00, sizeof(lid));   /* clear lid field //
               strncpy (lid, from, len);     /* copy lid from record //
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     ":LID line for lid |%s|", lid);
               if (strcmp (lid, inputLID) EQ 0)
                  requested_record_type = $KEY_LINE;
               else if (strcmp (lid, inputLID) LT 0)
                  continue;
               else if (strcmp (lid, inputLID) GT 0)
               {
                  strcpy(rule_type_perm_vec[i].last_lid_read, lid);
                  rc = ESA_WARN; /* end_of_user indication //
               }
            }
            else
            WS10078T end   @/
            {
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "unsolicited :LID line");
               rule_type_perm_vec[i].permError_indicator = TRUE;
               rc = ESA_FATAL;
            }
            break;
          /* * * * WS10078SG start * * * @/
          case ROLE_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "unsolicited :ROLE line");
            rule_type_perm_vec[i].permError_indicator = TRUE;
            rc = ESA_FATAL;
            break;
            /* * * * WS10078SG end * * * @/
          case $KEY_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Get_Rule_Record returned a $KEY line");
            if ( (requested_record_type EQ $KEY_LINE) OR
                 (requested_record_type EQ KPP_LINE)  )
            {
               requested_record_type = KPP_LINE;
               memset(prefix, 0X00, sizeof(prefix));
               from = strstr(rule_record, "$KEY(");
               RULE_KWD_VALUE_RTRVR (from,
                                     MAX_PERM_KEY_LEN,
                                     key,
                                     rc,
                                     fromw,
                                     tow,
                                     lenw);
               if (rc NE ESA_OK)
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                                  "$KEY parameter too large");
               }
               strcpy(type, resource_type);
               if (strstr(rule_record, " ROLESET") NE NULL)
    /* WS10078S   requested_record_type = $KEY_LINE;                @/
                  roleset_permission = TRUE;            /* WS10078S @/
               else                                     /* WS10078S @/
                  roleset_permission = FALSE;           /* WS10078S @/
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "$KEY line for key %s type %s", key, type);
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,  /* WS10078S @/
                     "$KEY line - roleset = %d",        /* WS10078S @/
                     roleset_permission);               /* WS10078S @/
            }
            else
            {
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "unsolicited $KEY/KPP line");
               rule_type_perm_vec[i].permError_indicator = TRUE;
               rc = ESA_FATAL;
            }
            break;
          case $PREFIX_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Get_Rule_Record returned a $PREFIX line");
            if (requested_record_type EQ KPP_LINE)
            {
               from = strstr(rule_record, "$PREFIX(");
               RULE_KWD_VALUE_RTRVR (from,
                                     MAX_PERM_PREFIX_LEN,
                                     prefix,
                                     rc,
                                     fromw,
                                     tow,
                                     lenw);
               if (rc NE ESA_OK)
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                                  "$PREFIX parameter too large");
               }
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                     "$PREFIX line for prefix %s", prefix);
            }
            else
            {
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "unsolicited $PREFIX line");
               rule_type_perm_vec[i].permError_indicator = TRUE;
               rc = ESA_FATAL;
            }
            break;
          case PERMISSION_LINE:
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "Get_Rule_Record returned a PERMISSION line");
            /* WS10078S Adding a clause to the 'if' statement below
            if (requested_record_type EQ KPP_LINE)                  @/
            if ( (requested_record_type EQ KPP_LINE) AND/* WS10078S @/
                 (roleset_permission    EQ FALSE)  )    /* WS10078S @/
            {
               found = TRUE;

               rc = Permission_Get_UID(rule_record,
                                       &user_or_group,
                                       &uid_parm,
                                       admin_params);

            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "uid_parm = %p -> %s", uid_parm, uid_parm);
               tow = strchr(uid_parm, ')');
               sprintf(full_uid, "%.*s",
                        tow-uid_parm+1, uid_parm);

            ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "tow = %p -> %s  full_uid = %p -> %s",
                     tow, tow, full_uid, full_uid);
               /*-------------------------------------------@/
               /* If user and direct, there's no need to    @/
               /* call the Permission_Drop_Decision routine @/
               /* because by accounts, direct permissions   @/
               /* are never dropped.                        @/
               /*-------------------------------------------@/

               RULE_KWD_VALUE_RTRVR (uid_parm,
                                     ACF2_UID_SIZE,
                                     only_uid,
                                     rc,
                                     fromw,
                                     tow,
                                        lenw);

               if (Is_UIDMASK_User (only_uid))
                  direct_or_indirect = 'D';
               else
                  direct_or_indirect = 'I';
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                               "direct or indirect uid = %c",
                               direct_or_indirect);

               if (strcmp(lid_perm_handle->lidra_vec[i].rules_type,
                                           "DSET") EQ 0) /* WS10079T @/
                                           /* WS10079T  "DSN") EQ 0) @/
                  strcpy(res_type, "A");
               else if (strcmp(lid_perm_handle->lidra_vec[i].rules_type,
                                                       "RSRC") EQ 0)
                  strcpy(res_type, "R");

               if (direct_or_indirect EQ 'D')
               {
                  rc = ESA_OK;
               }
               else
               {
                  rc = Permission_Drop_Decision(
                              rule_record,
                              res_type,
                              only_uid,
                              'U',
                              direct_or_indirect,
                              admin_params);
               }

               if (rc EQ ESA_FATAL)
               {
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, /*(H)@/
                          component, func,
                          "Permission_Drop_Decision error",
                          16, __LINE__);
                  rc = ESA_FATAL;
                  goto exit;
               }
               else if (rc EQ ESA_SKIP)
                  break;

               /*-------------------------------------------@/
               /* We are now ready to call the              @/
               /* Permission_Value_Builder routine to build @/
               /* the permission data.                      @/
               /*-------------------------------------------@/

               memset(formatted_permission, 0X00,
                                          ACF2_MAX_PERMISSN_SIZE);

               rc = Permission_value_builder(rule_record,
                                             resource_type,
                                             key,
                                             prefix,
                                             full_uid,
                                             direct_or_indirect,
                                             'U', /* user_or_group, @/
                                             ACF2_MAX_PERMISSN_SIZE,
                                             formatted_permission,
                                             admin_params);
               if (rc NE ESA_OK)
               {
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, /*(I)@/
                          component, func,
                          "Permission_value_builder error",
                          16, __LINE__);
                  rc = ESA_FATAL;
                  goto exit;
               }
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                 "Formatted permission: |%s|", formatted_permission);

               if ( (direct_or_indirect       EQ 'D')   AND
                    (direct_perm_addinfo_full EQ FALSE) AND
                    (direct_pair NE NULL)               )
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "ADDINFO_addval strlen %d vallen %d max %d",
                           strlen(formatted_permission),
                           direct_pair->vallen,
                           ACF_ADDINFO_VAL_LEN);
                  rcc = ADDINFO_addval (formatted_permission,
                                        ACF_ADDINFO_VAL_LEN,
                                        ADDINFO_LIST_ENTRY,
                                        direct_pair, dest, msgs);
                  if (rcc EQ ESA_EOF)
                  {
                     CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        @/
/* WS10078ST @/                    direct_pair->keyword,
/* WS10078ST @/                    trimmed_entity, formatted_permission,
/* WS10078ST @/                    strlen(formatted_permission),
/* WS10078ST @/                    direct_pair->vallen,
/* WS10078ST @/                    "permissions");
                     direct_perm_addinfo_full = TRUE;
                     rc = ESA_OK;
/* WS10078KM - Start  Add isIncomplete attribute in addinfo @/
                     rcc = ESA_OK;
                     pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
                     if (pair NE NULL)
                     {
                        if( pair->value[0] NE 'Y')
                           rcc = ADDINFO_updval("Y",
                                                ACF_ADDINFO_VAL_LEN,
                                                pair);
                        if (rcc NE ESA_OK)
                        {
                           sprintf(errmsg,
                                   "Update <%s> keyword failed. rc=%d",
                                   "isIncomplete",rcc);
                           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                         dest, component,func,
                                         errmsg, rcc,__LINE__);
                        }
                     }
/* WS10078KM - Ends @/
                  }
               }

               if ( (direct_or_indirect         EQ 'I')   AND
                    (indirect_perm_addinfo_full EQ FALSE) AND
                    (indirect_pair NE NULL)               )
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "ADDINFO_addval strlen %d vallen %d max %d",
                           strlen(formatted_permission),
                           indirect_pair->vallen,
                           ACF_ADDINFO_VAL_LEN);
                  rcc = ADDINFO_addval (formatted_permission,
                                        ACF_ADDINFO_VAL_LEN,
                                        ADDINFO_LIST_ENTRY,
                                        indirect_pair, dest, msgs);
                  if (rcc EQ ESA_EOF)
                  {
                     CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        @/
/* WS10078ST @/                    indirect_pair->keyword,
/* WS10078ST @/                    trimmed_entity, formatted_permission,
/* WS10078ST @/                    strlen(formatted_permission),
/* WS10078ST @/                    indirect_pair->vallen,
/* WS10078ST @/                    "permissions");
                     indirect_perm_addinfo_full = TRUE;
                     rc = ESA_OK;
/* WS10078KM - Start  Add isIncomplete attribute in addinfo @/
                     rcc = ESA_OK;
                     pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
                     if (pair NE NULL)
                     {
                        if( pair->value[0] NE 'Y')
                           rcc = ADDINFO_updval("Y",
                                                ACF_ADDINFO_VAL_LEN,
                                                pair);
                        if (rcc NE ESA_OK)
                        {
                           sprintf(errmsg,
                                   "Update <%s> keyword failed. rc=%d",
                                   "isIncomplete",rcc);
                           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                         dest, component,func,
                                         errmsg, rcc,__LINE__);
                        }
                     }
/* WS10078KM - Ends @/
                  }
               }
            }
            /* * * * WS10078S start * * * @/
            else if ( (requested_record_type EQ KPP_LINE) AND
                      (roleset_permission    EQ TRUE)     )
            {
               found = TRUE;

               rc = Permission_Get_ROLEUSER(rule_record,
                                            &roleuser_parm,
                                            admin_params);

               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                               "roleuser_parm = %p -> %s",
                               roleuser_parm, roleuser_parm);

               tow = strchr(roleuser_parm, ')');
               sprintf(full_roleuser, "%.*s",
                        tow-roleuser_parm+1, roleuser_parm);

               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                               "full_roleuser = %p -> %s",
                               full_roleuser, full_roleuser);

               /* * * * WS10078SG start * * * @/

               /*-------------------------------------------@/
               /* IF group, we check whether this is a      @/
               /* direct or indirect permission. If it is   @/
               /* a direct permission, we continue. If it   @/
               /* is an indirect permission, we do not      @/
               /* support indirect group permissions.       @/
               /*-------------------------------------------@/
               if (lid_perm_handle->RequiredPermissions EQ
                                                        PERM_TYPE_ROLE)
               {
                  RULE_KWD_VALUE_RTRVR (roleuser_parm,
                                        sizeof(only_roleuser),
                                        only_roleuser,
                                        rc,
                                        fromw,
                                        tow,
                                        lenw);
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                                  "entity = %s  roleuser = %s",
                                  trimmed_entity, only_roleuser);
                  if (strcmp (trimmed_entity, only_roleuser) NE 0)
                  {
                     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                              "permission not for this entity %s",
                              trimmed_entity);
                     continue;               /* skip this permission @/
                  }
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                           "this is direct permission of entity %s",
                           trimmed_entity);
                  direct_or_indirect = 'D';
                  user_or_group = 'G';
                  if (strcmp(lid_perm_handle->lidra_vec[i].rules_type,
                                           "DSET") EQ 0) /* WS10079T @/
                                         /* WS10079T    "DSN") EQ 0) @/
                  strcpy(res_type, "A");
               else if (strcmp(lid_perm_handle->lidra_vec[i].rules_type,
                                                          "RSRC") EQ 0)
                  strcpy(res_type, "R");

                  rc = Permission_Drop_Decision(
                              rule_record,
                              res_type,
                              only_roleuser,
                              user_or_group,
                              direct_or_indirect,
                              admin_params);
               }

               /* * * * WS10078SG end * * * @/

               /*-------------------------------------------@/
               /* If user and direct, there's no need to    @/
               /* call the Permission_Drop_Decision routine @/
               /* because by accounts, direct permissions   @/
               /* are never dropped.                        @/
               /*-------------------------------------------@/

               else if (lid_perm_handle->RequiredPermissions EQ
                                          PERM_TYPE_LID) /* WS10078SG@/
               {                                         /* WS10078SG@/
                  user_or_group = 'U';                   /* WS10078SG@/
                  if ( (strncmp(roleuser_parm, "ROLE(", 5)   EQ 0 ) OR
                       (strncmp(roleuser_parm, "USER(-)", 7) EQ 0 ) )
                     direct_or_indirect = 'I';
                  else
                     direct_or_indirect = 'D';

                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                                  "ROLE / USER is %s permission",
                                  (direct_or_indirect EQ 'I' ?
                                  "indirect" : "direct"));

                  if (strcmp(lid_perm_handle->lidra_vec[i].rules_type,
                                          "DSET") EQ 0) /* WS10079T @/
                                          /* WS10079T  "DSN") EQ 0) @/
                     strcpy(res_type, "A");
               else if (strcmp(lid_perm_handle->lidra_vec[i].rules_type,
                                                       "RSRC") EQ 0)
                     strcpy(res_type, "R");

                  if (direct_or_indirect EQ 'D')
                  {
                     rc = ESA_OK;
                  }
                  else
                  {
                     /*WS10078A pass the role/user value including the
                       paranthesis to differentiate from UID which is
                       passed as the value itself only @/
  /*WS10078A@/       tempRoleUser = strchr(roleuser_parm,'(');
  /*WS10078A@/       memcpy(only_uid,tempRoleUser,strlen(tempRoleUser));
                     rc = Permission_Drop_Decision(
                                 rule_record,
                                 res_type,
                                 only_uid,
                                 'U',
                                 direct_or_indirect,
                                 admin_params);
                  }
               }                                         /* WS10078SG@/

               if (rc EQ ESA_FATAL)
               {
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, /*(H)@/
                          component, func,
                          "Permission_Drop_Decision error",
                          16, __LINE__);
                  rc = ESA_FATAL;
                  goto exit;
               }
               else if (rc EQ ESA_SKIP)
                  break;

               /*-------------------------------------------@/
               /* We are now ready to call the              @/
               /* Permission_Value_Builder routine to build @/
               /* the permission data.                      @/
               /*-------------------------------------------@/

               memset(formatted_permission, 0X00,
                                          ACF2_MAX_PERMISSN_SIZE);

               rc = Permission_value_builder(rule_record,
                                             resource_type,
                                             key,
                                             prefix,
                                             full_roleuser,
                                             direct_or_indirect,
/* WS10078SG Do not hard-code this parm      'U', /* user_or_group, @/
/* WS10078SG @/                              user_or_group,
                                             ACF2_MAX_PERMISSN_SIZE,
                                             formatted_permission,
                                             admin_params);
               if (rc NE ESA_OK)
               {
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, /*(I)@/
                          component, func,
                          "Permission_value_builder error",
                          16, __LINE__);
                  rc = ESA_FATAL;
                  goto exit;
               }
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                 "Formatted permission: |%s|", formatted_permission);


 /*WS10078A*   if ( (direct_or_indirect            EQ 'I')   AND @/
 /*WS10078A@/  if ( (direct_or_indirect            EQ 'D')   AND
                    (role_direct_perm_addinfo_full EQ FALSE) AND
                    (role_direct_pair              NE NULL)  )
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "ADDINFO_addval strlen %d vallen %d max %d",
                           strlen(formatted_permission),
                           role_direct_pair->vallen,
                           ACF_ADDINFO_VAL_LEN);
                  rcc = ADDINFO_addval (formatted_permission,
                                        ACF_ADDINFO_VAL_LEN,
                                        ADDINFO_LIST_ENTRY,
                                        role_direct_pair, dest, msgs);
                  if (rcc EQ ESA_EOF)
                  {
                     CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        @/
/* WS10078ST @/                    role_direct_pair->keyword,
/* WS10078ST @/                    trimmed_entity, formatted_permission,
/* WS10078ST @/                    strlen(formatted_permission),
/* WS10078ST @/                    role_direct_pair->vallen,
/* WS10078ST @/                    "permissions");
                     role_direct_perm_addinfo_full = TRUE;
                     rc = ESA_OK;
/* WS10078KM - Start  Add isIncomplete attribute in addinfo @/
                     rcc = ESA_OK;
                     pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
                     if (pair NE NULL)
                     {
                        if( pair->value[0] NE 'Y')
                           rcc = ADDINFO_updval("Y",
                                                ACF_ADDINFO_VAL_LEN,
                                                pair);
                        if (rcc NE ESA_OK)
                        {
                           sprintf(errmsg,
                                   "Update <%s> keyword failed. rc=%d",
                                   "isIncomplete",rcc);
                           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                         dest, component, func,
                                         errmsg, rcc, __LINE__);
                        }
                     }
/* WS10078KM - Ends @/
                  }
               }
               /* WS10078T changed from 'D' to 'I' per Selig's req: @/
               if ( (direct_or_indirect              EQ 'I')   AND
                    (role_indirect_perm_addinfo_full EQ FALSE) AND
                    (role_indirect_pair              NE NULL)  )
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "ADDINFO_addval strlen %d vallen %d max %d",
                           strlen(formatted_permission),
                           role_indirect_pair->vallen,
                           ACF_ADDINFO_VAL_LEN);
                  rcc = ADDINFO_addval (formatted_permission,
                                        ACF_ADDINFO_VAL_LEN,
                                        ADDINFO_LIST_ENTRY,
                                        role_indirect_pair, dest, msgs);
                  if (rcc EQ ESA_EOF)
                  {
                     CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        @/
/* WS10078ST @/                    role_indirect_pair->keyword,
/* WS10078ST @/                    trimmed_entity, formatted_permission,
/* WS10078ST @/                    strlen(formatted_permission),
/* WS10078ST @/                    role_indirect_pair->vallen,
/* WS10078ST @/                    "permissions");
                     role_indirect_perm_addinfo_full = TRUE;
                     rc = ESA_OK;
/* WS10078KM - Start  Add isIncomplete attribute in addinfo @/
                     rcc = ESA_OK;
                     pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
                     if (pair NE NULL)
                     {
                        if( pair->value[0] NE 'Y')
                           rcc = ADDINFO_updval("Y",
                                                ACF_ADDINFO_VAL_LEN,
                                                pair);
                        if (rcc NE ESA_OK)
                        {
                           sprintf(errmsg,
                                   "Update <%s> keyword failed. rc=%d",
                                   "isIncomplete",rcc);
                           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                         dest, component, func,
                                         errmsg, rcc, __LINE__);
                        }
                     }
/* WS10078KM - Ends @/
                  }
               }
               /* * * * WS10078SG start * * * @/
               if ( (direct_or_indirect             EQ 'D')   AND
                    (role_direct_group_addinfo_full EQ FALSE) AND
                    (role_direct_group_pair         NE NULL)  )
               {
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                           "ADDINFO_addval strlen %d vallen %d max %d",
                           strlen(formatted_permission),
                           role_direct_group_pair->vallen,
                           ACF_ADDINFO_VAL_LEN);
                  rcc = ADDINFO_addval (formatted_permission,
                                ACF_ADDINFO_VAL_LEN,
                                ADDINFO_LIST_ENTRY,
                                role_direct_group_pair, dest, msgs);
                  if (rcc EQ ESA_EOF)
                  {
                     CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        @/
/* WS10078ST @/                    role_direct_group_pair->keyword,
/* WS10078ST @/                    trimmed_entity, formatted_permission,
/* WS10078ST @/                    strlen(formatted_permission),
/* WS10078ST @/                    role_direct_group_pair->vallen,
/* WS10078ST @/                    "permissions");
                     role_direct_group_addinfo_full = TRUE;
                     /* Set the next 4 fields to TRUE so that (in    @/
                     /* the case of group aggregation where the      @/
                     /* ADDINFO area is full) we leave the DO WHILE  @/
                     /* loop immediately with rc = ESA_OK.           @/
                     direct_perm_addinfo_full       = TRUE;
                     indirect_perm_addinfo_full     = TRUE;
                     role_direct_perm_addinfo_full  = TRUE;
                     role_indirect_perm_addinfo_full= TRUE;
                     rc = ESA_OK;
/* WS10078KM - Start  Add isIncomplete attribute in addinfo @/
                     rcc = ESA_OK;
                     pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs);
                     if (pair NE NULL)
                     {
                        if( pair->value[0] NE 'Y')
                           rcc = ADDINFO_updval("Y",
                                                ACF_ADDINFO_VAL_LEN,
                                                pair);
                        if (rcc NE ESA_OK)
                        {
                           sprintf(errmsg,
                                   "Update <%s> keyword failed. rc=%d",
                                   "isIncomplete",rcc);
                           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                         dest, component,func,
                                         errmsg, rcc,__LINE__);
                        }
                     }
/* WS10078KM - Ends @/
                  }
               }
               /* * * * WS10078SG end * * * @/
            }
            /* * * * WS10078S end * * * @/
            else
            {
               ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "unsolicited permission line");
               rule_type_perm_vec[i].permError_indicator = TRUE;
               rc = ESA_FATAL;
            }
            break;
          default:
            rule_type_perm_vec[i].permError_indicator = TRUE;
            rc = ESA_FATAL;
            break;
        }

        if (rc EQ ESA_SKIP) /* reset permission_drop_decision rc @/
           rc = ESA_OK;

     } while ( (rc EQ ESA_OK) AND
               ( (direct_perm_addinfo_full        EQ FALSE) OR
                 (indirect_perm_addinfo_full      EQ FALSE) OR
/* WS10078S @/   (role_direct_perm_addinfo_full   EQ FALSE) OR
/* WS10078S @/   (role_indirect_perm_addinfo_full EQ FALSE) ) );

     if (rc EQ ESA_SKIP)
        rc = ESA_OK;

     if ( (direct_perm_addinfo_full   EQ TRUE) AND
          (indirect_perm_addinfo_full EQ TRUE) )
     /* break;                                         WS10078T @/

     if (rc EQ ESA_FATAL)
     {
/* WS10078SG Changed variable name
       sprintf(errmsg,"Error while processing LID %s", inputLID);/*(K)@/
       sprintf(errmsg,"Error while processing LID/ROLE %s",/*WS10078SG@/
               trimmed_entity);                            /*WS10078SG@/
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func, errmsg, 16, __LINE__);
       lid_perm_handle->lidra_vec[i].IOError_indicator = TRUE;
     /*break;                                          WS10078T @/
     }
  /*  for loop moved to Ge_User_XREFAndPermissions  WS10078T
  } /* for (i=0; i LT lid_perm_handle->lidra_vec_num; i++) outer loop @/

  if (rc EQ ESA_OK)
  {
     if (found EQ FALSE)
     {
     /* CTSAMSG_print(ACF2_NO_PERMISSION, msgs, NULL, dest); BS10108T @/
        *perms_exist = FALSE;                             /* BS10108T @/
     }
     else                                                 /* BS10108T @/
        *perms_exist = TRUE;                              /* BS10108T @/
  }

  /*-------------------------------------------@/
  /* If the IOError_indicator is 'on' in all   @/
  /* vector entries, set the error indicator   @/
  /* in the permissions handle.                @/
  /*-------------------------------------------@/

  for (i=0; i LT lid_perm_handle->lidra_vec_num; i++)
  {
     if (lid_perm_handle->lidra_vec[i].IOError_indicator EQ FALSE)
        goto exit;
  };

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "IOError_indicator on in all vector entries");
  lid_perm_handle->error = TRUE;
  exit:
  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, rc);
  return rc;
}
    WS10084 */

/* * * * * * * * WS10075S End * * * * * * * */
/* WS10075K - Start */

/********************************************************************
 * Procedure Name: Permission_locate_data
 ********************************************************************
 * Description : Parse the permission and return the data requested
 *               Following is the input for function
 *               BYKEY - Return the value of keyword in output
 *               The keyword to find is mandatory for BYKEY
 *               function.
 *               PERMDATA - Return permission part
 *               RESNAME - Return resource name along with its type
 *               in a format TYPE(RESNAME)
 *
 * Input       : Function
 *               pointer to rule record (I)
 *               keyword to find (I)
 *               requested data or NULL (O)
 *
 * Output      : Formatted permission output
 *
 * NOTE        : Memory should be allocated by caller
 *               for requested data.
 *
 * Return Value: ESA_OK(0)    - OK with requested_data with data
 *               ESA_FATAL(4) - for PERMDATA, if no data after UID
 *                              (it means its a PREVENT permission)
 *               ESA_EOF(8)   - keyword not found with requested_data
 *                              to NULL
 *******************************************************************/
 static int Permission_locate_data (
              Permission_locate_data_functions     data_funcs,
              char                               * rule_record,
              char                               * kwd_to_find,
              char                              ** requested_data,
              ADMIN_PARAMS_rec_typ               * admin_params)
 {
   static char       func[] = "Permission_locate_data";
   int               rc = 0;
   char             *strPtr1 = NULL;
   char             *strPtr2 = NULL;
   char             *strPtrRP = NULL;
   char             *chPtr = NULL;
   char              ch = NULL_CHAR;
   char              errmsg[100] = "";

   CTSAMSG_HANDLE_rec_ptr      msgs;
   CTSAMSG_DEST_TABLE_rec_ptr  dest;

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_enter(PLT_COMP_PERMISSION, 2, func);

   ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
            "data_funcs (%d), rule_record (%s), kwd_to_find (%s)",
            data_funcs, rule_record, kwd_to_find);

   if( kwd_to_find EQ NULL)
   {
      rc = 8;
      sprintf(errmsg, "Key to find is NULL.");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, errmsg, 16, __LINE__);
      goto exit;
   }

   if( rule_record EQ NULL)
   {
      rc = 8;
      sprintf(errmsg, "Rule record is NULL.");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, errmsg, 16, __LINE__);
      goto exit;
   }


   /* Check if the keyword is in the rule_record. If found in
      rule then make sure that it is not part of DATA field.
   */
   if(data_funcs EQ BYKEY_Function)
   {
      strPtr1 = strstr(rule_record, kwd_to_find);
      if (strPtr1 NE NULL)
      {
        /* Check if there is DATA field in rule. If DATA is
           present then we want to check if keyword is part
           of DATA or not.
        */
        strPtr2 = strstr(rule_record, "DATA(");
        if (strPtr2 NE NULL)
        {
           /* Check if keyword is present before DATA attribute. */

           if (strPtr1 LT strPtr2)
              /* Keyword is found before 'DATA('. Return the
                 pointer to the keyword found.                   */
             *requested_data = strPtr1;
           else
           {
              /* Look for close bracket after DATA( to find
                 the keyword in remaining part strPtrRP of rule     */
              strPtrRP = strchr(strPtr2, ')');
              strPtrRP++;

               /* Check if keyword is present before DATA attribute.*/

               strPtr1 = strstr(strPtrRP, kwd_to_find);
               if (strPtr1 NE NULL)
                  /* Keyword is found after 'DATA('.
                     pointer to the keyword found.                   */
                 *requested_data = strPtr1;
               else
               {
                  /* Keyword is not found before and after data
                     It is possible it is a part of data and we
                     are want to return NULL with rc = ESA_EOF(8)   */
                  ESA_DIAG_printf(PLT_COMP_PERMISSION, 9,
                         "Keyword %s is a part of DATA", kwd_to_find);
                  *requested_data = NULL;
                  rc = 8;
               }
           }
        }
        else
        {
           /* Keyword DATA is not found in rule. Return the
              pointer to the keyword found.                         */
           *requested_data = strPtr1;
        }
      }
      else
      {
         /* Keyword is not found in rule return null and ESA_EOF(8) */
         *requested_data = NULL;
         rc = 8;
      }
   } /* ENDIF BYKEY_Function */
   else
   {
      /*Return resource name */
      if( data_funcs EQ RESNAME_Function)
      {
         strPtr1=strstr(rule_record, "UID(");
         if (strPtr1 EQ NULL)                           /* WS10078SG */
            strPtr1=strstr(rule_record, "ROLE(");       /* WS10078SG */
         if (strPtr1 EQ NULL)                           /* WS10078SG */
            strPtr1=strstr(rule_record, "USER(");       /* WS10078SG */
         if (strPtr1 EQ NULL)                           /* WS10078SG */
         {                                              /* WS10078SG */
            rc = 8;                                     /* WS10078SG */
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,    /* WS10078SG */
              dest, component, func,                    /* WS10078SG */
              "No UID(, ROLE(, or USER( in permission", /* WS10078SG */
              16, __LINE__);                            /* WS10078SG */
            goto exit;                                  /* WS10078SG */
         }                                              /* WS10078SG */

         /* Check if strPtr1 and data are pointing to "UID(".
            If it is then there is no resource                */
         if (rule_record+1 NE strPtr1)
         {
           *requested_data = rule_record+1;
         }
         else
         {
            ESA_DIAG_printf(PLT_COMP_PERMISSION, 9,
                            "Could not locate resource name.");
            *requested_data = NULL;
            rc = 8;
         }
      } /* ENDIF RESNAME_Function */
      else
      {
         /* Return part of data after UID(xxx) */
         if (data_funcs EQ PERMDATA_Function)
         {
            strPtr1 = strstr(rule_record, "UID(");
            if (strPtr1 EQ NULL)                        /* WS10078SG */
               strPtr1 = strstr(rule_record, "ROLE(");  /* WS10078SG */
            if (strPtr1 EQ NULL)                        /* WS10078SG */
               strPtr1 = strstr(rule_record, "USER(");  /* WS10078SG */
            if (strPtr1 EQ NULL)                        /* WS10078SG */
            {                                           /* WS10078SG */
               rc = 4;                                  /* WS10078SG */
               /* No need to print an error message here   WS10078SG
                  because an error message is printed      WS10078SG
                  when we return to the caller.            WS10078SG */
               goto exit;                               /* WS10078SG */
            }                                           /* WS10078SG */
            strPtr2 = strchr(strPtr1, ')');
            /* WS10079T
            if ( (*strPtr2+1) NE NULL_CHAR)                  WS10079T */
            if ( *(strPtr2+1) NE NULL_CHAR)               /* WS10079T */
               *requested_data = strPtr2 + 2; /* After UID(uid) + ' ' */
            else
            {
               /* If no data after UID it means it is PREVENT */
               *requested_data = NULL;
               /* WS10079T  rc = 4;  */
            }
         } /* ENDIF PERMDATA_Function */
      }
   }
   exit:;
   /*
   if (want_diag2)                                    /* WS10084 @/
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,          /* WS10084 @/
            "rc (%d), requested_data (%s)",           /* WS10084 @/
            rc, *requested_data);                     /* WS10084 @/
   */

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
            "rc (%d), requested_data (%s)",
            rc, *requested_data);
     ESA_DIAG_exit(PLT_COMP_PERMISSION, 2, func, rc);
     return rc;
 }

/******************************************************************
 * Procedure Name: Permission_value_builder
 ******************************************************************
 * Description : Create permission value by concatenating data
 *               in one of the following Permission structures:
 *               1. Type(name) has permission [key,prefix,
 *                  UID/ROLE/USER]
 *               For
 *               Account direct permission when permission with
 *               USER() (roleset)
 *               Group direct permission (we know the group type
 *               so UID/ROLE is not needed)
 *               2. Type(name) UID(uid)/ROLE(role-name) has
 *                  permission [key,prefix/UID/USER/ROLE]
 *               For Account direct permission & Account indirect
 *               permission
 *
 * Input       : pointer to rule record
 *               resource type
 *               key
 *               prefix
 *               uid
 *               is direct or indirect permission
 *               entity type    WS10084 : U when indirect
 *               user_or_group  WS10084 : this is the real U or G
 *               permission area length
 * Output      : Formatted permission output
 *
 * Return Value: ESA_OK or ESA_FATAL
 ******************************************************************/
 static ESA_RC Permission_value_builder(
                        char                   * rule_record,
                        char                   * resource_type,
                        char                   * key,
                        char                   * prefix,
                        char                   * uid,
                        char                     is_direct_perm,
                        char                     entity_type,
         /* WS10084 */  char                     user_or_group,
         /* WS10084 */  int                      roleset_permission,
                        int                      permission_attr_len,
                        char                   * permission_attr,
                        ADMIN_PARAMS_rec_typ   * admin_params        )
{
  static char                 func[] = "Permission_value_builder";
  ESA_RC                      rc = ESA_OK;
  int                         int_rc = 0;
  ACE_USER_typ                res_name_and_type="";
  /* Max Resource len + max key len + max UID len + buffer */
  char                        key_prefix_uid_attr[256+40+25+3] = "";
  char                        errmsg[100]="";
  char                        one_space[] = " ";
  char                      * rule_permission = NULL;
  /* char                        rule_permission[1024]="\0";   */
  int                         len = 0, buff_overflow = 0;
  char                        vol[ACF2_VOLSER_SIZE] = "";
  char                      * fromw;
  char                      * tow;
  int                         lenw;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 2, func);

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "rule_record - %.140s, resource_type - %s",
                  rule_record,resource_type);
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "key - %s,prefix - %s, uid - %s,is_direct_perm-%c",
                  key, prefix, uid, is_direct_perm);
  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "etity_type - %c, permission_attr_len - %i",
                  entity_type,permission_attr_len);

  /* Call Permission_dsnrsrc_key_prefix_builder to get the resource
     and type in type(resource) format and KEY, PREFIX, UID, USER,
     ROLE in [key,prefix/UID/USER/ROLE] format.
  */
  /*
  if (want_diag2)  /* WS10084 @/
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
        "Before Permission_dsnrsrc_key_prefix_handler \n");
  }
  */
  rc = Permission_dsnrsrc_key_prefix_handler(
                                        "BUILD",
                                        rule_record,
                                        resource_type,
                                        key,
                                        0,
                                        prefix,
                                        0,
                                        res_name_and_type,
                                        sizeof(res_name_and_type),
                                        key_prefix_uid_attr,
                                        sizeof(key_prefix_uid_attr),
                  /* WS10084 */         is_direct_perm,
                  /* WS10084 */         user_or_group,
                  /* WS10084 */         roleset_permission,
                                        PLT_COMP_PERMISSION,
                                        admin_params );
  /*
  if (want_diag2)  /* WS10084 @/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
     "After  Permission_dsnrsrc_key_prefix_handler. rc = %d \n",rc);
  */

  if(rc NE ESA_OK)
  {
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,                   /* WS10084 */
      "prefix_handler failed: rule_record - %.140s, resource_type - %s",
                  rule_record,resource_type);
    rc = ESA_FATAL;
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                  "Failed to build key prefix", rc, __LINE__);
    goto exit;
  }
  /* WS10076 - this routine is not available here... and is not needed
  Reset_Field(permission_attr,
              permission_attr_len,
              0X00,
              NULL);  */
  memset(permission_attr, 0X00, permission_attr_len);     /* WS10076 */

  len = strlen(res_name_and_type) + 1;
  if(len LT permission_attr_len)
  {
     strcpy(permission_attr,res_name_and_type);
     strcat (permission_attr,one_space);
  }
  else
  {
     rc = ESA_FATAL;
     buff_overflow = 2;
     /*
     if (want_diag1)  /* WS10084 @/
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
       "Buffer overflow 1 \n");
     */
     goto exit;
  }

  /* If VOLUME is present then add VOLUME to permission.
     No error if VOLUME is not present                    */
  /*
  if (want_diag2)  /* WS10084 @/
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
        "Before RULE_KWD_VALUE_RTRVR \n");
  }
  */
  int_rc = Permission_locate_data(BYKEY_Function,
                                  rule_record,
                                  "VOL(",
                                  &rule_permission,
                                  admin_params);
  /*
  if (want_diag2)  /* WS10084 @/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
     "After  RULE_KWD_VALUE_RTRVR int_rc = %d \n",int_rc);
  */

  if (int_rc EQ 0)
  {
     RULE_KWD_VALUE_RTRVR (rule_permission,
                           ACF2_VOLSER_SIZE,
                           vol,
                           rc,
                           fromw,
                           tow,
                           lenw);
     if (rc NE ESA_OK)
     {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                       "VOL in rule record too large", 16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
     }

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "vol = |%s|", vol);

     strcat(permission_attr,"VOL(");
     strcat(permission_attr,vol);
     strcat(permission_attr,") ");
  }

  /* * * * WS10078S start * * * */
  if ( (entity_type EQ 'U')                 AND
       (is_direct_perm EQ 'I')              AND
       ( (strncmp(uid, "ROLE(", 5)   EQ 0 ) OR
         (strncmp(uid, "USER(-)", 7) EQ 0 ) ) )
  {
     len = len + strlen(uid) + 1;
     if (len LT permission_attr_len)
     {
        strcat(permission_attr,uid);
        strcat(permission_attr,one_space);
     }
     else
     {
        rc = ESA_FATAL;
        buff_overflow = 1;
        /*
        if (want_diag2)  /* WS10084 @/
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
         "Buffer overflow 2 \n");
        */
        goto exit;
     }
  }
  /* * * * WS10078S end * * * */

  /* If the entity is user 'U' then concatenate UID to permission */
  /* WS10078S Add 'else' to this 'if' statement
  if (entity_type EQ 'U')                                           */
  else if (entity_type EQ 'U')                          /* WS10078S */
  {
    if( (*uid NE '\0') )
    {
       len = len + strlen(uid) + 1;
       if(len LT permission_attr_len)
       {
          strcat(permission_attr,uid);
          strcat(permission_attr,one_space);
       }
       else
       {
          rc = ESA_FATAL;
          buff_overflow = 1;
        /*
        if (want_diag2)  /* WS10084 @/
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
         "Buffer overflow 3 \n");
        */
          goto exit;
       }
    }
    else
    {
      rc = ESA_FATAL;
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                    "UID is empty for user", rc, __LINE__);
      goto exit;
    }
  }

  /* Lets find the remaining permission and append it */
  /*
  if (want_diag2)  /* WS10084 @/
  {
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
        "Before Permission_locate_data 1 \n");
  }
  */
  int_rc = Permission_locate_data(PERMDATA_Function,
                              rule_record,
                              "PERMDATA",
                              &rule_permission,
                              admin_params);

  /*
  if (want_diag2)  /* WS10084 @/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
     "After  Permission_locate_data  1 int_rc = %d \n",int_rc);
  */

  if(int_rc NE 0 )
  {
     rc = ESA_FATAL;
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                   "No permission data found for user", rc, __LINE__);
     goto exit;
  }

  len = len + strlen(rule_permission)
                   + strlen(key_prefix_uid_attr) + 4 + 1;
  if(len LT permission_attr_len)
  {
     /* concatenate has and one space to permission_attr */
     strcat(permission_attr,"has ");
     strcat(permission_attr,rule_permission);
     strcat(permission_attr,one_space);
  }
  else
  {
     rc = ESA_FATAL;
     buff_overflow = 1;
        /*
        if (want_diag2)  /* WS10084 @/
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
         "Buffer overflow 4 \n");
        */
     goto exit;
  }
  /* Concatenate key, prefix data received.length is already checked */
  if(key_prefix_uid_attr[0] NE '\0')
     strcat(permission_attr,key_prefix_uid_attr);
  else
  {
     rc = ESA_FATAL;
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                   "No key prefix data found for user", rc, __LINE__);
     goto exit;
  }

  exit:;
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                   "rc (%d), permission_attr (%s), buff_overflow (%d)",
                   rc, permission_attr, buff_overflow);

    if(buff_overflow EQ 1)
    {
       sprintf(errmsg,"%s allocated len (%d) actual len (%d)",
               "Buffer overflow for permission_attr",
               permission_attr_len, len);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, errmsg, rc, __LINE__);
    }

  /*
  if (want_diag2)  /* WS10084 @/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6 ,
     "return from %s  rc = %d \n",func,rc);
  */

    ESA_DIAG_exit(PLT_COMP_PERMISSION, 2, func, rc);
    return rc;
}

/* WS10075K - End  */

/* WS10075 - start */
/******************************************************************
 * Procedure Name: ACF2_Get_ACFRPTRX_Report
 *                             (old name was ACF2_get_LID_rules)
 ******************************************************************
 * Description   : This function gets the permissions from ACF2 for
 *                 the requested LIDs. This is done by calling
 *                 ACFRPTRX, intercepting its output and saving it
 *                 in buffers in memory.
 *
 * Input         : req_type   - request type:
 *                              GET - get the permissions from ACF2
 *                              TERM - free all areas.
 *                 lid_perm_handle - main handle used for handling
 *                              permissions. This hanlde is managed
 *                              by ts highr program.
 *
 * Output        : this routine allocated the LID_RULE_AREA vector,
 *                 pointing to the LID_RULE_AREA blocks containing
 *                 all the requested permissions.
 *
 *
 * Return Value  :
 *                 ESA_OK              - User retrieved ok
 *                 ESA_FATAL           - No user found matching criteria
 *********************************************************************/
/*WS10078A static ESA_RC  ACF2_get_LID_rules (  */
/*WS10078T static ESA_RC  ACF2_Get_ACFRPTRX_Report(         *WS10078A*/
/*WS10078T no longer static because called from CTSBGUS     *WS10078T*/
/* WS10084 the whole routine is removed
ESA_RC ACF2_Get_ACFRPTRX_Report(                           /*WS10078T@/
                             char                    * req_type,
                             LID_PERM_handle_rec_typ * lid_perm_handle,
                             ADMIN_PARAMS_rec_typ    * admin_params)
{

 /*************************************************************
 * Varaibles                                                  *
 *************************************************************@/
 /* WS10078A static         char func[]="ACF2_Get_LID_rules"; @/
 static         char func[]="ACF2_Get_ACFRPTRX_Report"; /*WS10078A@/

 ESA_RC         rc = ESA_OK;

 /* BS10111 IDB_GETRUOBLINE_rec_typ  getmemline_IDB;  @/

 void        * p_rtn = NULL;
 int           int_rc = 0;
 int           i = 0;
 int           dbglvl = 0;
 char          pgm[9] = "";
 /* BS10111 char          errmsg[80] = "";    @/
 char          errmsg[170] = "";                          /* BS10111 @/
 char          entity[16] = "";                          /* WS10078SG@/
 /* BS10110 int           skip_sprntf = FALSE;      /@ WS10078ST@/   @/
 int           rule_type_num = 0;
 int           act_rc = 0;
 int           att_rc = 0;
 int           deact_rc = 0;
 int           task_rc = 0;
 int           task_rs = 0;
 char          task_abend = ' ';         /* S / U / ' ' @/
 char          parm_type = 'P';
 char          s0 = 'N';

 char          mo1 = ' ';                /* Many or 1   @/
 char          ruo[8];                                    /* BS10111 @/
 LID_RULE_AREA_vec_rec_typ   * LRA_vec = NULL;
 CTS2RX_error_block_rec_typ    rxe;
 CTS2RX_error_block_rec_typ    deact_rxe;
 CTS2RX_error_block_rec_typ  * curr_rxe = NULL;
 rptrx_parm_type             rptrx_parm;
 /* BS10111 REXX@UTL_output_blk_rec_typ * ruo = NULL;  @/

 /*
  *    ignore list for CTS2RXO
  *
  *    the "full" field indicates whether we should ignore a line
  *    containing a specific character only (for example, a line
  *    containing only blanks).
  *    when this is required, len is 1, full is x'ff' and data
  *    contains the character repeated in the line.
  *
  *    the last line of the table contains len=0.
  @/

 static REXX@UTL_output_ignlist_rec_typ ACFRPTRX_output_ignore_list[] =
  {
    { 44, 0,    "CA ACF2 - ACFRPTRX - LOGONID ACCESS REPORT -"  },
    { 5,  0,    "DATE "                                         },
    { 30, 0,    "LID FILE PROCESSING COMPLETE, "                },
    { 31, 0,    "RULE FILE PROCESSING COMPLETE, "               },
    { 26, 0,    "ROLE PROCESSING COMPLETE, "     /* WS10078SG@/ },
    { 8,  0,    "STORED: "                                      },
    { 1,  0xFF, " "                                             },
    { 0,  0,     " "                                            }
  } ;
   /* BS10111 - the line below was removed from the ignore list
                because we want to print it in case of an error
    { 18, 0,    "INPUT PARAMETERS: "                            }, @/

 ACF2_PARAMS_rec_typ       * params_ptr = NULL;
 COMMON_PARAMS_rec_typ     * cmnprms = NULL;              /* BS10111 @/
 ASM_RTN_TYP               * p_ctsaruh = NULL;            /* BS10111 @/
 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 /*
  *   initialization
  @/

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  /* BS10111 params_ptr = admin_params->apiinit_handle;   @/
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  memcpy(ruo, p_ruob_null, 8); /* Initialize the ruob addr.  BS10111 @/

  if (lid_perm_handle EQ NULL)
  {
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                  dest, component,func,
                  "Parameters error",
                  16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

  dbglvl = (int)ESA_DIAG_get_debug_level(                 /* BS10111 @/
                                  PLT_COMP_PERMISSION);   /* BS10111 @/
  if ( dbglvl GT 0   AND   dbglvl NE 77)                  /* BS10111 @/
    dbglvl = 1;                                           /* BS10111 @/

  /*                                                       * BS10111 *
   *   Verify that common_params exist and keep            * BS10111 *
   *   its address and ctsaruh address.                    * BS10111 *
   @/                                                     /* BS10111 @/
  /* IS10184 GET_P_CTSARUH(params_ptr, cmnprms, p_ctsaruh) * BS10111 @/
  GET_CMNPRMS_PROG(admin_params, cmnprms, p_ctsaruh,      /* IS10184 @/
                     p_ctsaruh, rc, errmsg)               /* IS10184 @/
  if (rc NE ESA_OK)    /* environmental error ? */        /* BS10111 @/
  {                                                       /* Is10184 @/
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,        /* IS10184 @/
                  component, func, errmsg,                /* IS10184 @/
                  rc, __LINE__);                          /* IS10184 @/
    goto exit;                                            /* BS10111 @/
  };                                                      /* IS10184 @/

  params_ptr = admin_params->apiinit_handle;              /* IS10184 @/

  /*********************************************
   *                  GET
   ********************************************@/
  if (strcmp(req_type, "GET") EQ 0)
  {
    /*** WS10078A start **@/
    if (lid_perm_handle->lidra_vec_num GT RULE_TYPE_NUM)
    {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                  "Parameters error", 16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
    }
    rule_type_num = RULE_TYPE_NUM; /* set default @/
    if (lid_perm_handle->lidra_vec_num GT 0)
    {
     rule_type_num = lid_perm_handle->lidra_vec_num;
    }
    /*** WS10078A end **@/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,"rule_type_num=<%d>",
                rule_type_num);               /*WS10078A@/

    /* Reset output fields  @/
    lid_perm_handle->lidra_vec = NULL;
    lid_perm_handle->lidra_vec_num = 0;    /*WS10078A ???@/

    /*
     *    Verify that SYSPRINT exists. If not, error.
     @/
    rc = OS_MVS_ddinfo("SYSPRINT", NULL, TRUE,
                       dest, msgs, 0);
    if (rc NE ESA_OK)
    {
      if (rc EQ ESA_NOT_SUPP)
        CTSAMSG_print(DD_MISSING,msgs, NULL, dest,
                      "SYSPRINT");
      /* For any other error, OS-MVS_ddinfo issues the message @/
      rc = ESA_FATAL;
      goto exit;
    }

    /*
     *    load CTS2RXS and CTSAATC
     @/
    /* BS10111 - cts2rxf does not exist any more
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "p_CTS2RXS = %p    p_CTS2RCF = %p   p_CTSAATC = %p",
                params_ptr->p_cts2rxs, p_cts2rxf, p_ctsaatc);  @/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,               /* BS10111 @/
                "p_CTS2RXS = %p    p_CTSAATC = %p",       /* BS10111 @/
                params_ptr->p_cts2rxs, p_ctsaatc);        /* BS10111 @/
    /* BS10111 - p_cts2rxf does not exist any more
    if (params_ptr->p_cts2rxs EQ NULL  AND /@ first time ?        @/
        p_cts2rxf EQ NULL     AND
        p_ctsaatc EQ NULL)    @/
    if (params_ptr->p_cts2rxs EQ NULL AND /* first time ?    BS10111 @/
        p_ctsaatc EQ NULL)                                /* BS10111 @/
    {
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
      "going to load the modules...");
      strcpy(pgm, "CTS2RXS ");
      int_rc = (*(ASM_RTN_TYP *)&ctsaldm)      /* load CTS2RXS     @/
                 (pgm, "       ", &p_rtn);
      if (int_rc EQ 0)
      {
        params_ptr->p_cts2rxs = (ASM_RTN_TYP *)p_rtn;

        /* BS10111 - this program is not needed any more
        strcpy(pgm, "CTS2RXF ");
        int_rc = (*(ASM_RTN_TYP *)&ctsaldm)  /@ load CTS2RXF       @/
                   (pgm, "       ", &p_rtn);
        if (int_rc EQ 0)
        {
          p_cts2rxf = (ASM_RTN_TYP *)p_rtn;
          end of removed code - BS10111 @/

          strcpy(pgm, "CTSAATC ");
          int_rc = (*(ASM_RTN_TYP *)&ctsaldm)  /* load CTSAATC     @/
                     (pgm, "       ", &p_rtn);
          if (int_rc EQ 0)
            p_ctsaatc = (ASM_RTN_TYP *)p_rtn;

        /* BS10111 }  @/
      }

      if (int_rc NE 0)    /* Any load failed ?      @/
      {
        /* WS10078N CTSAMSG_print(ERR_API_LOAD, msgs,
                      NULL, dest, admin_params->rss_name, pgm);   @/
        CTSAMSG_print(DYNAMIC_LOAD_FAILED, msgs,      /* WS10078N @/
                      NULL, dest, pgm);               /* WS10078N @/
        /* WS10084
        GLR_del_mods(admin_params);   /* delete the modules.     @/
           WS10084 @/
        rc = ESA_FATAL;
        goto exit;
      }
    }
    else         /* one or more are loaded - verify @/
      /* BS10111
      if (params_ptr->p_cts2rxs EQ NULL  OR  /@ if any is missing   @/
          p_cts2rxf EQ NULL     OR
          p_ctsaatc EQ NULL)   @/
      if (params_ptr->p_cts2rxs EQ NULL  OR  /* if any...   BS10111 @/
          p_ctsaatc EQ NULL)              /* ...is missing  BS10111 @/
      {
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                      dest, component,func,
                      "Not all programs are loaded",
                      16,__LINE__);
        /* BS10111 ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
                "p_CTS2RXS = %p    p_CTS2RCF = %p   p_CTSAATC = %p",
                params_ptr->p_cts2rxs, p_cts2rxf, p_ctsaatc);  @/
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,           /* BS10111 @/
                "p_CTS2RXS = %p    p_CTSAATC = %p",       /* BS10111 @/
                params_ptr->p_cts2rxs, p_ctsaatc);        /* BS10111 @/
        rc = ESA_FATAL ;
        goto exit;     /* we didn't load so no delete   @/
      }

    /*  All modules are loaded  @/
    /* BS10111 ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                "p_CTS2RXS = %p    p_CTS2RCF = %p   p_CTSAATC = %p",
                params_ptr->p_cts2rxs, p_cts2rxf, p_ctsaatc);  @/
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,               /* BS10111 @/
                "p_CTS2RXS = %p     p_CTSAATC = %p",      /* BS10111 @/
                params_ptr->p_cts2rxs, p_ctsaatc);        /* BS10111 */

   /*
    *  prepare the parameters for ACFRPTRX output interception.
    @/
    if (strchr(lid_perm_handle->lid, '*') NE NULL) /* if lid has * @/
      mo1 = 'M';                         /* it is considerred Many @/
    else                                 /* otherwise              @/
      mo1 = '1';                         /* It is considerred 1.   @/

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "LID = %s   MO1 = %c",
                    lid_perm_handle->lid, mo1);

    /* BS10111  - this code was moved up becasue it is needed by TERM
                  as well.
    dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_PERMISSION);
    if ( dbglvl GT 0   AND   dbglvl NE 77)
      dbglvl = 1;
    @/

    /*
     *    Allocate the LID_RULE_AREA vector
     @/
  /*WS10078ALRA_vec=(LID_RULE_AREA_vec_rec_typ *)calloc(RULE_TYPE_NUM,@/
    /* use the calculated rule_type_num                  WS10078A @/
    LRA_vec = (LID_RULE_AREA_vec_rec_typ *)calloc(rule_type_num,
                                 sizeof(LID_RULE_AREA_vec_rec_typ));
    if (LRA_vec EQ NULL)
    {
      CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                   "LID RULE AREA vector",
        /*WS10078A sizeof(LID_RULE_AREA_vec_rec_typ) * RULE_TYPE_NUM);@/
       /*WS10078A@/sizeof(LID_RULE_AREA_vec_rec_typ) * rule_type_num);
      rc = ESA_FATAL;
      goto exit;
    }

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "LRA_vec = %p", LRA_vec);

    /*
     *    Attach ACFRPTRX to create the LID_RULE_AREA for all
     *    entries of the LID_RULE_AREA vector.
     @/
    /*WS10078A for (i = 0; i LT RULE_TYPE_NUM; i++) @/
    for (i = 0; i LT rule_type_num; i++) /*use calc value WS10078A@/
    {
      RESETRXE(rxe)
      RESETRXE(deact_rxe)
      strcpy(LRA_vec[i].rules_type, rule_parm_data[i].rule_type);

      /*    Prepare the svc screening environment @/
      curr_rxe = &rxe;
      /* BS10111
      act_rc = (*params_ptr->p_cts2rxs)("ACT     ", &dbglvl,
                            curr_rxe, &LRA_vec[i].lidra,
                            &ACFRPTRX_output_ignore_list,
                            &mo1);                            @/
      act_rc = (*params_ptr->p_cts2rxs)(                  /* BS10111 @/
                            "ACT     ",                   /* BS10111 @/
                            &dbglvl,                      /* BS10111 @/
                            curr_rxe,                     /* BS10111 @/
                            p_ctsaruh,                    /* BS10111 @/
                            LRA_vec[i].lidra,             /* BS10111 @/
                            &ACFRPTRX_output_ignore_list, /* BS10111 @/
                            &mo1,                         /* BS10111 @/
                            &cmnprms->ruob_utkn);         /* BS10111 @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                      "CTS2RXS: ACT rc = %d", rc);
      if (act_rc NE 0)
         break;

      /* BS10110 - start @/
      /*  The code below is removed replaced to decide on entty type
          according to role_required. When no permissions the loop
          will be done only once  so we will take DSET
      if (lid_perm_handle->RequiredPermissions EQ         /@WS10078ST@/
                                           NULL_CHAR)     /@WS10078ST@/
      {                                                   /@WS10078ST@/
         sprintf(rptrx_parm.parm, "DSET,LID(%s)",         /@WS10078ST@/
                 lid_perm_handle->lid);                   /@WS10078ST@/
         skip_sprntf = TRUE;                              /@WS10078ST@/
      }                                                   /@WS10078ST@/
      @/
      if  (lid_perm_handle->RequiredRoles NE NULL_CHAR)   /* BS10110 @/
         strcpy(entity, "LID");                           /* BS10110 @/
      else if (lid_perm_handle->RequiredPermissions EQ    /*WS10078SG@/
                                           PERM_TYPE_ROLE)/*WS10078SG@/
      {                                                   /*WS10078ST@/
         strcpy(entity, "ROLE");                          /*WS10078SG@/
         /* BS10110 skip_sprntf = FALSE;             /@WS10078ST@/    @/
      }                                                   /*WS10078ST@/
      else if (lid_perm_handle->RequiredPermissions EQ    /*WS10078SG@/
                                            PERM_TYPE_LID)/*WS10078SG@/
      {                                                   /*WS10078ST@/
         strcpy(entity, "LID");                           /*WS10078SG@/
         /* BS10110 skip_sprntf = FALSE;             /@WS10078ST@/    @/
      }                                                   /*WS10078ST@/
      /*    Prepare ACFRPTRX parameter            */
      /* BS10110 if (skip_sprntf EQ FALSE)           /@WS10078ST@/    @/
         sprintf(rptrx_parm.parm,
/*WS10078SG Removing 'LID' and making this a variable, called entity
              "%s%s,LID(%s)",                                        @/
/* BS10110    "%s%s,%s(%s)",                         /@WS10078SG@/   @/
              "%s%s,%s(%s)%s",                            /* BS10110 @/
              LRA_vec[i].rules_type,
              (strlen(rule_parm_data[i].rule_parm) GT 0 ?
                 rptrx_parm.parm, rule_parm_data[i].rule_parm : ""),
              entity,                                     /*WS10078SG@/
/* BS10110    lid_perm_handle->lid );                                @/
              lid_perm_handle->lid,                       /* BS10110 @/
/* BS10110 @/ params_ptr->rssparm_ACFRPTRX_NOUIDALL_SUPP[0] EQ 'Y' ?
/* BS10110 @/                                        NOUIDALL : "");
      rptrx_parm.parm_len = strlen(rptrx_parm.parm);

      /*    Attach ACFRPTRX                       @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                      "ACFRPTRX parameter = %s (%d)",
                      rptrx_parm.parm, rptrx_parm.parm_len);
      att_rc = (*p_ctsaatc)("ACFRPTRX", &parm_type,
                          &rptrx_parm, &s0, &dbglvl,
                          &task_rc, &task_rs, &task_abend);

      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "ATTACH:  rc = %d\n", att_rc);
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "ACFRPTRX: rc = %d (X'%8X') / %d (X'%8X') / %c\n",
                  task_rc, task_rc, task_rs, task_rs, task_abend);

      /*    Remove the SVC screening environment regardless of @/
      /*    how ACFRPTRX ended                                 @/
      curr_rxe = &deact_rxe;
      deact_rc = (*params_ptr->p_cts2rxs)("DEACT   ",
                                          &dbglvl, curr_rxe);
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                      "CTS2RXS: DEACT rc = %d", int_rc);

      /* ruo = (REXX@UTL_output_blk_rec_typ *)LRA_vec[i].lidra; @/
      /* BS10111 - start  */
      /*           the ruo is 8-bytes long so we should copy it
       *           using memcpy. In addition, we canot access
       *           the block.
      ruo = LRA_vec[i].lidra;
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "LID_RULE_AREA = %p -> %p, %d, %d, %10s",
                     ruo, ruo->ruohnext, ruo->ruohlen,
                     ruo->ruohdlen, ruo->ruodata);                 @/
      /* this is how we can copy and print the address   @/
      memcpy(ruo, LRA_vec[i].lidra, 8); /* 8-bytes addr.  @/

      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
               "LID_RULE_AREA = %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
               ruo[0], ruo[1], ruo[2], ruo[3], ruo[4], ruo[5],
               ruo[6],  ruo[7]);
      /* BS10111 - end    @/

      /*    if there was a failure in attach, ACFRPTRX or      @/
      /*    CTS2RXS DEACT, go out of loop)                     @/
      if (deact_rc NE 0   OR
          att_rc NE  0    OR
          task_rc NE  0)
        break;

    }

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
            "Return codes:  act = %d  att = %d  task = %d  deact = %d",
             act_rc, att_rc, task_rc, deact_rc);

    /*
     *  If all OK, return LID vector address and entry num.
     *
     *  If any error in loop, issue the error message passed
     *  from the assembler routines and free all obtained areas.
     @/
    if (act_rc EQ 0    AND
        att_rc EQ 0    AND
        task_rc EQ 0   AND
        deact_rc EQ 0)
    {
      lid_perm_handle->lidra_vec = LRA_vec;
      /*WS10078A lid_perm_handle->lidra_vec_num = RULE_TYPE_NUM;@/
      lid_perm_handle->lidra_vec_num = rule_type_num; /*WS10078A@/

      rc = ESA_OK;
    }
    else
    {
      GLR_RXE_message(&rxe, admin_params);
      GLR_RXE_message(&deact_rxe, admin_params);

      /* If task returned with a non-zero return code or if the
         task abended (not our abend code), print ACFRPTRX
         output to SYSPRINT                                      @/
      if ( (att_rc EQ 0  AND  task_rc NE 0)  OR
           (att_rc EQ 20  AND  task_rc NE 2088) )
        /*WS10078A GLR_print_ACFRPTRX_output(LRA_vec, RULE_TYPE_NUM,@/
        /* BS10111
        GLR_print_ACFRPTRX_output(LRA_vec, rule_type_num, /@WS10078A@/
                                  admin_params);    @/
        GLR_print_ACFRPTRX_output(LRA_vec,                /* BS10111 @/
                                  i,  /* vec index to print  BS10111 @/
                                  rptrx_parm.parm,        /* BS10111 @/
                                  p_ctsaruh, /* -> i/o rtn   BS10111 @/
                                  admin_params);

      /* BS10111 - this call is replced by a call to CTSARUH
      /@WS10078A GLR_free_all(LRA_vec, RULE_TYPE_NUM, admin_params);@/
      GLR_free_all(LRA_vec, rule_type_num, admin_params); /@WS10078A@/
      @/
      for (i = 0; i LT rule_type_num; i++)                /* BS10111 @/
      {                                                   /* BS1011 @/
        int_rc = (*(p_ctsaruh))(CTSARUH_REQ_FREERUOB,     /* BS10111 @/
                         NULL, LRA_vec[i].lidra,          /* BS10111 @/
                         NULL, NULL, NULL, NULL,          /* BS10111 @/
                         &dbglvl, CTSARUH_DBGTYPE_PRTDBG, /* BS10111 @/
                         errmsg, sizeof(errmsg), NULL);   /* BS10111 @/
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,           /* BS10111 @/
                        "CTSARUH - %s: rc = %d",          /* BS10111 @/
                        CTSARUH_REQ_FREERUOB, int_rc);    /* BS10111 @/

        if (int_rc NE 0)   /* if not OK - issue error msg    BS10111 @/
        {                                                 /* BS10111 @/
           if (errmsg[0] NE NULL_CHAR)                    /* BS10111 @/
             CTSAMSG_print(ERR_TL_STRING,                 /* BS10111 @/
                           msgs, NULL, dest, errmsg);     /* BS10111 @/
           sprintf(errmsg,                                /* BS10111 @/
               "CTSARUH - %s failed with rc=%d.",         /* BS10111 @/
               CTSARUH_REQ_FREERUOB, int_rc);             /* BS10111 @/

           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,       /* BS10111 @/
                         dest, component, func, errmsg,   /* BS10111 @/
                         int_rc, __LINE__);               /* BS10111 @/
        };                                                /* BS10111 @/
      } /* End of for (i = 0; i LT rule_type_num; i++)  @//* BS10111 @/

      free(LRA_vec);
      rc = ESA_FATAL;
    }
  }
  else
    /*********************************************
     *                  TERM
     ********************************************@/
    if (strcmp(req_type, "TERM") EQ 0)
    {
      /* BS10111
      ESA_DIAG_printf(PLT_COMP_XREF, 6, "TERM");    /@ WS10078T @/ @/
      ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,"TERM");   /* BS10111 @/
      LRA_vec = lid_perm_handle->lidra_vec;
      if (LRA_vec NE NULL)
      {
        /* * * WS10078 start * * @/
        rule_type_num = RULE_TYPE_NUM; /* set default @/
        if (lid_perm_handle->lidra_vec_num GT 0)
        {
         rule_type_num = lid_perm_handle->lidra_vec_num;
        }
        /* * * WS10078 end * * @/
        /* BS10111 - this call is replced by a call to CTSARUH
        if (p_cts2rxf NE NULL)
        /@WS10078A GLR_free_all(LRA_vec, RULE_TYPE_NUM, admin_params);@/
         GLR_free_all(LRA_vec, rule_type_num, admin_params);/@WS10078A@/
        @/
        for (i = 0; i LT rule_type_num; i++)
        {
          int_rc = (*(p_ctsaruh))(CTSARUH_REQ_FREERUOB,   /* BS10111 @/
                         NULL, LRA_vec[i].lidra,          /* BS10111 @/
                         NULL, NULL, NULL, NULL,          /* BS10111 @/
                         &dbglvl, CTSARUH_DBGTYPE_PRTDBG, /* BS10111 @/
                         errmsg, sizeof(errmsg), NULL);   /* BS10111 @/
          ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,         /* BS10111 @/
                          "CTSARUH - %s: rc = %d",        /* BS10111 @/
                          CTSARUH_REQ_FREERUOB, int_rc);  /* BS10111 @/

          if (int_rc NE 0)   /* if not OK - issue error msg  BS10111 @/
          {                                               /* BS10111 @/
             if (errmsg[0] NE NULL_CHAR)                  /* BS10111 @/
               CTSAMSG_print(ERR_TL_STRING,               /* BS10111 @/
                             msgs, NULL, dest, errmsg);   /* BS10111 @/
             sprintf(errmsg,                              /* BS10111 @/
                 "CTSARUH - %s failed with rc=%d.",       /* BS10111 @/
                  CTSARUH_REQ_FREERUOB, int_rc);          /* BS10111 @/

             CTSAMSG_print(ERR_INTERNAL2, msgs,           /* BS10111 @/
                           NULL, dest,                    /* BS10111 @/
                           component, func, errmsg,       /* BS10111 @/
                           int_rc, __LINE__);             /* BS10111 @/
          };                                              /* BS10111 @/
        }

        free(LRA_vec);
      }

      lid_perm_handle->lidra_vec = NULL;
      lid_perm_handle->lidra_vec_num = 0;

      rc = ESA_OK;

    }
    else
    {
      sprintf(errmsg, "Parameter %s invalid", req_type);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func, errmsg,
                          4, __LINE__);
      rc = ESA_FATAL;
    }

 exit:

   if (rc NE ESA_OK)
     CTSAMSG_print(ACF2_GET_LIDPERM_FAILED, msgs, NULL, dest,
                   lid_perm_handle->lid);

   ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func,rc);
   return rc;
 }
 WS10084 */
/******************************************************************
 * Procedure Name: GLR_del_mods
 ******************************************************************
 * Description   : Delete all modules loaded by ACF2_GetLID_Rules.
 *
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 *********************************************************************/
/* WS10084 the whole routine is deleted
void  GLR_del_mods(ADMIN_PARAMS_rec_typ    * admin_params)
{
  static char              func[]="GLR_del_mods";
  ACF2_PARAMS_rec_typ    * params_ptr = NULL;
  int                      rc = 0;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  params_ptr = admin_params->apiinit_handle;
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /* delete CTS2RXS  @/
  if (params_ptr->p_cts2rxs NE NULL)
  {
    rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTS2RXS ");
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Delete CTS2RXS - rc = %d", rc);
    if (rc EQ 0)
      params_ptr->p_cts2rxs = NULL;
    else
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Delete of CTS2RXS failed",
                     4, __LINE__);
  }

  /* BS10111  - no need to delete because not loaded any more
  /@ delete CTS2RXF  @/
  if (p_cts2rxf NE NULL)
  {
    rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTS2RXF ");
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Delete CTS2RXF - rc = %d", rc);
    if (rc EQ 0)
      p_cts2rxf = NULL;
    else
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Delete of CTS2RXF failed",
                     4, __LINE__);
  }
  end of removed code - BS10111 */

  /* delete CTSAATC  @/
  if (p_ctsaatc NE NULL)
  {
    rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTSAATC ");
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Delete CTSAATC - rc = %d", rc);
    if (rc EQ 0)
      p_ctsaatc = NULL;
    else
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Delete of CTSAATC failed",
                     4, __LINE__);
  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;
}
  WS10084 */
/******************************************************************
 * Procedure Name: GLR_RXE_message
 ******************************************************************
 * Description   : Issue error messages using the informaiton in the
 *                 rxe.
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 *********************************************************************/
/* WS10084
static  void  GLR_RXE_message(CTS2RX_error_block_rec_typ  * rxe,
                              ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char              func[]="GLR_RXE_message";
  ACF2_PARAMS_rec_typ    * params_ptr = NULL;
  int                      rc = 0;
  char                     errmsg[201];

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "RXE: %d / %s / %s / %s / %d / %s",
                  rxe->rxeerror, rxe->rxepgm, rxe->rxefunc,
                  rxe->rxemsg, rxe->rxeline_, rxe->rxedline);
  if (rxe->rxeerror NE 0)
  {
    if (strlen(rxe->rxemsg) NE 0)
      strcpy(errmsg, rxe->rxemsg);
    else
      strcpy(errmsg, "See JOBLOG for error details");

    CTSAMSG_print(ERR_INTERNAL3, msgs, NULL, dest,
                  rxe->rxepgm, rxe->rxefunc, 12, errmsg);
    if (strlen(rxe->rxedline) NE 0)
    {
      sprintf(errmsg, "Data line # %d: %s",
                       rxe->rxeline_, rxe->rxedline);
      CTSAMSG_print(ERR_3_STRINGS, msgs, NULL, dest,
                  errmsg, " ", " ");
    }

    RESETRXE((*rxe))

  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;
}
  WS10084 */

 /* BS10111 - removed - not used any more
/@*****************************************************************
 * Procedure Name: GLR_free_all
 ******************************************************************
 * Description   : Free the LRA vector and all blocks pointed by it.
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 ********************************************************************@/
static  void  GLR_free_all(LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                           int                          LRA_vec_num,
                           ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char              func[]="GLR_free_all";
  ACF2_PARAMS_rec_typ    * params_ptr = NULL;
  int                      rc = 0;
  int                      i = 0;

  CTS2RX_error_block_rec_typ   rxe;
  int                          dbglvl = 0;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "vec = %p   num = %d", LRA_vec, LRA_vec_num);

  if (LRA_vec NE NULL)
  {
    dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_PERMISSION);
    if ( dbglvl GT 0)
      dbglvl = 1;

    /@  Loop on vector,  free blocks for each entry @/
    for (i = 0; i LT LRA_vec_num; i++)
    {
      if (LRA_vec[i].lidra NE NULL)
      {
        RESETRXE(rxe);
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "LRA entry %d: Call CTS2RXF. Block addr = %p",
                        i, LRA_vec[i].lidra);
        rc = (*p_cts2rxf)(LRA_vec[i].lidra, &rxe, &dbglvl);
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "LRA entry %d: CTS2RXF: - rc = %d", i, rc);
        switch (rc)
        {
          case  0:     /@ OK @/
            break;
          case  4:     /@ parameters error, try next entry @/
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func,
                          "CTS2RXF - parameters error",
                           4, __LINE__);
            break;
          case  8:     /@ block release failed, try next entry @/
            GLR_RXE_message(&rxe, admin_params);
            break;
          case 12:     /@ work_area allocation failed @/
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func,
                          "CTS2RXF - allocation of work area failed",
                           4, __LINE__);
            break;
        }
        if (rc EQ 12)
          break;
      }
    }

    free (LRA_vec);
  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;

}
   end of removed code  - BS10111 */

/*  BS10111 - this routine was re-written to:
              1. Use CTSARUH for I/O to support above-the-bar
                 block.
              2. Print only 1 buffer (the one with the error - we
                 will get its index).
              3. Print only a coiunt ine for each LID/ROLE because
                 the output might be millions of lines.
/@*****************************************************************
 * Procedure Name: GLR_print_ACFRPTRX_output
 ******************************************************************
 * Description   : Print ACFRPTRX output to SYSPRINT
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 ********************************************************************@/
static  void  GLR_print_ACFRPTRX_output(
                           LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                           int                          LRA_vec_num,
                           ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char   func[]="GLR_print_ACFRPTRX_output";
  ESA_RC        rc = ESA_OK;
  int           i = 0;
  /@ WS10076 Changed the name of the routine
  char          errtxt[] =
                "Get_rule_line_from_memory (%s) failed with rc = %d";
  char          errmsg[80] =
                "Get_rule_line_from_memory (%s) failed with rc = %d";@/
  char          errtxt[] =                                /@ WS10076 @/
                  "ESA_CLI_get_RUOB_line (%s) failed with rc = %d";
  char          errmsg[80] =                              /@ WS10076 @/
                  "ESA_CLI_get_RUOB_line (%s) failed with rc = %d";

  GET_LINE_PTR             get_line_ptr = NULL;
  IDB_GETRUOBLINE_rec_typ  input_desc_block;
  void                   * get_line_handle = NULL;
  char                     get_line_buffer[134] = "";
  int                      get_line_len = 134;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "vec = %p   num = %d", LRA_vec, LRA_vec_num);

  if (LRA_vec NE NULL)
  {
    for (i = LRA_vec_num - 1; i GE 0; i--)
    {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "LRA_vec[%d] = %p", i, LRA_vec[i].lidra);
      if (LRA_vec[i].lidra NE NULL)
      {
        do
        {
          /@ WS10076 Changed the name of the routine
          get_line_ptr = &Get_rule_line_from_memory;                 @/
          get_line_ptr = &ESA_CLI_get_RUOB_line;          /@ WS10076 @/
        /@ WS10076 input_desc_block.LID_rule_area = LRA_vec[i].lidra;@/
          input_desc_block.blk = LRA_vec[i].lidra;        /@ Ws10076 @/
          rc = (get_line_ptr)("GETNEXT",
                             &input_desc_block,
                             &get_line_handle,
                             get_line_buffer,
                             sizeof(get_line_buffer),
                             admin_params);
          if (rc EQ ESA_OK)
           fprintf(stdout, "%s\n", get_line_buffer);

        } while (rc EQ ESA_OK);

        if (rc NE ESA_EOF)
        {
          sprintf(errmsg, errtxt, "GETNEXT", rc);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                        component, func, errmsg, 12, __LINE__);
        }

        rc = (get_line_ptr)("TERM",
                            &input_desc_block,
                            &get_line_handle,
                            get_line_buffer,
                            sizeof(get_line_buffer),
                            admin_params);
        if (rc NE ESA_EOF)
        {
          sprintf(errmsg, errtxt, "TERM", rc);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                        component, func, errmsg, 12, __LINE__);
        }
        break;
      }
    }
  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;

}
   end of replaced routine   - BS10111  */

/* BS10111 - this is the new version of GLR_print_ACFRPTRX_output */
/******************************************************************
 * Procedure Name: GLR_print_ACFRPTRX_output
 ******************************************************************
 * Description   : Print ACFRPTRX output to SYSPRINT
 *                 the output might be very large so we print
 *                 the INPUT PARAMETERS line and then for each
 *                 LID or ROLE, we print its line and a summary
 *                 line containing the number of "its" lines.
 *                 The output is printed to STDOUT which is directed
 *                 by C to SYSPRINT.
 *
 * Input         : LRA_vec - the vector poitnting to the ACFRPTRX
 *                           output blocks.
 *                 i        - index of LRA_vec entry we need to print.
 *
 * Output        :
 *
 * Return Value  :
 *********************************************************************/
/* WS10084
static  void  GLR_print_ACFRPTRX_output(
                           LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                           int                          i,
                           char                       * rptrx_parm,
                           ASM_RTN_TYP                * p_ctsaruh,
                           ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char   func[]="GLR_print_ACFRPTRX_output";
  ESA_RC        rc = ESA_OK;
  char          name[9] = "";        /* LID/ROLE name.          @/
  char        * name_loc;            /* name location in line   @/
  int           lr_lines = 0;        /* # of lines for lid/role @/
  int           total = 0;           /* number of lines read    @/
  int           before_lid = TRUE;
  int           int_rc = 0;
  char          errmsg[170] = "";
  void        * aruh_h = NULL;       /* -> CTSARUH handle       @/

  unsigned short  Year;
  unsigned short  Month;
  unsigned short  Day;
  unsigned short  Hour;
  unsigned short  Minute;
  unsigned short  Second;
  unsigned short  Milliseconds;

  int             dbglvl = 0;

  void           * get_line_handle = NULL;
  char             get_line_buffer[134] = "";

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "vec = %p   i = %d", LRA_vec, i);

  if (p_ctsaruh EQ NULL)
  {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
         component, func,
         "GLR_print_ACFRPTRX_output received a NULL I/O  routine",
         4, __LINE__);
    goto exit;
  }

  dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_PERMISSION);
  if ( dbglvl GT 0   AND   dbglvl NE 77)
    dbglvl = 1;

  if (LRA_vec NE NULL   AND
      memcmp(LRA_vec[i].lidra, p_ruob_null, 8) NE 0)
  {

    ctsaolt(&Year, &Month, &Day,
            &Hour, &Minute, &Second, &Milliseconds);
    fprintf(stdout, " \n");
    fprintf(stdout,
          "\n%4d/%02d/%02d  %2d:%02d:%02d - ACFRPTRX call, PARM=%s\n",
           Year,Month,Day,Hour,Minute,Second,rptrx_parm);

    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
           "LRA_vec[%d] = %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
           i,
           LRA_vec[i].lidra[0],LRA_vec[i].lidra[1],LRA_vec[i].lidra[2],
           LRA_vec[i].lidra[3],LRA_vec[i].lidra[4],LRA_vec[i].lidra[5],
           LRA_vec[i].lidra[6],LRA_vec[i].lidra[7]);

    lr_lines = 0;         /* # of lines for ID/ROLE = 0 @/
    name[0] = NULL_CHAR; /* No LID/ROLE line yet @/

    fprintf(stdout,
          "====> Start of ACFRPTRX output\n");

    do
    {
      int_rc = (*(p_ctsaruh))(CTSARUH_REQ_GETNEXT, &aruh_h,
                       LRA_vec[i].lidra, get_line_buffer,
                       NULL, sizeof(get_line_buffer), NULL,
                       &dbglvl, CTSARUH_DBGTYPE_PRTDBG,
                       errmsg, sizeof(errmsg), NULL);
      if (int_rc EQ 0)
      {
        total++;

        if (before_lid)
        {
          fprintf(stdout, "%s\n", get_line_buffer);

          if (strncmp(get_line_buffer, "---------------", 15) EQ 0)
            before_lid = FALSE;
        }
        else
        {
          if (strncmp(get_line_buffer, "---------------", 15) EQ 0)
          {
            if (lr_lines NE 0)
              fprintf(stdout, "%s - %d lines\n", name,  lr_lines);

            name[0] = NULL_CHAR;
            lr_lines = 0;
          }
          else
          {
            if (strncmp(get_line_buffer, "ACF", 3) EQ 0)
              fprintf(stdout, "%s\n", get_line_buffer);
            else
            {
              if ( (strncmp(get_line_buffer, "LID:", 4) EQ 0)  OR
                   (strncmp(get_line_buffer, "ROLE:",5) EQ 0) )
              {

                /* check is something got wrong @/
                if (name[0] NE NULL_CHAR)    /* do we have a name ?  @/
                  fprintf(stdout, "%s - %d lines  (???  no --- line)\n",
                         name, lr_lines);

                name_loc = strchr(get_line_buffer, ':');
                strncpy(name, name_loc+2, 8);
                name[8] = NULL_CHAR;
                lr_lines = 0;
              }
              else
              {
                if (name[0] NE NULL_CHAR) lr_lines++;
                else
                  fprintf(stdout, "---> %s\n", get_line_buffer);
              }
            }
          }
        }
      };  /* End of if (int_rc EQ 0)  @/

    } while (int_rc EQ 0);

    if (int_rc EQ 4)
    {
      if (lr_lines GT 0)
      {
        if (name[0] NE NULL_CHAR)
          fprintf(stdout, "%s - %d lines\n", name,  lr_lines);
        else
          fprintf(stdout, "???  - %d lines\n", lr_lines);
      }

      fprintf(stdout, "===> End of ACFRPTRX output - %d lines read\n",
              total);
      fprintf(stdout,
          "========================================================\n");
    }
    else
    {
      if (errmsg[0] NE NULL_CHAR)
        CTSAMSG_print(ERR_TL_STRING,
                      msgs, NULL, dest, errmsg);

      sprintf(errmsg,
             "CTSARUH - %s failed with rc=%d.",
               CTSARUH_REQ_GETNEXT, int_rc);

      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func, errmsg,
                    int_rc, __LINE__);
    }

    int_rc = (*(p_ctsaruh))(CTSARUH_REQ_TERMIO, &aruh_h,
                     NULL, NULL, NULL, NULL, NULL,
                     &dbglvl, CTSARUH_DBGTYPE_PRTDBG,
                     errmsg, sizeof(errmsg), NULL);
    if (int_rc NE 0)
    {
      if (errmsg[0] NE NULL_CHAR)
        CTSAMSG_print(ERR_TL_STRING,
                      msgs, NULL, dest, errmsg);

      sprintf(errmsg,
             "CTSARUH - %s failed with rc=%d.",
               CTSARUH_REQ_TERMIO, int_rc);

      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func, errmsg,
                    int_rc, __LINE__);
    };
  };  /* end of  if (LRA_vec NE NULL   AND
                     memcmp(LRA_vec[i].lidra, p_ruob_null, 8) NE 0) @/

 exit:
  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;

}  /* End of GLR_print_ACFRPTRX_output @/
 WS10084 */
/* BS10111 - end of re-written routine  */
/* WS10075 - end   */

/* WS10076N+S - start */
/*********************************************************************
 * Procedure Name: Permissions_block_Build
 *********************************************************************
 * Description   : Activate te REXX to get all rules, and create
 *                 the permissions block. The permissions block
 *                 address is set in the Permissions Block Handle.
 *
 *                 The permissions block is created according to the
 *                 data set in the permissions block handle:
 *                 - UID - For which UID to create the block.
 *                 - restype and resname - for which resource to
 *                   create the block.
 *                 - Permissions (Y/N) - whether the block should
 *                   contain permissions or on ly UIDs.
 *
 *                 Permissions block structure:
 *                 The permissions block contains a header pointing
 *                 to a chain of UIDs. Each UID in chain points to
 *                 its permissions (if requested) and to the next
 *                 UID in chain. The UIDs are sorted in ascending order.
 *
 *                 The permissions block header contains an index.
 *                 Each entry of the ndex points to ~1/100 of the UIDs
 *                 to make permissions block handling (Get, Insert)
 *                 more efficient.
 *                 During the Build process, the index updated after
 *                 100 UIDs are added, and then after each 1000 UIDs
 *                 are added. When a UID has to be added, its place
 *                 is found by first searching the index and then the
 *                 UIDs chain from this index entry.
 *
 * Input         : function:  BUILD / FREE
 *                 PB_Req  :  -> PB_Build_Request  (replaces PBhandle)
 *                 comp    :  Diag. component.
 *
 * Output        : The permissions block header is set tin the
 *                 permissions block handle.
 *
 *
 * Return Value  : ESA_OK - The block was built successfully.
 *                 ESA_KEY_NOT_FOUND - no rule was found.
 *                 ESA_FATAL - Build failed.
 *
 *
 ********************************************************************/
ESA_RC Permissions_block_Build(
                    char                  * function,
                 /* PBhandle_typ          * PBhandle,      /* WS10084 */
                    PB_Build_Request_typ  * PB_Req,        /* WS10084 */
                    ESA_DIAG_COMP_typ       comp,
                    ADMIN_PARAMS_rec_typ  * admin_params)
{
  static char    func[] = "Permissions_block_Build";
  ESA_RC         rc = ESA_OK;
  ESA_RC      ug_rc = ESA_OK;                             /* WS10084 */
  ESA_RC      pg_rc = ESA_OK;                             /* WS10084 */
  ESA_RC        mrc = ESA_OK;                             /* WS10084 */
  ACF2_API_Return_Codes  acf_rc = ACF2_OK;                /* WS10079N */

  PERM_BLK_HDR_rec_typ        * pbh = NULL;
  int                           pbh_len = 0;
  PERM_BLK_HDR_rec_typ        * pbh_groups = NULL;         /* WS10084 */
  PERM_BLK_HDR_rec_typ        * pbh_users  = NULL;         /* WS10084 */
  PERM_BLK_HDR_rec_typ        * pbh_g_or_u = NULL;         /* WS10084 */
  PERM_BLK_HDR_rec_typ       ** ppbh       = NULL;         /* WS10084 */
  PBhandle_typ                * G_PBhandle = NULL;         /* WS10084 */
  PBhandle_typ                * U_PBhandle = NULL;         /* WS10084 */
  PBhandle_typ                * R_PBhandle = NULL;         /* WS10084 */
  PBhandle_typ                * RG_PBhandle = NULL;        /* WS10084 */
  XBhandle_rec_typ            * R_XBhandle = NULL;         /* WS10084 */
  char      perm_data[ACF2_MAX_PERMISSN_SIZE] = "";        /* WS10084 */
  int                           Any_G_Perms = FALSE;       /* WS10084 */
  int                           Any_U_Perms = FALSE;       /* WS10084 */
  int                           Any_R_Perms = FALSE;       /* WS10084 */
  int                           i           = 0;           /* WS10084 */
  int                           lidlen      = 0;           /* WS10084 */
  ACF2_PARAMS_rec_typ         * params_ptr  = NULL;        /* WS10084 */
  char                          ftype       = NULL_CHAR;   /* WS10084 */
  /* BS10111 REXX@UTL_output_blk_rec_typ * p_ruob = NULL;  */
  char           p_ruob[8];                               /* BS10111 */

  void         * get_rule_rec_handle = NULL;
  /* WS10078S The ANY_LINE request has been phased out
  Permission_Record_Type req_rec_type = ANY_LINE;                   */
  Permission_Record_Type req_rec_type;                  /* WS10078S */
  Permission_Record_Type ret_rec_type;
  char           rule_record[ACF2_MAX_PERMISSN_SIZE] = "";
  char           formatted_permission[ACF2_MAX_PERMISSN_SIZE] = "";
  char           user_or_group = NULL_CHAR;
  char           perm_u_or_g   = NULL_CHAR;               /* WS10084 */
  char           direct = 'D';
  char           resource_type[4] = "";
  char           res_type[2] = "";
  char           key[MAX_PERM_KEY_LEN+1] = "";
  char           prefix[MAX_PERM_PREFIX_LEN+1]= "";
  char         * uid_parm = NULL;
  char           uid[ACF2_UID_SIZE+1]      = "";          /* WS10084 */
  char           only_uid[ACF2_UID_SIZE+1] = ""; /* uid itself */
  char           full_uid[ACF2_UID_SIZE+6] = ""; /* UID(uid)   */
  char           errmsg[200];
  ESA_RC         trm_rc = ESA_OK;
  int            int_rc = 0;                              /* BS10111 */
  char         * from = NULL;
  char         * to = NULL;
  char         * fromw = NULL;     /* Used by RULE_KWD_VALUE_RTRVR  */
  char         * tow = NULL;       /* Used by RULE_KWD_VALUE_RTRVR  */
  int            lenw = 0;         /* Used by RULE_KWD_VALUE_RTRVR  */
  char         * ret;
  int            phase = 0;        /* KEY=1, PREFIX=2,  PERM=3      */
  int            err_msg_rec = FALSE;
  int            dbglvl = 0;                              /* BS10111 */
  int            roleset_permission = FALSE;              /* WS10084 */
  char           direct_or_indirect = NULL_CHAR;          /* WS10084 */
  int            LID_Offset = 0;                          /* WS10084 */
  int            LID_Length = 0;                          /* WS10084 */
  char           lid[ACF2_LID_SIZE]   = "";               /* WS10084 */
  char           role[XREF_NAME_SIZE] = "";               /* WS10084 */
  char           role_in_paren[XREF_NAME_SIZE+2] = "";    /* WS10084 */
  char         * roleuser_parm = NULL;                    /* WS10084 */
  char           name[XREF_NAME_SIZE] = "";               /* WS10084 */
  char           sysid[9]             = "";               /* WS10084 */
  char         * ret_str              = NULL;             /* WS10084 */
  int            only_g               = FALSE;            /* WS10084T*/

  /* BS10111 GET_LINE_PTR   get_line_ptr;   */
  /* BS10111 IDB_GETRUOBLINE_rec_typ  getline_parms;  */

 /* WS10078SG This block not needed. It was used for ANY_LINE function.
  static WANTED_PERM_REC_rec_typ PERM_RECORD_groups[] =
  { {"$KEY("     ,  5,  $KEY_LINE    },
    {"$PREFIX("  ,  8,  $PREFIX_LINE },
    {""          ,  0,  0            }  };                           */

  /*
   *    ignore list for CTSCGRO
   *
   *    the "full" field indicates whether we should ignore a line
   *    containing a specific character only (for example, a line
   *    containing only blanks).
   *    when this is required, len is 1, full is x'ff' and data
   *    contains the character repeated in the line.
   *
   *    the last line of the table contains len=0.
   */

  static REXX@UTL_output_ignlist_rec_typ LISTRULE_output_ignore_list[] =
  { { 8,  0,    "ACF75052"  },
    { 1,  0xFF, " "         },
    { 0,  0,    " "         }   };
  char rectype[7];   /*WS10078A new parm with RULE or X(ROL) or X(SGP)*/
  char recparm[100]; /*WS10078A new parm with restype/resname */

  /* IS10184 ACF2_PARAMS_rec_typ    * params_ptr = NULL; * BS10111 * */
  COMMON_PARAMS_rec_typ     * cmnprms = NULL;             /* BS10111 */
  ASM_RTN_TYP               * p_ctsaruh = NULL;           /* BS10111 */
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  /*
   *   Initializtion
   */
  ESA_DIAG_enter(comp, 1, func );


  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(comp, 2,
                  "Function = %s   PB_Req = %p",           /* WS10084 */
                   function, PB_Req);                      /* WS10084 */
  /* WS10084      "Function = %s   PBhandle = %p",
                   function, PBhandle);                       WS10084 */

  /* if (PBhandle  EQ  NULL)                                  WS10084 */
  if (PB_Req  EQ  NULL)                                    /* WS10084 */
  {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
    /*     "No Permissions Block handle address",             WS10084 */
           "No Permissions Block Build Request address",   /* WS10084 */
           16, __LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

  /* WS10084 start */
  G_PBhandle = PB_Req->Groups_PBhandle_ptr;
  U_PBhandle = PB_Req->Users_PBhandle_ptr;
  if ( strcmp(function, "BUILD") EQ 0 )
     R_XBhandle = PB_Req->Roles_XBhandle_ptr;
  ESA_DIAG_printf(comp, 2,
                   "Groups_PBhandle_ptr = %p \n"
                  "Users_PBhandle_ptr  = %p \n"
                  "Roles_XBhandle_ptr  = %p \n"    ,
                   G_PBhandle,
                   U_PBhandle,
                   R_XBhandle);
  ESA_DIAG_printf(comp, 2,
                  "GroupDirect         = %d \n"
                  "AccountDirect       = %d \n"
                  "AccountIndirect     = %d \n"
                  "AccountRoleDirect   = %d \n"
                  "AccountRoleIndirect = %d \n"
                  "RoleDirect          = %d \n" ,
                   PB_Req->GroupDirect,
                   PB_Req->AccountDirect,
                   PB_Req->AccountIndirect,
                   PB_Req->AccountRoleDirect,
                   PB_Req->AccountRoleIndirect,
                   PB_Req->RoleDirect);

  if (PB_Req->SingleUser)
      ESA_DIAG_printf(comp, 6,
                  "Single User = |%s| \n",
                  PB_Req->lid);

  if (G_PBhandle NE NULL)
  {
      strcpy(PB_Req->resource_name,
             G_PBhandle->resource_name);
      strcpy(PB_Req->resource_type,
             G_PBhandle->resource_type);
  }

  if (U_PBhandle NE NULL)
  {
      strcpy(PB_Req->resource_name,
             U_PBhandle->resource_name);
      strcpy(PB_Req->resource_type,
             U_PBhandle->resource_type);
  }

  if (R_XBhandle NE NULL)
  {
     R_PBhandle  = R_XBhandle->XREF_PB_handle;
     RG_PBhandle = R_XBhandle->Groups_PB_handle;
     ESA_DIAG_printf(comp, 2,
                  "From XBhandle: \n"
                  "XREF_PB_handle      = %p \n"
                  "Groups_PB_handle    = %p \n"    ,
                   R_PBhandle,
                   RG_PBhandle);
     ESA_DIAG_printf(comp, 6,
       "R_XBhandle->shortest = %c", R_XBhandle->shortest);
  }

  /* WS10084 end   */
  /********************************************************************
   *
   *    BUILD
   *
   *    1. Execute the REXX to get the RUOB with the LIST RULE output.
   *    2. Allocate he permissions Block header.
   *    3. Get the rules from the ROUB, and for each group permission
   *       cretae a permisison string and add it to the permissions
   *       block.
   *
   *******************************************************************/
  if ( strcmp(function, "BUILD") EQ 0 )
  {
    /*  Take CTSARUH address from commmon_params.            BS10111 */
    /* IS10184
    GET_P_CTSARUH(params_ptr, cmnprms, p_ctsaruh)    * BS10111 *     */
    GET_CMNPRMS_PROG(admin_params, cmnprms, p_ctsaruh,    /* IS10184 */
                     p_ctsaruh, rc, errmsg)               /* IS10184 */
    if (rc NE ESA_OK)    /* environmental error ? */      /* BS10111 */
    {                                                     /* IS10184 */
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,      /* IS10184 */
                    component, func, errmsg,              /* IS10184 */
                    rc, __LINE__);                        /* IS10184 */
      goto exit;                                          /* BS10111 */
    };                                                    /* IS10184 */

    memcpy(p_ruob, p_ruob_null, 8); /* Init the ruob addr.   BS10111 */

    dbglvl = (int)ESA_DIAG_get_debug_level(               /* BS10111 */
                                comp);                    /* BS10111 */
    if ( dbglvl GT 0   AND   dbglvl NE 77)                /* BS10111 */
      dbglvl = 1;                                         /* BS10111 */

    /* PBhandle->PBptr = NULL;                               WS10084 */

    /*
     *
     *  Issue the ACF2 commands.
     *
     *  Prepare the REXX call, execute it and process its output.
     *
     */
    strcpy(rectype,"RULE");                          /*WS10078A*/
    sprintf(recparm,  /* recparm = restype/resname     WS10078A */
            "%s/%s",
            (PB_Req->resource_name EQ NULL ?              /* WS10084 */
                      "" : PB_Req->resource_name),        /* WS10084 */
            (PB_Req->resource_type EQ NULL ?              /* WS10084 */
                      "" : PB_Req->resource_type) );      /* WS10084 */
    /* WS10084
            (PBhandle->resource_name EQ NULL ?            /* WS10078N @/
                      "" : PBhandle->resource_name),      /* WS10078N @/
            (PBhandle->resource_type EQ NULL ?            /* WS10078N @/
                      "" : PBhandle->resource_type) );    /* WS10078N @/
       WS10084 */
  /* WS10078N PBhandle->resource_name,       */
  /* WS10078N PBhandle->resource_type);      */
 /* rc = ACF2_Get_Rules(PBhandle->resource_type,
                        PBhandle->resource_name,        WS10078A */
    /* WS10079N rc = ACF2_Cmd2Mem(rectype,         /@ WS10078A @/ */
    ESA_DIAG_printf(comp, 6,                              /* WS10084 */
         "Before ACF2_Cmd2Mem");                          /* WS10084 */
    acf_rc = ACF2_Cmd2Mem(rectype,                   /* WS10079N */
                      recparm,                       /* WS10078A */
                      LISTRULE_output_ignore_list,
         /* BS10111   &p_ruob,                                 */
                      p_ruob,                             /* BS10111 */
                      comp,
                      admin_params);
    ESA_DIAG_printf(comp, 6,                              /* WS10084 */
         "After  ACF2_Cmd2Mem");                          /* WS10084 */
    /* BS10111
    ESA_DIAG_printf(comp, 2,
            "ACF2_Cmd2Mem for %s/%s returned rc = %d  ruob = %p",
            (PBhandle->resource_type EQ NULL ?
                               "" : PBhandle->resource_type),
            (PBhandle->resource_name EQ NULL ?
                               "" : PBhandle->resource_name),
            rc, p_ruob);  */
    ESA_DIAG_printf(comp, 2,                              /* BS10111 */
         "ACF2_Cmd2Mem for %s/%s returned rc = %d...",    /* BS10111 */
        (PB_Req->resource_name EQ NULL ?                  /* WS10084 */
                      "" : PB_Req->resource_name),        /* WS10084 */
        (PB_Req->resource_type EQ NULL ?                  /* WS10084 */
                      "" : PB_Req->resource_type),        /* WS10084 */
        acf_rc);                                          /* WS10084 */
    /* WS10084
        (PBhandle->resource_type EQ NULL ?                /* BS10111 @/
                           "" : PBhandle->resource_type), /* BS10111 @/
        (PBhandle->resource_name EQ NULL ?                /* BS10111 @/
                           "" : PBhandle->resource_name), /* BS10111 @/
        acf_rc);                             /* WS10079N     BS10111 @/
       WS10084 */
        /* WS10079N rc);                               /@ BS10111 @  */
    ESA_DIAG_printf(comp, 2,                              /* BS10111 */
      "   ...and ruob = %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",/* BS10111 */
            p_ruob[0],p_ruob[1],p_ruob[2],p_ruob[3],      /* BS10111 */
            p_ruob[4],p_ruob[5],p_ruob[6],p_ruob[7]);     /* BS10111 */

    /* WS10079N if (rc  NE ESA_OK)  */
    if  (acf_rc   EQ ACF2_Not_Found)  /* Not found */     /* WS10079N */
    {                                                     /* WS10079N */
      /* PBhandle->PBnf = TRUE;              WS10084 */   /* WS10079N */
      /* WS10084 start  */
      PB_Req->PB_rules_nf = TRUE;
      if (G_PBhandle NE NULL)
        G_PBhandle->PBnf = TRUE;
      if (U_PBhandle NE NULL)
        U_PBhandle->PBnf = TRUE;
      /* WS10084 end   */
      rc = ESA_KEY_NOT_FOUND;                             /* WS10079N */
      goto bld_exit;                                      /* WS10079N */
    }                                                     /* WS10079N */
    else                                                  /* WS10079N */
      if (acf_rc   NE ACF2_OK)                            /* WS10079N */
      {
        rc = ESA_FATAL;   /* Error message was already issued  */
        goto bld_exit;
      };

    /*   If nothing was returned - error.    */
    /* BS10111 if (p_ruob EQ NULL)  */
    if (memcmp(p_ruob, p_ruob_null, 8) EQ 0)              /* BS10111 */
    {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                    "No output was returned by the ACF2 commands",
                    16, __LINE__);
      rc = ESA_FATAL;
      goto bld_exit;
    }

    /*
     *   Allocate the permissions block
     *
     *   We have an additional index entry for the last uid, which is
     *   part of the permissions block header structure.
     */
    if (G_PBhandle NE NULL)                                /* WS10084 */
    {                                                      /* WS10084 */
     pbh_len = sizeof(PERM_BLK_HDR_rec_typ) +
                  (sizeof(PB_INDEX_rec_typ) * PBH_INITAL_IX_NUM);
     pbh = (PERM_BLK_HDR_rec_typ *)calloc(1, pbh_len);
     ESA_DIAG_printf(comp, 2,
             "Alloc pbh: len = %d   addr = %p", pbh_len, pbh);

     if (pbh EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "Permissions block", pbh_len);
       rc = ESA_FATAL;
       goto bld_exit;
     };

     strncpy(pbh->eyecatcher, PBH_EYECATCHER,
                          sizeof(pbh->eyecatcher) );
     pbh->num_ix_ent = PBH_INITAL_IX_NUM + 1;
     pbh->table_type = ACF2_UID_PBENT_EYEC;         /*WS10079A*/
     pbh_groups = pbh;                                     /* WS10084 */
    }                                                      /* WS10084 */

    /* WS10084 start */
    if (U_PBhandle NE NULL)
    {
     pbh_len = sizeof(PERM_BLK_HDR_rec_typ) +
                  (sizeof(PB_INDEX_rec_typ) * PBH_INITAL_IX_NUM);
     pbh = (PERM_BLK_HDR_rec_typ *)calloc(1, pbh_len);
     ESA_DIAG_printf(comp, 2,
             "Alloc pbh: len = %d   addr = %p", pbh_len, pbh);

     if (pbh EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "Permissions block", pbh_len);
       rc = ESA_FATAL;
       goto bld_exit;
     };

     strncpy(pbh->eyecatcher, PBH_EYECATCHER,
                          sizeof(pbh->eyecatcher) );
     pbh->num_ix_ent = PBH_INITAL_IX_NUM + 1;
     pbh->table_type = ACF2_ACNT_PBENT_EYEC;
     pbh_users = pbh;
    }
    /* WS10084 end   */

    /*
     *   Get the rule records and create UID and Permission
     *   elements for the permissions block.
     */
    /* BS10111 get_line_ptr = &ESA_CLI_get_RUOB_line;  */
    /* BS10111 getline_parms.blk = p_ruob;             */
    req_rec_type = $KEY_LINE;    /* Ask for $KEY line */

    do
    {
      err_msg_rec = FALSE;
      ret_rec_type = 0;
      rule_record[0] = NULL_CHAR;
      user_or_group = NULL_CHAR;

      rc = Get_Rule_Record("GETNEXT",
                           &get_rule_rec_handle,
             /* BS10111    get_line_ptr,        */
             /* BS10111    &getline_parms,      */
/* WS10078S                PERM_RECORD_groups,                      */
                           p_ruob,                        /* BS10111 */
                           req_rec_type,
                           sizeof(rule_record),
                           "LIST RULES",
                           &ret_rec_type,
                           rule_record,
                           resource_type,
                           admin_params);
      /*
      if (strstr(rule_record,"$KEY(TLVCKC) TYPE(CKC)"))   /* WS10084 @/
         want_diag5 = TRUE;
      if (strstr(rule_record,"$KEY(TLVCKC.TLVCKC.TLVCKC.TLVCKC)"))
         want_diag5 = FALSE;
      if (want_diag5)                                     /* WS10084 @/
      {
      ESA_DIAG_printf(comp, 0,
           "Get_Rule_Record rc=%d  record type=%d  resource type=|%s|",
           rc, ret_rec_type, resource_type);
      ESA_DIAG_printf(comp,  0,
                      "rule record |%s|", rule_record);
      }
      */
      ESA_DIAG_printf(comp, 6,
           "Get_Rule_Record rc=%d  record type=%d  resource type=|%s|",
           rc, ret_rec_type, resource_type);
      ESA_DIAG_printf(comp, 17,
                      "rule record |%s|", rule_record);

      /* If any error, Get_Rule_record issued the detailed   */
      /* error message.                                      */

      if ( rc EQ ESA_EOF )     /* if end-of-file           */
         break;                /* leave the loop           */
      else
        if (rc EQ ESA_SKIP)      /* if output area too small */
        {
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                        component,func,
                        "No record printed above is ignored",
                         8, __LINE__);
          rc = ESA_OK;          /* ignore the record and... */
          continue;             /* continue looping         */
        }
        else
         if ( rc NE ESA_OK )    /*  error encountered       */
         {
           rc = ESA_FATAL;
           sprintf(errmsg, "Get_Rule_Record returned rc = %d",
                   rc);
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                         component, func, errmsg,
                         16, __LINE__);
           break;                /* leave the loop           */
         };

      /* Got a rule record - process it.  */
      /* If any error processing the record, skip it and continue */
      switch(ret_rec_type)
      {
        /***************************
        *        $KEY line         *
        ***************************/
        case $KEY_LINE:
          phase = 1;              /* $KEY record  */
          req_rec_type = KPP_LINE;

          key[0] = NULL_CHAR;
          prefix[0] = NULL_CHAR;
          formatted_permission[0] = NULL_CHAR;

          /* Get the KEY value into key */
          from = strstr(rule_record, "$KEY(");
          RULE_KWD_VALUE_RTRVR (from,
                                sizeof(key),
                                key,
                                rc,
                                fromw,
                                tow,
                                lenw);
          ESA_DIAG_printf(comp, 17,
             "RULE_KWD_VALUE_RTRVR for KEY: rc = %d  key = |%s|",
             rc, key);

          if (rc EQ ESA_OK)
          {
            ret = from + strlen("$KEY(") + strlen(key) + 1; /* after )*/
            if (strstr(ret, " ROLESET") NE NULL)
               /* req_rec_type = $KEY_LINE;   /@ Skip roleset rules @/
                WS10084 */
             /* WS10084 start */
             if ( ((PB_Req->AccountRoleDirect)
                    OR
                   (PB_Req->AccountRoleIndirect))
                   AND
                  (PB_Req->RequiredRoles EQ NULL_CHAR) )
               req_rec_type = $KEY_LINE;
             else
             if ( ( (PB_Req->Users_PBhandle_ptr NE NULL)
                    AND
                    (PB_Req->AccountRoleDirect) )
                 OR
                 ( (PB_Req->Roles_XBhandle_ptr NE NULL)
                   AND
                   (PB_Req->AccountRoleIndirect) )
                 OR
                 ( (PB_Req->Roles_XBhandle_ptr NE NULL)
                   AND
                   (PB_Req->RoleDirect) ) )
                 roleset_permission = TRUE;
             else  /* ROLESET RULE not needed - skip it */
               req_rec_type = $KEY_LINE;
            else
            {
              if (PB_Req->RoleDirect)
                 req_rec_type = $KEY_LINE; /* Skip non roleset rules */
              roleset_permission = FALSE;
            }
            ESA_DIAG_printf(comp, 6 ,
             "roleset_permission = %d \n",
             roleset_permission);
            /* WS10084 end   */
          }
          else             /* output field too small */
          {
            sprintf(errmsg,
               "RULE_KWD_VALUE_RTRVR for KEY rc = %d.  input = %.50s",
               rc, from);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                          func, errmsg, 16, __LINE__);
            err_msg_rec = TRUE;
            req_rec_type = $KEY_LINE;   /* skip this rule */
            rc = ESA_OK;
          }

          break;
        /***************************
        *     $PREFIX line         *
        ***************************/
        case $PREFIX_LINE:
          if (phase NE 1)
          {
            sprintf(errmsg,
             "$PREFIX without preceding $KEY. Phase = %d   rec = %.80s",
             phase, rule_record);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                          func, errmsg, 8, __LINE__);
            err_msg_rec = TRUE;
            req_rec_type = $KEY_LINE;   /* Ask for $KEY record */
            rc = ESA_OK;                /* Skip this record     */
            break;
          };

          req_rec_type = KPP_LINE;
          phase = 2;                 /* $PREFIX record */
          prefix[0] = NULL_CHAR;

          /* Get the PREFIX value into prefix */
          from = strstr(rule_record, "$PREFIX(");
          RULE_KWD_VALUE_RTRVR (from,
                                sizeof(prefix),
                                prefix,
                                rc,
                                fromw,
                                tow,
                                lenw);
          ESA_DIAG_printf(comp, 17,
             "RULE_KWD_VALUE_RTRVR for PREFIX: rc = %d  prefix = |%s|",
             rc, prefix);

          if (rc NE ESA_OK) /* output field too small */
          {
            sprintf(errmsg,
              "RULE_KWD_VALUE_RTRVR for PREFIX rc = %d, input = %.50s",
               rc, from);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                          func, errmsg, 8, __LINE__);
            err_msg_rec = TRUE;
            req_rec_type = $KEY_LINE;   /* skip this rule */
            rc = ESA_OK;
          }

          break;
        /***************************
        *     Permission line      *
        ***************************/
        case PERMISSION_LINE:
          if (phase EQ 0)
          {
            sprintf(errmsg,
         "permission without preceding $KEY.  Phase = %d   rec = %.80s",
             phase, rule_record);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                          func, errmsg, 8, __LINE__);
            rc = ESA_OK;                /* Skip this record     */
            err_msg_rec = TRUE;
            req_rec_type = $KEY_LINE;   /* Ask for $KEY record */
            break;
          };

          lid[0] = NULL_CHAR;                              /* WS10084 */
          role[0] = NULL_CHAR;                             /* WS10084 */
          formatted_permission[0] = NULL_CHAR;
          req_rec_type = KPP_LINE;
          phase = 3;                 /* Permission record */
            ESA_DIAG_printf(comp, 20,                      /* WS10084 */
            "permissions_line:roleset_permission = %d \n", /* WS10084 */
             roleset_permission);                          /* WS10084 */
          if (roleset_permission    EQ FALSE)              /* WS10084 */
          {                                                /* WS10084 */
           uid_parm = NULL;
           rc = Permission_Get_UID(rule_record,
                                   &user_or_group,
                                   &uid_parm,  /* -> UID(uid) in rule */
                                   admin_params);
           ESA_DIAG_printf(comp, 6,
             "Permission_Get_UID: rc = %d u/g = %c  uid = %p -> %.30s",
             rc, user_or_group, uid_parm, uid_parm);

           if ( rc NE ESA_OK OR  /* no uid or area too small    */
               uid_parm EQ NULL )
           {
             sprintf(errmsg,
                     "Permission_Get_UID returned rc = %d  uid = %s",
                     rc,
                     uid_parm EQ NULL? "" : uid_parm);
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                           dest, component,
                           func, errmsg, 12, __LINE__);
             rc = ESA_OK;               /* Skip this record     */
             err_msg_rec = TRUE;
             break;       /* ignore this record and continue looping */
           };

           /* WS10084  start (move from below with changes */
           if ( (user_or_group NE 'G') AND
              (user_or_group NE 'U') )
           {
             sprintf(errmsg,
            "Permission_Get_UID returned invalid type %c for UID %.*s",
                user_or_group,
                (strlen(rule_record) GT 80? 30 : strlen(rule_record)),
                rule_record);
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                           func, errmsg, 16, __LINE__);
             rc = ESA_FATAL;
             break;
           }

           /* Get the rule UID */
           only_uid[0] = NULL_CHAR;
           RULE_KWD_VALUE_RTRVR (uid_parm,
                                 sizeof(only_uid),
                                 only_uid,
                                 rc,
                                 fromw,
                                 tow,
                                 lenw);
           ESA_DIAG_printf(comp, 17,
             "RULE_KWD_VALUE_RTRVR for UID: rc = %d uid = |%s|",
             rc, only_uid);

           if (rc NE ESA_OK)
           {
             sprintf(errmsg,
              "RULE_KWD_VALUE_RTRVR for uid rc = %d, input = %.50s",
               rc, uid_parm);
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                           component, func, errmsg,
                           16, __LINE__);
             rc = ESA_FATAL;
             break;
           };
           /*
           if (strcmp(only_uid,"*************TLVKP1 ") EQ 0)
           {
              want_diag2 = TRUE;
              ESA_DIAG_printf(comp, 0 ,
                  "PBhandle->uid |%s| only_uid |%s|",
                  G_PBhandle->uid, only_uid);
           }
           else
             want_diag2 = FALSE;
           */
           ESA_DIAG_printf(comp, 17,
                  "PBhandle->uid |%s| only_uid |%s|",
                  G_PBhandle->uid, only_uid);
           /* WS10084T
           if ( (strcmp(only_uid,"*") EQ 0) AND
                (NOT PB_Req->GroupDirect) )
                break;   WS10084T */
           /* WS10084 end  */

           /* WS10084
           if (user_or_group EQ 'U')  /@ If user permission, drop it @/
             break;
            else
            {
              /@ If group permission @/
              if (user_or_group EQ 'G')
              {                                               WS10084 */

           /* WS10084 start */
           /* if user's UID, verify that AccountDirectPermissions
              was requested.  */
           if (user_or_group EQ 'U')
           {
              /*
              if (want_diag2)
                  ESA_DIAG_printf(comp, 0, "user_or_group is U");
              */

              if (NOT PB_Req->AccountDirect)
               break;
              else
               direct_or_indirect = 'D';

              perm_u_or_g = 'U';
              lid[0] = NULL_CHAR;
              if (ACF2_Is_LID_In_UID(&LID_Offset,&LID_Length))
              {
                 /*
                 if (want_diag2)
                  ESA_DIAG_printf(comp, 0,
                     "LID is in UID. Offset = %d Len = %d \n",
                      LID_Offset,LID_Length);
                 */

                 strncpy(lid, only_uid+LID_Offset,LID_Length);
                 lidlen = strlen(lid);
                 for (i = lidlen -1; i GT 0; i--)
                     if (lid[i] EQ ' ')
                        lid[i] = NULL_CHAR;
                     else
                        break;
                 ESA_DIAG_printf(comp, 6,
                     "LID = |%s| extracted from UID = |%s| \n",
                      lid, only_uid);
                 /*
                 if (want_diag2)
                  ESA_DIAG_printf(comp, 0,
                     "LID = |%s| extracted from UID = |%s| \n",
                      lid, only_uid);
                 */
              }
              if (PB_Req->SingleUser)
                 if (strcmp(lid,PB_Req->lid) NE 0)
                 {
                    /*
                    if (want_diag2)
                     ESA_DIAG_printf(comp, 0,
                       "User in rule = |%s| is not our user = |%s| \n",
                        lid, PB_Req->lid);
                    */
                     ESA_DIAG_printf(comp, 6,
                       "User in rule = |%s| is not our user = |%s| \n",
                        lid, PB_Req->lid);
                     break;
                 }
                 else
                     ESA_DIAG_printf(comp, 6,
                       "User in rule = %s is our user = %s \n",
                        lid, PB_Req->lid);
           }
           else

           /* if Group UID, verify that GroupDirectPermissions or
              AccountIndirect was requested. */
           if (user_or_group EQ 'G')
           {
              if  ( (NOT PB_Req->GroupDirect) AND
                    (NOT PB_Req->AccountIndirect) AND
                    (PB_Req->Groups_PBhandle_ptr EQ NULL) )   /* WS10084T */
               break;
              if  ( (NOT PB_Req->GroupDirect) AND             /* WS10084T */
                    (NOT PB_Req->AccountIndirect) )           /* WS10084T */
              {                                               /* WS10084T */
               only_g = TRUE;                                 /* WS10084T */
               ESA_DIAG_printf(comp, 6,                       /* WS10084T */
                             "only group no perms \n");       /* WS10084T */
              }                                               /* WS10084T */
              else                                            /* WS10084T */
              {                                               /* WS10084T */
               perm_u_or_g = 'G';
               if (PB_Req->GroupDirect)
                  direct_or_indirect = 'D';
               else
               if (PB_Req->AccountIndirect)
               {
                  direct_or_indirect = 'I';
                  perm_u_or_g = 'U';
               }

               ESA_DIAG_printf(comp, 6,
                             "direct or indirect uid = %c \n",
                              direct_or_indirect);

              }                                               /* WS10084T */
              /* Get the rule UID */
              /* WS10084
              only_uid[0] = NULL_CHAR;
              RULE_KWD_VALUE_RTRVR (uid_parm,
                                    sizeof(only_uid),
                                    only_uid,
                                    rc,
                                    fromw,
                                    tow,
                                    lenw);
              ESA_DIAG_printf(comp, 17,
                "RULE_KWD_VALUE_RTRVR for UID: rc = %d uid = |%s|",
                rc, only_uid);

              if (rc NE ESA_OK)
              {
                sprintf(errmsg,
                 "RULE_KWD_VALUE_RTRVR for uid rc = %d, input = %.50s",
                  rc, uid_parm);
                CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                              component, func, errmsg,
                              16, __LINE__);
                err_msg_rec = TRUE;
                rc = ESA_OK;               /* Skip this record     @/
                break;
              };

              ESA_DIAG_printf(comp, 17,
                     "PBhandle->uid |%s| only_uid |%s|",
                     PBhandle->uid, only_uid);
                 WS10084 */

              /* WS10084 start */
            /*if (Is_UIDMASK_User (only_uid))
                 direct_or_indirect = 'D';
              else
                 direct_or_indirect = 'I';*/
              /* WS10084 end  */

              /* Process the rule if we need to handle all UIDs, or */
              /* if the rule UID matches the UID requested          */
              /* WS10084 start */
              if ( (strcmp(G_PBhandle->uid,"*")     NE 0) AND
                   (strcmp(G_PBhandle->uid,only_uid) NE 0) )
                   break;
              /* WS10084 end  */
              /* WS10084
              if ( (strcmp(PBhandle->uid, "*")     EQ 0) OR
                   (strcmp(PBhandle->uid, only_uid) EQ 0) )
              {  WS10084 */
              formatted_permission[0] = NULL_CHAR;

              /* Process the permission, if required */
              rc = ESA_OK;                              /* WS10084 */
              if (PB_Req->GroupDirect OR                /* WS10084 */
                  PB_Req->AccountIndirect )             /* WS10084 */
           /* if (PBhandle->WithPermissions EQ 'Y')        WS10084 */
              {
                if (strcmp(resource_type, "DSN") EQ 0)
                  strcpy(res_type, "A");
                else
                  strcpy(res_type, "R");

                rc = Permission_Drop_Decision(rule_record,
                                              res_type,
                                              only_uid,
                                /* WS10084    'G',    */
                                /* WS10084    direct, */
                                /* WS10084 */ perm_u_or_g,
                                /* WS10084 */ direct_or_indirect,
                                              admin_params);
                ESA_DIAG_printf(comp, 17,
                   "Permission_Drop_Decision rc=%d for "
                   "res=%s uid=|%s| rule=%s",
                    rc, res_type, only_uid, rule_record);
              }                                         /* WS10084 */
           }   /* end of if G                              WS10084 */
                  /* We need this permission !!  */
           if (rc EQ ESA_OK)
           {
             strcpy(full_uid, "UID(");
             strcat(full_uid, only_uid);
             strcat(full_uid, ")");

             /*
             if (want_diag2)
                ESA_DIAG_printf(comp, 0,
                      "full_uid = %s  uid_parm: %p -> %.*s",
                      full_uid, uid_parm,
                      strlen(full_uid), uid_parm);
             */

             ESA_DIAG_printf(comp, 6,
                      "full_uid = %s  uid_parm: %p -> %.*s",
                      full_uid, uid_parm,
                      strlen(full_uid), uid_parm);

             rc = Permission_value_builder(rule_record,
                                   resource_type,
                                   key,
                                   prefix,
                                   full_uid,
                                /* direct,            WS10084 */
                               direct_or_indirect, /* WS10084 */
                                /* user_or_group,     WS10084 */
                                   perm_u_or_g,    /* WS10084 */
                                   user_or_group,  /* WS10084 */
                                   roleset_permission, /* WS10084 */
                                   sizeof(formatted_permission),
                                   formatted_permission,
                                   admin_params);
             /*
             if (want_diag2)
             {
                ESA_DIAG_printf(comp, 0 ,
                     "CAll Permission_value_builder: "
                     "key=%s pfx=%s restyp=%s uid=%s",
                      key, prefix, resource_type, full_uid);
                ESA_DIAG_printf(comp, 0,
                "Permission_value_builder rc = %d perm=%s",
                 rc, formatted_permission);
             }
             */

             ESA_DIAG_printf(comp, 17,
                     "CAll Permission_value_builder: "
                     "key=%s pfx=%s restyp=%s uid=%s",
                      key, prefix, resource_type, full_uid);
             ESA_DIAG_printf(comp, 6,
                "Permission_value_builder rc = %d perm=%s",
                 rc, formatted_permission);
             if (rc NE ESA_OK) /* output field too small so */
                                /* ignore this record and... */
             {
               sprintf(errmsg,
                          "Permission_value_builder for %s "
                          "/ %s / %s / %s / %c / %c failed.",
                          key, prefix, resource_type, full_uid,
                          /* WS10084 following is a new line */
                          direct_or_indirect, user_or_group);
                         /* direct, user_or_group);   WS10084 */
               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                             component, func, errmsg,
                             16, __LINE__);
               err_msg_rec = TRUE;
               rc = ESA_OK;          /* Skip this record     */
               break;
             };
           } /*  Permission not dropped */
           else /* Check Permission_Drop_Decision rc:        */
                 /* SKIP - We do not need this permission    */
                 /* FATAL - Permission_Drop_Decision failed  */
           if (rc NE ESA_SKIP)  /* Error */
           {
             snprintf(errmsg, sizeof(errmsg)-1,
                   "Permission_Drop_Decision rc=%d "
                   "for res=%s uid=|%s| rule=%.100s",
                      rc, res_type, only_uid, rule_record);
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     component, func, errmsg,
                     16, __LINE__);
             rc = ESA_FATAL;
             err_msg_rec = TRUE;
             break;
           }; /* No else because for ESA_SKIP the permission */
              /* is skipped.                                */
             /* WS10084
             }; /* No Else because it means permissions are not   */
                 /* needed.                                     */

             /* Add the UID and/or permission to the          */
             /* permissions block.                            */
             /*                                               */
             /* The formatted_permission field may contain a  */
             /* permission or may contain an empty string,    */
             /* depending on the value of WithPermissions and */
             /* the return code returned by                   */
             /* Permission_Drop_decition.                     */
             /* rc = Permissions_block_Insert(pbh,        WS10084 */
             if (user_or_group EQ 'U')                 /* WS10084 */
             {                                         /* WS10084 */
                pbh_g_or_u = pbh_users;                /* WS10084 */

                /* Extract LID from UID                   WS10084 */
                lid[0] = NULL_CHAR;                    /* WS10084 */
                if (ACF2_Is_LID_In_UID(&LID_Offset,    /* WS10084 */
                                       &LID_Length))   /* WS10084 */
                 strncpy (lid, only_uid+LID_Offset,    /* WS10084 */
                          LID_Length);                 /* WS10084 */
                 lidlen = strlen(lid);                 /* WS10084 */
                 for (i = lidlen -1; i GT 0; i--)      /* WS10084 */
                     if (lid[i] EQ ' ')                /* WS10084 */
                        lid[i] = NULL_CHAR;            /* WS10084 */
                     else                              /* WS10084 */
                        break;                         /* WS10084 */
             }                                         /* WS10084 */
             else                                      /* WS10084 */
                 pbh_g_or_u = pbh_groups;              /* WS10084 */

             pbh_g_or_u->skip_extYN = 'Y';             /* WS10084 */
             rc = Permissions_block_Insert(pbh_g_or_u, /* WS10084 */
                  (user_or_group EQ 'U') ? lid :       /* WS10084 */
                                           only_uid,
                                  only_g ? NULL :      /* WS10084T*/
                                           formatted_permission,
                                           comp,
                                           admin_params);
             pbh_g_or_u->skip_extYN = 'N';             /* WS10084 */
             /* WS10084 start */
             /*
             if (want_diag2)
                ESA_DIAG_printf(comp, 0,
                "Permissions_block_Insert rc = %d for %s / %s ",
                rc,
                (user_or_group EQ 'U') ? lid
                                       : only_uid,
                formatted_permission);            /* end WS10084 @/
             */

             ESA_DIAG_printf(comp, 6,
                "Permissions_block_Insert rc = %d for %s / %s ",
                rc,
                (user_or_group EQ 'U') ? lid
                                       : only_uid,
                formatted_permission);            /* end WS10084 */
            /*ESA_DIAG_printf(comp, 17,
                "Permissions_block_Insert rc = %d for %s / %s ",
                rc, only_uid, formatted_permission);     WS10084 */
             if (rc EQ ESA_OK)
             {
               /* Update the permissions block index, if needed */
           /* rc = Permissions_Block_updateIndex(&pbh,   WS10084 */
               if (user_or_group EQ 'U')              /* WS10084 */
               {                                      /* WS10084 */
                   ppbh = &pbh_users;                 /* WS10084 */
                   Any_U_Perms = TRUE;                /* WS10084 */
               }                                      /* WS10084 */
               else                                   /* WS10084 */
               {                                      /* WS10084 */
                   ppbh = &pbh_groups;                /* WS10084 */
                   Any_G_Perms = TRUE;                /* WS10084 */
               }                                      /* WS10084 */
               rc=Permissions_Block_updateIndex(ppbh, /* WS10084 */
                                                  FALSE,
                                                  comp,
                                                  admin_params);
               if (rc NE ESA_OK)
               {
                 sprintf(errmsg,
                   "Permissions_Block_updateIndex returned rc = %d",
                        rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                               dest, component,
                               func, errmsg, 16, __LINE__);
                 rc = ESA_FATAL;
               };
             }
             else
               if (rc EQ ESA_SKIP) /* (UID exists)  */
                 rc = ESA_OK;
               else
               {
                 /* WS10084 start */
                 sprintf(errmsg,
                         "Permissions_block_Insert rc = %d",
                          rc);
                 /* WS10084 end   */
                 /* WS10084
                 sprintf(errmsg,
                         "Permission_Get_UID returned with rc = %d",
                          rc);   */
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                               dest, component,
                               func, errmsg, 16, __LINE__);
                 err_msg_rec = TRUE;
                 rc = ESA_FATAL;
               }
              /* WS10084
              }; /* End of UID processing                    */
                  /* No else since we drop the rule entry if   */
                  /* the uid was not requested.                */
             /* WS10084
           } /* end of Process for 'G' type @/
             else  /* Unknown UID_type returned @/
             {
               sprintf(errmsg,
              "Permission_Get_UID returned invalid type %c for UID %.*s",
                  user_or_group,
                  (strlen(rule_record) GT 80? 30 : strlen(rule_record)),
                  rule_record);
               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                             func, errmsg, 16, __LINE__);
               err_msg_rec = TRUE;
               rc = ESA_OK;
             }
                WS10084 */
            /*  } /@ end of else for UID type  @/            WS10084 */
          }  /* end of if (roleset_permission    EQ FALSE)   WS10084 */

          else

          /* ========================================= */
          /* WS10084 start: handle ROLESET permissions */
          /* ========================================= */

          if (PB_Req->AccountRoleDirect    OR
              PB_Req->AccountRoleIndirect  OR
              PB_Req->RoleDirect)
          {
            lid[0] = NULL_CHAR;
            role[0] = NULL_CHAR;
            /* Locate USER(name) or ROLE(name) */
            rc = Permission_Get_ROLEUSER(rule_record,
                                         &roleuser_parm,
                                         admin_params);
            if (rc NE ESA_OK)
            {
              sprintf(errmsg,
                  "Could not find USER( or ROLE( in = %s",
                  rule_record);
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                        dest, component,
                        func, errmsg, 16, __LINE__);
              rc = ESA_FATAL;
              break;
            }

            to = strchr(roleuser_parm, ')');
            if (to EQ NULL)
            {
              sprintf(errmsg,
                  "Could not find closing ) after USER( or ROLE( in = %s",
                  rule_record);
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                        dest, component,
                        func, errmsg, 16, __LINE__);
              rc = ESA_FATAL;
              break;
            }

            memcpy(full_uid, roleuser_parm, to - roleuser_parm+1);
            full_uid[to - roleuser_parm + 1] = NULL_CHAR;

            ESA_DIAG_printf(comp, 6,
                     "roleuser = %s",
                     full_uid);
            ret_str = strstr(roleuser_parm, "USER(");
            if (ret_str NE NULL)
            {
              /* ======================= */
              /* ROLESET with USER(name) */
              /* ======================= */
               ESA_DIAG_printf(comp, 6,"ROLESET with USER()");

               memcpy(lid, ret_str+5, to - (ret_str+5) );
               lid[to - (ret_str+5)] = NULL_CHAR;

              if (lid[0] EQ '-')
                 break;
              if (NOT PB_Req->AccountRoleDirect)
                 break;
              user_or_group = 'U';
              direct_or_indirect = 'D';

              ESA_DIAG_printf(comp, 6,
                     "lid = %s ",
                     lid);
              if (PB_Req->SingleUser)
                 if (strcmp(lid,PB_Req->lid) NE 0)
                 {
                     ESA_DIAG_printf(comp, 6,
                       "User in rule = %s is not our user = %s \n",
                        lid, PB_Req->lid);
                     break;
                 }

            } /* end of USER() only */

            else
            { /* not USER(  */
              ret_str = strstr(roleuser_parm,"ROLE(");
              if (ret_str NE NULL)
              {
                /* ======================= */
                /* ROLESET with ROLE(name) */
                /* ======================= */
                ESA_DIAG_printf(comp, 6,"ROLESET with ROLE()");

                if ( (NOT PB_Req->RoleDirect)
                      AND
                     (NOT PB_Req->AccountRoleIndirect)
                   )
                   break;

                memcpy(role, ret_str+5, to - (ret_str+5) );
                role[to - (ret_str+5)] = NULL_CHAR;

                if ( (PB_Req->AccountRoleIndirect)
                      OR
                     (PB_Req->RoleDirect) )
                   if ( (role[0] EQ '-')  OR
                        (role[0] EQ '*') )
                      break;

                /* WS10084
                if (strcmp(role,"CHETAN") EQ 0)
                   want_diag1 = TRUE;
                else
                   want_diag1 = FALSE;
                   WS10084 */

                /*
                if (want_diag1)
                   ESA_DIAG_printf(comp, 0 ,
                      "ROLESET role %s \n",
                          role);
                if (want_diag1)
                   ESA_DIAG_printf(comp, 0 ,
                      "PB_Req->RoleDirect = %d",
                       PB_Req->RoleDirect);
                */
                /*
                if (strcmp(role,"ALROL") EQ 0)
                   want_diag = TRUE;
                else
                   want_diag = FALSE;
                  */

                if (PB_Req->RoleDirect)
                {
                   /* if the xref block was built for a single role then
                      split (if needed) to remove sysid and filter out all
                      other roles */

                   if (R_XBhandle->xrefname[0] NE '-')
                   {
                     if (strchr(R_XBhandle->xrefname, '(') NE NULL)
                     {
                        rc = XREF_Split_Name(R_XBhandle->xrefname,
                                             name,sysid,comp,admin_params);
                        if (rc  EQ ESA_FATAL)
                        {
                          sprintf(errmsg,
                           "XREF_Split_Name of %s returned rc = %d",
                           R_XBhandle->xrefname, rc);
                          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                       dest, component, func, errmsg,
                                       16, __LINE__);
                          rc = ESA_FATAL;
                          break;
                        }
                     }
                     else
                        strcpy(name,R_XBhandle->xrefname);

                     if (strcmp(name,role) NE 0) /* not our role - skip */
                     {
                        ESA_DIAG_printf(comp, 6 ,
                        "Rule for role %s skipped: doesn't match our role %s",
                          role,name);
                        rc = ESA_OK;
                        break;
                     }
                   }
                   params_ptr = admin_params->apiinit_handle;
                   if (params_ptr->DROP_GROUP_PERMS[0] NE NULL_CHAR)
                   {
                      ftype = 'N';
                      /* Drop_Perms_Match returns ESA_OK when there is a
                         match and we need to drop the perms           */
                      mrc = Drop_Perms_Match(
                             "DROP_GROUP_PERMS",
                             params_ptr->DROP_GROUP_PERMS,
                             name,
                             'R',
                             &ftype,
                             comp,
                             admin_params);
                      if (mrc EQ ESA_OK)
                      {
                         rc = ESA_OK;
                         break;
                      }
                   }
                }

                if (PB_Req->AccountRoleIndirect)
                {
                  user_or_group = 'U';
                  direct_or_indirect = 'I';
                }
                else
                if (PB_Req->RoleDirect)
                {
                  user_or_group = 'G';
                  direct_or_indirect = 'D';
                }
                else
                  break;

                /*
                if (want_diag1)
                 ESA_DIAG_printf(comp, 0,
                 "user_or_group = %c direct_or_indirect = %c",
                 user_or_group, direct_or_indirect);
                */
              }   /* end of ROLE() only */
            } /* end of not USER() */

            /* ========================  */
            /* common for USER() ROLE()  */
            /* ========================  */

            if (PB_Req->AccountRoleIndirect OR PB_Req->RoleDirect)
            {
              /* ======================================== */
              /* Call Permission_Drop_Decision for ROLE() */
              /* ======================================== */

              if (strcmp(resource_type, "DSN") EQ 0)
                strcpy(res_type, "A");
              else
                strcpy(res_type, "R");
              role_in_paren[0] = NULL_CHAR;
              strcat(role_in_paren, "(");
              strcat(role_in_paren, role);
              strcat(role_in_paren, ")");
              if ( (direct_or_indirect NE 'D') OR
                   (NOT PB_Req->AccountRoleDirect) )
              rc = Permission_Drop_Decision(rule_record,
                                            res_type,
                                            role_in_paren,
                                            user_or_group,
                                            direct_or_indirect,
                                            admin_params);
              /*
              if (want_diag1)
                ESA_DIAG_printf(comp, 0,
                "Permission_Drop_Decision rc=%d for res=%s role=|%s| "
                "rule=%s",
                rc, res_type, role, rule_record);
              */

              if (rc NE ESA_OK)
                ESA_DIAG_printf(comp, 6,
                "Permission_Drop_Decision rc=%d for res=%s role=|%s| "
                "rule=%s",
               rc, res_type, role, rule_record);
              ESA_DIAG_printf(comp, 17,
              "Permission_Drop_Decision rc=%d for res=%s role=|%s| "
              "rule=%s",
               rc, res_type, role, rule_record);

              if (rc EQ ESA_SKIP)
              {
                 break;
              }

              if (rc NE ESA_OK)  /* Error */
              {
                snprintf(errmsg, sizeof(errmsg)-1,
                 "Permission_Drop_Decision "
                 "rc=%d for res=%s uid=|%s| rule=%.100s",
                         rc, res_type, only_uid, rule_record);
                CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                        component, func, errmsg,
                        16, __LINE__);
                rc = ESA_FATAL;
              /*err_msg_rec = TRUE;  */
                break;
              }
            }

            /* ====================== */
            /* Extract the permission */
            /* ====================== */

            /*
            if (want_diag1)
            {
               ESA_DIAG_printf(comp, 0 ,
                  "ROLE = |%s| before Permission_value_builder \n"
                  "rule_record        =  %s "
                  "resource_type      =  %s "
                  "key                =  %s "
                  "prefix             =  %s "
                  "full_uid           =  %s "
                  "direct_or_indirect =  %c "
                  "user_or_group      =  %c \n",
                   role,
                   rule_record,
                   resource_type,
                   key,
                   prefix,
                   full_uid,
                   direct_or_indirect,
                   user_or_group);
            }
            */
            rc = Permission_value_builder(rule_record,
                                  resource_type,
                                  key,
                                  prefix,
                                  full_uid,
                                  direct_or_indirect,
                                  user_or_group,
                                  user_or_group,      /* WS10084 */
                                  roleset_permission, /* WS10084 */
                                  sizeof(formatted_permission),
                                  formatted_permission,
                                  admin_params);
            ESA_DIAG_printf(comp, 6 ,
              "CAll Permission_value_builder: "
              "key=%s pfx=%s restyp=%s role=%s",
              key, prefix, resource_type, full_uid);
            /*
            if (want_diag1)
             ESA_DIAG_printf(comp, 0,
               "Permission_value_builder rc = %d perm=%s",
                rc, formatted_permission);
               */

            ESA_DIAG_printf(comp, 6,
               "Permission_value_builder rc = %d perm=%s",
                rc, formatted_permission);

            if (rc NE ESA_OK) /* output field too small so */
                               /* ignore this record and... */
            {
              sprintf(errmsg,
               "Permission_value_builder for %s "
               "/ %s / %s / %s / %c / %c failed.",
                 key, prefix, resource_type, full_uid,
              direct_or_indirect, "U");
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                            component, func, errmsg,
                            16, __LINE__);
              err_msg_rec = TRUE;
              rc = ESA_OK;          /* Skip this record     */
              break;
            };

            /* If USER insert into users block */
            if (lid[0] NE NULL_CHAR)
            {
               pbh_users->skip_extYN = 'Y';
               rc = Permissions_block_Insert(pbh_users,
                                             lid,
                                             formatted_permission,
                                             comp,
                                             admin_params);
               pbh_users->skip_extYN = 'N';
               ESA_DIAG_printf(comp, 17,
                  "Permissions_block_Insert rc = %d for %s / %s ",
                  rc, lid, formatted_permission);
               if (rc EQ ESA_OK)
               {
                 Any_U_Perms = TRUE;
                 /* Update the permissions block index, if needed */
                 rc=Permissions_Block_updateIndex(&pbh_users,
                                                  FALSE,
                                                  comp,
                                                  admin_params);
                 if (rc NE ESA_OK)
                 {
                   sprintf(errmsg,
                     "Permissions_Block_updateIndex Users rc = %d",
                          rc);
                   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                 dest, component,
                                 func, errmsg, 16, __LINE__);
                   rc = ESA_FATAL;
                   break;
                 };
               }

               else
               if (rc EQ ESA_SKIP) /* (lid exists, permission added)  */
               {
                  rc = ESA_OK;
                  break;
               }
               else
               {
                 sprintf(errmsg,
                         "Permissions_block_Insert Users with rc = %d",
                          rc);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                               dest, component,
                               func, errmsg, 16, __LINE__);
             /*  err_msg_rec = TRUE;   */
                 rc = ESA_FATAL;
                 break;
               }
            }

            if ( (role[0] NE NULL_CHAR)    AND
                 (NOT PB_Req->PB_xref_nf) )
            {

              if (R_XBhandle NE NULL)
              {
                if (  (R_PBhandle EQ NULL) AND
                      (RG_PBhandle EQ NULL))
                {
                   ESA_DIAG_printf(comp, 6,
                           "Before XREF_Block_Build  BUILD");
                   rc = XREF_Block_Build("BUILD",
                                         R_XBhandle,
                                         comp,
                                         admin_params);

                  ESA_DIAG_printf(comp, 9,
                          "XREF_Block_Build returned rc - <%i>", rc);

                  if( rc NE ESA_OK)
                  {
                     if (rc EQ ESA_KEY_NOT_FOUND)
                     {
                       PB_Req->PB_xref_nf = TRUE;
                       rc = ESA_OK;
                       break;
                     }
                     else
                     {
                       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                             dest, component, func,
                             "XREF_Block_Build failed to BUILD.",
                             rc, __LINE__);
                       rc = ESA_FATAL;
                       break;
                     }
                  }
                  /* R_XBhandle = PB_Req->Roles_XBhandle_ptr; */
                  R_PBhandle  = R_XBhandle->XREF_PB_handle;
                  RG_PBhandle = R_XBhandle->Groups_PB_handle;
                  ESA_DIAG_printf(comp, 6 ,
                  "After XREF_Block_Build: "
                  "request_type = %s "
                  "R_XBhandle  = %p "
                  "R_PBhandle  = %p "
                  "RG_PBhandle = %p ",
                   R_XBhandle->request_type,
                   R_XBhandle,
                   R_PBhandle,
                   RG_PBhandle);

                }
                /* Insert under the active role/rolegroup.
                   if no active - drop */
                /*
                if (want_diag)
                   ESA_DIAG_printf(comp, 0,
                           "Before Chain_On_Active");
                  */

                 rc = Chain_On_Active(R_XBhandle,
                                      role,
                                      formatted_permission,
                                      comp,
                                      admin_params);
                /*
                if (want_diag)
                   ESA_DIAG_printf(comp, 0,
                           "Chain_On_Active rc = %d",rc);
                  */

                 if (rc EQ ESA_OK)
                    Any_R_Perms = TRUE;
                 else
                 if (rc EQ ESA_KEY_NOT_FOUND)
                    rc = ESA_OK;
              }
            }
          }
          /* WS10084 end  : handle ROLESET */
          break;
  /*
  */
        default:
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                        func, "record type unknown", 16, __LINE__);
          rc=ESA_FATAL;
          break;

      } /* end of switch */

      if (err_msg_rec)
      {
         CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest,
                       "The record printed below is skipped");

         sprintf(errmsg, "rec=%.*s",
                 (strlen(rule_record) LE sizeof(errmsg)-5 ?
                       strlen(rule_record) : sizeof(errmsg)-5),
                  rule_record);
         CTSAMSG_print(ERR_TL_STRING, msgs, NULL, dest, errmsg);

         err_msg_rec = FALSE;
      }
    } while ((rc EQ ESA_OK) OR (rc EQ ESA_SKIP) );   /* WS10084 */
    /* } while (rc EQ ESA_OK);                          WS10084 */

    /*
     * The permissions block was created successfully
     */
    if (rc EQ ESA_EOF)
    {
      /*  Update the permissions block index */

      /* WS10084 start */
         rc = ESA_OK;
         if ( (NOT Any_G_Perms) AND PB_Req->GroupDirect)
         {
           sprintf(errmsg,"Group Direct");
           CTSAMSG_print(ACF2_NO_PERMISSIONS, msgs, NULL,
                           dest, errmsg);
         }

         if ( (NOT Any_G_Perms)         AND
              (PB_Req->AccountIndirect) AND
              (NOT PB_Req->SingleUser)
            )
         {
           sprintf(errmsg,"Account Indirect");
           CTSAMSG_print(ACF2_NO_PERMISSIONS, msgs, NULL,
                           dest, errmsg);
         }

         if ( (NOT Any_U_Perms)         AND
              (PB_Req->AccountDirect)   AND
              (NOT PB_Req->SingleUser)
            )
         {
           sprintf(errmsg,"Account Direct");
           CTSAMSG_print(ACF2_NO_PERMISSIONS, msgs, NULL,
                           dest, errmsg);
         }

         if ( (NOT Any_U_Perms)            AND
              (PB_Req->AccountRoleDirect)  AND
              (NOT PB_Req->SingleUser)
            )
         {
           sprintf(errmsg,"Account Role Direct");
           CTSAMSG_print(ACF2_NO_PERMISSIONS, msgs, NULL,
                           dest, errmsg);
         }

         if ( (NOT Any_R_Perms) AND PB_Req->AccountRoleIndirect)
         {
           sprintf(errmsg,"Account Role Indirect");
           CTSAMSG_print(ACF2_NO_PERMISSIONS, msgs, NULL,
                           dest, errmsg);
         }

         if ( (NOT Any_R_Perms)    AND
              (PB_Req->RoleDirect) AND
              (R_XBhandle->xrefname[0] EQ '-')
            )
         {
           sprintf(errmsg,"Group Role Direct");
           CTSAMSG_print(ACF2_NO_PERMISSIONS, msgs, NULL,
                           dest, errmsg);
         }

      if ( (G_PBhandle NE NULL) AND (pbh_groups NE NULL) )
      {
        ESA_DIAG_printf(comp, 2 ,
                        "Permisions Block Groups created at address %p",
                        pbh);
        rc = Permissions_Block_updateIndex(&pbh_groups,
                                           TRUE,
                                           comp,
                                           admin_params);
        ESA_DIAG_printf(comp, 2,
           "Permissions_Block_updateIndex Groups (LAST) - rc = %d  pb = %p",
            rc, pbh_groups);
        if (rc EQ ESA_OK)
        {
          G_PBhandle->PBptr = pbh_groups; /* When all OK, return pb address */
          G_PBhandle->PBbldErr = FALSE;
          G_PBhandle->PBnf = FALSE;
          G_PBhandle->PBErr = FALSE;
        }
        else
        {
          sprintf(errmsg,
             "Permissions_Block_updateIndex Groups (LAST) returned rc = %d",
              rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                        dest, component,
                        func, errmsg, 16, __LINE__);
          rc = ESA_FATAL;
          goto bld_exit;
        };

        if (ESA_DIAG_get_debug_level(comp) GE 1)
        {
          G_PBhandle->curUIDinPB = NULL;
          do
          {
            G_PBhandle->PBptr->skip_extYN = 'Y';
            ug_rc = Permissions_block_Get("UIDNEXT",
                                           G_PBhandle,
                                           uid,
                                           NULL,
                                           0,
                                           comp,
                                           admin_params);
            G_PBhandle->PBptr->skip_extYN = 'N';
            if (ug_rc NE ESA_OK)
               continue;

               /* print the uid */
               ESA_DIAG_printf(comp, 6 ,
                  "UID = |%s| permissions: \n", uid);
            do
            {
               G_PBhandle->PBptr->skip_extYN = 'Y';
               pg_rc = Permissions_block_Get("PERMNEXT",
                                            G_PBhandle,
                                            uid,
                                            perm_data,
                                            sizeof(perm_data),
                                            comp,
                                            admin_params);
               G_PBhandle->PBptr->skip_extYN = 'N';
               if (pg_rc  NE  ESA_OK)
                  continue;
               /* print the permission */
               ESA_DIAG_printf(comp, 6 ,
                  "      |%s| \n", perm_data);
            }
            while (pg_rc EQ ESA_OK);
            if (pg_rc  NE  ESA_EOF)
               break;
            else
               continue;

          }
          while (ug_rc EQ ESA_OK);
        }
      }

      if ( (U_PBhandle NE NULL) AND (pbh_users NE NULL) )
      {
        ESA_DIAG_printf(comp, 2 ,
                        "Permisions Block Users created at address %p",
                        pbh);
        rc = Permissions_Block_updateIndex(&pbh_users,
                                           TRUE,
                                           comp,
                                           admin_params);
        ESA_DIAG_printf(comp, 2,
           "Permissions_Block_updateIndex Users (LAST) - rc = %d  pb = %p",
            rc, pbh_users);
        if (rc EQ ESA_OK)
        {
          U_PBhandle->PBptr = pbh_users; /* When all OK, return pb address */
          U_PBhandle->PBbldErr = FALSE;
          U_PBhandle->PBnf = FALSE;
          U_PBhandle->PBErr = FALSE;
        }
        else
        {
          sprintf(errmsg,
             "Permissions_Block_updateIndex Users (LAST) returned rc = %d",
              rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                        dest, component,
                        func, errmsg, 16, __LINE__);
          rc = ESA_FATAL;
          goto bld_exit;
        };

        if (ESA_DIAG_get_debug_level(comp) GE 1)
        {
          U_PBhandle->curUIDinPB = NULL;
          do
          {
            U_PBhandle->PBptr->skip_extYN = 'Y';
            ug_rc = Permissions_block_Get("UIDNEXT",
                                           U_PBhandle,
                                           uid,
                                           NULL,
                                           0,
                                           comp,
                                           admin_params);
            U_PBhandle->PBptr->skip_extYN = 'N';
            if (ug_rc NE ESA_OK)
               continue;

               /* print the uid */
               ESA_DIAG_printf(comp, 6 ,
                  "LID = |%s| permissions: \n", uid);
            do
            {
               U_PBhandle->PBptr->skip_extYN = 'Y';
               pg_rc = Permissions_block_Get("PERMNEXT",
                                            U_PBhandle,
                                            uid,
                                            perm_data,
                                            sizeof(perm_data),
                                            comp,
                                            admin_params);
               U_PBhandle->PBptr->skip_extYN = 'N';
               if (pg_rc  NE  ESA_OK)
                  continue;
               /* print the permission */
               ESA_DIAG_printf(comp, 6 ,
                  "      |%s| \n", perm_data);
            }
            while (pg_rc EQ ESA_OK);
            if (pg_rc  NE  ESA_EOF)
               break;
            else
               continue;

          }
          while (ug_rc EQ ESA_OK);
        }
      }

      if (ESA_DIAG_get_debug_level(comp) GE 1)
      {
        if (R_PBhandle NE NULL)
        {
          R_PBhandle->curUIDinPB = NULL;
          do
          {
            /*
            if (want_diag)
            {
               ESA_DIAG_printf(comp, 0 ,
                  "ROLE = |%s| before UIDNEXT curUIDinPB = %p \n",
                  uid, R_PBhandle->curUIDinPB);
               ESA_DIAG_printf(comp, 0 ,
                  "Before UIDNEXT curUIDinPB->next_uid = %p \n",
                  R_PBhandle->curUIDinPB->next_uid);

               SNAP_AREA("curUIDinPB", R_PBhandle->curUIDinPB,
                      sizeof(PERM_BLK_UID_rec_typ))
               SNAP_AREA("curUIDinPB->next_uid",
               R_PBhandle->curUIDinPB->next_uid,
                      sizeof(PERM_BLK_UID_rec_typ))
            }
              */

            R_PBhandle->PBptr->skip_extYN = 'Y';
            ug_rc = Permissions_block_Get("UIDNEXT",
                                           R_PBhandle,
                                           uid,
                                           NULL,
                                           0,
                                           comp,
                                           admin_params);
            R_PBhandle->PBptr->skip_extYN = 'N';
            /*
            if (want_diag)
               ESA_DIAG_printf(comp, 0 ,
                  "rc from UIDNEXT = %d \n", ug_rc);
              */

            if (ug_rc NE ESA_OK)
               continue;

               /* print the uid */
               ESA_DIAG_printf(comp, 6 ,
                  "ROLE = |%s| permissions: \n", uid);
         /* if (strcmp(uid,"FIN2ROL2") EQ 0)
               want_diag1 = TRUE;  */
            /*
            if (want_diag)
            {
               ESA_DIAG_printf(comp, 0 ,
                  "ROLE = |%s| before PERMNEXT curUIDinPB = %p \n",
                  uid, R_PBhandle->curUIDinPB);
               SNAP_AREA("curUIDinPB", R_PBhandle->curUIDinPB,
                      sizeof(PERM_BLK_UID_rec_typ))
               SNAP_AREA("curUIDinPB->next_uid",
               R_PBhandle->curUIDinPB->next_uid,
                      sizeof(PERM_BLK_UID_rec_typ))
            }
              */

            do
            {
               R_PBhandle->PBptr->skip_extYN = 'Y';
               pg_rc = Permissions_block_Get("PERMNEXT",
                                            R_PBhandle,
                                            uid,
                                            perm_data,
                                            sizeof(perm_data),
                                            comp,
                                            admin_params);
               R_PBhandle->PBptr->skip_extYN = 'N';
               /*
               if (want_diag)
               {
                 ESA_DIAG_printf(comp, 0 ,
                  "ROLE = |%s| after PERMNEXT curUIDinPB = %p \n",
                  uid, R_PBhandle->curUIDinPB);
                 SNAP_AREA("curUIDinPB", R_PBhandle->curUIDinPB,
                      sizeof(PERM_BLK_UID_rec_typ))
                 SNAP_AREA("curUIDinPB", R_PBhandle->curUIDinPB->next_uid,
                      sizeof(PERM_BLK_UID_rec_typ))
               }
                 */

               if (pg_rc  NE  ESA_OK)
                  continue;
               /* print the permission */
               ESA_DIAG_printf(comp, 6 ,
                  "      |%s| \n", perm_data);
            }
            while (pg_rc EQ ESA_OK);
            if (pg_rc  NE  ESA_EOF)
               break;
            else
               continue;

          }
          while (ug_rc EQ ESA_OK);
        }
      }

      if (ESA_DIAG_get_debug_level(comp) GE 1)
      {
        if (RG_PBhandle NE NULL)
        {
          RG_PBhandle->curUIDinPB = NULL;
          do
          {
            RG_PBhandle->PBptr->skip_extYN = 'Y';
            ug_rc = Permissions_block_Get("UIDNEXT",
                                           RG_PBhandle,
                                           uid,
                                           NULL,
                                           0,
                                           comp,
                                           admin_params);
            RG_PBhandle->PBptr->skip_extYN = 'N';
            if (ug_rc NE ESA_OK)
               continue;

               /* print the uid */
               ESA_DIAG_printf(comp, 6 ,
                  "ROLEG = |%s| permissions: \n", uid);
            do
            {
               RG_PBhandle->PBptr->skip_extYN = 'Y';
               pg_rc = Permissions_block_Get("PERMNEXT",
                                            RG_PBhandle,
                                            uid,
                                            perm_data,
                                            sizeof(perm_data),
                                            comp,
                                            admin_params);
               RG_PBhandle->PBptr->skip_extYN = 'N';
               if (pg_rc  NE  ESA_OK)
                  continue;
               /* print the permission */
               ESA_DIAG_printf(comp, 6 ,
                  "      |%s| \n", perm_data);
            }
            while (pg_rc EQ ESA_OK);
            if (pg_rc  NE  ESA_EOF)
               break;
            else
               continue;

          }
          while (ug_rc EQ ESA_OK);
        }
      }
      /* WS10084 end   */
      /* WS10084
      ESA_DIAG_printf(comp, 2 ,
                      "Permisions Block created at address %p",
                      pbh);
      rc = Permissions_Block_updateIndex(&pbh,
                                         TRUE,
                                         comp,
                                         admin_params);
      ESA_DIAG_printf(comp, 2,
         "Permissions_Block_updateIndex (LAST) - rc = %d  pb = %p",
          rc, pbh);
      if (rc EQ ESA_OK)
      {
        PBhandle->PBptr = pbh;  /* When all OK, return pb address @/
        PBhandle->PBbldErr = FALSE;
        PBhandle->PBnf = FALSE;                           /* WS10079N @/
        PBhandle->PBErr = FALSE;
      }
      else
      {
        sprintf(errmsg,
                "Permissions_Block_updateIndex (LAST) returned rc = %d",
                rc);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                      dest, component,
                      func, errmsg, 16, __LINE__);
        rc = ESA_FATAL;
      };
       WS10084 */
    };

    if (rc NE ESA_OK)  /* Permission block build failed */
    {
    /* WS10084
       PBhandle->PBbldErr = TRUE;
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, "Permissions Block creation failed",
                     16, __LINE__);
       WS10084 */
       PB_Req->PBbldErr = TRUE;
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, "Permissions Blocks creation failed",
                     16, __LINE__);
       rc = ESA_FATAL;
    }


   /*
    * Perform cleanup for the BUILD process
    */
  bld_exit:
    /* BS10111 ESA_DIAG_printf(PLT_COMP_XREF, 6,   /@ WS10078T @/ */
    ESA_DIAG_printf(comp, 6,"At bld_exit");           /* WS10084  */
    ESA_DIAG_printf(comp, 6,                          /* BS10111  */
                    "Calling Get_Rule_Record TERM");  /* WS10078T */
    trm_rc = Get_Rule_Record("TERM",
                             &get_rule_rec_handle,
            /* BS10111       get_line_ptr,    */
            /* BS10111       &getline_parms,  */
                             NULL,                        /* BS10111 */
/* WS10078S                  NULL,                                  */
                             0,
                             0,
                             "",
                             NULL,
                             NULL,
                             NULL,
                             admin_params);

    ESA_DIAG_printf(comp, 6,"Get_Rule_Record  TERM rc=%d ",   /* WS10084  */
    trm_rc);

    if (trm_rc NE ESA_OK)
    {
      sprintf(errmsg,
              "Get_Rule_Record (TERM) returned rc = %d   handle = %p",
              trm_rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, errmsg, 12, __LINE__);
    }

    get_rule_rec_handle = NULL;

    /* BS10111 - the code below is replaced
    trm_rc = ESA_CLI_del_RUOB(p_ruob,
                              admin_params);
    if (trm_rc NE ESA_OK)
    {
      sprintf(errmsg,
              "ESA_CLI_del_RUOB returned rc = %d  for ruob = %p",
              trm_rc, p_ruob);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, errmsg, 12, __LINE__);
    };

    p_ruob = NULL;
        end of replaced code - BS10111 */

    ESA_DIAG_printf(comp, 6,                              /* WS10084 */
    "Before (*p_ctsaruh)(CTSARUH_REQ_FREERUOB");          /* WS10084 */
    int_rc = (*p_ctsaruh)(CTSARUH_REQ_FREERUOB,           /* BS10111 */
                    NULL, p_ruob,                         /* BS10111 */
                    NULL, NULL, NULL, NULL,               /* BS10111 */
                    &dbglvl, CTSARUH_DBGTYPE_PRTDBG,      /* BS10111 */
                    errmsg, sizeof(errmsg), NULL);        /* BS10111 */
    ESA_DIAG_printf(comp, 6,                              /* BS10111 */
                    "CTSARUH - %s: rc = %d",              /* BS10111 */
                     CTSARUH_REQ_FREERUOB, int_rc);       /* BS10111 */

    if (int_rc NE 0)   /* if not OK - issue error msg        BS10111 */
    {                                                     /* BS10111 */
       if (errmsg[0] NE NULL_CHAR)                        /* BS10111 */
         CTSAMSG_print(ERR_TL_STRING,                     /* BS10111 */
                       msgs, NULL, dest, errmsg);         /* BS10111 */
       sprintf(errmsg,                                    /* BS10111 */
           "CTSARUH - %s failed with rc = %d.",           /* BS10111 */
           CTSARUH_REQ_FREERUOB, int_rc);                 /* BS10111 */

       CTSAMSG_print(ERR_INTERNAL2, msgs,                 /* BS10111 */
                     NULL, dest,                          /* BS10111 */
                     component, func, errmsg,             /* BS10111 */
                     int_rc, __LINE__);                   /* BS10111 */
    };                                                    /* BS10111 */
    /*  WS10084 start        */
    /*  Handle  multiple PBs */
    if (rc EQ ESA_FATAL)
    {
      if (pbh_groups NE NULL)
         Permissions_block_Print(pbh_groups, comp, admin_params);
      trm_rc = Permissions_block_Free(pbh_groups,
                                      comp,
                                      admin_params);
      if (trm_rc NE ESA_OK)
      {
        sprintf(errmsg,
                "Permissions_block_Free returned rc = %d  for pb = %p",
                trm_rc, pbh_groups);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      func, errmsg, 12, __LINE__);
      };

      pbh_groups = NULL;

      if (pbh_users NE NULL)
         Permissions_block_Print(pbh_users, comp, admin_params);
      trm_rc = Permissions_block_Free(pbh_users,
                                      comp,
                                      admin_params);
      if (trm_rc NE ESA_OK)
      {
        sprintf(errmsg,
                "Permissions_block_Free returned rc = %d  for pb = %p",
                trm_rc, pbh_users);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      func, errmsg, 12, __LINE__);
      };

      pbh_users = NULL;
    }
    else
    {
      if (ESA_DIAG_get_debug_level(comp) GE 15)
      {
         Permissions_block_Print(pbh_groups, comp, admin_params);
         Permissions_block_Print(pbh_users, comp, admin_params);
      }
    }
    /*  WS10084 end          */
    /* WS10084
    if (rc NE ESA_OK)
    {
      if (pbh NE NULL)                                   /* WS10076S @/
         Permissions_block_Print(pbh, comp, admin_params);
      trm_rc = Permissions_block_Free(pbh,
                                      comp,
                                      admin_params);
      if (trm_rc NE ESA_OK)
      {
        sprintf(errmsg,
                "Permissions_block_Free returned rc = %d  for pb = %p",
                trm_rc, p_ruob);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      func, errmsg, 12, __LINE__);
      };

      pbh = NULL;
    }
    else
    {
      if (ESA_DIAG_get_debug_level(comp) GE 15)
         Permissions_block_Print(pbh, comp, admin_params);
    }
      WS10084 */
  }
  else
    if ( strcmp(function, "FREE") EQ 0 )
    {
      /**************************************************************
       *
       *    FREE
       *
       *    Free the permissins block.
       *
       *************************************************************/
      /* WS10084 start */
      rc = ESA_OK;
      if (PB_Req EQ NULL)
        goto exit;
      /* BS10133
      ESA_DIAG_printf(comp, 6,
          "At Permissions_block_Free "
          "G PBptr = %p "
          "U PBptr = %p ",
          PB_Req->Groups_PBhandle_ptr->PBptr,
          PB_Req->Users_PBhandle_ptr->PBptr);
      BS10133 */

      /* BS10133 start */
      if (PB_Req->Groups_PBhandle_ptr NE NULL)
       ESA_DIAG_printf(comp, 6,
          "At Permissions_block_Free "
          "G PBptr = %p ",
          PB_Req->Groups_PBhandle_ptr->PBptr);
      if (PB_Req->Users_PBhandle_ptr NE NULL)
       ESA_DIAG_printf(comp, 6,
          "At Permissions_block_Free "
          "U PBptr = %p ",
          PB_Req->Users_PBhandle_ptr->PBptr);
      /* BS10133 end   */

      if (PB_Req->Groups_PBhandle_ptr NE NULL)     /* BS10133 */
      if (PB_Req->Groups_PBhandle_ptr->PBptr NE NULL)
      {
        PB_Req->Groups_PBhandle_ptr->PBptr->skip_extYN = 'Y';
        rc = Permissions_block_Free(
                  PB_Req->Groups_PBhandle_ptr->PBptr,
                  comp,
                  admin_params);
        if (rc NE ESA_OK)
        {
          sprintf(errmsg,
               "Groups Permissions_block_Free returned rc = %d  for pb = %p",
                rc, p_ruob);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                        func, errmsg, 12, __LINE__);
        };
      }

      if (PB_Req->Users_PBhandle_ptr NE NULL)         /* BS10133 */
      if (PB_Req->Users_PBhandle_ptr->PBptr NE NULL)
      {

        PB_Req->Users_PBhandle_ptr->PBptr->skip_extYN = 'Y';
        rc = Permissions_block_Free(
                  PB_Req->Users_PBhandle_ptr->PBptr,
                  comp,
                  admin_params);
        if (rc NE ESA_OK)
        {
          sprintf(errmsg,
               "Users Permissions_block_Free returned rc = %d  for pb = %p",
                rc, p_ruob);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                        func, errmsg, 12, __LINE__);
        };
      }
      /* WS10084 end   */
      /* WS10084
      if (PBhandle->PBptr NE NULL)
      {
        rc = Permissions_block_Free(PBhandle->PBptr,
                                    comp,
                                    admin_params);
        if (trm_rc NE ESA_OK)
        {
          sprintf(errmsg,
               "Permissions_block_Free returned rc = %d  for pb = %p",
               trm_rc, p_ruob);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                        func, errmsg, 12, __LINE__);
        };
      }
      else
        rc = ESA_OK;
         WS10084 */
    }
    /*
     *    Unknown request
     */
    else
    {
      sprintf(errmsg, "Invalid function %s", function);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
             errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }

 exit:

  ESA_DIAG_exit(comp, 1, func, rc);
  return rc;
}
/* WS10076N+S - end   */
/* WS10076N+S - end   */

/* WS10084 Start */
 /********************************************************************
 * Procedure Name: Chain_On_Active
 *********************************************************************
 * Description   : Cahin a permission on given role only if active.
 *                 Search the active role on both XREF blocks.
 *
 * Input         : XBhandle : XBhandle
 *                 role     : role
 *                 perm_data: permission
 *
 * RC              ESA_OK
 *                 ESA_KEY_NOT_FOUND - active role not found
 *                 ESA_ERR           - permission is too long.
 *                 ESA_FATAL
 *
 ********************************************************************/
ESA_RC Chain_On_Active(
                      XBhandle_rec_typ      * XBhandle,
                      char                  * role,
                      char                  * perm_data,
                      ESA_DIAG_COMP_typ       comp,
                      ADMIN_PARAMS_rec_typ  * admin_params)
{
  static char    func[] = "Chain_On_Active";
  ESA_RC         rc     = ESA_OK;
  PBhandle_typ                * R_PBhandle  = NULL;
  PBhandle_typ                * RG_PBhandle = NULL;
  PBhandle_typ                * Short_PBhandle  = NULL;
  PBhandle_typ                * Long_PBhandle   = NULL;
  PBhandle_typ                * Search_PBhandle = NULL;
  XB_SYSID_entry_rec_typ      * psysid          = NULL; /* P_SYSID */
  PERM_BLK_UID_rec_typ        * pUID            = NULL;
  PERM_BLK_PERM_rec_typ       * newPerm         = NULL;
  int                           search_only_r   = FALSE;
  ACF2_PARAMS_rec_typ         * params_ptr      = NULL;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  /*
   *   Initializtion
   */
  ESA_DIAG_enter(comp, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  params_ptr = admin_params->apiinit_handle;

  if( (perm_data EQ NULL)  OR
      (perm_data[0] EQ NULL_CHAR) )
  {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, "Permission data not provided",
                    12, __LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

  /*
  if (want_diag)
  ESA_DIAG_printf(comp, 0,
                  "Looking for active role = %s \n"
                  "permission = %s \n",
                  role,perm_data);
    */


  ESA_DIAG_printf(comp, 6,
                  "Looking for active role = %s \n"
                  "permission = %s \n",
                  role,perm_data);

  R_PBhandle  = XBhandle->XREF_PB_handle;
  RG_PBhandle = XBhandle->Groups_PB_handle;

  /*
  if (want_diag)
  ESA_DIAG_printf(comp, 0, "XBhandle->shortest = %c", XBhandle->shortest);
    */

  ESA_DIAG_printf(comp, 6, "XBhandle->shortest = %c", XBhandle->shortest);
  if (XBhandle->shortest EQ 'X')
  {
     Short_PBhandle  = R_PBhandle;
     Search_PBhandle = R_PBhandle;
     Long_PBhandle   = RG_PBhandle;
  }
  else
  if (XBhandle->shortest EQ 'G')
  {
     Short_PBhandle = RG_PBhandle;
     Long_PBhandle  = R_PBhandle;
  }
  else
  {
     Short_PBhandle = NULL;
     Long_PBhandle  = NULL;
     search_only_r   = TRUE;
  }

  /*
  if (want_diag)
  {
  ESA_DIAG_printf(comp, 0,
               "search_only_r = %d", search_only_r);
  ESA_DIAG_printf(comp, 0,
               "From XBhandle: \n"
               "shortest            = %c "
               "XREF_PB_handle      = %p ",
                XBhandle->shortest,
                R_PBhandle);
  ESA_DIAG_printf(comp, 0,
               "Groups_PB_handle    = %p "
               "Short_PBhandle      = %p "
               "Long_PBhandle       = %p ",
                RG_PBhandle,
                Short_PBhandle,
                Long_PBhandle);
  }
    */

  ESA_DIAG_printf(comp, 6,
               "search_only_r = %d", search_only_r);
  ESA_DIAG_printf(comp, 6,
               "From XBhandle: \n"
               "shortest            = %c "
               "XREF_PB_handle      = %p ",
                XBhandle->shortest,
                R_PBhandle);
  ESA_DIAG_printf(comp, 6,
               "Groups_PB_handle    = %p "
               "Short_PBhandle      = %p "
               "Long_PBhandle       = %p ",
                RG_PBhandle,
                Short_PBhandle,
                Long_PBhandle);

  /* search 1st in the short block is exists else only in R */

  if (Short_PBhandle NE NULL)
     Search_PBhandle = Short_PBhandle;
  else
     Search_PBhandle = R_PBhandle;

  Search_PBhandle->PBptr->skip_extYN = 'Y';
  rc = Permissions_block_Get("UIDTHIS",
                             Search_PBhandle,
                             role,
                             NULL,
                             0,
                             comp,
                             admin_params);
  Search_PBhandle->PBptr->skip_extYN = 'N';

  /*
  if (want_diag)
  ESA_DIAG_printf(comp, 0,
                  "Permissions_block_Get in short or R rc = %d \n",
                  rc);
    */

  ESA_DIAG_printf(comp, 6,
                  "Permissions_block_Get in short or R rc = %d \n",
                  rc);

  if (rc EQ ESA_FATAL)
     goto exit;

  if (rc EQ ESA_OK)
  {
     if(params_ptr->XREF_SYSID_SCOPE[0] NE 'a')
     {
       pUID = Search_PBhandle->curUIDinPB;
       goto chain;
     }

     /*
     if (want_diag)
     {
       SNAP_AREA("Search_PBhandle", Search_PBhandle,
              sizeof(PERM_BLK_UID_rec_typ))

       if (Search_PBhandle->curUIDinPB NE NULL)
       {
        SNAP_AREA("curUIDinPB", Search_PBhandle->curUIDinPB,
              sizeof(PERM_BLK_UID_rec_typ))
       }
     }
       */


     /* check if it is active  */
     if (Search_PBhandle->curUIDinPB NE NULL)
     {
       psysid = Search_PBhandle->curUIDinPB->P_SYSID;

     /* TEST START
     if (psysid NE NULL)
     {
      SNAP_AREA("First psysid", psysid,
            sizeof(XB_SYSID_entry_rec_typ))
     }
        TEST END */

       ESA_DIAG_printf(comp, 2,
                    "First SYSID = %p \n", psysid);

       while (psysid NE NULL)
       {
          ESA_DIAG_printf(comp, 6,
                    "SYSID = %p/%s  Active = %c \n",
                    psysid, psysid->SYSID, psysid->ActiveYN);

         if (psysid->ActiveYN EQ 'Y')
         {
            ESA_DIAG_printf(comp, 6,
                    "Found active in short block \n");
            pUID = Search_PBhandle->curUIDinPB;
            goto chain;
         }
         psysid = psysid->next_sysid;
         /* TEST START
         if (psysid NE NULL)
         {
          SNAP_AREA("Next psysid", psysid,
                sizeof(XB_SYSID_entry_rec_typ))
         }
            TEST END */
       }
     }
  }


  /* not found  or found but not active */

  if (Long_PBhandle EQ NULL)
  {
     rc = ESA_KEY_NOT_FOUND;
     goto exit;
  }

  /* search now in the long block               */
  Long_PBhandle->PBptr->skip_extYN = 'Y';
  rc = Permissions_block_Get("UIDTHIS",
                             Long_PBhandle,
                             role,
                             NULL,
                             0,
                             comp,
                             admin_params);
  Long_PBhandle->PBptr->skip_extYN = 'N';

  ESA_DIAG_printf(comp, 6,
                  "Permissions_block_Get in long rc = %d \n",
                  rc);

  if (rc EQ ESA_FATAL)
     goto exit;

  if (rc EQ ESA_OK)
  {
     /* check if it is active  */
     if(params_ptr->XREF_SYSID_SCOPE[0] NE 'a')
     {
       pUID = Long_PBhandle->curUIDinPB;
       goto chain;
     }

     psysid = Long_PBhandle->curUIDinPB->P_SYSID;
     ESA_DIAG_printf(comp, 2,
                  "First SYSID = %p \n", psysid);

     while (psysid NE NULL)
     {
        ESA_DIAG_printf(comp, 6,
                  "SYSID = %p/%s  Active = %c \n",
                  psysid, psysid->SYSID, psysid->ActiveYN);

       if (psysid->ActiveYN EQ 'Y')
       {
          ESA_DIAG_printf(comp, 6,
                  "Found active in long block \n");
          pUID = Long_PBhandle->curUIDinPB;
          goto chain;
       }
       psysid = psysid->next_sysid;
     }
  }

  rc = ESA_KEY_NOT_FOUND;
  goto exit;

  chain:

  newPerm = (PERM_BLK_PERM_rec_typ *)
                 malloc( sizeof(PERM_BLK_PERM_rec_typ) +
                 strlen(perm_data) );

  if(newPerm EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "PB Permission element",
       (sizeof(PERM_BLK_PERM_rec_typ)+strlen(perm_data)) );
    rc = ESA_FATAL;
    goto exit;
  }
  newPerm->next_perm = NULL;
  newPerm->eyec      = ACF2_PERM_PBENT_EYEC;
  strcpy(newPerm->perm,perm_data);

  /*
  if (want_diag)
    ESA_DIAG_printf(comp, 0 ,
        "New perm:  %p = %s", newPerm, perm_data);
    */

    ESA_DIAG_printf(comp, 6 ,
        "New perm:  %p = %s", newPerm, perm_data);

  /* If there is already permission in UID structure *
   * then link it to next_perm                       */
  if(pUID->first_perm NE NULL)
  {
     newPerm->next_perm = pUID->first_perm;
  }
  pUID->first_perm = newPerm;
  ESA_DIAG_printf(comp , 6,
             "Permission (%p) added to UID",newPerm);
  /*
  if (want_diag)
  {
   ESA_DIAG_printf(comp , 0,
             "Permission (%p) added to UID at %p",newPerm,pUID);
   SNAP_AREA("pUID",
              pUID,
              sizeof(PERM_BLK_UID_rec_typ))
         if (pUID->first_perm NE NULL)
          SNAP_AREA("pUID->first_perm",
                pUID->first_perm,
                strlen(pUID->first_perm->perm))
  }
    */

  rc = ESA_OK;

  exit:

  ESA_DIAG_exit(comp, 1, func, rc);
  return rc;
}
/* WS10084 End   */
/* WS10076 - start */
/**** WS10078A various changes including routine name ****************
 /********************************************************************
 * Procedure Name: ACF2_Cmd2Mem (ACF2_Get_Rules old name)
 *********************************************************************
 * Description   : Activate a REXX script to get access and/or
 *                 resource rules from ACF2.
 *
 *
 * Input         : rectype :  RULE or X(ROL) or X(SGP)
 *                 recparm :  for RULE:  resname/restype
 *                                       resname is empty for ALL
 *                            for X(ROL) rolename or -
 *                            for X(SGP) sourcename or -
 *                 ignlist :  list of ACF2 LIST command output lines
 *                            to ignore.
 *                 comp    :  Diag. component.
 *
 * Output        : p_ruob  :  pointer to the RUOB containing the
 *                            LIST command output.
 *
 *
 * Return Value  : ESA_OK - The block was built successfully.
 *                 ESA_FATAL - Build failed.
 *
 *
 ********************************************************************/
/* WS10078A static ESA_RC ACF2_Get_Rules( */
/* WS10078KG static ESA_RC ACF2_Cmd2Mem( */
/* WS10079N .ESA_RC ACF2_Cmd2Mem(                     /@ WS10078KG@/*/
ACF2_API_Return_Codes ACF2_Cmd2Mem(                  /* WS10079N */
 /*WS10078A*           char                            * restype,
                       char                            * resname, */
 /*WS10078A*/          char                            * rectype,
 /*WS10078A*/          char                            * recparm,
                       REXX@UTL_output_ignlist_rec_typ * ignlist,
 /* BS10111            REXX@UTL_output_blk_rec_typ    ** p_ruob, */
 /* BS10111 */         char                            * p_ruob,
                       ESA_DIAG_COMP_typ                 comp,
                       ADMIN_PARAMS_rec_typ            * admin_params)
{
  /* BS01111 - replace with number of segments (1MB)
  #define    RULES_RUOB_LONG    50*1024*1024
  #define    RULES_RUOB_SHORT   10*1024
  #define    ROLES_RUOB_LONG    5*1024*1024           /@WS10078A@/
     end of replaced definitions - BS10111   */
  #define    RULES_RUOB_LONG    1000       /* 1G */       /* BS10111 */
  #define    RULES_RUOB_SHORT   10         /* 10M */      /* BS10111 */
  #define    ROLES_RUOB_LONG    50         /* 50M */      /* BS10111 */
  #define    ROLES_RUOB_SHORT   1          /*  1M */      /* BS10111 */

  #define    DBGMSG_LEVEL       6  /* debug level for...    WS10079N */
                                   /* printing rexx output. WS10079N */
/*WS10078A static char    func[] = "ACF2_Get_Rules"; */
  static char    func[] = "ACF2_Cmd2Mem";         /*WS10078A*/
  ESA_RC         rc = ESA_OK;
  ACF2_API_Return_Codes  ret_rc = ACF2_OK;                /* WS10079N */

  OS_GRO_typ     gro_parm;
  char           gro_parm_c[10];        /* for rexx parm token */
  int            sum_symb = 0;          /* for rexx parm token */
  int            l = 0;                 /* for OS_MVS_checksum */
  char           cmd[100] = "";
  char           rexx_debug;            /* Y / N */
  ESA_RC         exec_rc = ESA_OK;
  int            tso_rc = 0;
  char           ddn[9] = "";
  char         * rexx_msgbuf = NULL;
  ESA_RC         get_output_rc = ESA_OK;
  short          rexx_output_len = 32767;
  int            ol_len;             /* output line length */
  int            ol_off;             /* offset in output buffer */
  char           dbg_cmds = 'N';     /* Y / N                  */
  char           prt_out = 'Y';      /* Y / N            WS10079N */
  char           errmsg[200];
  char         * tok;                /* WS10078A */
  int            dbglvl = 0;                              /* WS10079N */

  static char    cmds_s[] = "*** *** start of ACF2 commands *** ***";
  static char    cmds_e[] = "*** *** end of ACF2 commands *** ***";

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  /*
   *   Initializtion
   */
  ESA_DIAG_enter(comp, 1, func );


  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /*
   *  Prepare the parameters for the REXX
   */

  /*  Prepare the parameters for CTSCGRO */
  strcpy(gro_parm.eyecatcher, GRO_EYECATCHER);
  /*WS10078A we have different paramaters now
  if ( strlen(resname) EQ 0)
    gro_parm.RUOB_size = RULES_RUOB_LONG;
  else
    gro_parm.RUOB_size = RULES_RUOB_SHORT; ***/

  /* WS10078A start */
  if(strcmp(rectype,"RULE") EQ 0)
  {
   /* WS10078Ntok = strtok(recparm,"/"); /  recparm = resname/restype */
   tok = strchr(recparm,'/'); /* recparm = resname/restype   WS10078N */
   if(tok NE NULL)                  /* tok -> / */
   {
    /* WS10078N  ( strlen(tok) EQ 0)  */
    if ( (tok-recparm) EQ 0)   /* no resname - long */    /* WS10078N */
      gro_parm.RUOB_size = RULES_RUOB_LONG;
    else                       /* specific resname - short */
      gro_parm.RUOB_size = RULES_RUOB_SHORT;
   }
   else /* no '/' in recparm between resname & restype ==> error */
   {
    sprintf(errmsg, "recparm=<%s> does not have / as a separator",
            recparm);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                  component, func, errmsg, 16,__LINE__);
    /* WS10079N rc = ESA_FATAL;   */
    ret_rc = ACF2_Internal_Error;                         /* WS10079N */
    goto exit ;
   }
  } /*end of RULE */
  /*handle X(ROL) or X(SGP) */
  else if(strcmp(recparm,"-") EQ 0)
            gro_parm.RUOB_size = ROLES_RUOB_LONG;
       /* BS10111 else gro_parm.RUOB_size = RULES_RUOB_SHORT;  */
       else gro_parm.RUOB_size = ROLES_RUOB_SHORT;        /* BS10111 */
  ESA_DIAG_printf(comp, 6,
                  "gro_parm.RUOB_size=<%d>",
                  gro_parm.RUOB_size);
  /** WS10078A end ***********/

  gro_parm.RUOBptr = p_ruob;
  gro_parm.ignore_list = ignlist;
  gro_parm.comp = comp;
  gro_parm.debug_level = ESA_DIAG_get_debug_level(comp);
  gro_parm.admin_params = admin_params;                    /* BS10111 */

  /*  Create the token for CTSCGRO parameters block address
   *  to be passed to the REXX program.                       */
  sprintf(gro_parm_c,"%08x",&gro_parm);  /* Convert address to char */

  ESA_DIAG_printf(comp, 2,
                  "gro_parm=%p gro_parm_c=%s",
                  &gro_parm, gro_parm_c);

  /*  Calculate control symbol  */
  rc = OS_MVS_checksum(gro_parm_c, &sum_symb);
  if ( rc NE ESA_OK )
  {
    sprintf(errmsg, "OS_MVS_checksum returned rc = %d.  parm = %s",
            rc, gro_parm_c);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                  component, func, errmsg,
                  16,__LINE__);
    /* WS10079N rc = ESA_FATAL;  */
    ret_rc = ACF2_Internal_Error;                         /* WS10079N */
    goto exit ;
  }

  /*  Put contol symbol in token   */
  l = strlen(gro_parm_c);
  gro_parm_c[l] = sum_symb;
  gro_parm_c[l+1] = NULL_CHAR ;

  ESA_DIAG_printf(comp, 6,
                  "gro_parm = %x   gro_parm_c = %s",
                  &gro_parm, gro_parm_c);

  /*
   *  Create the TSO command to execute the REXX
   */
  strcpy(ddn, EXECOUT_DDNAME);
  rexx_debug = gro_parm.debug_level GE 20 ? 'Y' : 'N';
  /* WS10078A start --- call CTSBC2M with 2 different parms ***
  sprintf(cmd, "%%CTSBRLST %s/%s %s %s %c ",
          (resname EQ NULL?  "" : resname),
          (restype EQ NULL?  "" : restype),
          gro_parm_c, ddn, rexx_debug);     **********/

  sprintf(cmd, "%%CTSBC2M %s %s %s  %s %c ",
          (rectype EQ NULL?  "" : rectype),
          (recparm EQ NULL?  "" : recparm),
          gro_parm_c, ddn, rexx_debug);
  /********* WS10078A end ****************/

  ESA_DIAG_printf(comp, 6,
                  "TSO command: %s", cmd);

  /*
   *   Execute the TSO command
   */
  exec_rc = ESA_CLI_exec_wait(ddn, cmd, &tso_rc, admin_params);
  /* WS10079N ESA_DIAG_printf(PLT_COMP_API_ACF2, 6,  */
  ESA_DIAG_printf(comp, 6,                                /* WS10079N */
                  "Execute command: rc = %d  ddn = %s   tso_rc = %d",
                   exec_rc, ddn, tso_rc);

  /* WS10079N if (exec_rc NE ESA_OK  OR  tso_rc NE 0)
    rc = ESA_FATAL;   */
  if (exec_rc NE ESA_OK) /* The rexx was not "submitted"     WS10079N */
  {                                                       /* WS10079N */
    sprintf(errmsg,                                       /* WS10079N */
            "ESA_CLI_exec_wait failed with rc = %d",      /* WS10079N */
            exec_rc);                                     /* WS10079N */
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,        /* WS10079N */
                  component,func,                         /* WS10079N */
                  errmsg, 16, __LINE__);                  /* WS10079N */
    ret_rc = ACF2_Internal_Error;                         /* WS10079N */
    goto exit;                                            /* WS10079N */
  }                                                       /* WS10079N */
  else                                                    /* WS10079N */
  {                                                       /* WS10079N */
    switch (tso_rc)                                       /* WS10079N */
    {                                                     /* WS10079N */
      case 0:                   /* OK  */                 /* WS10079N */
        ret_rc = ACF2_OK;                                 /* WS10079N */
        prt_out = 'Y';          /* print messgaes so that    WS10079N */
                                /* we do not "hide" error.   WS10079N */
        break;                                            /* WS10079N */
      case 4:                   /* not found */           /* WS10079N */
        ret_rc = ACF2_Not_Found;                          /* WS10079N */
        prt_out = 'N';        /* No need to print the msgs.  WS10079N */
        break;                                            /* WS10079N */
      default:                  /* Error  */              /* WS10079N */
        ret_rc = ACF2_Internal_Error;                     /* WS10079N */
        prt_out = 'Y';          /* print the msgs.  */    /* WS10079N */
        break;                                            /* WS10079N */
    }                                                     /* WS10079N */
  }                                                       /* WS10079N */

  /* Get command messages (EXECOUT) */
  rexx_msgbuf = (void *) malloc(rexx_output_len);
  if (rexx_msgbuf EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "REXX message buffer", rexx_output_len);
    /* WS10079N rc = ESA_FATAL;  */
    ret_rc = ACF2_Internal_Error;                         /* WS10079N */
    goto exit;
  };

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,
                  "REXX message buffer = %p", rexx_msgbuf);

  get_output_rc = ESA_CLI_get_output(ddn,
                                 rexx_msgbuf,
                                 &rexx_output_len,
                                 admin_params);

  ESA_DIAG_printf(comp, 6,
                  "Get REXX output rc=%d  ddn=%s",
                  get_output_rc, ddn);

  ESA_DIAG_printf(comp, 6,
                  "output_buffer=%.100s, output_len=%d",
                  rexx_msgbuf, rexx_output_len);

  /*
   *  Issue command messages written to EXECOUT, to STDMSG
   */
  /* WS10079N
  if (exec_rc  EQ  ESA_OK   AND   /@ If cmd was issued successfully @/
      tso_rc   EQ  0        AND   /@ and was executed succesafully  @/*/
  if ( (prt_out EQ 'N') AND      /* If no need to print msgs WS10079N */
      rexx_debug EQ 'Y')         /* but debug was requested          /*/
      dbg_cmds = 'Y';         /* print acf2 cmds to prtdng   WS10079N */

  if (get_output_rc EQ ESA_OK)
  {
    dbglvl = ESA_DIAG_get_debug_level(comp);              /* WS10079N */
    /* WS10079N - do the loop only when we need to print the messages
                  and/or commands or write them to diag.
    for (ol_off = 0; ol_off LT rexx_output_len; ol_off += ol_len )    */
    for (ol_off = 0;                                      /* WS10079N */
         ( (ol_off LT rexx_output_len) AND                /* WS10079N */
           ( (dbg_cmds EQ 'Y') OR                         /* WS10079N */
             (prt_out EQ 'Y') OR                          /* WS10079N */
             (DBGMSG_LEVEL LE dbglvl) )    );             /* WS10079N */
         ol_off += ol_len )                               /* WS10079N */
    {
      ol_len = strlen(&rexx_msgbuf[ol_off])+1;

      /* suppress newline markers */
      if ( (ol_len GT 2) AND
           (rexx_msgbuf[ol_off+ol_len-2] EQ '\n'))
         rexx_msgbuf[ol_off+ol_len-2] = NULL_CHAR;

      /* WS10079N ESA_DIAG_printf(comp, 20,  */
      ESA_DIAG_printf(comp, DBGMSG_LEVEL,                 /* WS10079N */
            "msg =(%s) , ol_off=(%d), ol_len=(%d)",
            &rexx_msgbuf[ol_off],ol_off,ol_len);

      /*   dbg_cmds = Y, the output should start with the commands */
      /*   issued for ACF2 - write them to PRTDBG                  */
      if (dbg_cmds EQ 'Y')
      {
        if (ol_off EQ 0)
        {
          /* Identify the start commands line */
          if ( strlen(&rexx_msgbuf[ol_off]) GE strlen(cmds_s)  AND
               strstr(&rexx_msgbuf[ol_off], cmds_s) NE NULL )
            dbg_cmds = 'Y';
          else
          {
            dbg_cmds = 'N';
            if (prt_out EQ 'Y')                           /* WS10079N */
              CTSAMSG_print(ACF2_OUTPUT_LINE, msgs, NULL, dest,
                            &rexx_msgbuf[ol_off] );
          }
        };

        if (dbg_cmds EQ 'Y')
        {
          ESA_DIAG_printf(comp, 0,
                "%s", &rexx_msgbuf[ol_off]);

          /* Identify the end commands line */
          if ( ol_off NE 0  AND
               strlen(&rexx_msgbuf[ol_off]) GE strlen(cmds_e)  AND
               strstr(&rexx_msgbuf[ol_off], cmds_e) NE NULL )
            dbg_cmds = 'N';
        }
      }
      else
        if (prt_out EQ 'Y')                              /* WS10079N */
          CTSAMSG_print(ACF2_OUTPUT_LINE,   msgs, NULL, dest,
                        &rexx_msgbuf[ol_off] );
    } /* for */
  }
  else
  {
    /* Error processing the command messages  */
    CTSAMSG_print(ACF2_OUTPUT_ERR,   msgs, NULL, dest);
    /* WS10079N rc = ESA_FATAL;   */
    ret_rc = ACF2_Internal_Error;                         /* WS10079N */
    goto exit;
  }

  /*
   *  Remove output file and area
   *  We do not check the return code of ESA_CLI_delete_output
   *  because it will not affect our process. We do not have
   *  to issue any error messgaes because they were already
   *  issued by the routine.
   */
  free(rexx_msgbuf);
  rexx_msgbuf = NULL;
  get_output_rc = ESA_CLI_delete_output(ddn, admin_params);

  /* WS10079N - the code below is removed because these return codes
                are handled earlier.
  /@
   *  Verify that the commands were issued and processed successfully.
   *
   *  If the REXX or ACF2 commands failed, nothing to do because
   *  we already have all messages written to STDMSG.
   @/
  if (rc  NE ESA_OK)
  {
    if (exec_rc  NE  ESA_OK)   /@ REXX was not "submitted" @/
    {
      sprintf(errmsg, "ESA_CLI_exec_wait failed with rc = %d",
              exec_rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                    errmsg, 16, __LINE__);
    }

    rc = ESA_FATAL;
  }
     end of removed code - WS10079N */

 exit:
  /* WS10079N ESA_DIAG_exit(comp, 1, func, rc);  */
  /* WS10079N return rc;                            */
  ESA_DIAG_exit(comp, 1, func, ret_rc);                   /* WS10079N */
  return ret_rc;                                          /* WS10079N */
}
 /*  WS10076N - end   */

/* WS10076K - start */
/*********************************************************************
 * Procedure Name: Permissions_block_Insert
 *********************************************************************
 * Description   : The procedure inserts UID and/or Permission for
 *                 UID to permission block.
 *                 When called for XREF may be called to add a SYSID
 *                 UID to permission block.                   WS10079A
 * Input         : PBheader - Permission block header
 *                 UID - UID to be inserted
 *                 permission_data - Permissions to be inserted.
 *                 comp - diagnostic component
 *                 admin_params - Admin parameters.
 *
 * Output        : The permissions block is updated with the UID or
 *                 permission to add.
 *
 *
 * Return Value  : ESA_OK - If UID/Permission is added
 *                 ESA_SKIP  - UID exists. Permission was processed.
 *                 ESA_FATAL - If there is an error while inserting
 *                 data in chain.
 *
 * Type returned from Permission_block_Look4uid:
 *  (U(id) / P(rev) / L(ast) / N(ot found) / E(rror))
 *
 ********************************************************************/
ESA_RC Permissions_block_Insert(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 char                     * UID,
                 char                     * permission_data,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "Permissions_block_Insert";
  ESA_RC                      rc = ESA_OK;
  char                        prev = 'Y';
  PERM_BLK_UID_rec_typ      * UIDentry = NULL;
  PERM_BLK_UID_rec_typ      * UIDEleAddr = NULL;
  PERM_BLK_UID_rec_typ      * newUID = NULL;
  PERM_BLK_PERM_rec_typ     * newPerm = NULL;
  char                        type;
  char                        errmsg[80];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  rc = Permission_block_Look4uid(UID,PBheader,prev,&type,
                                 &UIDEleAddr,comp, admin_params);

  ESA_DIAG_printf(comp, 6,
                  " %s returned UIDEleAddr(%p),type(%c),rc(%d)",
                  "Permission_block_Look4uid", UIDEleAddr, type, rc);

  if( (rc EQ ESA_FATAL) OR (rc EQ ESA_KEY_NOT_FOUND) )
  {
    rc = ESA_FATAL;
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                  "Permission_block_Look4uid failed to locate uid",
                  rc, __LINE__);
    goto exit;
  }
  else
  {
    if( (type EQ 'P') OR (type EQ 'L') OR (type EQ 'U'))
    {
      /* If UID is found then we want to add permission *
       * to the UID                                     */
      if((type EQ 'U'))
      {
        if(permission_data EQ NULL)
        {
          ESA_DIAG_printf(comp, 6,
              "No permission received for UID - %s",UID);
        }
        newUID = UIDEleAddr;
      }
      else
      { /* type is 'P' or 'L' - allocate new uid*/
        /* WS10079N newUID = (PERM_BLK_UID_rec_typ*)
                     malloc(sizeof(PERM_BLK_UID_rec_typ)); */
        newUID = (PERM_BLK_UID_rec_typ*)                  /* WS10079N */
                   calloc(1,sizeof(PERM_BLK_UID_rec_typ));/* WS10079N */
        if(newUID EQ NULL)
        {
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "PB UID element", sizeof(PERM_BLK_UID_rec_typ));
          rc = ESA_FATAL;
          goto exit;
        }
        newUID->next_uid = NULL;
        newUID->eyec = PBheader->table_type;             /*WS10079A*/
        /*WS10079A newUID->eyec = ACF2_UID_PBENT_EYEC; */
        newUID->first_perm = NULL;
        strcpy(newUID->uid, UID);
        ESA_DIAG_printf(comp, 17,
              "New UID:  %p = %s", newUID, UID);
      }

      if( (permission_data NE NULL)  AND
          (permission_data[0] NE NULL_CHAR) )
      {
        /* If permission is received along with UID then add *
         * the permission as well in UID structure.          *
         * The Permission block permission structure has     *
         * permission placeholder defined as perm[1]. While  *
         * allocating memory for permissions block, memory   *
         * for permiossion data is also allocated so that    *
         * the memory is allocated continuously. Since it is *
         * continuous allocation we have an extra byte from  *
         * permission block structure.Hence there is no need *
         * to allocate one extra byte to hold end character  */
        newPerm = (PERM_BLK_PERM_rec_typ *)
                       malloc( sizeof(PERM_BLK_PERM_rec_typ) +
                       strlen(permission_data) );

        if(newPerm EQ NULL)
        {
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                        "PB Permission element",
             (sizeof(PERM_BLK_PERM_rec_typ)+strlen(permission_data)) );
          rc = ESA_FATAL;
          goto exit;
        }
        newPerm->next_perm = NULL;
        newPerm->eyec      = ACF2_PERM_PBENT_EYEC;
        strcpy(newPerm->perm,permission_data);
          ESA_DIAG_printf(comp, 17,
              "New perm:  %p = %s", newPerm, permission_data);

        /* If there is already permission in UID structure *
         * then link it to next_perm                       */
        if(newUID->first_perm NE NULL)
        {
           newPerm->next_perm = newUID->first_perm;
        }
        newUID->first_perm = newPerm;
        ESA_DIAG_printf(comp , 6,
                   "Permission (%p) added to newUID",newPerm);

      }/* END permission_data NE NULL */
      else
      {
        ESA_DIAG_printf(comp , 6,
                   "No permission to be added to newUID");
      }

      /* If type is 'P' and the newUID to be inserted is the  *
       * first in the list then we update the first and last  *
       * entries in the index accordingly.                    */
      if(type EQ 'P')
      {
        if(UIDEleAddr EQ NULL)
        {
          /* If it is the first element */
          if(PBheader->index[0].UIDentry EQ NULL)
          {
            /* Set number of indexes used to 2 when first UID is *
             * inserted in the permission block header           */
            PBheader->num_used_ix_ent = 2;
            /* Point starting index and last index to new UID */
            PBheader->index[0].UIDentry = newUID;
            PBheader->index[0].entry_number = 1;
            strcpy(PBheader->index[0].uid, newUID->uid);

            memcpy(&(PBheader->index[1]), &(PBheader->index[0]),
                   sizeof(PB_INDEX_rec_typ) );
            PBheader->index[1].entry_number = 2;
          }
          else
          {
            /* Chain the current first to newUID element   *
             * and put the newUID element as first.        */
            newUID->next_uid = PBheader->index[0].UIDentry;
            PBheader->index[0].UIDentry = newUID;
            strcpy(PBheader->index[0].uid, newUID->uid);
          }

          ESA_DIAG_printf(comp , 6,
                          "UID %s inserted as first UID before UID %s",
                          newUID->uid,
                          (newUID->next_uid NE NULL?
                                       newUID->next_uid->uid : "") );
        }
        else
        {
          /* UIDEleAddr is not NULL and is pointing to UID *
           * after which newUID has to be inserted         */
          newUID->next_uid = UIDEleAddr->next_uid;
          UIDEleAddr->next_uid = newUID;

          ESA_DIAG_printf(comp , 6,
                          "UID %s inserted between %s and %s to list",
                          newUID->uid,UIDEleAddr->uid,
                          (newUID->next_uid)->uid);
        }
      }/* End type EQ 'P' */
      else
      {
        if(type EQ 'L')
        {
          if(UIDEleAddr EQ NULL)
          {
            rc = ESA_FATAL;
            sprintf(errmsg,
                "No UIDEleAddr received for UID - %s, type - L",UID);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                func, errmsg, rc, __LINE__);
            goto exit;
          }
          else
          {
            /*newUID -> next_uid is already set to NULL */
            UIDEleAddr->next_uid = newUID;
            /* Point last index to new UID */
            PBheader->index[(PBheader->num_used_ix_ent) - 1]
                 .UIDentry = newUID;
            strcpy(PBheader->index[(PBheader->num_used_ix_ent) - 1].uid,
                   newUID->uid);
          }
          ESA_DIAG_printf(comp , 6,
                          "UID %s inserted as last after UID %s",
                          newUID->uid, UIDEleAddr->uid);
        } /* END type EQ 'L'*/
        else   /* Type U - UID exists */
          rc = ESA_SKIP;              /* return SKIP            */
      }

      /* Increment number of UID's in list if type is not U*/
      if((type NE 'U'))
        PBheader->num_uids++;

      /************************   WS10079A starts   *******************/
      /* call XREF_Block_InsertSYSID routine if UID entry is valid
         and if external routine exists.                             */
      if((newUID->eyec EQ PBheader->table_type) AND
         (PBheader->ext_block_routines NE NULL) AND
         (PBheader->skip_extYN NE 'Y')          AND           /* WS10084 */
         (PBheader->ext_block_routines->insert NE NULL)) {
        rc = (*PBheader->ext_block_routines->insert)(
                   newUID,
                   (void *)PBheader,
                   comp,
                   admin_params);
        if(rc NE ESA_OK) {
          rc = ESA_FATAL;
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                        "Failed to insert SYSID", rc, __LINE__);
          goto exit;
        }
        ESA_DIAG_printf(comp, 6,
             "Extension routine of %s returned rc(%d)", func,rc);
      }
      /************************   WS10079A ends   *********************/

    } /* END - (type EQ 'P') OR (type EQ 'L') OR (type EQ 'U')*/
    else
    {
      rc = ESA_FATAL;
      sprintf(errmsg,
              "Permission_block_Look4uid returned invalid type %c",
              type);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, errmsg, rc, __LINE__);
      goto exit;
    }
  }

  exit:
  if(rc EQ ESA_FATAL)
  {
    if( (newUID NE NULL) AND (type NE 'U') )
      free(newUID);
    if(newPerm NE NULL)
      free(newPerm);
  }

  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/**************** Permissions_block_Insert end ************WS10079A**/
/*********************************************************************
 * Procedure Name: Permissions_block_Get
 *********************************************************************
 * Description   :  The procedure is used to Get a UID and/or a
 *                  permission for a UID or a SYSID from the
 *                  permissions block.
 *
 *                  The procedure returns two pointers in permission
 *                  block handle along with return code.
 *                  - Permissions Block Handle
 *                  - p_curUIDinPB - Return UID to be returned in
 *                    permissions block. NULL if none was returned.
 *                  - p_curPERMinPB - Return fisrt permission of
 *                    the UID returned. NULL if UID was returned
 *                    without its permissions or no UID is returned.
 *                    For function PERMNEXT is used then the
 *                    permissions read are maintained in p_curPERMinPB.
 *
 * Input         :  - function
 *                     1. UIDNEXT - Get next UID, and its 1st
 *                     permission, if permission_data_area is provided.
 *                     2. PERMNEXT - Get next permission of current
 *                     UID (regardless of UID provided, if at all).
 *                     3. UIDTHIS - Get specific UID, and its 1st
 *                     permission, if permission_data_area is provided
 *                     4. SYSIDNXT- Get next SYSID.
 *                  - Permissions Block Handle
 *                  - UID (input/output)
 *                  - permission_data_area (output)
 *                  - permission_data_area_length (input)
 *                  - diag comp
 *                  - admin_params
 *
 * Output        :  If UIDTHIS or UIDNEXT - Return UID along with first
 *                  permission if permission_data_area is provided.
 *                  If PERMNEXT - Return next permission of UID
 *
 *
 * Return Value  :
 *                  Following return codes are returned for given
 *                  scenario -
 *                    1. ESA_OK - If there are no errors and all
 *                    requested values are returned. When UIDNEXT
 *                    or UIDFIRST were requested and permdata was
 *                    passed this means that the UID was found.
 *                    The caller needs to check the permission data
 *                    area for the permission, if it is empty it
 *                    means the permission was not found.
 *                    2. ESA_KEY_NOT_FOUND - For UIDTHIS, the UID
 *                    was not found.
 *                    3. ESA_EOF - no more UIDs (for UIDNEXT) or
 *                    permissions for the UID (for PERMNEXT)
 *                    4. ESA_ERR - permission is too long.
 *                    5. ESA_FATAL - any other error.
 ********************************************************************/
 /* WS10084
    We need to add a new function: UIDTHISN. It will start searching
    for the UID (or ROLE in the UID parameter) after a given previous
    last UID.
    We need this function for more efficient search when we need to
    find the groups that a LID belongs to in the GROUPS PB and get the
    AccountIndirectPermissions from them.
    We will sort the the groups that we take from the groups ADDINFO
    attribute (if needed) so that searcing for the next group doesn't
    have to start from the begining.

    We also need this new function to search in the USERS PB for the
    AccountRoleDirectPermission.

    We also need this new function to search for the user's roles to get
    the AccountRoleIndirectPermissions from the ROLES PB.
    We do not need to provide the last UID we want to search after
    becuase it is in curUIDinPB.
    If curUIDinPB is NULL it is the same as UIDTHIS.
    WS10084 */
ESA_RC Permissions_block_Get(
                     char                     * function,
                     PBhandle_typ             * PBhandle,
                     char                     * UID,
                     char                     * permission_data,
                     int                        permission_buffer_len,
                     ESA_DIAG_COMP_typ          comp,
                     ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                  func[] = "Permissions_block_Get";
  ESA_RC                       rc = ESA_OK;
  PERM_BLK_UID_rec_typ       * UIDEleAddr;
  char                         type;
  char                         errmsg[80];
  int                          i;                          /* WS10084 */
  int                          j;                          /* WS10084 */
  int                          int_rc;                     /* WS10084 */
  int                          foundi  = FALSE;            /* WS10084 */
  int                          foundj  = FALSE;            /* WS10084 */
  int                          in_last = FALSE;            /* WS10084 */
  PERM_BLK_UID_rec_typ       * puid = NULL;                /* WS10084 */
  PERM_BLK_UID_rec_typ       * luid = NULL;                /* WS10084 */

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if( (PBhandle EQ NULL) OR (PBhandle->PBptr EQ NULL) )
  {
    /* cdump("PBhandle is NULL");                     /* WS10084 */
    ctrace("PBhandle is NULL");                       /* WS10084 */
    rc = ESA_FATAL;
    /*WS10079A PBhandle->PBErr = TRUE; PBhandle may be NULL */
    sprintf(errmsg, "%s can not be NULL",
           ((PBhandle EQ NULL) ? "PBhandle" : "PBptr") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg , rc, __LINE__);
    goto exit;
  }

  if( (PBhandle->PBErr EQ TRUE) OR (PBhandle->PBbldErr EQ TRUE) )
  {
    rc=ESA_EOF;
    sprintf(errmsg, "Error set in PBhandle PBErr(%d) PBbldErr(%d)",
            PBhandle->PBErr, PBhandle->PBbldErr);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg , rc, __LINE__);
    goto exit;
  }

  if (PBhandle->PBnf EQ TRUE)                             /* WS10079N */
  {                                                       /* WS10079N */
    rc=ESA_EOF;                                           /* WS10079N */
    goto exit;                                            /* WS10079N */
  }                                                       /* WS10079N */

  /* If function starts with UID then we want to retun the UID
   * found for UIDTHIS and UIDNEXT.
   * If permissions_data buffer is not NULL then return
   * first permission of the UID if exists.
   */
  if( strncmp(function,"UID",3) EQ 0 )
  {
    /* For UIDNEXT and UIDTHIS functions UID can not be null */
    if(UID EQ NULL)
    {
      rc = ESA_FATAL;
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                    func, "Null UID received" , rc, __LINE__);
      goto exit;
    }

    /* WS10084 start */
    if(
        ( strcmp(function,"UIDTHISN") EQ 0 )
        AND
        (PBhandle->curUIDinPB NE NULL)
      )
    {
      PBhandle->curPERMinPB = NULL;
      /* locate curUIDinPB in the index */

      if (strcmp(PBhandle->curUIDinPB->uid,
                   PBhandle->PBptr->index[0].uid) LT 0)
      {
        sprintf(errmsg,
           "UIDTHISN curUIDinPB = %s LT first index",
            PBhandle->curUIDinPB->uid);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
           dest, component,func, errmsg , rc, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }

      i = PBhandle->PBptr->num_used_ix_ent - 1;
      if (strcmp(PBhandle->curUIDinPB->uid,
                   PBhandle->PBptr->index[i].uid) GE 0)
      {
         in_last = TRUE;
         puid = PBhandle->curUIDinPB->next_uid;      /* scan start */
         luid = NULL;
      }
      else  /* not in the last index */
      {
        for (i = 1; i LT PBhandle->PBptr->num_used_ix_ent; i++)
          if (strcmp(PBhandle->curUIDinPB->uid,
                     PBhandle->PBptr->index[i].uid) LT 0)
          {
             foundi = TRUE;
             break;
          }

        if (NOT foundi)  /* this is an error */
        {
          sprintf(errmsg,
             "UIDTHISN curUIDinPB = %s not found in index range",
              PBhandle->curUIDinPB->uid);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
             dest, component,func, errmsg , rc, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }

        /* curUIDinPB is in index i -1 */
        /* find in which index is  UIDTHIS  */
        for (j = i; j LT PBhandle->PBptr->num_used_ix_ent; j++)
          if (strcmp(UID, PBhandle->PBptr->index[j].uid) LT 0)
          {
             foundj = TRUE;
             break;
          }

        if (NOT foundj)  /* maybe in last */
        {
           puid = PBhandle->PBptr->
           index[PBhandle->PBptr->num_used_ix_ent -1].UIDentry;  /* start */
           luid = NULL;
        }
        /* UID found in some index j -1
           if i EQ j both are in same index range and we should
           start scanning for the uid after curUIDinPB.
           else we should start scanning at index j-1       */

        if (i EQ j)
        {
           puid = PBhandle->curUIDinPB->next_uid;      /* scan start */
           luid = PBhandle->PBptr->index[i].UIDentry;  /* scan end   */
        }
        else
        {
           puid = PBhandle->PBptr->index[j-1].UIDentry;  /* scan start */
           luid = PBhandle->PBptr->index[j].UIDentry;    /* scan end   */
        }

        if (puid EQ NULL)
        {
          sprintf(errmsg,
             "UIDTHISN start serach is NULL. UID = %s. curUIDinPB = %s",
              UID,PBhandle->curUIDinPB);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
             dest, component,func, errmsg , rc, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }

        ESA_DIAG_printf(comp, 2 ,
               "start search at = |%s|  \n"
               "end   search at = |%s|  \n",
                puid->uid, luid->uid);
      }

      PBhandle->curUIDinPB = NULL;
      rc = ESA_KEY_NOT_FOUND;                              /* BS10131 */
      while (puid NE NULL   AND   puid NE luid)
      {
        int_rc = strcmp(UID, puid->uid);
        ESA_DIAG_printf(comp, 2 ,
                   "Compare - uid / puid->uid |%s|/|%s| rc = %d",
                   UID, puid->uid, int_rc);

        if (int_rc EQ 0)   /*  UID was found  */
        {
          PBhandle->curUIDinPB = puid;
          rc = ESA_OK;
          break;
        }
        else
          if (int_rc LT 0)       /*  UID is lower than next entry */
          {
            rc = ESA_KEY_NOT_FOUND;
            break;
          }

        puid = puid->next_uid;  /* -> next uid element */
      }
    }
    else

    /*if( strcmp(function,"UIDTHIS") EQ 0 )                  */
    if(
        ( strcmp(function,"UIDTHIS") EQ 0 )
        OR
        (
          ( strcmp(function,"UIDTHISN") EQ 0 )
           AND
          (PBhandle->curUIDinPB EQ NULL)
        )
      )

    /* WS10084 end */
    {
      /* Initialise curUIDinPB and curPERMinPB to NULL */
      PBhandle->curUIDinPB = NULL;
      PBhandle->curPERMinPB = NULL;
      rc = Permission_block_Look4uid(UID, PBhandle->PBptr,'N',
                       &type, &UIDEleAddr, comp, admin_params);

      ESA_DIAG_printf(comp, 6,
             "%s returned UIDEleAddr(%p) for UID(%s) ,type(%c),rc(%d)",
             "Permission_block_Look4uid",UIDEleAddr,UID,type,rc);
      if(rc EQ ESA_OK)
      {
        PBhandle->curUIDinPB = UIDEleAddr;
      }
      else
      {
        if( (rc NE ESA_KEY_NOT_FOUND) )
        {
          rc = ESA_FATAL;
          PBhandle->PBErr = TRUE;
          CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,func,
                      "Permission_block_Look4uid failed to locate uid",
                      rc, __LINE__);
        }
      }
    }/* END UIDTHIS */
    else
    {
      if( strcmp(function,"UIDNEXT") EQ 0 )
      {
        /* Initialise curPERMinPB to NULL */
        PBhandle->curPERMinPB = NULL;
        /* WS10084   START
        if (want_diag)
        ESA_DIAG_printf(comp, 0 ,
               "PBhandle->curUIDinPB = %p \n",
               PBhandle->curUIDinPB);
           WS10084   END   */


        /* If current UID in Permission block is NULL, *
         * return with first UID from the list else    *
         * return next UID from the list.              */
        if(PBhandle->curUIDinPB EQ NULL)
        {
          PBhandle->curUIDinPB =
              (PBhandle->PBptr)->index[0].UIDentry;
        }
        else
        {
          /* WS10084   START
          if (want_diag)
          {
            ESA_DIAG_printf(comp, 0 ,
               "(PBhandle->curUIDinPB)->next_uid =  %p \n",
               (PBhandle->curUIDinPB)->next_uid);
            SNAP_AREA("next_uid",
                      (PBhandle->curUIDinPB)->next_uid,
                      sizeof(PERM_BLK_UID_rec_typ))
          }
             WS10084   END   */

          PBhandle->curUIDinPB = (PBhandle->curUIDinPB)->next_uid;
        }
        if( (PBhandle->curUIDinPB) NE NULL )
        {
          strcpy(UID,(PBhandle->curUIDinPB)->uid);
        }
        else
          rc = ESA_EOF;
      }/* END UIDNEXT */
      else
      {
        rc = ESA_FATAL;
        sprintf(errmsg, "Invalid function %s received", function);
        CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                      func,errmsg,rc,__LINE__);
      }
    }
    /* If UIDFIRST or UIDNEXT finished with OK and permission_data *
     * address is not NULL then we want to send first permission.  *
     * If the address is NULL then return with ESA_OK.             */
    if( (rc EQ ESA_OK) )
    {
      if (permission_data NE NULL)
      {
        rc = Permissions_block_GetNextPerm(PBhandle,permission_data,
                                           permission_buffer_len,
                                           comp, admin_params);
        /* If there is no permission to UID, we want to return *
         * OK since the function is for UID. For other cases   *
         * return the rc received from getNextPerm procedure   */
        if(rc EQ ESA_EOF)
          rc = ESA_OK;
      }
    /* WS10079N }  */
      /************************   WS10079A starts   *******************/
      /* call the extension routine if it's a real UID entry
         and if external routine exists.                             */
      if((PBhandle->curUIDinPB->eyec EQ PBhandle->PBptr->table_type) AND
         (PBhandle->PBptr->ext_block_routines NE NULL) AND
         (PBhandle->PBptr->skip_extYN NE 'Y')          AND    /* WS10084 */
         (PBhandle->PBptr->ext_block_routines->get NE NULL)) {
        rc = (*PBhandle->PBptr->ext_block_routines->get)(
                   PBhandle->curUIDinPB,
                   (void *) PBhandle,
                   comp,
                   admin_params);
        ESA_DIAG_printf(comp, 6,
             "Extension routine of %s returned rc(%d)", func,rc);

        /*
        if (want_diag)                                        /* WS10084 @/
         ESA_DIAG_printf(comp, 0,                             /* WS10084 @/
             "Extension routine of %s  rc(%d)", func,rc);     /* WS10084 @/
        */
        /* WS10079N if(rc NE ESA_OK) {  */
        if ( (rc NE ESA_OK) AND (rc NE ESA_KEY_NOT_FOUND) )
        {
          rc = ESA_FATAL;
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                        "Failed to get SYSID", rc, __LINE__);
          goto exit;
        }
      }
    };                                                    /* WS10079N */
      /*WS10079A the following errors are dropped as the relevant RC
        is now the extension routine's RC
      rc = ESA_FATAL;
      sprintf(errmsg, "Invalid function %s received", function);
      CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                    func,errmsg,rc,__LINE__);         ***WS10079A*/
      /************************   WS10079A ends   *********************/
  }/* END FUNCTION STARTS WITH UID */
  else
  {
    if( strcmp(function,"PERMNEXT") EQ 0 )
    {
      if (permission_data NE NULL)
      {
        rc = Permissions_block_GetNextPerm(PBhandle,permission_data,
                                           permission_buffer_len,
                                           comp, admin_params);
      }
      else
      {
        rc = ESA_FATAL;
        CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,func,
         "Permission buffer can not be null for PERMNEXT",rc,__LINE__);
      }
    }
    else
    /* function is "unknown" including SYSIDNXT, so we call the
       extension routine which will check the function itself. */
    {
      /************************   WS10079A starts   *******************/
      /* call the extension routine if it's a real UID entry
         and if external routine exists.                     WS10079A*/
      if((PBhandle->curUIDinPB->eyec EQ
          PBhandle->PBptr->table_type) AND
         (PBhandle->PBptr->ext_block_routines NE NULL) AND
         (PBhandle->PBptr->skip_extYN NE 'Y')          AND    /* WS10084 */
         (PBhandle->PBptr->ext_block_routines->get NE NULL) AND
         (rc NE ESA_EOF) AND
         (rc NE ESA_KEY_NOT_FOUND) AND
         (rc NE ESA_FATAL)) {
        rc = (*PBhandle->PBptr->ext_block_routines->get)(
                   PBhandle->curUIDinPB,
                   (void *) PBhandle,
                   comp,
                   admin_params);
        ESA_DIAG_printf(comp, 6,
             "Extension routine of %s returned rc(%d)", func,rc);
      }
      /*WS10079A the following errors are dropped as the relevant RC
        is now the extension routine's RC
      rc = ESA_FATAL;
      sprintf(errmsg, "Invalid function %s received", function);
      CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,
                    func,errmsg,rc,__LINE__);         ***WS10079A*/
      /************************   WS10079A ends   *********************/
    }
  }
  exit:
    ESA_DIAG_exit(comp, 2, func, rc);
    return rc;
}
/************* Permissions_block_get   ends *************************/
/*********************************************************************
 * Procedure Name: Permissions_block_GetNextPerm
 *********************************************************************
 * Description   :  The procedure is used to get the permission of UID
 *
 *
 * Input         :  PBhandle
 *                  permission_data
 *                  permission_buffer_len
 *                  comp
 *                  admin_params
 *
 * Output        :  If permission_data is passed then return the
 *                  permission.
 *                  If Permission Block handle is pointing to
 *                  a permission then send next permission
 *
 * Return Value  :  ESA_OK    - if the permission is retrieved
 *                  ESA_ERR   - if buffer overflow
 *                  ESA_FATAL - if there is error while getting
 *                              permission
 *
 ********************************************************************/
static ESA_RC Permissions_block_GetNextPerm(
                      PBhandle_typ           * PBhandle,
                      char                   * permission_data,
                      int                      permission_buffer_len,
                      ESA_DIAG_COMP_typ        comp,
                      ADMIN_PARAMS_rec_typ   * admin_params)
{
  static char                 func[] = "Permissions_block_GetNextPerm";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[80];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if (permission_data  EQ NULL)  /* permission is not requested */
  {
    rc = ESA_OK;
    goto exit;
  };

  permission_data[0] = NULL_CHAR;

  if( (PBhandle EQ NULL) OR (PBhandle->PBptr EQ NULL))
  {
    rc = ESA_FATAL;
    /*WS10079A PBhandle->PBErr = TRUE; PBhandle may be NULL */
    sprintf(errmsg, "%s can not be NULL",
           ((PBhandle EQ NULL) ? "PBhandle" : "PBptr") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg , rc, __LINE__);
    goto exit;
  };

  if(PBhandle->curUIDinPB EQ NULL)
  {
    rc = ESA_FATAL;
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, "NULL UID received", rc, __LINE__);
    goto exit;
  }
  else
  {
    /* If we are not pointing to any permission lets start *
     * from first permission itself.                       */
    if(PBhandle->curPERMinPB EQ NULL)
    {
      if ((PBhandle->curUIDinPB)->first_perm EQ NULL)
        rc = ESA_EOF;
      else
      {
        PBhandle->curPERMinPB = (PBhandle->curUIDinPB)->first_perm;
        ESA_DIAG_printf(comp,6,"Reading first permission");
      }
    }
    else
    {
      /* If next permission is NULL we dont want to move to *
       * next permission but instead keep returning EOF.    */
      if( (PBhandle->curPERMinPB)->next_perm EQ NULL)
      {
        rc = ESA_EOF;
        ESA_DIAG_printf(comp,6,"This is last permission");
      }
      else
      {
        PBhandle->curPERMinPB = (PBhandle->curPERMinPB)->next_perm;
        ESA_DIAG_printf(comp,6,"Moving to next permission");
      }
    }
  }

  if (rc NE ESA_EOF)
  {
    if( ((PBhandle->curPERMinPB)->eyec) EQ ACF2_PERM_PBENT_EYEC )
    {
      if(strlen((PBhandle->curPERMinPB)->perm) LT
          permission_buffer_len)
      {
        strcpy(permission_data,(PBhandle->curPERMinPB)->perm);
        ESA_DIAG_printf(comp,6,"Permission_data - %.400s",
                        permission_data);
      }
      else
      {
        rc = ESA_ERR;
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
            func, "Permission too long", rc, __LINE__);
        goto exit;
      }
    }
    else
    {
      rc = ESA_FATAL;
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
          func, "Invalid permission record", rc, __LINE__);
      goto exit;
    }
  }

  exit:
  ESA_DIAG_exit(comp, 2, func, rc);
  return rc;
}

/*********************************************************************
 * Procedure Name: Permissions_Block_updateIndex
 *********************************************************************
 * Description   : The procedure is used to update the indexes whenever
 *                 a permission is added in the chain.
 *                 The indexes are updated for following scenarios,
 *                 1) We have only 2 indexes if the number of UID's
 *                    are less than 100.
 *                 2) When we reach the number 100, we add 11 indexes
 *                    The first index always points to first UID and
 *                    the last index always points to last UID. With
 *                    this logic every index point to 10 UID's.
 *                 3) When there are more than 100 and less than 1000
 *                    UID's in the list when its a last call then UPI
 *                    (UID's Per Index entry) is considered as 10.
 *                    If number of UID's are more than 1000 and its a
 *                    last call then use defined UPI's and rebuild the
 *                    indexes.
 *                 4) If there are more than 1000 UID's in the list
 *                    then divide number of UID's by 100 to get number
 *                    of (UPI's) UID's Per Index entry.
 *
 * Input         : **PBheader - Address of permission block header
 *                  last_call - This flag determines whether the call
 *                              to update the index is final call. This
 *                              means we are done with inserting all
 *                              UID's in list.
 *
 * Output        : **PBheader - If the indexes are rebuilt in new
 *                              header the address is returned in
 *                              the same field.
 *
 * Return Value  : ESA_OK - If the indexes are updated.
 *                 ESA_FATAL - If there is any error.
 *
 ********************************************************************/
ESA_RC Permissions_Block_updateIndex(
                      PERM_BLK_HDR_rec_typ    ** PBheader,
                      int                        last_call,
                      ESA_DIAG_COMP_typ          comp,
                      ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                func[] = "Permissions_Block_updateIndex";
  ESA_RC                     rc = ESA_OK;
  char                       msg[80];
  int                        num_of_uids=0, num_of_index_ent = 0;
  int                        mod_num_of_uids=0, rebuild_index=TRUE;
  int                        uids_per_index = 0, uids_processed = 0;
  int                        index_entries_needed= 0, entry_num = 0;
  PERM_BLK_HDR_rec_typ     * myPBheader = NULL;
  PERM_BLK_UID_rec_typ     * uid_ptr = NULL;
  PB_INDEX_rec_typ         * index_ptr = NULL;

  CTSAMSG_HANDLE_rec_ptr     msgs;
  CTSAMSG_DEST_TABLE_rec_ptr dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(comp, 6,
                  "Input pb = %p -> %p",
                  PBheader,
                  PBheader NE NULL?  *PBheader : NULL);

  /* Lets check all the scenarios when we dont want to       *
   * refresh indexes and return to improve the performance.  *
   * 1. If total number of UID's in permission block header  *
   *    are less than 100                                    *
   * 2. If its not a last call and following is true         *
   *    2.1 If number of UID's is between 100 < UID's < 1000 *
   *    2.2 If number of UID's is not equal to               *
   *    1000, 2000, 3000,...,n000 (we create index only if   *
   *    number of UID's are n000)                            */

  if(*PBheader EQ NULL)
  {
    rc = ESA_FATAL;
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, "Received NULL PBheader", rc, __LINE__);
    goto exit;
  }
  else
  {
    num_of_uids = (*PBheader)->num_uids;
    uid_ptr = (*PBheader)->index[0].UIDentry;
  }

  if(uid_ptr EQ NULL)
  {
    /* There are no UID's to traverse. Lets return without *
     * updating the structure                              */
    if(num_of_uids NE 0)
    {
      /* This is an error. The uid_ptr is not pointing *
       * any UID but there are UID's in list           */
      rc = ESA_FATAL;
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                func, "UIDEntry and number of UID's missmatch",
                rc, __LINE__);
    }
    rebuild_index=FALSE;
    goto exit;
  }
  else
  {
    if(num_of_uids LT 100)
    {
      rebuild_index=FALSE;
      if (ESA_DIAG_get_debug_level(comp) GE 15)
        sprintf(msg, "number of uids are less than 100");
    }
    else
    {
      if ( (last_call EQ FALSE) AND (num_of_uids NE 100) )
      {
        /* If the number of UID's are less than 1000 then *
         * we do nothing and return                       */
        if(num_of_uids LT 1000)
        {
          rebuild_index=FALSE;
          if (ESA_DIAG_get_debug_level(comp) GE 15)
             sprintf(msg, "number of uids are less than 1000");
        }
        else
        {
          /* We want to rebuid indexes after 1000 UID's    *
           * If number of UID's MOD 1000 is 0 which means  *
           * the UID's are in the range of 1000, 2000, 3000*
           * then we rebuild the index else return.        */
          mod_num_of_uids = num_of_uids % 1000;
          if (mod_num_of_uids NE 0)
          {
            rebuild_index=FALSE;
            if (ESA_DIAG_get_debug_level(comp) GE 15)
              sprintf(msg, "number of uids are not in range of n000");
          }
        }
      }
    }
  }

  if(rebuild_index EQ TRUE)
  {
    /* We want to rebuild the indexes by setting UPI (UID's  *
     * Per Index entry) as followes,
     * 1. If number of UID's are 100 then create index with  *
     *    11 entries (10 + 1 entry to point to last UID)     *
     * 2. If last call is TRUE                               *
     *    2.1 Number of UID's are less than 1000 then divide *
     *        number of UID's by 11 to get UPI               *
     *    2.2 Number of UID's are more than 1000 then divide *
     *        number of UID's by the number of index entries *
     *        to get UPI                                     *
     * 3. If last call is FALSE                              *
     *    3.1 Number of UID's are more than 1000 set UPI to  *
     *        100                                            */

    if(num_of_uids EQ 100)
    {
      index_entries_needed = 10;
      uids_per_index = 10;
    }
    else
    {
      if(num_of_uids LT 1000)
      {
        /* Since we are here, last call is true and UIDs *
         * are less than 1000. To get number of UPI's we *
         * divide number of UID's by 10.                 */
        index_entries_needed = 10;
        uids_per_index = num_of_uids / index_entries_needed;
        /* Lets find if there are more uid's to be added   *
         * in the index. for example if there are 999 uids *
         * then UPI should be 100 instead of 99.           */
        mod_num_of_uids = num_of_uids % index_entries_needed;
        if(mod_num_of_uids NE 0)
          uids_per_index++;
      }
      else
      {
        /* Lets check if the last call is true. If last *
         * call is true divide the number of UIDs by no *
         * of index entries used to get uids per index  */
        if(last_call EQ TRUE)
        {
          index_entries_needed = (*PBheader)->num_used_ix_ent - 1;
          uids_per_index = num_of_uids / index_entries_needed;

          mod_num_of_uids = num_of_uids % index_entries_needed;
          if(mod_num_of_uids NE 0)
            uids_per_index++;
        }
        else
        {
          /* Since we are here it means the mod_num_of_uids  *
           * calculated above is 0. Lets add 100 to existing *
           * uids_per_index                                  */
          uids_per_index = 100;
          index_entries_needed = num_of_uids / uids_per_index;

          if( ((*PBheader)->num_ix_ent - 1) LT index_entries_needed )
          {
            index_entries_needed=((*PBheader)->num_ix_ent)
                                       + PBH_INITAL_IX_NUM;
          }
          /* Here we decide how many indexes should be  *
           * created by looking at number of UID's. If  *
           * there are few extra UID's to accomodate    *
           * lets increase number of indexes.           */
          if((num_of_uids % uids_per_index) NE 0)
            index_entries_needed++;
        }
      }
    }
    ESA_DIAG_printf(comp,6,
        "Updating index for uids(%d), indexes(%d), UPI(%d)",
        num_of_uids, index_entries_needed, uids_per_index);

    /* Lets check if the number of indexes to be rebuilt *
     * are sufficient or we have to allocate 100 more    */
    if( ((*PBheader)->num_ix_ent - 1) LT index_entries_needed )
    {
      /* We have one index added in PERM_BLK_HDR_rec_typ *
       * declaration which is the last index to point to *
       * the last UID.                                   */

      myPBheader = (PERM_BLK_HDR_rec_typ *)
                      calloc( 1, sizeof(PERM_BLK_HDR_rec_typ)
                              + ( sizeof(PB_INDEX_rec_typ)
                                  * index_entries_needed) );
      if(myPBheader EQ NULL)
      {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
            "Permissions block header",
            (sizeof(PERM_BLK_HDR_rec_typ) +
                (sizeof(PB_INDEX_rec_typ) * index_entries_needed)) );
        rc = ESA_FATAL;
        goto exit;
      }
      /*WS10079A strcpy(myPBheader->eyecatcher,PBH_EYECATCHER); */
      /*************** WS10079A start ****************/
      strncpy(myPBheader->eyecatcher,PBH_EYECATCHER,
              sizeof(myPBheader->eyecatcher));
      myPBheader->table_type = (*PBheader)->table_type;
      myPBheader->ext_block_header = (*PBheader)->ext_block_header;
      myPBheader->ext_block_routines = (*PBheader)->ext_block_routines;
      myPBheader->skip_extYN = 'N';                        /* WS10084 */
      /*************** WS10079A end   ****************/
      myPBheader->num_uids = (*PBheader)->num_uids;
      myPBheader->num_ix_ent = index_entries_needed + 1;
      memcpy(myPBheader->index,(*PBheader)->index,
                                  sizeof((*PBheader)->index));
    }
    else
    {
      myPBheader = (*PBheader);
    }

    ESA_DIAG_printf(comp, 6,
                  "updating index for pb at %p  (input pb = %p)",
                   myPBheader, *PBheader);

    /* Lets start traversing the list of UID's from start */
    uid_ptr = myPBheader->index[0].UIDentry;

    myPBheader->num_used_ix_ent=0;
    /* WS10076N index_ptr = &(myPBheader->index);  */
    index_ptr = &(myPBheader->index[0]);                  /* WS10076N */
    for(uids_processed=1, entry_num=0;
        uid_ptr NE NULL;
        uids_processed++)
    {
      /* We want to update the index when we process *
       * uids_per_index set. The index will be       *
       * traversed with entry_num                    */

      if((uids_processed EQ 1 ) OR
          (uids_processed % uids_per_index) EQ 0)
      {
        index_ptr[entry_num].UIDentry = uid_ptr;
        strcpy(index_ptr[entry_num].uid,uid_ptr->uid);
        index_ptr[entry_num].entry_number = entry_num+1;
        myPBheader->num_used_ix_ent++;

        ESA_DIAG_printf(comp, 6,
            "entry_num=%d, uid=(%s), uid_entry_ptr=%p",
            index_ptr[entry_num].entry_number,
            index_ptr[entry_num].uid,
            index_ptr[entry_num].UIDentry);
        entry_num++;
      }
      else                                                /* WS10076N */
      {                                                   /* WS10076N */
        if(uid_ptr->next_uid EQ NULL)
        {
          /* This is last uid in the list. entry_num should *
           * point to last available index                  */

          if(entry_num LT myPBheader->num_ix_ent)
          {
            index_ptr[entry_num].UIDentry = uid_ptr;
            strcpy(index_ptr[entry_num].uid,uid_ptr->uid);
            index_ptr[entry_num].entry_number = entry_num+1;
            myPBheader->num_used_ix_ent++;

            ESA_DIAG_printf(comp, 6,
                "Last UID entry_num=%d, uid=(%s), uid_entry_ptr=%p",
                index_ptr[entry_num].entry_number,
                index_ptr[entry_num].uid,
                index_ptr[entry_num].UIDentry);
          }
          else
          {
            ESA_DIAG_printf(comp, 6,
                "%s index_ptr=%p, uid_entry_ptr=%p, uid=(%s)",
                "Failed to update Last entry", index_ptr,
                index_ptr->UIDentry, uid_ptr->uid);

            ESA_DIAG_printf(comp, 6,
                "%s entry_num=%d, index_entries_needed=%d",
                "Failed to update Last entry", entry_num,
                index_entries_needed);

            rc = ESA_FATAL;
            sprintf(msg,"%s (%d), numOfUids (%d), uidPtr (%p)",
                "Failed to update last entry uidsProcessed",
                uids_processed, num_of_uids, uid_ptr);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                component,func, msg, rc, __LINE__);
            goto exit;
          }
        }
      }                                                   /* WS10076N */
      uid_ptr = uid_ptr->next_uid;
    }
    /* Check if we have processed all the uids */
    if(uids_processed-1 EQ num_of_uids)
    {
      /* All is good. If it is last call, clear the rest of *
       * the indexes, if exist. This is needed becasue in   *
       * last call we may use less entries than was used    *
       * before this call.                                  *
       * We traverse one less than used index entries since *
       * the there is additional entry to point to last uid */
      if (last_call)
      {
        num_of_index_ent = myPBheader->num_used_ix_ent + 1;
        while(num_of_index_ent LT (myPBheader->num_ix_ent) )
        {
          index_ptr[num_of_index_ent].entry_number = 0;
          index_ptr[num_of_index_ent].UIDentry = NULL;
          index_ptr[num_of_index_ent].uid[0] = NULL_CHAR;
          num_of_index_ent++;

          ESA_DIAG_printf(comp, 15,
              "Resetting %d th index", num_of_index_ent);
        }
      }
    }
    else
    {
      /* There is something wrong */
      rc = ESA_FATAL;
      sprintf(msg,"uidsProcessed(%d), numOfUids(%d), uidPtr(%p)",
          uids_processed, num_of_uids, uid_ptr);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
          msg, rc, __LINE__);
      goto exit;
    }

  }
  else
  {
    ESA_DIAG_printf(comp,15,
            "%s uids(%d), indexes(%d), UPI(%d) reason: %s",
            "Not rebuilding index for ", num_of_uids,
            index_entries_needed,uids_per_index, msg);
  }

  exit:
    if (rc EQ ESA_OK)
    {
      if ( (myPBheader NE NULL)  AND
           (myPBheader NE *PBheader) )
      {
        /* Free existing PBheader and point to a new one */
        free(*PBheader);
        (*PBheader) = myPBheader;
        ESA_DIAG_printf(comp, 9,
                        "returned pb = %p", *PBheader);
      }
    }
    else
    {
      /* There is an error. If PBheader was allocated *
       * lets free it                                 */
      if ( (myPBheader NE NULL)  AND
           (myPBheader NE *PBheader) )
        free(myPBheader);
    }

    ESA_DIAG_exit(comp, 2, func, rc);
    return rc;
}
/* WS10076K - Ends */

 /*  WS10076N - start */
/*********************************************************************
 * Procedure Name: Permission_block_Look4uid
 *********************************************************************
 * Description   : Look for a UID in the Permissions block.
 *                 If found, return the address of the UID element.
 *                 If not found, return the address of the UID element
 *                 to which the new UID has to be chained (upon request)
 *
 * Input         : uid:      UID to look for.
 *                 PBHeader: -> permissions block header.
 *                 chk_prev: What to return when uid is not found:
 *                           Y - return pointer to prev UID element.
 *                           N - return Not-FOUND.
 *
 * Output        : ret_code: return code.
 *               : ret_uid : -> uid element
 *
 *                 Data returned in ret_code and ret_uid:
 *                 - When UID is found:
 *                     ret_uid -> uid-entry;
 *                     ret_code = U.
 *                 - When UID is not found and chk_prev = Y:
 *                   - If UID is lower than 1st UID
 *                       ret_uid = NULL
 *                       ret_code = P.
 *                   - If UID is higher than last UID
 *                       ret_uid -> last uid element;
 *                       ret_code = L.
 *                   - All other cases:
 *                       ret_uid -> uid lower than uid requested.
 *                       ret_code = P.
 *
 * Return Value  : ESA_OK - data returned in ret_uid and ret_code,
 *                          according to chk_prev.
 *                 ESA_KEY_NOT_FOUND - uid was not found and
 *                                     chk_prev = N.
 *                 ESA_FATAL - error. Message was issued.
 *
 ********************************************************************/
static ESA_RC Permission_block_Look4uid(
                                char                     * uid,
                                PERM_BLK_HDR_rec_typ     * PBheader,
                                char                       chk_prev,
                                char                     * ret_code,
                                PERM_BLK_UID_rec_typ    ** ret_uid,
                                ESA_DIAG_COMP_typ          comp,
                                ADMIN_PARAMS_rec_typ     * admin_params)
{
 static char         func[] = "Permission_block_Look4uid";
 ESA_RC              rc = ESA_SKIP;

 PERM_BLK_UID_rec_typ * puid = NULL;     /* -> prev entry  */
 PERM_BLK_UID_rec_typ * luid = NULL;     /* -> last-to-check entry */
 int                  i = 0;
 int                  int_rc = 0;
 int                  msg_issued = FALSE;

 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 ESA_DIAG_enter(comp, 1, func );

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_printf(comp, 17,
                 "Look4UID:  uid = |%s|  prev = %c  pbh = %p",
                 uid, chk_prev, PBheader);

 /* Initialize return fields */
 *ret_code = NULL_CHAR;
 *ret_uid = NULL;

 /* Validate the PB */
 if (PBheader EQ NULL)
 {
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                 "Look4UID: No PB",
                 16, __LINE__);
   msg_issued = TRUE;
   rc = ESA_FATAL;
   goto exit;
 };

 ESA_DIAG_printf(comp, 17,
               "Look4UID: PB = X'%p'-> %4s / %d / %d / %d ",
               PBheader, PBheader->eyecatcher,
               PBheader->num_uids, PBheader->num_ix_ent,
               PBheader->num_used_ix_ent);

 /* PB is empty ?   */
 if (PBheader->num_uids EQ 0)
 {
   if (chk_prev EQ 'Y')
   {
     *ret_code = 'P';
     rc = ESA_OK;
   }
   else
     rc = ESA_KEY_NOT_FOUND;

   goto exit;
 }
 else
   if (PBheader->num_used_ix_ent LT 2)
   {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               "Look4UID: Invalid PB. See PRTDBG",
               16, __LINE__);
     msg_issued = TRUE;
     rc = ESA_FATAL;
     goto exit;
   };

 /*
  *  Check UID against first and last entries.
  *  - If equal - return uid element address and ret_code = U.
  *  - If UID is lower than 1st UID
  *    - If chk_prev = N, return ret_uid = NULL and
  *      rc = ESA_KEY_NOT_FOUND
  *    - If chk_prev = Y, return ret_uid = NULL, ret_code = P
  *      and rc = ESA_OK.
  *  - If UID is higher than last UID
  *    - If chk_prev = N, return ret_uid = NULL and
  *      rc = ESA_KEY_NOT_FOUND
  *    - If chk_prev = Y, return ret_uid = last entry address,
  *      ret_code = L and rc = ESA_OK.
  *
  */

 /*   uid <= first */
 int_rc = strcmp(uid, PBheader->index[0].uid);
 ESA_DIAG_printf(comp, 17,
                "Look4UID: first = X'%p'->%d / |%s|   compare = %d",
                PBheader->index[0].UIDentry,
                PBheader->index[0].entry_number,
                PBheader->index[0].uid, int_rc);

 if (int_rc EQ 0)             /*  UID is equal to first in index */
 {
   if (PBheader->index[0].UIDentry NE NULL)
   {
     *ret_uid = PBheader->index[0].UIDentry;
     *ret_code = 'U';
     rc = ESA_OK;
   }
   else
     rc = ESA_FATAL;
 }
 else
 {
   if (int_rc LT 0)       /*  UID is lower than 1st in index */
   {
     if (chk_prev EQ 'Y')
     {
       *ret_code = 'P';
       rc = ESA_OK;
     }
     else
       rc = ESA_KEY_NOT_FOUND;
   }
   else                   /* uid is higher than first */
   {
     /*    uid >= last ?   */
     i = PBheader->num_used_ix_ent - 1;
     int_rc = strcmp(uid,
                 PBheader->index[i].uid);
     ESA_DIAG_printf(comp, 17,
       "last = X'%p'->%d / |%s|   compare = %d",
       PBheader->index[i].UIDentry,
       PBheader->index[i].entry_number,
       PBheader->index[i].uid, int_rc);
     if (int_rc EQ 0)             /*    is equal to last ?          */
     {
       *ret_uid = PBheader->index[i].UIDentry;
       *ret_code = 'U';
       rc = ESA_OK;
     }
     else
       if (int_rc GT 0)           /*  UID is higher than last ?     */
       {
         if (chk_prev EQ 'Y')
         {
           if (PBheader->index[0].UIDentry NE NULL)
           {
             *ret_uid =
                PBheader->index[i].UIDentry;
             *ret_code = 'L';
             rc = ESA_OK;
           }
           else
             rc = ESA_FATAL;
         }
         else
           rc = ESA_KEY_NOT_FOUND;
       }
   }
 }

 ESA_DIAG_printf(comp, 17,
       "first/last checked: rc = %d  ret_code = %c  ret_UID = X'%p'",
       rc, *ret_code, *ret_uid );

 /*  If we have an answer - return.  */
 if (rc NE ESA_SKIP)
   goto exit;

 /*
  *  Look for UID in index (search entries 2 - 1-before-last)
  *  - If found - return.
  *  - If lower than first ix entry, return NULL and P/N according
  *    to chk_prev.
  *  - if higher than ix entry, check next entry.
  *
  */
 for (i = 1; i LT PBheader->num_used_ix_ent-1; i++)
 {
   int_rc = strcmp(uid, PBheader->index[i].uid);
   ESA_DIAG_printf(comp, 17,
               "Look4UID: index entry %d - |%s|  compare = %d",
                i, PBheader->index[i].uid, int_rc);

   if (int_rc EQ 0)         /*    UID was found in index ?    */
   {
     *ret_uid = PBheader->index[i].UIDentry;
     *ret_code = 'U';
     rc = ESA_OK;
     break;
   }
   else
     if (int_rc LT 0)       /*  UID is lower than index entry  */
       break;
 }

 ESA_DIAG_printf(comp, 17,
               "Look4UID: After index search - %c / X'%p'  i = %d",
                *ret_code, *ret_uid, i);

 /*  If we have an answer - return.  */
 if (rc NE ESA_SKIP)
   goto exit;

 /*
  *  If not found yet, scan the UIDs pointed by ix entry i-1
  *  until we find the UID or a higher UID.
  */
 puid = PBheader->index[i-1].UIDentry;  /* scan start point */
 luid = PBheader->index[i].UIDentry;    /* scan end point */

 ESA_DIAG_printf(comp, 17,
                "start scan: X'%p' -> X'%p'/ %c / |%s|",
                puid,
                puid EQ NULL? 0 : puid->next_uid,
                puid EQ NULL? ' ' : puid->eyec,
                puid EQ NULL? "" : puid->uid);
 ESA_DIAG_printf(comp, 17,
                "end scan: X'%p' -> X'%p'/ %c / |%s|",
                luid,
                luid EQ NULL? 0 : luid->next_uid,
                luid EQ NULL? ' ' : luid->eyec,
                luid EQ NULL? "" : luid->uid);

 /*  validate the entries */
 if (puid NE NULL                       AND
     luid NE NULL                       AND
     puid->eyec EQ PBheader->table_type AND         /*WS10079A*/
     luid->eyec EQ PBheader->table_type)            /*WS10079A*/
     /*WS10079A puid->eyec EQ ACF2_UID_PBENT_EYEC  AND
                luid->eyec EQ ACF2_UID_PBENT_EYEC)  /*WS10079A*/
 {
   /*
    *  scan the UID elements:
    *  The scan is done from the second element (because we
    *  know that the UID we have is lower tan the first in chain)
    *  until the last element to check, which is the element
    *  of the next index entry. (We know that the UID is lower
    *  than this element).
    */
   while (puid NE NULL   AND   puid NE luid)
   {
     if ( puid->next_uid EQ  NULL    OR    /* validate the ... */
          ( puid->next_uid NE  NULL    AND /* ...next UID ent. */
            puid->next_uid->eyec NE PBheader->table_type) ) /*WS10079A*/
            /*WS10079Apuid->next_uid->eyec NE ACF2_UID_PBENT_EYEC ) )*/
     {
       ESA_DIAG_printf(comp, 6,
          "Look4UID: Invalid element: %s / X'%p' ->  %c / |%s|",
          puid->uid, puid->next_uid,
          puid->next_uid EQ NULL ? ' ' : puid->next_uid->eyec,
          puid->next_uid EQ NULL ? "" : puid->next_uid->uid);
       rc = ESA_FATAL;
       break;
     }

     int_rc = strcmp(uid, puid->next_uid->uid);
     ESA_DIAG_printf(comp, 20,
                "UID entry compare - X'%p' / |%s|   rc = %d",
                puid->next_uid, puid->next_uid->uid, int_rc);

     if (int_rc EQ 0)         /*  UID was found in next entry. */
     {
       *ret_uid = puid->next_uid;
       *ret_code = 'U';
       rc = ESA_OK;
       break;
     }
     else
       if (int_rc LT 0)       /*  UID is lower than next entry */
       {
         if (chk_prev EQ 'Y')
         {
           *ret_code = 'P';
           *ret_uid = puid;
           rc = ESA_OK;
         }
         else
           rc = ESA_KEY_NOT_FOUND;
         break;
       }

     puid = puid->next_uid;  /* -> next uid element */
   }
 }
 else    /* The elemen pointed by index is invalid */
 {
   ESA_DIAG_printf(comp, 6,
                  "puid = X'%p' -> X'%p'/ %c / |%s|",
                   puid,
                   puid EQ NULL? 0 : puid->next_uid,
                   puid EQ NULL? ' ' : puid->eyec,
                   puid EQ NULL? "" : puid->uid);
   ESA_DIAG_printf(comp, 6,
                   "luid = X'%p' -> X'%p'/ %c / |%s|",
                   luid,
                   luid EQ NULL? 0 : luid->next_uid,
                   luid EQ NULL? ' ' : luid->eyec,
                   luid EQ NULL? "" : luid->uid);
   rc = ESA_FATAL;
 }

 ESA_DIAG_printf(comp, 17,
                 "Look4UID: chain checked -  %c / X'%p'",
                 *ret_code, *ret_uid);

 /*
  *  When we get here, we should have a return code set.
  *  If not, this is an error.
  */
 exit:
  if ( rc EQ ESA_SKIP)
    rc = ESA_FATAL;
  else
    if ( *ret_uid NE NULL  AND          /* Validate returned element */
         (*ret_uid)->eyec NE PBheader->table_type)       /*WS10079A*/
         /*WS10079A (*ret_uid)->eyec NE ACF2_UID_PBENT_EYEC)       */
    {
      ESA_DIAG_printf(comp, 0,
              "Invalid returned element: '%p' -> X'%p'/ %c / |%s|",
              *ret_uid, (*ret_uid)->next_uid, (*ret_uid)->eyec,
              (*ret_uid)->uid);
      rc = ESA_FATAL;
    };

  if ( rc EQ ESA_FATAL  AND  !msg_issued)
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
          "Look4UID: Search failed or invalid UID element. See PRTDBG",
          16, __LINE__);

  ESA_DIAG_printf(comp, 17,
                  "Look4UID: return -  %c / X'%p'",
                  *ret_code, *ret_uid);

  ESA_DIAG_exit(comp, 1, func, rc);
  return rc;
}
/*  WS10076N - end   */

/*** *** *** *** *** *** ** WS10076S start ** *** *** *** *** *** ***/
/*********************************************************************
 * Procedure Name: Permissions_block_Free
 *********************************************************************
 * Description   : Free the entire Permissions Block
 *
 * Input         : PBHeader
 *                 comp - diagnostic component
 *
 * Output        : none
 *
 * Return Value  : ESA_OK - The entire Permissions Block was freed
 *                 ESA_FATAL - The PB was not entirely freed
 *                             because an error was encountered
 *
 ********************************************************************/
ESA_RC Permissions_block_Free(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char             func[] = "Permissions_block_Free";
  ESA_RC                  rc = ESA_OK;

  PERM_BLK_UID_rec_typ  * thisUID = NULL;
  PERM_BLK_UID_rec_typ  * nextUID = NULL;
  PERM_BLK_PERM_rec_typ * thisPERM = NULL;
  PERM_BLK_PERM_rec_typ * nextPERM = NULL;
  char                    errmsg[200];

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *    To free the entire PB, we begin with the first UID entry
  *    and set up a nested loop. The outer loop will be the
  *    'vertical' loop which frees each UID entry and the inner
  *    loop will be the 'horizontal' loop which frees each
  *    permission connected to the UID.  This 'horizontal' loop
  *    gets each permission, frees it, and goes on to the next
  *    permission until we reach a NULL (no additional permissions).
  */

  ESA_DIAG_printf(comp, 6,
                 "PBheader = %p -> %s",
                  PBheader,
                  PBheader EQ NULL?  "" : PBheader->eyecatcher);

  if (PBheader NE NULL)
  {
     if (strncmp(PBheader->eyecatcher, PBH_EYECATCHER,
                 sizeof(PBheader->eyecatcher))     NE 0)
     {
        sprintf(errmsg,
               "PB header eyec error at location %p",
                PBheader);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, func, errmsg,
                      16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     thisUID = PBheader->index[0].UIDentry;

     while(thisUID NE NULL)             /* outer vertical loop - UID */
     {
        /* WS10079T start */
        if (thisUID->eyec NE PBheader->table_type)
           {
              sprintf(errmsg,
     "UID %.*s block eyec %c is not equal to PBheader eyec <%c> (%p)",
                      ACF2_UID_SIZE, thisUID->uid, thisUID->eyec,
                      PBheader->table_type, thisUID);
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                            component, func, errmsg,
                            16, __LINE__);
              rc = ESA_FATAL;
              goto exit;
           }
        /* WS10079T end  */
        thisPERM = thisUID->first_perm; /* 1st permission block */
        while(thisPERM NE NULL) /* inner horizontal loop - PERM */
        {
           nextPERM = thisPERM->next_perm;   /* get ptr to next */
           if (thisPERM->eyec NE ACF2_PERM_PBENT_EYEC)
              {
                 sprintf(errmsg,
                         "Perm block eyec error at location %p",
                         thisPERM);
                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                               component, func, errmsg,
                               16, __LINE__);
                 rc = ESA_FATAL;
                 goto exit;
              }
           ESA_DIAG_printf(comp, 17,
                    "About to free perm block at location %p",
                    thisPERM);
           free(thisPERM);
           thisPERM = nextPERM;                /* point to next */
        } /* while(thisPERM NE NULL) */
        nextUID = thisUID->next_uid;         /* get ptr to next */
        /* WS10079T start
        if (thisUID->eyec NE ACF2_UID_PBENT_EYEC)
           {
              sprintf(errmsg,
                      "UID %.*s block eyec error at location %p",
                      sizeof(ACF2_UID_SIZE), thisUID->uid,
                      thisUID);
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                            component, func, errmsg,
                            16, __LINE__);
              rc = ESA_FATAL;
              goto exit;
           }
           WS10079T end  */
      /************************   WS10079A starts   *******************/
      /* call the extension routine if it's a real UID entry
         and if external routine exists.                     WS10079A*/
      /* WS10084
      if((thisUID->eyec EQ PBheader->table_type) AND          WS10084*/
      /* WS10084 we need to call ext free for Roles                  */
      /*IS10189 free for all entities, including sources
      if((                                                   *WS10084*
           (thisUID->eyec EQ ACF2_UID_PBENT_EYEC )           *WS10084*
           OR                                                *WS10084*
           (thisUID->eyec EQ ACF2_ROLE_PBENT_EYEC)           *WS10084*
         )                                       AND         *WS10084*
        ((PBheader->ext_block_routines NE NULL)  AND        /*IS10189*/
      if((PBheader->ext_block_routines NE NULL)  AND        /*IS10189*/
         (PBheader->skip_extYN NE 'Y')           AND        /*WS10084*/
         (PBheader->ext_block_routines->free NE NULL)) {
        /* WS10084
        ESA_DIAG_printf(comp, 0 ,                        /* WS10084 @/
            "About to call ->ext_block_routines->free"); /* WS10084 @/
           WS10084  */
        rc = (*PBheader->ext_block_routines->free)(
                   thisUID,
                   (void *) PBheader,
                   comp,
                   admin_params);
        if(rc NE ESA_OK) {
          rc = ESA_FATAL;
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                       "Failed to free SYSID", rc, __LINE__);
          goto exit;
        }
        ESA_DIAG_printf(comp, 6,
             "Extension routine of %s returned rc(%d)", func,rc);
      }
      /************************   WS10079A ends   *********************/
        ESA_DIAG_printf(comp, 17,
                 "About to free UID %s block at location %p",
                 thisUID->uid, thisUID);
        free(thisUID);
        thisUID = nextUID;                     /* point to next */
     } /* while(thisUID NE NULL) */

     ESA_DIAG_printf(comp, 17,
              "About to free PB header block at location %p",
              PBheader);
     free(PBheader);
  } /* if (PBheader NE NULL) */

  rc = ESA_OK;
  goto exit;

  exit:

  ESA_DIAG_exit(comp, 1, func, rc);
  return rc;
}
/***************** Permissions_block_Free ends ***********************/

/*********************************************************************
 * Procedure Name: Permissions_block_Print
 *********************************************************************
 * Description   : Print the entire Permissions Block
 *
 * Input         : PBHeader
 *                 comp - diagnostic component
 *
 * Output        : none
 *
 * Return Value  : ESA_OK - The entire Permissions Block was printed
 *                 ESA_FATAL - The PB was not entirely printed
 *                             because an error was encountered
 *
 ********************************************************************/
ESA_RC Permissions_block_Print(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char             func[] = "Permissions_block_Print";
  ESA_RC                  rc = ESA_OK;
  int                     i = 0;

  PERM_BLK_UID_rec_typ  * thisUID = NULL;
  PB_INDEX_rec_typ      * thisINDEX = NULL;
  char                    errmsg[200];

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *    We will print parts of the PB.
  *    1) header: address, num_uids, num_ix_ent, and num_used_ix_ent
  *    2) uid ('vertical'): address, uid name, and uid number
  *    3) index entries: address, uid name, and entry number
  */

  if (PBheader EQ NULL)
  {
     ESA_DIAG_printf(comp, 0, "PBheader input NULL");
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   component, func, "PBheader input NULL",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  else
  {
     if (strncmp(PBheader->eyecatcher, PBH_EYECATCHER,
                 sizeof(PBheader->eyecatcher)) NE 0)
     {
        ESA_DIAG_printf(comp, 0,
            "PB header incorrect eyec - location %p", PBheader);
        sprintf(errmsg, "PB header incorrect eyec - location %p",
                PBheader);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, func, errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     ESA_DIAG_printf(comp, 6,
         "PBheader at %p: num_uids=%d num_index=%d num_used_index=%d",
         PBheader, PBheader->num_uids, PBheader->num_ix_ent,
         PBheader->num_used_ix_ent);
  }

  for (i = 1, thisUID = PBheader->index[0].UIDentry;
       i LE PBheader->num_uids;
       i++, thisUID = thisUID->next_uid)
  {
     /*WS10079A if (thisUID->eyec NE ACF2_UID_PBENT_EYEC)             */
     if (thisUID->eyec NE PBheader->table_type)             /*WS10079A*/
     {
        ESA_DIAG_printf(comp, 6,
            "(i) - UID block incorrect eyec - location %p", i, thisUID);
        sprintf(errmsg,
                "UID block incorrect eyec - location %p",
                thisUID);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, func, errmsg,
                      16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     ESA_DIAG_printf(comp, 6,
         "UID (%d) block at %p: UID=|%s|",
         i, thisUID, thisUID->uid);
     /************************   WS10079A starts   *******************/
     /* call the extension routine if external routine exists.       */
     if((PBheader->ext_block_routines NE NULL) AND
       (PBheader->skip_extYN NE 'Y')           AND          /* WS10084 */
       (PBheader->ext_block_routines->print NE NULL)) {
       rc = (*PBheader->ext_block_routines->print)(
                  thisUID,
                  (void *) PBheader,
                  comp,
                  admin_params);
       if(rc NE ESA_OK) {
         rc = ESA_FATAL;
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                       "Failed to print SYSID", rc, __LINE__);
         goto exit;
       }
       ESA_DIAG_printf(comp, 6,
            "Extension routine of %s returned rc(%d)", func,rc);
     }
     /************************   WS10079A ends   *********************/
  }

  for (i = 1;
       i LE PBheader->num_used_ix_ent;
       i++, thisINDEX = &(PBheader->index[i-1]))
  {
     thisINDEX = &(PBheader->index[i-1]);
     ESA_DIAG_printf(comp, 6,
         "INDEX (%d) block at %p: UID=|%s| at %p",
         thisINDEX->entry_number, thisINDEX, thisINDEX->uid,
         thisINDEX->UIDentry);
  }

  rc = ESA_OK;

  exit:
  ESA_DIAG_exit(comp, 1, func, rc);
  return rc;
}
/*** *** *** *** end of permissions_block_print *** *** *** *** ***/
/*** *** *** *** *** *** ** WS10076S end ** *** *** *** *** *** ***/


/* * * * WS10078S start * * * */

/******************************************************************
 * Procedure Name: Permission_Get_ROLEUSER
 ******************************************************************
 * Description   : Get the ROLE or USER from the rule record.
 *
 * Input         : pointer to rule record
 * Output        : pointer to ROLE or USER from rule record
 * Return Value  : ESA_OK or ESA_FATAL
 ******************************************************************/
static ESA_RC Permission_Get_ROLEUSER(char     * rule_record,
                          char                ** return_roleuser,
                          ADMIN_PARAMS_rec_typ * admin_params)
{
  static char func[] = "Permission_Get_ROLEUSER";

  ESA_RC        rc = ESA_OK;
  int           roleuser_rc = 0;
  char          kwdrole_to_find[6] = "ROLE(";
  char          kwduser_to_find[6] = "USER(";
  char          errmsg[125];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func);

  roleuser_rc = Permission_locate_data(BYKEY_Function,
                                       rule_record,
                                       kwdrole_to_find,
                                       return_roleuser,
                                       admin_params);
  if (roleuser_rc EQ 0)
     goto exit;

  roleuser_rc = Permission_locate_data(BYKEY_Function,
                                       rule_record,
                                       kwduser_to_find,
                                       return_roleuser,
                                       admin_params);
  if (roleuser_rc EQ 0)
     goto exit;

  else
   {
      sprintf(errmsg,"No ROLE( or USER( in rule record");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   };


  exit:;

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, rc);
  return rc;
}

/* * * * WS10078S end * * * */
/* WS10079T - start */
/**************************************************************
*                                                             *
* PROCEDURE NAME : Drop_Perms_Match                           *
*                                                             *
* DESCRIPTION    : Match UID or ROLE with filter values       *
*                  DROP_ACCT_IND_PERMS  or                    *
*                  DROP_GROUP_PERMS                           *
* INPUT          : parm  : which parm we are validating       *
*                : filter:the string of filter values         *
*                : entity: the entity being handled,          *
*                           without parenthesis               *
*                : etype : U or R                             *
*                : ftype : filter type:                       *
*                          P - only with P                    *
*                          N - only without P                 *
*                          ? - return type                    *
* OUTPUT         : ftype : filter type: P/N                   *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                  ESA_OK :    found                          *
*                  ESA_FATAL : not found                      *
**************************************************************/
EXT ESA_RC Drop_Perms_Match(
                 char                       * parm,
                 char                       * filter,
                 char                       * entity,
                 char                         etype,
                 char                       * ftype,
                 ESA_DIAG_COMP_typ            diag_comp,
                 ADMIN_PARAMS_rec_typ       * admin_params)
{

  static char func[]     = "Drop_Perms_Match";
  ESA_RC      rc         = ESA_FATAL;
  char        errmsg[80] = "";
  char        search[30] = "";
  char      * p1         = NULL;
  char      * p2         = NULL;
  char      * last       = NULL;
  int         len        = 0;
  int         slen       = 0;
  int         i          = 0;
  int         left       = 0;
  int         blanks     = 0;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(diag_comp, 1, func);

  if ( (parm   EQ NULL)   OR
       (filter EQ NULL)   OR
       (entity EQ NULL)   OR
       (ftype  EQ NULL)   )
  {
     strcat(errmsg,"Mandatory parmameter(s) not provided: ");
     if (parm   EQ NULL) strcat(errmsg,"parm ");
     if (filter EQ NULL) strcat(errmsg,"filter ");
     if (entity EQ NULL) strcat(errmsg,"entity ");
     if (ftype  EQ NULL) strcat(errmsg,"ftype");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
  }
  else
  if (  (*ftype NE 'P')  AND
        (*ftype NE 'N')  AND
        (*ftype NE '?')  )
  {
      sprintf(errmsg,"Invalid ftype = %c",*ftype);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
  }
  ESA_DIAG_printf(diag_comp,7,
      "RSSPARM = %s filter = <%s> \n"
      "entity = %s etype = %c ftype = %c",
      parm, filter, entity, etype, *ftype);

  len = strlen(filter);
  if (len EQ 0) goto exit;

  if (*ftype EQ 'P')
     sprintf(search,"%c(%s)P", etype,entity);
  else
     sprintf(search,"%c(%s)", etype,entity);

  ESA_DIAG_printf(diag_comp,7,
      "Searching for ftype %c <%s> in %s <%s>",
       *ftype, search,parm,filter);
  slen = strlen(search);
  last = filter + len - 1;

  /* find first non blank */

  blanks = strspn(filter," ");
  p1 = filter + blanks;

  while (p1 + slen - 1 LE last)
  {
    ESA_DIAG_printf(diag_comp,7,
            "while: p1 = %s", p1);
    if (strncmp(p1,search,slen) EQ 0)
    {
       if (*ftype EQ 'P')
            goto found;

       if (*ftype EQ 'N')
       {
          if ((p1 + slen - 1) EQ last)
               goto found;

          if (*(p1 + slen) NE 'P' )
               goto found;
          else
          {
            p1++;
            continue;
          }

       }

       if (*ftype EQ '?')
       {
          if ((p1 + slen - 1) EQ last)
             {
               *ftype = 'N';
               goto found;
             }
          if (*(p1 + slen) EQ 'P' )
             {
               *ftype = 'P';
               goto found;
             }
          *ftype = 'N';
          goto found;
       }
    }
    p1++;
  }
  ESA_DIAG_printf(diag_comp,20,
            "not found %s ftype %c in %s",
             search, *ftype, p1);
  goto exit;

  found:
      ESA_DIAG_printf(diag_comp,6,
            "found %s ftype %c in %s",
             search, *ftype, filter);
      rc = ESA_OK;
      goto exit;


  exit:
  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;
}
/* WS10079T - end   */
/* BS10108 - Move Get_User_XSPG to CTSBGUS                        */
/* WS10079A Drop Get_User_XSPG from here to reduce member size.   */
