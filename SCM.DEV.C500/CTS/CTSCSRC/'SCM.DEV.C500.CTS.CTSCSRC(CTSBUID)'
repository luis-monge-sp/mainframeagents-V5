 /**************************************************************
 *                                                             *
 * Title            : Various ACF2 UID manipulation functions  *
 *                                                             *
 * File Name        : ctsbuid.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 20/07/97                                 *
 *                                                             *
 * Description      :                                          *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 * The main functionality of this package is to analyze what is*
 * required to adjust a User's UID String according to a UID   *
 * Mask, and if such a change is possible without destroying   *
 * fields values already in place for the User.                *
 *                                                             *
 * Examples: UID fields: KLMNOPQ (each field is one pos.)      *
 *           UID String: A  B  D                               *
 *           UID Mask  : AC****D                               *
 *           Connect User to Mask: CHANGE USER L(C)            *
 *                                                             *
 * Examples: UID fields: KLMNOPQ (each field is one pos.)      *
 *           UID String: AD B  D                               *
 *           UID Mask  : AC*B**D                               *
 *           Connect User to Mask: Cant connect, collision in  *
 *                                 position 2.                 *
 * Examples: UID fields: KLMNOPQ (each field is one pos.)      *
 *           UID String: A  B  D                               *
 *           UID Mask  : AC*B**D                               *
 *        DisConnect User to Mask: CHANGE USER K( ) N( ) Q( )  *
 *           No need to handle "C" value change because target *
 *           UID is already " ".                               *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------- -------------------------------- *
 * WS2337   Guy      08/10/98 Added Multi Valued Fields support*
 * PS0321   Guy      26/10/98 Added UIDX field                 *
 * PS0339   Guy      26/11/98 Fix a bug in UID_Is_MULTI check  *
 * PS0345   Guy      02/12/98 Add ACF2_Is_Part_Of_Multi        *
 * PS0351   Guy      07/12/98 Multivalued fields support       *
 * PS0354   Guy      09/12/98 Check Disconnect from Multivalued*
 *                            field in Update User             *
 * PS0458   Michael  18/03/01 User to UG conn fix              *
 * BS2556   AvnerL   14/10/02 send acf2 original error msg     *
 * bs2607   AvnerL 29/05/2003 support date user defined fields *
 * IS10088  NuritY 26/03/2012 Abend S0C4 when uid mask in group*
 *                            is longer than max uid. (BS10030)*
 * WS10082  MauriC   07/11/22 Recompile for new ADDINFO macros *
 **************************************************************/
#include <globs.h>

#include STDLIB
#include STDIO
#include STRING
#include CTYPE

#include ESA_DIAG

#include MVS_COMP

#include API_ADDINFO
#include ACF2

 /*************************************************************
 * Installation UID fields definitions and attributes         *
 **************************************************************/
static int           UID_Field_Count = 0;
static UID_Structure UIDtab[ACF2_UID_SIZE];
static char          UIDdescription[256] = "";
static char          UID_Is_MULTI='N';                    /* PS0321 */
static char          MULTI_VALUE_Field_In_UID[20]="";     /* PS0321 */
static short         MULTI_VALUE_Field_Offset = 0;        /* PS0321 */

 /*************************************************************
 * UID component modification  descriptor                     *
 **************************************************************/
typedef struct {
 char  UMT_Field_Name[16];
 char  UMT_Field_Value[ACF2_UID_SIZE];
 int   UMT_Field_Offset;
 int   UMT_Length;
 char  UMT_New_Value[ACF2_UID_SIZE];
} UID_Modifier_Transaction;

 /*************************************************************
 * Non_Masked UID component description                       *
 **************************************************************/
typedef struct {
 short UM_Offset;
 short UM_Length;
} UID_Modifier;

static void Break_UID_to_UID_Modifiers(UIDMASK   UID,
                                       int       *modcnt,
                                       UID_Modifier moduid[1]);

static ESA_RC Convert_UID_Offset_to_UIDtab_Index(int   uid_offset,
                                               int   *index,
                                               int   *field_offset);

ESA_RC Convert_UID_Offset_to_Field_Name(int   uid_offset,
                                        char  *field_name,
                                        int   *field_offset);

static ESA_RC Build_UID_Modifiers(UID_Update_type Update_Type,
                                  UIDMASK UID_User_p,
                                  UIDMASK UID_Mask_p,
                                  int  *UMT_Count,
              /* WS10090 */       UID_Modifier_Transaction *UMT,
              /* WS10090 */       char  allow_collision);
              /* WS10090          UID_Modifier_Transaction *UMT); */

/* PS0351 - New Function */
static ESA_RC Generate_Multi_Update(UID_Update_type Update_Type,
                                    char *UID_User,
                                    char *UID_Masks,
                                    ADDINFO_rec_ptr uaddinfo,
                                    ADDINFO_rec_ptr laddinfo);

/******************************************************************
 * Procedure Name: Initialize_UID_Definitions
 ******************************************************************
 * Description   : Get Installation UID components definitions
 *
 * Input         : NONE
 * Output        : UID definition table completed (static)
 *
 * Return Value  : None
 ******************************************************************/
void Initialize_UID_Definitions( /* void) add admin_params bs2607*/
         /* bs2607 */           ADMIN_PARAMS_rec_typ  * admin_params)
 {
 static char func[] = "Initialize_UID_Definitions";
 int i;
 int found_multi;                                         /* PS0321 */
 ACF2_PARAMS_rec_typ * params_ptr = NULL;                /*IS10088*/
 int uidlen;                                             /*IS10088*/

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*************************************************************
 * Get UID Strcuture                                          *
 **************************************************************/
 ACF2_Get_UID_Info( UIDdescription                      ,
                    &UID_Field_Count                    ,
                    UIDtab                              ,
                    &UID_Is_MULTI,                        /* PS0321 */
                    admin_params);                        /* bs2607 */

 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                 "UID Description = (%s)",
                 UIDdescription);
 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                 "UID Field Count = (%d)",
                 UID_Field_Count);
 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                 "UID contains MULTI VALUED field = (%c)",
                 UID_Is_MULTI);                           /* PS0321 */

 found_multi = FALSE;                                     /* PS0321 */

 /*************************************************************
 * Display UID Structure                                      *
 **************************************************************/
 for(i=0;i LT UID_Field_Count;i++)
 {
   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
      "UID f(%d) is (%s) uid_o=(%d) uid_l(%d) fld_o=(%d) mul=(%c)",
                   i+1,
                   UIDtab[i].UID_Part_Field_Name,
                   UIDtab[i].UID_Part_Offset,
                   UIDtab[i].UID_Part_Length,
                   UIDtab[i].UID_Field_Offset,
                   UIDtab[i].UID_Part_Multi);             /* PS0321 */

   /* PS0321 - Keep name and UID offset of MULTI-VALUED field in UID */
   if ( (UIDtab[i].UID_Part_Multi EQ 'Y') AND
        (NOT found_multi) )
   {
     found_multi = TRUE;
     strcpy (MULTI_VALUE_Field_In_UID, UIDtab[i].UID_Part_Field_Name);
     MULTI_VALUE_Field_Offset = UIDtab[i].UID_Part_Offset;
   };
 };

 /********************* IS10088 ************************************
  *       calculate UID_Length and keep it for future use         *
  *****************************************************************/
 if (UID_Field_Count GT 0)
 {
  ESA_DIAG_printf(PLT_COMP_API_ACF2, 1,
      "UID_Field_Count = <%d>",UID_Field_Count);
  ESA_DIAG_printf(PLT_COMP_API_ACF2, 1,
      "UIDtab[UID_Field_Count - 1].UID_Part_Offset = <%d>",
      UIDtab[UID_Field_Count - 1].UID_Part_Offset);
  ESA_DIAG_printf(PLT_COMP_API_ACF2, 1,
      "UIDtab[UID_Field_Count - 1].UID_Part_Length = <%d>",
      UIDtab[UID_Field_Count - 1].UID_Part_Length);
  uidlen = UIDtab[UID_Field_Count - 1].UID_Part_Offset +
           UIDtab[UID_Field_Count - 1].UID_Part_Length;
  ESA_DIAG_printf(PLT_COMP_API_ACF2, 1,
      "uidlen= <%d>", uidlen);
  params_ptr = admin_params->apiinit_handle;
  params_ptr->uidlen = uidlen;
 }
 /*** end of IS10088 ***/
 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, ESA_OK);
}

/******************************************************************
 * Procedure Name: Get_UID_In_ESS_Format
 ******************************************************************
 * Description   : Get UID structure information in ESS format
 *
 * Input         : None
 *
 * Output        : ACFFDR in ESS Table Format
 *
 * Return Value  : None
 ******************************************************************/
void Get_UID_In_ESS_Format(char *field)
{
 int i;
 char temp[256]="";
 char subfield[2], entry[2];

 subfield[0]=ADDINFO_LIST_SUBFIELD;
 subfield[1]=NULL_CHAR;
 entry[0]=ADDINFO_LIST_ENTRY;
 entry[1]=NULL_CHAR;

 field[0] = NULL_CHAR;
 for(i=0;i LT UID_Field_Count;i++)
  {
   strcat(field,UIDtab[i].UID_Part_Field_Name);
   strcat(field,subfield);
   sprintf(temp,"%d",UIDtab[i].UID_Field_Offset);
   strcat(field,temp);
   strcat(field,subfield);
   sprintf(temp,"%d",UIDtab[i].UID_Part_Offset);
   strcat(field,temp);
   strcat(field,subfield);
   sprintf(temp,"%d",UIDtab[i].UID_Part_Length);
   strcat(field,temp);
   strcat(field,entry);
  };
 field[strlen(field)-1]=NULL_CHAR;
}

/* PS0321 - New function */
/******************************************************************
 * Procedure Name: UID_Contains_MULTI
 ******************************************************************
 * Description   : Check if UID contains MULTI VALUED field
 *
 * Input         : None
 *
 * Output        : Name of MULTI-VALUED field
 *                 Offset of MULTI-VALUED field in UID
 *
 * Return Value  : Y/N
 ******************************************************************/
int UID_Contains_MULTI(char  * multi_field_name,
                       int   * multi_field_offset)
{
  int UID_Multi_Flag;

  if (UID_Is_MULTI EQ 'Y')                                /* PS0339 */
  {
    UID_Multi_Flag = TRUE;
    strcpy (multi_field_name, MULTI_VALUE_Field_In_UID);
    *multi_field_offset = MULTI_VALUE_Field_Offset;
  }
  else
    UID_Multi_Flag = FALSE;

  return UID_Multi_Flag;
}
/* End of PS0321 */

/******************************************************************
 * Procedure Name: Generate_UID_Update
 ******************************************************************
 * Description   : Generate an ADDINFO object that can be executed
 *                 against a User's record to modify its UID fields
 *
 * Input         : Update Type - Connect to Mask/ Disconnect from Mask
 *                 User UID - a UID String
 *                 Uid Mask - a UID Mask representing the required
 *                            modification.
 *                 uaddinfo - Original User field values
 *                 allow_collision - Y / N
 *
 * Output        : laddinfo - Update ADDINFO
 *
 * Return Value  : ESA_RC
 *                 ESA_OK    - Update ADDINFO generated
 *                 ESA_ERR   - User UID dont match UID Mask
 *                 ESA_FATAL - Failure
 ******************************************************************/
ESA_RC Generate_UID_Update(UID_Update_type Update_Type,
                           UIDMASK UID_User,
                           UIDMASK UID_Mask,
                           ADDINFO_rec_ptr uaddinfo,
                           ADDINFO_rec_ptr laddinfo,      /* WS10090 */
                           char    allow_collision)       /* Ws10090 */
           /* WS10090      ADDINFO_rec_ptr laddinfo)    */
{
 static char func[] = "Generate_UID_Update";

 ESA_RC rc = ESA_OK;
 int i, UMT_Count = 0;
 UID_Modifier_Transaction UMT[ACF2_UID_SIZE];

 char    field_type;
 char    field_rw;
 char    field_multi;                                     /* WS2337 */
 int     field_length = 0;
 int     field_offset = 0;
 int     field_mvmax = 0;                                 /* WS2337 */
 char    field_value[256] = "";
 char    original_value[256] = "";

 ONE_FIELD_rec_ptr pair;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*************************************************************
 * Build UID modifcation descriptors                          *
 **************************************************************/
 rc = Build_UID_Modifiers(Update_Type,
                          UID_User,
                          UID_Mask,
                          &UMT_Count,
                          UMT,                            /* WS10090 */
                          allow_collision);               /* WS10090 */
         /* WS10090       UMT);    */

 if (rc NE ESA_OK) /* Error in Processing UID modification */
   goto exit;

 /*************************************************************
 * If no descriptor was created, no modification is required  *
 **************************************************************/
 if (UMT_Count EQ 0) /* Full Match no Modification */
   goto handle_multivalue;                                /* PS0351 */

 /*************************************************************
 * Process Modifcation descriptors                            *
 **************************************************************/
 for (i=0;i LT UMT_Count;i++)
  {
   /*************************************************************
   * Dont allow updates of LID field (read only)                *
   **************************************************************/
   if (strcmp(UMT[i].UMT_Field_Name,"LID") EQ 0)
    continue;

  /*************************************************************
  * Get Modified field initial value (if any)                  *
  **************************************************************/
    pair = ADDINFO_search(UMT[i].UMT_Field_Name,
                          ACF_ADDINFO_KWD_LEN,
                          uaddinfo->pair,
                          uaddinfo->num_pairs);

   if (pair EQ NULL)
    original_value[0] = NULL_CHAR;
   else
    strcpy(original_value,pair->value);

   /*************************************************************
   * Did we build an Update ADDINFO entry for that field?       *
   **************************************************************/
    pair = ADDINFO_search(UMT[i].UMT_Field_Name,
                          ACF_ADDINFO_KWD_LEN,
                          laddinfo->pair,
                          laddinfo->num_pairs);

   /*************************************************************
   * No, Create one                                             *
   * Yes, Copy current modification value                       *
   **************************************************************/
   if (pair EQ NULL)
    Reset_Field(field_value,256,' ',original_value);
   else
    Reset_Field(field_value,256,' ',pair->value);

   /*************************************************************
   * Get Modified fields information                            *
   **************************************************************/
   rc = ACF2_Get_Field_Information(UMT[i].UMT_Field_Name,
                              &field_type,
                              &field_rw,
                              &field_length,
                              &field_offset,
                              &field_multi,               /* WS2337 */
                              &field_mvmax);              /* WS2337 */

   if (rc NE ESA_OK)
    goto exit;

   /*************************************************************
   * Merge Field value with the Modified Value                  *
   **************************************************************/
   memcpy(field_value + UMT[i].UMT_Field_Offset,
          UMT[i].UMT_New_Value,
          UMT[i].UMT_Length);

   /*************************************************************
   * Set Field Actual Length                                    *
   **************************************************************/
   field_value[field_length] = NULL_CHAR;

   /*************************************************************
   * Add or Update modified field                               *
   **************************************************************/
   if (pair EQ NULL)
     ADDINFO_insert(TYPE_1A,
                   UMT[i].UMT_Field_Name,
                   field_value,
                   laddinfo,
                   ACF_ADDINFO_KWD_LEN,
                   ACF_ADDINFO_VAL_LEN,
                   UNIQUE);
   else
    {
     memcpy(field_value + UMT[i].UMT_Field_Offset,
            UMT[i].UMT_New_Value,
            UMT[i].UMT_Length);
     ADDINFO_updval(field_value,ACF_ADDINFO_VAL_LEN,pair);
     };
  };

 rc = ESA_OK;

 /* PS0351 - Handle REAL multivalued field */
 handle_multivalue:;

 if (UID_Is_MULTI EQ 'Y')                                 /* PS0351 */
 {                                                        /* PS0351 */
   rc = Generate_Multi_Update (Update_Type,               /* PS0351 */
                               UID_User,                  /* PS0351 */
                               UID_Mask,                  /* PS0351 */
                               uaddinfo,                  /* PS0351 */
                               laddinfo);                 /* PS0351 */
   if (rc NE ESA_OK)                                      /* PS0351 */
     goto exit;                                           /* PS0351 */
 };                                                       /* PS0351 */

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: Build_UID_Modifiers
 ******************************************************************
 * Description   : Generate UMT structures describing the required
 *                 modifications to the user's uid to match him with the
 *                 uidmask (either connect or disconnect).
 *
 * Input         : Update Type - Connect to Mask/ Disconnect from Mask
 *                 User UID - a UID String
 *                 Uid Mask - a UID Mask representing the required
 *                            modification.
 *                 allow_collision - Y / N
 *
 * Output        : UMT_Count - Number of Modifications
 *                 UMT       - Modification descriptions
 *
 * Return Value  : ESA_RC
 *                 ESA_OK    - successfull
 *                 ESA_ERR   - User UID dont match UID Mask
 *                 ESA_FATAL - Failure
 *
 * Remark: It is possible to have several UMTs related to the same
 *         field. Upper level code will resolve all these UMTs to
 *         a single field update.
 ******************************************************************/
static ESA_RC Build_UID_Modifiers(UID_Update_type Update_Type,
                                  UIDMASK UID_User_p,
                                  UIDMASK UID_Mask_p,
                                  int  *UMT_Count,
               /* WS10090 */      UID_Modifier_Transaction *UMT,
               /* WS10090 */      char allow_collision)
               /* WS10090         UID_Modifier_Transaction *UMT)  */
 {
  static char func[] = "Build_UID_Modifiers";

  UIDMASK UID_User, UID_Mask, ALL_Empty;

  ESA_RC rc = ESA_OK;
  int  i, i1, j = 0 , UM_Count , Compare_Len;
  char  *User_Begin, *Mask_Begin;

  char User_Comp[256]="";
  char Mask_Comp[256]="";

  UID_Modifier UM_Vec[ACF2_UID_SIZE];

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

  Reset_Field(ALL_Empty,sizeof(ALL_Empty),' ',NULL);
  Reset_Field(UID_User,sizeof(UID_User),'*',UID_User_p);
  Reset_Field(UID_Mask,sizeof(UID_Mask),'*',UID_Mask_p);
  (*UMT_Count) = 0;

  /*************************************************************
  * Break UID masks to Non-Asterisk components                 *
  **************************************************************/
  Break_UID_to_UID_Modifiers(UID_Mask,
                             &UM_Count,
                             UM_Vec);

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                  "UID Modifiers Count = %d",
                  UM_Count);

  /*************************************************************
  * Generate a Modification descriptor to each UM component    *
  * not crossing Field Boundaries.                             *
  **************************************************************/
  for (i=0; i LT UM_Count;i++)
   {
    ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                    "UID Modifiers[%d] = Offset(%d), length(%d)",
                    i,UM_Vec[i].UM_Offset,UM_Vec[i].UM_Length);

   /*************************************************************
   * Build UID Mask Modifier and User UID parallel component    *
   **************************************************************/
    User_Begin = UID_User + UM_Vec[i].UM_Offset;
    Mask_Begin = UID_Mask + UM_Vec[i].UM_Offset;
    Compare_Len  = UM_Vec[i].UM_Length;

    Reset_Field(User_Comp,sizeof(User_Comp),0X00,NULL);
    memcpy(User_Comp,User_Begin,Compare_Len);
    Reset_Field(Mask_Comp,sizeof(Mask_Comp),0X00,NULL);
    memcpy(Mask_Comp,Mask_Begin,Compare_Len);

   /*************************************************************
   * Convert modifier UID offset to UID Field Table Index       *
   **************************************************************/
    rc = Convert_UID_Offset_to_UIDtab_Index(UM_Vec[i].UM_Offset,
                        &j,
                        &(UMT[*UMT_Count].UMT_Field_Offset));

    if (rc NE ESA_OK)
     {
      rc = ESA_FATAL;
      goto exit;
     };

  /*************************************************************
  * For Connect Request:                                       *
  * If UID String contains ALL_EMPTY for the modification pos. *
  *    build a modifier transaction.                           *
  * For Disconnect Request:                                    *
  * If UID String contains ALL_EMPTY for the modification pos. *
  *    then UID is already in the target status, no            *
  *    modifcation is required.                                *
  **************************************************************/
    if (memcmp(User_Begin,ALL_Empty,Compare_Len) EQ 0)
     {
      if (Update_Type EQ Connect_Update)
       goto Build_UMT;
      else
       continue;
     };

  /*************************************************************
  * For Connect Request:                                       *
  * If UID String already matches modifier, no modification is *
  *    required.                                               *
  * For Disconnect Request:                                    *
  * If UID String matched modifier, generate modification      *
  *    transaction.                                            *
  **************************************************************/
    if (memcmp(User_Begin,Mask_Begin,Compare_Len) EQ 0)
     {
      ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
              "Matching UID Modifier detected, User(%s) Mask(%s)",
              User_Comp,Mask_Comp);
      if (Update_Type EQ Connect_Update)
       continue;
      else
       goto Build_UMT;
     };

  /*************************************************************
  * Check for Collision between the Mask and the UID string    *
  * (if there is a combination of blanks and non-blanks on the *
  *  UID string it is possible that the UID mask will match the*
  *  UID String).                                              *
  *                                                            *
  * Example: UID String A B                                    *
  *          UID MASK   ABB                                    *
  *          Modifier is *B* -> Change Field(ABB)              *
  **************************************************************/
  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,      /* WS10090 */
               "allow_collision = %c", allow_collision);  /* WS10090 */
  if (allow_collision NE 'Y')                             /* WS10090 */
  {                                                       /* WS10090 */
    for (i1=0;i1 LT Compare_Len;i1++)
     {
      if (User_Begin[i1] NE ALL_Empty[i1])
       if (User_Begin[i1] NE '*')                      /* PS0458 */
       if (User_Begin[i1] NE Mask_Begin[i1])
        goto Collision_Detected;
     };
  };                                                      /* WS10090 */

  /*************************************************************
  * Build UMT Transaction                                      *
  **************************************************************/
    Build_UMT:

    ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                    "Building UMT for field %s, Modifier(%s)",
                    UIDtab[j].UID_Part_Field_Name,Mask_Comp);

      /* Set UMT Field Name */

      strcpy(UMT[*UMT_Count].UMT_Field_Name,
             UIDtab[j].UID_Part_Field_Name);

      /* Set UMT Field Current Value at Modified Positions*/

      memset(UMT[*UMT_Count].UMT_Field_Value,0X00,ACF2_UID_SIZE);
      memcpy(UMT[*UMT_Count].UMT_Field_Value,User_Begin,Compare_Len);

      /* Set UMT Length*/

      UMT[*UMT_Count].UMT_Length = Compare_Len;

      /* Set UMT Modified Value */

      memset(UMT[*UMT_Count].UMT_New_Value,0X00,256);
      if (Update_Type EQ Connect_Update)
        memcpy(UMT[*UMT_Count].UMT_New_Value,Mask_Begin,Compare_Len);
      else
        memcpy(UMT[*UMT_Count].UMT_New_Value,ALL_Empty,Compare_Len);
      (*UMT_Count)++;
      continue;

  /*************************************************************
  * If Collision Detected return ESA_ERR indication            *
  **************************************************************/
    Collision_Detected:

      ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
              "Collision Detected, User(%s) Mask(%s)",
              UID_User,UID_Mask);
      rc = ESA_ERR;
      goto exit;

   };

  exit:

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

  return rc;
}

/******************************************************************
 * Procedure Name: Break_UID_to_UID_Modifiers
 ******************************************************************
 * Description   : Break the UID mask into non-asterisk components
 *                 considering UID fields boundaries.
 *
 * Example: UID Structure: A2,B3,C2
 *          UID String   : AABBBCC
 *          UID Mask is  : XX**YZ*
 *          UM Vec is    : XX, len=2
 *                       : Y, len=1
 *                       : Z, len=1
 *                       : Y and Z generates separate UMs because they
 *                         cross field boundaries.
 *
 * Input         : Uid Mask - a UID Mask representing the required
 *                            modification.
 *
 * Output        : modcnt    - Modifiers count
 *                 UM        - Modifiers Vector
 *
 * Return Value  : None
 ******************************************************************/
static void Break_UID_to_UID_Modifiers(UIDMASK   UID,
                                       int       *modcnt,
                                       UID_Modifier moduid[1])
 {
  static char func[] = "Break_UID_to_UID_Modifiers";

  int  Part_Length, UID_Loc, i;
  char *UID_ptr1 = NULL;
  char *UID_ptr2 = NULL;
  char *UID_EOS  = NULL;
  UIDMASK UID_part = "";
  int  accum_uid_offset = 0;
  int  first_multi;                                       /* PS0351 */

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);


  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, "UID: %s", UID);

  (*modcnt) = 0;

  first_multi = TRUE;                                     /* PS0351 */

  /*************************************************************
  * Scan UID Mask for Modifiers                                *
  **************************************************************/
  for(i=0;i LT UID_Field_Count;i++)
   {
    /*************************************************************
    * PS0351 - Perform following check ONLY if UID is MULTIVALUE *
    **************************************************************/
    if (UID_Is_MULTI EQ 'Y')
    {
      /***********************************************************
      * If current multivalued field is the first one, skip it!  *
      * (if this is the first multivalued field, it's the only   *
      *  REAL multivalued field in the UID. Handle it later..)   *
      ************************************************************/
      if ( (UIDtab[i].UID_Part_Multi EQ 'Y') AND (first_multi) )
      {
        first_multi = FALSE;
        accum_uid_offset += UIDtab[i].UID_Part_Length;
        continue;
      };
    };

    /*************************************************************
    * Copy mask component parallel with specific UID component   *
    **************************************************************/
    Reset_Field(UID_part,sizeof(UIDMASK),0X00,NULL);
    memcpy     (UID_part,UID+UIDtab[i].UID_Part_Offset,
                UIDtab[i].UID_Part_Length);

    ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                    "UID part(%s)", UID_part);

    UID_ptr1= UID_part;
    UID_EOS = UID_ptr1 + strlen(UID_part);

    /*************************************************************
    * For this UID component generate all modifiers:             *
    * if the mask UID component is A*B, then 2 modifiers are     *
    * created (A and B).                                         *
    **************************************************************/
    do
     {
      UID_Loc = strspn(UID_ptr1,"*");

      UID_ptr1 += UID_Loc;
      UID_ptr2 = strpbrk(UID_ptr1,"*");

      ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                      "UID ptr1 %X  UID ptr2 %X",UID_ptr1,UID_ptr2);

    /*************************************************************
    * Between beginning of UID part and first asterisk or 2 aster*
    * -isks or an asterisk and the End-Of-String, lies a modifier*
    **************************************************************/
      if (UID_ptr2 EQ NULL)
       Part_Length = UID_EOS - UID_ptr1;
      else
       Part_Length = UID_ptr2 - UID_ptr1;

      if (Part_Length EQ 0)
       break;

      ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                    "UID Modifier(%d): UID offset %d, len %d",
                    (*modcnt),
                    UID_ptr1-UID_part+accum_uid_offset,
                    Part_Length);

    /*************************************************************
    * Build a modifier: String, UID Offset & Length              *
    **************************************************************/
      moduid[*modcnt].UM_Offset = UID_ptr1 - UID_part +accum_uid_offset;
      moduid[*modcnt].UM_Length = Part_Length;
      (*modcnt)++;

      UID_ptr1 = UID_ptr2;
     } while(UID_ptr2 NE NULL);
     accum_uid_offset += strlen(UID_part);
  };

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, ESA_OK);

 }

/******************************************************************
 * Procedure Name: Convert_UID_Offset_to_UIDtab_Index
 ******************************************************************
 * Description   : Convert a UID offset (0 to 23) to UIDtab entry
 *                 that describes the UID component.
 *
 * Input         : Uid offset - UID Offset to convert
 *
 * Output        : index        - UIDtab Index
 *                 field_offset - If uid offset dont fall on field
 *                                boundary, state offset from begin
 *                                of field.
 * Return Value  : None
 ******************************************************************/
static ESA_RC Convert_UID_Offset_to_UIDtab_Index(int   uid_offset,
                                               int   *index,
                                               int   *field_offset)
 {
  static char func[] = "Convert_UID_Offset_to_UIDtab_Index";

  ESA_RC rc = ESA_OK;

  int i;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

  for (i=0;i LT UID_Field_Count;i++)
   {
    if ( (uid_offset GE UIDtab[i].UID_Part_Offset) AND
         (uid_offset LT UIDtab[i].UID_Part_Offset +
                        UIDtab[i].UID_Part_Length) )
      {
        (*index) = i;
        (*field_offset) = UIDtab[i].UID_Field_Offset +
                          (uid_offset - UIDtab[i].UID_Part_Offset);
        goto exit;
      };
   };

  rc = ESA_ERR;

  exit:;

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                  "UIDTAB[%d] is connected to UID offset %d",
                  *index,uid_offset);
  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);
  return rc;
}

/******************************************************************
 * Procedure Name: Convert_UID_Offset_to_Field_Name
 ******************************************************************
 * Description   : Convert a UID offset (0 to 23) to UID Component
 *                 field name.                     .
 *
 * Input         : Uid offset - UID Offset to convert
 *
 * Output        : field_name   - UID component field name
 *                 field_offset - If uid offset dont fall on field
 *                                boundary, state offset from begin
 *                                of field.
 * Return Value  : None
 ******************************************************************/
ESA_RC Convert_UID_Offset_to_Field_Name  (int   uid_offset,
                                          char  *field_name,
                                          int   *field_offset)
 {
  static char func[] = "Convert_UID_Offset_to_Field_Name";

  ESA_RC rc = ESA_OK;

  int i;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

  rc = Convert_UID_Offset_to_UIDtab_Index(uid_offset,     /* IS10088 */
                                     &i,
                                     field_offset);

  if (rc EQ ESA_OK)                                       /* IS10088 */
    strcpy(field_name,UIDtab[i].UID_Part_Field_Name);

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);
  /* IS10088   return ESA_OK;          */
  return rc;                                              /* IS10088 */
}

/* PS0345 - New function */
/******************************************************************
 * Procedure Name: ACF2_Is_Part_Of_Multi
 ******************************************************************
 * Description   : Check if UID offset is part of MULTIVALUED field.
 *                 If it is, return some field info.
 *
 * Input         : Uid offset - UID Offset to check
 *
 * Output        : mvf_name     - UID component field name
 *                 mvf_offs     - field start offset in UID
 *                 mvs_len      - field length
 *
 * Return Value  : TRUE  - offset is part of MULTIVALUED field
 *                 FALSE - offset is not part of MULTIVALUED field
 ******************************************************************/
int ACF2_Is_Part_Of_Multi (int   uid_offset,
                           char *mvf_name,
                           int  *mvf_offs,
                           int  *mvf_len)
 {
  static char func[] = "ACF2_Is_Part_Of_Multi";

  ESA_RC       rc = ESA_OK;
  int          field_is_multi = FALSE;
  int          field_offset;
  int          i;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

  strcpy (mvf_name,"");
  *mvf_offs = 0;
  *mvf_len = 0;

  rc = Convert_UID_Offset_to_UIDtab_Index(uid_offset,
                                          &i,
                                          &field_offset);

  if (rc NE ESA_OK)
    goto exit;

  if (UIDtab[i].UID_Part_Multi EQ 'Y')
  {
    field_is_multi = TRUE;
    strcpy (mvf_name, UIDtab[i].UID_Part_Field_Name);
    *mvf_offs = UIDtab[i].UID_Part_Offset;
    *mvf_len = UIDtab[i].UID_Part_Length;
  };

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2,
                DEBUG_SHOW_REGULAR,
                func,
                field_is_multi);

  return field_is_multi;
}
/* PS0345 - End */

/******************************************************************
 * Procedure Name: Calc_User_UID_String
 ******************************************************************
 * Description   : based on the UID strcuture definition, and the
 *                 user's ACF2 record fields (ADDINFO), generate its
 *                 uid string. For missing fields, use filler char.
 *
 *     PS0354      If there is no Multivalued field in UID, we return
 *     PS0354      the single calculated UID in the UID parameter.
 *     PS0354
 *     PS0354      If there is Multivalued field in UID, we ALWAYS
 *     PS0354      return the result in the UIDs_List parameter.
 *     PS0354      No matter if the change was made to the MVF only,
 *     PS0354      to the non-MVF only, if the change removed all
 *     PS0354      MVF values etc.
 *
 *
 * Input         : user_lid   - Lid of User to check     PS0354
 *                 ADDINFO    - User ACF2 record field values
 *                 Init_UID_CHar - Filler for missing UID fields
 *
 * Output        : UID        - Resulting UID String
 * Return Value  : ESA_OK or ESA_FATAL
 ******************************************************************/
ESA_RC Calc_User_UID_String(USER_typ user_lid,            /* PS0354 */
                            ADDINFO_rec_ptr addinfo,
                            UIDMASK UID,
                            char   *UIDs_List,            /* PS0354 */
                            char    Init_UID_Char,
      /* bs2556 */          ADMIN_PARAMS_rec_typ * admin_params)
{
 static char func[] = "Calc_User_UID_String";

 ESA_RC            rc = ESA_OK;                           /* PS0354 */
 ACF2_API_Return_Codes ACF2_rc = ACF2_OK;                 /* PS0354 */
 int               i, uidloc = 0;
 int               j;                                     /* PS0354 */
 int               multi_field_offset=0;                  /* PS0354 */
 int               check_for_multi;                       /* PS0354 */
 int               Num_UIDs;                              /* PS0354 */
 ADDINFO_rec_ptr   faddinfo = NULL;                       /* PS0354 */
 ONE_FIELD_rec_ptr pair;
 UIDMASK           UID_NOT_CHANGED;                       /* PS0354 */
 UIDMASK           user_UID;                              /* PS0354 */
 char              Curr_UIDs_List[9600]="";               /* PS0354 */
 char              UID_part[256]="";
 char              multi_field_name[20]="";               /* PS0354 */
 char              current_user[ACF2_LID_SIZE]="";        /* PS0354 */

 ESA_DIAG_enter(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR, func);

 strcpy (UIDs_List,"");                                   /* PS0354 */

 check_for_multi = UID_Contains_MULTI (multi_field_name,
                                       &multi_field_offset);
                                                          /* PS0354 */

 if (check_for_multi)                                     /* PS0354 */
 {                                                        /* PS0354 */
   if (ADDINFO_alloc(func,                                /* PS0354 */
                     ACF2_ADDINFO,                        /* PS0354 */
                     &faddinfo, NULL, NULL) NE ESA_OK)    /* PS0354 */
   {                                                      /* PS0354 */
     rc = ESA_FATAL;                                      /* PS0354 */
     goto exit;                                           /* PS0354 */
   };                                                     /* PS0354 */
 };                                                       /* PS0354 */

 Reset_Field(UID,ACF2_UID_SIZE,Init_UID_Char,NULL);

 strcpy (UID_NOT_CHANGED, UID);                           /* PS0354 */

 /******************************************************************
 * Calculate modifications for non-MVF only!                       *
 * If only MVF was updated - result will be full mask UID!         *
 *******************************************************************/
 for (i=0;i LT UID_Field_Count;i++)
  {
    /* PS0354 - Skip REAL Multivalued field */
    if (check_for_multi)                                  /* PS0354 */
      if (strcmp (multi_field_name,                       /* PS0354 */
                  UIDtab[i].UID_Part_Field_Name) EQ 0)    /* PS0354 */
      {                                                   /* PS0354 */
        ESA_DIAG_printf(ESA_COMP_UPDUSER,                 /* PS0354 */
                        DEBUG_SHOW_IMPORTANT,             /* PS0354 */
                        "Currently skip MVF(%s)",         /* PS0354 */
                        multi_field_name);                /* PS0354 */
        uidloc += UIDtab[i].UID_Part_Length;              /* PS0354 */
        continue;                                         /* PS0354 */
      };                                                  /* PS0354 */

    pair = ADDINFO_search(UIDtab[i].UID_Part_Field_Name,
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);
    if (pair NE NULL)
    {
      Reset_Field(UID_part,256,' ',pair->value);
      memcpy(UID + uidloc,UID_part + UIDtab[i].UID_Field_Offset,
             UIDtab[i].UID_Part_Length);
    };
    uidloc += UIDtab[i].UID_Part_Length;
  };

  ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT,
                  "Calculated UID string(without MVF): (%s)",
                  UID);

  /* Start of PS0354 */
  if (check_for_multi)
  {
    /***************************************************************
    * Do we have MVF field in ESS ADDINFO ?                        *
    * If NO, then there are two possible scenarios:                *
    * 1. Only non-MVF fields were changed                          *
    * 2. No UID fields were changed at all                         *
    *                                                              *
    * In any case, build UIDs_List from User Record,               *
    * then make the required changes                               *
    ****************************************************************/
    pair = ADDINFO_search(multi_field_name,
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

    if (pair EQ NULL)
    {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT,
                      "No MVF change found");

      Build_Multi_UIDs (user_lid,
                        multi_field_name,
                        multi_field_offset,
                        NULL,      /* NULL = build from Database */
                        &Num_UIDs,
                        UIDs_List,
                        admin_params);                /*bs2556*/

      /*************************************************************
      * If no change occured in UID fields, leave UIDs_List as is. *
      * Otherwise, copy non-'*' chars from UID, to all UIDs in     *
      * UIDs_List                                                  *
      **************************************************************/
      if (strcmp (UID, UID_NOT_CHANGED) NE 0)
      {
        for (i=0; i LT ACF2_UID_SIZE-1;i++)
        {
          if (UID[i] NE '*')
            for (j=0; j LT Num_UIDs; j++)
              UIDs_List[(j*ACF2_UID_SIZE)+i] = UID[i];
        };
      };
    }
    else
    {
      /***************************************************************
      * MVF has changed!                                             *
      * Possible scenarios:                                          *
      * 1. Only MVF has changed                                      *
      * 2. Both MVF and non-MVF has changed                          *
      *                                                              *
      * Input to Build_Multi_UIDs is:                                *
      * 1. Calculated User UID, NOT including multivalued field      *
      * 2. Multivalued field values, as received from ESS            *
      ****************************************************************/
      ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT,
                      "MVF change was found!");

      ADDINFO_insert(TYPE_1A,
                     "UID",
                     UID,
                     faddinfo,
                     ACF_ADDINFO_KWD_LEN,
                     ACF_ADDINFO_VAL_LEN,
                     UNIQUE);

      ADDINFO_copy_by_prefix (multi_field_name,
                              ACF_ADDINFO_KWD_LEN,
                              ACF_ADDINFO_VAL_LEN,
                              FALSE,
                              addinfo,
                              faddinfo);

      /***************************************************************
      * Next step:                                                   *
      * replace all '*' in UIDs_List with current user UID values    *
      * '*' are all the chars that were not changed.                 *
      * This will complete the image of the modified UIDs            *
      ****************************************************************/
      Build_Multi_UIDs (user_lid,
                        multi_field_name,
                        multi_field_offset,
                        faddinfo,
                        &Num_UIDs,
                        UIDs_List,
                        admin_params);                /*bs2556*/

      ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT,
                      "Num UIDS(%d) List(%d,%s)",
                      Num_UIDs, strlen(UIDs_List), UIDs_List);

      if (strlen(UIDs_List) LT (sizeof(UIDMASK)-1))
      {
        rc = ESA_FATAL;
        goto exit;
      };

      ADDINFO_empty(faddinfo);

      Reset_Field(user_UID,
                  sizeof(UIDMASK),
                  0X00,
                  NULL);

      Reset_Field(user_UID,
                  (sizeof(UIDMASK)-1),
                  ' ',
                  NULL);

      ACF2_rc = ACF2_Get_User_UID(user_lid,
                                  user_UID,
                                  current_user,
                                  "",
                                  Curr_UIDs_List,
                                  faddinfo,
                                  admin_params);      /*bs2556*/
      if (ACF2_rc NE ACF2_OK)
      {
        rc = ESA_FATAL;
        goto exit;
      };

      for (i=0; i LT ACF2_UID_SIZE-1;i++)
      {
        if (UIDs_List[i] EQ '*')
        {
          for (j=0; j LT Num_UIDs; j++)
          {
            if (user_UID[i] NE NULL_CHAR)
              UIDs_List[(j*ACF2_UID_SIZE)+i] = user_UID[i];
            else
              UIDs_List[(j*ACF2_UID_SIZE)+i] = ' ';
          };
        };
      };
    };

    ESA_DIAG_printf(ESA_COMP_UPDUSER,
                    DEBUG_SHOW_IMPORTANT,
                    "Calculated UIDs: (%s)",
                    UIDs_List);
  };

 exit:;

 if (faddinfo NE NULL)                                    /* PS0354 */
  ADDINFO_free(&faddinfo);                                /* PS0354 */

 ESA_DIAG_exit(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR, func, rc);

 return rc;                                               /* PS0354 */
}

/* PS0351 - New function */
/******************************************************************
 * Procedure Name: Generate_Multi_Update
 ******************************************************************
 * Description   : Generate an ADDINFO object that can be executed
 *                 against a User's record to modify its UID fields
 *
 * Input         : Update Type - Connect to Mask/ Disconnect from Mask
 *                 User UID - a UID String
 *                 Uid Mask - a UID Mask representing the required
 *                            modification.
 *                 uaddinfo - Original User field values
 *
 * Output        : laddinfo - Update ADDINFO
 *
 * Return Value  : ESA_RC
 *                 ESA_OK    - Update ADDINFO generated
 *                 ESA_ERR   - User UID dont match UID Mask
 *                 ESA_FATAL - Failure
 ******************************************************************/
static ESA_RC Generate_Multi_Update(UID_Update_type Update_Type,
                                    UIDMASK UID_User,
                                    UIDMASK UID_Mask,
                                    ADDINFO_rec_ptr uaddinfo,
                                    ADDINFO_rec_ptr laddinfo)
{
 static char func[] = "Generate_Multi_Update";

 ESA_RC rc = ESA_OK;

 ONE_FIELD_rec_ptr pair;
 UIDMASK           ALL_Mask;
 char              temp_values[9600]="";
 char              temp_values2[9600]="";
 char              new_value[256]="";
 char              curr_value[256]="";
 char              multi_field_name[20]="";
 char              entry_sep[2];
 char             *field_ptr;
 char              field_type;
 char              field_rw;
 char              field_multi;
 int               field_length = 0;
 int               field_mvmax = 0;
 int               multi_field_offset=0;
 int               multi_field_len=0;
 int               field_offset;
 int               compare_len;
 int               num_values;
 int               delete_value;
 int               i;

 ESA_DIAG_enter(ESA_COMP_ADDU2UG, DEBUG_SHOW_REGULAR, func);

 entry_sep[0] = ADDINFO_LIST_ENTRY;
 entry_sep[1] = NULL_CHAR;

 Reset_Field(ALL_Mask,sizeof(ALL_Mask),'*',NULL);

 /****************************************************************
 * If no multivalue field, exit function                         *
 *****************************************************************/
 if (NOT UID_Contains_MULTI (multi_field_name,
                             &multi_field_offset))
   goto exit;

 /****************************************************************
 * Convert multivalued field offset to index in UIDtab           *
 *****************************************************************/
 rc = Convert_UID_Offset_to_UIDtab_Index(multi_field_offset,
                                         &i,
                                         &field_offset);

 if (rc NE ESA_OK)
 {
   rc = ESA_FATAL;
   goto exit;
 };

 multi_field_len = UIDtab[i].UID_Part_Length;

 /****************************************************************
 * Obtain value of multivalued field from group's UID Mask       *
 *****************************************************************/
 memcpy (new_value, UID_Mask+multi_field_offset, multi_field_len);

 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "Multi field name(%s) offs(%d) len(%d) newval(%s)",
                 multi_field_name,
                 multi_field_offset,
                 multi_field_len,
                 new_value);

 compare_len = strlen (new_value);

 num_values = 0;

 /****************************************************************
 * If value in UID Mask is all asterik (full mask) - exit        *
 *****************************************************************/
 if (memcmp(new_value,ALL_Mask,compare_len) EQ 0)
   goto exit;

 /****************************************************************
 * Obtain all values of multivalued field from user's record     *
 *****************************************************************/
 pair = ADDINFO_search(multi_field_name,
                       ACF_ADDINFO_KWD_LEN,
                       uaddinfo->pair,
                       uaddinfo->num_pairs);

 /****************************************************************
 * If no value in user's multivalue field:                       *
 * Connect    : add value                                        *
 * Disconnect : exit                                             *
 *****************************************************************/
 if (pair EQ NULL)
   if (Update_Type EQ Connect_Update)
     goto add_value;
   else
     goto exit;

 strcpy (temp_values, pair->value);

 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "User field values(%s)",
                 temp_values);

 strcpy (temp_values2,"");
 delete_value = FALSE;

 field_ptr = strtok (temp_values, entry_sep);

 /****************************************************************
 * At least one value exists - check all values for match        *
 *****************************************************************/
 while (field_ptr NE NULL)
 {
   num_values++;

   Reset_Field(curr_value, sizeof(curr_value), 0X00, NULL);
   Reset_Field(curr_value, compare_len, ' ', field_ptr);

   ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                   "Compare userval(%s,%d) and newval(%s,%d)",
                   curr_value,
                   strlen(curr_value),
                   new_value,
                   strlen(new_value));

   /**************************************************************
   * If new value found in user's multivalue field:              *
   * Connect    : exit (connection already exists..)             *
   * Disconnect : delete value                                   *
   ***************************************************************/
   if (memcmp (curr_value, new_value, compare_len) EQ 0)
   {
     if (Update_Type EQ Connect_Update)
       goto exit;
     else
     {
       delete_value = TRUE;
       field_ptr = strtok (NULL,entry_sep);

       /**********************************************************
       * Remove entry separator from previous entry              *
       ***********************************************************/
       if ( (field_ptr EQ NULL) AND (strlen(temp_values2) NE 0) )
         temp_values2[(strlen(temp_values2)-1)]=NULL_CHAR;

       continue;
     };
   };

   strcat (temp_values2, curr_value);

   field_ptr = strtok (NULL, entry_sep);

   if (field_ptr NE NULL)
     strcat (temp_values2, entry_sep);
 };

 if (delete_value)
   goto del_value;

 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "Value NOT found in user multivalue field");

 /****************************************************************
 * Value NOT found in user's multivalue field:                   *
 * Connect    : add value                                        *
 * Disconnect : exit                                             *
 *****************************************************************/
 if (Update_Type EQ Connect_Update)
   goto add_value;
 else
   goto exit;

 add_value:;
 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "ADD new value to user");

 /*************************************************************
 * Check if we reached maximum allowed number of values       *
 **************************************************************/
 rc = ACF2_Get_Field_Information(multi_field_name,
                            &field_type,
                            &field_rw,
                            &field_length,
                            &field_offset,
                            &field_multi,
                            &field_mvmax);

 if (rc NE ESA_OK)
 {
   rc = ESA_FATAL;
   goto exit;
 };

 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "maxval(%d) numval(%d)",
                 field_mvmax, num_values);

 /* For now - skip this check...
 if (num_values GE field_mvmax)
 {
   rc = ESA_FATAL;
   goto exit;
 };
 */

 /*************************************************************
 * Prepare new list of values                                 *
 **************************************************************/
 strcpy (temp_values2,"");

 if (pair EQ NULL)
   strcpy (temp_values2, new_value);
 else
 {
   /***********************************************************
   * Copy existing user values and add new value              *
   ************************************************************/
   strcpy (temp_values2, pair->value);
   strcat (temp_values2, entry_sep);
   strcat (temp_values2, new_value);
 };

 goto insert_keyword;

 del_value:;
 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "DELETE existing value from user");

 goto insert_keyword;

 insert_keyword:;
 ESA_DIAG_printf(ESA_COMP_ADDU2UG, DEBUG_SHOW_IMPORTANT,
                 "Values list (%s)", temp_values2);

 ADDINFO_insert(TYPE_1A,
                multi_field_name,
                temp_values2,
                laddinfo,
                ACF_ADDINFO_KWD_LEN,
                ACF_ADDINFO_VAL_LEN,
                UNIQUE);

 exit:;

 ESA_DIAG_exit(ESA_COMP_ADDU2UG, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}
/* End of PS0351 */

