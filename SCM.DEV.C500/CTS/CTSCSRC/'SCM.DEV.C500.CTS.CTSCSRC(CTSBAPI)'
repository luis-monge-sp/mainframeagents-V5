/**************************************************************
*                                                             *
* Title            : ACF2 API and other Low-Level functions   *
*                                                             *
* File Name        : ctsbapi.c                                *
*                                                             *
* Author           : Yishay Yovel                             *
*                                                             *
* Creation Date    : 04/06/97                                 *
*                                                             *
* Description      : This source includes a set of low-level  *
*                    access routines to ACF2 Databases,       *
*                    Conversion Routines.                     *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------- -------------------------------- *
* PS0321   Guy      26/10/98 Added UIDX field (MULTI VALUE)   *
* WS2338   Guy      10/11/98 Group support of MUL.VALUE fields*
* PS0338   Guy      25/11/98 Added some debug messages        *
* PS0339   Guy      26/11/98 Return connections of all user   *
*                            UIDs if MULTI VALUED             *
* PS0354   Guy      09/12/98 Check Disconnect from Multivalued*
*                            field                            *
* PS0364   Guy      24/12/98 Remove EMULATE stuff             *
* ws2431   Michael  22/11/01 Send connection updates for ACF2 *
* bs2499   Yoni     28/11/01 abend S0C4 in get connections    *
* ws2370   RamiK    01/12/01 add support for specific user    *
*                            profiles                         *
* BS2513   RamiK    17/03/01 added ACF2_User_Exists func      *
* BS2556   AvnerL   14/10/02 send acf2 original error msg     *
* BS2586   AvnerL   16/02/03 fix BS2556.                      *
* IS0071   AvnerL   26/04/05 add diags for lid retieval.      *
* IS0371   Eli MY   04/10/06 Fix call to ESA_DIAG_printf      *
*                            when only string printed         *
* WS2565   Eli MY   19/10/06 Support keywords: PSWDPAIR,      *
*                            PSWDPLST, PSWXHST# + BS2716(from *
*                            ACF2 v3102)                      *
* WS10005  AvnerL   17/07/07 Add diags & recompile UP_kdts.   *
* WS10006  AvnerL   05/08/07 Compile UP_kdts & convert # to @.*
* IS10119  AvnerL   30/03/14 GetRSSParms fails                *
* BS10049  AVNERL   30/05/16 UID WITH BLANK BUG FOR KPMG      *
* SAS2IBMT SeligT   09/10/16 SAS/C to IBM C Conversion Project*
* IS10147A SeligT   18/06/17 Add support for password phrase  *
* BS10070  SeligT   23/10/17 ABEND S0C4 during aggregation    *
*                            when user not authorized         *
* BS10072  SeligT   24/10/17 Improve previous fix - allow for *
*                            smaller message area in call to  *
*                            macro                            *
* WS10075  NuritY   21/11/19 Support permissions              *
* WS10076S SeligT   19/12/19 Manage Permissions as Account    *
*                            and Group Attributes - Phase 2   *
* WS10076N NuritY   31/12/19  ---  "  ---                     *
* WS10076A AvnerL   19/01/20 Add admin_params 2 ACF2_Get_Group*
* WS10078A AvnerL   15/04/20 fix diags                        *
*WS10078KM KailasP  06/06/20 Add isIncomplete attribute in    *
*                            addinfo if truncated             *
* BS10111  NuritY   03/01/21 Move some diags                  *
* WS10079  ThomaS   13/01/21 JPMC Phase2 - move ACF2_Get_Xref *
*                            here and make some changes in it *
* BS10120  AvnerL   03/01/22 Add diags to user profile records*
* WS10084  ThomaS   13/07/23  Replace ACFRPTRX                *
* BS10134  AvnerL   18/02/24 S0C4 when Sources aggregation    *
* WS10082N NuritY   03/12/23 Fix a storage leak issue.        *
**************************************************************/

 /*
  *   Standard include files
  */

 #define _ISOC99_SOURCE                                   /* WS10079N*/
 #include   <globs.h>
 #include   STDIO
 #include   STDLIB
 #include   STRING
 #include   CTYPE
 #include   FCNTL

 #include <ctest.h>                                      /* WS10084 */
 /*
  *   ESA include files
  */

 #include   ESA_API
 #include   ESA_DIAG
 /*WS10076A #include   ESA_INIT                          * WS10076S */
 #include   ESA_CTSAMSG
 #include   ESA_API_CODES

 #include   MVS_OS_CLI
 #include   MVS_OS_MVS
 #include   MVS_COMP
 /* WS10076N - moved to CTSBPHR
 #include   MVS_CODES                                    /@ WS10075 @/
 */

 #include   API_ADDINFO
 #include   API_DATES
 #include   ACF2_CODES
 #include   ACF2

 /* WS10079N static char component[]="GTUSERS";  */
 static char component[]="CTSBAPI";                       /* WS10079N */


 /* SAS2IBMT prototype changed for IBM C
 void cts2alt(char *lid,
              char *uidmask,
              char *returned_user,
              char *ALT_Get_Fields,
              int  *API_Fields_Count,
              char *API_Fields,
              int  *buffer_length,
              char *buffer,
              int  *rc,
              char *errmsg);                                         */
 void cts2alt();                                          /* SAS2IBMT */

 /* SAS2IBMT prototype changed for IBM C
 void ctsacvd(int     *,
              int     *,
              int     *,
              char    *,
              char    *);                                            */
 void ctsacvd();                                          /* SAS2IBMT */

 /* SAS2IBMT prototype changed for IBM C
 void cts2ntr(ACF2_INF_record *infrec,
              ACF2_INF_record *current_infrec,
              char *lid,
              char *tod,
              int  *buffer_length,
              char *buffer,
              int  *rc,
              char *errmsg);                                         */
 void cts2ntr();                                          /* SAS2IBMT */

 /* SAS2IBMT prototype changed for IBM C
 void cts2sys(char *ACF2_sysid,
              int  *rc);                                             */
 void cts2sys();                                          /* SAS2IBMT */

 /* WS10076N- moved to CTSBPHR
 /@  WS10075 - start @/
 extern  int ctsaldm();
 extern  int ctsadlm();
 /@  WS10075 - end  @/
 */

 static ACF2_API_Return_Codes
         ACF2_Get_INFRec(ACF2_INF_record *record,
                         ACF2_INF_record *current_record,
                         ADDINFO_rec_ptr laddinfo,
                         char       *errmsg);

 static ACF2_API_Return_Codes
        ACF2_Get_INF( ACF2_INF_record *record,
                      ACF2_INF_record *current_record,
                      ACF2_INF_Match match,
                      ADDINFO_rec_ptr laddinfo,
                      char *errmsg);

 static void Create_InfRec_Id(ACF2_INF_record *InfRec,
                        char      *class,
                        char      *type,
                        ACF2_Object_Mask sysid_masked,
                        char      *sysid,
                        ACF2_Object_Mask recid_masked,
                        char      *recid);

 static int  Check_Best_Match(char *Best_Sysid,char *Current_Sysid);
 static void Get_SYSID_Component(ACF2_INF_record *record,char *sysid);
 static void Get_RECID_Component(ACF2_INF_record *record,char *recid);

 static void Process_AREs(ARE_typ *are_ptr,
                         char    *prefix,
                         ADDINFO_rec_ptr addinfo);

 static int sysid_is_profile(char               *sysid,
                             ESA_DIAG_COMP_typ  comp);
 static ACF2_API_Return_Codes ACF2_Get_specific_user_profile
                                          (char              *recname,
                                           char              *sysid,
                                           ADDINFO_rec_ptr   laddinfo,
                                           ESA_DIAG_COMP_typ comp,
                                           int               pass_rc,
                                           char              *errmsg);
 static void convert_bit_to_char(char *,char *);
 static void convert_binary_to_char(char *,char *);
 static void convert_date_to_YYYYMMDD(char *,char *);
 static void convert_time_to_HHMMSS(char *,char *);
 static void convert_hex_to_char(char *,int,char *);
 static void convert_encr_to_char(char *,int,char *);
 static void convert_multi_to_char(char *,char *);
 static void convert_multi_bin_to_char(char *,char *);
 static void convert_2Bmulti_to_char(char *,char *);

 static int debug = 0;
 /* WS10079K - ACF2_Get_Xrf handle.  Moved here from CTSBSRV WS10079T */
 typedef struct {
    LID_PERM_handle_rec_typ     * lid_perm_handle;
    PBhandle_typ                * PBhandle;
    char                          out_ActiveYN;
    char                          out_xref_recYN;
    char                          recparm[19];
    } ACF2_Get_Xref_Handle;
 /* WS10079K - End */

 /* WS10076N - moved to CTSBPHR
 /@  WS10075 - start @/
 static  void  GLR_RXE_message(CTS2RX_error_block_rec_typ  * rxe,
                               ADMIN_PARAMS_rec_typ   * admin_params);

 static  void  GLR_free_all(LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                            int                          LRA_vec_num,
                            ADMIN_PARAMS_rec_typ       * admin_params);

 static void GLR_print_ACFRPTRX_output(
                             LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                             int                          LRA_vec_num,
                             ADMIN_PARAMS_rec_typ       * admin_params);

 #define RULE_TYPE_NUM 2

 typedef struct _parm_data {
      char      rule_type[5];
      char      rule_parm[10];
     } RULE_PARM_typ,  * RULE_PARM_ptr;

 static RULE_PARM_typ  rule_parm_data[RULE_TYPE_NUM] =
           {  "DSET", "" ,
              "RSRC", ",TYPE(***)" };

 typedef  struct _parm {
      short   parm_len;
      char    parm[30];
     } rptrx_parm_type,  * rptrx_parm_ptr;

 static  ASM_RTN_TYP * p_ctsaatc = NULL;
 static  ASM_RTN_TYP * p_cts2rxf = NULL;
/@
 *    ignore list for CTS2RXO
 *
 *    the "full" field indicates whether we should ignore a line
 *    containing a specific character only (for example, a line
 *    containing only blanks).
 *    when this is required, len is 1, full is x'ff' and data
 *    contains the character repeated in the line.
 *
 *    the last line of the beable contains len=0.
 @/
 #pragma pack(packed)

 typedef struct _ignlst {
   unsigned char  len;       /@ text length                           @/
   unsigned char  full;      /@ whether the text (1 char) is all line @/
   unsigned char  data[133]; /@ text length                           @/
   } ACRPTRX_output_ignlst_typ;

 #pragma pack(reset)

 static ACRPTRX_output_ignlst_typ ACFRPTRX_output_ignore_list[] = {
               44, 0, "CA ACF2 - ACFRPTRX - LOGONID ACCESS REPORT -",
               5,  0, "DATE ",
               18, 0, "INPUT PARAMETERS: ",
               30, 0, "LID FILE PROCESSING COMPLETE, ",
               31, 0, "RULE FILE PROCESSING COMPLETE, ",
               8,  0, "STORED: ",
               1,  0xFF, " ",
               0,  0,  " ",
              } ;

#define  RESETRXE(rxe)                                          \
  rxe.rxeerror = 0;                                             \
  rxe.rxepgm[0] = NULL_CHAR;                                    \
  rxe.rxefunc[0] = NULL_CHAR;                                   \
  rxe.rxemsg[0] = NULL_CHAR;                                    \
  rxe.rxedline[0] = NULL_CHAR;                                  \
  rxe.rxeline_ = 0;

 /@  WS10075 - end  @/
/* WS10076N - end */

/******************************************************************
 * Procedure Name: ACF2_Get_User
 ******************************************************************
 * Description   : This function is the High-Level interface used by
 *                 the API to access ACF2 Logonid Database.
 *
 *                 The function supports Get_Next logic by the current
 *                 user field (if Null, get first user matching user key
 *                 else read the user following the current_user).
 *
 * Input         : lidmask    - User id or User id mask
 *                 lid_masked - An inidcation if lidmask is a mask
 *                              (i.e, userid prefix)
 *                 uidmask    - A filtering criteria users matching both
 *                              lidmask and uidmask will be returned.
 *                 get_fields - Indicate if fields are to be retrieved
 *                 required_fields - list of comma separated field names
 *                                   to be retrieved for the user (used
 *                                   for UID only retrievals).
 *                 mode       - Indicates if multi UIDs are to be
 *                              retrieved
 *
 * Input/Output  : current_lid - Input:get next matching user after this
 *                               Output: current user after operation
 *
 * Output        : laddinfo    - ACF2 Retrieved fields
 *                 errmsg      - error message description
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - User retrieved ok
 *                 ACF2_Not_Found      - No user found matching criteria
 *                 ACF2_Internal_Error - Error in ACF2 processing
 *********************************************************************/
 ACF2_API_Return_Codes ACF2_Get_User (char     *lidmask,
                                      ACF2_Object_Mask lid_masked,
                                      char     *uidmask,
                                      char     *current_lid,
                                      ACF2_GetUser_Fields Get_Fields,
                                      char     *Required_Fields,
                                      ADDINFO_rec_ptr laddinfo,
       /* PS0321 */                   ACF2_Multi_UIDs_Mode_Type mode,
                                      char     *errmsg,
       /* bs2556 */                ADMIN_PARAMS_rec_typ * admin_params)

 {
 /*************************************************************
 * Varaibles                                                  *
 **************************************************************/
   static         char func[]="ACF2_Get_User";

   char           buffer[ACF2_ARE_BUFFER_LENGTH] = "";

   ESA_RC         rc0 = ESA_OK;
   int            rc1 = 0;
   /* BS10070 The following declaration was too small and had to be
              declared larger. Reason: When cts2alt returns with a bad
              return code, errmsg (124 bytes) is concatenated (via
              sprintf) into errmsg1 (128 bytes) with several additional
              constants. This caused an S0C4 because errmsg1 was not
              declared large enough to handle this long msg. This field
              was now increased from 128 to 180 characters.
   char           errmsg1[128] = "";                        bs2556*/
   char           errmsg1[180] = "";            /* bs2556 BS10070 */
   /* The errmsgt field is 1 byte larger than the message BS10070 */
   /* that cts2alt places into the field. This final byte BS10070 */
   /* will later be set to NULL_CHAR when trimming the    BS10070 */
   /* blanks in the message.                              BS10070 */
   char           errmsgt[125];                        /* BS10070 */
   int            j;                                   /* BS10070 */
   CTSAMSG_HANDLE_rec_ptr     msgs;                       /*bs2556*/
   CTSAMSG_DEST_TABLE_rec_ptr  dest;                      /*bs2556*/
   ACF2_API_Return_Codes rc = ACF2_OK;

   int            buffer_length = ACF2_ARE_BUFFER_LENGTH;
   char           ALT_Get_Fields = 'Y';

   char           ACF2_lidmask[ACF2_LID_SIZE];
   UIDMASK        ACF2_uidmask;
   char           ACF2_current_lid[ACF2_LID_SIZE];
/* char           ACF2_msgid[8];                             WS2565 */
   char           ACF2_msgid[9] = {0,0,0,0,0,0,0,0,0};    /* WS2565 */
   char           multi_field_name[20]="";                /* PS0321 */
   char           Mask_char = ' ';

   int            multi_field_offset = 0;                 /* PS0321 */
   int            Num_UIDs = 0;                           /* PS0354 */
   int i = 0, API_Fields_Count = 0;
   char *ii = NULL;
   char               API_Fields[2048] = "";
   char               Temp_Fields[2048] = "";

   char               uid_strings[9600] = "";             /* PS0320 */

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func );

   msgs = admin_params->ctsamsg_handle;                   /*bs2556*/
   dest = admin_params->ctsamsg_dest;                     /*bs2556*/

 /*************************************************************
 * Prepare indication for fields/no_fields retrieval          *
 **************************************************************/
   if (Get_Fields NE ACF2_GetUser_Get_Fields)
    ALT_Get_Fields = 'N'  ; /* No_Fields Indication in ACF2 */

   if (lid_masked EQ ACF2_Object_is_Masked)
    Mask_char = '*';

   Reset_Field(ACF2_lidmask,sizeof(ACF2_lidmask),Mask_char,lidmask);

   if (uidmask[0] NE NULL_CHAR)
    Reset_Field(ACF2_uidmask,sizeof(ACF2_uidmask),'*',uidmask);
   else
    Reset_Field(ACF2_uidmask,sizeof(ACF2_uidmask),' ',uidmask);

   Reset_Field(ACF2_current_lid,sizeof(ACF2_current_lid),
               ' ',current_lid);
   Reset_Field(errmsg,sizeof(errmsg),0X00,NULL);
   Reset_Field(buffer,4,0X00,NULL);

   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR,
                   "lidmask=(%s), uidmask=(%s), current lid=(%s)",
                   ACF2_lidmask,ACF2_uidmask,ACF2_current_lid);

 /******************************************************************
 * Convert Required Fields string to an ACF2-API 8-Char Entry Vector
 *******************************************************************/
  strcpy(Temp_Fields,Required_Fields);
   strcat(Temp_Fields,",");

   while(i LT strlen(Required_Fields))
    {
     ii = strpbrk(Temp_Fields + i,",");

     if (ii EQ NULL)
      break;

     (*ii) = NULL_CHAR;
     Reset_Field(API_Fields + API_Fields_Count*8,9,' ',
                 Temp_Fields + i);
     i = (ii - Temp_Fields) + 1;
     API_Fields_Count++;
     ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                     "API field count = (%d), fields =(%s)",
                      API_Fields_Count,API_Fields);

    };

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR,
                  "Final API field count = (%d), fields =(%s)",
                  API_Fields_Count,API_Fields);

  /******************************************************************
  * Issue ACF2 API Call to ACALT SVC                                *
  *******************************************************************/
  /* SAS2IBMT cts2alt(ACF2_lidmask,                                  */
  (*(ASM_RTN_TYP *)&cts2alt)(ACF2_lidmask,                /* SAS2IBMT */
          ACF2_uidmask,
          ACF2_current_lid,
          &ALT_Get_Fields,
          &API_Fields_Count,
          API_Fields,
          &buffer_length,
          buffer,
          &rc1,
          errmsg);

  /* The first 124 characters of errmsg does not have a      BS10070 */
  /* NULL_CHAR so when printing the message, we print a      BS10070 */
  /* very long message (until the NULL_CHAR somewhere after  BS10070 */
  /* 124 characters. The following macro 'trims' the message BS10070 */
  /* by placing a NULL_CHAR after the last non-blank char.   BS10070 */
  /* (The loop starts from errmsgt[123] and goes back to     BS10070 */
  /* errmsgt[0] looking for the last non-blank character.)   BS10070 */

  TRIM_BLANKS(errmsg, errmsgt, 124, j)                    /* BS10070 */
  /* All references to errmsg will now be changed to         BS10072 */
  /* errmsgt because this is the field which now contains    BS10072 */
  /* a NULL_CHAR after the last non-blank.                   BS10072 */

  /* IS0071 add some diags (part 1)*/
  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
  "lidmask=(%s),uidmask=(%s),cur_lid=(%s),A_G_Flds=(%s)",
   ACF2_lidmask,ACF2_uidmask,ACF2_current_lid,ALT_Get_Fields);

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
   "Fields_Count=(%d),Fields=(%s),buffer_length=(%d),buffer_start=(%s)",
    API_Fields_Count,API_Fields,buffer_length,buffer[60]);

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
   "rc=%d,msg=%s",
    rc1,errmsgt);                         /* errmsg->errmsgt BS10072 */
  /* end of IS0071 */

 if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE DEBUG_SHOW_ALL)
  {
    SNAP_AREA( "ARE Buffer", buffer, 1024 )
  };

 /******************************************************************
 * Check ACF2 API Rc                                               *
 *******************************************************************/
   switch(rc1)
    {
     case 0:  rc = ACF2_OK;

              /***************************************************
              * Set Current_User Fields                          *
              ****************************************************/
              if (lid_masked EQ ACF2_Object_is_Masked)
                memcpy(current_lid,ACF2_current_lid,
                       strlen(ACF2_current_lid));
              else
                memcpy(current_lid,ACF2_lidmask,strlen(ACF2_lidmask));

              if (Get_Fields EQ ACF2_GetUser_Get_Fields)
              {
                /* PS0321 - Return all possible UID values */
                /*************************************************
                * Does UID contain a MULTI-VALUED field ?        *
                * If YES, return all possible UID values in UIDX *
                **************************************************/
                if (mode EQ ACF2_Return_Multi_UIDs)
                {
                  if (UID_Contains_MULTI(multi_field_name,
                                         &multi_field_offset))
                  {
                    ESA_DIAG_printf(PLT_COMP_API_ACF2,
                                    DEBUG_SHOW_IMPORTANT,
                                    "UID contains MULTI VALUE");

                    ESA_DIAG_printf(PLT_COMP_API_ACF2,
                                    DEBUG_SHOW_IMPORTANT,
                                    "MULTI VALUE field (%s) offs(%d)",
                                    multi_field_name,
                                    multi_field_offset);

                    rc0 = Build_Multi_UIDs (current_lid,
                                            multi_field_name,
                                            multi_field_offset,
                                            NULL,         /* PS0354 */
                                            &Num_UIDs,    /* PS0354 */
                                            uid_strings,
                                            admin_params); /*bs2556*/

                    if (rc0 EQ ESA_OK)
                      ADDINFO_insert(TYPE_1B, "UIDX",
                                     uid_strings,
                                     laddinfo,
                                     ACF_ADDINFO_KWD_LEN,
                                     ACF_ADDINFO_VAL_LEN,
                                     UNIQUE);
                  };
                };
                /* End of PS0321 */

                /*************************************************
                * Convert ACF2 ARE chain to ADDINFO structure    *
                **************************************************/
                Process_AREs((ARE_typ *) buffer,
                             "",
                             laddinfo);
              };
              break;

              /***************************************************
              * Check EOF Status (via ACF2 Error Messages Codes) *
              ****************************************************/
     case 4:
              /* send a msg when internal error in acf2 - bs2556*/
              /* send it only when not one of the 2 msgs below
              sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
              rc1,errmsg);
              CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
              func,errmsg1, 16,__LINE__);
               * end of avner fix */
              strncpy(ACF2_msgid,errmsgt,8); /*errmsg->errmsgt BS10072*/
              if ( (strcmp(ACF2_msgid,ACF2_EOF) EQ 0)      OR
                   (strcmp(ACF2_msgid,ACF2_NOT_FOUND) EQ 0) )
                rc = ACF2_Not_Found;
              else
              /* send a msg when internal error in acf2 - BS2586*/
              {
              sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
              rc1,errmsgt);               /* errmsg->errmsgt BS10072 */
              CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
              func,errmsg1, 16,__LINE__);
              /* end of avner fix */
                rc = ACF2_Internal_Error;
                strcpy(errmsg,"ACF2 Access Denied");      /* BS10070 */
              }
              break;

              /***************************************************
              * ACF2 Internal Error situations                   *
              ****************************************************/
     case 8:
              /* send a msg when internal error in acf2 - bs2556*/
              sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
              rc1,errmsgt);               /* errmsg->errmsgt BS10072 */
              CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
              func,errmsg1, 16,__LINE__);
              /* end of avner fix */
              rc = ACF2_Internal_Error;
              strcpy(errmsg,"ACF2 Control Block Error");
              break;

              /***************************************************
              * ACF2 Not Active                                  *
              ****************************************************/
     case 12:
              /* send a msg when internal error in acf2 - bs2556*/
              sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
              rc1,errmsgt);               /* errmsg->errmsgt BS10072 */
              CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
              func,errmsg1, 16,__LINE__);
              /* end of avner fix */
              rc = ACF2_ACF2_Not_Active;
              strcpy(errmsg,"ACF2 Not Active");
              break;

     default:
              /* send a msg when internal error in acf2 - bs2556*/
              sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
              rc1,errmsgt);               /* errmsg->errmsgt BS10072 */
              CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
              func,errmsg1, 16,__LINE__);
              /* end of avner fix */
              rc = ACF2_Internal_Error;
              strcpy(errmsg,"Unknown ACF2 return code");
              break;
     };

   exit:

    ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func,rc);
    return rc;
 }

/******************************************************************
 * Procedure Name: ACF2_Get_User_UID
 ******************************************************************
 * Description   : This function retrievs the User UID field only by
 *                 calling ACF2_Get_User.
 *
 * Input         : lid        - User id
 *                 uidmask    - A filtering criteria users matching both
 *                              lidmask and uidmask will be returned.
 *
 * Input/Output  : current_lid - Input:get next matching user after this
 *                               Output: current user after operation
 *                 laddinfo    - addinfo workarea
 *
 * Output        : uid         - User's UID
 *                 uids_list   - User's UIDs list (if MULTI VALUE)
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - User retrieved ok
 *                 ACF2_Not_Found      - No user found matching criteria
 *                 ACF2_Internal_Error - Error in ACF2 processing
 *********************************************************************/
 ACF2_API_Return_Codes ACF2_Get_User_UID (char     *lid,
                                          char     *uid,
                                          char     *current_lid,
                                          char     *uidmask,
      /* PS0339 */                        char     *uids_list,
                                          ADDINFO_rec_ptr laddinfo,
       /* bs2556 */                ADMIN_PARAMS_rec_typ * admin_params)
{
   static         char func[]="ACF2_Get_User_UID";
   char           errmsg[128] = "";
   char           ACF2_sysid[ACF2_SYSID_SIZE];
   char           multi_field_name[20]="";                /* PS0339 */
   char           entry_sep[2];                           /* PS0339 */
   ACF2_API_Return_Codes rc = ACF2_OK;
   ONE_FIELD_rec_ptr pair = NULL;
   ACF2_Object_Mask object_masked;
   URID           urid, last_urid;                        /* PS0339 */
   UID            temp_uid;                               /* PS0339 */
   LID            prev_lid;                               /* PS0339 */
   UDB_Codes      UDB_rc;
   int            multi_field_offset = 0;                 /* PS0339 */
   int            first_time;                             /* PS0339 */

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT, func );

   entry_sep[0] = ADDINFO_LIST_ENTRY;                     /* PS0339 */
   entry_sep[1] = NULL_CHAR;                              /* PS0339 */

   strcpy (uids_list, "");                                /* PS0339 */

   memset(ACF2_sysid,0X00,sizeof(ACF2_sysid));

 /******************************************************************
 * Check if Userid is masked                                       *
 *******************************************************************/
   if (strpbrk(lid,"*") NE NULL)
    object_masked = ACF2_Object_is_Masked;
   else
    object_masked = ACF2_Object_is_Not_Masked;

 /******************************************************************
 * If UDB is operational and The Get operation is non-specific:    *
 *   Use UDB UID access shortcut                                   *
 *******************************************************************/
   if ( (Global_UDB_Active() EQ TRUE)
               AND
        (object_masked EQ ACF2_Object_is_Masked) )
    {
     ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
                     "Get all UIDs from UDB");

     /* PS0339 - Added */
     /**************************************************************
     * If UID contains MULTI VALUED field, read all user UIDs from *
     * UDB into uids_list parameter                                *
     ***************************************************************/
     if (UID_Contains_MULTI(multi_field_name,
                            &multi_field_offset))
     {
       first_time = TRUE;

       strcpy (temp_uid,"");

       UDB_rc = UDB_GetNext(urid,current_lid,temp_uid);

       /* Read all user UIDs */
       while (UDB_rc EQ UDB_OK)
       {
         ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
                         "URID (%s) UID (%s)", urid,temp_uid);

         strcpy (last_urid, urid);

         if (first_time)
         {
           first_time = FALSE;
           strcpy (uid,temp_uid);
           strcpy (prev_lid, current_lid);
         }
         else
         {
           ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
                           "Not first time. Check URID");
           /* Did we reach the first record of the next user? */
           if (strcmp (urid, "0001") EQ 0)
           {
             /* locate on next user's 1st record - for next time */
             ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
                             "Locate rec (%s) of next user:(%s)",
                             urid,current_lid);

             UDB_rc = UDB_Locate(urid,current_lid,UDB_Exact_Locate);

             ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
                             "Locate rc=(%d)", UDB_rc);

             uids_list[(strlen(uids_list)-1)] = NULL_CHAR;

             strcpy (current_lid, prev_lid);

             break;
           };
         };

         strcat (uids_list, temp_uid);
         strcat (uids_list, entry_sep);

         strcpy (temp_uid,"");                      /* bs2499 */

         UDB_rc = UDB_GetNext(urid,current_lid,temp_uid);

         /* Did we reach EOF ? */
         if (UDB_rc EQ UDB_EOF)
         {
           /* Point back to last record */
           UDB_Locate(last_urid, prev_lid, UDB_Exact_Locate);
           strcpy (temp_uid,"");                      /* bs2499 */
           UDB_GetNext(urid,prev_lid,temp_uid);
           UDB_rc = UDB_OK;
           uids_list[(strlen(uids_list)-1)] = NULL_CHAR;
           break;
         };
       };

       switch(UDB_rc)
       {
         case UDB_OK : break;
         case UDB_EOF: rc = ACF2_Not_Found;
                       ESA_DIAG_printf(ESA_COMP_GTUG2UC,
                                       DEBUG_SHOW_IMPORTANT,
                                       "EOF reached");
                       break;
         default     : rc = ACF2_Internal_Error;
       };

       goto exit;

     }; /* End of PS0339 */

     /**************************************************************
     * Following is the procedure for non MULTI-VALUE              *
     ***************************************************************/

     UDB_rc = UDB_Get_Next_User(urid,current_lid,uid);   /* WS2338 */

     ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
                     "Get_Next_User rc(%d) lid(%s) uid(%s)",
                     UDB_rc, current_lid, uid);          /* PS0338 */

     switch(UDB_rc)
     {
       case UDB_OK : break;
       case UDB_EOF: rc = ACF2_Not_Found;
                     ESA_DIAG_printf(ESA_COMP_GTUG2UC,
                                     DEBUG_SHOW_IMPORTANT,
                                     "EOF reached");     /* PS0338 */
                     break;
       default     : rc = ACF2_Internal_Error;

     };

      goto exit;
   };

 /******************************************************************
 * Get User's UID (with specific record retrieval request)         *
 *******************************************************************/
  Read_ACF2_Database:

     ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,
        "Before ACF2_Get_User. lid(%s) masked(%d)",
                     lid,object_masked);

   rc = ACF2_Get_User(lid,
                      object_masked,
                      uidmask,
                      current_lid,
                      ACF2_GetUser_Get_Fields,
                      "UID",
                      laddinfo,
                      ACF2_Return_Multi_UIDs,             /* PS0339 */
                      errmsg,
                      admin_params);

 /******************************************************************
 * Check ACF2 API Return Codes                                     *
 *******************************************************************/
   switch(rc)
    {
      case ACF2_OK:
         /*****************************************************
         * Locate UID field in ADDINFO                        *
         *****************************************************/
         pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                               laddinfo->pair,
                               laddinfo->num_pairs);
         /*****************************************************
         * Return it via uid parm, or error                   *
         *****************************************************/
         if (pair NE NULL)
           strcpy (uid,pair->value);
         else
         {
           rc = ACF2_Internal_Error;
           goto exit;                                     /* PS0339 */
         };

         /* PS0339 - Added */
         /*****************************************************
         * Locate UIDX field in ADDINFO                       *
         *****************************************************/
         pair = ADDINFO_search("UIDX", ACF_ADDINFO_KWD_LEN,
                               laddinfo->pair,
                               laddinfo->num_pairs);
         /*****************************************************
         * Return it via uids_list parm                       *
         *****************************************************/
         if (pair NE NULL)
           strcpy (uids_list,pair->value);

         /* End of PS0339 */

         break;

      default:;
    };

   exit:

    ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func , rc);
    return rc;
 }
/******************************************************************
 * Procedure Name: ACF2_Get_Group
 ******************************************************************
 * Description   : This function retrievs ACF2 virtual groups from GDB.
 *                 The function assumes the GDB is open.
 *
 * Input         : mode       - Access Mode: Exact, Generic (re-pos)
 *                                           Next (Get Next Group)
 *
 * Input/Output  : Group       - Group returned
 *                 PB_Req      - -> PB_Build_Request         WS10084
 *                                  (replaces PBhandle)      WS10084
 *
 * Output        : laddinfo    - Group ADDINFO
 *                             - ADDINFO (where permissions//WS10076S //
 *                                        will be moved to)//WS10076S //
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Group Retrieved
 *                 ACF2_Not_Found      - No Group to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in group processing
 *********************************************************************/
 ACF2_API_Return_Codes ACF2_Get_Group(
                                GDB_Locate_Mode mode,
                                UG_typ          Group,
                                ADDINFO_rec_ptr laddinfo,
                                ADDINFO_rec_ptr addinfo,  /* WS10076S */
       /* WS10084               PBhandle_typ  * PBh,      /* WS10076S */
       /* WS10084  */           PB_Build_Request_typ * PB_Req,
       /* WS10076A */           ADMIN_PARAMS_rec_typ * admin_params)
 {
   static         char func[]="ACF2_Get_Group";
   ACF2_API_Return_Codes rc = ACF2_OK;
   ESA_RC                pb_rc = ESA_OK;                  /* WA10076N */
   char Record_Type;
   ONE_FIELD_rec_ptr      pair = NULL;                    /* WS10076S */
   ONE_FIELD_rec_ptr      perm_pair = NULL;               /* WS10076N */
   ESA_RC                 rcc = 0;                        /* WS10076S */
   int                    addinfo_full = FALSE;           /* WS10076S */
   int                    with_perm = NULL_CHAR;          /* WS10076N */
   char                   errmsg[125] = "";               /* WS10076S */
   char      perm_data[ACF2_MAX_PERMISSN_SIZE] = "";      /* WS10076S */
   CTSAMSG_HANDLE_rec_ptr      msgs;                      /* WS10076S */
   CTSAMSG_DEST_TABLE_rec_ptr  dest;                      /* WS10076S */
   PBhandle_typ          * PBh = NULL;                    /* WS10084  */

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func );

   /* BS10111 - move down to be issued only when there is a
      permisisons block.
   ESA_DIAG_printf (PLT_COMP_PERMISSION, 77,              /@ WS10076S @/
                    "Just entered ACF2_Get_Group");       /@ WS10076S @/
   */

 /* ****** ****** ****** ** WS10076S Start ** ****** ****** ****** */

   msgs = admin_params->ctsamsg_handle;                   /* WS10076S */
   dest = admin_params->ctsamsg_dest;                     /* WS10076S */

   if (PB_Req NE NULL)                                    /* WS10084  */
    PBh =  PB_Req->Groups_PBhandle_ptr;                   /* WS10084  */
   else
    ESA_DIAG_printf (PLT_COMP_PERMISSION, 20,             /* WS10084  */
                      "PB_Req is NULL");                  /* WS10084  */

   if (PBh NE NULL)
   {
     /* BS10111 - this diag was moved here to be issued only
                  when there is a pemrissions block.                  */
     ESA_DIAG_printf (PLT_COMP_PERMISSION, 77,            /* WS10076S */
                      "Just entered ACF2_Get_Group");     /* WS10076S */
     if (PBh->PBbldErr EQ TRUE)
     {
       rc = ACF2_Internal_Error;
       goto exit;
     }

     if (PBh->PBnf EQ TRUE)                               /* WS10079N */
     {                                                    /* WS10079N */
       rc = ACF2_Not_Found;                               /* WS10079N */
       goto exit;                                         /* WS10079N */
     }                                                    /* WS10079N */

     if (PBh->PBptr EQ NULL)
     {
       pb_rc = Permissions_block_Build("BUILD",
                                      /*PBh,                 WS10084 */
                                        PB_Req,           /* WS10084 */
                                        PLT_COMP_PERMISSION,
                                        admin_params);

       if (pb_rc EQ ESA_KEY_NOT_FOUND)                    /* WS10079N */
       {                                                  /* WS10079N */
          PBh->PBnf = TRUE;                               /* WS10079N */
          rc = ACF2_Not_Found;                            /* WS10079N */
          goto exit;                                      /* WS10079N */
       }                                                  /* WS10079N */
       else                                               /* WS10079N */
         if ( (pb_rc NE ESA_OK) OR (PBh->PBptr EQ NULL) )
         {
            PBh->PBbldErr = TRUE;
            rc = ACF2_Internal_Error;
            goto exit;
         }
     } /* end of if (PBh->PBptr EQ NULL) */

     /* WS10076N - start */
     if ( (addinfo NE NULL) )
     {
       perm_pair = ADDINFO_search("GROUPDIRECTPERMISSIONS",
                             ACF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs);
       if (perm_pair NE NULL )
         with_perm = TRUE;
       else
         with_perm = FALSE;
     };

     switch(mode)
     {
       case GDB_Next_Locate:
         pb_rc = Permissions_block_Get("UIDNEXT",
                                        PBh,
                                        Group,
                                        (with_perm? perm_data : NULL),
                                        sizeof(perm_data),
                                        PLT_COMP_API_ACF2,
                                        admin_params);
                        /* WS10076N     perm_data,  */

        break;
       case GDB_Exact_Locate:
         pb_rc = Permissions_block_Get("UIDTHIS",
                                        PBh,
                                        Group,
                                        (with_perm? perm_data : NULL),
                                        sizeof(perm_data),
                                        PLT_COMP_API_ACF2,
                                        admin_params);
                        /* WS10076N     perm_data,  */
          break;
       case GDB_Generic_Locate:
       default:
         sprintf(errmsg,"Undefined or incorrect input mode %d",
                 mode);
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                       func, errmsg, 16, __LINE__);
         rc = ACF2_Internal_Error;
         goto exit;
     } /* end of switch(mode) */

     /*  WS10076N - start  */
     /*
      *   Do we have a UID ?
      *   We have a UID when the return code is OK or ERR.
      *   ERR means that the area for the permission is too short.
      */
     if (pb_rc EQ ESA_OK   OR  pb_rc EQ ESA_ERR)
       rc = ACF2_OK;
       else
         if (pb_rc EQ ESA_EOF)
         {
           rc = ACF2_Not_Found;
           goto exit;
         }
         else
         {
           rc = ACF2_Internal_Error;
           goto exit;
         };

     /*
      *   Set the UIDMASKS keyword
      */
     pair = ADDINFO_search("UIDMASKS",
                           ACF_ADDINFO_KWD_LEN,
                           laddinfo->pair,
                           laddinfo->num_pairs);
     if (pair NE NULL)
       ADDINFO_updval(Group,
                      ACF_ADDINFO_VAL_LEN,
                      pair);
     else
       ADDINFO_insert(TYPE_1B, "UIDMASKS",
                      Group,
                      laddinfo,
                      ACF_ADDINFO_KWD_LEN,
                      ACF_ADDINFO_VAL_LEN,
                      UNIQUE);

     /*
      *   Set the PERMISSIONS, if requested and exists
      *   (ESA_ERR means permission too long so we need
      *   to take the rest.
      */
     if ( (with_perm)  AND
           ( perm_data[0] NE NULL_CHAR  OR  pb_rc EQ ESA_ERR) )
     {
       while (pb_rc EQ ESA_OK  OR    /* While perm was returned or */
              pb_rc EQ ESA_ERR)      /* permission is too long.    */
       {
         if (pb_rc  EQ  ESA_OK)  /* when ok, take the permission */
         {
           if ( (addinfo_full EQ FALSE) )
           {
             rcc = ADDINFO_addval (perm_data,
                                   ACF_ADDINFO_VAL_LEN,
                                   ADDINFO_LIST_ENTRY,
                                   perm_pair, dest, msgs);
             /* WS10082N if (rcc EQ ESA_EOF)  */
             if (rcc NE ESA_OK)                           /* WS10082N */
             {
/* WS10078ST   CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL,
                             dest, "Direct", Group);                 */
               CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,
/* WS10078ST Changing message text completely                        */
/* WS10078ST */              perm_pair->keyword, Group, perm_data,
/* WS10078ST */              strlen(perm_data), perm_pair->vallen,
/* WS10078ST */              "permissions");
/* WS10078KM - Start Lets add isIncomplete attribute in addinfo */
               rcc = ESA_OK;
               pair = ADDINFO_search("isIncomplete",
                                     ACF_ADDINFO_KWD_LEN,
                                     laddinfo->pair,
                                     laddinfo->num_pairs);
               if (pair NE NULL)
               {
                  if( pair->value[0] NE 'Y')
                     rcc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN,
                                          pair);
                  if (rcc NE ESA_OK)
                  {
                     /* WS10082N sprintf(errmsg,
                             "Insert <%s> keyword failed. rc=%d",
                             "isIncomplete",rc); */
                     /* WS10082N - start */
                     sprintf(errmsg,
                          "Update <isIncomplete> keyword failed. rc=%d",
                           rc);
                     /* WS10082N - end   */
                     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                   dest, component,func,
                                   errmsg, 16,__LINE__);
                  }
               }
/* WS10078KM - Ends */
               addinfo_full = TRUE;
               pb_rc = ESA_EOF; /* fake EOF        */
               break;
             };
           };
         };

         pb_rc = Permissions_block_Get("PERMNEXT",
                                       PBh,
                                       Group,
                                       perm_data,
                                       sizeof(perm_data),
                                       PLT_COMP_PERMISSION,
                                       admin_params);

         ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
            "Permission_block_get: rc = %d, |%s|", pb_rc, perm_data);
       } /* end of while */

       /* We got here because the Permissions_block_get routine    */
       /* returned with ESA_EOF (no more permssions) or ESA_FATAL  */
       /* (internal error), or we faked 'EOF' when addinfo is full.*/
       /* In all cases, we set the ACF2_Get_Group routine rc       */
       /* appropriately.                                           */

       if (pb_rc EQ ESA_EOF)
          rc = ACF2_OK;
       else
          rc = ACF2_Internal_Error;
     }     /* end of if ( ((addinfo NE NULL) and there is perm */
     /*  WS10076N - end    */

  } /* end of if (PBh NE NULL) */
  else       /* else for: if (PBh EQ NULL) */
  {
 /* ****** ****** ****** ** WS10076S End **** ****** ****** ****** */

 /******************************************************************
 * Re position GDB for Group (if not get next processing)          *
 *******************************************************************/
   if (mode NE GDB_Next_Locate)
     switch(GDB_Locate(GDB_RECORD_TYPE_GROUP,Group,mode))
      {
       case GDB_OK:
        break;
       case GDB_Not_Found:
        rc = ACF2_Not_Found;
        goto exit;
       default:
        rc = ACF2_Internal_Error;
        goto exit;
      };

 /******************************************************************
 * Get Re-positioned/Next group record                             *
 *******************************************************************/
   switch(GDB_GetNext(GDB_RECORD_TYPE_GROUP,NULL))
    {
     case GDB_OK:
       break;
     case GDB_EOF:
       rc = ACF2_Not_Found;
       goto exit;
     default:
       rc = ACF2_Internal_Error;
       goto exit;
    };

 /******************************************************************
 * Convert Current Record to Group Name + ADDINFO                  *
 *******************************************************************/
   GDB_Convert_from_Record(&Record_Type,Group,laddinfo);
   } /* end of piece of old, existing code                   WS10076S */

   exit:;

   if (PBh NE NULL)  /* issue this only when pbh exists      BS10111 */
     ESA_DIAG_printf (PLT_COMP_PERMISSION, 77,            /* WS10076S */
              "Leaving ACF2_Get_Group - rc = %d", rc);    /* WS10076S */

    ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func , rc);
    return rc;
 }

/******************************************************************
 * Procedure Name: ACF2_Get_GSO
 ******************************************************************
 * Description   : Get GSO record from ACF2 Infostorage Database.
 *                 GSO access is done via 2 keys (sysid, recname).
 *
 *                 The routine returns a single GSO record where many
 *                 records may match the sysid/recname combination.
 *
 *                 The record returned is the Best-Match between the
 *                 recname, ACF2 sysid, and records sysid/sysid_mask.
 *
 * Input         : recname    - GSO Record Name to Retrieve
 *
 * Output        : laddinfo   - GSO Record fields
 *                 errmsg     - Error Message from low-level
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in processing
 *********************************************************************/
 ACF2_API_Return_Codes  ACF2_Get_GSO  (char     *recname,
                                       ADDINFO_rec_ptr laddinfo,
                                       char     *errmsg)
 {

  static char           func[]="ACF2_Get_GSO";
  char                  ACF2_sysid[ACF2_SYSID_SIZE];
  ACF2_INF_record       InfRec , Current_InfRec;
  ACF2_API_Return_Codes rc = 0;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func );

   memset(ACF2_sysid,0X00,sizeof(ACF2_sysid));

 /********************************************************************
 * Create InfRec structures: Record to process, Get Next logic Support
 *********************************************************************/
  Create_InfRec_Id(&InfRec,"C","GSO",
                   ACF2_Object_is_Masked,"********",
                   ACF2_Object_is_Not_Masked,recname);
  Create_InfRec_Id(&Current_InfRec,"","",
                   ACF2_Object_is_Not_Masked,"",
                   ACF2_Object_is_Not_Masked,"");

 /********************************************************************
 * Get Current Gso Record (no relevance to Get Next Logic)           *
 *********************************************************************/
  rc = ACF2_Get_INF(&InfRec,
                    &Current_InfRec,
                    ACF2_INF_Get_Best_Match,
                    laddinfo,
                    errmsg);
   exit:;

   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func , rc);
   return rc;
 }

/******************************************************************
 * Procedure Name: ACF2_UP_exists
 ******************************************************************
 * Description   : checks if the specified type of user profile exists
 *                 for the current user.
 *
 * Input         : recname    - user of the requested profile
 *               : sysname    - the type of profile
 *
 * Output        : none
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in processing
 *********************************************************************/

 ACF2_API_Return_Codes ACF2_UP_exists
                                (char                       *recname,
                                 char                       *sysname,
                                 ESA_DIAG_COMP_typ          comp,
                                 CTSAMSG_HANDLE_rec_typ     * msgs,
                                 CTSAMSG_DEST_TABLE_rec_typ * dest)
 {
   static                char func[]="ACF2_UP_exists";
   ESA_RC   rc = ESA_OK ;
   ADDINFO_rec_ptr       laddinfo = NULL;
   char                  errmsg[128] = "";
   /* allocating the temporary laddinfo header */
   if (ADDINFO_alloc(func, ACF2_ADDINFO, &laddinfo,
      dest, msgs) NE ESA_OK)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
              "ADDINFO allocation for user profs failed", 16,__LINE__);
     rc = ESA_FATAL;
     goto exit;
   }
   rc = ACF2_Get_specific_user_profile(recname,
                                       sysname,
                                       laddinfo,comp, TRUE,
                                       errmsg);
   exit:;
   ADDINFO_free(&laddinfo);
   return rc;
 }
/******************************************************************
 * Procedure Name: ACF2_Get_all_specific_user_profiles
 ******************************************************************
 * Description   : Gets all specific user profiles from ACF2 Infostorage
 *                 Database.
 *                 array contains name of all user profile types.
 *
 *                 The routine returns all keywords and values of all
 *                 SPECIFIC user profiles.
 *
 *                 a SPECIFIC user profile is one that is the same name
 *                 as the LID, i.e. NOT MASKED.
 *
 * Input         : recname    - LID of the requested profile
 *
 * Output        : laddinfo   - addinfo with all keywords concatinated
 *                 errmsg     - Error Message from low-level
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in processing
 *********************************************************************/
 ACF2_API_Return_Codes ACF2_Get_all_specific_user_profiles
                                 (char                       *recname,
                                  char                       *func,
                                  ADDINFO_rec_ptr            laddinfo,
                                  char                       *errmsg,
                                  ESA_DIAG_COMP_typ          comp,
                                  CTSAMSG_HANDLE_rec_typ     * msgs,
                                  CTSAMSG_DEST_TABLE_rec_typ * dest)
 {
   int      i;
   ESA_RC   rc = ESA_OK ;
   ADDINFO_rec_ptr            curr_profile_laddinfo = NULL;
   ESA_DIAG_enter(PLT_COMP_API_ACF2,6,func );              /*BS10120*/
   /* allocating the temporary laddinfo header */
   if (ADDINFO_alloc(func, ACF2_ADDINFO, &curr_profile_laddinfo,
      dest, msgs) NE ESA_OK)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
              "ADDINFO allocation for user profs failed", 16,__LINE__);
     rc = ESA_FATAL;
     goto exit;
   }
   for(i=0; UP_kdts[i].UP_name[0] NE NULL_CHAR;i++)
   {
     rc = ACF2_Get_specific_user_profile(recname,
                                         UP_kdts[i].UP_name,
                                         curr_profile_laddinfo,comp,
                                         FALSE, errmsg);
     if (rc NE ESA_OK) {
         goto exit;
     }
     ESA_DIAG_printf(PLT_COMP_API_ACF2,6,
       "print the user_profile addinfo");                   /*BS10120*/
     if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE 6)  /*BS10120*/
       ADDINFO_dump(curr_profile_laddinfo,1);               /*BS10120*/
     ADDINFO_masupd(laddinfo, curr_profile_laddinfo,
                    ADDINFO_masupd_Merge,dest,msgs);
     ADDINFO_empty(curr_profile_laddinfo);
   };
  exit:;
  ADDINFO_free(&curr_profile_laddinfo);
  ESA_DIAG_exit(PLT_COMP_API_ACF2,1, func,rc);              /*BS10120*/
  return rc;
 }
/******************************************************************
 * Procedure Name: ACF2_Get_specific_user_profile
 ******************************************************************
 * Description   : Get a specific user profile from ACF2 Infostorage
 *                 Database.
 *                 access is done via 2 keys (sysid, recname).
 *
 *                 The routine returns a single profile record.
 *
 * Input         : recname    - LID of the requested profile
 *               : sysid      - the type of profile record requested
 *                              (i.e. - OMVS, CICS...)
 *
 * Output        : laddinfo   - profile record fields
 *                 errmsg     - Error Message from low-level
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in processing
 *********************************************************************/
 static ACF2_API_Return_Codes ACF2_Get_specific_user_profile
                                          (char              *recname,
                                           char              *sysid,
                                           ADDINFO_rec_ptr   laddinfo,
                                           ESA_DIAG_COMP_typ comp,
                                           int               pass_rc,
                                           char              *errmsg)
 {
  static char           func[]="ACF2_Get_specific_user_profile";
  char                  ACF2_sysid[ACF2_SYSID_SIZE];
  char        ACF2_sysid_switch[ACF2_SYSID_SIZE+UP_SWITCH_CONST_LEN];
  char                  ACF2_sysid_switch_val[2];
  ACF2_INF_record       InfRec , Current_InfRec;
  ACF2_API_Return_Codes rc = 0;
  ACF2_API_Return_Codes user_profile_exists_rc;

  ESA_DIAG_enter(comp, DEBUG_SHOW_REGULAR, func );
    ESA_DIAG_printf(comp,DEBUG_SHOW_REGULAR,
   "ACF2_Get_specific_user_profile called for recid=%s,sysid=%s",
     recname,sysid);
  memset(ACF2_sysid,0X00,sizeof(ACF2_sysid));

 /********************************************************************
 * Create InfRec structures: Record to process, Get Next logic Support
 *********************************************************************/
  Create_InfRec_Id(&InfRec,"P","USR",
                   ACF2_Object_is_Not_Masked,sysid,
                   ACF2_Object_is_Not_Masked,recname);
  Create_InfRec_Id(&Current_InfRec,"","",
                   ACF2_Object_is_Not_Masked,"",
                   ACF2_Object_is_Not_Masked,"");

 /********************************************************************
 * Get profile of specified user                                     *
 *********************************************************************/
  rc = ACF2_Get_INF(&InfRec,
                    &Current_InfRec,
                    ACF2_INF_Get_Match,
                    laddinfo,
                    errmsg);
 /********************************************************************
 * building SWITCH keyword for user_profile                          *
 *********************************************************************/
  if (rc EQ ESA_OK) {
     strcpy(ACF2_sysid_switch_val, UP_SWITCH_ON);
  }
  else {
     strcpy(ACF2_sysid_switch_val, UP_SWITCH_OFF);
  }
  user_profile_exists_rc = rc;
  strcpy (ACF2_sysid_switch, sysid);
  strcat (ACF2_sysid_switch, UP_SWITCH_CONST);
  ADDINFO_insert(TYPE_1A,
                 ACF2_sysid_switch,
                 ACF2_sysid_switch_val,
                 laddinfo,
                 ACF_ADDINFO_KWD_LEN,
                 ACF_ADDINFO_VAL_LEN,
                 UNIQUE);
  rc = ESA_OK;

  exit:;

  if (pass_rc) {
     rc = user_profile_exists_rc;
  }
  ESA_DIAG_exit(comp, DEBUG_SHOW_REGULAR, func , rc);

  return rc;
 } /* end of ACF2_Get_specific_user_profile */

/* PS0321 - New function */
/******************************************************************
 * Procedure Name: Build_Multi_UIDs
 ******************************************************************
 * Description   : Return all possible values of UIDs, influenced by
 *                 a MULTI VALUED field which is part of the UID.
 *
 * Input         : user_lid   - user LID
 *                 field_name - MULTI VALUED field name
 *                 field_offs - MULTI VALUED field offset in UID
 *      PS0354     faddinfo   - if not NULL, contains field values
 *                              and modified UID without multivalue
 *
 * Output        : Num_UIDs   - Number of UIDs in UIDs_List (PS0354)
 *                 UIDs_list  - list of all UIDs
 *
 * Return Value  : ESA_OK, ESA_FATAL
 *********************************************************************/
 ESA_RC Build_Multi_UIDs (char           *user_lid,
                          char           *field_name,
                          int             field_offs,
                          ADDINFO_rec_ptr faddinfo,       /* PS0354 */
                          int            *Num_UIDs,       /* PS0354 */
                          char           *UIDs_list,
 /* bs2556 */             ADMIN_PARAMS_rec_typ * admin_params)
 {
   static char           func[]="Build_Multi_UIDs";

   ESA_RC                rc = ESA_OK;
   ADDINFO_rec_ptr       laddinfo = NULL;
   ONE_FIELD_rec_ptr     UID_pair = NULL;
   ONE_FIELD_rec_ptr     field_pair = NULL;
   char                  current_lid[ACF2_LID_SIZE]="";
   char                  fields_list[40]="";
   char                  current_UID[ACF2_UID_SIZE]="";
   char                * field_ptr = NULL;
   char                  entry_sep[2];
   char                  errmsg[128] = "";

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func );

   entry_sep[0] = ADDINFO_LIST_ENTRY;
   entry_sep[1] = NULL_CHAR;

   *Num_UIDs = 0;                                         /* PS0354 */

   strcpy (UIDs_list, "");

   /*************************************************************/
   /* If given addinfo is NULL, allocate our own and get UID    */
   /* and multivalued field values from User record             */
   /*************************************************************/
   if (faddinfo EQ NULL)                                  /* PS0354 */
   {
     if (ADDINFO_alloc(func, ACF2_ADDINFO, &laddinfo, NULL, NULL)
           NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     };

     strcpy (fields_list, "UID,");
     strcat (fields_list, field_name);

     /* Retrieve UID or UID + Multivalue field values */
     rc = ACF2_Get_User(user_lid,
                        ACF2_Object_is_Not_Masked,
                        "",
                        current_lid,
                        ACF2_GetUser_Get_Fields,
                        fields_list,
                        laddinfo,
                        ACF2_No_Multi_UIDs,
                        errmsg,
                        admin_params);        /*bs2556*/

     if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     };
   }
   else                                                   /* PS0354 */
     laddinfo = faddinfo;                                 /* PS0354 */

   /* Locate user UID */
   UID_pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                             laddinfo->pair,
                             laddinfo->num_pairs);

   if (UID_pair EQ NULL)
   {
     rc = ESA_FATAL;
     goto exit;
   };

   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                   "Primary UID value is (%s)",
                   UID_pair->value);

   /*************************************************************/
   /* Locate field                                              */
   /* If the field is not found it means that the user does not */
   /* have any value in it, so the user has ONLY one UID.       */
   /* In this case we return ESA_ERR, but create UIDs_List.     */
   /* Having one value in that field is considered having multi */
   /* values, with only one value.                              */
   /* ESA_ERR   - causing a bypass on the UIDX field creation   */
   /*************************************************************/
   field_pair = ADDINFO_search(field_name, ACF_ADDINFO_KWD_LEN,
                               laddinfo->pair,
                               laddinfo->num_pairs);

   if (field_pair EQ NULL)
   {
     *Num_UIDs = 1;                                       /* PS0354 */
     strcpy (UIDs_list,UID_pair->value);                  /* PS0354 */
     rc = ESA_ERR;                                        /* PS0354 */
     goto exit;
   };

   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                   "Field values (%s)",
                   field_pair->value);

   field_ptr = strtok (field_pair->value, entry_sep);

   /* A loop to build all possible UID values */
   /* (we drop duplicate UIDs)                */
   while (field_ptr NE NULL)
   {
     Reset_Field(current_UID,sizeof(current_UID),' ', UID_pair->value);
     memcpy (current_UID+field_offs, field_ptr, strlen(field_ptr));

     ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                     "Current UID (%s)",
                     current_UID);

     /* Is this UID the same as an existing one ? */
     /* If not, concatenate it to the list        */
     if (strstr (UIDs_list, current_UID) EQ NULL)
     {
       strcat (UIDs_list, current_UID);

       (*Num_UIDs) = (*Num_UIDs) + 1;                     /* PS0354 */

       /* Is it the last value in the field values list ? */
       field_ptr = strtok (NULL, entry_sep);

       if (field_ptr NE NULL)
       {
         ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                         "Not last UID. Add ENTRY SEP");
         strcat (UIDs_list, entry_sep);
         continue;
       }
       else
         break;
     };

     ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,
                     "Move to next field value");

     field_ptr = strtok (NULL, entry_sep);
   };

   exit:;

   if (faddinfo EQ NULL)                                  /* PS0354 */
     if (laddinfo NE NULL)
      ADDINFO_free(&laddinfo);

   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func , rc);

   return rc;
 }
 /* End of PS0321 */

/******************************************************************
 * Procedure Name: ACF2_Get_INF
 ******************************************************************
 * Description   : Get Infostorage Record
 *
 *                 The routine returns a single GSO record where many
 *                 records may match the sysid/recname combination.
 *
 *                 2 processing logics may be used:
 *
 *                 Return matching records (sysid,recname). Use Get
 *                 Next logic to retrieve more records.
 *
 *                 Return Best Match Record: Return a single record
 *                 from set of records matching (sysid,recname).
 *
 *
 *
 * Input         : record     - Infostorage Record Key Fields
 *                 match      - Match Type (Best,  Any Match)
 *
 * Output        : current_record - Current Infstor record for get next
 *                 addinfo    - Infostor record fields
 *                 errmsg     - Error Message from low-level
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in processing
 *********************************************************************/
static ACF2_API_Return_Codes  ACF2_Get_INF  ( ACF2_INF_record *record,
                                        ACF2_INF_record *current_record,
                                        ACF2_INF_Match  match,
                                        ADDINFO_rec_ptr addinfo,
                                        char            *errmsg)

 {

   static         char func[]="ACF2_Get_INF";
   ADDINFO_rec_ptr laddinfo = NULL;
   ACF2_API_Return_Codes rc = 0;

   char Best_Sysid[ACF2_SYSID_SIZE];
   char Current_Sysid[ACF2_SYSID_SIZE];
   char Current_Recid[ACF2_RECID_SIZE] = "";

   int Best_Found = FALSE , Continue = TRUE;

   /*---------------------------------------------------------------*/

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func );

   if (ADDINFO_alloc(func, ACF2_ADDINFO, &laddinfo, NULL, NULL)
         NE ESA_OK)
    {
      rc = ACF2_Internal_Error;
      goto exit;
     };

   Reset_Field(Best_Sysid,sizeof(Best_Sysid),'*',NULL);
   Reset_Field(errmsg,sizeof(errmsg),'*',"");

   memset(Current_Sysid,0X00,sizeof(Current_Sysid));

   ADDINFO_empty(addinfo);

   if (match EQ ACF2_INF_Get_Match)
    Continue = FALSE;

 /********************************************************************
 * Get Records Loop: Single Record for Any_Match                     *
 *                   Get All Matching Records and return Best Match  *
 *********************************************************************/
   do {

     ADDINFO_empty(laddinfo);
     rc = ACF2_Get_INFRec(record,
                        current_record,
                        laddinfo,
                        errmsg);

   switch(rc) {

     case ACF2_OK:

      Get_SYSID_Component(current_record,Current_Sysid);
      Get_RECID_Component(current_record,Current_Recid);

      switch(match) {
         /***************************************************
          * If Best Match Found: Update Return Candidate    *
          *                      (see default processing)   *
          ***************************************************/
        case ACF2_INF_Get_Best_Match:

           Best_Found = Check_Best_Match(Best_Sysid,Current_Sysid);

           if (Best_Found EQ FALSE)
             continue;

         /***************************************************
          * If Any Match       : Update Return Candidate    *
          ***************************************************/
        default:
             ADDINFO_empty(addinfo);
             ADDINFO_copy(addinfo,laddinfo);
             /***************************************************
              * Add virtual SYSID field to returned ADDINFO     *
              ***************************************************/
             if (NOT sysid_is_profile(Current_Sysid,ESA_COMP_GTUG2UC)){
                strcat(Current_Recid,".SYSID");
                ADDINFO_insert(TYPE_1A,
                               Current_Recid,
                               Current_Sysid,
                               addinfo,
                               ACF_ADDINFO_KWD_LEN,
                               ACF_ADDINFO_VAL_LEN,
                               UNIQUE);
             }
         };
        break;

    /***************************************************
     * If No More Matches : Return Candidate (if any)  *
     *                      OR "Not Found"             *
     ***************************************************/
     case ACF2_Not_Found:
        Continue = FALSE;
        if (match EQ ACF2_INF_Get_Best_Match)
          if (addinfo->pair NE NULL)
           rc = ACF2_OK;

    /***************************************************
     * If Error:            Exit with error rc         *
     ***************************************************/
     default:;
      Continue = FALSE;
    };
   } while(Continue EQ TRUE);

   exit:;

   if (laddinfo NE NULL) {
    ADDINFO_free(&laddinfo);
   }

   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func , rc);
   return rc;
 }

/******************************************************************
 * Procedure Name: ACF2_Get_InfRec
 ******************************************************************
 * Description   : Get Infostorage Record Low-Level Interface
 *
 *                 The routine returns a single GSO record according
 *                 to an Infrec Structure setup:
 *                 a. Key: Record Class ('C' - control)
 *                         Record Type  ('GSO' - gso record)
 *                         Record Name  ('PSWD', 'OPTS', etc.)
 *                 b. Sysid: Specific or Mask
 *
 *
 *
 * Input         : record     - Infostor record to retrieve (keys)
 *
 * Output        : current_record - Current Infstor record (for getnext)
 *                 addinfo    - Infostor record fields
 *                 errmsg     - Error Message from low-level
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error in processing
 *********************************************************************/
 static ACF2_API_Return_Codes  ACF2_Get_INFRec(ACF2_INF_record *record,
                                        ACF2_INF_record *current_record,
                                        ADDINFO_rec_ptr addinfo,
                                        char       *errmsg)

 {

   static         char func[]="ACF2_Get_INFRec";
   ACF2_INF_record Temp_Record;
   char           buffer[ACF2_ARE_BUFFER_LENGTH];
   int            rc1 = 0;
   ACF2_API_Return_Codes rc = 0;
   int            buffer_length = ACF2_ARE_BUFFER_LENGTH;
   /* IS10119 char        ACF2_msgid[8]; missing null char at end */
   char           ACF2_msgid[9] = {0,0,0,0,0,0,0,0,0};    /*IS10119*/
   char           recid[ACF2_RECID_SIZE+1];
   char           sysid[ACF2_SYSID_SIZE+1];
   char           TOD[15];
   char           last_lid[ACF2_LID_SIZE];
   char           last_tod[9];
   char           field_name[256] = "";

   /*BS10120ESA_DIAG_enter(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,func);*/
   ESA_DIAG_enter(PLT_COMP_API_ACF2, 6, func );              /*BS10120*/

   memset(last_lid,0X00,sizeof(last_lid));
   memset(last_tod,0X00,sizeof(last_tod));
   memset(TOD,0X00,sizeof(TOD));
   memset(recid,0X00,sizeof(recid));
   memset(buffer,0X00,4);

   *errmsg = NULL_CHAR;

   Temp_Record = *record;

 /*if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE DEBUG_SHOW_ALL)*/
 if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE 6)      /*BS10120*/
  {
   SNAP_AREA( "Before GSO Record", &Temp_Record, 64)
   SNAP_AREA( "Before Current Record", current_record,64)
  };
 /********************************************************************
 * Call ACF2 low-level API (ACNTRY SVC Call)                         *
 *********************************************************************/
  /* SAS2IBMT cts2ntr(&Temp_Record,                                  */
  (*(ASM_RTN_TYP *)&cts2ntr)(&Temp_Record,                /* SAS2IBMT */
           current_record,
           last_lid,
           last_tod,
           &buffer_length,
           buffer,
           &rc1,
           errmsg);

 /*if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE DEBUG_SHOW_ALL)*/
 if ((ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE 6) AND /*BS10120*/
    (rc1 EQ 0))
    {
     SNAP_AREA( "After Record", &Temp_Record, 64)
     SNAP_AREA( "After Current Record", current_record, 64)
     SNAP_AREA( "ARE Buffer", buffer, 256)
    };

   switch(rc1)
    {
     /*************************************************************
      * Record Retrieved: Convert Returned AREs                   *
      *                   Add virtual fields (last update lid,    *
      *                                       last update tod)    *
      *************************************************************/
     case 0:  rc = ACF2_OK;
                Get_RECID_Component(current_record,
                                    recid);
                Get_SYSID_Component(current_record,
                                    sysid);
                /* for profile records  dont use RECID as prefix */
                if (sysid_is_profile(sysid,ESA_COMP_GTUG2UC)) {
                   strcat(sysid,".");
                   Process_AREs((ARE_typ *) buffer,
                                sysid,
                                addinfo);

                }
                else {
                   strcat(recid,".");
                   Process_AREs((ARE_typ *) buffer,
                                recid,
                                addinfo);

                   strcpy(field_name,recid);
                   strcat(field_name,"LASTLID");
                   ADDINFO_insert(TYPE_1A,
                                  field_name,
                                  last_lid,
                                  addinfo,
                                  ACF_ADDINFO_KWD_LEN,
                                  ACF_ADDINFO_VAL_LEN,
                                  UNIQUE);

                   convert_tod_to_YYYYMMDDHHMMSS(last_tod,TOD);
                   ESA_DIAG_printf(PLT_COMP_API_ACF2, 6,
                     "last_tod as string=<%s>",TOD);        /*BS10120*/
                   strcpy(field_name,recid);
                   strcat(field_name,"LASTTOD");
                   ADDINFO_insert(TYPE_1A,
                                  field_name,
                                  TOD,
                                  addinfo,
                                  ACF_ADDINFO_KWD_LEN,
                                  ACF_ADDINFO_VAL_LEN,
                                  UNIQUE);
                }
              break;

     /*************************************************************
      * Record Not Retrieved: Record Not Found status (ACF2 EOF)  *
      *************************************************************/
     case 4:  strncpy(ACF2_msgid,errmsg,8);
              if ( (strcmp(ACF2_msgid,ACF2_EOF) EQ 0)      OR
                   (strcmp(ACF2_msgid,ACF2_NOT_FOUND) EQ 0) )
                rc = ACF2_Not_Found;
              else
                rc = ACF2_Internal_Error;
              break;

     /*************************************************************
      * Record Not Retrieved: Internal Error                      *
      *************************************************************/
     case 8:  rc = ACF2_Internal_Error;
              strcpy(errmsg,"ACF2 Control Block Error");
              break;

     /*************************************************************
      * Record Not Retrieved: Acf2 Not Active                     *
      *************************************************************/
     case 12:  rc = ACF2_ACF2_Not_Active;
              break;

     /*************************************************************
      * Record Not Retrieved: Acf2 Internal Error                 *
      *************************************************************/
     default: rc = ACF2_Internal_Error;
              strcpy(errmsg,"Unknown ACF2 return code");
              break;
     };


   exit:;

   /* ESA_DIAG_exit(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,func,rc); */
   ESA_DIAG_exit(PLT_COMP_API_ACF2, 6, func , rc);        /*BS10120*/
   return rc;
 }

 /******************************************************************
 * Procedure Name: Create_Infrec_Id
 *******************************************************************
 * Description   : Creates access strcuture to infostor records
 *
 *                 The routine sets up a strcuture for using infostor
 *                 access services. Based on the following input:
 *                 a. Key: Record Class ('C' - control)
 *                         Record Type  ('GSO' - gso record)
 *                         Record Name  ('PSWD', 'OPTS', etc.)
 *                 b. Sysid: Specific or Mask
 *                 c. Masking information for both record name and sysid
 *
 * Input         : class      - Infostor record class (i.e. 'C')
 *                 type       - Infostor record type  (i.e. 'GSO')
 *                 sysid_masked - Indication if Sysid is masked
 *                 sysid        - requested record's sysid
 *                 recnid_masked - Indication if Record name is masked
 *                 recid        - requested record's id
 *
 * Output        : Infrec     - Resulting Record
 *
 * Return Value  : None
 *********************************************************************/
 static void Create_InfRec_Id(ACF2_INF_record *InfRec,
                        char      *class,
                        char      *type,
                        ACF2_Object_Mask sysid_masked,
                        char      *sysid,
                        ACF2_Object_Mask recid_masked,
                        char      *recid)
 {
  InfRec->INF_class = *class;
  memcpy(InfRec->INF_type,type,strlen(type));

  if (sysid_masked EQ ACF2_Object_is_Masked) {
    InfRec->INF_sysid_masked = 'Y';
     }
  else {
    InfRec->INF_sysid_masked = 'N';
  }
  if (recid_masked EQ ACF2_Object_is_Masked) {
    InfRec->INF_recid_masked = 'Y';
  }
  else  {
    InfRec->INF_recid_masked = 'N';
  }

  InfRec->INF_sysid_length = strlen(sysid);
  InfRec->INF_recid_length = strlen(recid);
  strcpy(InfRec->INF_key,sysid);
  strcat(InfRec->INF_key,recid);
 }

 /******************************************************************
 * Procedure Name: Check_Best_Match
 *******************************************************************
 * Description   : Check if current Record (Sysid,Recid) is better
 *                 then current Best Match.
 *
 *                 The implemented algorithm look for the most specific
 *                 sysid mask matching current ACF2 Sysid.
 *
 * Input         : Current_Sysid - sysid to check
 *
 * Input/Output  : Best_Sysid    - Best Sysid found so far
 *
 * Return Value  : TRUE - Better match found
 *                 FALSE- Current Best Match remains
 *********************************************************************/
static int  Check_Best_Match(char *Best_Sysid,char *Current_Sysid)
 {
  int rc = FALSE;
  char ACF2_Sysid[ACF2_SYSID_SIZE];
  char *blank_loc;
  static char func[]="Check_Best_Match";                /* WS10005 */

  ESA_DIAG_enter(PLT_COMP_API_ACF2, 10, func );         /* WS10005 */
  memset(ACF2_Sysid,0X00,sizeof(ACF2_Sysid));

  /*************************************************************
   * Get Current ACF2 Sysid                                    *
   *************************************************************/
  /* SAS2IBMT cts2sys(ACF2_Sysid,                                    */
  (*(ASM_RTN_TYP *)&cts2sys)(ACF2_Sysid,                  /* SAS2IBMT */
          &rc);

  /*************************************************************
   * Adjust Sysid Length                                       *
   *************************************************************/
  blank_loc = strpbrk(ACF2_Sysid," ");
  if (blank_loc NE NULL)
   (*blank_loc) = NULL_CHAR;

  /*************************************************************
   * If a record was found with sysid matching ACF2 sysid, dont*
   * bother with other records.                                *
   *************************************************************/
  if (strcmp(ACF2_Sysid, Best_Sysid) EQ 0)
   goto exit;

  ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,
         "Find_Best_Match(Before): ACF2=%s Current=%s Best=%s",
         ACF2_Sysid,Current_Sysid, Best_Sysid);

  /*************************************************************
   * If ACF2 sysid is masked by Current Sysid - Continue Check *
   *************************************************************/
  if (ACF2_Match_Id_to_Mask(LID_Object,ACF2_Sysid,Current_Sysid)
           EQ TRUE)
    {
    /*************************************************************
     * If Current Record Sysid is masked by Best Sysid:          *
     * a new best is found (a more specific sysid mask that match*
     * acf2 sysid was found).                                    *
     *************************************************************/
     if (ACF2_Match_Id_to_Mask(LID_Object,Current_Sysid,Best_Sysid)
           EQ TRUE)
     {
      rc = TRUE;
      strcpy(Best_Sysid,Current_Sysid);
     };
    };

  ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,
         "Find_Best_Match(after): ACF2=%s Current=%s Best=%s",
         ACF2_Sysid,Current_Sysid, Best_Sysid);


  exit:;

  ESA_DIAG_exit(ESA_COMP_GTUG2UC, 10,func,rc);        /* WS10005 */
  return rc;
 }

 /******************************************************************
 * WS2370
 * Procedure Name: ACF2_UP_switch_is_activated
 *******************************************************************
 * Description   : Return RC whether user profile switch for the
 *                 respective sysid is activated (ON)
 *
 * Input         : sysid         - sysid key component
 *
 * Output        : RC
 *
 * Return Value  : ESA_OK\ESA_ERR\ESA_FATAL
 *********************************************************************/
ESA_RC ACF2_UP_switch_is_activated(char   *sysid,
                                   ADDINFO_rec_ptr       addinfo)
 {
   ESA_RC                  rc;
   ONE_FIELD_rec_ptr       pair;
   char       ACF2_sysid_switch[ACF2_SYSID_SIZE+UP_SWITCH_CONST_LEN+1];
   char       switch_value[3];

   strcpy (ACF2_sysid_switch, sysid);
   strcat (ACF2_sysid_switch, UP_SWITCH_CONST);

   pair = ADDINFO_search(ACF2_sysid_switch,ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs);
   if (pair NE NULL) {
      memset(switch_value,0X00,sizeof(switch_value));
      strcpy (switch_value,pair->value);
      if (strncmp(switch_value,"Y",1) EQ 0) {
         rc = ESA_OK;
      }
      else if (strncmp(switch_value,"N",1) EQ 0) {
         rc = ESA_ERR;
      }
   }
   else {
      rc = ESA_FATAL;
   }

   return rc;
 }

 /******************************************************************
 * Procedure Name: sysid_is_profile
 *******************************************************************
 * Description   : Return Boolean value whether sysid is a profile
 *
 * Input         : sysid         - sysid key component
 *
 * Output        : none
 *
 * Return Value  : True\False
 *********************************************************************/
static int sysid_is_profile(char               *sysid,
                            ESA_DIAG_COMP_typ  comp)
 {
   int      rc = FALSE;
   int      i;
   for(i=0; UP_kdts[i].UP_name[0] NE NULL_CHAR;i++)
   {
     if (strcmp(UP_kdts[i].UP_name,sysid) EQ 0) {
        rc = TRUE;
        break;
     }
   };
   return rc;
 }

 /******************************************************************
 * Procedure Name: Get Sysid Component
 *******************************************************************
 * Description   : Return Sysid Part of infostor record
 *
 * Input         : record        - ACF2 Inf Record
 *
 * Output          sysid         - sysid key component
 *
 * Return Value  : None
 *********************************************************************/
static void Get_SYSID_Component(ACF2_INF_record *record,
                                char *sysid)
 {
  memcpy(sysid,record->INF_key,record->INF_sysid_length);
  sysid[ACF2_SYSID_SIZE-1] = NULL_CHAR;
  if (strpbrk(sysid," ") NE NULL)
   *(strpbrk(sysid," ")) = NULL_CHAR;
 }

 /******************************************************************
 * Procedure Name: Get Recid Component
 *******************************************************************
 * Description   : Return Recid Part of infostor record
 *
 * Input         : record        - ACF2 Inf Record
 *
 * Output          recid         - recid key component
 *
 * Return Value  : None
 *********************************************************************/
static void Get_RECID_Component(ACF2_INF_record *record,
                                char *recid)
 {
  memcpy(recid,
         record->INF_key + record->INF_sysid_length,
         record->INF_recid_length);
  recid[ACF2_RECID_SIZE-1] = NULL_CHAR;
  if (strpbrk(recid," ") NE NULL)
   *(strpbrk(recid," ")) = NULL_CHAR;
 }

 /********************************************************************
 * C O N V E R S I O N      R o u t i n e s
 *********************************************************************
 * This section maps various conversion routines from ACF2 formats to
 * ESS/API Universal formats.
 *********************************************************************/

 /********************************************************************
 * Procedure Name: convert_binary_to_char
 *********************************************************************
 * Description   : convert a binary (4-byte int) to char
 *
 * Input         : field in      - pointer to 4 byte int
 *
 * Output          field_out     - character string containg number
 *********************************************************************/
 static void convert_binary_to_char(char *field_in, char *field_out)
  {
   sprintf(field_out,"%d",*((int *) field_in));
   }

 /********************************************************************
 * Procedure Name: convert_bit_to_char
 *********************************************************************
 * Description   : convert a bit to char
 *
 * Input         : field in      - pointer to X'00' or X'01'
 *
 * Output          field_out     - KWD_FLAG_OFF / KWD_FLAG_ON
 *********************************************************************/
 static void convert_bit_to_char(char *field_in, char *field_out)
  {
   if (field_in[0] EQ NULL_CHAR)
    strcpy(field_out,KWD_FLAG_OFF);
   else
    strcpy(field_out,KWD_FLAG_ON);
   }

 /********************************************************************
 * Procedure Name: convert_date_to_char
 *********************************************************************
 * Description   : convert an ACF2 packed decimal date to ESS Date
 *                 (uses general routine ctsacvd)
 *
 * Input         : field in      - pointer to 4 byte packed field
 *
 * Output        : field_out     - ESS DATE: YYYYMMDD
 *********************************************************************/
 static void convert_date_to_YYYYMMDD
        (char *date_in, char *date_out)
  {
   int dummy_time = 0;
   char dummy_time_char[6]="";

  /* SAS2IBMT ctsacvd(&debug,(int *) date_in, &dummy_time,           */
  (*(ASM_RTN_TYP *)&ctsacvd)(&debug,(int *) date_in, &dummy_time,
           date_out,dummy_time_char);                     /* SAS2IBMT */
   }

 /********************************************************************
 * Procedure Name: convert_time_to_char
 *********************************************************************
 * Description   : convert an ACF2 time field to ESS time
 *                 (uses general routine ctsacvd)
 *
 * Input         : field in      - pointer to 4 byte binary field
 *                                 representing time
 *
 * Output        : field_out     - ESS TIME: HHMMSS
 *********************************************************************/
 static void convert_time_to_HHMMSS (char *time_in, char *time_out)
  {
   int dummy_date = 0X0099365F;
   char dummy_date_char[9]="";

  /* SAS2IBMT ctsacvd(&debug,&dummy_date,(int *) time_in,            */
  (*(ASM_RTN_TYP *)&ctsacvd)(&debug,&dummy_date,(int *) time_in,
                  dummy_date_char,time_out);              /* SAS2IBMT */
   }

 /********************************************************************
 * Procedure Name: convert_tod_to_YYYYMMDDHHMMSS
 *********************************************************************
 * Description   : convert time+date to ESS TOD
 *                 (uses general routine ctsacvd)
 *
 * Input         : field in      - pointer to 8 byte binary field
 *                                 representing date+time
 *
 * Output        : field_out     - ESS TOD: YYYYMMDDHHMMSS
 *********************************************************************/
 void convert_tod_to_YYYYMMDDHHMMSS (char *tod_in, char *tod_out)
  {
   /* SAS2IBMT
   ctsacvd(&debug,(int *) tod_in,(int *)(tod_in+4),tod_out,tod_out+8);*/
  (*(ASM_RTN_TYP *)&ctsacvd)(&debug,(int *) tod_in,(int *)(tod_in+4),
                             tod_out,tod_out+8);          /* SAS2IBMT */
   }

 /********************************************************************
 * Procedure Name: convert_hex_to_char
 *********************************************************************
 * Description   : convert hexadecimal field to char
 *
 * Input         : field in      - pointer to area
 *               : field length  - area length
 *
 * Output        : field_out     - double size area contain hex value
 *********************************************************************/
 static void convert_hex_to_char(char *field_in, int field_length,
                                 char *field_out)
  {
   int   i;

   for (i=0;i LT field_length*2;i+=2)
    {
     sprintf(field_out+i,"%2.2X",field_in[i/2]);
     }
   }

 /********************************************************************
 * Procedure Name: convert_encr_to_char
 *********************************************************************
 * Description   : convert encrypted field to char
 *
 * Input         : field in      - pointer to area
 *               : field length  - area length
 *
 * Output        : field_out     - area of '*'
 *********************************************************************/
 static void convert_encr_to_char(char *field_in,
                                  int field_length,
                                  char *field_out)
  {
   if (field_length GT 0)
     memset(field_out,'*',field_length);
  }

 /********************************************************************
 * Procedure Name: convert_multi_bin_to_char
 *********************************************************************
 * Description   : convert ACF2 multivalue field to ESS list field
 *
 * Input         : field in      - pointer to area
 *
 * Output        : field_out     - ESS list field
 *********************************************************************/
 static void convert_multi_bin_to_char(char *field_in,
                                  char *field_out)
  {
   short entrys      = 0;
   char  *current_entry;
   short i;

   union {
    short entry_length;
    char  entry_length_char[2];
   } sfl;

   /* int   entry_value_temp; */
   char  entry_value_temp_char[4];

   char  entry_value[11];
   char  sep[2];

   sep[0] = ADDINFO_LIST_ENTRY;
   sep[1] = NULL_CHAR;

   memcpy(&entrys,field_in,2);
   current_entry = field_in+2;
   sfl.entry_length = 0;

   for(i=0;i LT entrys;i++)
    {
     memset(entry_value,0X00,sizeof(entry_value));
     sfl.entry_length_char[1]= *current_entry;
     memcpy(entry_value_temp_char,current_entry+1,sfl.entry_length);
     sprintf(entry_value,"%d",*((int *) entry_value_temp_char));
     current_entry += sfl.entry_length + 1;
     strcat(field_out,entry_value);
     strcat(field_out,sep);
  }
  if (strlen(field_out) GT 0)
   field_out[strlen(field_out)-1] = NULL_CHAR;
 }

 /********************************************************************
 * Procedure Name: convert_multi_to_char
 *********************************************************************
 * Description   : convert ACF2 multivalue field to ESS list field
 *
 * Input         : field in      - pointer to area
 *
 * Output        : field_out     - ESS list field
 *********************************************************************/
 static void convert_multi_to_char(char *field_in,
                                   char *field_out)
  {
   short entrys      = 0;
   char  *current_entry;
   short i;

   union {
    short entry_length;
    char  entry_length_char[2];
   } sfl;

   char  entry_value[256];
   char  sep[2];

   sep[0] = ADDINFO_LIST_ENTRY;
   sep[1] = NULL_CHAR;

   memcpy(&entrys,field_in,2);
   current_entry = field_in+2;
   sfl.entry_length = 0;

   for(i=0;i LT entrys;i++)
    {
     memset(entry_value,0X00,sizeof(entry_value));
     sfl.entry_length_char[1]= *current_entry;
     memcpy(entry_value,current_entry+1,sfl.entry_length);
     current_entry += sfl.entry_length + 1;
     strcat(field_out,entry_value);
     strcat(field_out,sep);
  }
  if (strlen(field_out) GT 0)
   field_out[strlen(field_out)-1] = NULL_CHAR;
 }

 /********************************************************************
 * Procedure Name: convert_2Bmulti_to_char
 *********************************************************************
 * Description   : convert ACF2 multivalue field to ESS list field
 *                 same as convert_multi_to_char, except that length
 *                 field is 2 bytes long instead of 1 byte.
 *
 * Input         : field in      - pointer to area
 *
 * Output        : field_out     - ESS list field
 *********************************************************************/
 static void convert_2Bmulti_to_char(char *field_in,
                                   char *field_out)
  {
   short entrys       = 0;
   short curr_entry_length = 0;
   char  *current_entry;
   short i;
/*
   union {
    short entry_length;
    char  entry_length_char[2];
   } sfl;  */

   char  entry_value[1023];
   char  sep[2];

   sep[0] = ADDINFO_LIST_ENTRY;
   sep[1] = NULL_CHAR;

   memcpy(&entrys,field_in,2);
   current_entry = field_in+2;
   curr_entry_length = 0;

   for(i=0;i LT entrys;i++)
    {
     memset(entry_value,0X00,sizeof(entry_value));
     memcpy(&curr_entry_length,current_entry,2);
     memcpy(entry_value,current_entry+2,curr_entry_length);
     current_entry += curr_entry_length + 2;
     strcat(field_out,entry_value);
     strcat(field_out,sep);
  }
  if (strlen(field_out) GT 0)
   field_out[strlen(field_out)-1] = NULL_CHAR;
 }

 /******************************************************************
 * Procedure Name: Process_AREs
 *******************************************************************
 * Description   : Convert ACF2 AREs chain to ADDINFO structure
 *
 *                 ACF2 may return results in 2 formats: AREs and
 *                 XAREs. XAREs are more complicated and flexible.
 *                 Currently (ACF2 6.1) ACF2 returns only AREs. So,
 *                 XARE is not debugged. For next versions, XARE
 *                 processing should be debugged.
 *
 * Input         : are_ptr       - pointer to returned ARE buffer
 *                 prefix        - add prefix to resulting keyword
 *                                 names in ADDINFO (includes ".")
 *
 * Output        : laddinfo      - resulting ADDINFO struc
 *********************************************************************/
 static void Process_AREs(ARE_typ *are_ptr,
                         char    *prefix,
                         ADDINFO_rec_ptr laddinfo)
 {
   static char func[]="Process_AREs";                    /* WS10005 */
   XARE_Header_typ  *xare_hptr;
   XARE_Value_typ  *xare_ptr;

   char           field_name[ACF2_FIELDNAME_SIZE];
   char           extended_field_name[256];
   char           field_value[2048];
   char           out_field_value[4096];
   int            i, field_length;
   int            Last_ARE ;
   char           field_msg[2048]="";
   char           field_cat[2048]="";
   int            value_field_len;        /* WS2565 */

   ESA_DIAG_enter(PLT_COMP_API_ACF2, 10, func ); /* WS10005 */
  /*************************************************************
   * Process ALL AREs                                          *
   *************************************************************/
   if ( *((short *) are_ptr) EQ 0)
    goto exit;

   do
    {
     memset(field_name,0X00,sizeof(field_name));
     memcpy(field_name,are_ptr->ARE_Field_Name,8);

 /*****              ws10006 start                     ******/
 /* convert '#' to '@' , for compatability with "ess" field-names*/
     if (strpbrk(field_name,"#") NE NULL) {
        ESA_DIAG_printf(PLT_COMP_API_ACF2,6,
            "Field with # changed (%s)",
            field_name);
        while(strpbrk(field_name,"#") NE NULL)
          *strpbrk(field_name,"#") = '@';

        ESA_DIAG_printf(PLT_COMP_API_ACF2,6,
            "New field named (%s)",
            field_name);
     }
 /*****              ws10006 end                       ******/

     memset(extended_field_name,0X00,sizeof(extended_field_name));
     memset(field_value,0X00,sizeof(field_value));
     memset(out_field_value,0X00,sizeof(out_field_value));

     /*WS10005 printf(field_msg,"Process_ARE: Name(%s) ",field_name);*/
     sprintf(field_msg,"Name(%s) ",field_name);        /* WS10005 */

    /*************************************************************
     * Is this an XARE (not yet used by ACF2 (version 6.1))      *
     * Yes: Setup environment (field name,length,type,value)     *
     *************************************************************/
     if (are_ptr->ARE_Type & ARE_IS_XARE)
      {
       strcat(field_msg,"XARE ");
       xare_hptr = (XARE_Header_typ *) &(are_ptr->ARE_Value_Length);

       /* CHECK !!!!!! is Value_Offset from begin of XARE extension
          of from ARE begining !!!!! */

       xare_ptr = (XARE_Value_typ *)  (xare_hptr +
                                       xare_hptr->XARE_Value_Offset);

       field_length = xare_ptr->XARE_Value_Length;
       memcpy(field_value,&(xare_ptr->XARE_Value),
              xare_ptr->XARE_Value_Length);
      }
     else
      {
       /*************************************************************
        * Is this an ARE                                            *
        * Yes: Setup environment (easy)                             *
        *************************************************************/
       strcat(field_msg,"ARE ");

       field_length = are_ptr->ARE_Value_Length;

       memcpy(field_value,&(are_ptr->ARE_Value),field_length);
      };

     sprintf(field_cat,"val(%s) ",field_value);
     strcat(field_msg,field_cat);
     sprintf(field_cat,"len(%d) ",field_length);
     strcat(field_msg,field_cat);

     /*************************************************************
      * Handle field value conversions based on field types       *
      *************************************************************/
     switch(are_ptr->ARE_Field_Type)
      {
       case ARE_BINARY:
        if (are_ptr->ARE_Type & ARE_IS_MULTI) /* WS2370 */
         {
           convert_multi_bin_to_char(field_value,out_field_value);
         }
        else {
           convert_binary_to_char(field_value,out_field_value);
        }
        sprintf(field_cat,"bin(%s) ",out_field_value);
        break;

       case ARE_CHAR:
        if (are_ptr->ARE_Type & ARE_IS_MULTI)
         {
           if (are_ptr->ARE_Type EQ ARE_IS_2BMULTI) { /* WS2370 */
             convert_2Bmulti_to_char(field_value,out_field_value);
           }
           else
             convert_multi_to_char(field_value,out_field_value);
         }
        else
         {
           memcpy(out_field_value,field_value,field_length);
           out_field_value[field_length] = NULL_CHAR;
           for (i=0;i LT field_length;i++)
            if (out_field_value[i] EQ NULL_CHAR)
             out_field_value[i] = ' ';
           Trim(out_field_value);
         };
        sprintf(field_cat,"chr(%s) ",out_field_value);
        break;

       case ARE_PACKED:
        convert_date_to_YYYYMMDD(field_value,out_field_value);
        sprintf(field_cat,"date(%s) ",out_field_value);
        break;

       case ARE_TIME:
        convert_time_to_HHMMSS(field_value,out_field_value);
        sprintf(field_cat,"time(%s) ",out_field_value);
        break;

       case ARE_BIT:
        convert_bit_to_char(field_value,out_field_value);
        sprintf(field_cat,"bit(%s) ",out_field_value);
        break;

       case ARE_TOD:
        convert_tod_to_YYYYMMDDHHMMSS(field_value,out_field_value);
        sprintf(field_cat,"TOD(%s) ",out_field_value);
        break;

       case ARE_HEX:
        convert_hex_to_char(field_value,field_length,out_field_value);
        sprintf(field_cat,"hex(%s) ",out_field_value);
        break;

       case ARE_ENCR:
        convert_encr_to_char(field_value,field_length,out_field_value);
        sprintf(field_cat,"encr(%s) ",out_field_value);
        break;

       default:
        sprintf(field_cat,"SKIPPED %X ",are_ptr->ARE_Field_Type);
        goto skip_field;
      };

     strcat(field_msg,field_cat);

     /* IS0371:
     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,field_msg);*/

     /* IS0371:
        add %s to ESA_DIAG_printf when printing only string.
        possible variable contains format character (like %d) */
     ESA_DIAG_printf(PLT_COMP_API_ACF2,
                     DEBUG_SHOW_REGULAR,
                     "%s",
                     field_msg);

    /*************************************************************
     * Build Resulting field name (include prefix)               *
     *************************************************************/
     strcpy(extended_field_name,prefix);
     strcat(extended_field_name,field_name);

     if (strpbrk(extended_field_name," ") NE NULL)
      *(strpbrk(extended_field_name," ")) = NULL_CHAR;

     while(strpbrk(extended_field_name,"-") NE NULL)
      *strpbrk(extended_field_name,"-") = '_';

     /* WS2565: Start here
        Support PSWXHST# keyword. # is not supported as
        ESS keyword name, so special treat is given.
        # is replaced with N */

     if ( strcmp(extended_field_name, "PSWD.PSWXHST#" ) EQ 0 ) {
        strcpy( extended_field_name, "PSWD.PSWXHST@" ); /*ws10006*/
     /*ws10006 strcpy( extended_field_name, "PSWD.PSWXHSTN" );*/
     }
     else if ((strcmp(extended_field_name, "PSWD.PSWDPLST")     EQ 0) OR
              (strcmp(extended_field_name, "PWPHRASE.SPECLIST") EQ 0))
              /* check above to support password phrase IS10147A */    {
        value_field_len = strlen(out_field_value);
        if ( value_field_len GT 0 )
           /* Set blanks between fields values */
           for (i = 1;i < value_field_len;i += 2) {
               out_field_value[i] = ' ';
           }
     }
     else if ((strcmp(extended_field_name, "PSWD.PSWDPAIR")    EQ 0) OR
              (strcmp(extended_field_name, "PWPHRASE.REPCHAR") EQ 0))
              /* check above to support password phrase IS10147A */   {
        if ( strcmp(out_field_value, "255") EQ 0 )
            strcpy(out_field_value,"N"); /* N -> for Null indication */
     }

    /*  WS2565 ended here */

    /*************************************************************
     * Insert Field Name + Value to resulting ADDINFO            *
     *************************************************************/
     ADDINFO_insert(TYPE_1A,
                    extended_field_name,
                    out_field_value,
                    laddinfo,
                    ACF_ADDINFO_KWD_LEN,
                    ACF_ADDINFO_VAL_LEN,
                    UNIQUE);

      skip_field:

      /* If not last entry, Increment to next ARE or XARE */

    /*************************************************************
     * Adjust Next ARE/XARE pointers:                            *
     * If last one just processed set Last_ARE flag              *
     *************************************************************/

      Last_ARE = FALSE;

      /* Is it Last */
      if ( (are_ptr->ARE_Last_Entry & ARE_LAST_ENTRY) EQ 0)
       /* Not Last, Handle XARE */
       if (are_ptr->ARE_Type & ARE_IS_XARE)
         are_ptr = (ARE_typ *) ((char *) xare_hptr          +
                                xare_hptr->XARE_Value_Offset+
                                xare_ptr->XARE_Value_Length + 2);
       else
       /* Not Last, Handle ARE */
        {
         are_ptr = (ARE_typ *) ((char *)are_ptr + are_ptr->ARE_Length);
        }
       else
        {
         /* Last, Leave Processing Loop */
         ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_ALL,"Last ARE!");
         Last_ARE = TRUE;
        };
    } while(Last_ARE EQ FALSE);

 exit:;
 ESA_DIAG_exit(ESA_COMP_GTUG2UC, 10,func,0);         /* WS10005z */
}
/*ws2431 - moved ACF2_Get_User_Groups from CTSBGCN */
/******************************************************************
 * Procedure Name: ACF2_Get_User_Groups
 ******************************************************************
 * Description   : Get Group Connected to user
 *                 When Mode = Exact_Locate
 *                 - Check and Return connection status of User to Group
 *                   passed as parameter.
 *                 When Mode = Generic_Locate
 *                 - Get Next Group matching user after last Group
 *                   retrieved.
 *
 * Input         : Mode         - Exact_Locate   (specific group)
 *                                Generic_Locate (poisiton to group)
 *                 UID          - User UID to match group uidmasks
 *                 laddinfo     - pre-allocated laddinfo
 *                 ctsamsg stuff
 *
 * Input/Output  : group        - Last matching group or NULL string
 *
 * Return Value  : ACF2_OK        - Matching Group Found
 *               : ACF2_Not_Found - Matching Group Not Found
 *               : otherwise      - ACF2 Internal Error
 ******************************************************************/
 ACF2_API_Return_Codes ACF2_Get_User_Groups
              (GDB_Locate_Mode mode,
               char   *UID,
               UG_typ Group,
               ADDINFO_rec_ptr laddinfo,
 /* WS10076A*/ ADMIN_PARAMS_rec_typ * admin_params)
 /* WS10076A   CTSAMSG_DEST_TABLE_rec_typ  * dest,
               CTSAMSG_HANDLE_rec_typ      * msgs)
                           * BS2306 - added dest+msgs parms         */
  {

   static char                func[]="ACF2_Get_User_Groups";

   ACF2_API_Return_Codes ACF2_rc = ACF2_OK;
   ESA_RC                rc      = ESA_OK;
   int  i, reason_code = 0;
   int  Group_UID_Count = 0;
   UIDMASK  Group_UID[ACF2_MAX_GRP_UIDMASKS];             /* BS2306 */
   UG_typ Previous_Group = "";
   CTSAMSG_HANDLE_rec_ptr     msgs;                       /*WS10076A*/
   CTSAMSG_DEST_TABLE_rec_ptr  dest;                      /*WS10076A*/

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT, func);
   msgs = admin_params->ctsamsg_handle;                   /*WS10076A*/
   dest = admin_params->ctsamsg_dest;                     /*WS10076 */

   strcpy(Previous_Group,Group);

 /*-------------------------------------------------------------------*/
 /* Re-Position to Group                                              */
 /*-------------------------------------------------------------------*/
   ADDINFO_empty(laddinfo);
   ACF2_rc = ACF2_Get_Group(mode,
                            Group,
                            laddinfo,
                            NULL, NULL,                  /* WS10076S */
                            admin_params);               /* WS10076A */

   if ( (mode EQ GDB_Exact_Locate) OR (ACF2_rc NE ACF2_OK) )
     goto exit;


   if (Previous_Group[0] NE NULL_CHAR)
    {
     ADDINFO_empty(laddinfo);
     ACF2_rc = ACF2_Get_Group(GDB_Next_Locate,
                         Group,
                         laddinfo,
                         NULL, NULL,                     /* WS10076S */
                         admin_params);                  /* WS10076A */
    };

 /*-------------------------------------------------------------------*/
 /* Re-Position  to Group                                             */
 /*-------------------------------------------------------------------*/
   while(ACF2_rc EQ ACF2_OK)
    {
      strcpy(Previous_Group,Group);

      /*----------------------------------------------------------*/
      /* Get Current Group UIDMASKS                               */
      /*----------------------------------------------------------*/
      rc = ACF2_Get_Group_UIDMASKS(Group,
                                   &Group_UID_Count,
                                   Group_UID,
                                   laddinfo,
                                   &reason_code,
                                   admin_params);         /* WS10076A *
                                   dest,                   * BS2306 *
                                   msgs);                  * BS2306 */

      if (rc NE ESA_OK)
       {
        ACF2_rc = ACF2_Internal_Error;
        goto exit;
       };

      /*----------------------------------------------------------*/
      /* Check UIDMASKS against User UID                          */
      /*----------------------------------------------------------*/
      for (i=0;i LT Group_UID_Count;i++)
       {
        ESA_DIAG_printf(ESA_COMP_GTUG2UC, DEBUG_SHOW_REGULAR,
                        "UID(%s) i(%d) of Group %s is (%s)",
                        UID,i,Group,Group_UID[i]); /* BS10049 */
                     /* i,Group,Group_UID[i]);  BS10049 */
        if (ACF2_Match_Id_to_Mask(UID_Object,UID,Group_UID[i]) EQ TRUE)
          goto Group_Found;
       };

      /*----------------------------------------------------------*/
      /* Continue to Next Group                                   */
      /*----------------------------------------------------------*/
     ADDINFO_empty(laddinfo);
     ACF2_rc = ACF2_Get_Group(GDB_Next_Locate,
                         Group,
                         laddinfo,
                         NULL, NULL,                     /* WS10076S*/
                         admin_params);                  /* WS10076A*/
  };

  /*----------------------------------------------------------*/
  /* All group DB scanned, no connection found                */
  /*----------------------------------------------------------*/
  Group_Not_Found:
   ACF2_rc = ACF2_Not_Found;
   goto exit;

  /*----------------------------------------------------------*/
  /* Connection Found                                         */
  /*----------------------------------------------------------*/
  Group_Found:
   ACF2_rc = ACF2_OK;
   goto exit;

  exit:;

   ESA_DIAG_exit(ESA_COMP_GTUG2UC, DEBUG_SHOW_IMPORTANT,func,ACF2_rc);

   return ACF2_rc;
 }
/******************************************************************
 * BS2513
 * Procedure Name: ACF2_User_exists
 ******************************************************************
 * Description   : This function checks if a user exists and returns
 *                 an ACF2 return code.
 *
 *                 The function supports ONLY specific users.
 *                 NO MASKS
 *
 * Input         : lid        - User id
 *
 * Output        : none.
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - User exists
 *                 ACF2_Not_Found      - No user found
 *                 ACF2_Internal_Error - Error in ACF2 processing
 *********************************************************************/
 ACF2_API_Return_Codes ACF2_User_Exists (char     *lid,
       /* bs2556 */                ADMIN_PARAMS_rec_typ * admin_params)

 {
 /*************************************************************
 * Variables                                                  *
 **************************************************************/
   static char           func[]="ACF2_User_Exist";

   char                  buffer[ACF2_ARE_BUFFER_LENGTH] = "";

   int                   rc1 = 0;
   ACF2_API_Return_Codes rc = ACF2_OK;

   int                   buffer_length = ACF2_ARE_BUFFER_LENGTH;
   char                  ALT_Get_Fields = 'N';

   UIDMASK               ACF2_uidmask;
   char                  ACF2_lidmask[ACF2_LID_SIZE];
   /* IS10119 char        ACF2_msgid[8]; missing null char at end */
   char           ACF2_msgid[9] = {0,0,0,0,0,0,0,0,0};    /*IS10119*/
   char                  Mask_char = ' ';

   int                   i = 0, API_Fields_Count = 0;
   char                 *ii = NULL;
   char                  API_Fields[2048] = "";
   char                  Temp_Fields[2048] = "";


   char                 *uidmask = "";
   char                 *Required_Fields= "";
   char                  errmsg[ACF2_ARE_BUFFER_LENGTH] = "";
   char                  ACF2_current_lid[ACF2_LID_SIZE] = "";

   /* BS10070 The following declaration was too small and had to be
              declared larger. Reason: When cts2alt returns with a bad
              return code, errmsg (124 bytes) is concatenated (via
              sprintf) into errmsg1 (128 bytes) with several additional
              constants. This caused an S0C4 because errmsg1 was not
              declared large enough to handle this long msg. This field
              was now increased from 128 to 180 characters.
   char           errmsg1[128] = "";                        bs2556*/
   char           errmsg1[180] = "";            /* bs2556 BS10070 */
   /* The errmsgt field is 1 byte larger than the message BS10070 */
   /* that cts2alt places into the field. This final byte BS10070 */
   /* will later be set to NULL_CHAR when trimming the    BS10070 */
   /* blanks in the message.                              BS10070 */
   char           errmsgt[125];                        /* BS10070 */
   int            j;                                   /* BS10070 */
   CTSAMSG_HANDLE_rec_ptr     msgs;                       /*bs2556*/
   CTSAMSG_DEST_TABLE_rec_ptr  dest;                      /*bs2556*/

   msgs = admin_params->ctsamsg_handle;                   /*bs2556*/
   dest = admin_params->ctsamsg_dest;                     /*bs2556*/

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func );

 /*************************************************************
 * Prepare indication for fields/no_fields retrieval          *
 **************************************************************/
 Reset_Field(ACF2_lidmask,sizeof(ACF2_lidmask),Mask_char,lid);

 Reset_Field(ACF2_uidmask,sizeof(ACF2_uidmask),' ',uidmask);

 Reset_Field(ACF2_current_lid,sizeof(ACF2_current_lid),
             ' ',"");
 /******************************************************************
 * Convert Required Fields string to an ACF2-API 8-Char Entry Vector
 *******************************************************************/
 strcpy(Temp_Fields,Required_Fields);
 strcat(Temp_Fields,",");

 while(i LT strlen(Required_Fields))
  {
   ii = strpbrk(Temp_Fields + i,",");

   if (ii EQ NULL)
    break;

   (*ii) = NULL_CHAR;
   Reset_Field(API_Fields + API_Fields_Count*8,9,' ',
               Temp_Fields + i);
   i = (ii - Temp_Fields) + 1;
   API_Fields_Count++;
   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                   "API field count = (%d), fields =(%s)",
                    API_Fields_Count,API_Fields);

  };

 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR,
                "Final API field count = (%d), fields =(%s)",
                API_Fields_Count,API_Fields);

 /******************************************************************
 * Issue ACF2 API Call to ACALT SVC                                *
 *******************************************************************/
  /* SAS2IBMT cts2alt(ACF2_lidmask,                                  */
  (*(ASM_RTN_TYP *)&cts2alt)(ACF2_lidmask,                /* SAS2IBMT */
         ACF2_uidmask,
         ACF2_current_lid,
         &ALT_Get_Fields,
         &API_Fields_Count,
         API_Fields,
         &buffer_length,
         buffer,
         &rc1,
         errmsg);

  /* The first 124 characters of errmsg does not have a      BS10070 */
  /* NULL_CHAR so when printing the message, we print a      BS10070 */
  /* very long message (until the NULL_CHAR somewhere after  BS10070 */
  /* 124 characters. The following macro 'trims' the message BS10070 */
  /* by placing a NULL_CHAR after the last non-blank char.   BS10070 */
  /* (The loop starts from errmsgt[123] and goes back to     BS10070 */
  /* errmsgt[0] looking for the last non-blank character.)   BS10070 */

  TRIM_BLANKS(errmsg, errmsgt, 124, j)                    /* BS10070 */
  /* All references to errmsg will now be changed to         BS10072 */
  /* errmsgt because this is the field which now contains    BS10072 */
  /* a NULL_CHAR after the last non-blank.                   BS10072 */

 /* IS0071 add some diags (part 2)*/
 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
  "lidmask=(%s),uidmask=(%s),cur_lid=(%s),A_G_Flds=(%s)",
   ACF2_lidmask,ACF2_uidmask,ACF2_current_lid,ALT_Get_Fields);

 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
   "Fields_Count=(%d),Fields=(%s),buffer_length=(%d),buffer_start=(%s)",
    API_Fields_Count,API_Fields,buffer_length,buffer[60]);

 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
   "rc=%d,msg=%s",
    rc1,errmsgt);                         /* errmsg->errmsgt BS10072 */
 /* end of IS0071 */

 if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE DEBUG_SHOW_ALL) {
    SNAP_AREA( "ARE Buffer", buffer, 1024 )
 };

 /******************************************************************
 * Check ACF2 API Rc                                               *
 *******************************************************************/
 switch(rc1)
  {
   case 0:  rc = ACF2_OK;
            break;
            /***************************************************
            * Check EOF Status (via ACF2 Error Messages Codes) *
            ****************************************************/
   case 4:
            /*** send a msg when internal error in acf2 - bs2556 ***/
            sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
            rc1,errmsgt);                 /* errmsg->errmsgt BS10072 */
            CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
            func,errmsg1, 16,__LINE__);
            /******* end of bs2556 fix *******/
            strncpy(ACF2_msgid,errmsgt,8); /* errmsg->errmsgt BS10072 */
            if ( (strcmp(ACF2_msgid,ACF2_EOF) EQ 0)      OR
                 (strcmp(ACF2_msgid,ACF2_NOT_FOUND) EQ 0) )
              rc = ACF2_Not_Found;
            else
              rc = ACF2_Internal_Error;
            break;

            /***************************************************
            * ACF2 Internal Error situations                   *
            ****************************************************/
   case 8:
            /*** send a msg when internal error in acf2 - bs2556 ***/
            sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
            rc1,errmsgt);                 /* errmsg->errmsgt BS10072 */
            CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
            func,errmsg1, 16,__LINE__);
            /******* end of bs2556 fix *******/
            rc = ACF2_Internal_Error;
            break;

            /***************************************************
            * ACF2 Not Active                                  *
            ****************************************************/
   case 12:
            /*** send a msg when internal error in acf2 - bs2556 ***/
            sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
            rc1,errmsgt);                 /* errmsg->errmsgt BS10072 */
            CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
            func,errmsg1, 16,__LINE__);
            /******* end of bs2556 fix *******/
             rc = ACF2_ACF2_Not_Active;
            break;

   default:
            /*** send a msg when internal error in acf2 - bs2556 ***/
            sprintf(errmsg1,"cts2alt Failed, rc=%d msg=%s",
            rc1,errmsgt);                 /* errmsg->errmsgt BS10072 */
            CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
            func,errmsg1, 16,__LINE__);
            /******* end of bs2556 fix *******/
            rc = ACF2_Internal_Error;
            break;
   };

 exit:

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func,rc);
 return rc;
 }

/* WS10079T - Moved ACF2_Get_Xref from CTSBSRV *
 *            with some changes                */
/* WS10079K - Moved ACF2_Get_Xref from CTSBGUG *
 *            with new code                    */
/******************************************************************
 * Procedure Name: ACF2_Get_Xref
 ******************************************************************
 * Description   : This function retrievs returns the Roles or
 *                 Sources read from ACF2 database.
 *                 If no block exists, it allocates it and then
 *                 executes the request.
 *
 * Note:           The routine ACF2_Get_Xref refers to addinfo only
 *                 once before setting the flags in ACF2_Get_Xref_handle
 *                 which decides whether to return active/XREF record
 *                 or not. The scenario of calling ACF2_Get_Xref
 *                 multiple times for one transaction and changing
 *                 the addinfo in between the calls is not supported.
 *                 Also, the flags active_request and need_rec_YN
 *                 from XBHandle can not be used either since these
 *                 flags are referred to get what is requested in
 *                 the Xref block but we need a decision what data
 *                 should be returned in addinfo.
 *
 * Input         : - Function
 *                    1. GETTHIS  - Get a specific name[(sysid)]
 *                    2. GETTHISA - Get a specific name[(sysid)]
 *                                  only if it is active.
 *                    3. GETNEXT  - Get the next name/sysid
 *                    4. TERM     - free all.
 *                 - XB_handle
 *                 - ACF2_Get_Xref_handle
 *                 - Blk_to_read - X(ref)/G(roup)/S(hort)/L(ong)
 *                 - Blk_read(O) - X / G  (when blk_to_read=S/L)
 *                 - Xrefname_in
 *                 - Xrefname_out
 *                 - Addinfo
 *
 * Input         : mode       - GET_ALL_ROLES   To get all XROLs
 *                            - GET_ALL_SOURCES To get all XSGPs
 *                            - PB handle
 *
 * Input/Output  : ug_params   - Role or Source returned
 *                 addinfo     - ADDINFO containing Include/Exclude
 *                               list for Source.
 *                               more two parameters Description and
 *                               RoleDirectPermissions for Role.
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - The XREF record Retrieved
 *                 ACF2_Not_Found      - No record to retrieve (EOF)
 *                 ACF2_Internal_Error - Error while processing records
 *********************************************************************/
ACF2_API_Return_Codes ACF2_Get_Xref(
                       char                   * function,
                       XBhandle_rec_typ       * XBhandle,
                       void                  ** xref_handle,
                       char                     block_to_read,
                       char                   * block_read,
                       UG_typ                   xrefname_in,
                       UG_typ                   xrefname_out,
                       ADDINFO_rec_ptr          addinfo,
                       ESA_DIAG_COMP_typ        diag_comp,
                       ADMIN_PARAMS_rec_typ   * admin_params)
{
  static char                     func[]="ACF2_Get_Xref";
  ACF2_API_Return_Codes           aarc = ACF2_OK;
  ESA_RC                          rc = ESA_OK;
  char                            msg[100] = NULL_STRING;
  char                            charToString[2] = NULL_STRING;
  short                           getNext = TRUE, isXrefRec = FALSE;
  /* LID_PERM_handle_rec_typ     *lid_perm_handle = NULL;  WS10079T */
  ACF2_Get_Xref_Handle           *get_xref_handle = NULL;
  ONE_FIELD_rec_ptr               pair = NULL;
  PBhandle_typ                   *PBhandle = NULL;
  PERM_BLK_HDR_rec_typ           *PBheader = NULL;
  PB_rtnblk_ext_rec_typ          *ExtBlockRoutines = NULL;
  XB_PB_SYSID_rtnparms_rec_typ   *XbPbSysIdRtnparms = NULL;
  XB_PB_onlyrec_rtnparms_rec_typ *XbPbOnlyrecRtnparms = NULL;
  XB_GetSYSID_parms_typ          *XbGetSysidParms = NULL;
  XB_GetRec_parms_typ            *XbGetRecParms = NULL;
  char                            outActiveYN = NULL_CHAR;
  char                           *out_xref_rec_ptr = NULL;
  char                            xref_name[XREF_NAME_SIZE]=NULL_STRING;
  char                            sysid[ACF2_SYSID_SIZE] = NULL_STRING;
  short                           isFirstTime = FALSE;
  short                           shouldGetUID = TRUE;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(diag_comp, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if(xref_handle EQ NULL)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                   func, "xref_handle can not be NULL", rc, __LINE__);
     aarc = ACF2_Internal_Error;
     goto cleanup;
  }

  ESA_DIAG_printf(diag_comp ,3,
            "Input function<%s>, XBhandle<%p>, xref_handle<%p>",
             function, XBhandle, xref_handle);

  ESA_DIAG_printf(diag_comp ,3,
            "Input block_to_read<%c>, xrefname_in<%s>, addinfo<%p>",
             block_to_read, xrefname_in, addinfo);

  if (strncmp(function, "TERM", 4) EQ 0)
  {
     ESA_DIAG_printf(diag_comp ,9, "Function received is TERM");
     /* WS10084 start */
     if(*xref_handle NE NULL)
       get_xref_handle = (ACF2_Get_Xref_Handle *) *xref_handle;
     /* WS10084 end   */
     goto cleanup;
  }
  else
  {
     if(strncmp(function,"GET",3) NE 0)
     {
        rc = ESA_FATAL;
        sprintf(msg, "Invalid function received <%s>",function);
        ESA_DIAG_printf(diag_comp, 1, msg);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      func, msg, rc, __LINE__);
        aarc = ACF2_Internal_Error;
        goto cleanup;
     }
  }

  /*                                                         WS10079N
   *   Verify that there is no previous error                WS10079N
   */                                                     /* WS10079N */
  if (XBhandle->bld_nf)                                   /* WS10079N */
  {                                                       /* WS10079N */
    ESA_DIAG_printf(diag_comp, 3,                         /* WS10079N */
                    "Not-Found is on in XBhandle");       /* WS10079N */
    aarc = ACF2_Internal_Error;                           /* WS10079N */
    goto exit;                                            /* WS10079N */
  }                                                       /* WS10079N */
  else if (XBhandle->bld_err)                             /* WS10079N */
  {                                                       /* WS10079N */
    ESA_DIAG_printf(diag_comp, 3,                         /* WS10079N */
                    "Build error is on in XBhandle");     /* WS10079N */
    aarc = ACF2_Not_Found;                                /* WS10079N */
    goto exit;                                            /* WS10079N */
  }                                                       /* WS10079N */

  /* Check if *xref_handle is NULL. If null allocate it */
  if(*xref_handle EQ NULL)
  {
     *xref_handle = (void *) calloc (1, sizeof(ACF2_Get_Xref_Handle));
     if(*xref_handle EQ NULL)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "xref_Handle",
                      sizeof(ACF2_Get_Xref_Handle));
        /* WS10079N rc = ESA_FATAL;  */
        aarc = ACF2_Internal_Error;
        goto cleanup;
     }

     get_xref_handle = (ACF2_Get_Xref_Handle *) *xref_handle;
     ESA_DIAG_printf(diag_comp, 9,
                "allocated get_xref_handle - <%p>", get_xref_handle);
      /* @Check - Do we need ALLOC_STORAGE_DIAG?? */
     ALLOC_STORAGE_DIAG(get_xref_handle,
                        sizeof(ACF2_Get_Xref_Handle),
                        func)
     strcpy(get_xref_handle->recparm,XBhandle->xrefname);
     /* get_xref_handle is not null. Now check if we already *
        have data to be read or we have to build it.         */
     if( (XBhandle->XREF_PB_handle EQ NULL)   AND
         (XBhandle->Groups_PB_handle EQ NULL) )           /* WS10079N */
         /* Ws10079N (XBhandle->Groups_PB_handle EQ NULL) AND
         (XBhandle->bld_err EQ FALSE) )   */
     {
     ESA_DIAG_printf(diag_comp, 9,                        /* WS10084 */
                "Before XREF_Block_Build  BUILD");        /* WS10084 */
        /* ctrace("Before XREF block build");                WS10084 */
        rc = XREF_Block_Build("BUILD",
                              XBhandle,
                              diag_comp,
                              admin_params);

        ESA_DIAG_printf(diag_comp, 9,
                "XREF_Block_Build returned rc - <%i>", rc);

        if( rc NE ESA_OK)
        {
           if (rc EQ ESA_KEY_NOT_FOUND)                   /* WS10079N */
           {                                              /* WS10079N */
             aarc = ACF2_Not_Found;                       /* WS10079N */
             goto cleanup;                                /* WS10079N */
           }                                              /* WS10079N */
           else                                           /* WS10079N */
           {                                              /* WS10079N */
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component, func,
                   "XREF_Block_Build failed to BUILD.",
                   rc, __LINE__);
             /* WS10079N rc = ESA_FATAL;  */
             aarc = ACF2_Internal_Error;
             goto cleanup;
           }                                              /* WS10079N */
        }
     }
     /* WS10084: the XREF blocka may aready exist becuase the first user
        doesn't have roles so that get_user_xrol was not called for it
        and acf2_get_xref has not already built the xref blocks when
        permissions_block_build started scanning the rules list.
        If a ROLESET with ROLE was encountered during the scan it was
        necessary to call xref_block_build at that time to build the
        xref blocks. When a subsequent user has roles, get_user_xrol is
        called and calls acf2_get_xref which discovers that xref block
        is already built. However, now with ACFRPTRX replacement this
        is legitimate.                                                 */

     /* WS10084
     else
     {
        ctrace("XREF block already built");                 /@ WS10084 @/
        rc = ESA_FATAL;
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, "XREF_Block_Build",
                      "The XREF block is already built.",
                      rc, __LINE__);
        aarc = ACF2_Internal_Error;
        goto cleanup;
     }
       WS10084 */

     if( (XBhandle->bld_err EQ TRUE) OR (XBhandle->XB_err EQ TRUE) )
     {
        rc = ESA_FATAL;
        sprintf(msg,"Error set in XBhandle. bld_err=%s, XB_err=%s",
        (XBhandle->bld_err EQ TRUE) ? "TRUE" : "FALSE",
        (XBhandle->XB_err EQ TRUE) ? "TRUE" : "FALSE" );
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, "XREF_Block_Build", msg,
                      rc, __LINE__);
        aarc = ACF2_Internal_Error;
        goto cleanup;
     }

     /* We want to send permissions to ROLE records which are  *
      * active and if permissions should be sent               */

     ESA_DIAG_printf(diag_comp, 9,
       "XBhandle-pbType<%c>,xrefname<%s>,activeChk<%c>,activeDef<%c>",
        XBhandle->PB_type, XBhandle->xrefname, XBhandle->active_check,
        XBhandle->active_default);

     /* WS10079T start
     if( XBhandle->PB_type EQ 'R' )
     {
        if( ((XBhandle->xrefname[0] EQ '-') OR
             (strchr(XBhandle->xrefname,'(') EQ NULL))
            AND (XBhandle->active_check EQ 'N')
            AND (XBhandle->active_default EQ 'U') )
        {
           XBhandle->XREF_PB_handle->WithPermissions = 'N';
        }
        else
        {
           if( (addinfo NE NULL) AND
               (ADDINFO_search("RoleDirectPermissions",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs) NE NULL ) )
              XBhandle->XREF_PB_handle->WithPermissions = 'Y';
           else
              XBhandle->XREF_PB_handle->WithPermissions = 'N';
        }
     ESA_DIAG_printf(diag_comp, 9, "PBhandle->withPerm <%c>",
                     XBhandle->XREF_PB_handle->WithPermissions);
     }
        WS10079T end t */

     if(addinfo NE NULL)
     {
        if (ADDINFO_search("Active",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs) NE NULL )
           get_xref_handle->out_ActiveYN = 'Y';
        else
           get_xref_handle->out_ActiveYN = 'N';

        /* Check if one of Include, Exclude or description  *
         * attribute is present in addinfo. If it does then *
         * we request for complete XREF record.             */

        if( (ADDINFO_search("IncludeList",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs) NE NULL )
            OR
            (ADDINFO_search("ExcludeList",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs) NE NULL )
            OR
            (ADDINFO_search("Description",
                           ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs) NE NULL ) )
           get_xref_handle->out_xref_recYN = 'Y';
        else
           get_xref_handle->out_xref_recYN = 'N';

        ESA_DIAG_printf(diag_comp, 9, "xrefHandle->out_xref_recYN<%c>",
                        get_xref_handle->out_xref_recYN);
     }
     get_xref_handle->PBhandle = PBhandle;
     isFirstTime = TRUE;
  } /*endif (get_xref_handle EQ NULL)*/
  else
  {
     get_xref_handle = (ACF2_Get_Xref_Handle *) *xref_handle;
  }

  /* We have to decide which block to read.                     *
   * This is decided as,                                        *
   *  - If block_to_read is X(ref)/G(roup) refer to             *
   *    XBhandle->XREF_PB_handle or XBhandle->Groups_PB_handle  *
   *  - If block_to_read is S(hort) / L(ong) then check         *
   *    XBhandle->shortest and accordingly read the block       *
   *    XBhandle->XREF_PB_handle or XBhandle->Groups_PB_handle  *
   *  - If block_to_read is not set then                        *
   *      - If function is XREFONLY. If yes read                *
   *        XBhandle->XREF_PB_handle                            *
   *      - If function is ONLYSHRT, read the shortest one and  *
   *        set block_read                                      *
   *  else error.                                               */

  switch(block_to_read)
  {
     case 'X':
        PBhandle = XBhandle->XREF_PB_handle;
        break;
     case 'G':
        PBhandle = XBhandle->Groups_PB_handle;
        break;
     case 'S':
        if(XBhandle->shortest EQ 'X')
           PBhandle = XBhandle->XREF_PB_handle;
        else
           PBhandle = XBhandle->Groups_PB_handle;
        break;
     case 'L':
        if(XBhandle->shortest EQ 'X')
           PBhandle = XBhandle->Groups_PB_handle;
        else
           PBhandle = XBhandle->XREF_PB_handle;
        break;
     default:
        if(strcmp(function,"XREFONLY") EQ 0 )
           PBhandle = XBhandle->XREF_PB_handle;
        else
        {
           if(strcmp(function,"ONLYSHRT") EQ 0 )
           {
              if(XBhandle->shortest EQ 'X')
                 PBhandle = XBhandle->XREF_PB_handle;
              else
                 PBhandle = XBhandle->Groups_PB_handle;
           }
           else
           {
              rc = ESA_FATAL;
              sprintf(msg,
                   "Failed to determine the PB Block to process");
              sprintf(msg+strlen(msg),
                      "function=%s,blk_to_read=%c",
                      function,block_to_read);

              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                            component, "ACF2_Get_Xref",msg,
                            rc, __LINE__);
              aarc = ACF2_Internal_Error;
           }
        }
  }/* End of Switch-case */

  /* PBhandle can not be NULL */
  if(PBhandle EQ NULL)
  {
     rc = ESA_FATAL;
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,component,
                   "ACF2_Get_Xref","PBHandle can not be NULL",
                   rc, __LINE__);
     aarc = ACF2_Internal_Error;
     goto cleanup;
  }

  /* PBheader can not be NULL */
  PBheader = (PERM_BLK_HDR_rec_typ *)PBhandle->PBptr;
  if(PBheader EQ NULL)
  {
     rc = ESA_FATAL;
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,component,
                   "ACF2_Get_Xref","PBheader can not be NULL",
                   rc, __LINE__);
     aarc = ACF2_Internal_Error;
     goto cleanup;
  }

  /* If PBhandle->ext_type is 'N' then pointer   *
     to extention routine is not set             */
  if(PBhandle->ext_type NE 'N')
  {
     ExtBlockRoutines = (PB_rtnblk_ext_rec_typ *)
                                 PBheader->ext_block_routines;
     if(ExtBlockRoutines EQ NULL)
     {
        ctrace("ACF2_Get_Xref extension block null");
        rc = ESA_FATAL;
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      "ACF2_Get_Xref",
                      "ExtBlockRoutines can not be NULL",
                      rc, __LINE__);
        aarc = ACF2_Internal_Error;
        goto cleanup;
     }

     ESA_DIAG_printf(diag_comp, 9,"XBhandle->sysidYN<%c>",
                     XBhandle->sysidYN);

     if(PBhandle->ext_type EQ 'S')
     {
        XbPbSysIdRtnparms = (XB_PB_SYSID_rtnparms_rec_typ *)
                                    ExtBlockRoutines->p_rtnparms;
        if(XbPbSysIdRtnparms EQ NULL)
        {
           rc = ESA_FATAL;
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,component,
                         "ACF2_Get_Xref",
                         "XbPbSysIdRtnparms can not be NULL",
                         rc, __LINE__);
           aarc = ACF2_Internal_Error;
           goto cleanup;
        }

        /* WS10079N
        XbGetSysidParms = (XB_GetSYSID_parms_typ *)
                                    XbPbSysIdRtnparms->get_parms;

        if(XbGetSysidParms EQ NULL)
        {
           rc = ESA_FATAL;
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                         component, "ACF2_Get_Xref",
                         "XbGetSysidParms can not be NULL",
                         rc, __LINE__);
           aarc = ACF2_Internal_Error;
           goto cleanup;
        }
        */
        XbGetSysidParms = &XbPbSysIdRtnparms->get_parms;
        /* Lets initialise the output parameters */
        XbGetSysidParms->out_SYSID         = NULL;
        XbGetSysidParms->out_ActiveYN      = NULL;
        XbGetSysidParms->out_num_of_SYSIDs = NULL;
        XbGetSysidParms->out_xref_rec      = NULL;
        XbGetSysidParms->out_SYSID_ent     = NULL;
     }
     else
     {
        if(PBhandle->ext_type EQ 'R')
        {
           XbPbOnlyrecRtnparms = (XB_PB_onlyrec_rtnparms_rec_typ *)
                                          ExtBlockRoutines->p_rtnparms;
           if(XbPbOnlyrecRtnparms EQ NULL)
           {
              rc = ESA_FATAL;
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                            "ACF2_Get_Xref",
                            "XbPbOnlyrecRtnparms can not be NULL",
                            rc, __LINE__);
              aarc = ACF2_Internal_Error;
              goto cleanup;
           }

           /* WS10079N
           XbGetRecParms = (XB_GetRec_parms_typ *)
                                     XbPbOnlyrecRtnparms->get_parms;
           if(XbGetRecParms EQ NULL)
           {
              rc = ESA_FATAL;
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                            "ACF2_Get_Xref",
                            "XbGetRecParms can not be NULL",
                            rc, __LINE__);
              aarc = ACF2_Internal_Error;
              goto cleanup;
           }
           */
           XbGetRecParms = &XbPbOnlyrecRtnparms->get_parms;
           /* Lets initialise the output parameters */
           XbGetRecParms->out_xref_rec = NULL;
        }
        else
        {
           rc = ESA_FATAL;
           sprintf(msg,
                   "PBhandle->ext_type set with wrong value<%c>",
                   PBhandle->ext_type);
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                         "ACF2_Get_Xref", msg, rc, __LINE__);
           aarc = ACF2_Internal_Error;
           goto cleanup;
        }
     }
  }

  if(strcmp(function,"GETNEXT") EQ 0)
  {
     if(XBhandle->sysidYN EQ 'Y')
     {
        XbGetSysidParms->out_SYSID = sysid;
        XbGetSysidParms->out_ActiveYN = &outActiveYN;
        strcpy(XbGetSysidParms->Function,"UIDNEXT");

        /* Check if addinfo contains include/exclude/description */
        if(get_xref_handle->out_xref_recYN EQ 'Y')
        {
           XbGetSysidParms->out_xref_rec = &out_xref_rec_ptr;
        }

        /* Now we want to fetch the SYSID if the  *
         * UID was already fetched                */
        if( (isFirstTime EQ FALSE) AND
            (((XB_SYSID_PBhandle_rec_typ *)PBhandle->handle_extension)
                             ->sysidEOF EQ FALSE)   )
        {
           strcpy(XbGetSysidParms->Function,"SYSIDNXT");
           rc = Permissions_block_Get("SYSIDNXT",
                                      PBhandle,
                                      NULL, /* No UID needed */
                                      NULL, /* No permissions needed*/
                                      0, /* max buffer for perm data */
                                      diag_comp,
                                      admin_params);

           if(rc NE ESA_OK)
           {
              CTSAMSG_print(ERR_INTERNAL, msgs, NULL, dest,
                            component, "Permissions_block_Get",
                            rc, __LINE__);
              aarc = ACF2_Internal_Error;
              goto cleanup;
           }

        ESA_DIAG_printf(diag_comp, 6,
                        "Permissions_block_Get ended with rc <%d>",
                        rc);
        ESA_DIAG_printf(diag_comp, 9,
                        "sysid<%s>,outActiveYN<%c>,out_xref_rec<%p>",
                        sysid, outActiveYN, out_xref_rec_ptr);

           shouldGetUID = FALSE;
        }
     }/* Endif (sysidYN EQ 'Y') */
     else /* The condition is (sysidYN EQ 'N')*/
     {
        strcpy(XbGetRecParms->Function,"UIDNEXT");
        /* Check if addinfo contains include/exclude/description */
        if(get_xref_handle->out_xref_recYN EQ 'Y')
        {
           XbGetRecParms->out_xref_rec = &out_xref_rec_ptr;
        }
     } /*Endif (PBhandle->sysidYN EQ 'N') */

     if(shouldGetUID EQ TRUE)
     {
        /* Get next UID if we are not getting next SYSID*/
        rc = Permissions_block_Get("UIDNEXT", /* Get next XREF rec */
                                   PBhandle,
       /*XREF name returned here*/ xref_name,
                                   NULL, /* No permissions needed */
                                   0, /* max buffer for perm data */
                                   diag_comp,
                                   admin_params);
     }
     /* WS10084 start */
     ESA_DIAG_printf(diag_comp, 6,
        "Permissions_block_Get ended with rc <%d>. curUIDinPB = %p",
     /* WS10084 end   */
                        rc,PBhandle->curUIDinPB);
  } /* Endif GETNEXT */
  else
  {
     if( (strcmp(function,"GETTHIS") EQ 0)
        OR (strcmp(function,"GETTHISA") EQ 0) )
     {
        rc = XREF_Split_Name(xrefname_in, xref_name, sysid,
                             diag_comp, admin_params);
        if(rc NE ESA_OK)
        {
           CTSAMSG_print(ERR_INTERNAL, msgs, NULL, dest,
                         component, "XREF_Split_Name",
                         rc, __LINE__);
           aarc = ACF2_Internal_Error;
           goto cleanup;
        }

        ESA_DIAG_printf(diag_comp, 9,
                      "XREF_Split_Name rc<%d>,xref_name<%s>,sysid<%s>",
                      rc, xref_name, sysid);

        if(XBhandle->sysidYN EQ 'Y')
        {
           if(strcmp(function,"GETTHISA") EQ 0)
              XbGetSysidParms->in_Active='Y';

           if(sysid[0] NE NULL_CHAR)
           {
              XbGetSysidParms->in_SYSID = sysid;
           }
           else
           {
              XbGetSysidParms->out_SYSID = sysid;
           }
           XbGetSysidParms->out_ActiveYN = &outActiveYN;
           strcpy(XbGetSysidParms->Function,"UIDTHIS");

           /* Check if addinfo contains include/exclude/description */
           if(get_xref_handle->out_xref_recYN EQ 'Y')
           {
              XbGetSysidParms->out_xref_rec = &out_xref_rec_ptr;
           }
        }/* Endif sysidYN EQ 'Y' */
        else /* The condition is (sysidYN EQ 'N')*/
        {
           /* Check if addinfo contains include/exclude/description */
           if(get_xref_handle->out_xref_recYN EQ 'Y')
           {
              strcpy(XbGetRecParms->Function,"UIDTHIS");
              XbGetRecParms->out_xref_rec = &out_xref_rec_ptr;
           }
        }

        rc = Permissions_block_Get("UIDTHIS",
                                   PBhandle,
     /*XREF name returned at UID*/ xref_name,
                                   NULL, /* No permissions needed */
                                   0, /* max buffer for perm data */
                                   diag_comp,
                                   admin_params);

     } /* Endif GETTHIS/GETTHISA */
     else
     {
        /* Error function is not supported */
        rc = ESA_FATAL;
        sprintf(msg, "Invalid function received <%s>",function);
        ESA_DIAG_printf(diag_comp , 1, msg);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                      func, msg, rc, __LINE__);
        aarc = ACF2_Internal_Error;
        goto cleanup;
     }
  } /* End else of GETNEXT */

  /* WS10079T start (moved from below)  */
  ESA_DIAG_printf(diag_comp, 6,
                  "Permissions_block_Get ended with rc - <%d>",
                  rc);

  ESA_DIAG_printf(diag_comp, 9,
                  "sysid(%s),outActiveYN(%c),out_xref_rec(%p)",
                  sysid, outActiveYN, out_xref_rec_ptr);
  /* WS10079T end                       */

  /* Check rc returned by Permissions_block_Get */
  if((rc EQ ESA_EOF)    OR
    (rc EQ ESA_KEY_NOT_FOUND))                       /* WS10079T */
  {
     aarc = ACF2_Not_Found;
     goto exit;                                      /* WS10079T */
  }
  else
  {
     if(rc NE ESA_OK)
     {
        CTSAMSG_print(ERR_INTERNAL, msgs, NULL, dest,
                      component, "Permissions_block_Get",
                      rc, __LINE__);
        aarc = ACF2_Internal_Error;
        XBhandle->XB_err = TRUE;
        PBhandle->PBErr = TRUE;
        goto cleanup;
     }
  }
  /* WS10079T start (moved above)
  ESA_DIAG_printf(diag_comp, 6,
                  "Permissions_block_Get ended with rc - <%d>",
                  rc);

  ESA_DIAG_printf(diag_comp, 9,
                  "sysid(%s),outActiveYN(%c),out_xref_rec(%p)",
                  sysid, outActiveYN, out_xref_rec_ptr);

     WS10079T end */

  /* rc is ESA_OK. Lets return the data */

  if(rc EQ ESA_OK)
  {
     if(block_to_read EQ 'S')
     {
        *block_read = XBhandle->shortest;
     }
     else
     {
        if(XBhandle->shortest EQ 'X')
        {
           *block_read = 'G';
        }
        else
        {
           *block_read = 'X';
        }
     }

     /* The XREF name returned is in the format XREF(SYSID) */
     strcpy( xref_name,((PERM_BLK_UID_rec_typ *)(PBhandle->curUIDinPB))
                                          ->uid );
     strcpy(xrefname_out,xref_name);
     if(strlen(sysid) NE 0)
     {
        snprintf( (xrefname_out+strlen(xref_name)),
                    (19-strlen(xref_name)),"%s%s%s","(",sysid,")");
     }

     ESA_DIAG_printf(diag_comp,9,"block_read <%c>, xrefname_out<%s>",
                     *block_read, xrefname_out);

     /* Check if addinfo contains include/exclude/description */
     /* Get record irrespective of SYSID - Y/N */
     if(get_xref_handle->out_xref_recYN EQ 'Y')
     {
        rc = Parse_XREF_Record(NULL, NULL, addinfo, out_xref_rec_ptr,
                               'Y',NULL, admin_params);

        /*BS10134 if(rc NE ESA_OK) ***/
        if((rc NE ESA_OK) AND (rc NE ESA_EOF))       /*BS10134*/
        {
           CTSAMSG_print(ERR_INTERNAL, msgs, NULL, dest,
                         component, "Parse_XREF_Record",
                         rc, __LINE__);
           aarc = ACF2_Internal_Error;
           goto cleanup;
        }
     }

     /* For sysidYN EQ Y outActiveYN is already set before */
     if(XBhandle->sysidYN EQ 'N')
     {
        outActiveYN = XBhandle->active_default;
     }

     /* Update active if addinfo contains active attribute */
     if(get_xref_handle->out_ActiveYN EQ 'Y')
     {
        pair = ADDINFO_search("Active",
                              ACF_ADDINFO_KWD_LEN,
                              addinfo->pair,
                              addinfo->num_pairs);
        if (pair NE NULL)
        {
           charToString[0] = outActiveYN;
           charToString[1] = NULL_CHAR;
           rc = ADDINFO_updval(charToString,ACF_ADDINFO_VAL_LEN,pair);
           if (rc NE ESA_OK)
           {
              sprintf(msg,
                      "Updating xref=<%s> active=<%c> failed",
                      xref_name, outActiveYN);
              CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                            "ADDINFO_updval", msg, rc,__LINE__);
              rc = ESA_FATAL;
              aarc = ACF2_Internal_Error;
              goto cleanup;
           }
           ESA_DIAG_printf(diag_comp, 9,
                           "Updated Active attribute to (%c)",
                           outActiveYN);
        }
        else
        {
           ESA_DIAG_printf(diag_comp, 9,
                           "Active attribute is not present");
        }
     }

     if (XBhandle->xrefname[0] EQ '-')                 /* WS10079T */
     goto exit;                                        /* WS10079T */

     /* We have Role data. Lets check if we should  *
      * be getting permissions along with Roles     */
      /* WS10079 start - moved to GUG
     if( (outActiveYN EQ 'Y') AND (aarc EQ ACF2_OK)
          AND (PBhandle->WithPermissions EQ 'Y')  )
     {
        lid_perm_handle = (LID_PERM_handle_rec_typ *)
                               get_xref_handle->lid_perm_handle;
        if(lid_perm_handle EQ NULL)
        {
           lid_perm_handle = (LID_PERM_handle_rec_typ *)
                         calloc (1, sizeof(LID_PERM_handle_rec_typ));

           if (lid_perm_handle EQ NULL)
           {
              CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                            "LID_PERM handle",
                            sizeof(LID_PERM_handle_rec_typ));
              aarc = ACF2_Internal_Error;
              rc = ESA_FATAL;
              goto cleanup;
           }
           else
           {
              ALLOC_STORAGE_DIAG(lid_perm_handle,
                                 sizeof(LID_PERM_handle_rec_typ),
                                 func)
              lid_perm_handle->RolesBlk   = NULL;
              lid_perm_handle->SourcesBlk = NULL;
              lid_perm_handle->lidra_vec  = NULL;
              lid_perm_handle->RequiredPermissions= PERM_TYPE_ROLE;

              if( (strlen(get_xref_handle->recparm) GT 0)
                 AND (strcmp(get_xref_handle->recparm,"-") NE 0) )
                 strcpy(lid_perm_handle->lid,get_xref_handle->recparm);
              else /@Run ACFRPTRX for "*" @/
                 strcpy(lid_perm_handle->lid,"*");

              get_xref_handle->lid_perm_handle =
                          (LID_PERM_handle_rec_typ *) lid_perm_handle;
           }
        }
        rc = Get_ROLE_Permissions(xref_name,
                                  lid_perm_handle,
                                  addinfo,
                                  "GET",
                                  admin_params);

        if(rc NE ESA_OK)
        {
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                         component,func,
                         "Get_ROLE_Permissions ended with error",
                          rc, __LINE__);
           aarc = ACF2_Internal_Error;
           goto cleanup;
        }
        ESA_DIAG_printf(diag_comp, 9,
                        "Permissions for ROLE=<%s> added", xref_name);
     }    WS10079T end */
  }/*Endif(rc EQ ESA_OK)*/

  /* WS10079T start
  cleanup:
    if( (aarc NE ACF2_OK) OR
        (XBhandle->xrefname[0] NE '-') )
    {
      /* WS10079T start
      if (PBhandle->WithPermissions EQ 'Y')
      {
         lid_perm_handle = (LID_PERM_handle_rec_typ *)
                                   get_xref_handle->lid_perm_handle;

         ESA_DIAG_printf(diag_comp, 6,
            "Calling Get_ROLE_Permissions TERM. lid_perm_handle=%p",
             lid_perm_handle);

         rc = Get_ROLE_Permissions(xref_name,
                                   lid_perm_handle,
                                   addinfo,
                                   "TERM",
                                   admin_params);

         if( rc NE ESA_OK)
         {
            CTSAMSG_print(ERR_INTERNAL, msgs, NULL, dest, component,
                          "Get_ROLE_Permissions", rc, __LINE__);
            aarc = ACF2_Internal_Error;
         }
         if(lid_perm_handle NE NULL)
         {
           free(lid_perm_handle);
           FREE_STORAGE_DIAG(lid_perm_handle, func)
         }
      }
         WS10079T end  */
  goto exit;                                           /* WS10084  */
  cleanup:                                             /* WS10079T */
      /* WS10084
      ctrace("cleanup: Before XREF_Block_Build TERM");    WS10084  @/
      ESA_DIAG_printf(diag_comp, 0,                    /* WS10084  @/
            "Calling XREF_Block_Build TERM");          /* WS10084  @/
         WS10084  */
      rc = XREF_Block_Build("TERM",
                            XBhandle,
                            diag_comp,
                            admin_params);
      if( rc NE ESA_OK)
      {
         CTSAMSG_print(ERR_INTERNAL, msgs, NULL, dest,
                       component, "XREF_Block_Build", rc, __LINE__);
         aarc = ACF2_Internal_Error;
      }

      if(get_xref_handle NE NULL)
      {
         free(get_xref_handle);
         get_xref_handle = NULL;                      /* WS10084 */
         FREE_STORAGE_DIAG(get_xref_handle, func)
      }
    /* }                                                WS10079T */
    exit:                                            /* WS10079T */
    ESA_DIAG_exit(diag_comp, 1, func, aarc);
    return aarc;
}
/* WS10079K - End */
/* WS10079T - End */
/* WS10076N - the following routines are moved to CTSBPHR
/@ WS10075 - start @/
/@*****************************************************************
 * Procedure Name: ACF2_get_LID_rules
 ******************************************************************
 * Description   : This function gets the permissions from ACF2 for
 *                 the requested LIDs. This is done by calling
 *                 ACFRPTRX, intercepting its output and saving it
 *                 in buffers in memory.
 *
 * Input         : req_type   - request type:
 *                              GET - get the permissions from ACF2
 *                              TERM - free all areas.
 *                 lid_perm_handle - main handle used for handling
 *                              permissions. This hanlde is managed
 *                              by ts highr program.
 *
 * Output        : this routine allocated the LID_RULE_AREA vector,
 *                 pointing to the LID_RULE_AREA blocks containing
 *                 all the requested permissions.
 *
 *
 * Return Value  :
 *                 ESA_OK              - User retrieved ok
 *                 ESA_FATAL           - No user found matching criteria
 ********************************************************************@/
 ESA_RC  ACF2_get_LID_rules (char                    * req_type,
                             LID_PERM_handle_rec_typ * lid_perm_handle,
                             ADMIN_PARAMS_rec_typ    * admin_params)
 {

  /@************************************************************
  * Varaibles                                                  *
  *************************************************************@/
   static         char func[]="ACF2_Get_LID_rules";

   ESA_RC         rc = ESA_OK;

   IDB_GETMEMLINE_rec_typ  getmemline_IDB;

   void        * p_rtn = NULL;
   int           int_rc = 0;
   int           i = 0;
   int           dbglvl = 0;
   char          pgm[9] = "";
   char          errmsg[80] = "";

   int           act_rc = 0;
   int           att_rc = 0;
   int           deact_rc = 0;
   int           task_rc = 0;
   int           task_rs = 0;
   char          task_abend = ' ';         /@ S / U / ' ' @/
   char          parm_type = 'P';
   char          s0 = 'N';

   char          mo1 = ' ';                /@ Many or 1   @/
   LID_RULE_AREA_vec_rec_typ   * LRA_vec = NULL;
   CTS2RX_error_block_rec_typ    rxe;
   CTS2RX_error_block_rec_typ    deact_rxe;
   CTS2RX_error_block_rec_typ  * curr_rxe = NULL;
   rptrx_parm_type             rptrx_parm;
   LID_RULE_AREA_blk_rec_typ   * lra = NULL;

   ACF2_PARAMS_rec_typ       * params_ptr = NULL;
   CTSAMSG_HANDLE_rec_ptr      msgs;
   CTSAMSG_DEST_TABLE_rec_ptr  dest;

  /@
   *   initialization
   @/

   ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

   params_ptr = admin_params->apiinit_handle;
   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   if (lid_perm_handle EQ NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                   dest, component,func,
                   "Parameters error",
                   16,__LINE__);
     rc = ESA_FATAL;
     goto exit;
   }

   /@********************************************
    *                  GET
    ********************************************@/
   if (strcmp(req_type, "GET") EQ 0)
   {
     /@ Reset output fields  @/
     lid_perm_handle->lidra_vec = NULL;
     lid_perm_handle->lidra_vec_num = 0;

     /@
      *    Verify that SYSPRINT exists. If not, error.
      @/
     rc = OS_MVS_ddinfo("SYSPRINT", NULL, TRUE,
                        dest, msgs, 0);
     if (rc NE ESA_OK)
     {
       if (rc EQ ESA_NOT_SUPP)
         CTSAMSG_print(DD_MISSING,msgs, NULL, dest,
                       "SYSPRINT");
       /@ For any other error, OS-MVS_ddinfo issues the message @/
       rc = ESA_FATAL;
       goto exit;
     }

     /@
      *    load CTS2RXS and CTS2RXF
      @/
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                 "p_CTS2RXS = %p    p_CTS2RCF = %p   p_CTSAATC = %p",
                 params_ptr->p_cts2rxs, p_cts2rxf, p_ctsaatc);

     if (params_ptr->p_cts2rxs EQ NULL  AND /@ first time ?         @/
         p_cts2rxf EQ NULL     AND
         p_ctsaatc EQ NULL)
     {
       strcpy(pgm, "CTS2RXS ");
       int_rc = (*(ASM_RTN_TYP *)&ctsaldm)      /@ load CTS2RXS     @/
                  (pgm, "       ", &p_rtn);
       if (int_rc EQ 0)
       {
         params_ptr->p_cts2rxs = (ASM_RTN_TYP *)p_rtn;

         strcpy(pgm, "CTS2RXF ");
         int_rc = (*(ASM_RTN_TYP *)&ctsaldm)  /@ load CTS2RXF       @/
                    (pgm, "       ", &p_rtn);
         if (int_rc EQ 0)
         {
           p_cts2rxf = (ASM_RTN_TYP *)p_rtn;

           strcpy(pgm, "CTSAATC ");
           int_rc = (*(ASM_RTN_TYP *)&ctsaldm)  /@ load CTSAATC     @/
                      (pgm, "       ", &p_rtn);
           if (int_rc EQ 0)
             p_ctsaatc = (ASM_RTN_TYP *)p_rtn;

         }
       }

       if (int_rc NE 0)    /@ Any load failed ?      @/
       {
         CTSAMSG_print(ERR_API_LOAD, msgs,
                       NULL, dest, admin_params->rss_name, pgm);
         GLR_del_mods(admin_params);   /@ delete the modules.     @/
         rc = ESA_FATAL;
         goto exit;
       }
     }
     else         /@ one or more are loaded - verify @/
       if (params_ptr->p_cts2rxs EQ NULL  OR  /@ if any is missing   @/
           p_cts2rxf EQ NULL     OR
           p_ctsaatc EQ NULL)
       {
         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                       dest, component,func,
                       "Not all programs are loaded",
                       16,__LINE__);
         ESA_DIAG_printf(PLT_COMP_PERMISSION, 0,
                 "p_CTS2RXS = %p    p_CTS2RCF = %p   p_CTSAATC = %p",
                 params_ptr->p_cts2rxs, p_cts2rxf, p_ctsaatc);
         rc = ESA_FATAL ;
         goto exit;     /@ we didn't load so no delete   @/
       }

     /@  All modules are loaded  @/
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                 "p_CTS2RXS = %p    p_CTS2RCF = %p   p_CTSAATC = %p",
                 params_ptr->p_cts2rxs, p_cts2rxf, p_ctsaatc);

    /@
     *  prepare the parameters for ACFRPTRX output interception.
     @/
     if (strchr(lid_perm_handle->lid, '*') NE NULL) /@ if lid has * @/
       mo1 = 'M';                         /@ it is considerred Many @/
     else                                 /@ otherwise              @/
       mo1 = '1';                         /@ It is considerred 1.   @/

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "LID = %s   MO1 = %c",
                     lid_perm_handle->lid, mo1);

     dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_PERMISSION);
     if ( dbglvl GT 0   AND   dbglvl NE 77)
       dbglvl = 1;

     /@
      *    Allocate the LID_RULE_AREA vector
      @/
     LRA_vec = (LID_RULE_AREA_vec_rec_typ *)calloc(RULE_TYPE_NUM,
                                  sizeof(LID_RULE_AREA_vec_rec_typ));
     if (LRA_vec EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "LID RULE AREA vector",
                    sizeof(LID_RULE_AREA_vec_rec_typ) * RULE_TYPE_NUM);
       rc = ESA_FATAL;
       goto exit;
     }

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                     "LRA_vec = %p", LRA_vec);

     /@
      *    Attach ACFRPTRX to create the LID_RULE_AREA for all
      *    entries of the LID_RULE_AREA vector.
      @/
     for (i = 0; i LT RULE_TYPE_NUM; i++)
     {
       RESETRXE(rxe)
       RESETRXE(deact_rxe)
       strcpy(LRA_vec[i].rules_type, rule_parm_data[i].rule_type);

       /@    Prepare the svc screening environment @/
       curr_rxe = &rxe;
       act_rc = (*params_ptr->p_cts2rxs)("ACT     ", &dbglvl,
                             curr_rxe, &LRA_vec[i].lidra,
                             &ACFRPTRX_output_ignore_list,
                             &mo1);
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                       "CTS2RXS: ACT rc = %d", rc);
       if (act_rc NE 0)
          break;

       /@    Prepare ACFRPTRX parameter            @/
       sprintf(rptrx_parm.parm,
               "%s%s,LID(%s)",
               LRA_vec[i].rules_type,
               (strlen(rule_parm_data[i].rule_parm) GT 0 ?
                  rptrx_parm.parm, rule_parm_data[i].rule_parm : ""),
               lid_perm_handle->lid );
       rptrx_parm.parm_len = strlen(rptrx_parm.parm);

       /@    Attach ACFRPTRX                       @/
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                       "ACFRPTRX parameter = %s (%d)",
                       rptrx_parm.parm, rptrx_parm.parm_len);
       att_rc = (*p_ctsaatc)("ACFRPTRX", &parm_type,
                           &rptrx_parm, &s0, &dbglvl,
                           &task_rc, &task_rs, &task_abend);

       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                      "ATTACH:  rc = %d\n", att_rc);
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                   "ACFRPTRX: rc = %d (X'%8X') / %d (X'%8X') / %c\n",
                   task_rc, task_rc, task_rs, task_rs, task_abend);

       /@    Remove the SVC screening environment regardless of @/
       /@    how ACFRPTRX ended                                 @/
       curr_rxe = &deact_rxe;
       deact_rc = (*params_ptr->p_cts2rxs)("DEACT   ",
                                           &dbglvl, curr_rxe);
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                       "CTS2RXS: DEACT rc = %d", int_rc);

       /@ lra = (LID_RULE_AREA_blk_rec_typ *)LRA_vec[i].lidra; @/
       lra = LRA_vec[i].lidra;
       ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                      "LID_RULE_AREA = %p -> %p, %d, %d, %10s",
                      lra, lra->lrahnext, lra->lrahlen,
                      lra->lrahdlen, lra->lradata);

       /@    if there was a failure in attach, ACFRPTRX or      @/
       /@    CTS2RXS DEACT, go out of loop)                     @/
       if (deact_rc NE 0   OR
           att_rc NE  0    OR
           task_rc NE  0)
         break;

     }

     ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
             "Return codes:  act = %d  att = %d  task = %d  deact = %d",
              act_rc, att_rc, task_rc, deact_rc);

     /@
      *  If all OK, return LID vector address and entry num.
      *
      *  If any error in loop, issue the error message passed
      *  from the assembler routines and free all obtained areas.
      @/
     if (act_rc EQ 0    AND
         att_rc EQ 0    AND
         task_rc EQ 0   AND
         deact_rc EQ 0)
     {
       lid_perm_handle->lidra_vec = LRA_vec;
       lid_perm_handle->lidra_vec_num = RULE_TYPE_NUM;

       rc = ESA_OK;
     }
     else
     {
       GLR_RXE_message(&rxe, admin_params);
       GLR_RXE_message(&deact_rxe, admin_params);

       /@ If task returned with a non-zero return code or if the
          task abended (not our abend code), print ACFRPTRX
          output to SYSPRINT                                      @/
       if ( (att_rc EQ 0  AND  task_rc NE 0)  OR
            (att_rc EQ 20  AND  task_rc NE 2088) )
         GLR_print_ACFRPTRX_output(LRA_vec, RULE_TYPE_NUM,
                                   admin_params);

       GLR_free_all(LRA_vec, RULE_TYPE_NUM, admin_params);
       free(LRA_vec);
       rc = ESA_FATAL;
     }
   }
   else
     /@********************************************
      *                  TERM
      ********************************************@/
     if (strcmp(req_type, "TERM") EQ 0)
     {
       LRA_vec = lid_perm_handle->lidra_vec;
       if (LRA_vec NE NULL)
       {
         if (p_cts2rxf NE NULL)
           GLR_free_all(LRA_vec, RULE_TYPE_NUM, admin_params);

         free(LRA_vec);
       }

       lid_perm_handle->lidra_vec = NULL;
       lid_perm_handle->lidra_vec_num = 0;

       rc = ESA_OK;

     }
     else
     {
       sprintf(errmsg, "Parameter %s invalid", req_type);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     component, func, errmsg,
                           4, __LINE__);
       rc = ESA_FATAL;
     }

  exit:

    if (rc NE ESA_OK)
      CTSAMSG_print(ACF2_GET_LIDPERM_FAILED, msgs, NULL, dest,
                    lid_perm_handle->lid);

    ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func,rc);
    return rc;
 }

/@*****************************************************************
 * Procedure Name: GLR_del_mode
 ******************************************************************
 * Description   : Delete all modules loaded by ACF2_GetLID_Rules.
 *
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 ********************************************************************@/
void  GLR_del_mods(ADMIN_PARAMS_rec_typ    * admin_params)
{
  static char              func[]="GLR_del_mods";
  ACF2_PARAMS_rec_typ    * params_ptr = NULL;
  int                      rc = 0;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  params_ptr = admin_params->apiinit_handle;
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /@ delete CTS2RXS  @/
  if (params_ptr->p_cts2rxs NE NULL)
  {
    rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTS2RXS ");
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Delete CTS2RXS - rc = %d", rc);
    if (rc EQ 0)
      params_ptr->p_cts2rxs = NULL;
    else
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Delete of CTS2RXS failed",
                     4, __LINE__);
  }
  /@ delete CTS2RXF  @/
  if (p_cts2rxf NE NULL)
  {
    rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTS2RXF ");
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Delete CTS2RXF - rc = %d", rc);
    if (rc EQ 0)
      p_cts2rxf = NULL;
    else
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Delete of CTS2RXF failed",
                     4, __LINE__);
  }

  /@ delete CTSAATC  @/
  if (p_ctsaatc NE NULL)
  {
    rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTSAATC ");
    ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                    "Delete CTSAATC - rc = %d", rc);
    if (rc EQ 0)
      p_ctsaatc = NULL;
    else
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Delete of CTSAATC failed",
                     4, __LINE__);
  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;
}

/@*****************************************************************
 * Procedure Name: GLR_RXE_message
 ******************************************************************
 * Description   : Issue error messages using the informaiton in the
 *                 rxe.
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 ********************************************************************@/
static  void  GLR_RXE_message(CTS2RX_error_block_rec_typ  * rxe,
                              ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char              func[]="GLR_RXE_message";
  ACF2_PARAMS_rec_typ    * params_ptr = NULL;
  int                      rc = 0;
  char                     errmsg[201];

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "RXE: %d / %s / %s / %s / %d / %s",
                  rxe->rxeerror, rxe->rxepgm, rxe->rxefunc,
                  rxe->rxemsg, rxe->rxeline_, rxe->rxedline);
  if (rxe->rxeerror NE 0)
  {
    if (strlen(rxe->rxemsg) NE 0)
      strcpy(errmsg, rxe->rxemsg);
    else
      strcpy(errmsg, "See JOBLOG for error details");

    CTSAMSG_print(ERR_INTERNAL3, msgs, NULL, dest,
                  rxe->rxepgm, rxe->rxefunc, 12, errmsg);
    if (strlen(rxe->rxedline) NE 0)
    {
      sprintf(errmsg, "Data line # %d: %s",
                       rxe->rxeline_, rxe->rxedline);
      CTSAMSG_print(ERR_3_STRINGS, msgs, NULL, dest,
                  errmsg, " ", " ");
    }

    RESETRXE((*rxe))

  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;
}

/@*****************************************************************
 * Procedure Name: GLR_free_all
 ******************************************************************
 * Description   : Free the LRA vector and all blocks pointed by it.
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 ********************************************************************@/
static  void  GLR_free_all(LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                           int                          LRA_vec_num,
                           ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char              func[]="GLR_free_all";
  ACF2_PARAMS_rec_typ    * params_ptr = NULL;
  int                      rc = 0;
  int                      i = 0;

  CTS2RX_error_block_rec_typ   rxe;
  int                          dbglvl = 0;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "vec = %p   num = %d", LRA_vec, LRA_vec_num);

  if (LRA_vec NE NULL)
  {
    dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_PERMISSION);
    if ( dbglvl GT 0)
      dbglvl = 1;

    /@  Loop on vector,  free blocks for each entry @/
    for (i = 0; i LT LRA_vec_num; i++)
    {
      if (LRA_vec[i].lidra NE NULL)
      {
        RESETRXE(rxe);
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "LRA entry %d: Call CTS2RXF. Block addr = %p",
                        i, LRA_vec[i].lidra);
        rc = (*p_cts2rxf)(LRA_vec[i].lidra, &rxe, &dbglvl);
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "LRA entry %d: CTS2RXF: - rc = %d", i, rc);
        switch (rc)
        {
          case  0:     /@ OK @/
            break;
          case  4:     /@ parameters error, try next entry @/
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func,
                          "CTS2RXF - parameters error",
                           4, __LINE__);
            break;
          case  8:     /@ block release failed, try next entry @/
            GLR_RXE_message(&rxe, admin_params);
            break;
          case 12:     /@ work_area allocation failed @/
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func,
                          "CTS2RXF - allocation of work area failed",
                           4, __LINE__);
            break;
        }
        if (rc EQ 12)
          break;
      }
    }

    free (LRA_vec);
  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;

}

/@*****************************************************************
 * Procedure Name: GLR_print_ACFRPTRX_output
 ******************************************************************
 * Description   : Print ACFRPTRX output to SYSPRINT
 * Input         :
 *
 * Output        :
 *
 * Return Value  :
 ********************************************************************@/
static  void  GLR_print_ACFRPTRX_output(
                           LID_RULE_AREA_vec_rec_typ  * LRA_vec,
                           int                          LRA_vec_num,
                           ADMIN_PARAMS_rec_typ       * admin_params)
{
  static char   func[]="GLR_print_ACFRPTRX_output";
  ESA_RC        rc = ESA_OK;
  int           i = 0;
  char          errtxt[] =
                  "Get_rule_line_from_memory (%s) failed with rc = %d";
  char          errmsg[80] =
                  "Get_rule_line_from_memory (%s) failed with rc = %d";

  GET_LINE_PTR             get_line_ptr = NULL;
  IDB_GETMEMLINE_rec_typ   input_desc_block;
  void                   * get_line_handle = NULL;
  char                     get_line_buffer[134] = "";
  int                      get_line_len = 134;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(PLT_COMP_PERMISSION, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                  "vec = %p   num = %d", LRA_vec, LRA_vec_num);

  if (LRA_vec NE NULL)
  {
    for (i = LRA_vec_num - 1; i GE 0; i--)
    {
        ESA_DIAG_printf(PLT_COMP_PERMISSION, 6,
                        "LRA_vec[%d] = %p", i, LRA_vec[i].lidra);
      if (LRA_vec[i].lidra NE NULL)
      {
        do
        {
          get_line_ptr = &Get_rule_line_from_memory;
          input_desc_block.LID_rule_area = LRA_vec[i].lidra;
          rc = (get_line_ptr)("GETNEXT",
                             &input_desc_block,
                             &get_line_handle,
                             get_line_buffer,
                             sizeof(get_line_buffer),
                             admin_params);
          if (rc EQ ESA_OK)
           fprintf(stdout, "%s\n", get_line_buffer);

        } while (rc EQ ESA_OK);

        if (rc NE ESA_EOF)
        {
          sprintf(errmsg, errtxt, "GETNEXT", rc);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                        component, func, errmsg, 12, __LINE__);
        }

        rc = (get_line_ptr)("TREM",
                            &input_desc_block,
                            &get_line_handle,
                            get_line_buffer,
                            sizeof(get_line_buffer),
                            admin_params);
        if (rc NE ESA_EOF)
        {
          sprintf(errmsg, errtxt, "TERM", rc);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                        component, func, errmsg, 12, __LINE__);
        }
        break;
      }
    }
  }

  ESA_DIAG_exit(PLT_COMP_PERMISSION, 1, func, 0);
  return;

}

/@ WS10075 - end  @/
/* WS10076N - end */
