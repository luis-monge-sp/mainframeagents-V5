/**************************************************************
*                                                             *
* Title            : Get oe information (TSS)                 *
*                                                             *
* File Name        : ctstgoe.c                                *
*                                                             *
* Author           : Alexander Shvartsman                     *
*                                                             *
* Creation Date    : 19/01/97                                 *
*                                                             *
* Description      :                                          *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------  -------------------------------- *
* BS2383   AS       13/04/99 Global sync fails trying to list *
*                            a non existing container         *
*                                                             *
* BS2434   AS       26/10/00 Handling an empties NAME field   *
*                                                             *
* PS0495   RamiK    9/12/01  fixing index advancment in case  *
*                            of download restart              *
*                                                             *
* IS0361   YoniMa   20/08/06 TSS upgrade for v3.2.03,include: *
*                            IS0347 - Support external CFILE  *
* BS10010  AvnerL   16/06/08 INSTDATA is not sent to ESS.     *
* IS10091  NuritY   06/06/13 ParentContainer for accounts and *
*                            Groups + dynamic tsscfile records*
*                            table (WS10034 + WS10036)        *
* SAS2IBMT SeligT   30/06/16 SAS/C to IBM C Conversion Project*
* BS10085  SeligT   09/04/18 Add VERBOSE to LIST command      *
* IS10174  NuritY   15/01/18 Dynamic EXECOUT support.         *
* WS10082  MauriC   14/11/22 Recompile for new ADDINFO macros *
**************************************************************/

 /*
  *   Standard include files
  */

 #include   <globs.h>
 #include   STDIO
 #include   STDLIB
 #include   STRING
 /* #include   LCIO                                          SAS2IBMT */
 #include   ERRNO                                         /* SAS2IBMT */

 /*
  *   ESA include files
  */

 #include   ESA_API
 #include   ESA_DIAG
 #include   ESA_CTSAMSG
 #include   ESA_API_CODES
 #include   API_ADDINFO
 #include   API_AUTH

 /*
  *   MVS include files
  */

 #include MVS_COMP
 #include MVS_OS_MVS

 /*
  *   TSS include files
  */

 #include TSS
 #include TSS_CODES

 static char component[] = "CTSTGOE";

 static ESA_RC TSS_locate_oe(ESA_DIAG_COMP_typ          comp,
                          char                        * acid,
                          char                        * acid_type,
                          OE_PARAMS_rec_typ             oe_params[1],
                          OBJ_EXISTS_typ                objs_exist[1],
                          int                           max_oe,
                          int                         * found_ind,
                          int                           issue_msg,
                          CTSAMSG_DEST_TABLE_rec_typ  * dest,
                          CTSAMSG_HANDLE_rec_typ      * msgs);

 static ESA_RC TSS_invoke_tsscfile_oe(ESA_DIAG_COMP_typ  comp,
                             TSS_TRAP_BUF_rec_typ     * acids_list,
                             int /* PS0495 added * */ * i_from,
                             int                      * i_max,
                             OE_PARAMS_rec_typ          oe_params[1],
                             OBJ_EXISTS_typ             objs_exist[1],
                             int                        max_acids,
                             HAVE_MORE_typ              * have_more,
                             char                       * main_cmd,
                             CTSAMSG_DEST_TABLE_rec_typ * dest,
                             CTSAMSG_HANDLE_rec_typ     * msgs);

 static ESA_RC TSS_do_oes_list(ESA_DIAG_COMP_typ     comp,
                          char                     * acid_type,
                          TSS_TRAP_BUF_rec_typ     * oes_list,
                          TSS_GET_HANDLE_typ       * get_handle,
                          short                      max_oe,
                          short                    * actual_num,
                          HAVE_MORE_typ            * have_more,
                          OE_PARAMS_rec_typ          oe_params[1],
                          ADDINFO_rec_ptr            addinfo[1],
                          OBJ_EXISTS_typ             objs_exist[1],
                          ADMIN_PARAMS_rec_typ     * admin_params,
                          ERR_STRUCT_rec_typ       * err);

static ESA_RC TSS_put_oe_info(ESA_DIAG_COMP_typ      comp,
                          OE_PARAMS_rec_typ        * oe_params,
                          ADDINFO_rec_ptr            addinfo,
                          ADDINFO_rec_ptr            laddinfo,
  /*IS10091               CTSAMSG_DEST_TABLE_rec_typ  * dest,
                          CTSAMSG_HANDLE_rec_typ      * msgs,    */
  /*IS10091*/             ADMIN_PARAMS_rec_typ        * admin_params);

static ESA_RC TSS_get_many_acids_list(ESA_DIAG_COMP_typ   comp,
                   TSS_TRAP_BUF_rec_typ           ** oes_list,
                   short                             num_oe_in,
                   OE_PARAMS_rec_typ                 oe_params_in[1],
                   ADMIN_PARAMS_rec_typ            * admin_params,
                   ERR_STRUCT_rec_typ              * err);

static ESA_RC TSS_upd_acids_list(ESA_DIAG_COMP_typ       comp,
                                 TSS_TRAP_BUF_rec_typ  * oes_list,
                                 TSS_GET_TYPES_rec_typ   get_types[1],
                                 OE_typ                  oe,
                                 ADMIN_PARAMS_rec_typ  * admin_params,
                                 ERR_STRUCT_rec_typ    * err);

static void TSS_get_sort_symb(TSS_GET_TYPES_rec_typ   get_types[1],
                              char                  * req_type,
                              char                  * ssymb);

static ESA_RC TSS_add_to_list(ESA_DIAG_COMP_typ        comp,
                       char                          * acid,
                       char                            ssymb,
                       TSS_TRAP_BUF_rec_typ          * get_info,
                       CTSAMSG_DEST_TABLE_rec_typ    * dest,
                       CTSAMSG_HANDLE_rec_typ        * msgs);

/****************************************************
 * Procedure Name: CTSGetOEs
 * Description   : Get oes
 * Input         : mode          - GET_ALL,
 *                                 GET_MANY (one or many),
 *                                 GET_WILD (wildcards)
 *                                 GET_FREE_HANDLE (see below)
 *                 max_oe        - # of elements in oe_params,
 *                                 objs_exist and addinfo arrays
 *                 num_oe_in     - # of elements in oe_params_in
 *                 oe_params_in  - array of num_oe_in, filled with
 *                                 OEs requested.
 *                 admin_params   -
 * Output        : actual_num   - # of OEs returned
 *                 have_more    - HAVE_MORE if more OEs, else NO_MORE
 *                 err          - error indication, message, etc.
 *                 objs_exist   - array of max_oe:
 *                                OBJ_EXIST if OE exists, else
 *                                OBJ_NOT_EXIST.
 *                 oe_params    - array of max_oe:
 *                                callee fills with OES returned
 *  Input/Output : addinfo      - array of max_OE pointers:
 *                                add.info per OE, Caller puts
 *                                requested keywords, callee returns
 *                                actual add.info.
 *                 handle       - NULL on first call, filled by callee,
 *                                used by callee to keep track.
 * Return Value  : ESA_RC
 * Side Effects  : The function may allocate memory for internal usage
 *                 and return pointer to it in *handle.
 *                 Memory will be freed when function returns
 *                 have_more==NO_MORE.
 *                 If caller stop calling the function before NO_MORE,
 *                 he MUST call the function with mode=GET_FREE_HANDLE
 *                 to free the memory.
 * Comments      : Caller must reset I/O params to their initial values
 *                 when using subsequent calls (if HAVE_MORE).
 ****************************************************/

 ESA_RC CTSGetOEs  (GET_OE_MODE            mode,
                    OE_typ                 oe,
                    short                  max_oe,
                    short                * actual_num,
                    HAVE_MORE_typ        * have_more,
                    void                ** handle,
                    short                  num_oe_in,
                    OE_PARAMS_rec_typ      oe_params_in[1],
                    OE_PARAMS_rec_typ      oe_params[1],
                    ADDINFO_rec_typ      * addinfo[1],
                    OBJ_EXISTS_typ         objs_exist[1],
                    ADMIN_PARAMS_rec_typ * admin_params,
                    ERR_STRUCT_rec_typ   * err)
{

 static char func[]="CTSGetOEs";

/*
 *   Variables
 */

 ESA_RC                       rc = ESA_OK ;
 OE_typ                       dummy_oe = "";
 TSS_GET_HANDLE_typ         * get_handle = NULL;
 TSS_TRAP_BUF_rec_typ       * oes_list = NULL;
 CTSAMSG_HANDLE_rec_typ     * msgs;
 CTSAMSG_DEST_TABLE_rec_typ * dest;
 char                         root_name[MAX_TSS_PARAM_LEN + 1];
 int                          i_dump;
 OE_typ                       entering_oe;
 TSSCFILE_ERR_BEH_typ         err_action;
 ONE_FIELD_rec_ptr            cpair;     /* BS2434 */
 int                          i;         /* BS2434 */
 static TSS_GET_TYPES_rec_typ get_types[] = {
                       /*                   '0' - Reserved for Root */
                       {  TSS_ZONE,         '1'   } ,
                       {  TSS_DIVISION,     '2'   } ,
                       {  TSS_DEPARTMENT,   '3'   } ,
                       {  NULL ,            '0'   } };

/*
 *  Initialize
 */

 ESA_DIAG_enter(ESA_COMP_GETOES, 1, func );

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 *have_more = NO_MORE ;
 *actual_num = 0 ;

 ESA_DIAG_printf(ESA_COMP_GETOES,1,
                 "mode=%d handle=%X max_oes=%d oe=%s",
                  mode, *handle , max_oe, oe);
/*
 *    Check if handle was passed, if no create it
 */

 if ( mode NE GET_FREE_HANDLE_OES ) {
    if ( mode EQ GET_MANY_OES )
      err_action = TSS_IGNORE_ERR;
    else
      err_action = TSS_BREAK_BY_ERR;
    rc = TSS_init_get_handle( ESA_COMP_GETOES, err_action,
                              &get_handle, handle ,
                              addinfo[0], admin_params, err );
    if ( rc NE ESA_OK )
       goto exit ;
 }

/*
 *  Some 'Root' object related checks
 *  Pay attention, the entering mode may be changed
 */

 /* Deleted By B2383 and transferred to appropriate mode
  * ----------------------------------------------------
  * strcpy(entering_oe, oe);
  *if ( TSS_use_root_object(ESA_COMP_GETOES,root_name,dest,msgs) ) {
  *  if ( mode EQ GET_ALL_OES ) {
  *    if ( ( num_oe_in EQ 1 )                         AND
  *       ( strcmp(oe_params_in[0].oe, root_name) EQ 0 ) )
  *    num_oe_in = 0;
  *  }
  *  else if ( mode EQ GET_SUBTREE_OES)  {
  *   if (strcmp(entering_oe, root_name) EQ 0) {
  *     mode = GET_ALL_OES;
  *     strcpy(entering_oe, "");
  *   }
  *  }
  * }
  */
/*
 *    Execute according to mode
 */

 switch (mode) {

      case GET_FREE_HANDLE_OES   :

         *have_more = NO_MORE ;
         goto exit ;

      case GET_ALL_OES    :

         if ( TSS_use_root_object(ESA_COMP_GETOES,           /*BS2383*/
                              root_name,dest,msgs) ) {       /*BS2383*/
          if ( ( num_oe_in EQ 1 )         AND                /*BS2383*/
               ( strcmp(oe_params_in[0].oe,root_name) EQ 0)) /*BS2383*/
              num_oe_in = 0;                                 /*BS2383*/
         }                                                   /*BS2383*/

         if ( NOT get_handle->acids_list ) {
            rc=TSS_get_acids_list(ESA_COMP_GETOES, TSS_CONTAINER,
                                  &oes_list, get_types,
                                  dummy_oe, admin_params, err );
            get_handle->acids_list = oes_list;
            if ( rc NE ESA_OK )
               goto exit;
           /*
            *  Restart Download
            */

            if ( num_oe_in EQ 1 ) {

               ESA_DIAG_printf(ESA_COMP_GETOES,1,
                         "Restart download from=%s",
                         oe_params_in[0].oe);

               CTSAMSG_print(ERR_3_STRINGS,                 /* PS0312 */
                             msgs, NULL, dest,              /* PS0312 */
                             "Restart Download From",       /* PS0312 */
                              oe_params_in[0].oe, "");      /* PS0312 */

               rc=TSS_select_acids_list_from(ESA_COMP_GETOES,
                                             oes_list,
                                             TSS_CONTAINER,
                                             oe_params_in[0].oe,
                                             dest, msgs );
               if ( rc NE ESA_OK )
                  goto exit;
            }
            else {
               rc=TSS_upd_acids_list(ESA_COMP_GETOES,
                                     oes_list, get_types,
                                     dummy_oe, admin_params, err);
               if ( rc NE ESA_OK )
                  goto exit;
            }
         }       /* Get OE   ALL. First invoke */
         else
            oes_list = get_handle->acids_list;

         rc=TSS_do_oes_list(ESA_COMP_GETOES, TSS_CONTAINER, oes_list,
                              get_handle, max_oe,   actual_num,
                              have_more,  oe_params, addinfo,
                              objs_exist, admin_params, err);
         break ;

      case GET_MANY_OES   :

         if ( NOT get_handle->acids_list ) {
           rc=TSS_get_many_acids_list(ESA_COMP_GETOES,
                                      &oes_list, num_oe_in,
                                      oe_params_in, admin_params, err);
           get_handle->acids_list = oes_list;
           if ( rc NE ESA_OK )
              goto exit;
         }
         else
            oes_list = get_handle->acids_list;

         rc=TSS_do_oes_list(ESA_COMP_GETOES, TSS_CONTAINER, oes_list,
                            get_handle, max_oe, actual_num,
                            have_more,  oe_params, addinfo,
                            objs_exist, admin_params, err);

         break ;

      case GET_SUBTREE_OES   :

         strcpy(entering_oe, oe);
         if ( TSS_use_root_object(ESA_COMP_GETOES,           /*BS2383*/
                              root_name,dest,msgs) ) {       /*BS2383*/
           if (strcmp(entering_oe, root_name) EQ 0)          /*BS2383*/
             strcpy(entering_oe, "");                        /*BS2383*/
         }                                                   /*BS2383*/

         if ( NOT get_handle->acids_list ) {
            rc=TSS_get_acids_list(ESA_COMP_GETOES, TSS_CONTAINER,
                                  &oes_list, get_types,
                                  entering_oe, admin_params, err );
            get_handle->acids_list = oes_list;
            if ( rc NE ESA_OK )
               goto exit;

            rc=TSS_upd_acids_list(ESA_COMP_GETOES,
                                  oes_list, get_types, oe,
                                  admin_params, err);
            if ( rc NE ESA_OK )
               goto exit;
         }
         else
            oes_list = get_handle->acids_list;

         rc=TSS_do_oes_list(ESA_COMP_GETOES, TSS_CONTAINER, oes_list,
                            get_handle, max_oe,   actual_num,
                            have_more,  oe_params, addinfo,
                            objs_exist, admin_params, err);
         break ;

      default :

         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                       func, "Invalid mode", mode,__LINE__) ;
         rc=ESA_FATAL;
         goto exit ;

 }

/*
 *  BS2434. Replace an empty NAME field to **UNDEFINED**
 */

 ESA_DIAG_printf(ESA_COMP_GETOES,1,
                 "Max_oes=%d actual num=%d", max_oe, *actual_num);

 for (i=0; i LT *actual_num; i++) {
   if (objs_exist[i] EQ OBJ_EXIST ) {
      cpair = ADDINFO_search("NAME", TSS_ADDINFO_KWD_LEN,
                             addinfo[i]->pair,
                             addinfo[i]->num_pairs );
      if (cpair NE NULL) {
        if (cpair->vallen EQ 0) {
           ADDINFO_updval("**UNDEFINED**",
                          ACF_ADDINFO_VAL_LEN, cpair);
        }     /* Field is empty   */
      }       /* NAME field found */
   }          /* Obj exists       */
 }            /* Actual num loop  */

/*
 *  Print diagnostic information
 */

 ESA_DIAG_printf(ESA_COMP_GETOES,1,
                 "Max_oes=%d actual num=%d", max_oe, *actual_num);

 if ( ESA_DIAG_get_debug_level(ESA_COMP_GETOES) GE 1 ) {
    for (i_dump=0; i_dump LT *actual_num; i_dump++) {
      ESA_DIAG_printf(ESA_COMP_GETOES,0,
        "%d. OE=%s exist=%d parent=%s attr=%d",
                      i_dump,                      /* IS10091 */
                      oe_params[i_dump].oe,
                      objs_exist[i_dump],
                      oe_params[i_dump].parent,
                      oe_params[i_dump].attr);
      if ( ( objs_exist[i_dump] EQ OBJ_EXIST ) AND
           ( ESA_DIAG_get_debug_level(ESA_COMP_GETOES) GE 2 ) )
         ADDINFO_dump(addinfo[i_dump],0);
    }
 }

/*
 *  Finish
 */

 exit : ;

/*
 *  Return to caller
 */

 ESA_DIAG_printf(ESA_COMP_GETOES, 1,
                 "Exiting with rc = %d actual num=%d have_more=%d",
                 rc,*actual_num,*have_more);
/*
 *  Cleanup
 */

 if ( (rc NE ESA_OK) OR (*have_more EQ NO_MORE) ) {
    if ( *handle NE NULL ) {
       TSS_free_get_handle( ESA_COMP_GETOES, handle, dest, msgs);
       *handle    = NULL;
       get_handle = NULL;
    }
    *have_more = NO_MORE ;
 }

 ESA_DIAG_exit(ESA_COMP_GETOES, 1, func, rc);

 return rc ;

}

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_invoke_tsscfile_oe                     *
 *                                                             *
 * DESCRIPTION    : Create input for TSSCFILE utility, invoke  *
 *                  for receive oe   parameters                *
 *                                                             *
 * INPUT          : comp      - diag component                 *
 *                  acids_list- acids list                     *
 *                  i_from    - index from                     *
 *                  i_max     - number of acids                *
 *                  main_cmd  - main_cmd                       *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : i_max     - number of acids procced        *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_invoke_tsscfile_oe(ESA_DIAG_COMP_typ comp,
                             TSS_TRAP_BUF_rec_typ     * acids_list,
                             int /* PS0495 added * */ * i_from,
                             int                      * i_max,
                             OE_PARAMS_rec_typ          oe_params[1],
                             OBJ_EXISTS_typ             objs_exist[1],
                             int                        max_acids,
                             HAVE_MORE_typ              * have_more,
                             char                       * main_cmd,
                             CTSAMSG_DEST_TABLE_rec_typ * dest,
                             CTSAMSG_HANDLE_rec_typ     * msgs)
 {

  /*
   *   Variables
   */

   ESA_RC                 rc = ESA_OK ;
   char                   cmd[MAX_TSS_API_ST];
   int                    root_only = TRUE;
   int                    i;
   int                    actual_num = 0;
   int                    nb;
   char                   file_name[TSS_MAX_FILENAME_LEN + 10];
   char                   root_name[MAX_TSS_PARAM_LEN + 1];
   char                   ddn_with[MAX_FILENAME_LEN];     /* SAS2IBMT */
   FILE                 * file_in = NULL ;
   static char func[]="TSS_invoke_tsscfile_oe";

  /*
   *   Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /* IS10174
   rc = OS_MVS_ddinfo(TSSCFILE_IN_DD , file_name , TRUE, dest, msgs);*/
   rc = OS_MVS_ddinfo(TSSCFILE_IN_DD , file_name ,       /* IS10174 */
                      TRUE, dest, msgs, 0);              /* IS10174 */

   ESA_DIAG_printf(comp, 3,
                  "OS_MVS_ddinfo rc=%d file name %s", rc, file_name);
   if ( rc NE ESA_OK )
      goto exit;

  /*
   *  Open file for create input for TSSCFILE
   */

   strcpy(ddn_with,"DD:");                                /* SAS2IBMT */
   strcat(ddn_with, TSSCFILE_IN_DD);                      /* SAS2IBMT */

   /* SAS2IBMT
   file_in = fopen(TSSCFILE_IN_DD , FILE_OPEN_WRITE_TEXT);           */
   file_in = fopen(ddn_with , FILE_OPEN_WRITE_TEXT);      /* SAS2IBMT */
   if ( ferror(file_in) OR (file_in EQ NULL) ) {
       CTSAMSG_print(ERR_IO, msgs, NULL, dest, "fopen", TSSCFILE_IN_DD,
                     strerror(errno) );
       ESA_DIAG_printf(comp, 3,
              "file %s error %s", TSSCFILE_IN_DD, strerror(errno));
       rc = ESA_FATAL;
       goto exit;
   }

  /*
   *  Create input file for TSSCFILE utility
   */

   ESA_DIAG_printf(comp, 3, "i_from=%d i_max=%d used_entries=%d",
                   *i_from, *i_max, acids_list->used_entries);

   i=*i_from; /* PS0495 */
   while ( (actual_num LT  max_acids              ) AND
           (actual_num LT *i_max                  ) AND
           (i          LT acids_list->used_entries)   ) {

      if (acids_list->trap_data[i].used) {
         i++;
         continue;
      }

     /*
      *  Reset oes  parameters
      */

      oe_params[actual_num].oe[0]     = NULL_CHAR;
      oe_params[actual_num].parent[0] = NULL_CHAR;
      oe_params[actual_num].attr      = OE_ATTR_NO_ACL;
      objs_exist [actual_num]         = OBJ_NOT_EXIST;

     /*
      * Attention ! The first symbol - sort symbol
      * Be aware  ! ROOT
      */

      TSS_use_root_object(comp,root_name,dest,msgs);
      if (strcmp(&acids_list->trap_data[i].data[1], root_name)
                                  EQ 0 )  {
        if ( TSS_use_root_object(comp,root_name,dest,msgs) ) {
           strcpy(oe_params[actual_num].oe,
                               &acids_list->trap_data[i].data[1]);
           strcpy(oe_params[actual_num].parent, TSS_ROOT_PARENT);
           objs_exist[actual_num] = OBJ_EXIST;
           i++;
        }
      }
      else {
         strcpy(oe_params[actual_num].oe,
                             &acids_list->trap_data[i].data[1]);
        /*
         *  The item may be does not exist
         */

         if (acids_list->trap_data[i].data[0] EQ TSS_GET_MANY_SKIP_ITEM)
         {
            i++;
            continue;
         }

         root_only = FALSE;
         sprintf(cmd, main_cmd, &acids_list->trap_data[i].data[1]);
         nb = fputs( cmd, file_in);
         i++;

         ESA_DIAG_printf(comp, 3, "written %d bytes, cmd=%s", nb, cmd);

         if ( ferror(file_in) OR (nb EQ 0) ) {
             CTSAMSG_print(ERR_IO, msgs, NULL, dest,
                           "fputs", TSSCFILE_IN_DD, strerror(errno) );
             ESA_DIAG_printf(comp, 3,
                             "file %s error %s", TSSCFILE_IN_DD,
                              strerror(errno));
             rc = ESA_FATAL;
             goto exit;
         }
      }
      actual_num++;
   }

   /* RRK PS0495 saving the current index in the acid array */

   *i_from = i;  /* PS0495 added * to i_from */

   ESA_DIAG_printf(comp, 3, "last index =%d", *i_from);

   fclose(file_in);
   file_in = NULL;

  /*
   * Handling end of processing
   */

   if (i EQ acids_list->used_entries) {      /* Last set of list */
      *have_more = NO_MORE;
      *i_max     = actual_num;
   }
   else if (actual_num EQ 0)  {          /* Empty set of list */
      *have_more = NO_MORE;
      *i_max     = 0;
      goto exit;
   }
   else {
      *have_more = HAVE_MORE;            /* Waiting for next call */
      *i_max     = actual_num;
   }

   if ( NOT root_only )
     rc = TSS_cfile_activate(comp, dest, msgs );
   else
     rc = ESA_EOF;

  /*
   *   Finish
   */

   exit :;

   if (file_in NE NULL)
      fclose(file_in);

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_do_oes_list                            *
 *                                                             *
 * DESCRIPTION    : acids list processing (get info)           *
 *                                                             *
 * INPUT          : comp      - diag component                 *
 *                  acid_type - acid type                      *
 *                  acids_list- acids list                     *
 *                  get_handle- get handle                     *
 *                  max_oe - max oes                           *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : actual_num - actual num                    *
 *                  have_more  - have more flag                *
 *                  oe_params  - oe params                     *
 *                  addinfo    - addinfo                       *
 *                  obj_exist  - obj exist                     *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_do_oes_list(ESA_DIAG_COMP_typ    comp,
                            char                  * acid_type,
                            TSS_TRAP_BUF_rec_typ  * oes_list,
                            TSS_GET_HANDLE_typ    * get_handle,
                            short                   max_oe,
                            short                 * actual_num,
                            HAVE_MORE_typ         * have_more,
                            OE_PARAMS_rec_typ       oe_params[1],
                            ADDINFO_rec_ptr         addinfo[1],
                            OBJ_EXISTS_typ          objs_exist[1],
                            ADMIN_PARAMS_rec_typ  * admin_params,
                            ERR_STRUCT_rec_typ    * err)
{

 static char func[]="TSS_do_oes_list";

/*
 *   Variables
 */

 ESA_RC                       rc   = ESA_OK ;
 ESA_RC                       rc_a = ESA_OK ;
 TSSCFILE_REC_typ           **tsscf_recs;
 CTSAMSG_HANDLE_rec_typ     * msgs;
 CTSAMSG_DEST_TABLE_rec_typ * dest;
 ADDINFO_rec_ptr              laddinfo    = NULL;
 ONE_FIELD_rec_ptr            pair;
 ONE_FIELD_rec_ptr            pair_rec_0001;
 ONE_FIELD_rec_typ            rec_0001;
 /*rec_0001 is output of TSSCFILE so no risk it's GT 1024 WS10082A*/
 FILE                       * file_out  = NULL;
 char                         main_cmd[MAX_TSS_API_ST];
 char                         root_name[MAX_TSS_PARAM_LEN + 1];
 int                          do_oes_info = 1;
 int                          i;
 int                          root_only = FALSE;
 int                          rec_cnt = 0;
 int                          i_from;
 int                          i_max     = max_oe;
 int                          max_acids = max_oe;
 int                          logout_done = 0;
 /* IS10091 - start */
 TSS_PARAMS_rec_typ * params_ptr = admin_params->apiinit_handle;
 /* IS10091 - end   */

/*
 *  Initialize
 */

  ESA_DIAG_enter(comp, 3, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /* IS10091 tsscf_recs = TSS_get_global_tssc_desc("GENERAL");     */
  tsscf_recs = params_ptr->tsscf_rec_general;          /* IS10091  */
  i_from = get_handle->list_ind;
  ESA_DIAG_printf(comp, 3, "processing list from ind=%d", i_from);
  rc = CTSCRSS_set_authority( &logout_done,
                              SET_TO_STARTED_TASK_AUTH,
                              admin_params, err );
  if ( rc NE ESA_OK )
      goto exit;

  laddinfo = get_handle->laddinfo;

  /**************************** BS10010 ****************************
   * TSS LIST(%s) DATA(BASIC) command does not retrieve the INSTDATA
     field...
   *BS10010 strcpy(main_cmd, " TSS LIST(%s) DATA(BASIC) \n");*/
  /* BS10085 Adding VERBOSE to LIST command
  strcpy(main_cmd, " TSS LIST(%s) DATA(ALL) \n"); //BS10010*/
  strcpy(main_cmd, " TSS LIST(%s) DATA(ALL,VERBOSE) \n"); /*BS10085*/

  rc = TSS_invoke_tsscfile_oe(comp, oes_list, &i_from, &i_max,
                             oe_params, objs_exist, max_acids,
                             have_more, main_cmd, dest, msgs);
  if ( rc EQ ESA_EOF ) {
     rc        = ESA_OK;
     root_only = TRUE;
  }

  if ( rc NE ESA_OK )
     goto exit;

 /*
  *  Check End-of-list
  */

  if ( ( (*have_more) EQ NO_MORE ) AND (i_max EQ 0) ) {
     rc = ESA_OK;
     goto exit;
  }

  ESA_DIAG_printf(comp, 3, "procceed=%d", i_max);
  /* RRK PS0495 saving the index from the ACID array */
  get_handle->list_ind = i_from;

  *actual_num = i_max;  /* actual_num == tsscfile created entries */

 /*
  *  Before open and whole processing
  *  Check if was ROOT
  */

  if ( TSS_use_root_object(comp,root_name,dest,msgs) ) {
    rc = TSS_locate_oe(comp, root_name, TSS_ROOT_TYPE,
                       oe_params, objs_exist, i_max,
                       &i, 0, dest, msgs);
    if ( rc EQ ESA_OK ) {
       pair = ADDINFO_search(TSS_OE_TYPE, TSS_ADDINFO_KWD_LEN,
                             addinfo[i]->pair, addinfo[i]->num_pairs );
       if ( pair NE NULL )
         ADDINFO_addval(TSS_ROOT_TYPE, TSS_ADDINFO_VAL_LEN,
                        ADDINFO_LIST_ENTRY, pair, dest, msgs );

       /*** Mandatory keyword "NAME"  ***/

       pair = ADDINFO_search( "NAME", TSS_ADDINFO_KWD_LEN,
                              addinfo[i]->pair, addinfo[i]->num_pairs );
       if ( pair NE NULL )
         ADDINFO_addval(root_name, TSS_ADDINFO_VAL_LEN,
                        ADDINFO_LIST_ENTRY, pair, dest, msgs );
    }
  }

  if ( root_only )
    goto exit;

 /*
  *   Open TSSCFILE utility output file
  */
  /* IS0347 start */
  rc = TSS_open_output_file(comp,admin_params,&file_out);
  if ( rc NE ESA_OK )
    goto exit;
  /*
  file_out = afopen(TSSCFILE_OUT_DD, FILE_OPEN_READ_BINARY,
                    NULL_STRING, NULL_STRING);
  if (file_out EQ NULL) {
      CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                    "fopen", func, TSSCFILE_OUT_DD, strerror(errno));
     rc = ESA_FATAL;
     goto exit;
  }
  */
  /* IS0347 end */

  while ( do_oes_info ) {

   /*
    *   Load information to addinfo
    */

    pair_rec_0001 = ADDINFO_search( CFILE_REC_0001, TSS_ADDINFO_KWD_LEN,
                                 laddinfo->pair, laddinfo->num_pairs );
    if ( pair_rec_0001 NE NULL )
      memcpy( (char *)&rec_0001, (char *)pair_rec_0001,
              sizeof(ONE_FIELD_rec_typ) );

    ADDINFO_empty( laddinfo );
    ADDINFO_clear( get_handle->waddinfo);
    TSS_reset_list_buf(comp, &(get_handle->list_buffer));

    if ( pair_rec_0001 NE NULL )
       ADDINFO_insert(TYPE_1A, rec_0001.keyword, rec_0001.value,
                      laddinfo,
                      TSS_ADDINFO_KWD_LEN, TSS_ADDINFO_VAL_LEN, UNIQUE);

    rc_a = TSS_output_to_addinfo(comp, tsscf_recs,
                                 get_handle, file_out, &rec_cnt,
                                 acid_type, get_handle->waddinfo,
                                 laddinfo, dest, msgs);
    if ( (rc_a EQ ESA_FATAL) OR
         (rc_a EQ ESA_ERR  )  ) {
       rc = ESA_FATAL;
       goto exit;
    }
    else  if ( rc_a EQ ESA_WARN)
       rc = ESA_OK;

    if (  get_handle->found_err AND
         (get_handle->err_action EQ TSS_BREAK_BY_ERR ) ) {
      rc = ESA_FATAL;
      *actual_num = 0;
      goto exit;
    }

    pair = ADDINFO_search( "ACID", TSS_ADDINFO_KWD_LEN,
                           laddinfo->pair, laddinfo->num_pairs );
    if ( pair NE NULL ) {
       rc = TSS_locate_oe(comp, pair->value, acid_type,
                          oe_params, objs_exist, i_max,
                          &i, 1, dest, msgs);
       if ( rc NE ESA_OK )
         goto exit;

       ADDINFO_copy( addinfo[i], get_handle->waddinfo);
       TSS_put_list_info(comp, &(get_handle->list_buffer),
                         addinfo[i], dest, msgs );

       rc = TSS_put_oe_info(comp, &oe_params[i], addinfo[i], laddinfo,
       /*IS10091            dest, msgs,*/ admin_params); /*IS10091*/
       if ( rc NE ESA_OK )
         goto exit;

    }    /* ACID found */

    if (rc_a EQ ESA_EOF) {
       rc = ESA_OK;
       break;
    }
  }

 /*
  *  Finish
  */

 exit : ;

  if (file_out NE NULL)
     fclose(file_out);

  if (logout_done)
    CTSCRSS_set_authority( &logout_done,
                           RETURN_FROM_STARTED_TASK_AUTH,
                           admin_params, err );

  ESA_DIAG_exit(comp, 3, func, rc);

  return rc ;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : TSS_locate_oe                              *
*                                                             *
* DESCRIPTION    : Search and set oe   found parameters       *
*                                                             *
* INPUT          : acid            - acid val                 *
*                  oe_params       - oe_params                *
*                  obj_exist       - obj exist area           *
*                  dest                                       *
*                  msgs                                       *
*                                                             *
* OUTPUT         : i               - index of user            *
*                                                             *
* RETURN VALUE   : ESA_OK, ESA_FATAL                          *
*                                                             *
/**************************************************************/

static ESA_RC TSS_locate_oe(ESA_DIAG_COMP_typ           comp,
                          char                        * acid,
                          char                        * acid_type,
                          OE_PARAMS_rec_typ             oe_params[1],
                          OBJ_EXISTS_typ                objs_exist[1],
                          int                           max_oe,
                          int                         * found_ind,
                          int                           issue_msg,
                          CTSAMSG_DEST_TABLE_rec_typ  * dest,
                          CTSAMSG_HANDLE_rec_typ      * msgs)
{

 static char func[]="TSS_locate_oe";

/*
 *   Variables
 */

 ESA_RC   rc = ESA_OK ;
 int      i;

/*
 *  Initialize
 */

 ESA_DIAG_enter(comp, 5, func );

 for (i=0; i LT max_oe; i++ ) {
    if ( strcmp(acid, oe_params[i].oe) EQ 0 ) {
      objs_exist [i] = OBJ_EXIST;
      *found_ind = i;
      ESA_DIAG_printf(comp, 5, "found %s=%s index=%d",
                      acid_type, acid, i );
      goto exit;
    }
 }

 if ( issue_msg )
   CTSAMSG_print(TSS_ERR_NO_ACID, msgs, NULL, dest,
                 acid_type, acid );
 rc = ESA_ERR;

/*
 *  Finish
 */

 exit : ;

 ESA_DIAG_exit(comp, 5, func, rc);

 return rc ;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : TSS_put_oe_info                            *
*                                                             *
* DESCRIPTION    : Fill up the user structure                 *
*                                                             *
* INPUT          : oe_params       - user param struct        *
*                  addinfo         - addinfo area             *
*                  laddinfo        - local addinfo area       *
*                  dest                                       *
*                  msgs                                       *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_OK, ESA_FATAL                          *
*                                                             *
/**************************************************************/

static ESA_RC TSS_put_oe_info(ESA_DIAG_COMP_typ         comp,
                          OE_PARAMS_rec_typ           * oe_params,
                          ADDINFO_rec_ptr               addinfo,
                          ADDINFO_rec_ptr               laddinfo,
  /*IS10091               CTSAMSG_DEST_TABLE_rec_typ  * dest,
                          CTSAMSG_HANDLE_rec_typ      * msgs,       */
  /*IS10091*/             ADMIN_PARAMS_rec_typ        * admin_params)
{

 static char func[]="TSS_put_oe_info";

/*
 *   Variables
 */

 ESA_RC                rc = ESA_OK ;
 char                  oe_type[MAX_TSS_PARAM_LEN];
 CTSAMSG_HANDLE_rec_typ     * msgs;                /*IS10091*/
 CTSAMSG_DEST_TABLE_rec_typ * dest;                /*IS10091*/

/*
 *  Initialize
 */

 ESA_DIAG_enter(comp, 3, func );
 msgs = admin_params->ctsamsg_handle;              /*IS10091*/
 dest = admin_params->ctsamsg_dest;                /*IS10091*/

 rc = TSS_get_parent_oe( comp, TSS_OE_TYPE, oe_type, oe_params->parent,
                         addinfo, laddinfo, /*IS10091 dest, msgs ,*/
                         admin_params);        /*IS10091*/
 if ( rc NE ESA_OK )
    goto exit;

/*
 *  Finish
 */

 exit : ;

 ESA_DIAG_exit(comp, 3, func, rc);

 return rc ;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : TSS_get_many_acids_list                    *
*                                                             *
* DESCRIPTION    : Create acids list from obtained users id   *
*                                                             *
* INPUT          : oe_params_in    - user param struct        *
*                  num_oe_in       - number of entered users  *
*                  dest                                       *
*                  msgs                                       *
*                                                             *
* OUTPUT         : oes_list                                   *
*                                                             *
* RETURN VALUE   : ESA_OK, ESA_FATAL                          *
*                                                             *
/**************************************************************/

static ESA_RC TSS_get_many_acids_list(ESA_DIAG_COMP_typ   comp,
                   TSS_TRAP_BUF_rec_typ           ** oes_list,
                   short                             num_oe_in,
                   OE_PARAMS_rec_typ                 oe_params_in[1],
                   ADMIN_PARAMS_rec_typ            * admin_params,
                   ERR_STRUCT_rec_typ              * err)
{

 static char func[]="TSS_get_many_acids_list";

/*
 *   Variables
 */

 ESA_RC                            rc = ESA_OK ;
 TSS_TRAP_BUF_rec_typ            * tmp;
 int                               i;
 int                               buf_size = num_oe_in + 2;
 char                              acid[MAX_TSS_PARAM_LEN];
 CTSAMSG_DEST_TABLE_rec_typ      * dest;
 CTSAMSG_HANDLE_rec_typ          * msgs;

 /*** For TSS_chk_acid ***/

 char                    real_acid_type[TSS_ACID_TYPE_LEN+1]="";
 OBJECT_TYPE_typ         real_obj_type = TYPE_IGNORE;

/*
 *  Initialize
 */

 ESA_DIAG_enter(comp, 3, func );

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

/*
 *  Create buffer
 */

 rc = TSS_alloc_trap_handle (comp, buf_size, &tmp, dest, msgs );
 if ( rc NE ESA_OK )
   goto exit;

 for (i=0; i LT num_oe_in; i++ ) {

   ESA_DIAG_printf(ESA_COMP_GETOES,1,
                   "%d.OE=%s", i, oe_params_in[i].oe);

   /***  Check user existance  ***/

   rc = TSS_chk_acid(ESA_COMP_GETOES,
                     oe_params_in[i].oe,
                     TSS_CONTAINER, TYPE_CONTAINER,
                     OBJ_EXIST, FALSE,
                     real_acid_type, &real_obj_type,
                     admin_params, err);
   if (rc EQ ESA_OK)
      strcpy(acid, "0");   /* Sort symbol */
   else {
      acid[0] = TSS_GET_MANY_SKIP_ITEM;
      acid[1] = NULL_CHAR;
   }

   strcat(acid, oe_params_in[i].oe);
   rc = TSS_save_output(comp,tmp, acid, dest, msgs);
   if ( rc NE ESA_OK )
     goto exit;
 }

 *oes_list = tmp;

/*
 *  Finish
 */

 exit : ;

 ESA_DIAG_exit(comp, 3, func, rc);

 return rc ;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : TSS_upd_acids_list                         *
*                                                             *
* DESCRIPTION    : Add special containers to oes_list         *
*                                                             *
* INPUT          : oee_list        - oes list structure       *
*                  oe              - container                *
*                  dest                                       *
*                  msgs                                       *
*                                                             *
* OUTPUT         : oes_list                                   *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
/**************************************************************/

static ESA_RC TSS_upd_acids_list(ESA_DIAG_COMP_typ       comp,
                                 TSS_TRAP_BUF_rec_typ  * oes_list,
                                 TSS_GET_TYPES_rec_typ   get_types[1],
                                 OE_typ                  oe,
                                 ADMIN_PARAMS_rec_typ  * admin_params,
                                 ERR_STRUCT_rec_typ    * err)
{

 static char func[]="TSS_upd_acids_list";

/*
 *   Variables
 */

 ESA_RC                       rc = ESA_OK ;
 char                         root_name[MAX_TSS_PARAM_LEN + 1];
 TSS_ACID_HEADER_rec_typ      acid_info;
 CTSAMSG_HANDLE_rec_typ     * msgs;
 CTSAMSG_DEST_TABLE_rec_typ * dest;
 char                         ssymb;

/*
 *  Initialize
 */

 ESA_DIAG_enter(comp, 3, func );

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

/*
 *  Special "Container" processing
 */

 if ( TSS_use_root_object(comp,root_name,dest,msgs) ) {
   rc = TSS_add_to_list(comp, root_name, '0', oes_list, dest, msgs);
   if ( rc NE ESA_OK )
      goto exit;
 }

 if ( strlen(oe) GT 0 ) {
     /*
      *  Get parent oe parameters
      */
      rc = TSS_get_acid_header(comp, TSS_CMD_DEFAULT_MODE,
                               oe, &acid_info, admin_params,err);
      if ( rc NE ESA_OK )
         goto exit;

      ESA_DIAG_printf(comp, 3, "ACID=%s",      acid_info.acid);
      ESA_DIAG_printf(comp, 3, "ACID_TYPE=%s", acid_info.type);
      ESA_DIAG_printf(comp, 3, "DEPT_ACID=%s", acid_info.dept_acid);
      ESA_DIAG_printf(comp, 3, "DIV_ACID=%s",  acid_info.div_acid);
      ESA_DIAG_printf(comp, 3, "ZONE_ACID=%s", acid_info.zone_acid);

     /*
      * Add to list if neseccary :
      * ZONE, DIV
      */
      if (strlen(acid_info.zone_acid) GT 0 ) {
         TSS_get_sort_symb(get_types, TSS_ZONE, &ssymb);
         rc = TSS_add_to_list(comp, acid_info.zone_acid  ,ssymb,
                              oes_list, dest, msgs);
         if ( rc NE ESA_OK )
             goto exit;
      }

      if (strlen(acid_info.div_acid) GT 0 ) {
         TSS_get_sort_symb(get_types, TSS_DIVISION, &ssymb);
         rc = TSS_add_to_list(comp, acid_info.div_acid  ,ssymb,
                              oes_list, dest, msgs);
         if ( rc NE ESA_OK )
             goto exit;
      }
 }

 TSS_trap_buf_sort(comp, oes_list);

 if ( ESA_DIAG_get_debug_level(comp) GE 5 )  {
      ESA_DIAG_printf (comp, 0 , "ACIDS LIST");
      TSS_trap_buf_dump(comp, oes_list);
 }

/*
 *  Finish
 */

 exit : ;

 ESA_DIAG_exit(comp, 3, func, rc);

 return rc ;

}

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_sort_symb                          *
 *                                                             *
 * DESCRIPTION    : Search get types table and return sort symb*
 *                                                             *
 * INPUT          : get_types - get types table                *
 *                  req_type  - requested type                 *
 *                                                             *
 * OUTPUT         : ssymb     - sort symbol                    *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 static void TSS_get_sort_symb(TSS_GET_TYPES_rec_typ   get_types[1],
                               char                  * req_type,
                               char                  * ssymb)
 {

  int   i;

  *ssymb = '0';

  for (i=0; get_types[i].get_type; i++ ) {
     if ( strcmp(get_types[i].get_type, req_type) EQ 0 ) {
       *ssymb = get_types[i].sort_symb;
       break;
     }
  }

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_add_to_list                            *
 *                                                             *
 * DESCRIPTION    : Add special objects to list                *
 *                                                             *
 * INPUT          : acid      - acid                           *
 *                  ssymb     - sort symbol                    *
 *                  get_info  - ptr to list                    *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_add_to_list(ESA_DIAG_COMP_typ       comp,
                       char                          * acid,
                       char                            ssymb,
                       TSS_TRAP_BUF_rec_typ          * get_info,
                       CTSAMSG_DEST_TABLE_rec_typ    * dest,
                       CTSAMSG_HANDLE_rec_typ        * msgs)
 {

   ESA_RC       rc = ESA_OK;
   static char  func[] = "TSS_add_to_list";
   char         val[MAX_TSS_PARAM_LEN];

  /*
   *  Initialize
   */

   ESA_DIAG_enter(comp, 3, func );

   ESA_DIAG_printf(comp, 3, "Add ACID=%d", acid);

   sprintf(val, "%c%s", ssymb, acid);

   rc = TSS_save_output(comp, get_info, val, dest, msgs );

  /*
   *  Finish
   */

   exit : ;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc ;

 }


