/**************************************************************
*                                                             *
* Title            : Update a user (RACF)                     *
*                                                             *
* File Name        : ctsruus.c                                *
*                                                             *
* Author           : Doron Cohen                              *
*                                                             *
* Creation Date    : 28/03/94                                 *
*                                                             *
* Description      :                                          *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------  -------------------------------- *
* dc1005   Doron    10/05/95 When default group is changed,   *
*                            connect to new group, and remove *
*                            old connection according to      *
*                            the def_ug_action flag.          *
* dc1405   Doron    14/05/95 Generalize categories handling   *
*                            to "delta" handling to support   *
*                            CLAUTH as well as CATEGORY       *
* dc0706   Doron    07/06/95 Support OMVS segement (RACF21)   *
* dc0806   Doron    08/06/95 Support INTERVAL change          *
* as1506   A.Shv    15/06/95 New racf check program           *
* dc0207   Doron    02/07/95 Internal error when interval chg *
*                            in RACF 1.9.                     *
* spr135   Alex     30/07/95 Add rejection change default grp *
*                            when new dfltgrp = old dfltgrp   *
* ISAR0001 Alex     31/03/96 RACF 2.2 support                 *
* BSAR1007 Alex     07/04/96 Correct lists data (CATEGORY,    *
*                            CLAUTH) processing               *
* BSAR1008 Alex     14/04/96 Add special processing of field  *
*                            TSO.ACCTNUM                      *
* ps0156   Alex     21/07/97 DCE segment support              *
* ps0163   Alex     27/07/97 RACF security server support     *
* ps0292   AS       30/07/98 Digital certificate support      *
* ps0391   AlexS    08/11/99 RACF 2.8 Support                 *
* ws2377   ShmuelK  27/03/01 RESTRICTED/NORESTRICTED attribute*
* BS2459   AlexS    04/10/01 OPERPARM(AUTH,LEVEL) fields proc *
* ps0460   ShmuelK  15/04/01 NOPASSWORD (PROTECTED user) supp *
*                            also handle RESTRICTED outsid kdt*
* ws2394   ShmuelK  31/05/01 dflt group AUTHORITY support     *
*                   The code assumes that if dfltgrp is changed
*                   then ALTUSER DFLTGRP is done before       *
*                   ALTUSER for other keywords incl AUTHORITY.*
* ws2399   ShmuelK  05/07/01 pass exired/noexpired to updpass *
*                   change 2 diag calls from adduser to updus *
* ws2457   Yonatan  17/02/02 support for VERIFY_PWD flag from *
*                            ESS                              *
* ws2549   Yonatan  09/11/05 New parm MSG_CONNGRP_ERR.        *
* BS2703   yonim    26/03/06 Support Multi subgroup keyword   *
* WS10004  AvnerL   05/06/07 Extend ICHEINTY & add SUBGROUP3  *
* BS10006  MeirS    28/08/07 REVOKE/RESUME for z/os 1.7       *
* WS10024  AvnerL   28/07/09 Support SHARED UID for OMVS.     *
* WS10025  BarakH   04/10/09 Support AUTOUID    for OMVS.     *
* IS10076  NuritY   31/01/13 Support Custom Fields.           *
* IS10076A NuritY   31/01/13 Fix a bug in NO_PKB entries.     *
* IS10100  NuritY   29/07/13 Support CTSA internal custom     *
*                            fields (CTSACFs) and revoke      *
*                            reason.                          *
* IS10100A NuritY   14/10/13 Support RACF command limitations.*
* SAS2IBMT SeligT   09/10/16 SAS/C to IBM C Conversion Project*
* SAS2IBMN NuritY   08/02/17 SAS/C to IBM C Conversion Project*
*                            Resolve S0C4 abend caused by     *
*                            uninitialized variable.          *
* CIQ#6    SeligT   19/03/17 Account Aggr includes Connections*
* IS10147B AvnerL   13/06/17 Empty pswd 4 protected user only.*
* IS10147C Kailas   06/07/17 Ignore field if '3' or '/'       *
* IS10161  MeirS    09/11/17 remove calling to CTSRVRS rtns   *
* WS10068  NuritY   07/01/18 Change DFLTGRP in the same ALU   *
*                            command with OWNER parameter and *
*                            handle connection owner +        *
*                            correct error in list-type       *
*                            keywords processing.             *
* WS10070  KailasP  17/03/18 support SYSTEM_ACCESS in update  *
* IS10174  NuritY   15/01/18 1. Dynamic EXECOUT support.      *
*                            2. Replcae RACF_YES and RACF_NO  *
*                               with MS-YES and MS_NO for     *
*                               RACF_pro_user proteced parm.  *
* WS10081  ThomaS   18/07/21 MFA support                      *
* IS10185  AvnerL   22/08/22 Recomp with CTSRRCF              *
* WS10082  MauriC   24/11/22 Update per ADDINFO new structure *
* WS10082N NuritY   21/09/23 Update per ADDINFO new structure *
**************************************************************/

#include   <globs.h>

/*
 *   Standard include files
 */

#include   STDLIB
#include   STDIO
#include   STRING

/*
 *   CONTROL-SA include files
 */

#include ESA_DIAG
/* WS10082 APIINFO must be included before ESAAPI */
#include ESA_API_CODES
#include ESA_API
#include ESA_CTSAMSG

#include MVS_CODES                                      /* IS10076 */

#include RACF_CODES
#include API_ADDINFO
#include RACF

/*
 *     RKT for UPDUSER
 *         (Reserved Keywords Table)
 */

static ADDINFO_RKTE_rec_typ rkt[] = {
   "ADDCATEGORY", "DELCATEGORY", "DFLTGRP", "PASSWORD", "REVOKE",
   "RESUME", "SPECIAL", "AUDITOR", "ROAUDIT",              /*WS10070*/
   "CICS.ADDOPCLASS",    "CICS.DELOPCLASS",

   /* ISAR0001 */
   "NETVIEW.ADDDOMAINS", "NETVIEW.DELDOMAINS",
   "NETVIEW.ADDOPCLASS", "NETVIEW.DELOPCLASS",
   ""            /* a null string indicate end-of-rkt */
 };

/*
 *     MKT for ALTUSER
 *         (Mandatory Keywords Table)
 */

static ADDINFO_MKTE_rec_typ mkt[] = {
       ""         /* a null string indicate end-of-mkt */
 };

/*
 *     MKT for minimal CONNECT/REMOVE commands
 */

static ADDINFO_MKTE_rec_typ connect_mkt[] = {
       "GROUP",
       ""         /* a null string indicate end-of-mkt */
 };

/*
 *     KDT for ALTUSER COMMAND
 *         (Keyword Decscription Table)
 */

/*  IS10076 - the static KDT is not used any more.
 *            A dynamic KDT created at API INIT time is used instead
static ADDINFO_KDTE_rec_typ kdt[] =      {

  *                                                            *
  * keyword             type   negative       value delimiters *
  *                             value                          *
  * =================== ====== ============== ================ *

  {"ADSP"               ,KDT_FLG ,"NOADSP"             ,""  , " " },
  {"AUDITOR"            ,KDT_FLG ,"NOAUDITOR"          ,""  , ""  },
  {"CATEGORY"           ,KDT_IGN ,""                   ,"(", ") " },
  {"CLAUTH"             ,KDT_IGN ,""                   ,"(" , ")" },
  {"DATA"               ,KDT_KEY ,"NODATA"             ,"('", "')"},
  {"DFLTGRP"            ,KDT_KEY ,"DFLTGRP()"          ,"(" , ")" },
   * ws2394 add authority kwd *
  {"AUTHORITY"          ,KDT_KEY ,"AUTHORITY()"        ,"(" , ")" },
  {"GRPACC"             ,KDT_FLG ,"NOGRPACC"           ,""  , " " },
  {"INTERVAL"           ,KDT_IGN ,""                   ,"(", ") " },
  {"MODEL"              ,KDT_KEY ,"NOMODEL"            ,"(" , ")" },
  {"NAME"               ,KDT_KEY ,"NAME()"             ,"('", "')"},
  {"OIDCARD"            ,KDT_FLG ,"NOOIDCARD"          ,""  , " " },
  {"OPERATIONS"         ,KDT_FLG ,"NOOPERATIONS"       ,""  , " " },
  {"OWNER"              ,KDT_KEY ,"OWNER()"            ,"(" , ")" },
  {"PASSWORD"           ,KDT_KEY ,"PASSWORD()"         ,"(" , ")" },
   *ps0460 changed from key to flg
  {"NOPASSWORD"         ,KDT_KEY ,""                   ,"(" , ")" },*
  {"NOPASSWORD"         ,KDT_FLG ,""                   ,"(" , ")" },
   * ws2399 pass expired/noexpired in local addinfo to updpass      *
  {"EXPIRED"            ,KDT_IGN ,""                   ,""  , " " },
  {"NOEXPIRED"          ,KDT_IGN ,""                   ,""  , " " },
   * ws2457 pass VERIFY_PWD in local addinfo to updpass             *
  {"VERIFY_PWD"         ,KDT_IGN ,""                   ,""  , " " },
  {"RESUME"             ,KDT_KEY ,"RESUME"             ,"(" , ")" },
  {"RESUME_DATE"        ,KDT_IGN ,""                   ,"(", ") " },
  {"REVOKE"             ,KDT_KEY ,"REVOKE"             ,"(" , ")" },
  {"REVOKE_DATE"        ,KDT_IGN ,""                   ,"(", ") " },
   * BS10006  NORESUME & NOREVOKE             --> start              *
  {"NORESUME"           ,KDT_KEY ,"NORESUME"           ,""  , " " },
  {"NOREVOKE"           ,KDT_KEY ,"NOREVOKE"           ,""  , " " },
   * BS10006  NORESUME & NOREVOKE             --> end                *
  {"SECLABEL"           ,KDT_KEY ,"NOSECLABEL"         ,"(" , ")" },
  {"SECLEVEL"           ,KDT_KEY ,"NOSECLEVEL"         ,"(" , ")" },
  {"SPECIAL"            ,KDT_FLG ,"NOSPECIAL"          ,""  , " " },
  {"UAUDIT"             ,KDT_FLG ,"NOUAUDIT"           ,""  , " " },
  {"WHEN.TIME"          ,KDT_KEY ,"WHEN.TIME(ANYTIME)" ,"(" , ")" },
  {"WHEN.DAYS"          ,KDT_KEY ,"WHEN.DAYS(ANYDAY)"  ,"(" , ")" },
  {"NOCICS"             ,KDT_FLG ,""                   ,""  , " " },
  {"CICS.NO_PKB"        ,KDT_FLG ,""                   ,"",   ""  },
  {"NODFP"              ,KDT_FLG ,""                   ,""  , " " },
  {"DFP.NO_PKB"         ,KDT_FLG ,""                   ,"",   ""  },
  {"NOLANGUAGE"         ,KDT_FLG ,""                   ,""  , " " },
  {"LANGUAGE.NO_PKB"    ,KDT_FLG ,""                   ,"",   ""  },
  {"NOOPERPARM"         ,KDT_FLG ,""                   ,""  , " " },
  {"OPERPARM.NO_PKB"    ,KDT_FLG ,""                   ,"",   ""  },
  {"NOTSO"              ,KDT_FLG ,""                   ,""  , " " },
  {"TSO.NO_PKB"         ,KDT_FLG ,""                   ,"",   ""  },
  {"NOWORKATTR"         ,KDT_FLG ,""                   ,""  , " " },
  {"WORKATTR.NO_PKB"    ,KDT_FLG ,""                   ,"",   ""  },
  {"NOOMVS"             ,KDT_FLG ,""                   ,""  , " " },
  {"OMVS.NO_PKB"        ,KDT_FLG ,""                   ,"",   ""  },

   * ISAR0001 *
  {"NONETVIEW"          ,KDT_FLG ,""                   ,""  , " " },
  {"NETVIEW.NO_PKB"     ,KDT_FLG ,""                   ,"",   ""  },

   * ps0156 *
  {"NODCE"              ,KDT_FLG ,""                   ,""  , " " },
  {"DCE.NO_PKB"         ,KDT_FLG ,""                   ,"",   ""  },

   * ps0163 *
  {"NOOVM"              ,KDT_FLG ,""                   ,""  , " " },
  {"OVM.NO_PKB"         ,KDT_FLG ,""                   ,"",   ""  },

   * ps0391 *
  {"NOLNOTES"           ,KDT_FLG ,""                   ,"",   ""  },
  {"NLNOTES.NO_PKB"     ,KDT_FLG ,""                   ,"",   ""  },
  {"NONDS"              ,KDT_FLG ,""                   ,"",   ""  },
  {"NDS.NO_PKB"         ,KDT_FLG ,""                   ,"",   ""  },

  {"CICS.OPCLASS"       ,KDT_KEY ,"CICS.NOOPCLASS"     ,"(" , ")" },
  {"CICS.OPIDENT"       ,KDT_KEY ,"CICS.NOOPIDENT"     ,"('", "')"},
  {"CICS.OPPRTY"        ,KDT_KEY ,"CICS.NOOPPRTY"      ,"(" , ")" },
  {"CICS.TIMEOUT"       ,KDT_KEY ,"CICS.NOTIMEOUT"     ,"(" , ")" },
  {"CICS.XRFSOFF"       ,KDT_KEY ,"CICS.NOXRFSOFF"     ,"(" , ")" },
  {"DFP.DATAAPPL"       ,KDT_KEY ,"DFP.NODATAAPPL"     ,"(" , ")" },
  {"DFP.DATACLAS"       ,KDT_KEY ,"DFP.NODATACLAS"     ,"(" , ")" },
  {"DFP.MGMTCLAS"       ,KDT_KEY ,"DFP.NOMGMTCLAS"     ,"(" , ")" },
  {"DFP.STORCLAS"       ,KDT_KEY ,"DFP.NOSTORCLAS"     ,"(" , ")" },
  {"LANGUAGE.PRIMARY"   ,KDT_KEY ,"LANGUAGE.NOPRIMARY" ,"(" , ")" },
  {"LANGUAGE.SECONDARY" ,KDT_KEY ,"LANGUAGE.NOSECONDARY","(" , ")"},
  {"OPERPARM.ALTGRP"    ,KDT_KEY ,"OPERPARM.NOALTGRP"  ,"(" , ")" },
  {"OPERPARM.AUTH"      ,KDT_KEY ,"OPERPARM.NOAUTH"    ,"(" , ")" },
  {"OPERPARM.AUTO"      ,KDT_KEY ,"OPERPARM.NOAUTO"    ,"(" , ")" },
  {"OPERPARM.CMDSYS"    ,KDT_KEY ,"OPERPARM.NOCMDSYS"  ,"(" , ")" },
  {"OPERPARM.DOM"       ,KDT_KEY ,"OPERPARM.NODOM"     ,"(" , ")" },
  {"OPERPARM.KEY"       ,KDT_KEY ,"OPERPARM.NOKEY"     ,"(" , ")" },
  {"OPERPARM.LEVEL"     ,KDT_KEY ,"OPERPARM.NOLEVEL"   ,"(" , ")" },
  {"OPERPARM.LOGCMDRESP",KDT_KEY ,"OPERPARM.NOLOGCMDRESP","(" , ")" },
  {"OPERPARM.MFORM"     ,KDT_KEY ,"OPERPARM.NOMFORM"   ,"(" , ")" },
  {"OPERPARM.MIGID"     ,KDT_KEY ,"OPERPARM.NOMIGID"   ,"(" , ")" },
  {"OPERPARM.MONITOR"   ,KDT_KEY ,"OPERPARM.NOMONITOR" ,"(" , ")" },
  {"OPERPARM.MSCOPE"    ,KDT_KEY ,"OPERPARM.NOMSCOPE"  ,"(" , ")" },
  {"OPERPARM.ROUTCODE"  ,KDT_KEY ,"OPERPARM.NOROUTCODE","(" , ")" },
  {"OPERPARM.STORAGE"   ,KDT_KEY ,"OPERPARM.NOSTORAGE" ,"(" , ")" },
  {"OPERPARM.UD"        ,KDT_KEY ,"OPERPARM.NOUD"      ,"(" , ")" },
  {"TSO.ACCTNUM"        ,KDT_KEY ,"TSO.NOACCTNUM"      ,"('", "')"},

   * ps0163 *
  {"TSO.COMMAND"        ,KDT_KEY ,"TSO.NOCOMMAND"      ,"('", "')"},

  {"TSO.DEST"           ,KDT_KEY ,"TSO.NODEST"         ,"(" , ")" },
  {"TSO.HOLDCLASS"      ,KDT_KEY ,"TSO.NOHOLDCLASS"    ,"(" , ")" },
  {"TSO.JOBCLASS"       ,KDT_KEY ,"TSO.NOJOBCLASS"     ,"(" , ")" },
  {"TSO.MAXSIZE"        ,KDT_KEY ,"TSO.NOMAXSIZE"      ,"(" , ")" },
  {"TSO.MSGCLASS"       ,KDT_KEY ,"TSO.NOMSGCLASS"     ,"(" , ")" },
  {"TSO.PROC"           ,KDT_KEY ,"TSO.NOPROC"         ,"(" , ")" },
  {"TSO.SECLABEL"       ,KDT_KEY ,"TSO.NOSECLABEL"     ,"(" , ")" },
  {"TSO.SIZE"           ,KDT_KEY ,"TSO.NOSIZE"         ,"(" , ")" },
  {"TSO.SYSOUTCLASS"    ,KDT_KEY ,"TSO.NOSYSOUTCLASS"  ,"(" , ")" },
  {"TSO.UNIT"           ,KDT_KEY ,"TSO.NOUNIT"         ,"(" , ")" },
  {"TSO.USERDATA"       ,KDT_KEY ,"TSO.NOUSERDATA"     ,"(" , ")" },
  {"WORKATTR.WAACCNT"   ,KDT_KEY ,"WORKATTR.NOWAACCNT" ,"('", "')"},
  {"WORKATTR.WAADDR1"   ,KDT_KEY ,"WORKATTR.NOWAADDR1" ,"('", "')"},
  {"WORKATTR.WAADDR2"   ,KDT_KEY ,"WORKATTR.NOWAADDR2" ,"('", "')"},
  {"WORKATTR.WAADDR3"   ,KDT_KEY ,"WORKATTR.NOWAADDR3" ,"('", "')"},
  {"WORKATTR.WAADDR4"   ,KDT_KEY ,"WORKATTR.NOWAADDR4" ,"('", "')"},
  {"WORKATTR.WABLDG"    ,KDT_KEY ,"WORKATTR.NOWABLDG"  ,"('", "')"},
  {"WORKATTR.WADEPT"    ,KDT_KEY ,"WORKATTR.NOWADEPT"  ,"('", "')"},
  {"WORKATTR.WANAME"    ,KDT_KEY ,"WORKATTR.NOWANAME"  ,"('", "')"},
  {"WORKATTR.WAROOM"    ,KDT_KEY ,"WORKATTR.NOWAROOM"  ,"('", "')"},
  {"OMVS.UID"           ,KDT_KEY ,"OMVS.NOUID"         ,"(",  ")" },
  {"OMVS.AUTOUID"       ,KDT_FLG ,""  *WS10025*        ,"('", "')" },
  {"OMVS.SHARED"        ,KDT_FLG ,""  *WS10024*        ,"('", "')" },
  {"OMVS.HOME"          ,KDT_KEY ,"OMVS.NOHOME"        ,"('", "')" },
  {"OMVS.PROGRAM"       ,KDT_KEY ,"OMVS.NOPROGRAM"     ,"('", "')" },
    * PS0391 *
  {"OMVS.ASSIZEMAX"     ,KDT_KEY ,"OMVS.NOASSIZEMAX"   ,"(",    ")" },
  {"OMVS.CPUTIMEMAX"    ,KDT_KEY ,"OMVS.NOCPUTIMEMAX"  ,"(",    ")" },
  {"OMVS.FILEPROCMAX"   ,KDT_KEY ,"OMVS.NOFILEPROCMAX" ,"(",    ")" },
  {"OMVS.MMAPAREAMAX"   ,KDT_KEY ,"OMVS.NOMMAPAREAMAX" ,"(",    ")" },
  {"OMVS.PROCUSERMAX"   ,KDT_KEY ,"OMVS.NOPROCUSERMAX" ,"(",    ")" },
  {"OMVS.THREADSMAX"    ,KDT_KEY ,"OMVS.NOTHREADSMAX"  ,"(",    ")" },

   * ISAR0001 *
  {"NETVIEW.CONSNAME"   ,KDT_KEY ,"NETVIEW.NOCONSNAME" ,"(",   ")" },
  {"NETVIEW.CTL"        ,KDT_KEY ,"NETVIEW.NOCTL"      ,"(",    ")"},
  {"NETVIEW.DOMAINS"    ,KDT_KEY ,"NETVIEW.NODOMAINS"  ,"(",    ")"},
  {"NETVIEW.IC"         ,KDT_KEY ,"NETVIEW.NOIC"       ,"('",  "')"},
  {"NETVIEW.MSGRECVR"   ,KDT_KEY ,"NETVIEW.NOMSGRECVR" ,"(",    ")"},
  {"NETVIEW.NGMFADMN"   ,KDT_KEY ,"NETVIEW.NONGMFADM"  ,"(",    ")"},
  {"NETVIEW.OPCLASS"    ,KDT_KEY ,"NETVIEW.NOOPCLASS"  ,"(",    ")"},

   * ps0163 *
   {"NETVIEW.NGMFVSPN"  ,KDT_KEY ,"NETVIEW.NONGMFVSPN" ,"(",    ")" },

   * ps0156 *
  {"DCE.UUID"           ,KDT_KEY ,"DCE.NOUUID"         ,"(",   ")" },
  {"DCE.DCENAME"        ,KDT_KEY ,"DCE.NODCENAME"      ,"('",  "')"},
  {"DCE.HOMECELL"       ,KDT_KEY ,"DCE.NOHOMECELL"     ,"('",  "')"},
  {"DCE.HOMEUUID"       ,KDT_KEY ,"DCE.NOHOMEUUID"     ,"(",   ")" },
  {"DCE.AUTOLOGIN"      ,KDT_KEY ,"DCE.NOAUTOLOGIN"    ,"(",   ")" },

   * ps0163 *
  {"OVM.UID"            ,KDT_KEY ,"OVM.NOUID"          ,"(",   ")"  },
  {"OVM.FSROOT"         ,KDT_KEY ,"OVM.NOFSROOT"       ,"('",  "')" },
  {"OVM.HOME"           ,KDT_KEY ,"OVM.NOHOME"         ,"('",  "')" },
  {"OVM.PROGRAM"        ,KDT_KEY ,"OVM.NOPROGRAM"      ,"('",  "')" },

   * ps0292 *
  {"NODCERT"            ,KDT_IGN ,""             ,"",   ""    },
  {"DCERT.*"            ,KDT_IGN ,""             ,"",   ""    },

   * ps0391 *
  {"LNOTES.SNAME"       ,KDT_KEY ,"LNOTES.NOSNAME"     ,"(" , ")" },
  {"NDS.UNAME"          ,KDT_KEY ,"NDS.NOUNAME"        ,"(" , ")" },

   * ws2377 *    *ps0460
  {"RESTRICTED"         ,KDT_FLG ,"NORESTRICTED"       ,""  , " " },*
   * ps0460 2 lines:*
  {"RESTRICTED"         ,KDT_FLG ,""                   ,""  , " " },
  {"NORESTRICTED"       ,KDT_FLG ,""                   ,""  , " " },

  {""                   ,KDT_FLG ,""                   ,""  ,""   }};

 */

static ADDINFO_KDTE_rec_ptr    kdt;                  /* IS10076  */

/*
 *     KDT for ALTUSER COMMAND per delta keywords
 *         (Keyword Decscription Table)
 */

static ADDINFO_KDTE_rec_typ delta_kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"ADDCATEGORY"        ,KDT_KEY ,""         ,"(" , ")" },
  {"DELCATEGORY"        ,KDT_KEY ,""         ,"(" , ")" },
  {"CLAUTH"             ,KDT_KEY ,""         ,"(" , ")" },
  {"NOCLAUTH"           ,KDT_KEY ,""         ,"(" , ")" },
  {""                   ,KDT_FLG ,""         ,""  ,""   }};

/*
 *     KDT for minimal CONNECT/REMOVE commands
 */

static ADDINFO_KDTE_rec_typ connect_kdt[] =      {

 /*                                                            */
 /* keyword            type     negative      value delimiters */
 /*                             value                          */
 /* ================= ======== ============== ================ */

  {"GROUP"            ,KDT_KEY ,"GROUP()"    ,"(" , ")" },
  {"OWNER"            ,KDT_KEY ,""           ,"(" , ")" }, /* WS10068 */
  {""                 ,KDT_FLG ,""           ,""  , ""  }};

/*
 *     KDT for minimal PASSWORD command (for interval change)
 */

 static ADDINFO_KDTE_rec_typ password_kdt[] =      {

  /*                                                            */
  /* keyword             type   negative       value delimiters */
  /*                             value                          */
  /* =================== ====== ============== ================ */

   {"INTERVAL"           ,KDT_KEY ,"INTERVAL"     ,"(" , ")" },
   {"NOINTERVAL"         ,KDT_FLG ,"INTERVAL"     ,"(" , ")" },
   {"USER"               ,KDT_KEY ,""             ,"(" , ")" },
   {""                   ,KDT_FLG ,""             ,""  , ""  }  };

 /*
  *  Delta Keyword Table
  */

 typedef struct {
    char          kwd[RCF_ADDINFO_KWD_LEN+1];
    char          addkwd[RCF_ADDINFO_KWD_LEN+1];
    char          delkwd[RCF_ADDINFO_KWD_LEN+1];
    int           kwd_found; /* BSAR1007 */
    ADDINFO_typ   add_typ;
    int           curr_entry_index;                      /* WS10068 */
    /*WS10082A char oldval[RCF_ADDINFO_VAL_LEN+1];
    char          newval[RCF_ADDINFO_VAL_LEN+1];
    char          addval[RCF_ADDINFO_VAL_LEN+1];
    char          delval[RCF_ADDINFO_VAL_LEN+1];                    */
    char          oldval[ADDINFO_16K_VAL_LEN+1];          /*WS10082A*/
    char          newval[ADDINFO_16K_VAL_LEN+1];          /*WS10082A*/
    char          addval[ADDINFO_16K_VAL_LEN+1];          /*WS10082A*/
    char          delval[ADDINFO_16K_VAL_LEN+1];          /*WS10082A*/
  } DELTA_DESC_rec_typ;

 /*
  *     Delta keywords description table
  */

 #define DELTA_NUM         2

 static DELTA_DESC_rec_typ delta[DELTA_NUM] = {
   { "CATEGORY" ,       "ADDCATEGORY" ,       "DELCATEGORY" },
   { "CLAUTH"   ,       "CLAUTH"      ,       "NOCLAUTH"    },
 };

 /* IS10100 - start */
 /*
 static ESA_RC CTSUpdUser_lists (
                             short                  delta_num,
                             DELTA_DESC_rec_typ   * delta,
                             USER_PARAMS_rec_typ  * user_params,
                             ADDINFO_rec_typ      * addinfo,
                             ADMIN_PARAMS_rec_typ * admin_params,
                             ERR_STRUCT_rec_typ   * err );        */
 static ESA_RC CTSUpdUser_lists (USER_PARAMS_rec_typ  * user_params,
                                 ADDINFO_rec_typ      * addinfo,
                                 ADDINFO_rec_typ      * uaddinfo,
                                 ADMIN_PARAMS_rec_typ * admin_params,
                                 ERR_STRUCT_rec_typ   * err);
 /* IS10100 - end  */

 static ESA_RC CTSUpdUser_dfltgrp (
                             USER_PARAMS_rec_typ  * user_params,
                             ADDINFO_rec_typ      * addinfo,
               /* WS10068 */ ADDINFO_rec_typ      * in_laddinfo,
               /* WS10068 */ ADDINFO_rec_typ      * uaddinfo,
               /* WS10068 */ char                 * old_defug,
                             ADMIN_PARAMS_rec_typ * admin_params);
               /* WS10068    ERR_STRUCT_rec_typ   * err );   */

 static ESA_RC CTSUpdUser_interval (
                             char                 * interval,
                             USER_PARAMS_rec_typ  * user_params,
                             ADMIN_PARAMS_rec_typ * admin_params,
                             ERR_STRUCT_rec_typ   * err );

 /* Deleted by BS2459
  * static ESA_RC CTSUpdUser_clear_mform (
  *                           USER_PARAMS_rec_typ  * user_params,
  *                           ADMIN_PARAMS_rec_typ * admin_params,
  *                           ERR_STRUCT_rec_typ   * err );
  */

 /* BS2459 */
 static ESA_RC CTSUpdUser_clear_operparm_attr (
                                   USER_PARAMS_rec_typ  * user_params,
                                   char                 * attr,
                                   ADMIN_PARAMS_rec_typ * admin_params,
                                   ERR_STRUCT_rec_typ   * err);

/* IS10100 - start */
static ESA_RC CTSUpdUser_ChkOrGet_User(
                                USER_PARAMS_rec_typ  * user_params,
                                ADDINFO_rec_typ      * addinfo,
               /* WS10068 */    ADDINFO_rec_typ      * in_laddinfo,
                                ADDINFO_rec_ptr      * uaddinfo,
                                ADMIN_PARAMS_rec_typ * admin_params,
                                ERR_STRUCT_rec_typ   * err);

static ESA_RC CTSUpdUser_rvkrsn_PreCmd(ESA_DIAG_COMP_typ  comp,
                                char                     *cf_name,
                                ONE_FIELD_rec_ptr         in_pair,
                                ADDINFO_rec_ptr           addinfo,
                                ADDINFO_rec_ptr           uaddinfo,
                                void                     *entity_parms,
                                ADMIN_PARAMS_rec_typ     *admin_params,
                                int                       args_num,
                                va_list                   args_list);

static ESA_RC CTSUpdUser_rvkrsn_PostCmd(ESA_DIAG_COMP_typ  comp,
                                char                     *cf_name,
                                ONE_FIELD_rec_ptr         in_pair,
                                ADDINFO_rec_ptr           addinfo,
                                ADDINFO_rec_ptr           uaddinfo,
                                void                     *entity_parms,
                                ADMIN_PARAMS_rec_typ     *admin_params,
                                int                       args_num,
                                va_list                   args_list);

static ESA_RC CTSUpdUser_Remove_NocsdataY(
                                ADDINFO_rec_ptr           addinfo,
                                ADDINFO_rec_ptr           laddinfo,
                                ADDINFO_rec_ptr           uaddinfo,
                                ADDINFO_rec_ptr          *chk_addinfo,
                                ADMIN_PARAMS_rec_typ     *admin_params);
/* WS10068 - start */
static ESA_RC CTSUpdUser_post_DFLTGRP(
                                USER_PARAMS_rec_typ     * user_params,
                                char                    * old_defug,
                                ADMIN_PARAMS_rec_typ    * admin_params);
/* WS10068 - end   */

/* IS10100 - end   */
/*
 *   Assembler user information extraction routine
 */
 /* ps0292 */
 /* SAS2IBMT typedef and prototype changed for IBM C
 extern int ctsfrlu (char                     * option,
                     char                     * entry_type,
                     char                     * entry,
                     int                      * generic_flag,
                     RACF_OUTPUT_LINE_rec_typ * output,
                     int                      * debug,
                     int                      * rc_racf,
                     int                      * reason_code,
                     char                     * sep);                */
 extern int ctsfrlu ();                                   /* SAS2IBMT */

 /* IS10100 - start */
 static RACF_CTSACF_PROC_rec_typ CTSACF_pre_cmd[2] = {
   { LOCKED_ACCOUNT,  CTSUpdUser_rvkrsn_PreCmd },
   { NONE,            NULL                     }
 };

 static RACF_CTSACF_PROC_rec_typ CTSACF_post_cmd[2] = {
   { LOCKED_ACCOUNT,  CTSUpdUser_rvkrsn_PostCmd },
   { NONE,            NULL                     }
 };
 /* IS10100 - end  */

 static char component[] = "CTSRUUS";

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser                                 *
*                                                             *
* DESCRIPTION    : Update a RACF user                         *
*                                                             *
* INPUT          :                                            *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC CTSUpdUser (USER_PARAMS_rec_typ  * user_params,
                   ADDINFO_rec_typ      * addinfo,
                   ADMIN_PARAMS_rec_typ * admin_params,
                   ERR_STRUCT_rec_typ   * err)
{

 static char         func[]="CTSUpdUser";

 #define LADDINFO_MAX_PAIRS    40                         /* WS10068  */

/*
 *   Variables
 */

 ESA_RC                       rc , chk_rc;
 /* IS10100A char             cmd[MAX_API_ST];                    */
 char                         racf_date[10];
 RACF_FLAG_typ                at_least_Z17;           /* BS10006  */
 RACF_PARAMS_rec_typ          * params_ptr = NULL;    /* BS10006  */
 ADDINFO_rec_ptr              laddinfo = NULL;
 ADDINFO_rec_ptr              uaddinfo = NULL;        /* IS10100  */
 ADDINFO_rec_ptr              chg_addinfo = NULL;     /* IS10100  */
 /* IS10100A ADDINFO_rec_ptr    addinfo_vec[2] = { NULL, NULL }; */
 ONE_FIELD_rec_ptr            cpair;
 ONE_FIELD_rec_ptr            pair;             /* WS10081 */
 ONE_FIELD_rec_ptr            pair1;            /* WS10082 */
 RACF_FLAG_typ           nopassword; /*ps0460*/
 ONE_FIELD_rec_ptr            rev_pair, res_pair;
 ONE_FIELD_rec_ptr       rulk_pair, russpnd_pair; /* IS10100 */
 static char tso_acctnum_spec_symb[]=" ,();'";  /* BSAR1008 */
 char                        *spcsmb;           /* BSAR1008 */
 ADDINFO_KDTE_rec_ptr         tso_acctnum;      /* BSAR1008 */
 static char acct_num_spc_l[] = "('";           /* BSAR1008 */
 static char acct_num_spc_r[] = "')";           /* BSAR1008 */
 static char acct_num_smp_l[] = "(";            /* BSAR1008 */
 static char acct_num_smp_r[] = ")";            /* BSAR1008 */
 static char *operparm_attr_list[] = {          /* BS2459   */
                                      "MFORM",  /* BS2459   */
                                      "AUTH",   /* BS2459   */
                                      "LEVEL",  /* BS2459   */
                                      NULL };   /* BS2459   */
 char   operparm_attr[80] = "";                 /* BS2459   */
 char   operparm_temp[40];                      /* BS2459   */
 int    operparm_ind      = 0;                  /* BS2459   */
 USER_STATUS_typ        rev_res_req = USER_STAT_IGNORED; /* IS10100 */
 char                   do_nocsdata;                     /* IS10100 */
 int                    chg_dfltgrp = FALSE;             /* WS10068 */
 UG_typ                 old_defug = "";                  /* WS10068 */
 /*WS10070 start*/
 ONE_FIELD_rec_ptr      spair, opair;
 char kwd_flag[2]= NULL_STRING;
 char attr[13] = NULL_STRING;
 char *sPtr, *attrPtr;
 int  pairs_left  = 0;                                   /* WS10081 */
 char    msg[200] = { NULL_CHAR };                       /* WS10081 */
 /* WS10070 end*/

 CTSAMSG_HANDLE_rec_typ     * msgs;
 CTSAMSG_DEST_TABLE_rec_typ * dest;

 /****************************************************************
 *                                                               *
 *   Initialize                                                  *
 *                                                               *
 ****************************************************************/

 ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;
 params_ptr = admin_params->apiinit_handle;               /* IS10076 */

 /*WS10082A ADDINFO_spi_init(admin_params);                * WS10082 */

 /* WS10081 - start*/
 if (ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE 1)
 {
  pairs_left = 0;
  pair = ADDINFO_prefix_search("MFA.", RCF_ADDINFO_KWD_LEN,
                                TRUE,    /* include NULL value */
                                addinfo->pair, addinfo->num_pairs);
  ESA_DIAG_printf(ESA_COMP_UPDUSER,0,
                  "Recieved MFA. attributes:\n");
  while (pair NE NULL)
  {
   ESA_DIAG_printf(ESA_COMP_UPDUSER,0,
                  "keyword = <%s>\n "
                  "value   = <%s>\n ",
                  pair->keyword,
                  pair->value);
   /* WS10082N
   pairs_left = addinfo->num_pairs - (pair - addinfo->pair) - 1; */
   pairs_left = addinfo->num_pairs - (pair->index+1);     /* WS10082N */
   if (pairs_left EQ 0) break;
   pair = ADDINFO_prefix_search("MFA.", RCF_ADDINFO_KWD_LEN,
                                TRUE,   /* find also empty */
                                ppair(pair), pairs_left);/*WS10082N*/
                   /* WS10082N  pair+1, pairs_left);             */
  }
 }
 /* WS10081 - end  */
 /* IS10100 - start */
 ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "input:  user=%s   rev_status=%d",
                  user_params->user, user_params->rev_status);

 ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "Input addinfo");
 /* IS10100 - end */

 if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE 1 ) /* BS2459 */
   ADDINFO_dump(addinfo,1);                             /* ps0460 */
 /*ADDINFO_dump(addinfo,0);                             /* BS2459 */

 /****************************************************************
 *                                                               *
 *   Initial Validity Checks                                     *
 *                                                               *
 ****************************************************************/

/* IS10076 - start  */
/*
 *   Check that the dynamic KDT exists
 */
 if (params_ptr->uu_kdt.p_kdt NE NULL)
 {
   kdt = params_ptr->uu_kdt.p_kdt;
   ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                "kdt = %.8X", kdt);
 }
 else
 {
   CTSAMSG_print(WARN_INT1, msgs, NULL, dest, component, func,
                 "Update User: Dynamic KDT was not found",
                 ESA_FATAL,__LINE__);
   rc = ESA_FATAL;
   goto exit;
 }
/* IS10076 - end    */


/*
 *   Check that Reserved Keywords were not used
 */

 if (ADDINFO_rkt_check(func, 1, &addinfo, rkt,
                       dest, msgs ) NE ESA_OK) {
    rc = ESA_FATAL;
    goto exit;
 }

/*  IS10100 - Remove the call to RACF_chk_user. It will be done later
 *
 *   Check user existance
 *

 ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                "Checking user %s existance", user_params->user);
 chk_rc = RACF_chk_user(user_params->user,OBJ_EXIST,TRUE,dest,msgs);
 if ( chk_rc NE ESA_OK ) {
    rc = ESA_FATAL;
    goto exit;
 }
 */

/*
 *   Obtain a local addinfo buffer
 */
 /* if (ADDINFO_alloc(func, 20, &laddinfo, dest, msgs) NE ESA_OK) { */
 /* WS10068 - start */
 /* if (ADDINFO_alloc(func, 30, &laddinfo, dest, msgs) NE ESA_OK)   */
 rc = ADDINFO_alloc(func, LADDINFO_MAX_PAIRS, &laddinfo, dest, msgs);
 if (rc NE ESA_OK)
 /* WS10068 - end   */
 {
    rc = ESA_FATAL;
    goto exit;
 }

 /*  IS10100A
 addinfo_vec[0] = laddinfo;
 addinfo_vec[1] = addinfo;      */

 if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE 1 )
   ADDINFO_dump(addinfo,1);

 /****************************************************************
 * ws2457                                                        *
 *   If VERIFY_PWD was sent, disregard all other changes and     *
 *   only verify the password.                                   *
 *                                                               *
 ****************************************************************/

 cpair = ADDINFO_search ( "VERIFY_PWD", RCF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
 if (cpair NE NULL)
 {
   ESA_DIAG_printf(ESA_COMP_UPDUSER, 2,
                   "VERIFY_PWD=%s",cpair->value);
   if (strcmp(cpair->value,KWD_FLAG_ON) EQ 0)
   {
     /*  IS10100 - start */
     /*
      *  Check user existance.
      */
 /* WS10068 chk_rc = CTSUpdUser_ChkOrGet_User(user_params, NULL, NULL,*/
     chk_rc = CTSUpdUser_ChkOrGet_User(user_params,      /* WS10068 */
                                       NULL, NULL, NULL, /* WS10068 */
                                       admin_params,     /* WS10068 */
                                       err);             /* WS10068 */
     if ( chk_rc NE ESA_OK )
     {
        rc = ESA_FATAL;
        goto exit;
     }
     /*  IS10100 - end   */

     ADDINFO_insert(TYPE_1A,"VERIFY_PWD", cpair->value, laddinfo,
                   RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                   UNIQUE);

     rc = CTSUpdPassword (user_params, laddinfo, admin_params, err);
     goto exit;
   }
 }

 /*  IS10076 - start   */
 /****************************************************************
 *                                                               *
 *   If CSDATA/NOCSDATA are provided but CUSRTOM_FIELDS_SUPPORT  *
 *   is N, issue a message.                                      *
 *                                                               *
 ****************************************************************/
 if (params_ptr->rssparm_CUSTOM_FIELDS_SUPPORT[0] EQ 'N')
 {
   cpair = ADDINFO_prefix_search("CSDATA.",
                         RCF_ADDINFO_KWD_LEN,
                         TRUE,
                         addinfo->pair,
                         addinfo->num_pairs );

   if (cpair EQ NULL)
     cpair = ADDINFO_search("NOCSDATA",
                           RCF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );

   if (cpair NE NULL)
     CTSAMSG_print(ERR_NOT_SUPP_DUE_RSSP_NO, msgs, NULL,
                   dest, "CSDATA. and NOCSDATA keywords",
                   "CUSTOM_FIELDS_SUPPORT", "N");
 }
 /*  IS10076 - end     */

 /*  WS10068 - start   */
 /*  if DFLTGRP should be changed, add an entry to the laddinfo */
 /*  to "tell" CTSUpdUser_ChkOrGet_User that groups should      */
 /*  be retrieved.                                              */
 if ( (strcmp(user_params->def_group, BACKSLASH_STR) NE 0) AND
      (strcmp(user_params->def_group, BACKSLASH_ALT) NE 0)) /*IS10147C*/
 {
   chg_dfltgrp = TRUE;
   ADDINFO_insert(TYPE_1A, "DFLTGRP", NULL_STRING,
                  laddinfo, RCF_ADDINFO_KWD_LEN,
                  RCF_ADDINFO_VAL_LEN,  UNIQUE);
 }
 /*  WS10068 - end     */
 /*  IS10100 - start */
 /*
  *  Check user existance and get user details, if required.
  */
 /* WS10068 - start */
 /* chk_rc = CTSUpdUser_ChkOrGet_User(user_params, addinfo, &uaddinfo,
                                   admin_params, err);                */
 chk_rc = CTSUpdUser_ChkOrGet_User(user_params,
                                   addinfo, laddinfo, &uaddinfo,
                                   admin_params, err);
 /* WS10068 - end  */
 if ( chk_rc NE ESA_OK )
 {
    rc = ESA_FATAL;
    goto exit;
 }
 /*  IS10100 - end   */

 /****************************************************************
 *                                                               *
 *   Handle default group change                                 *
 *                                                               *
 ****************************************************************/

 /* WS10068 - the lines below were moved up
 if ( (strcmp(user_params->def_group, BACKSLASH_STR) NE 0)
  AND (strcmp(user_params->def_group, BACKSLASH_ALT) NE 0)){ *IS10147C*
 */
 if (chg_dfltgrp)                                         /* WS10068 */
 {
   /* WS10068 - start */
   /*
   rc = CTSUpdUser_dfltgrp(user_params, addinfo, admin_params, err);
   */
   rc = CTSUpdUser_dfltgrp(user_params, addinfo, laddinfo, uaddinfo,
                           (char *)old_defug, admin_params);
   /* WS10068 - end  */
   if (rc NE ESA_OK)
   {
      rc = ESA_FATAL;
      goto exit;
   }
 }

 /****************************************************************
 *                                                               *
 *   Handle lists changes (CATEGORY, CLAUTH)                     *
 *                                                               *
 ****************************************************************/

 /* IS10100 - start  */
 /*
 rc = CTSUpdUser_lists ( DELTA_NUM, delta, user_params, addinfo,
                         admin_params, err);                     */
 rc = CTSUpdUser_lists (user_params, addinfo, uaddinfo,
                        admin_params, err);
 /* IS10100 - end    */
 if (rc NE ESA_OK)
    goto exit;

 /****************************************************************
 *                                                               *
 * !*Handle Password Changes (must be after interval chg)*!      *
 *   Handle Password Changes (placed before interval chg by      *
 *                            PS0460)                            *
 ****************************************************************/

 if ( (strcmp(user_params->passwd, BACKSLASH_STR) NE 0)
  AND (strcmp(user_params->passwd, BACKSLASH_ALT) NE 0) ) { /*IS10147C*/
    /*start of ws2399 */
    cpair = ADDINFO_search ( "EXPIRED", RCF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
    if ( cpair NE NULL) {
    ADDINFO_insert(TYPE_1A,"EXPIRED", cpair->value, laddinfo,
                   RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                   UNIQUE);
    }
    cpair = ADDINFO_search ( "NOEXPIRED", RCF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
    if ( cpair NE NULL) {
    ADDINFO_insert(TYPE_1A,"NOEXPIRED", cpair->value, laddinfo,
                   RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                   UNIQUE);
    }
    /* end of ws2399 */
    rc = CTSUpdPassword (user_params, laddinfo, admin_params, err);
    if (rc NE ESA_OK) {
       rc = ESA_FATAL;
       goto exit;
    }

 } /* End of password update */

 /****************************************************************
 *                                                               *
 *   Handle password interval changes                            *
 *PS0460 Placed after password change.                           *
 *PS0460 Password change gets a user out of Protected            *
 *PS0460 (nopassword) attribute and thus enables                 *
 *PS0460 issuing of RACF command PASSWORD to change interval     *
 *PS0460                                                         *
 ****************************************************************/
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
 "Checking update user %s for NOPASSWORD keyword",user_params->user);
  cpair = ADDINFO_search ("NOPASSWORD", RCF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
  if (( cpair NE NULL) AND (strcmp(cpair->value, KWD_FLAG_ON) EQ 0))
     nopassword = RACF_YES;
     else nopassword= RACF_NO;

 cpair = ADDINFO_search ( "INTERVAL", RCF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
 if ( cpair NE NULL) {
       if (nopassword EQ RACF_YES)
                  CTSAMSG_print(RACF_PROTECTED_IGNORE_KWD,
                  msgs, NULL, dest, "INTERVAL", user_params->user);
       else {
       rc = CTSUpdUser_interval ( cpair->value, user_params,
                               admin_params, err);
       if (rc NE ESA_OK)
          goto exit;
       }
 }

 /****************************************************************
 *                                                               *
 *   Clear OPERPARM.MFORM if changed to a non empty              *
 *   Deleted by BS2459                                           *
 ****************************************************************/

 /* Deleted by BS2459
  * cpair = ADDINFO_search( "OPERPARM.MFORM",
  *                        RCF_ADDINFO_KWD_LEN,
  *                        addinfo->pair,
  *                        addinfo->num_pairs);
  * if (cpair NE NULL)
  *   if ( strlen(cpair->value) GT 0 ) {
  *      rc = CTSUpdUser_clear_mform (user_params, admin_params, err);
  *      if (rc NE ESA_OK) {
  *         rc = ESA_FATAL;
  *         goto exit;
  *      }
  *  }
  */

 /****************************************************************
 *                                                               *
 *   Clear OPERPARM.MFORM if changed to a non empty              *
 *   Clear OPERPARM.AUTH  if changed to a non empty              *
 *   Clear OPERPARM.LEVEL if changed to a non empty              *
 *   BS2459                                                      *
 *                                                               *
 ****************************************************************/

 for (operparm_ind=0; operparm_attr_list[operparm_ind];
      operparm_ind++)                                    {
    sprintf(operparm_temp, "OPERPARM.%s",
            operparm_attr_list[operparm_ind]);
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "Checking ... %d.%s",
                    operparm_ind, operparm_temp);
    cpair = ADDINFO_search( operparm_temp,
                            RCF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "%d.%s cpair=%x",
                    operparm_ind, operparm_temp, cpair);
    if (cpair NE NULL) {
       ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "%d.%s val=%d/%s",
                    operparm_ind, operparm_temp,
                    strlen(cpair->value), cpair->value);
       if ( strlen(cpair->value) GT 0 ) {
          strcat(operparm_attr, " NO");
          strcat(operparm_attr, operparm_attr_list[operparm_ind]);
       }
    }
 }

 if (strlen(operparm_attr) GT 0) {
   strcat(operparm_attr, " ");
   rc = CTSUpdUser_clear_operparm_attr (user_params,
                                        operparm_attr,
                                        admin_params, err);
   if (rc NE ESA_OK) {
      rc = ESA_FATAL;
      goto exit;
   }
 }
 /* End of BS2459 */

 /****************************************************************
 *                                                               *
 *  Insert administrator authorities SPECIAL/AUDITOR to addinfo  *
 *                                                               *
 ****************************************************************/

 ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                 "Inserting paramters to local addinfo");

 /* WS10070 - start */
 spair = ADDINFO_search("SYSTEM_ACCESS", RCF_ADDINFO_KWD_LEN,
                      addinfo->pair, addinfo->num_pairs);

 if (spair NE NULL)
 {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 2,
                    "SYSTEM_ACCESS keyword located - %s",
                    spair->value);

    /* If SYSTEM_ACCESS is populated then we dont want to give    *
     * other ways to define SPECIAL,OPERATIONS,AUDITOR attributes *
     * Since OPERATIONS is defined in separate attribute and not  *
     * in User_Admin, we want to remove OPERATIONS from addinfo   */

    opair= ADDINFO_search("OPERATIONS", RCF_ADDINFO_KWD_LEN,
                          addinfo->pair, addinfo->num_pairs);
    if ( opair NE NULL )
    {
        ADDINFO_delete( addinfo, "OPERATIONS" );
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                        "OPERATIONS attribute ignored.");
    }

    sPtr = NULL;
    do
    {

        chk_rc = ADDINFO_list_getnextvalue(spair, ADDINFO_LIST_ENTRY,
                                           attr, &sPtr);

        if( *attr EQ NULL_CHAR )
            continue;
        else
        {
          if ( (strlen(attr) GT 2) AND (strncmp(attr,"NO",2) EQ 0) )
          {
             strcpy(kwd_flag , KWD_FLAG_OFF);
             attrPtr =attr+2; /*Ignore two characters to get kwd name*/
          }
          else
          {
             strcpy(kwd_flag , KWD_FLAG_ON);
             attrPtr = attr;
          }
        }

        ESA_DIAG_printf(ESA_COMP_UPDUSER, 9,
                        "kwd_flag - %s, attr - %s",
                        kwd_flag, attrPtr);


        ADDINFO_insert(TYPE_1A, attrPtr , kwd_flag, laddinfo,
                       RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       UNIQUE);

     } while( chk_rc EQ ESA_OK );
 }
 else
 { /* WS10070 - end */


    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "user_admin=%d", user_params->user_admin );

    switch ( user_params->user_admin ) {

       case USER_ADM_ALL :
          ADDINFO_insert(TYPE_1A,"SPECIAL", KWD_FLAG_ON, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          ADDINFO_insert(TYPE_1A,"AUDITOR", KWD_FLAG_ON, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          break ;

       case USER_ADM_ADMIN:
          ADDINFO_insert(TYPE_1A,"SPECIAL", KWD_FLAG_ON, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          ADDINFO_insert(TYPE_1A,"AUDITOR", KWD_FLAG_OFF, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          break ;

       case USER_ADM_AUDIT:
          ADDINFO_insert(TYPE_1A,"SPECIAL", KWD_FLAG_OFF, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          ADDINFO_insert(TYPE_1A,"AUDITOR", KWD_FLAG_ON, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          break ;

       case USER_ADM_NONE:
          ADDINFO_insert(TYPE_1A,"SPECIAL", KWD_FLAG_OFF, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          ADDINFO_insert(TYPE_1A,"AUDITOR", KWD_FLAG_OFF, laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
          break ;
       default:
          break ;
  }

 }

 /****************************************************************
 *                                                               *
 *  Handle TSO.ACCTNUM field             (BSAR1008)              *
 *                                                               *
 ****************************************************************/

 cpair = ADDINFO_search("TSO.ACCTNUM", RCF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
 if (cpair NE NULL) {
 /* ESA_DIAG_printf(ESA_COMP_ADDUSER, 1, ws2399 */
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "TSO.ACCTNUM keyword located %s=%s",
                    cpair->keyword, cpair->value);
   /*
    *   Locate "TSO.ACCTNUM" in KDTE table
    */

    tso_acctnum =  ADDINFO_kdt_search("TSO.ACCTNUM", kdt);
    if ( tso_acctnum NE NULL ) {

       spcsmb = strpbrk( cpair->value, tso_acctnum_spec_symb);

       /***  Account number without special symbols ***/

       if ( spcsmb EQ NULL ) {
          tso_acctnum->txtl =  acct_num_smp_l;
          tso_acctnum->txtr =  acct_num_smp_r;
       }

       /***  Account number with special symbols ***/

       else {
          tso_acctnum->txtl =  acct_num_spc_l;
          tso_acctnum->txtr =  acct_num_spc_r;
       }
    }
    else {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
               component,func,
               "KDTE table corrupted. TSO.ACCTNUM field not found",
               16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
    }
 }

 /****************************************************************
 *                                                               *
 *  Handle user status changes (REVOKE,RESUME etc...)            *
 *                                                               *
 ****************************************************************/
 /*  BS10006  -  Reflect the changes done in RACF for z/os 1.7:  *
  *              1. NOREVOKE parameter in ALTUSER to clear the   *
  *                 REVOKE date                                  *
  *              2. NORESUME parameter in ALTUSER to clear the   *
  *                 RESUME date                                  *
  *              3. Retrieve RSSPARM's RESUME_CLEAR_REVOKEDATE   *
  *                 to decide whethe or not to clear REVOKE      *
  *                 date when REVOKE flag set off                *
  *              4. Retrieve RSSPARM's REVOKE_CLEAR_RESUMEDATE   *
  *                 to decide whethe or not to clear RESUME      *
  *                 date when REVOKE flag set on                 *
  *              5. Enable to change both, RESUME and REVOKE     *
  *                 dates and optionally the REVOKE flag         *
  *  ----------------------------------------------------------- */
 /* IS10100 - support changes to RU_SUSPENDED and RU_LOCKED      *
  *           - If RU_SUSPENDED is changed - act by its value    *
  *             (Y= REVOKE, N=RESUME)                            *
  *           - Else, if RU_LOCKED it changed to N (RU_LOCKED    *
  *             cannot be changed to Y) -- RESUME                *
  *           - If none is specified, act by user_params         *
  *             rev_status field (revoke/resume).                *
  *  ----------------------------------------------------------- */

 /*
  *  Handle Revoke Status change to REVOKE
  */
  /*  BS10006  Retrieve RACF version     ==> start */
  /*  IS10161 start - remove RACF version retrieving
   rc = RACF_version_at_least(RACFZ17,
                             &at_least_Z17);
   if (rc NE ESA_OK) {
      rc = ESA_FATAL;
      goto exit;
   }
      IS10161 end                                             */
   at_least_Z17 = RACF_YES ;              /* IS10161          */
  /*  IS10161 start - remove RACF version retrieving
   if (at_least_Z17 EQ RACF_NO)
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                     "RACF below z1.7");
   else
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                     "RACF above z1.7");
      IS10161 end                                             */

  /*  Retrieve RSSPARM's CLEAR parm */
   /* IS10076 params_ptr = admin_params->apiinit_handle;          */
   ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
    "RESUME_CLEARS_REVOKEDATE = <%c> , REVOKE_CLEARS_RESUMEDATE = <%c>",
    params_ptr->rssparm_RES_CLR_REV[0],
    params_ptr->rssparm_REV_CLR_RES[0]);
  /*  BS10006  Retrieve RSSPARM's CLEAR  ==> end   */

  res_pair = ADDINFO_search("RESUME_DATE",   RCF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
  rev_pair = ADDINFO_search("REVOKE_DATE",   RCF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
  /*  IS10100 - start */
  rulk_pair = ADDINFO_search("RU_LOCKED",   RCF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
  russpnd_pair = ADDINFO_search("RU_SUSPENDED", RCF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);

  if (russpnd_pair NE NULL)
  {
    if (strcmp(russpnd_pair->value, "Y") EQ 0)
      rev_res_req = USER_STAT_REVOKED;
    else
      if (strcmp(russpnd_pair->value, "N") EQ 0)
        rev_res_req = USER_STAT_ACTIVE;
  }
  else
  {
    if (rulk_pair NE NULL)
      if (strcmp(rulk_pair->value, "N") EQ 0)
        rev_res_req = USER_STAT_ACTIVE;
  }

  /* If RU_SUSPENDED or RU_LOCKED were not chanegd, check user params */
  if (rev_res_req EQ USER_STAT_IGNORED)
  {
  /*  IS10100 - end   */

    if (user_params->rev_status EQ USER_STAT_REVOKED)
    {
       ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                       "REVOKE user was requested");
       /* IS10100  ADDINFO_insert( TYPE_1A, "REVOKE", "", laddinfo,
                       RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       UNIQUE);  */
        rev_res_req = USER_STAT_REVOKED;          /* IS10100 */
       /* BS10006 NORESUME if RSSPARM's specified     ==> start    */
       if(params_ptr->rssparm_REV_CLR_RES[0] == REV_CLR_RES_ON)
          if (at_least_Z17 EQ RACF_YES)    /* only for z/os >= 1.7  */
             ADDINFO_insert( TYPE_1A, "NORESUME", "", laddinfo,
                            RCF_ADDINFO_KWD_LEN,
                            RCF_ADDINFO_VAL_LEN,
                            UNIQUE);
          else {  /* for z/os < 1.7, can't clear RESUME_DATE without
                     setting on REVOKE flag                        */
             CTSAMSG_print(RACF_ZOS_CLEARING,  msgs, NULL, dest,
                           REV_CLR_RES);
             rc = ESA_FATAL;
             goto exit;
          }
       /* BS10006 NORESUME if RSSPARM's specified     ==> end      */
       if (res_pair NE NULL) {
          ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                          "1. RESUME_DATE keyword located %s=%s",
                          res_pair->keyword, res_pair->value);
          if (strlen(res_pair->value) GT 0) {
             rc = RACF_revoke_date(res_pair->value, racf_date,
                                   dest, msgs);
             if (rc NE ESA_OK) {
                rc = ESA_FATAL;
                goto exit;
             }
             ADDINFO_insert(TYPE_1A,"RESUME", racf_date, laddinfo,
                            RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                            UNIQUE);
          }
       }
       if (rev_pair NE NULL)
          CTSAMSG_print(RACF_REVDATE_IGN,   msgs, NULL, dest);
    }

   /*
    *  Handle Revoke Status change to RESUME
    */

    else if (user_params->rev_status EQ USER_STAT_ACTIVE) {

       ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                       "RESUME user was requested");
       /* IS10100 ADDINFO_insert( TYPE_1A, "RESUME", "", laddinfo,
                       RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       UNIQUE);                   */
       rev_res_req = USER_STAT_ACTIVE;           /* IS10100 */
       /* BS10006 NOREVOKE if RSSPARM's specified     ==> start    */
       if(params_ptr->rssparm_RES_CLR_REV[0] == RES_CLR_REV_ON)
          if (at_least_Z17 EQ RACF_YES)    /* only for z/os >= 1.7  */
             ADDINFO_insert( TYPE_1A, "NOREVOKE", "", laddinfo,
                            RCF_ADDINFO_KWD_LEN,
                            RCF_ADDINFO_VAL_LEN,
                            UNIQUE);
          else {  /* for z/os < 1.7, can't clear REVOKE_DATE without
                     setting off REVOKE flag                       */
             CTSAMSG_print(RACF_ZOS_CLEARING,  msgs, NULL, dest,
                           RES_CLR_REV);
             rc = ESA_FATAL;
             goto exit;
          }
       /* BS10006 NOREVOKE if RSSPARM's specified     ==> end      */
       if (rev_pair NE NULL) {
          ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                          "1. REVOKE_DATE keyword located %s=%s",
                          rev_pair->keyword, rev_pair->value);
          if (strlen(rev_pair->value) GT 0) {
             rc = RACF_revoke_date(rev_pair->value, racf_date, dest,
                                   msgs);
             if (rc NE ESA_OK) {
                rc = ESA_FATAL;
                goto exit;
             }
             ADDINFO_insert(TYPE_1A,"REVOKE", racf_date, laddinfo,
                            RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                            UNIQUE);
          }
       }
       if (res_pair NE NULL)
          CTSAMSG_print(RACF_RESDATE_IGN,   msgs, NULL, dest);
    }
  }

  /* IS10100 - start */
  switch (rev_res_req)
  {
    case USER_STAT_REVOKED:
      ADDINFO_insert( TYPE_1A, "REVOKE", "", laddinfo,
                      RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                      UNIQUE);
      break;
    case USER_STAT_ACTIVE:
      ADDINFO_insert( TYPE_1A, "RESUME", "", laddinfo,
                      RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                      UNIQUE);
      break;
    default:
      break;
  }
  /* IS10100 - end   */

  /*
   *  Handle Revoke/Resume date change
   */
   /* BS10006 remove <<else>>
   else {
   */
     /*
      *  Handle REVOKE_DATE
      */

      if (rev_pair NE NULL) {
         ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                         "2. REVOKE_DATE keyword located %s=%s",
                         rev_pair->keyword, rev_pair->value);
         if (strlen(rev_pair->value) GT 0) {
            rc = RACF_revoke_date(rev_pair->value, racf_date, dest,
                                  msgs);
            if (rc NE ESA_OK) {
               rc = ESA_FATAL;
               goto exit;
            }
            ADDINFO_insert(TYPE_1A,"REVOKE", racf_date, laddinfo,
                           RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                           UNIQUE);
         }
         else { /* revoke_date was cleared */
  /* BS10006  NORESUME & NOREVOKE             --> start              */
             ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                             "NOREVOKE was requested");
             if (at_least_Z17 EQ RACF_YES) /* only for z/os >= 1.7  */
               ADDINFO_insert( TYPE_1A, "NOREVOKE", "", laddinfo,
                               RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                               UNIQUE);
             else { /* for z/os < 1.7, can't clear RESUME_DATE without
                       setting on REVOKE flag                        */
               CTSAMSG_print(RACF_REVOKE_CLEAR,   msgs, NULL, dest,
                             rev_pair->keyword);
               rc = ESA_FATAL;
               goto exit;
            }
  /* BS10006  NORESUME & NOREVOKE             --> end                */
         }   /* revoke_date was cleared */
      }

     /*
      *  Handle RESUME DATE
      */

      if (res_pair NE NULL) {
         ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                         "2. RESUME_DATE keyword located %s=%s",
                         res_pair->keyword, res_pair->value);
         if (strlen(res_pair->value) GT 0) {
            rc = RACF_revoke_date(res_pair->value, racf_date, dest,
                                  msgs);
            if (rc NE ESA_OK) {
               rc = ESA_FATAL;
               goto exit;
            }
            ADDINFO_insert(TYPE_1A,"RESUME", racf_date, laddinfo,
                           RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                           UNIQUE);
         }
         else { /* resume_date was cleared */
  /* BS10006  NORESUME & NOREVOKE             --> start              */
             ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                             "NORESUME was requested");
             if (at_least_Z17 EQ RACF_YES) /* only for z/os >= 1.7  */
               ADDINFO_insert( TYPE_1A, "NORESUME", "", laddinfo,
                               RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                               UNIQUE);
             else { /* for z/os < 1.7, can't clear RESUME_DATE without
                       setting on REVOKE flag                        */
               CTSAMSG_print(RACF_REVOKE_CLEAR,   msgs, NULL, dest,
                             res_pair->keyword);
               rc = ESA_FATAL;
               goto exit;
             }
  /* BS10006  NORESUME & NOREVOKE             --> end                */
         } /* resume_date was cleared */
      }
  /* BS10006 remove <<}>>
   }    revoke status was not changed */

   /****************************************************************
   *                                                               *
   *  Handle special NO_PKB flags for addinfo_concat function      *
   *                                                               *
   ****************************************************************/


   ADDINFO_insert_cond("NOCICS"         , KWD_FLAG_ON, addinfo,
                       "CICS.NO_PKB"    , KWD_FLAG_ON,
                       RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );
   ADDINFO_insert_cond("NODFP"          , KWD_FLAG_ON, addinfo,
                       "DFP.NO_PKB"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                        laddinfo );
   ADDINFO_insert_cond("NOTSO"          , KWD_FLAG_ON, addinfo,
                       "TSO.NO_PKB"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );
   ADDINFO_insert_cond("NOLANGUAGE"     , KWD_FLAG_ON, addinfo,
                       "LANGUAGE.NO_PKB", KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                        laddinfo );
   ADDINFO_insert_cond("NOOPERPARM"     , KWD_FLAG_ON, addinfo,
                       "OPERPARM.NO_PKB", KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );
   ADDINFO_insert_cond("NOWORKATTR"     , KWD_FLAG_ON, addinfo,
                       "WORKATTR.NO_PKB", KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );
   ADDINFO_insert_cond("NOOMVS"         , KWD_FLAG_ON, addinfo,
                       "OMVS.NO_PKB"    , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );

  /* ISAR0001 */
   ADDINFO_insert_cond("NONETVIEW"      , KWD_FLAG_ON, addinfo,
                       "NETVIEW.NO_PKB" , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );

  /* ps0156 */
   ADDINFO_insert_cond("NODCE"          , KWD_FLAG_ON, addinfo,
                       "DCE.NO_PKB"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );

  /* ps0163 */
   ADDINFO_insert_cond("NOOVM"          , KWD_FLAG_ON, addinfo,
                       "OVM.NO_PKB"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );

  /* ps0391 */
   ADDINFO_insert_cond("NOLNOTES"       , KWD_FLAG_ON, addinfo,
     /* IS10076A       "OVM.NO_PKB"     , KWD_FLAG_ON,              */
     /* IS10076A */    "LNOTES.NO_PKB"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );
   ADDINFO_insert_cond("NONDS"          , KWD_FLAG_ON, addinfo,
     /* IS10076A       "OVM NO_PKB"     , KWD_FLAG_ON,              */
     /* IS10076A */    "NDS.NO_PKB"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );

   /* IS10076 - start */
   if (params_ptr->rssparm_CUSTOM_FIELDS_SUPPORT[0] EQ 'Y')
     ADDINFO_insert_cond("NOCSDATA"       , KWD_FLAG_ON, addinfo,
                         "CSDATA.NO_PKB"     , KWD_FLAG_ON,
                          RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         laddinfo );
   /* IS10076 - end */

   /* PS0460           */

   cpair = ADDINFO_search("RESTRICTED", RCF_ADDINFO_KWD_LEN,
                          addinfo->pair, addinfo->num_pairs);
   if (cpair NE NULL) {
   /* ESA_DIAG_printf(ESA_COMP_ADDUSER, 1, ws2399 */
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                      "RESTRICTED keyword located %s=%s",
                      cpair->keyword, cpair->value);
      ADDINFO_insert_cond("RESTRICTED"     , KWD_FLAG_OFF, addinfo,
                       "NORESTRICTED"     , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                        laddinfo );
   } /*ps0460 thru here */

   /* IS10100 - start */
   /*
    *  Do command pre-processing required for CTSACF features.
    *  Currently we do not check the return code becasue we will
    *  issue the command anyway.
    */
   do_nocsdata = NULL_CHAR;
   RACF_Handle_CTSACF_Features(ESA_COMP_UPDUSER, 'U', CTSACF_pre_cmd,
                               addinfo, uaddinfo, user_params,
                               admin_params,
                               2, laddinfo, &do_nocsdata);

   ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
            "After RACF_Handle_CTSACF_Features:  do_nocsdata =%.1s",
            do_nocsdata);

   /* If any of the routines requested to remove the NOCSDATA=Y */
   /* replace it with NOxxx for all CSDATA. fields.             */
   if (params_ptr->rssparm_CUSTOM_FIELDS_SUPPORT[0] EQ 'Y'  AND
       do_nocsdata EQ 'N')
     CTSUpdUser_Remove_NocsdataY(addinfo, laddinfo, uaddinfo,
                                 &chg_addinfo, admin_params);

   /* IS10100 - end   */

   /****************************************************************
   *                                                               *
   *  Issue ALTUSER command                                        *
   *                                                               *
   ****************************************************************/
   /* IS10100A - start  */
   /*
   sprintf(cmd,"ALTUSER %s ", user_params->user);
   ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                   "Command header prepared (%s)", cmd);

   rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                cmd, MAX_OK_RC_0,
                2, addinfo_vec, mkt, kdt, dest, msgs,
                CMDOUT_YES, RACF_YES);                          */

   rc = RACF_do_AddAlt_cmd(ESA_COMP_UPDUSER, 'U',
                          user_params->user, "ALT",
                          chg_addinfo EQ NULL ? addinfo : chg_addinfo,
                          laddinfo, mkt, kdt,
                          CMDOUT_YES, RACF_YES, MAX_OK_RC_0,
                          admin_params);
   /* IS10100A - end  */

   if (rc NE ESA_OK)       /* ps0292 */
     goto exit;            /* ps0292 */

   /* WS10068 - start */

  /*
   *  If DFLTGRP had to be changed, and old DFLTGRP is known,
   *  disconnect the old default group, if needed.
   */
   if (chg_dfltgrp  AND  strlen(old_defug) NE 0)
   {
     rc = CTSUpdUser_post_DFLTGRP(user_params, old_defug, admin_params);
     if (rc NE ESA_OK)
       goto exit;
   }
   /* WS10068 - end   */
   /* WS10081 - start */


   if (ADDINFO_prefix_search("MFA.", RCF_ADDINFO_KWD_LEN,
                           TRUE,    /* include NULL value */
                           addinfo->pair, addinfo->num_pairs)  EQ NULL)
    goto skip_mfa;

   pair = ADDINFO_search("MFA.ENABLE", RCF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);
   if (pair NE NULL)
    if (strcmp(pair->value, "N") EQ 0)
      goto after_insert;

   rc = ADDINFO_insert(TYPE_1B, "MFA.ACTIVE", "",
             addinfo, RCF_ADDINFO_KWD_LEN,
             RCF_ADDINFO_VAL_LEN,  UNIQUE);
   if (rc NE ESA_OK)
   {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                   "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                   "UpdUsr ",user_params->user,"MFA.ACTIVE",rc);
      sprintf(msg,
      "%s %s: ADDINFO_insert keyword %s failed with rc %d",
      "UpdUsr ",user_params->user,"MFA.ACTIVE",rc);
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component,func, msg, 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
   }
   rc = ADDINFO_insert(TYPE_1B, "MFA.TAGS", "",
             addinfo, RCF_ADDINFO_KWD_LEN,
             RCF_ADDINFO_VAL_LEN,  UNIQUE);
   if (rc NE ESA_OK)
   {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                   "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                   "UpdUsr ",user_params->user,"MFA.TAGS",rc);
      sprintf(msg,
      "%s %s: ADDINFO_insert keyword %s failed with rc %d",
      "UpdUsr ",user_params->user,"MFA.TAGS",rc);
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component,func, msg, 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
   }
   after_insert:

   rc = RACF_MFA_cmd(ESA_COMP_UPDUSER,
                     user_params->user,
                     "UpdUsr",
                     addinfo,
                     uaddinfo,
                     admin_params);
   if (rc NE ESA_OK)
    goto exit;

   skip_mfa:
   /* WS10081 - end   */
  /*  ps0292
   *  Digital certificate processing  (RACDCERT ADD)
   */

   /* IS10100 - start */
   /*
    *  Do command post-processing required for CTSACF features.
    */
   RACF_Handle_CTSACF_Features(ESA_COMP_UPDUSER, 'U', CTSACF_post_cmd,
                               addinfo, uaddinfo, user_params,
                               admin_params,
                               1, laddinfo);
   /* IS10100 - end   */

   rc = RACF_Dig_cert_add(ESA_COMP_UPDUSER,
                          user_params, addinfo, laddinfo, /* ps0292 */
                          admin_params, dest, msgs);      /* ps0292 */
   if (rc NE ESA_OK)
     goto exit;

  /*  ps0292
   *  Digital certificate processing  (RACDCERT DELETE/ALTER)
   */
 /* SAS2IBMT typedef and prototype changed for IBM C
   rc = RACF_Dig_cert_upd(ESA_COMP_UPDUSER, &ctsfrlu,      * ps0292 * */
   rc = RACF_Dig_cert_upd(ESA_COMP_UPDUSER, (ASM_RTN_TYP *) &ctsfrlu,
                          user_params, addinfo, laddinfo, /* ps0292 */
                          admin_params, dest, msgs);      /* ps0292 */
   if (rc NE ESA_OK)
     goto exit;

   /****************************************************************
   *                                                               *
   *   Finish                                                      *
   *                                                               *
   ****************************************************************/

  exit:;

   /* IS10100 - start */
   ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "Output: user%s   rev_status=%d",
                  user_params->user, user_params->rev_status);

   if (uaddinfo NE NULL)
     ADDINFO_free(&uaddinfo);

   if (chg_addinfo NE NULL)
     ADDINFO_free(&chg_addinfo);

   /* IS10100 - end */

   ADDINFO_free(&laddinfo);

   ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

   return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_dfltgrp                         *
*                                                             *
* DESCRIPTION    : Update a RACF user default group           *
*                                                             *
* INPUT          :                                            *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CTSUpdUser_dfltgrp ( USER_PARAMS_rec_typ  * user_params,
                                   ADDINFO_rec_typ      * addinfo,
                 /* WS10068 */     ADDINFO_rec_typ      * in_laddinfo,
                 /* WS10068 */     ADDINFO_rec_typ      * uaddinfo,
                 /* WS10068 */     char                 * old_defug,
                                   ADMIN_PARAMS_rec_typ * admin_params)
                 /* WS10068        ERR_STRUCT_rec_typ   * err) */
{

#define   CONN_OWNER  "CONN_OWNER"                       /* WS10068 */

  static char         func[]="CTSUpdUser_dfltgrp";

 /*
  *   Variables
  */

  /* WS10068 ESA_RC                       rc, chk_rc ;         */
  ESA_RC                       rc = ESA_OK;              /* WS10068 */
  char                         cmd[MAX_API_ST];
  ADDINFO_rec_ptr              laddinfo = NULL;
  ONE_FIELD_rec_ptr            cpair = NULL;              /* WS10068 */
  char                       * group = NULL;              /* WS10068 */
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;
  /* @degrp@ UG_typ                       old_defug;   */

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /* WS10068
  * NO need to obtain old DFLTGRP because we already have it in
    uaddinfo.
  *
  *   Obtain old default group (if required to remove it)
  *

  chk_rc = RACF_extract_defug( user_params->user, old_defug,
                               dest, msgs);
  if (chk_rc NE ESA_OK) {
      rc = ESA_FATAL;
      goto exit;
  }

  *
  *  spr135
  *  Check new default group and old default group equivalence
  *

  if ( strcmp(old_defug,user_params->def_group) EQ 0 )  {
      rc = ESA_OK;
      goto exit;
  }
  */


  /* WS10068 - this code is moved a bit further.
  *
  *  Allocate local/internal addinfo
  *

  rc = ADDINFO_alloc(func, 10, &laddinfo, dest, msgs);
  if (rc NE ESA_OK) {
     rc = ESA_FATAL;
     goto exit;
  }
  */

  /* WS10068
  * This code is replaced by the code below checking the "groups"
  * keyword.
  *
  *   Check new default group connection existance
  *

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "Checking connection existance (%s/%s)",
                  user_params->user, user_params->def_group);
  chk_rc = RACF_chk_conn(user_params->user,
                         user_params->def_group, OBJ_EXIST,
                         FALSE, dest, msgs,
                         admin_params);             * WS2549 *
  */

  /* WS10068 - start */
 /*
  *   If the new DFLTGRP is the same as the current - nothing to do.
  */
  old_defug[0] = NULL_CHAR;
  cpair = ADDINFO_search ( "DFLTGRP", RCF_ADDINFO_KWD_LEN,
                           uaddinfo->pair,
                           uaddinfo->num_pairs );
  if (cpair NE NULL)
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                   "Current DFLTGRP = %s   new DFLTGRP = %s",
                    cpair->value, user_params->def_group );
    if ( strcmp(cpair->value,user_params->def_group) EQ 0 )
    {
      ADDINFO_delete(in_laddinfo, "DFLTGRP"); /* Nothing to do */
      rc = ESA_OK;
      goto exit;
    }
    else
      strcpy(old_defug, cpair->value);    /* return the old DFLTGRP */
  }
  else
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                   "DFLTGRP not retrieved");
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
               component,func,
               "DFLTGRP keyword is missing in uaddinfo",
               16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

 /*
  *   Check if user is connected to the new DFLTGRP
  */
  group = NULL;
  cpair = ADDINFO_search ( "groups", RCF_ADDINFO_KWD_LEN,
                           uaddinfo->pair,
                           uaddinfo->num_pairs );
  if (cpair NE NULL)
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                   "Groups = %s", cpair->value);
    group = ADDINFO_list_search (cpair->value, user_params->def_group,
                                 ADDINFO_LIST_ENTRY);
  }
  else
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                   " 'groups' not retrieved");
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
               component,func,
               " 'groups' keyword is missing in uaddinfo",
               16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
  }
  /* WS10068 - end   */

 /*
  *   Connect to new group, if not already connected.
  */

  /* WS10068 switch (chk_rc) {  */

  /* WS10068  case (ESA_OK):    */
  if (group NE NULL)  /* already connected ?   */        /* WS10068 */
  {                                                      /* WS10068 */
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                    "User %s already conected to group %s",
                    user_params->user, user_params->def_group );
     /* WS10068 break; */
  }                                                      /* WS10068 */
     /* WS10068 case ESA_ERR:  */
  else    /* not connected - need to connect/ */         /* WS10068 */
  {                                                      /* WS10068 */
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                    "Connecting user %s to new default group %s",
                    user_params->user, user_params->def_group );

     /* WS10068  - start  */
     rc = ADDINFO_alloc(func, 10, &laddinfo, dest, msgs);
     if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     }
     /* WS10068  - end    */

     /* WS10068 ADDINFO_empty(laddinfo);    */
     ADDINFO_insert(TYPE_1A, "GROUP", user_params->def_group,
                    laddinfo,
                    RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                    UNIQUE);

     /* WS10068  - start  */
     /*
      *  Get CONN_OWNER, if supplied.
      */
     cpair = ADDINFO_search ( CONN_OWNER, RCF_ADDINFO_KWD_LEN,
                              addinfo->pair,
                              addinfo->num_pairs );
     if (cpair NE NULL)
     {
       ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                    "CONN_OWNER = %s", cpair->value);
       ADDINFO_insert(TYPE_1A, "OWNER", cpair->value,
                      laddinfo,
                      RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                      UNIQUE);
     }
     /* WS10068  - end    */

     sprintf(cmd,"CONNECT %s ", user_params->user);
     rc = racfcmd(func, EXECOUT_DDNAME,
                  admin_params->admin_uname, cmd,
                  MAX_OK_RC_0, 1, &laddinfo, connect_mkt,
                  connect_kdt, admin_params,             /* IS10174 */
                  CMDOUT_YES, RACF_YES);                 /* IS10174 */
      /* IS10174  connect_kdt, dest, msgs, CMDOUT_YES, RACF_YES);   */
     if (rc NE ESA_OK)
        goto exit;
     /* WS10068 break;        */
  }                                                      /* WS10068 */
  /* WS10068
   *  The code below is removed

      *
      *   Error
      *

     default:

        rc = ESA_FATAL;
        goto exit;
        break;
  }
  */

 /* WS10068 - start  */
 /* The code below is replaced with setting the default group
  * in the caller laddinfo (in_laddinfo) so that it wil be added
  * to the ALTUSER command along with all other parameters.

  *
  *   Make the new connection the default
  *

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "Making connection to group %s the default",
                  user_params->def_group );

  ADDINFO_empty(laddinfo);
  ADDINFO_insert(TYPE_1A, "DFLTGRP", user_params->def_group, laddinfo,
                 RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                 UNIQUE);
  sprintf(cmd,"ALTUSER %s ", user_params->user);
  rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
               cmd, MAX_OK_RC_0,
               1, &laddinfo, mkt, kdt, dest, msgs,
               CMDOUT_YES, RACF_YES);

  if (rc NE ESA_OK)
     goto exit;
 */
 /*
  *  Set the defult group name in laddinfo so it will
  *  be set in the ALU command issue later.
  */
  cpair = ADDINFO_search ( "DFLTGRP", RCF_ADDINFO_KWD_LEN,
                           in_laddinfo->pair,
                           in_laddinfo->num_pairs );
  if (cpair NE NULL)
  {
    ADDINFO_updval(user_params->def_group,
                        RCF_ADDINFO_VAL_LEN, cpair);
    rc = ESA_OK;
  }
  else
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
             "DFLTGRP not found in laddinfo");
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
               component,func,
               " DFLTGRP keyword is missing in laddinfo",
               16,__LINE__);
    rc = ESA_FATAL;
  }
 /* WS10068 - end   */


 /* WS10068 - start   */
 /*
  *  The code below is moved to separate routine called after
  *  the ALU command is issued.

  *
  *   Remove old default group connection (if requested)
  *

  if (user_params->def_ug_action EQ OLD_DEF_UG_ACT_DROP) {

     ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
             "def_ug_action= %d", user_params->def_ug_action);
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
             "Removing old default connection to group %s", old_defug);

     ADDINFO_empty(laddinfo);
     ADDINFO_insert(TYPE_1A, "GROUP", old_defug, laddinfo,
                    RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                    UNIQUE);
     sprintf(cmd,"REMOVE %s ", user_params->user);
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname, cmd,
                  MAX_OK_RC_0, 1, &laddinfo, connect_mkt, connect_kdt,
                  dest, msgs, CMDOUT_YES, RACF_YES);
     if (rc NE ESA_OK)
        goto exit;
  }
  */

 /*
  *    Finished default group  processing
  */

  exit:;

  ADDINFO_free(&laddinfo);

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

  return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_lists                           *
*                                                             *
* DESCRIPTION    : Update a RACF user                         *
*                                                             *
* INPUT          :                                            *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
/* IS10100 - start */
/*
static ESA_RC CTSUpdUser_lists (short                  delta_num,
                                DELTA_DESC_rec_typ   * delta,
                                USER_PARAMS_rec_typ  * user_params,
                                ADDINFO_rec_typ      * addinfo,
                                ADMIN_PARAMS_rec_typ * admin_params,
                                ERR_STRUCT_rec_typ   * err)
*/
static ESA_RC CTSUpdUser_lists (USER_PARAMS_rec_typ  * user_params,
                                ADDINFO_rec_typ      * addinfo,
                                ADDINFO_rec_typ      * uaddinfo,
                                ADMIN_PARAMS_rec_typ * admin_params,
                                ERR_STRUCT_rec_typ   * err)
/* IS10100 - end   */
{

  static char         func[]="CTSUpdUser_lists";

 /*
  *   Variables
  */

  ESA_RC                       rc;
  char                         cmd[MAX_API_ST];
  ADDINFO_rec_ptr              laddinfo = NULL;
  /* IS10100 ONE_FIELD_rec_ptr            cpair;                 */
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;
  /* IS10100 char             msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100]; */

  /* IS10100 - fields below are not neede since GetUser was moved out
  OBJ_EXISTS_typ               obj_exist;        * GTUSERS params   *
  HAVE_MORE_typ                have_more;        * GTUSERS params   *
  void                       * handle;           * GTUSERS params   *
  short                        actual_num ;      * GTUSERS params   *
  USER_PARAMS_rec_typ          user;             * GTUSERS params   *
  char                         get_conn = 'N';            // CIQ#6 //
  */

  /* IS10100 short i, delta_count;               * Delta Processing */
  short i;                          /* IS10100 -   Delta Processing */
  ESA_RC rc_add, rc_del;                        /* Delta Processing */
  int   copy_size;                  /* WS10082 */
 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /* IS10100 - start
 /* The code below was moved to CTSUpdUser_ChkOrGet_User
  *
  *   Check if any of the delta keywords were specified
  *

  delta_count=0;
  for (i=0; i LT delta_num; i++) {
      delta[i].kwd_found = 0;  * BSAR1007 *
      strcpy( delta[i].newval, NULL_STRING);
      cpair = ADDINFO_search(delta[i].kwd,  RCF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs );
      if (cpair NE NULL) {
         strcpy( delta[i].newval, cpair->value);
         ESA_DIAG_printf(ESA_COMP_UPDUSER, 2,
                  "Delta %d: '%s' at %X", i, delta[i].kwd, cpair);
         delta_count++;
         delta[i].kwd_found = 1;  * BSAR1007 *
         delta[i].add_typ   = cpair->add_typ;

         if ( (cpair->add_typ NE TYPE_1B ) AND
              (cpair->add_typ NE TYPE_2B )   ) {
            sprintf(msgbuf, "Invalid type=%d for list keyword=%s",
                    cpair->add_typ,  cpair->keyword);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func, msgbuf, 0, __LINE__);
         }

      }
  }
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "Delta keywords count = %d", delta_count);

  *
  *   If no delta keywords, finish
  *

  if ( delta_count EQ 0 ) {
     rc = ESA_OK;
     goto exit;
  }

  *
  *   Prepare parameters to obtain old user values
  *

  rc = ADDINFO_alloc(func, delta_num, &laddinfo, dest, msgs);
  if (rc NE ESA_OK) {
     rc = ESA_FATAL;
     goto exit;
  }

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "Obtaining user %s details", user_params->user);

  for (i=0; i LT delta_num; i++)
      ADDINFO_insert(TYPE_1B, delta[i].kwd, NULL_STRING,
                     laddinfo, RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                     UNIQUE);

  if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GT 2)
     ADDINFO_dump(laddinfo ,1);

  *
  *   Obatain user details of delta values
  *

  actual_num = 0;
  have_more = NO_MORE;
  handle = NULL;
  obj_exist = OBJ_NOT_EXIST;

  rc = CTSGetUsers ( GET_MANY_USERS, "", 1, &actual_num,
                     &have_more, &handle,
                     1, user_params, &user, &laddinfo, &obj_exist,
                     admin_params, err,
                     get_conn);                             // CIQ#6 //

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "Obtained user %s rc=%d", user_params->user, rc);

  if ( (rc NE ESA_OK) OR (obj_exist NE OBJ_EXIST) ) {
     rc = ESA_FATAL;
     goto exit;
  }

  if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GT 1)
     ADDINFO_dump(laddinfo,1);

  */
  /*  IS10100 - end  */

 /*
  *    Analyze differance between old and new value
  */

  /* IS10100 for (i=0; i LT delta_num; i++) {   */
  for (i=0; i LT DELTA_NUM; i++)                  /* IS10100  */
  {
      strcpy( delta[i].addval, NULL_STRING);
      strcpy( delta[i].delval, NULL_STRING);

      if ( delta[i].kwd_found )        /* BSAR1007 */
      {
        /*IS10100 strcpy( delta[i].oldval, laddinfo->pair[i].value); */
        /* WS10068 - start */
         /*
         strcpy( delta[i].oldval, uaddinfo->pair[i].value);  *IS10100*
         */
         strcpy( delta[i].oldval,
                 uaddinfo->pair[delta[i].curr_entry_index].value);
        /* WS10068 - end   */
         /***WS10082A we assume the value is always LE 16K*/
         rc_add = ADDINFO_list_diff(delta[i].newval, delta[i].oldval,
                                    delta[i].addval,
                                    ADDINFO_LIST_ENTRY,
                                    ADDINFO_LIST_ENTRY);
         rc_del = ADDINFO_list_diff(delta[i].oldval, delta[i].newval,
                                    delta[i].delval,
                                    ADDINFO_LIST_ENTRY,
                                    ADDINFO_LIST_ENTRY);
         ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
               "Add: diff rc=%d addval=%s", rc_add, delta[i].addval);
         ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
               "Del: diff rc=%d delval=%s", rc_del, delta[i].delval);
         if ( (rc_del NE ESA_OK) OR (rc_add NE ESA_OK) ) {
            CTSAMSG_print(RACF_LISTDIFF, msgs, NULL, dest,
                          delta[i].newval);
            rc = ESA_FATAL;
            goto exit;
         } /* Error in lists processing */
      } /* Keyword specfied */
  } /* Loop on delta array */

 /* IS10100 - start */
 /*
  *   Prepare addinfo for deta keywords update.
  */

 /*IS10100 rc = ADDINFO_alloc(func, delta_num, &laddinfo, dest, msgs);*/
  rc = ADDINFO_alloc(func, DELTA_NUM, &laddinfo, dest, msgs);/*IS10100*/
  if (rc NE ESA_OK) {
     rc = ESA_FATAL;
     goto exit;
  }
 /* IS10100 - end   */

 /*
  *   Delete deleted items
  */

  /* IS10100 ADDINFO_empty(laddinfo);   */
  /* IS10100 for (i=0; i LT delta_num; i++) { */
  for (i=0; i LT DELTA_NUM; i++)                         /* IS10100 */
  {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
          "Delta %d:%s: delval=%s", i, delta[i].kwd, delta[i].delval);
      if (strlen(delta[i].delval) GT 0)
         ADDINFO_insert(TYPE_1B, delta[i].delkwd,
                        delta[i].delval, laddinfo, RCF_ADDINFO_KWD_LEN,
                        RCF_ADDINFO_VAL_LEN, UNIQUE);
  }

  if (laddinfo->num_pairs GT 0)
  {
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                     "Deleting deleted list items");
     sprintf(cmd,"ALTUSER %s ", user_params->user);
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                  cmd, MAX_OK_RC_0,
                  1, &laddinfo, mkt, delta_kdt,          /* IS10174 */
                  admin_params,                          /* IS10174 */
                  CMDOUT_YES, RACF_YES);
      /* IS10174  1, &laddinfo, mkt, delta_kdt, dest, msgs,         */
     if (rc NE ESA_OK)
        goto exit;
  }

 /*
  *   Add added items
  */

  ADDINFO_empty(laddinfo);
  /* IS10100  for (i=0; i LT delta_num; i++) {                  */
  for (i=0; i LT DELTA_NUM; i++)                         /* IS10100 */
  {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
          "Delta %d:%s: addval=%s", i, delta[i].kwd, delta[i].addval);
      if (strlen(delta[i].addval) GT 0)
         ADDINFO_insert(TYPE_1B, delta[i].addkwd,
                        delta[i].addval, laddinfo, RCF_ADDINFO_KWD_LEN,
                        RCF_ADDINFO_VAL_LEN, UNIQUE);
  }

  if (laddinfo->num_pairs GT 0)
  {
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                     "Adding added list items");
     sprintf(cmd,"ALTUSER %s ", user_params->user);
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                  cmd, MAX_OK_RC_0,
                  1, &laddinfo, mkt, delta_kdt,          /* IS10174 */
                  admin_params,                          /* IS10174 */
                  CMDOUT_YES, RACF_YES);
      /* IS10174  1, &laddinfo, mkt, delta_kdt, dest, msgs,         */
     if (rc NE ESA_OK)
        goto exit;
  }

 /*
  *    Finished delta processing
  */

  exit:;

  ADDINFO_free(&laddinfo);

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

  return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_interval                        *
*                                                             *
* DESCRIPTION    : Update a RACF user password interval       *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CTSUpdUser_interval( char                 * interval,
                                   USER_PARAMS_rec_typ  * user_params,
                                   ADMIN_PARAMS_rec_typ * admin_params,
                                   ERR_STRUCT_rec_typ   * err)
{

  static char         func[]="CTSUpdUser_interval";

 /*
  *   Variables
  */

  char                         cmd[MAX_API_ST];
  ESA_RC               pro_rc, rc = ESA_OK;
  MS_FLAG_typ                    protected;         /* IS10147B */
  /* IS10147B RACF_FLAG_typ              protected; */
  ADDINFO_rec_ptr              laddinfo = NULL;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *   Fail operation if RACF = 1.9 no password was changed
  */

  if ( (strcmp(admin_params->rss_type, RACF19_RSS_TYPE) EQ 0) AND
      ((strcmp(user_params->passwd, BACKSLASH_ALT  ) EQ 0) /*IS10147C*/
    OR (strcmp(user_params->passwd, BACKSLASH_STR  ) EQ 0) )) {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "UPDUSER",
                   func, "INTRVL/NPSSWD", 16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  /*ps0460 from here*/
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
          "Extracting user %s PROTECTED attribute", user_params->user);
  /* change parameters                                        IS10147B */
  /*pro_rc=RACF_pro_user(user_params->user,&protected,TRUE,dest,msgs);*/
    pro_rc = RACF_pro_user(user_params->user,&protected,admin_params);
  if (pro_rc NE ESA_OK) {;
     rc = ESA_FATAL;
     goto exit;
  }
  /* IS10174 if (protected EQ RACF_YES) {   */
  if (protected EQ MS_YES) {                             /* IS10174 */
      CTSAMSG_print(RACF_PROTECTED_INTERVAL,
                         msgs, NULL, dest, interval, user_params->user);
     rc = ESA_FATAL;
     goto exit;
  }    /* to here ps0460 */

 /*
  *   Prepare to issue PASSWORD command
  */

  rc = ADDINFO_alloc(func, 10, &laddinfo, dest, msgs);
  if (rc NE ESA_OK) {
     rc = ESA_FATAL;
     goto exit;
  }

 /*
  *   INTERVAL paramter can be set to the following values :
  *
  *       YES - use default site interval
  *       NO  - no password interval enforced
  *       nnn - interval in days
  */

  if (strcmp(interval, "YES") EQ 0 )
     ADDINFO_insert(TYPE_1A,"INTERVAL", NULL_STRING, laddinfo,
                    RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                    UNIQUE);
  else if (strcmp(interval, "NO") EQ 0 )
     ADDINFO_insert(TYPE_1A,"NOINTERVAL", KWD_FLAG_ON, laddinfo,
                    RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                    UNIQUE);
  else
     ADDINFO_insert(TYPE_1A,"INTERVAL", interval, laddinfo,
                    RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                    UNIQUE);

 /*
  *     Insert the user name to local addinfo
  */

  ADDINFO_insert( TYPE_1A, "USER",user_params->user, laddinfo,
                  RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                  UNIQUE);

 /*
  *     issue PASSWORD command to change user's interval
  */

  strcpy(cmd, "PASSWORD ");
  rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname, cmd,
               MAX_OK_RC_0, 1, &laddinfo, mkt, password_kdt,
               admin_params, CMDOUT_YES, RACF_YES);      /* IS10174 */
   /* IS10174  dest, msgs, CMDOUT_YES, RACF_YES);                   */

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "password command rc = %d", rc);

 /*
  *     Issue success/failure message for interval change
  */

  if (rc NE ESA_OK) {
     CTSAMSG_print( RACF_INTERVAL_FAIL, msgs, NULL, dest,
                    user_params->user);
     goto exit;
  }
  CTSAMSG_print( RACF_INTERVAL_OK, msgs, NULL, dest,
                 user_params->user);

 /*
  *    Finished interval processing
  */

  exit:;

  ADDINFO_free(&laddinfo);

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

  return rc;

}

#if 0         /* Deleted by BS2459 */
/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_clear_mform                     *
*                                                             *
* DESCRIPTION    : Clear OPERPARM.MFORM field                 *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CTSUpdUser_clear_mform (
                                   USER_PARAMS_rec_typ  * user_params,
                                   ADMIN_PARAMS_rec_typ * admin_params,
                                   ERR_STRUCT_rec_typ   * err)
{

  static char         func[]="CTSUpdUser_clear_mform";

 /*
  *   Variables
  */

  char                         cmd[MAX_API_ST];
  ESA_RC                       rc = ESA_OK;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *     issue ALTUSER command to clear OPERPARM.MFORM field
  */

  sprintf( cmd,"ALTUSER %s OPERPARM(NOMFORM)", user_params->user );
  rc = racfcmd( func, EXECOUT_DDNAME, admin_params->admin_uname,
                cmd, MAX_OK_RC_0,
                0,NULL, mkt, kdt, admin_params,          /* IS10174 */
                CMDOUT_YES, RACF_YES);                   /* IS10174 */
    /* IS10174  0,NULL, mkt, kdt, dest, msgs,CMDOUT_YES, RACF_YES); */

 /*
  *    Finished
  */

  exit:;

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

  return rc;

}
#endif        /* Deleted by BS2459 */

/* BS2459 */
/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_clear_operparm_attr             *
*                                                             *
* DESCRIPTION    : Clear OPERPARM.<attr> field                *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CTSUpdUser_clear_operparm_attr (
                                   USER_PARAMS_rec_typ  * user_params,
                                   char                 * attr,
                                   ADMIN_PARAMS_rec_typ * admin_params,
                                   ERR_STRUCT_rec_typ   * err)
{

  static char         func[]="CTSUpdUser_clear_operparm_attr";

 /*
  *   Variables
  */

  char                         cmd[MAX_API_ST];
  ESA_RC                       rc = ESA_OK;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *   issue ALTUSER command to clear OPERPARM.<attr> field
  */

  sprintf( cmd,"ALTUSER %s OPERPARM(%s)", user_params->user, attr);
  rc = racfcmd( func, EXECOUT_DDNAME, admin_params->admin_uname,
                cmd, MAX_OK_RC_0,
                0,NULL, mkt, kdt, admin_params,          /* IS10174 */
                CMDOUT_YES, RACF_YES);                   /* IS10174 */
   /* IS10174   0,NULL, mkt, kdt, dest, msgs,CMDOUT_YES, RACF_YES); */

 /*
  *    Finished
  */

  exit:;

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

  return rc;

}

/* IS10100 - start */
/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_lists                           *
*                                                             *
* DESCRIPTION    : Check if user exists, and get user details *
*                  is required.                               *
*                  User details are required when uaddinfo is *
*                  not NULL and one of the items below is     *
*                  true:                                      *
*                  1. Delta fields were specified.            *
*                  2. Site custom fields are supported,       *
*                     NOCSDATA was requested, and there is    *
*                     at least one active CTSACF feature.     *
*                                                             *
* INPUT          : user_params - user params recieved from    *
*                                UpdateUser caller            *
*                : addinfo     - addinfo containing required  *
*                                changes.                     *
*                : in_laddinfo - GetUser addinfo conaining    *
*                                additional changes.          *
*                                                             *
* OUTPUT         : uaddinfo    - if GetUser is done, it wil   *
*                                point to addinfo containing  *
*                                retrieved data. Othersie     *
*                                NULL.                        *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
static ESA_RC CTSUpdUser_ChkOrGet_User(
                                USER_PARAMS_rec_typ  * user_params,
                                ADDINFO_rec_typ      * addinfo,
               /* WS10068 */    ADDINFO_rec_typ      * in_laddinfo,
                                ADDINFO_rec_ptr      * uaddinfo,
                                ADMIN_PARAMS_rec_typ * admin_params,
                                ERR_STRUCT_rec_typ   * err)
{

  #define CSDATA_PREFIX     "CSDATA."
  #define ADDITINAL_ENTRIES  5
  #define GRP_NUM            2                           /* WS10068 */
  #define MFA_NUM            5                           /* WS10082N*/

  /*
   *   Variables
   */

  static char         func[]="CTSUpdUser_ChkOrGet_User";

  ESA_RC                       rc;
  ADDINFO_rec_ptr              laddinfo = NULL;
  ONE_FIELD_rec_ptr            cpair;
  ONE_FIELD_rec_ptr            nocsdata_pair;
  /*WS10082 char           msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];     */
  char                         msgbuf[134];                /*WS10082*/

  OBJ_EXISTS_typ               obj_exist;       /* GTUSERS params   */
  HAVE_MORE_typ                have_more;       /* GTUSERS params   */
  void                       * handle;          /* GTUSERS params   */
  short                        actual_num ;     /* GTUSERS params   */
  USER_PARAMS_rec_typ          user;            /* GTUSERS params   */
  char                         get_conn = 'N';             /* CIQ#6 */

  short i, delta_count;                         /* Delta Processing */
  char                         msg[200] = { NULL_CHAR };  /* WS10081 */
  int                          MFA = FALSE;               /* WS10081 */

  RACF_PARAMS_rec_typ        * params_ptr = NULL;
  /* WS10068  - start */
  /*  Init the fields

  RACF_CTSACF_block_ptr        ctsacf_blk;
  int                          ctsacf_num;
  int                          need_csdata;
  int                          csdata_num;        */

  RACF_CTSACF_block_ptr        ctsacf_blk = NULL;
  int                          ctsacf_num = 0;
  int                          need_csdata = FALSE;
  int                          csdata_num = 0;
  int                          dfltgrp_chg = FALSE;
  /* WS10068  - end   */
  char                         full_cfname[16];
  RACF_CUSTOM_FIELDS_block_ptr cfb;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

  /*
   *   Initialization
   */
  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;
  params_ptr = admin_params->apiinit_handle;

  /* WS10068 ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                 "Input: uaddinfo = %8X", uaddinfo); */
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,                   /* WS10068 */
        "Input: uaddinfo = %8X,  addinfo = %8X,  in_laddinfo = %8X",
         uaddinfo, addinfo, in_laddinfo);                /* WS10068 */
  /*
   *   Check if any of the delta keywords were specified
   */
  if (uaddinfo NE NULL)
  {
    delta_count = 0;
    for (i = 0; i LT DELTA_NUM; i++)
    {
      delta[i].kwd_found = 0;
      strcpy( delta[i].newval, NULL_STRING);
      cpair = ADDINFO_search(delta[i].kwd,  RCF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs );
      if (cpair NE NULL)
      {

        /* WS10082A we assume the value is LE 16K */
        strcpy( delta[i].newval, cpair->value);
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "Delta %d: '%s' at %X", i, delta[i].kwd, cpair);
        delta_count++;
        delta[i].kwd_found = 1;
        delta[i].add_typ   = cpair->add_typ;

        if ( (cpair->add_typ NE TYPE_1B ) AND
             (cpair->add_typ NE TYPE_2B )   )
        {
          sprintf(msgbuf, "Invalid type=%d for list keyword=%s",
                  cpair->add_typ,  cpair->keyword);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                        component, func, msgbuf, 0, __LINE__);
        }
      }
    }

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "Delta keywords count = %d", delta_count);

    /*
     *  If NOCSDATA=Y was requested, we need to retrieve the
     *  site custom fields.
     */
    need_csdata = FALSE;
    if (params_ptr->rssparm_CUSTOM_FIELDS_SUPPORT[0] EQ 'Y'  AND
        params_ptr->p_user_CFields NE NULL)
    {
      nocsdata_pair = ADDINFO_search("NOCSDATA",
                              RCF_ADDINFO_KWD_LEN,
                              addinfo->pair,
                              addinfo->num_pairs );
      if (nocsdata_pair NE NULL   AND
          nocsdata_pair->vallen GT 0  AND
          strcmp(nocsdata_pair->value, KWD_FLAG_ON) EQ 0)
        need_csdata = TRUE;
    }

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                    "need_csdata = %d", need_csdata);

    /*
     *  We need to retrieve all active CTSACF fields.
     */
    ctsacf_blk = params_ptr->p_u_ctsacfs;
    ctsacf_num = 0;

    if (ctsacf_blk NE NULL)
    {
      for (i = 0; i LT ctsacf_blk->num_of_entries; i++)
      {
        if (ctsacf_blk->entries[i].act EQ ACT_YES)
          ctsacf_num++;
      }
    }

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                    "Active CTSACF fields count = %d", ctsacf_num);

    /* WS10068 - start */
    /*  If DFLTGRP is changed, we need DFLTGRP and groups.      */
    dfltgrp_chg = FALSE;
    if (in_laddinfo NE NULL)
    {
      cpair = ADDINFO_search("DFLTGRP",  RCF_ADDINFO_KWD_LEN,
                              in_laddinfo->pair,
                              in_laddinfo->num_pairs );
      if (cpair NE NULL)
        dfltgrp_chg = TRUE;

      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                      "dfltgrp_chg = %d", dfltgrp_chg);
    }
    /* WS10068 - end   */
  }
  /* WS10081 - start */
  MFA = FALSE;
  if (ADDINFO_prefix_search("MFA.", RCF_ADDINFO_KWD_LEN,
                           TRUE,    /* include NULL value */
                           addinfo->pair, addinfo->num_pairs) NE NULL)
      MFA = TRUE;
  /* MFA = TRUE;     TEST */
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                      "MFA = %d", MFA);
  /* WS10081 -  end */

  /*
   *  Decide if we need to get current user information, or it is
   *  enough to check user existance.
   *
   *  We need to get user data when there are delta fields OR
   *  (NOCSDATA=Y was requetsed AND the user may have data in
   *  CTSACF fields) or DFLTGRP is changed.
   *
   *  In all other cases, we just have to call RACF_Chk_User
   *  to verify user existance.
   */
  /* @dfltgrp@
  if ( (delta_count GT 0   OR  ctsacf_num GT 0  OR  need_csdata)  AND */
  if ( (delta_count GT 0  OR  ctsacf_num GT 0  OR
        MFA OR                                           /* WS10081 */
        need_csdata  OR  dfltgrp_chg)   AND              /* WS10068 */
       uaddinfo NE NULL )
  {
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,                   /* WS10081 */
                      "before laddinfo alloc");          /* WS10081 */
    /*
     *   Prepare parameters to obtain old user values
     */
    csdata_num = 0;
    if (need_csdata)
    {
      for (cfb = params_ptr->p_user_CFields; cfb NE NULL;
           cfb = cfb->next_block)
      {
         csdata_num += cfb->used_fields_count;
      }
    }

    /* WS10068
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "Site Custom fields count = %d", csdata_num); */

    /* WS10068 - start */
    /* rc = ADDINFO_alloc(func,
            DELTA_NUM + csdata_num + ctsacf_num + ADDITINAL_ENTRIES,
            &laddinfo, dest, msgs);  */

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
    "ADDINFO size: delta = %d  csdata = %d/%d  acf = %d  dfgrp = %d/%d",
       delta_count, need_csdata, csdata_num, ctsacf_num,
       dfltgrp_chg, GRP_NUM);

    rc = ADDINFO_alloc(func,
                       ( (delta_count GT 0 ? delta_count : 0) +
                         (need_csdata ? csdata_num : 0) +
                         (ctsacf_num GT 0 ? ctsacf_num : 0) +
                         (dfltgrp_chg ? GRP_NUM : 0) +
                         (MFA ? MFA_NUM : 0) +            /* WS10082N */
                         ADDITINAL_ENTRIES ),
                       &laddinfo, dest, msgs);
    /* WS10068 - end   */
    if (rc NE ESA_OK)
    {
       rc = ESA_FATAL;
       goto exit;
    }

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,                 /* WS10068 */
                    "ADDINFO_alloc:  max_pairs = %d",    /* WS10068 */
                    laddinfo->max_pairs);                /* WS10068 */

    /*  Add delta parameters to addinfo  */
    if (delta_count NE 0)                                /* WS10068 */
    {                                                    /* WS10068 */
      for (i=0; i LT DELTA_NUM; i++)
      {
        if (delta[i].kwd_found EQ 1)                     /* WS10068 */
        {
          ADDINFO_insert(TYPE_1B, delta[i].kwd, NULL_STRING,
                         laddinfo, RCF_ADDINFO_KWD_LEN,
                         RCF_ADDINFO_VAL_LEN,  UNIQUE);
          delta[i].curr_entry_index =                    /* WS10068 */
                             laddinfo->num_pairs - 1;    /* WS10068 */
        }
      }
    }                                                    /* WS10068 */

    /*  If NOCSDATA=Y and there are CTSACF feature, we need     */
    /*  all the CSDATA fields the user has.                     */
    if (need_csdata)
    {
      for (cfb = params_ptr->p_user_CFields; cfb NE NULL;
           cfb = cfb->next_block)
      {
        for (i = 0; i LT cfb->used_fields_count; i++)
        {
          ADDINFO_insert(TYPE_1A, cfb->fields[i].name, NULL_STRING,
                         laddinfo, RCF_ADDINFO_KWD_LEN,
                         RCF_ADDINFO_VAL_LEN,  UNIQUE);
        }
      }
    }

      /*  Add CTSACF fields to addinfo  */
    /* WS10068 if (ctsacf_blk NE NULL)                        */
    if (ctsacf_num GT 0)
    {
      /* WS10068 strcpy(full_cfname, CSDATA_PREFIX);         */
      for (i = 0; i LT ctsacf_blk->num_of_entries; i++)
      {
        if (ctsacf_blk->entries[i].act EQ ACT_YES)
        {
          strcpy(full_cfname, CSDATA_PREFIX);
          strcat(full_cfname, ctsacf_blk->entries[i].CF_name);
          ADDINFO_insert(TYPE_1A, full_cfname, NULL_STRING,
                         laddinfo, RCF_ADDINFO_KWD_LEN,
                         RCF_ADDINFO_VAL_LEN,  UNIQUE);
        }
      }
    }

    /* WS10068 - start */
    /*  When defauit group is changed - we need to retrieve  */
    /*  the default group and all groups.                    */
    if (dfltgrp_chg)
    {
      ADDINFO_insert(TYPE_1B, "groups", NULL_STRING,
                         laddinfo, RCF_ADDINFO_KWD_LEN,
                         RCF_ADDINFO_VAL_LEN,  UNIQUE);
      get_conn = 'Y';
    }
    /* WS10068 - end  */

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "Obtaining user %s details", user_params->user);
    if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GT 5)
       ADDINFO_dump(laddinfo ,1);

    /* WS10081 - start*/
    /* Ws10082N
    if (ADDINFO_prefix_search("MFA.", RCF_ADDINFO_KWD_LEN,
                          TRUE,
                          addinfo->pair, addinfo->num_pairs)  NE NULL)*/

    if (MFA)                                              /* WS10082N */
    {
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                     "inserting MFA keywords to laddinfo");

     rc = ADDINFO_insert(TYPE_1B, "MFA.FACTORS", "",
                    laddinfo, RCF_ADDINFO_KWD_LEN,
                    RCF_ADDINFO_VAL_LEN,  UNIQUE);
     if (rc NE ESA_OK)
     {
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                  "UpdUsr ",user_params->user,"MFA.FACTORS",rc);
        sprintf(msg,
        "%s %s: ADDINFO_insert keyword %s failed with rc %d",
        "UpdUsr ",user_params->user,"MFA.FACTORS",rc);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                      component,func, msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     rc = ADDINFO_insert(TYPE_1B, "MFA.POLICIES", "",
                    laddinfo, RCF_ADDINFO_KWD_LEN,
                    RCF_ADDINFO_VAL_LEN,  UNIQUE);
     if (rc NE ESA_OK)
     {
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                 "UpdUsr ",user_params->user,"MFA.POLICIES",rc);
        sprintf(msg,
        "%s %s: ADDINFO_insert keyword %s failed with rc %d",
        "UpdUsr ",user_params->user,"MFA.POLICIES",rc);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                      component,func, msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     rc = ADDINFO_insert(TYPE_1B, "MFA.ACTIVE", "",
                    laddinfo, RCF_ADDINFO_KWD_LEN,
                    RCF_ADDINFO_VAL_LEN,  UNIQUE);
     if (rc NE ESA_OK)
     {
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                 "UpdUsr ",user_params->user,"MFA.ACTIVE",rc);
        sprintf(msg,
        "%s %s: ADDINFO_insert keyword %s failed with rc %d",
        "UpdUsr ",user_params->user,"MFA.ACTIVE",rc);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                      component,func, msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     rc = ADDINFO_insert(TYPE_1B, "MFA.TAGS", "",
                    laddinfo, RCF_ADDINFO_KWD_LEN,
                    RCF_ADDINFO_VAL_LEN,  UNIQUE);
     if (rc NE ESA_OK)
     {
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                 "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                 "UpdUsr ",user_params->user,"MFA.TAGS",rc);
        sprintf(msg,
        "%s %s: ADDINFO_insert keyword %s failed with rc %d",
        "UpdUsr ",user_params->user,"MFA.TAGS",rc);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                      component,func, msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
     rc = ADDINFO_insert(TYPE_1A, "MFA.PWFALLBACK",NULL_CHAR,
                         laddinfo,
                         RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                         UNIQUE);
     if (rc NE ESA_OK)
     {
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "%s %s ADDINFO_insert keyword %s failed with rc %d" ,
                  "UpdUsr ",user_params->user,"MFA.PWFALLBACK",rc);
        sprintf(msg,
        "%s %s: ADDINFO_insert keyword %s failed with rc %d",
        "UpdUsr ",user_params->user,"MFA.PWFALLBACK",rc);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                      component,func, msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
    }
    /* WS10081 - end  */
    /*
     *   Obatain user details of delta values
     *   and/or MFA parameters   WS10081
     */

    actual_num = 0;
    have_more = NO_MORE;
    handle = NULL;
    obj_exist = OBJ_NOT_EXIST;

    rc = CTSGetUsers ( GET_MANY_USERS, "", 1, &actual_num,
                       &have_more, &handle,
                       1, user_params, &user, &laddinfo, &obj_exist,
                       admin_params, err,
                       get_conn);                           /* CIQ#6 */

    ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                    "Obtained user %s rc=%d", user_params->user, rc);
    if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GT 1) /* WS10081 */
       ADDINFO_dump(laddinfo,1);                          /* WS10081 */

    if ( (rc NE ESA_OK) OR (obj_exist NE OBJ_EXIST) )
    {
      rc = ESA_FATAL;
      goto exit;
    }

    /*
     *  if the user is revoked, add an entry to addinfo so that
     *  other routines examining this addinfo will see it.
     */
    if (user.rev_status EQ USER_STAT_REVOKED)
      ADDINFO_insert(TYPE_1A, "REVOKED", KWD_FLAG_ON,
                     laddinfo, RCF_ADDINFO_KWD_LEN,
                     RCF_ADDINFO_VAL_LEN,  UNIQUE);

    /* WS10068  - start */
    if (dfltgrp_chg)
      ADDINFO_insert(TYPE_1A, "DFLTGRP", user.def_group,
                     laddinfo, RCF_ADDINFO_KWD_LEN,
                     RCF_ADDINFO_VAL_LEN,  UNIQUE);
    /* WS10068  - end   */

    if ( ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GT 1)
       ADDINFO_dump(laddinfo,1);

    *uaddinfo = laddinfo;       /* return addinfo with user data    */
  }
  else
  {
    /* Call RACF_chk_user to check user existance  */
    rc = RACF_chk_user(user_params->user, OBJ_EXIST,
                       TRUE, dest, msgs);
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 2,                 /* WS10068 */
                  "RACF_chk_user for user %s:  rc = %d", /* WS10068 */
                    user_params->user, rc);              /* WS10068 */
    if ( rc NE ESA_OK )
    {
      rc = ESA_FATAL;
      goto exit;
    }
  }

  /*
   *    Finish
   */

 exit:;

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, rc);

  return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_rvkrsn_PreCmd                   *
*                                                             *
* DESCRIPTION    : Called before the RACF command is issued   *
*                  to handle the NOCSDATA=Y attrbute, if      *
*                  specified, and do any specific process:    *
*                  - If the user is revoked and has a revoke  *
*                    reason, and the addinfo does not contain *
*                    REVOKE or RESUME - indicate to replace   *
*                    with NOxxx for all site custom fields.   *
*                  - Otherwise, leave it.                     *
*                                                             *
* INPUT          : cf_name     - CTSACF custom field name.    *
*                : in_pair     - CTSACF custom field pair in  *
*                                uaddinfo if user has data    *
*                                for the field, or NULL if    *
*                                no data.                     *
*                : addinfo     - addinfo containing required  *
*                                changes.                     *
*                : uaddinfo    - addinfo contaning CTSACF     *
*                                fields.                      *
*                : user_params - user params recieved from    *
*                                UpdateUser caller            *
*                : args_num    - 2                            *
*                : args_list:                                 *
*                : 1. laddinfo - containing additional        *
*                                changes.                     *
*                : 2. do_nocsdata - see output below.         *
*                                                             *
* INPUT/OUTPUT   : do_nocsdata - Y / N / NULL                 *
*                                if N is received, do not     *
*                                change.                      *
*                                If Y or NULL - change, if    *
*                                needed by our logic.         *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
static ESA_RC CTSUpdUser_rvkrsn_PreCmd(ESA_DIAG_COMP_typ  comp,
                                char                     *cf_name,
                                ONE_FIELD_rec_ptr         in_pair,
                                ADDINFO_rec_ptr           addinfo,
                                ADDINFO_rec_ptr           uaddinfo,
                                void                     *entity_parms,
                                ADMIN_PARAMS_rec_typ     *admin_params,
                                int                       args_num,
                                va_list                   args_list)
{

  char     func[] = "CTSUpdUser_rvkrsn_PreCmd";
  /* SAS2IBMN - start */
  /*
  USER_PARAMS_rec_typ  *user_params;
  ONE_FIELD_rec_ptr     pair;
  ONE_FIELD_rec_ptr     nocsdata_pair;
  char                 *do_nocsdata;
  ADDINFO_rec_ptr       laddinfo;
  */
  USER_PARAMS_rec_typ  *user_params = NULL;
  ONE_FIELD_rec_ptr     pair = NULL;
  ONE_FIELD_rec_ptr     nocsdata_pair = NULL;
  char                 *do_nocsdata = NULL;
  ADDINFO_rec_ptr       laddinfo = NULL;
  /* SAS2IBMN - end   */
  int                   revoke, resume, revoked;

  RACF_PARAMS_rec_typ          * params_ptr = NULL;
  CTSAMSG_HANDLE_rec_ptr        msgs;
  CTSAMSG_DEST_TABLE_rec_ptr    dest;

  /*
   *  Initialization
   */
  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;
  params_ptr = admin_params->apiinit_handle;

  if (params_ptr->rssparm_CUSTOM_FIELDS_SUPPORT[0] EQ 'N')
    goto exit;

  if (entity_parms EQ NULL  OR args_num NE 2  OR
      addinfo EQ NULL  OR  uaddinfo EQ NULL)
    goto exit;                    /* out if parameters are missing */

  user_params = (USER_PARAMS_rec_typ *)entity_parms;
  laddinfo = va_arg(args_list, ADDINFO_rec_ptr);
  do_nocsdata = va_arg(args_list, char*);

  if (laddinfo EQ NULL OR  do_nocsdata EQ NULL)
    goto exit;                    /* out if parameters are missing */

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 1,
                  "Input: do_nocsdata = %.1s", do_nocsdata);

  if (*do_nocsdata EQ 'N')        /* if someone else set to N - out */
    goto exit;
  else
    if (*do_nocsdata NE 'Y')
      *do_nocsdata = NULL_CHAR;   /* default - no change         */

  /*
   *  Verify we have NOCSDATA=Y
   */
  nocsdata_pair = ADDINFO_search("NOCSDATA",
                                 RCF_ADDINFO_KWD_LEN,
                                 addinfo->pair,
                                 addinfo->num_pairs );

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "Input: NOCSDATA = %s   do_nocsdata = %.1s",
                  nocsdata_pair->value, *do_nocsdata);

  if ( nocsdata_pair EQ NULL  OR
       ( nocsdata_pair NE NULL  AND
        ( nocsdata_pair->vallen EQ 0  OR
         ( nocsdata_pair->vallen GT 0  AND
           strcmp(nocsdata_pair->value, KWD_FLAG_ON) NE 0) ) ) )
    goto exit;                 /* if not, nothing to do */

  /*
   *  If the user is revoked and has a revoke reason, and the
   *  laddinfo does not contain REVOKE or RESUME - indicate to
   *  replace with NOxxx for all site custom fields.
   *  Otherwise, NOCSDATA=Y can be done.
   *
   *  Note:
   *  If the laddinfo contains REVOKE or RESUME, we can leave the
   *  NOCSDATA=Y that will remove the revoke reason, becasue we
   *  will handle the revoke reason later, after the command is
   *  issued.
   */
  pair = ADDINFO_search("REVOKED",             /* user is revoked ? */
                        RCF_ADDINFO_KWD_LEN,
                        uaddinfo->pair,
                        uaddinfo->num_pairs );
  if (pair NE NULL  AND  strcmp(pair->value, KWD_FLAG_ON) EQ 0)
    revoked = TRUE;
  else
    revoked = FALSE;

  pair = ADDINFO_search("REVOKE",              /* REVOKE requested ? */
                        RCF_ADDINFO_KWD_LEN,
                        laddinfo->pair,
                        laddinfo->num_pairs );
  if (pair NE NULL  AND  pair->vallen EQ 0)
    revoke = TRUE;
  else
    revoke = FALSE;

  pair = ADDINFO_search("RESUME",              /* RESUME requested ? */
                        RCF_ADDINFO_KWD_LEN,
                        laddinfo->pair,
                        laddinfo->num_pairs );
  if (pair NE NULL  AND  pair->vallen EQ 0)
    resume = TRUE;
  else
    resume = FALSE;

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "Revoke = %d   Resume = %d   User_stat = %d",
                  revoke, resume, revoked);

  if (revoked   AND                /* if revoked                 */
      in_pair NE NULL  AND         /* with a revoke reason...    */
      NOT revoke   AND             /* and no REVOKE or RESUME in */
      NOT resume)                  /* the command...             */
    *do_nocsdata = 'N';            /* ...do not do NOCSDATTA=Y   */
  else                             /* Else...                    */
    *do_nocsdata = 'Y';            /*  ...NOCSDATA=Y can be done */

  /*
   *  Termination
   */
 exit:;
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "Return:  do_nocsdata = %.1s", do_nocsdata);

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, ESA_OK);

  return ESA_OK;
}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_rvkrsn_PostCmd                  *
*                                                             *
* DESCRIPTION    : Called after the RACF command is issued    *
*                  to handle the revoke reason, if needed:    *
*                  - If the command contains REVOKE, set      *
*                    revoke reason 'C'.                       *
*                  - if the command contains RESUME, set      *
*                    revoke reason = '?' (GetUser will remove *
*                    it or set 'D'if revoked becasue of date. *
*                                                             *
* INPUT          : cf_name     - CTSACF custom field name.    *
*                : in_pair     - N/A                          *
*                : addinfo     - addinfo containing required  *
*                                changes.                     *
*                : uaddinfo    - addinfo with CTSACF fields.  *
*                : user_params - user params recieved from    *
*                                UpdateUser caller            *
*                : args_num    - 1                            *
*                : args_list:                                 *
*                : 1. laddinfo - containing additional        *
*                                changes.                     *
*                                                             *
* OUTPUT         :                                            *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
* NOTE           : We return always ESA_RC because the        *
*                  return code of this function will not      *
*                  affect the return code of the update       *
*                  user execution.                            *
*                                                             *
**************************************************************/
static ESA_RC CTSUpdUser_rvkrsn_PostCmd(ESA_DIAG_COMP_typ  comp,
                                char                     *cf_name,
                                ONE_FIELD_rec_ptr         in_pair,
                                ADDINFO_rec_ptr           addinfo,
                                ADDINFO_rec_ptr           uaddinfo,
                                void                     *entity_parms,
                                ADMIN_PARAMS_rec_typ     *admin_params,
                                int                       args_num,
                                va_list                   args_list)
{

  char     func[] = "CTSUpdUser_rvkrsn_PostCmd";
  ESA_RC   rc;
  USER_PARAMS_rec_typ  *user_params;
  ONE_FIELD_rec_ptr     rvk_pair;
  ONE_FIELD_rec_ptr     rsm_pair;
  ADDINFO_rec_ptr       laddinfo;

  CTSAMSG_HANDLE_rec_ptr        msgs;
  CTSAMSG_DEST_TABLE_rec_ptr    dest;

  /*
   *  Initialization
   */
  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if (entity_parms EQ NULL  OR   args_num NE 1  OR
      addinfo EQ NULL  OR  uaddinfo EQ NULL)
    goto exit;                    /* out of parameters are missing */

  user_params = (USER_PARAMS_rec_typ *)entity_parms;
  laddinfo = va_arg(args_list, ADDINFO_rec_ptr);

  if (laddinfo EQ NULL)
    goto exit;

  /*
   *  If laddinfo contains REVOKE, set revoke reason = C (command)
   */
  rvk_pair = ADDINFO_search("REVOKE",
                            RCF_ADDINFO_KWD_LEN,
                            laddinfo->pair,
                            laddinfo->num_pairs );

  if (rvk_pair NE NULL  AND  rvk_pair->vallen EQ 0)
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "REVOKE: Set revoke reason 'C'");
    rc = RACF_Update_Revoke_Reason(comp, user_params->user,
                                   'U', 'V', 'C',
                                   cf_name, admin_params);
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
             "RACF_Update_Revoke_Reason returned with rc = %d", rc);
  }
  else
  {
    /*
     *  If laddinfo contains RESUME, set revoke reason = ? (unknown)
     *  GetUser will later remove it, if the user is active, or set
     *  'D' if the user is revoked because of date.
     *
     *  RESUME is checked only if no REVOKE becasue if both are
     *  specified, RACF uses REVOKE (from the manual).
     */
    rsm_pair = ADDINFO_search("RESUME",
                              RCF_ADDINFO_KWD_LEN,
                              laddinfo->pair,
                              laddinfo->num_pairs );
    if ( rsm_pair NE NULL  AND  rsm_pair->vallen EQ 0 )
    {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                  "RESUME: Set revoke reason '?'");
      rc = RACF_Update_Revoke_Reason(comp, user_params->user,
                                     'U', 'V', '?',
                                     cf_name, admin_params);
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
             "RACF_Update_Revoke_Reason returned with rc = %d", rc);
    }
  }

  /*
   *  Termination
   */
 exit:;
  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, ESA_OK);

  return ESA_OK;
}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_Remove_NocsdataY                *
*                                                             *
* DESCRIPTION    : Called after CTSACF pre-cmd routines       *
*                  are called, to replace NOCSDATA=Y with     *
*                  NOxxx for all custom fields in the user    *
*                  record.                                    *
*                                                             *
* INPUT          : addinfo     - addinfo containing required  *
*                                changes.                     *
*                : laddinfo    - addinfo with additional      *
*                                changes.                     *
*                : uaddinfo    - addinfo containing user      *
*                                data.                        *
*                : admin_params                               *
*                                                             *
* OUTPUT         : chg_addinfo - -> changed addinfo to be     *
*                                used instead of addinfo.     *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
* NOTE           : We return always ESA_RC because the        *
*                  return code of this function will not      *
*                  affect the return code of the update       *
*                  user execution.                            *
*                                                             *
**************************************************************/
static ESA_RC CTSUpdUser_Remove_NocsdataY(
                                ADDINFO_rec_ptr           addinfo,
                                ADDINFO_rec_ptr           laddinfo,
                                ADDINFO_rec_ptr           uaddinfo,
                                ADDINFO_rec_ptr          *chg_addinfo,
                                ADMIN_PARAMS_rec_typ     *admin_params)
{

  char     func[] = "CTSUpdUser_Remove_NocsdataY";
  ESA_RC   rc = ESA_OK;
  ADDINFO_rec_ptr       new_addinfo;
  ONE_FIELD_rec_ptr     pair;
  /* WS10082N ONE_FIELD_rec_ptr     srch_start;   */
  int                   srch_num;
  int                   csdata_ent_num;
  int                   gen_ent_num;
  RACF_PARAMS_rec_typ  *params_ptr = NULL;
  RACF_CTSACF_block_ptr ctsacf_blk;

  CTSAMSG_HANDLE_rec_ptr        msgs;
  CTSAMSG_DEST_TABLE_rec_ptr    dest;

  /*
   *  Initialization
   */
  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  params_ptr = admin_params->apiinit_handle;
  ctsacf_blk = params_ptr->p_u_ctsacfs;

  /*
   * If NOCSDATA=Y was not requested - nothing to do
   */
  pair = ADDINFO_search("NOCSDATA",
                                 RCF_ADDINFO_KWD_LEN,
                                 addinfo->pair,
                                 addinfo->num_pairs );
  if ( pair EQ NULL  OR
       ( pair NE NULL   AND
        ( pair->vallen EQ 0   OR
         ( pair->vallen GT 0   AND
           strcmp(pair->value, KWD_FLAG_ON) NE 0) ) ) )
     goto exit;

  /*
   *  Count the number of CSDATA. fields the user has.
   *  If there are no CSDATA fields, nothing to do.
   *
   *  Note:
   *  The uaddinfo contains both site and CTSACF fields so
   *  if the count is 0, the user has none of both types.
   */
  ADDINFO_count_by_prefix(uaddinfo, CSDATA_PREFIX,
                          &csdata_ent_num, &gen_ent_num,
                          TRUE, TRUE);

  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "The user has %d CSDATA fields", csdata_ent_num);

  if (csdata_ent_num EQ 0)
    goto exit;

  /*
   *  Allocate new_addinfo. size = addinfo size + CSDATA. count
   */
  rc = ADDINFO_alloc(func, addinfo->num_pairs + csdata_ent_num,
                     &new_addinfo, dest, msgs);
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "Allocate new addinfo: rc = %d, new_addinfo = %8X",
              rc, new_addinfo);

  if (rc NE ESA_OK)
    goto exit;

  /*
   *  Copy addinfo to new_addinfo.
   */
  rc = ADDINFO_copy(new_addinfo, addinfo);
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "Copy addinfo to new_addinfo.   rc = %d", rc);
  if (rc NE ESA_OK)
    goto exit;

  /*
   *  Remove NOCSDATA and CSDATA. fields (if any) from chg_addinfo,
   *  and CSDATA.NO_PKB from laddinfo.
   */
  rc = ADDINFO_delete(new_addinfo, "NOCSDATA");
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "Delete NOCSDATA. rc = %d", rc);
  if (rc NE ESA_OK)
    goto exit;

  /* WS10082N srch_start = new_addinfo->pair;   */
  pair = new_addinfo->pair;                               /* WS10082N */
  srch_num = new_addinfo->num_pairs;

  do
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
            "Search for CSDATA in new_addimfo: start = %8X,  num = %d",
            pair, srch_num);                              /* WS10082N */
     /* WS10082N  srch_start, srch_num);   */

    pair = ADDINFO_prefix_search(CSDATA_PREFIX,
                                 RCF_ADDINFO_KWD_LEN, TRUE,
                                 pair, srch_num);         /* WS10082N */
                   /* WS10082N   srch_start, srch_num);  */
    if (pair NE NULL)
    {
      pair = get_orig_pair(pair);  /* point to short pair   WS10082N */
      rc = ADDINFO_delete(new_addinfo, pair->keyword);
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "%s - delete from new_addinfo: rc = %d",
              pair->keyword, rc);

      if (rc NE ESA_OK)
        break;

      /* WS10082N
      srch_start = pair;
      srch_num = new_addinfo->num_pairs - (pair - srch_start); */
      srch_num = new_addinfo->num_pairs - pair->index;    /* WS10082N */
    }

  } while(pair NE NULL  AND  srch_num GT 0);

  if (rc NE ESA_OK)
    goto exit;

  ADDINFO_delete(laddinfo, "CSDATA.NO_PKB");
  ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "CSDATA.NO_PKB - delete from new_addinfo: rc = %d",
              rc);

  /*
   *  Add NOxxx for all site custom fields with values.
   */
  /* WS10082N srch_start = uaddinfo->pair;  */
  pair = uaddinfo->pair;                                  /* WS10082N */
  srch_num = uaddinfo->num_pairs;

  do
  {
    ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
              "Search for CSDATA in uaddinfo:  start = %8X,  num = %d",
              pair, srch_num);                            /* WS10082N */
     /* WS10082N   srch_start, srch_num); */

    pair = ADDINFO_prefix_search(CSDATA_PREFIX,
                                 RCF_ADDINFO_KWD_LEN, TRUE,
                                 pair, srch_num);      /*WS10082N*/
                   /* WS10082N   srch_start, srch_num);   */
    if (pair EQ NULL)
      break;

    if (pair->vallen GT 0)
    {
      rc = RACF_IsIt_CTSACF_cf(ESA_COMP_UPDUSER, 'U',
                               ctsacf_blk, &pair->keyword[7],
                               NULL, NULL, NULL, admin_params);
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                "RACF_IsIt_CTSACF_cf for %s in blk %8X: rc = %d",
                pair->keyword[7], ctsacf_blk, rc);

      if (rc NE ESA_OK)    /* If not CTSACF field, add NOxxx  */
      {
        rc = ADDINFO_insert(TYPE_1A, pair->keyword, "", new_addinfo,
                       RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       UNIQUE);
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 5,
                "Add %s to chg_addinfo: rc = %d",
                pair->keyword, rc);

        if (rc NE ESA_OK)
          break;
      }
    }

    /* WS10082
    srch_start = pair + 1;
    srch_num = uaddinfo->num_pairs - (srch_start - uaddinfo->pair); */
    pair = get_pair(pair);                                /* WS10082N */
    srch_num = uaddinfo->num_pairs - (pair->index + 1); /* WS10082N */
    pair++;        /* We can do it because it is short pair WS10082N */

  /* WS10082N } while(pair NE NULL  AND  srch_num GT 0);  */
  } while(srch_num GT 0);                                /* WS10082N */

  /*
   *  Termination
   */
 exit:;
  if (rc EQ ESA_OK)
    *chg_addinfo = new_addinfo;
  else
  {
    *chg_addinfo = NULL;
    if (new_addinfo NE NULL)
      ADDINFO_free(&new_addinfo);
  }

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, ESA_OK);

  return rc;
}
/*  IS10100 - end */

/* WS10068 - start */
/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdUser_post_DFLTGRP                    *
*                                                             *
* DESCRIPTION    : Called when DFLTGRP is changed, to         *
*                  disconnect the old default group, if       *
*                  needed.                                    *
*                                                             *
* INPUT          : old_defug   - olfddefault group to be      *
*                                disconnected.                *
*                : admin_params                               *
*                                                             *
* OUTPUT         :                                            *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
* NOTE           :                                            *
*                                                             *
**************************************************************/
static ESA_RC CTSUpdUser_post_DFLTGRP(
                                USER_PARAMS_rec_typ     * user_params,
                                char                    * old_defug,
                                ADMIN_PARAMS_rec_typ    * admin_params)
{

  char     func[] = "CTSUpdUser_post_DFLTGRP";
  ESA_RC   rc = ESA_OK;
  ADDINFO_rec_ptr       laddinfo = NULL;
  char                  cmd[MAX_API_ST];

  CTSAMSG_HANDLE_rec_ptr        msgs;
  CTSAMSG_DEST_TABLE_rec_ptr    dest;

  /*
   *  Initialization
   */
  ESA_DIAG_enter(ESA_COMP_UPDUSER, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *   Disconnectthe old defulatgroup, if requested
  */

  if (user_params->def_ug_action EQ OLD_DEF_UG_ACT_DROP)
  {
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
             "def_ug_action= %d", user_params->def_ug_action);
     ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
             "Removing old default connection to group %s", old_defug);

     rc = ADDINFO_alloc(func, 10, &laddinfo, dest, msgs);
     if (rc NE ESA_OK)
     {
        rc = ESA_FATAL;
        goto exit;
     }

     ADDINFO_insert(TYPE_1A, "GROUP", old_defug, laddinfo,
                    RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                    UNIQUE);
     sprintf(cmd,"REMOVE %s ", user_params->user);
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname, cmd,
                  MAX_OK_RC_0, 1, &laddinfo, connect_mkt, connect_kdt,
                  admin_params, CMDOUT_YES, RACF_YES);   /* IS10174 */
       /* IS10174 dest, msgs, CMDOUT_YES, RACF_YES);                */
     if (rc NE ESA_OK)
        goto exit;
  }

 exit:;

  if (laddinfo NE NULL)                                   /* WS10082N */
    ADDINFO_free(&laddinfo);

  ESA_DIAG_exit(ESA_COMP_UPDUSER, 1, func, ESA_OK);

  return rc;
}
/*  WS10068 - end */
