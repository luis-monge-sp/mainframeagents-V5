 /**************************************************************
 *                                                             *
 * Title            : Resources handling functions             *
 *                                                             *
 * File Name        : ctsbres.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 01/02/1998                               *
 *                                                             *
 * Description      : This source contains a set of low-level  *
 *                    access routines to ACF2 Databases,       *
 *                    and routines to build and analyze        *
 *                    resources info.                          *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who    When       Description                      *
 * -------- ------ ---------- -------------------------------- *
 * PS0250   Guy    31/03/1998 Support ACEs of type WORLD       *
 * PS0251   Guy    05/04/1998 Assume NULL keywords are sent    *
 * PS0278   Guy    15/06/1998 Added Rule_Backup function       *
 * WS2333   Guy    28/07/1998 NEXTKEYs loading and displaying  *
 *                            + improve ruleset filtering      *
 * PS0298   Guy    18/08/1998 Add new NEXTKEYs message         *
 * BS2362   Guy    19/08/1998 ACF2 compiler error message fix  *
 * PS0347   Guy    03/12/1998 Determine MAXRULE usage with parm*
 * PS0373   Guy    14/01/1999 Compile_Ruleset exits with rc=6  *
 * WS2358   Guy    14/10/1999 Support for the virtual resource *
 * BS2409   Guy    28/11/1999 SERVICE() returns SERVICE(ALL)   *
 * PS0398   Guy    02/12/1999 ARI fails for qualified resrules *
 * BS2411   Guy    20/12/1999 PREFIX field not handled correct *
 * BS2416   Guy    06/01/2000 Bug when RESMASK starts with -   *
 * BS2417   Guy    09/01/2000 Equal RESMASKs are not matched   *
 * IS10122  NuritY 16/06/2014 Ignore ROLESET rules.            *
 * SAS2IBMT SeligT 30/06/2016 SAS/C to IBM C Conversion Project*
 * SAS2IBMN NuritY 10/10/2016 SAS/C to IBM C Conversion:Replace*
 *                            access() with fopen & fgets.     *
 * WS10058  AvnerL 11/05/2017 Undefined perms are sent(DNB-3.3)*
 * WS10060  AvnerL 10/05/2017 Support UIDMASK=* (DNB from 3.3) *
 * IS10174  NuritY 15/01/2018 Dynamic EXECOUT support.         *
 * BS10098  SeligT 04/12/2018 When deleting a permission, all  *
 *                            permissions in the rule are      *
 *                            deleted.                         *
 * IS10178  SeligT 07/01/2019 Supporting LID Anywhere in UID   *
 * WS10075  SeligT 08/12/2019 Manage Permissions as Account    *
 *                            and Group Attributes             *
 * BS10121  AvnerL 20/03/2023 restoring ACE_TYPE_MASK - IS10178*
 * WS10082  MauriC 07/11/2022 Recompile for new ADDINFO macros *
 **************************************************************/

 /*
  *   Standard include files
  */

 #include   <globs.h>
 #include   STDIO
 #include   STDLIB
 #include   STRING
 #include   CTYPE
 #include   TIME
 #include   FCNTL
 #include   ERRNO                                         /* SAS2IBMT */
 #include   UNISTD                                        /* SAS2IBMT */

 /*
  *   ESA include files
  */

 #include   ESA_API
 #include   ESA_DIAG
 #include   ESA_CTSAMSG
 #include   ESA_API_CODES

 #include   MVS_OS_CLI
 #include   MVS_OS_MVS
 #include   MVS_COMP

 #include   API_ADDINFO
 #include   API_DATES
 #include   ACF2_CODES
 #include   ACF2

 static char component[]="CTSBRES";

 /* Compile and Insert/Replace a ruleset */
 /* SAS2IBMT prototype changed for IBM C
 void cts2cmp(char *key,
              char *type,
              char *frep,
              char *ruleprm,
              char *ddname,
              char *obj_buffer,
              int  *rc,
              char *errmsg);                                         */
 void cts2cmp();                                          /* SAS2IBMT */

 /* Retrieve access rules */
 /* SAS2IBMT prototype changed for IBM C
 void cts2rul(char *op,
              char *key,
              char *ckey,
              char *keyt,                                 // WS2333 //
              char *obj_buffer,
              char *src_buffer,
              int  *buffer_length,
              int  *rc,
              char *errmsg);                                         */
 void cts2rul();                                          /* SAS2IBMT */

 /* Retrieve resource rules */
 /* SAS2IBMT prototype changed for IBM C
 void cts2grs(char *op,
              char *key,
              char *type,
              char *ckey,
              char *keyt,                                 // WS2333 //
              char *obj_buffer,
              char *src_buffer,
              int  *buffer_length,
              char *datelst,
              char *userlst,
              int  *rc,
              char *errmsg);                                         */
void cts2grs();                                           /* SAS2IBMT */

static int Is_Line_Continued (char *);

/* WS2333 */
static ESA_RC Get_NEXTKEYs (char *,
                            char *,
                            int,
                            char **,
                            int *,
                            char *,
                            int,
                            int,
                            int,
                            int *,
                            char *,
                            CTSAMSG_HANDLE_rec_typ *,
                            CTSAMSG_DEST_TABLE_rec_typ *);
/* WS2333 */
static ESA_RC Get_Res_NEXTKEYs (char *,
                                char *,
                                char **,
                                int *,
                                int *,
                                char **,
                                char *,
                                int,
                                int,
                                int,
                                char *,
                                CTSAMSG_HANDLE_rec_typ *,
                                CTSAMSG_DEST_TABLE_rec_typ *);

/* WS2333 */
static ESA_RC Accum_NEXTKEYs (char **,
                              int *,
                              int *,
                              char **,
                              char *,
                              int,
                              int,
                              int,
                              char *,
                              CTSAMSG_HANDLE_rec_typ *,
                              CTSAMSG_DEST_TABLE_rec_typ *);

static ESA_RC Find_Keywords (ADDINFO_rec_ptr,
                             char *,
                             char *,
                             CTSAMSG_HANDLE_rec_typ *,
                             CTSAMSG_DEST_TABLE_rec_typ *);

static void Get_Compiler_Messages (CTSAMSG_HANDLE_rec_typ *,
                                   CTSAMSG_DEST_TABLE_rec_typ *);

static char * Locate_ACE_End (char *);

static ESA_RC Get_ACE_Resmask (ACF2_Get_ResACL_Handle *,
                               char *,
                               char *,
                               char **,
                               CTSAMSG_HANDLE_rec_typ *,
                               CTSAMSG_DEST_TABLE_rec_typ *);

static ACF2_API_Return_Codes Get_Rule_Entry_Info(
                                         ACF2_Get_ResACL_Handle *,
                                         ACE_rec_typ *,
                                         ADDINFO_rec_ptr,
                                         char  *,         /* IS10122 */
                                         CTSAMSG_HANDLE_rec_typ *,
                                         CTSAMSG_DEST_TABLE_rec_typ *);

static ESA_RC Filter_Rule_Records (ACF2_Resource_Data_Type,
                                   char *,
                                   int,                   /* WS2333 */
                                   char **,               /* WS2333 */
                                   int *);

static ESA_RC Get_Dsn_Output(char *,
                             char *,
                             int *,
                             CTSAMSG_DEST_TABLE_rec_ptr,
                             CTSAMSG_HANDLE_rec_ptr);

 static ESA_RC Get_Rule_Mod_Data (char *,
                                  ADDINFO_rec_ptr,
                                  CTSAMSG_HANDLE_rec_typ     *,
                                  CTSAMSG_DEST_TABLE_rec_typ *);

 static ESA_RC Get_Ruleset_Info (char *,
                                 int,
                                 ADDINFO_rec_ptr,
                                 CTSAMSG_HANDLE_rec_typ     *,
                                 CTSAMSG_DEST_TABLE_rec_typ *);

 /* WS2358 */
 static ESA_RC Write_Entire_Rule (char *,
                                  char *,
                                  ADDINFO_rec_ptr,
                                  ACF2_Get_ResACL_Handle *,
                                  ADDINFO_rec_ptr,
                                  ACE_rec_typ *,
                                  ADDINFO_rec_ptr,
                                  int *,
                                  FILE *,
                                  char *,
                                  ADMIN_PARAMS_rec_typ *);

 /* WS2358 */
 static int Is_Access_Denied (char *,
                              ADDINFO_rec_ptr,
                              ADDINFO_rec_ptr,
                              int *);

 /* WS2358 */
 static ESA_RC Access_Env_Matches (ACE_rec_typ *,
                                   char *,
                                   ADDINFO_rec_ptr,
                                   ADDINFO_rec_ptr,
                                   ADDINFO_rec_ptr,       /* BS2411 */
                                   int *,
                                   char *,                /* BS2411 */
                                   char *,                /* BS2411 */
                                   CTSAMSG_HANDLE_rec_typ *,
                                   CTSAMSG_DEST_TABLE_rec_typ *);

 /* WS2358 */
 static int Full_Masks_Match (char *,
                              char *);

 /* WS2358 */
 static int Single_Qualifiers_Match (char *,
                                     char *,
                                     int);

 /* WS2358 */
 static int Is_All_Asteriks (char *);

 /* WS2358 */
 static void Build_Interpreted_Mask (char *, int, char *);

 /* WS2358 */
 static int VOLs_Match (char *, char *);

 /* WS2358 */
 static ESA_RC Handle_ACE_Types (ACE_rec_typ *,
                                 ADDINFO_rec_ptr,
                                 char *,
                                 CTSAMSG_HANDLE_rec_typ *,
                                 CTSAMSG_DEST_TABLE_rec_typ *);

 /* WS2358 */
 static int UIDMASKs_Match (char *, char *);

 /* BS2411 */
 static void Calc_Real_Rule_Entry (char *,
                                   char *,
                                   ADDINFO_rec_ptr,
                                   char *,
                                   char *,
                                   int *,
                                   CTSAMSG_HANDLE_rec_typ *,
                                   CTSAMSG_DEST_TABLE_rec_typ *);

 /* BS2411 */
 static int Num_Of_Qualifiers (char *);

/******************************************************************
 * Procedure Name: ACF2_Get_Resource
 ******************************************************************
 * Description   : This function is the High-Level interface used by
 *                 the API to retrieve Resource and Access rules.
 *
 *                 The function supports Get_Next logic by the current
 *                 key field (if Null, get first ruleset matching key
 *                 else read the ruleset following the current_key).
 *
 * Input         : key        - Key or Key mask
 *                 key_masked - An inidcation if key is a mask
 *                              (i.e, key prefix)
 *                 restype    - type of resource(s) to be retrieved
 *                 ret_type   - return ruleset header or
 *                              ruleset entries
 *                 ACE handle
 *                 Res handle
 *                 admin params
 *
 * Input/Output  : current_key - Input:get next matching key after this
 *                               Output: current key after operation
 *
 * Output        : ace         - ace params
 *                 addinfo     - ACF2 Retrieved fields
 *                 errmsg      - error message description
 *
 * Return Value  : ACF2_API_Return_Codes
 *                 ACF2_OK             - Ruleset retrieved ok
 *                 ACF2_Not_Found      - No key found matching criteria
 *                 ACF2_Internal_Error - Error in ACF2 processing
 *********************************************************************/
 ACF2_API_Return_Codes ACF2_Get_Resource(char            *key,
                                         ACF2_Object_Mask key_masked,
                                          char           *restype,
                                  ACF2_Resource_Data_Type ret_type,
                                  ACF2_Get_ResACL_Handle *h,
                                  ACF2_Get_Res_Handle    *hres,
                                          char           *current_key,
                                         ACE_rec_typ     *ace,
                                         ADDINFO_rec_ptr  addinfo,
                                          char           *errmsg,
                                   ADMIN_PARAMS_rec_typ  *admin_params)

 {
 /*************************************************************
 * Variables                                                  *
 **************************************************************/
   static         char func[]="ACF2_Get_Resource";

   RESOURCE_typ  the_resource, res_to_print;

   char          *obj_buffer = NULL;
   char          *src_buffer = NULL;

   int            src_buffer_length = ACF2_RULE_SOURCE_LENGTH;
   int            records_buffer_length;                  /* WS2333 */
   int            nextkeys_bufflen = 0;                   /* WS2333 */
   int            res_is_dsn = FALSE;                     /* WS2333 */
   int            nextkeys_count = 0;                     /* WS2333 */

   ESA_RC                arc;
   int                   rc1 = 0;
   ACF2_API_Return_Codes rc = ACF2_OK;

   char          *records_buffer = NULL;                  /* WS2333 */
   char          *nextkeys_buffer = NULL;                 /* WS2333 */

   /* WS2333 - merged Get_Dsn_Resource and Get_Resource */
   char           ACF2_RES_key[ACF2_RESRULE_KEY_SIZE];
   char           ACF2_DSN_key[ACF2_ACCRULE_KEY_SIZE];
   char           ACF2_current_RES_key[ACF2_RESRULE_KEY_SIZE];
   char           ACF2_current_DSN_key[ACF2_ACCRULE_KEY_SIZE];

   char           ACF2_msgid[9];
   char           date_last[9];
   char           user_last[9];
   char           TOD[15];
   char           Mask_char = ' ';
   char           key_type[2];

   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

   ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   /* WS2333 */
   if (strcmp (restype, "DSN") EQ 0)
     res_is_dsn = TRUE;

   /*************************************************************
   * Prepare specific/masked name to retrieve                   *
   **************************************************************/
   if (key_masked EQ ACF2_Object_is_Masked)
   {
     Mask_char = '*';
     strcpy (key_type, "P");                              /* WS2333 */
   }
   else
     strcpy (key_type, "S");                              /* WS2333 */

   memset(user_last,0X00,sizeof(user_last));
   memset(date_last,0X00,sizeof(date_last));
   memset(TOD,0X00,sizeof(TOD));

   if (res_is_dsn)
   {
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Resource is ACCESS RULE");
     Reset_Field(ACF2_DSN_key,sizeof(ACF2_DSN_key),Mask_char,key);
     Reset_Field(ACF2_current_DSN_key,sizeof(ACF2_current_DSN_key),
                 ' ',current_key);
   }
   else
   {
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Resource is RESOURCE RULE");
     Reset_Field(ACF2_RES_key,sizeof(ACF2_RES_key),Mask_char,key);
     Reset_Field(ACF2_current_RES_key,sizeof(ACF2_current_RES_key),
                 ' ',current_key);
   };

   Reset_Field(errmsg,sizeof(errmsg),0X00,NULL);

   /* WS2333 */
   /*************************************************************
   * For GetResource - Load NEXTKEYs of resource ?              *
   **************************************************************/
   if ( (ret_type EQ ACF2_Return_Ruleset) AND
        (hres NE NULL) )
   {
     if (hres->Load_Nextkeys)
     {
       if (res_is_dsn)
         strcpy (the_resource, ACF2_DSN_key);
       else
         strcpy (the_resource, ACF2_RES_key);

       ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                       "Load NEXTKEYs for resource(%s)",
                       the_resource);

       strcpy (res_to_print, the_resource);
       Trim (res_to_print);

       CTSAMSG_print(ACF2_LOADING_NEXTKEYS, msgs, NULL, dest,
                     res_to_print, restype);

       arc = Get_NEXTKEYs (the_resource,
                           restype,
                           hres->Nextkeys_Depth,
                           &(hres->Nextkeys_Chain),
                           &nextkeys_bufflen,
                           NULL,
                           0,
                           1,
                           TRUE,
                           &(hres->Num_Loaded_Nextkeys),
                           res_to_print,
                           msgs,
                           dest);

       if (arc NE ESA_OK)
       {
         /* IS10122 - start */
         if (arc EQ ESA_SKIP)
         {
           strcpy(errmsg, ACF2_ROLESET_IGNORED_MSG);
           rc = ACF2_Not_Found;
           goto exit;
         }
         else
           if (arc EQ ESA_ERR)
           {
             rc = ACF2_Not_Found;
             goto exit;
           }
           /* IS10122 - end */
           else                                           /* IS10122 */
           {                                              /* IS10122 */
             CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                           dest, component,func,
                           "Rule NEXTKEYs extraction failed",
                           16,__LINE__);
             rc = ACF2_Internal_Error;
             goto exit;
           };                                             /* IS10122 */
       };

       ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                       "Total # of NEXTKEYs FOUND(%d)",
                       hres->Num_Loaded_Nextkeys);

       hres->Nextkeys_List_Ptr = hres->Nextkeys_Chain;
     };
   };

   /*************************************************************
   * Obtain storage for rule object buffer                      *
   **************************************************************/
   obj_buffer = (char *) malloc (ACF2_RULE_BUFFER_LENGTH);

   if (obj_buffer EQ NULL)
   {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "RULE OBJECT BUFFER",
                  ACF2_RULE_BUFFER_LENGTH);
     rc = ACF2_Internal_Error;
     goto exit;
   };

   /***************************************************************
   * For GetResource calls we allocate the rule source buffer.    *
   * In GetResourceACL the high-level function already allocated  *
   * it so we just use it.                                        *
   ****************************************************************/
   if (ret_type EQ ACF2_Return_Ruleset)
   {
     /*************************************************************
     * Obtain storage for rule source buffer                      *
     **************************************************************/
     src_buffer = (char *) malloc (ACF2_RULE_SOURCE_LENGTH);

     if (src_buffer EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "RULE SOURCE BUFFER",
                    ACF2_RULE_SOURCE_LENGTH);
       rc = ACF2_Internal_Error;
       goto exit;
     };
   }
   else
   {
     /*************************************************************
     * Source buffer already allocated. Just use it.              *
     **************************************************************/
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Source Buffer already allocated");
     src_buffer = h->Rule_Buffer;
     src_buffer_length = h->Rule_Buffer_Len;
   };

   if (res_is_dsn)
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_REGULAR,
                     "keymask=(%s), current DSN key=(%s)",
                     ACF2_DSN_key,ACF2_current_DSN_key);
   else
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_REGULAR,
                     "keymask=(%s), current RES key=(%s)",
                     ACF2_RES_key,ACF2_current_RES_key);

 /******************************************************************
 * If Return_Rule_Entries (GetResACL) and not First_Call, handle   *
 * next_ACE processing (no need to re-issue ACFSVC. Buffer exists) *
 *******************************************************************/
 if (ret_type EQ ACF2_Return_Rule_Entries)
 {
   if (NOT h->First_Call)
   {
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Next ACE retrieve...");
     rc = Get_Rule_Entry_Info(h,
                              ace,
                              addinfo,
                              errmsg,                     /* IS10122 */
                              msgs,
                              dest);

     switch (rc)
     {
       case ACF2_OK:
         goto exit;

       case ACF2_Not_Found:
         /* IS10122  */
         if ( strcmp(errmsg, ACF2_ROLESET_IGNORED_MSG) NE 0 )
         {                                                /* IS10122 */
           rc = ACF2_OK;
           strcpy(errmsg,"NO MORE ACES");
         }                                                /* IS10122 */

         goto exit;
       default:
         strcpy(errmsg,"Get_Rule_Entry_Info failed");
         rc = ACF2_Internal_Error;
         goto exit;
     };
   }
   else
     h->First_Call = FALSE;
 };

 if (NOT res_is_dsn)
 /******************************************************************
 * Issue ACF2 API Call to ACGRSRC SVC                              *
 *******************************************************************/
   /* SAS2IBMT
   cts2grs(ACF2_RETRIEVE_OP,                                         */
   (*(ASM_RTN_TYP *)&cts2grs)                             /* SAS2IBMT */
          (ACF2_RETRIEVE_OP,
           ACF2_RES_key,
           restype,
           ACF2_current_RES_key,
           key_type,                                      /* WS2333 */
           obj_buffer,
           src_buffer,
           &src_buffer_length,
           date_last,
           user_last,
           &rc1,
           errmsg);
 else
 /******************************************************************
 * Issue ACF2 API Call to ACRULE SVC                               *
 *******************************************************************/
   /* SAS2IBMT
   cts2rul(ACF2_RETRIEVE_OP,                                         */
   (*(ASM_RTN_TYP *)&cts2rul)                             /* SAS2IBMT */
          (ACF2_RETRIEVE_OP,
           ACF2_DSN_key,
           ACF2_current_DSN_key,
           key_type,                                      /* WS2333 */
           obj_buffer,
           src_buffer,
           &src_buffer_length,
           &rc1,
           errmsg);

 /******************************************************************
 * For Resources (ruleset header only):                            *
 * If source buffer is too small, expand it once and retry         *
 *******************************************************************/
   if ( (ret_type EQ ACF2_Return_Ruleset) AND (rc1 EQ 2) )
   {
     free (src_buffer);
     src_buffer = NULL;
     src_buffer = (char *) malloc (ACF2_RULE_SOURCE_INC);

     if (src_buffer EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "RULE SOURCE BUFFER",
                    ACF2_RULE_SOURCE_INC);
       rc = ACF2_Internal_Error;
       goto exit;
     };

     src_buffer_length = ACF2_RULE_SOURCE_INC;

     if (NOT res_is_dsn)
       /* SAS2IBMT
       cts2grs(ACF2_RETRIEVE_OP,                                     */
       (*(ASM_RTN_TYP *)&cts2grs)                         /* SAS2IBMT */
              (ACF2_RETRIEVE_OP,
               ACF2_RES_key,
               restype,
               ACF2_current_RES_key,
               key_type,                                  /* WS2333 */
               obj_buffer,
               src_buffer,
               &src_buffer_length,
               date_last,
               user_last,
               &rc1,
               errmsg);
     else
       /* SAS2IBMT
       cts2rul(ACF2_RETRIEVE_OP,                                     */
       (*(ASM_RTN_TYP *)&cts2rul)                         /* SAS2IBMT */
              (ACF2_RETRIEVE_OP,
               ACF2_DSN_key,
               ACF2_current_DSN_key,
               key_type,                                  /* WS2333 */
               obj_buffer,
               src_buffer,
               &src_buffer_length,
               &rc1,
               errmsg);
   };

 if (ESA_DIAG_get_debug_level(ESA_COMP_GETRES) GE DEBUG_SHOW_ALL)
  {
    SNAP_AREA( "RULE obj Buffer", obj_buffer, 256 )
    SNAP_AREA( "RULE src Buffer", src_buffer, 256 )
  };

   date_last[8] = NULL_CHAR;
   user_last[8] = NULL_CHAR;

   if (NOT res_is_dsn)
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                   "returned key=(%s) rc=(%d) errmsg(%s) buflen=(%d)",
                   ACF2_current_RES_key, rc1, errmsg,
                   src_buffer_length);
   else
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                   "returned key=(%s) rc=(%d) errmsg(%s) buflen=(%d)",
                   ACF2_current_DSN_key, rc1, errmsg,
                   src_buffer_length);

 /******************************************************************
 * Check ACF2 API Rc                                               *
 *******************************************************************/
   switch(rc1)
    {
     case 0:  rc = ACF2_OK;

              if ( (ret_type EQ ACF2_Return_Ruleset) AND
                   (NOT res_is_dsn) )
              {
                convert_tod_to_YYYYMMDDHHMMSS (date_last, TOD);

                ACF2_Set_Keyword_Value ("DATELAST",
                                        TOD,
                                        addinfo,
                                        msgs,
                                        dest);

                ACF2_Set_Keyword_Value ("DATEUSER",
                                        user_last,
                                        addinfo,
                                        msgs,
                                        dest);
              };

              /* WS2358 - Added NULL_CHAR at the end */
              if (key_masked EQ ACF2_Object_is_Masked)
              {
                if (NOT res_is_dsn)
                {
                  memcpy(current_key,ACF2_current_RES_key,
                         strlen(ACF2_current_RES_key));
                  current_key[strlen(ACF2_current_RES_key)]=NULL_CHAR;
                }
                else
                {
                  memcpy(current_key,ACF2_current_DSN_key,
                         strlen(ACF2_current_DSN_key));
                  current_key[strlen(ACF2_current_DSN_key)]=NULL_CHAR;
                };
              }
              else
              {
                if (NOT res_is_dsn)
                {
                  memcpy(current_key,ACF2_RES_key,
                         strlen(ACF2_RES_key));
                  current_key[strlen(ACF2_RES_key)]=NULL_CHAR;
                }
                else
                {
                  memcpy(current_key,ACF2_DSN_key,
                         strlen(ACF2_DSN_key));
                  current_key[strlen(ACF2_DSN_key)]=NULL_CHAR;
                };
              };

              /*****************************************************
              * Get ruleset source from ACF2OUT dataset            *
              ******************************************************/
              arc = Get_Dsn_Output("ACF2OUT ",
                                   src_buffer,
                                   &src_buffer_length,
                                   dest,
                                   msgs);

              if (arc NE ESA_OK)
              {
                strcpy(errmsg,"Get_Dsn_Output failed");
                rc = ACF2_Internal_Error;
                goto exit;
              };

              ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                              "Buffer length after read=(%d)",
                              src_buffer_length);

              if (ESA_DIAG_get_debug_level(ESA_COMP_GETRES) GE
               DEBUG_SHOW_IMPORTANT)
              {
                SNAP_AREA( "RULE", src_buffer, 400)
              };

              if ( (ret_type EQ ACF2_Return_Ruleset) AND
                   (res_is_dsn) )
              {
                /***************************************************
                 * Get rule-last-modified date and user            *
                 ***************************************************/
                 arc = Get_Rule_Mod_Data (src_buffer,
                                          addinfo,
                                          msgs,
                                          dest);

                 if (arc NE ESA_OK)
                 {
                  CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                                dest, component,func,
                                "Rule header extraction failed",
                                16,__LINE__);
                  rc = ACF2_Internal_Error;
                  goto exit;
                 };
              };

              /* WS2333 - Return NEXTKEYs in ADDINFO */

              /* IS10122
               * The pragraph below is moved forward in the code,
               * when we know we want this rule.
               *
               ****************************************************
              * For GetRes, get list of NEXTKEYs for ruleset      *
              *****************************************************
              if (ret_type EQ ACF2_Return_Ruleset)
              {
                ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                                "Create NEXTKEYS addinfo keyword");

                arc = Get_NEXTKEYs (current_key,
                                    restype,
                                    1,                    * depth *
                                    &nextkeys_buffer,     * =NULL *
                                    &nextkeys_bufflen,
                                    src_buffer,
                                    src_buffer_length,
                                    1,
                                    FALSE,
                                    &nextkeys_count,
                                    current_key,
                                    msgs,
                                    dest);

                if (arc NE ESA_OK)
                {
                 CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                               dest, component,func,
                               "Rule NEXTKEYs extraction failed",
                               16,__LINE__);
                 rc = ACF2_Internal_Error;
                 goto exit;
                };

                ACF2_Set_Keyword_Value ("NEXTKEYS",
                                        nextkeys_buffer,
                                        addinfo,
                                        msgs,
                                        dest);

                ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                                "Free NEXTKEYS buffer(%X)",
                                nextkeys_buffer);

                free(nextkeys_buffer);
              };
              end of moved part    IS10122 */

              /*****************************************************
              * Filter non-interesting records                     *
              ******************************************************/
              arc = Filter_Rule_Records
                            (ret_type,
                             src_buffer,
                             src_buffer_length,           /* WS2333 */
                             &records_buffer,             /* WS2333 */
                             &records_buffer_length);     /* WS2333 */

              ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                              "Buffer length after filter=(%d)",
                              records_buffer_length);     /* WS2333 */

              /* WS2333 */
              if (ret_type EQ ACF2_Return_Rule_Entries)
              {
                h -> Records_Buffer = records_buffer;
                h -> Records_Buffer_Len = records_buffer_length;
              };

              /* WS2333 - Deleted following 2 lines
              if (ret_type EQ ACF2_Return_Rule_Entries)
                h->Rule_Buffer_Len = src_buffer_length;
                                                */

              if (ESA_DIAG_get_debug_level(ESA_COMP_GETRES) GE
               DEBUG_SHOW_IMPORTANT)
              {
                /* WS2333 */
                SNAP_AREA( "RULE after filter", records_buffer, 400)
              };

              if (ret_type EQ ACF2_Return_Ruleset)
              {
                /*****************************************************
                * Convert ruleset header to addinfo format           *
                ******************************************************/
                arc = Get_Ruleset_Info(records_buffer,    /* WS2333 */
                                       records_buffer_length,
                                       addinfo,
                                       msgs,
                                       dest);

                if (arc NE ESA_OK)
                {
                  /* IS10122 - start */
                  if (arc EQ ESA_SKIP)
                  {
                    /* Issue "ROLSET rule ignored" msg */
                    /* resource name is in current_key. */
                    strcpy(errmsg, ACF2_ROLESET_IGNORED_MSG);
                    rc = ACF2_Not_Found;
                  }
                  else
                  {
                  /*  IS10122 - end */
                    strcpy(errmsg,"Get_Ruleset_Info failed");
                    rc = ACF2_Internal_Error;
                  }                                      /* IS10122 */
                  goto exit;
                /* IS10122 }; */
                }                                        /* IS10122 */

                /* IS10122 - start */
                /* nextkeys process moved here so it is done         */
                /* after we verified it is not a roleset rule.       */
                else
                {
                  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                                  "Create NEXTKEYS addinfo keyword");

                  arc = Get_NEXTKEYs (current_key,
                                      restype,
                                      1,                   /* depth */
                                      &nextkeys_buffer,    /* =NULL */
                                      &nextkeys_bufflen,
                                      src_buffer,
                                      src_buffer_length,
                                      1,
                                      FALSE,
                                      &nextkeys_count,
                                      current_key,
                                      msgs,
                                      dest);

                  if (arc NE ESA_OK)
                  {
                   CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                                 dest, component,func,
                                 "Rule NEXTKEYs extraction failed",
                                 16,__LINE__);
                   rc = ACF2_Internal_Error;
                   goto exit;
                  };

                  ACF2_Set_Keyword_Value ("NEXTKEYS",
                                          nextkeys_buffer,
                                          addinfo,
                                          msgs,
                                          dest);

                  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                                  "Free NEXTKEYS buffer(%X)",
                                  nextkeys_buffer);

                  free(nextkeys_buffer);
                }
                /* IS10122 - end */
              }
              else
              {
               if (records_buffer_length EQ 0)            /* WS2333 */
               {
                 rc = ACF2_OK;
                 strcpy(errmsg,"NO MORE ACES");
                 goto exit;
               };

               ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                               "First ACE retrieve...");

                rc = Get_Rule_Entry_Info(h,
                                         ace,
                                         addinfo,
                                         errmsg,          /* IS10122 */
                                         msgs,
                                         dest);

                switch (rc)
                {
                  case ACF2_OK:
                    break;

                  case ACF2_Not_Found:
      /* IS10122 */ if ( strcmp(errmsg, ACF2_ROLESET_IGNORED_MSG) NE 0 )
                    {                                     /* IS10122 */
                      rc = ACF2_OK;
                      strcpy(errmsg,"NO MORE ACES");
                    }                                     /* IS10122 */

                    break;
                  default:
                    strcpy(errmsg,"Get_Rule_Entry_Info failed");
                    rc = ACF2_Internal_Error;
                    goto exit;
                };
              };

              break;

              /***************************************************
              * Output buffer too small                          *
              ****************************************************/
     case 2:  rc = ACF2_Internal_Error;
              strcpy(errmsg,"ACF2 Output buffer too small");
              break;

              /***************************************************
              * Decompile failed                                 *
              ****************************************************/
     case 3:  rc = ACF2_Internal_Error;
              strcpy(errmsg,"ACF2 Rule Decompile failed");
              break;

              /***************************************************
              * Check EOF Status (via ACF2 Error Messages Codes) *
              ****************************************************/
     case 4:  strncpy(ACF2_msgid,errmsg,8);
              ACF2_msgid[8] = NULL_CHAR;
              if ( (strcmp(ACF2_msgid,ACF2_RESRULE_EOF) EQ 0) OR
                   (strcmp(ACF2_msgid,ACF2_RULE_NOT_FOUND) EQ 0) )
                rc = ACF2_Not_Found;
              else
                rc = ACF2_Internal_Error;
              break;

              /***************************************************
              * ACFRDS failed                                    *
              ****************************************************/
     case 5:  rc = ACF2_Internal_Error;
              strcpy(errmsg,"ACF2 ACFRDS process failed");
              break;

              /***************************************************
              * ACF2 Internal Error situations                   *
              ****************************************************/
     case 8:  rc = ACF2_Internal_Error;
              strcpy(errmsg,"ACF2 Control Block Error");
              break;

              /***************************************************
              * ACF2 Not Active                                  *
              ****************************************************/
     case 12:  rc = ACF2_ACF2_Not_Active;
              strcpy(errmsg,"ACF2 Not Active");
              break;

     default: rc = ACF2_Internal_Error;
              strcpy(errmsg,"Unknown ACF2 return code");
              break;
     };

   exit:

    if (obj_buffer NE NULL)
      free (obj_buffer);

    if (ret_type EQ ACF2_Return_Ruleset)
      if (src_buffer NE NULL)
        free (src_buffer);

    ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_REGULAR, func,rc);
    return rc;
 }

/* WS2358 */
/******************************************************************
 * Procedure Name: Prepare_KEYs_List
 ******************************************************************
 * Description   : Prepare list of all resource KEYs of a specific
 *                 resource type
 *
 * Input         : res_type   - Resource type
 *                 admin_params
 *
 * Output        : KEYs_list   - List of all resource KEYs
 *                 num_keys    - Number of keys in list
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Prepare_KEYs_List (char                  *res_type,
                           ACF2_Key_Cell_Typ     *KEYs_list,
                           int                   *num_keys,
                           ADMIN_PARAMS_rec_typ  *admin_params)
 {
   /*************************************************************
   * Variables                                                  *
   **************************************************************/
   static                       char func[]="Prepare_KEYs_List";

   ESA_RC         rc = ESA_OK;
   char           ACF2_RES_key[ACF2_RESRULE_KEY_SIZE];
   char           ACF2_current_RES_key[ACF2_RESRULE_KEY_SIZE];
   char           trimmed_key[ACF2_RESRULE_KEY_SIZE];
   char           errmsg[256];
   char           key_type[2]="P";
   char          *obj_buffer = NULL;
   int            rc1 = 0;

   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   *num_keys = 0;

   Reset_Field(ACF2_RES_key, sizeof(ACF2_RES_key), '*', NULL);
   Reset_Field(ACF2_current_RES_key, sizeof(ACF2_current_RES_key),
               ' ',NULL);

   Reset_Field(errmsg, sizeof(errmsg), 0X00, NULL);

   /*************************************************************
   * Obtain storage for rule object buffer                      *
   **************************************************************/
   obj_buffer = (char *) malloc (ACF2_RULE_BUFFER_LENGTH);

   if (obj_buffer EQ NULL)
   {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "RULE OBJECT BUFFER",
                  ACF2_RULE_BUFFER_LENGTH);
     rc = ESA_FATAL;
     goto exit;
   };

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "keymask=(%s) current RES key=(%s)",
                   ACF2_RES_key, ACF2_current_RES_key);

   /****************************************************************
   * A loop to read all resource KEYs of res_type                  *
   *****************************************************************/
   while (rc1 EQ 0)
   {
     /**************************************************************
     * Issue ACF2 API Call to ACGRSRC SVC                          *
     ***************************************************************/
     /* SAS2IBMT
     cts2grs(ACF2_RET_KEY_OP,                                        */
     (*(ASM_RTN_TYP *)&cts2grs)                           /* SAS2IBMT */
            (ACF2_RET_KEY_OP,
             ACF2_RES_key,
             res_type,
             ACF2_current_RES_key,
             key_type,
             obj_buffer,
             NULL,
             NULL,
             NULL,
             NULL,
             &rc1,
             errmsg);

     strcpy (trimmed_key, ACF2_current_RES_key);
     Trim (trimmed_key);

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "returned key=(%s)(%d) rc=(%d) errmsg(%s)",
                   trimmed_key, strlen(trimmed_key),
                   rc1, errmsg);

     if (rc1 EQ 0)
     {
       if ( *num_keys GE ACF2_MAX_NUM_OF_RULES )
       {
         CTSAMSG_print(ACF2_MAX_ALLOWED_KEYS_EXCEED, msgs, NULL, dest,
               res_type, ACF2_MAX_NUM_OF_RULES);

         rc = ESA_FATAL;
         goto exit;
       };

       strcpy (KEYs_list[*num_keys].Key_Cell_Val,
        trimmed_key);

       KEYs_list[*num_keys].Key_Cell_Match = TRUE;
       KEYs_list[*num_keys].Key_Cell_Rank = 0;

       *num_keys = *num_keys + 1;
     };

   }; /* End of loop */

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "num of KEYs(%d)",
                   *num_keys);

  exit:;

   if (obj_buffer NE NULL)
     free (obj_buffer);

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func,rc);

   return rc;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Most_Specific_Match
 ******************************************************************
 * Description   : This function returns the most specific match
 *                 resource ruleset for a given resource name.
 *
 * Input         : resmask_in - Resource name (full/1st qualifier)
 *                 KEYs_list  - List of all resource KEYs for res_type
 *                 num_keys   - Number of KEYs in list
 *
 * Output        : ruleset     - Most specific match ruleset
 *
 * Return Value  : TRUE or FALSE (no match found)
 *********************************************************************/
 int Most_Specific_Match (char                 *ruleset,
                          char                 *resmask_in,
                          ACF2_Key_Cell_Typ    *KEYs_list,
                          int                   num_keys,
                          ADMIN_PARAMS_rec_typ *admin_params)
 {
   /*************************************************************
   * Variables                                                  *
   **************************************************************/
   static                       char func[]="Most_Specific_Match";

   char                        *asterik_pos;
   int                          match_found, i, highest_rank;

   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   match_found = FALSE;

   highest_rank = -1;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "resource name=(%s) len(%d) num_keys(%d)",
                 resmask_in, strlen(resmask_in), num_keys);

   /*************************************************************
   * Loop to go over all KEYs in list and mark all those        *
   * that match our resource name                               *
   **************************************************************/
   for (i=0; i LT num_keys; i++)
   {
     if (Single_Qualifiers_Match (KEYs_list[i].Key_Cell_Val,
                                  resmask_in, FALSE) )
     {
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "$KEY(%s) MATCHES",
                     KEYs_list[i].Key_Cell_Val);

       match_found = TRUE;

       KEYs_list[i].Key_Cell_Match = TRUE;

       asterik_pos = strchr (KEYs_list[i].Key_Cell_Val, '*');

       /* No asterik ?  This is the best match we can get !!! */
       if (asterik_pos EQ NULL)
       {
         strcpy (ruleset, KEYs_list[i].Key_Cell_Val);
         goto exit;
       }
       else
       {
         if (asterik_pos-(KEYs_list[i].Key_Cell_Val) GT highest_rank)
         {
           highest_rank = (asterik_pos-(KEYs_list[i].Key_Cell_Val));
           strcpy (ruleset, KEYs_list[i].Key_Cell_Val);
         };
       };
     }
     else
     {
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "$KEY(%s) DOES NOT MATCH",
                     KEYs_list[i].Key_Cell_Val);

       KEYs_list[i].Key_Cell_Match = FALSE;
     };

   }; /* End of loop */

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func,
                 match_found);

   return match_found;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: ACF2_Automate
 ******************************************************************
 * Description   : This recursive function automates the process of
 *                 adding a new rule entry to the ruleset chain
 *                 at the appropriate place.
 *
 * Input         : res_name   - Current resource name
 *                 res_type   - Resource type
 *                 new_ace    - New ACE struct fields (sent from ESS)
 *                 new_addinfo- New ACE ADDINFO fields (from ESS)
 *                 rule_file
 *                 KEYs_list  - List of KEYs
 *                 num_keys   - Number of KEYs in list
 *                 admin params
 *
 * Input/Output  : h          - ACEs handle
 *                 laddinfo   - Resource work ADDINFO
 *                 ace_addinfo- ACE work ADDINFO
 *                 nextkeys_list
 *
 * Output        : num_rules   - total number of rule entries
 *                               in modified ruleset (for compile)
 *                 target_rule - final ruleset name
 *                 errmsg      - error message description
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC ACF2_Automate (char                      *res_name,
                       char                      *res_type,
                       ACE_rec_typ               *new_ace,
                       ADDINFO_rec_ptr            new_addinfo,
                       ACF2_Get_ResACL_Handle    *h,
                       ADDINFO_rec_ptr            laddinfo,
                       ADDINFO_rec_ptr            ace_addinfo,
                       FILE                      *rule_file,
                       int                       *num_rules,
                       char                      *target_rule,
                       ACF2_Key_Cell_Typ         *KEYs_list,
                       int                        num_keys,
                       char                      *nextkeys_list,
                       char                      *errmsg,
                       ADMIN_PARAMS_rec_typ      *admin_params)
 {
   /*************************************************************
   * Variables                                                  *
   **************************************************************/
   static                       char func[]="ACF2_Automate";

   RESOURCE_typ                current_key, nextkey_res, real_next;
   RESOURCE_typ                real_rule_entry;           /* BS2411 */
   ACE_rec_typ                 curr_ace;
   ONE_FIELD_rec_ptr           pair = NULL;
   ONE_FIELD_rec_ptr           opair = NULL;              /* BS2411 */
   ESA_RC                      rc = ESA_OK;
   char                        msg[256]="";
   char                        sep[3];
   char                       *new_nextkey_pos;
   char                       *curr_nextkey;
   char                       *curr_nextkey_end;
   int                         rule_sorted, full_prevent, access_match;
   int                         scan_aces, match_found, rule_number;
   int                         nextkey_exists;
   int                         resmask_with_quotes;       /* BS2411 */

   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   BUILD_STRING_SEPARATOR(sep, ADDINFO_LIST_ENTRY);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   new_nextkey_pos = nextkeys_list + strlen(nextkeys_list);

   if (strlen(nextkeys_list) NE 0)
     new_nextkey_pos = new_nextkey_pos + 1;

   Reset_Field(current_key, sizeof(RESOURCE_typ), NULL_CHAR, NULL);

   ADDINFO_empty(laddinfo);
   ADDINFO_empty(ace_addinfo);

   /*************************************************************
   * Fill local addinfo with all the resource keywords          *
   * (used to emulate a Get_Resource request with all keywords) *
   **************************************************************/
   Fill_Res_Keywords(laddinfo);

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "NEXTKEYs list (%s) len(%d)",
                 nextkeys_list, strlen(nextkeys_list));

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "Get current ruleset: res(%s) type(%s)",
                 res_name, res_type);

   /*************************************************************
   * Get current ruleset header fields                          *
   **************************************************************/
   rc = ACF2_Get_Resource(res_name,
                          ACF2_Object_is_Not_Masked,
                          res_type,
                          ACF2_Return_Ruleset,
                          NULL,
                          NULL,
                          current_key,
                          NULL,
                          laddinfo,
                          errmsg,
                          admin_params);

   /*************************************************************
   * Check result of GET operation                              *
   **************************************************************/
   switch(rc)
   {
      case ACF2_OK:
        break;

      case ACF2_Not_Found:
        /* IS10122 - start */
        /*
         *   Issue a message when rule is ignored or not found
         */
        if ( strcmp(errmsg, ACF2_ROLESET_IGNORED_MSG) EQ 0 )
            CTSAMSG_print(ACF2_RES_ROLESET_IGNORED, msgs, NULL, dest,
                          res_name, res_type);
        else
            CTSAMSG_print(ERR_RES_NOT_EXIST, msgs, NULL, dest,
                        res_name);
        /* IS10122 - end */
        rc = ESA_FATAL;
        goto exit;

      default:
        sprintf(msg,"Get Res fail res=%s rc=%d msg=%s",
                  res_name, rc, errmsg);
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
               func, msg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
   }

   /*************************************************************
   * Is the current ruleset in NOSORT mode ?                    *
   **************************************************************/
   pair = ADDINFO_search ("NOSORT",
                          ACF_ADDINFO_KWD_LEN,
                          laddinfo->pair,
                          laddinfo->num_pairs);

   if (pair EQ NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component, func,
           "Mandatory keyword NOSORT missing in resource ADDINFO",
           16,__LINE__);
     rc = ESA_FATAL;
     goto exit;
   };

   if (pair->value[0] EQ 'Y')
     rule_sorted = FALSE;
   else
     rule_sorted = TRUE;

   if (rule_sorted)
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "** Current ruleset is SORTED **");
   else
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "** Current ruleset is NOT SORTED **");

   /*************************************************************
   * BS2411 - Calculate real rule entry for this rule set       *
   **************************************************************/
   opair = ADDINFO_search ("RESMASK",                     /* BS2411 */
                           ACF_ADDINFO_KWD_LEN,           /* BS2411 */
                           new_addinfo->pair,             /* BS2411 */
                           new_addinfo->num_pairs);       /* BS2411 */

   Calc_Real_Rule_Entry (res_name,                        /* BS2411 */
                         res_type,                        /* BS2411 */
                         laddinfo,                        /* BS2411 */
                         opair->value,                    /* BS2411 */
                         real_rule_entry,                 /* BS2411 */
                         &resmask_with_quotes,            /* BS2411 */
                         msgs,                            /* BS2411 */
                         dest);                           /* BS2411 */

   /*************************************************************
   * Fill ACE addinfo with all the ACE keywords                 *
   * (used to emulate a Get_ACE request with all keywords)      *
   **************************************************************/
   Fill_ACE_Keywords (ace_addinfo);

   h->First_Call = TRUE;
   h->Current_ACE_Pos = 0;
   h->Current_ACE_Offset = NULL;

   scan_aces = TRUE;

   rule_number = 0;

   /*************************************************************
   * a loop to scan all rule entries of current ruleset         *
   **************************************************************/
   while (scan_aces)
   {
     ADDINFO_clear(ace_addinfo);

     /***********************************************************
     * Get current ACE from current ruleset                     *
     ************************************************************/
     rc = ACF2_Get_Resource(res_name,
                            ACF2_Object_is_Not_Masked,
                            res_type,
                            ACF2_Return_Rule_Entries,
                            h,
                            NULL,
                            current_key,
                            &curr_ace,
                            ace_addinfo,
                            errmsg,
                            admin_params);

     switch(rc)
     {
        case ACF2_OK:
          break;

        case ACF2_Not_Found:
          /* IS10122 - start */
          /*
           *   Issue a message when rule is ignored or not found
           */
          if ( strcmp(errmsg, ACF2_ROLESET_IGNORED_MSG) EQ 0 )
            CTSAMSG_print(ACF2_RES_ROLESET_IGNORED, msgs, NULL, dest,
                          res_name, res_type);
          else
          /* IS10122 - end   */
            CTSAMSG_print(ERR_RES_NOT_EXIST, msgs, NULL, dest,
                          res_name);
          rc = ESA_FATAL;
          goto exit;

        default:
          sprintf(msg,"Get ResACL fail res=%s rc=%d msg=%s",
                    res_name, rc, errmsg);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                 func, msg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
     }

     /***********************************************************
     * Have we reached end of current ruleset ?                 *
     * If yes, it means this is our final destination...        *
     *                                                          *
     * If this ruleset is in NOSORT mode, we exit with error.   *
     * Otherwise, we need to write the ruleset header and then  *
     * re-read all its rule entries so we can write them to the *
     * file.                                                    *
     ************************************************************/
     if (strcmp (errmsg, "NO MORE ACES") EQ 0)
     {
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "Reached end of curr res (%s)",
                     res_name);

       CTSAMSG_print(ACF2_SELECTED_RULESET, msgs, NULL, dest,
                     res_name);

       strcpy (target_rule, res_name);

       /*********************************************************
       * Reset some ACE handle variables                        *
       **********************************************************/
       h->First_Call = TRUE;
       h->Current_ACE_Pos = 0;
       h->Current_ACE_Offset = NULL;

       Reset_Field(current_key, sizeof(RESOURCE_typ), NULL_CHAR, NULL);

       /*********************************************************
       * BS2411 - Update RESMASK with real rule entry unless    *
       *          RESMASK contains rule with quotes             *
       **********************************************************/
       if (NOT resmask_with_quotes)                       /* BS2411 */
         ACF2_Set_Keyword_Value ("RESMASK",               /* BS2411 */
                                 real_rule_entry,         /* BS2411 */
                                 new_addinfo,             /* BS2411 */
                                 msgs,                    /* BS2411 */
                                 dest);                   /* BS2411 */

       /*********************************************************
       * We can add our ACE only if the ruleset is SORTed       *
       **********************************************************/
       if (rule_sorted)
       {
         /*******************************************************
         * Write entire ruleset + new rule entry to rule file   *
         ********************************************************/
         ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                       "Writing entire rule");

         rc = Write_Entire_Rule (res_name,
                                 res_type,
                                 laddinfo,
                                 h,
                                 ace_addinfo,
                                 new_ace,
                                 new_addinfo,
                                 num_rules,
                                 rule_file,
                                 errmsg,
                                 admin_params);

         if (rc NE ESA_OK)
         {
           rc = ESA_FATAL;
           goto exit;
         };

         /* Finish ... */
         rc = ESA_OK;
         goto exit;
       }
       else
       {
         ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                       "Ruleset is NOSORT. terminating.");
          CTSAMSG_print(ACF2_RULESET_IS_NOSORT, msgs, NULL, dest);
          rc = ESA_FATAL;
          goto exit;
       };
     }; /* End of reached-end-of-ruleset handling */

     rule_number++;

     /***********************************************************
     * Possible scenarios:                                      *
     * ===================                                      *
     * 1. NEXTKEY not found - jump to next rule entry           *
     *    Reached ruleset end ?  Add new rule (see logic above) *
     *                                                          *
     * 2. NEXTKEY found. Does access environment match ?        *
     *    NO  - jump to next rule entry                         *
     *    YES - Is access prevented ?                           *
     *          YES - perform NEXTKEY jump                      *
     *          NO  - jump to next rule entry                   *
     /***********************************************************
     * Do we have a NEXTKEY field in current rule entry ?       *
     ************************************************************/
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "Check if current rule has NEXTKEY field");

     pair = ADDINFO_search ("NEXTKEY",
                            ACF_ADDINFO_KWD_LEN,
                            ace_addinfo->pair,
                            ace_addinfo->num_pairs);

     if (pair EQ NULL)
       continue;

     if (pair->value[0] EQ NULL_CHAR)
       continue;

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "NEXTKEY(%s) found",
                     pair->value);

     /***********************************************************
     * we have a NEXTKEY field. Do access environment check     *
     ************************************************************/
     /***********************************************************
     * THE HEART OF IT ALL:                                     *
     * Does the curr. rule entry access env. include ours ?     *
     * If yes, it means ours is more specific. For example:     *
     * curr. rule entry is:   PARMLIB.- UID(A)                  *
     * our rule entry is  :   PARMLIB.- UID(ABCD)               *
     ************************************************************/
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "Checking if access env. match.");

     rc = Access_Env_Matches (new_ace,
                              res_type,
                              new_addinfo,
                              ace_addinfo,
                              laddinfo,                   /* BS2411 */
                              &access_match,
                              real_rule_entry,            /* BS2411 */
                              res_name,                   /* BS2411 */
                              msgs,
                              dest);

     if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     };

     if (access_match)
     {
       /*********************************************************
       * Is access denied in this rule ?                        *
       **********************************************************/
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "Access env matches. Check if access is denied");

       if (Is_Access_Denied (res_type,
                             new_addinfo,
                             ace_addinfo,
                             &full_prevent) )
       {
         strcpy (nextkey_res, pair->value);

         /*******************************************************
         * Check for NEXTKEYs loop                              *
         ********************************************************/
         ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                   "Check for NEXTKEYs loop. New NEXTKEY=(%s)",
                   nextkey_res);

         nextkey_exists = FALSE;

         if (strlen(nextkeys_list) NE 0)
         {
           curr_nextkey = nextkeys_list;
           curr_nextkey_end = strchr (curr_nextkey,
                                      ADDINFO_LIST_ENTRY);

           while ( (curr_nextkey_end NE NULL) AND
                   (NOT nextkey_exists) )
           {
             *curr_nextkey_end = NULL_CHAR;

             if (strcmp (curr_nextkey, nextkey_res) EQ 0)
               nextkey_exists = TRUE;

             *curr_nextkey_end = ADDINFO_LIST_ENTRY;
             curr_nextkey = curr_nextkey_end + 1;

             curr_nextkey_end = strchr (curr_nextkey,
                                        ADDINFO_LIST_ENTRY);

           }; /* while loop */

           if (strcmp (curr_nextkey, nextkey_res) EQ 0)
             nextkey_exists = TRUE;
         };

         if (nextkey_exists)
         {
           CTSAMSG_print(ACF2_NEXTKEYS_LOOP, msgs, NULL, dest);
           rc = ESA_FATAL;
           goto exit;
         };

         /*******************************************************
         * Add new NEXTKEY to NEXTKEYs list                     *
         ********************************************************/
         if (strlen (nextkeys_list) GT 0)
           strcat (nextkeys_list, sep);

         strcat (nextkeys_list, nextkey_res);

         CTSAMSG_print(ACF2_JUMP_TO_NEXTKEY, msgs, NULL, dest,
                       rule_number, res_name);

         /* Special logic for RESOURCE RULES */
         if (strcmp (res_type, "DSN") EQ 0)
           ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                         "Access IS DENIED. jump to NEXTKEY(%s)",
                         nextkey_res);
         else
         {
           ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                         "Access IS DENIED. Find match to NEXTKEY(%s)",
                         nextkey_res);

           match_found = Most_Specific_Match (real_next,
                                              nextkey_res,
                                              KEYs_list,
                                              num_keys,
                                              admin_params);

           if (NOT match_found)
           {
             CTSAMSG_print(ACF2_NO_MATCHING_KEY, msgs, NULL, dest);
             rc = ESA_FATAL;
             goto exit;
           };

           ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                         "most specific match to NEXTKEY is(%s)",
                         real_next);

           strcpy (nextkey_res, real_next);
         };

         CTSAMSG_print(ACF2_NEXTKEY_NAME, msgs, NULL, dest,
                       nextkey_res);

         rc = ACF2_Automate (nextkey_res,
                             res_type,
                             new_ace,
                             new_addinfo,
                             h,
                             laddinfo,
                             ace_addinfo,
                             rule_file,
                             num_rules,
                             target_rule,
                             KEYs_list,
                             num_keys,
                             nextkeys_list,
                             errmsg,
                             admin_params);

         if (rc NE ESA_OK)
         {
           if (rc GT ESA_SKIP)                            /* IS10122 */
             rc = ESA_FATAL;
           goto exit;
         };

         /* Finish ... */
         rc = ESA_OK;
         goto exit;
       }
       else
       {
         ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                       "Access is NOT denied. Do not NEXTKEY");

         if (full_prevent)
         {
           ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                         "New ACE fully prevents access");
           CTSAMSG_print(ACF2_ACCESS_FULLY_PREVENTED,
                         msgs, NULL, dest);
         };
       };
     };
   }; /* End of loop to scan all rule entries of current ruleset */

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func,rc);

   return rc;
 }
 /* End of WS2358 */

/******************************************************************
 * Procedure Name: Build_Ruleset
 ******************************************************************
 * Description   : Build ruleset header in file
 *
 * Input         : resource name          WS2358
 *                 resource type          WS2358
 *                 addinfo
 *                 file handle
 *                 msgs,dest
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Build_Ruleset (char                       *res_name,
                       char                       *res_type,
                       ADDINFO_rec_ptr             addinfo,
                       FILE                       *rule_file,
                       CTSAMSG_HANDLE_rec_typ     *msgs,
                       CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static         char func[]="Build_Ruleset";
   ESA_RC         rc = ESA_OK;
/*All statements refer to Rules so no risk of work_pair GT 1K WS10082A*/
   ONE_FIELD_rec_typ work_pair;
   ONE_FIELD_rec_ptr pair = NULL;
   char              record[81], sep[3], curr_keyword[20]="";
   char             *curr_uid;
   int               i;

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   BUILD_STRING_SEPARATOR(sep, ADDINFO_LIST_ENTRY);

  /*****************************************************************
  * Write ruleset key and type                                     *
  ******************************************************************/
  memset (record, ' ', sizeof(record)-1);
  strcpy (record, "$KEY(");
  strcat (record, res_name);                              /* WS2358 */
  strcat (record, ") ");

  if (strcmp (res_type, "DSN") NE 0)                      /* WS2358 */
  {
    strcat (record, "TYPE(");
    strcat (record, res_type);                            /* WS2358 */
    strcat (record, ") ");
  };

  ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                  "Handle NOSORT, MODE and RECNAME");

  /*****************************************************************
  * Handle NOSORT                                                  *
  ******************************************************************/
  pair = ADDINFO_search("NOSORT", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  if (pair NE NULL)
    if (pair->value[0] EQ 'Y')
      strcat (record, "NOSORT ");

  /*****************************************************************
  * Handle MODE                                                    *
  ******************************************************************/
  pair = ADDINFO_search("MODE", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  if (pair NE NULL)
    if (pair->value[0] NE NULL_CHAR)
    {
      strcat (record, "MODE(");
      strcat (record, pair->value);
      strcat (record, ") ");
    };

  /*****************************************************************
  * Handle RECNAME                                                 *
  ******************************************************************/
  pair = ADDINFO_search("RECNAME", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  if (pair NE NULL)
    if (pair->value[0] NE NULL_CHAR)
    {
      strcat (record, "RECNAME(");
      strcat (record, pair->value);
      strcat (record, ") ");
    };

  /*****************************************************************
  * Write the record to the file                                   *
  ******************************************************************/
  ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                  "First record=(%s)", record);

  record[strlen(record)] = ' ';
  fwrite (record, 1, 80, rule_file);

  pair = NULL;

  /*****************************************************************
  * Handle rest of keywords                                        *
  ******************************************************************/
  for (i=0; i LT addinfo->num_pairs; i++)
  {
    pair = ADDINFO_get_next(addinfo, pair);

    if (pair EQ NULL)
      break;

    /***************************************************************
    * Ignore the following keywords:                               *
    * NOSORT, MODE, RECNAME     - already handled                  *
    * CHANGE, RCHANGE           - will be handled later            *
    * DATELAST, DATEUSER        - internal fields, not ACF2 fields *
    * COPYRES, RESMODEL         - internal fields, not ACF2 fields *
    ****************************************************************/
    if ( (strcmp (pair->keyword, "NOSORT") EQ 0) OR
         (strcmp (pair->keyword, "MODE") EQ 0) OR
         (strcmp (pair->keyword, "RECNAME") EQ 0) OR
         (strcmp (pair->keyword, "CHANGE") EQ 0) OR
         (strcmp (pair->keyword, "RCHANGE") EQ 0) OR
         (strcmp (pair->keyword, "DATELAST") EQ 0) OR
         (strcmp (pair->keyword, "DATEUSER") EQ 0) OR
         (strcmp (pair->keyword, "COPYRES") EQ 0) OR
         (strcmp (pair->keyword, "RESMODEL") EQ 0))
      continue;

    ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                    "Keyword=(%s)", pair->keyword);

    if (pair->value[0] EQ NULL_CHAR)
      continue;

    ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                    "Value=(%s)", pair->value);

    /***************************************************************
    * Build current record and write it to the file                *
    ****************************************************************/
    memset (record, ' ', sizeof(record)-1);
    strcpy (record, "$");
    strcat (record, pair->keyword);
    strcat (record, "(");
    if ( (strlen(pair->keyword)+strlen(pair->value)) GT 70)
    {
      strcat (record, "-");
      record[strlen(record)] = ' ';
      fwrite (record, 1, 80, rule_file);
      memset (record, ' ', sizeof(record)-1);
      strcpy (record, pair->value);
      strcat (record, ") ");
      record[strlen(record)] = ' ';
      fwrite (record, 1, 80, rule_file);
    }
    else
    {
      strcat (record, pair->value);
      strcat (record, ") ");
      record[strlen(record)] = ' ';
      fwrite (record, 1, 80, rule_file);
    };
  };

  /*****************************************************************
  * Handle CHANGE and RCHANGE                                      *
  ******************************************************************/
  for (i=0; i LT 2; i++)
  {
    if (i EQ 0)
      strcpy (curr_keyword, "CHANGE");
    else
      strcpy (curr_keyword, "RCHANGE");

    pair = ADDINFO_search(curr_keyword,
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

    if (pair NE NULL)
      if (pair->value[0] NE NULL_CHAR)
      {
        ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                        "%s Value=(%s)", curr_keyword, pair->value);

        memcpy ((char *)&work_pair, (char *)pair,
         sizeof (ONE_FIELD_rec_typ));

        pair = &work_pair;

        curr_uid = strtok (pair->value, sep);
        while (curr_uid NE NULL)
        {
          memset (record, ' ', sizeof(record)-1);
          strcpy (record, "%");
          strcat (record, curr_keyword);
          strcat (record, " ");
          Trunc_One_UIDMASK (curr_uid);

          if (curr_uid[0] EQ NULL_CHAR)
            strcpy (curr_uid, "*");

          strcat (record, curr_uid);
          record[strlen(record)] = ' ';
          fwrite (record, 1, 80, rule_file);
          curr_uid = strtok (NULL, sep);
        };
      };
  };

  exit:;

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/******************************************************************
 * Procedure Name: Build_Rule_Entry
 ******************************************************************
 * Description   : Build rule entry in file
 *
 * Input         : ace
 *                 addinfo
 *                 restype
 *                 file handle
 *                 msgs,dest
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Build_Rule_Entry (ACE_rec_typ                *ace,
                          ADDINFO_rec_ptr             addinfo,
                          RESTYPE_typ                 restype,
                          FILE                       *rule_file,
                          CTSAMSG_HANDLE_rec_typ     *msgs,
                          CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static         char func[]="Build_Rule_Entry";
   ESA_RC         rc = ESA_OK;
/*All statements refer to Rules so no risk of work_pair GT 1K WS10082A*/
   ONE_FIELD_rec_typ work_pair;
   ONE_FIELD_rec_ptr pair = NULL;
   char              record[81], sep[3], resmask_part[80]="";
   char              access_level[10]="";
   char              Date_Pattern[9]="";
   char              ACF2_Date[9]="";
   char              curr_uid[256]="";
   char             *curr_service;
   int               i, curr_ofs, write_dash, no_resmask;

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   BUILD_STRING_SEPARATOR(sep, ADDINFO_LIST_ENTRY);

   Global_ACF2_Date_Format(Date_Pattern);

   /****************************************************************
   * Handle different ACE types (WORLD, USER, MASK)                *
   *****************************************************************/
   rc = Handle_ACE_Types (ace,                            /* WS2358 */
                          addinfo,                        /* WS2358 */
                          curr_uid,                       /* WS2358 */
                          msgs,                           /* WS2358 */
                          dest);                          /* WS2358 */

   if (rc NE ESA_OK)                                      /* WS2358 */
   {                                                      /* WS2358 */
     rc = ESA_FATAL;                                      /* WS2358 */
     goto exit;                                           /* WS2358 */
   };                                                     /* WS2358 */

  ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                  "Handle RESMASK, UIDMASK");

  /*****************************************************************
  * Write the resource mask                                        *
  * We split the mask to 64-char strings, each occupying one line. *
  * To the last line we concat the UID keyword.                    *
  * To all the other lines we add '-' in the end unless the last   *
  * (64th) char in the line is already '-'.                        *
  * In that case we begin the next line with '-'.                  *
  ******************************************************************/
  pair = ADDINFO_search("RESMASK", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);

  if (pair EQ NULL)
    no_resmask = TRUE;

  if (pair NE NULL)
    if ((pair->value[0] NE NULL_CHAR) AND (strlen(pair->value) GT 0))
    {
      no_resmask = FALSE;

      ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                      "Resource mask=(%s)", pair->value);

      i = ( ( (strlen(pair->value)-1) / 64) + 1 );

      curr_ofs = 0;

      write_dash = FALSE;

      while (i GT 0)
      {
        memset (resmask_part, NULL_CHAR, sizeof(resmask_part)-1);

        strncpy (resmask_part, &(pair->value[curr_ofs]), 64);

        memset (record, ' ', sizeof(record)-1);

        /* Only in first line we begin from column 2 */
        if (curr_ofs EQ 0)
          strcpy (record+1, resmask_part);
        else
        {
          if (write_dash)
          {
            record[0] = '-';
            strcpy (record+1, resmask_part);
            write_dash = FALSE;
          }
          else
            strcpy (record, resmask_part);
        };

        /* In last line we concat the UID keyword */
        /* If it's not the last line we concat    */
        /* a dash unless a dash is already there  */
        if (i EQ 1)
          strcat (record, " UID(-");
        else
        {
          if (record[strlen(record)-1] NE '-')
            strcat (record, "-");
          else
            write_dash = TRUE;
        };

        record[strlen(record)] = ' ';
        fwrite (record, 1, 80, rule_file);

        curr_ofs = curr_ofs + 64;
        i--;
      };

      /*************************************************************
      * Write the UIDMASK                                          *
      **************************************************************/
      memset (record, ' ', sizeof(record)-1);
      Trunc_One_UIDMASK (curr_uid);

      if (curr_uid[0] EQ NULL_CHAR)
        strcpy (curr_uid, "-");

      ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                      "UIDMASK=(%s)", curr_uid);

      strcpy (record, curr_uid);
      strcat (record, ") -");
      record[strlen(record)] = ' ';
      ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,/* IS10178 */
               "curr_uid=(%s) before fwrite", curr_uid);   /* IS10178 */
      ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,/* IS10178 */
               "record=(%s) before fwrite", record);       /* IS10178 */
      fwrite (record, 1, 80, rule_file);
    }
    else
      no_resmask = TRUE;

  if (no_resmask)
  {
    ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                    "No resource mask in ACE");

    memset (record, ' ', sizeof(record)-1);
    strcpy (record+1, "UID(");
    Trunc_One_UIDMASK (curr_uid);

    if (curr_uid[0] EQ NULL_CHAR)
      strcpy (curr_uid, "-");

    ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                    "UIDMASK=(%s)", curr_uid);

    strcat (record, curr_uid);
    strcat (record, ") -");
    record[strlen(record)] = ' ';
    fwrite (record, 1, 80, rule_file);
  };

  /*****************************************************************
  * Handle ADDINFO keywords                                        *
  ******************************************************************/
  for (i=0; i LT addinfo->num_pairs; i++)
  {
    pair = ADDINFO_get_next(addinfo, pair);

    if (pair EQ NULL)
      break;

    /***************************************************************
    * Ignore the following keywords:                               *
    * POS                       - internal, not an ACF2 keyword    *
    * RESMASK, UID              - already handled                  *
    * VERIFY, SERVICE, ACCESS   - will be handled later            *
    ****************************************************************/
    if ( (strcmp (pair->keyword, "POS") EQ 0) OR
         (strcmp (pair->keyword, "RESMASK") EQ 0) OR
         (strcmp (pair->keyword, "UID") EQ 0) OR
         (strcmp (pair->keyword, "VERIFY") EQ 0) OR
         (strcmp (pair->keyword, "SERVICE") EQ 0) OR
         (strcmp (pair->keyword, "ACCESS") EQ 0))
      continue;

    if (pair->value[0] EQ NULL_CHAR)
      continue;

    ESA_DIAG_printf(ESA_COMP_UPDRES,DEBUG_SHOW_IMPORTANT,
                    "Keyword=(%s) Value=(%s)",
                    pair->keyword, pair->value);

    /***************************************************************
    * Build current record and write it to the file                *
    ****************************************************************/
    memset (record, ' ', sizeof(record)-1);
    strcpy (record+1, pair->keyword);
    strcat (record, "(");

    /***************************************************************
    * For READ, WRITE, EXEC or ALLOC we take the 1st letter of     *
    * the value as the ACF2 value                                  *
    ****************************************************************/
    if ( (strcmp (pair->keyword, "READ") EQ 0) OR
         (strcmp (pair->keyword, "WRITE") EQ 0) OR
         (strcmp (pair->keyword, "EXEC") EQ 0) OR
         (strcmp (pair->keyword, "ALLOC") EQ 0))
    {
      if (strcmp (restype, "DSN") NE 0)
        continue;

      strcpy (access_level, pair->value);
      /* WS10075 skip this statement: access_level[1] = NULL_CHAR; */
      strcat (record, access_level);
    }

    /***************************************************************
    * For UNTIL and ACTIVE we convert the date to ACF2 format      *
    ****************************************************************/
    /* ******* ******* ******* WS10075 start ******* ******* *******/
    /* We will no longer make this change.                         */
    /*
    else if ( (strcmp (pair->keyword, "UNTIL") EQ 0) OR
              (strcmp (pair->keyword, "ACTIVE") EQ 0))
    {
      CTSCDAT_conv2RSS(ESA_COMP_ADDRES,
                       Date_Pattern,pair->value,ACF2_Date,
                       dest,msgs);

      strcat (record, ACF2_Date);
    }                                                              */
    /* ******* ******* ******* WS10075  end  ******* ******* *******/

    /***************************************************************
    * For the rest we just copy the value as it is                 *
    ****************************************************************/
    else
      strcat (record, pair->value);

    if (strcmp (pair->keyword, "DATA") EQ 0)
      strcat (record, ")-");
    else
      strcat (record, ") - ");

    record[strlen(record)] = ' ';
    fwrite (record, 1, 80, rule_file);
  };

  /*****************************************************************
  * Handle SERVICE                                                 *
  ******************************************************************/
  if (strcmp (restype, "DSN") NE 0)
  {
    pair = ADDINFO_search("SERVICE", ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

    if (pair NE NULL)
      if (pair->value[0] NE NULL_CHAR)
      {
        memset (record, ' ', sizeof(record)-1);
        strcpy (record+1, "SERVICE(");

        /* ******* ******* **** WS10075 start **** ******* *******/
        /* We will no longer make this change.                   */
        /*
        if (strstr (pair->value, "ALL") NE NULL)
          strcat (record, "READ,ADD,UPDATE,DELETE");
        else
        {                                                        */
          memcpy ((char *)&work_pair, (char *)pair,
           sizeof (ONE_FIELD_rec_typ));

          pair = &work_pair;

          curr_service = strtok (pair->value, sep);

          i = TRUE;

          while (curr_service NE NULL)
          {
            if (i)
              i = FALSE;
            else
              strcat (record, ",");

            strcat (record, curr_service);
            curr_service = strtok (NULL, sep);
          };
        /*
        }; This was removed because of WS10075 change above. */

        strcat (record, ") - ");
        record[strlen(record)] = ' ';
        fwrite (record, 1, 80, rule_file);
      };
  };

  /*****************************************************************
  * Handle VERIFY                                                  *
  ******************************************************************/
  if (strcmp (restype, "DSN") NE 0)
  {
    memset (record, ' ', sizeof(record)-1);

    pair = ADDINFO_search("VERIFY", ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

    if (pair NE NULL)
      if (pair->value[0] EQ 'Y')
      {
        strcpy (record+1, "VERIFY - ");
        record[strlen(record)] = ' ';
        fwrite (record, 1, 80, rule_file);
      };
  };

  /*****************************************************************
  * Handle ACCESS                                                  *
  ******************************************************************/
  if (strcmp (restype, "DSN") NE 0)
  {
    memset (record, ' ', sizeof(record)-1);

    pair = ADDINFO_search("ACCESS", ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

    if (pair NE NULL)
      if (pair->value[0] NE NULL_CHAR)
      {
        strcpy (record+1, pair->value);
        strcat (record, " - ");
        record[strlen(record)] = ' ';
        fwrite (record, 1, 80, rule_file);
      };
  };

  memset (record, ' ', sizeof(record)-1);
  fwrite (record, 1, 80, rule_file);

  exit:;

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/******************************************************************
 * Procedure Name: Compile_Ruleset
 ******************************************************************
 * Description   : Compile ruleset and store it
 *
 * Input         : reskey
 *                 restype
 *                 replace/dont replace rule
 *                 num of rules
 *                 buffer
 *                 msgs,dest
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Compile_Ruleset (char                       *reskey,
                         char                       *restype,
                         ACF2_Replace_Rule_Type      rep,
                         int                         num_rules,
                         char                       *obj_buffer,
                         char                       *errmsg,
       /* PS0347 */      ADMIN_PARAMS_rec_typ       *admin_params)
 {
   static         char func[]="Compile_Ruleset";
   ESA_RC         rc = ESA_OK;

   int            rc1 = 0;

   char           ACF2_msgid[9];
   char           ACF2_key[ACF2_RESRULE_KEY_SIZE];
   char           rule_parm[13]="";
   char           replace_flag;
   char           init_char = ' ';
   char           parm_get[201];                          /* PS0347 */

   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   Reset_Field(errmsg,sizeof(errmsg),0X00,NULL);

   Reset_Field(ACF2_key,sizeof(ACF2_key),init_char,reskey);

   if (rep EQ ACF2_Replace_Rule)
     replace_flag = 'Y';
   else
     replace_flag = 'N';

   /* PS0347 - Added */
   /******************************************************************
   * Search for USE_MAXRULE parameter in RSSPARM                     *
   *******************************************************************/
   strcpy (rule_parm,"");

   rc = admin_params ->
    cs_func.rssprm_get_opt_ptr(admin_params -> rss_name,
                               "USE_MAXRULE",
                               sizeof(parm_get),
                               parm_get,
                               OPT_TRUE,
                               OPT_TRUE);

   /******************************************************************
   * If USE_MAXRULE value is Y, build MAXRULE parm to ACF2 compiler  *
   *******************************************************************/
   if (rc EQ ESA_OK)
   {
     if (strcmp (parm_get, "Y") EQ 0)
     {
       sprintf (rule_parm, "MAXRULE(%03d)", num_rules);

       ESA_DIAG_printf(ESA_COMP_UPDRES, DEBUG_SHOW_IMPORTANT,
                       "Rule parm=%s",
                       rule_parm);
     };
   };
   /* End of PS0347 */

   rc = ESA_OK;                                           /* PS0373 */

   /******************************************************************
   * Compile and insert/replace the rule                             *
   *******************************************************************/
   /* SAS2IBMT
   cts2cmp(ACF2_key,                                                 */
   (*(ASM_RTN_TYP *)&cts2cmp)(ACF2_key,                   /* SAS2IBMT */
           restype,
           &replace_flag,
           rule_parm,
           "ACF2IN  ",
           obj_buffer,
           &rc1,
           errmsg);

   ESA_DIAG_printf(ESA_COMP_UPDRES, DEBUG_SHOW_IMPORTANT,
                   "rc=(%d) errmsg(%s)",
                   rc1, errmsg);

   switch(rc1)
   {
     case 0:  Get_Compiler_Messages (msgs, dest);
              break;

              /***************************************************
              * ACF2 Compiler Error situations                   *
              ****************************************************/
     case 6:  rc = ESA_FATAL;
              Get_Compiler_Messages (msgs, dest);
              strcpy(errmsg,"ACF2 Compiler Error");
              break;

              /***************************************************
              * ACF2 Access Error situations                     *
              ****************************************************/
     case 4:  strncpy(ACF2_msgid,errmsg,8);
              ACF2_msgid[8] = NULL_CHAR;
              if ( (strcmp(ACF2_msgid,ACF2_ARULE_EXISTS) EQ 0) OR
                   (strcmp(ACF2_msgid,ACF2_RRULE_EXISTS) EQ 0) OR
                   (strcmp(ACF2_msgid,ACF2_ARULE_NOT_FND) EQ 0) OR
                   (strcmp(ACF2_msgid,ACF2_NOT_FOUND) EQ 0) )
                rc = ESA_ERR;
              else
              {
                rc = ESA_FATAL;
                strcpy(errmsg,"ACF2 Access Error");
              };
              break;

              /***************************************************
              * ACF2 Internal Error situations                   *
              ****************************************************/
     case 8:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Control Block Error");
              break;

              /***************************************************
              * ACF2 Not Active                                  *
              ****************************************************/
     case 12:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Not Active");
              break;

     default: rc = ESA_FATAL;
              strcpy(errmsg,"Internal error in CTS2CMP");
              break;
   };

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/******************************************************************
 * Procedure Name: Delete_Ruleset
 ******************************************************************
 * Description   : Delete ruleset
 *
 * Input         : reskey
 *                 restype
 *                 msgs,dest
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Delete_Ruleset (char                       *reskey,
                        char                       *restype,
                        char                       *errmsg,
                        CTSAMSG_HANDLE_rec_typ     *msgs,
                        CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static         char func[]="Delete_Ruleset";
   ESA_RC         rc = ESA_OK;

   int            rc1 = 0;

   char           delete_operation[] = "DEL";
   char           ACF2_msgid[9];
   char           ACF2_key[ACF2_RESRULE_KEY_SIZE];
   char           init_char = ' ';

   ESA_DIAG_enter(ESA_COMP_DELRES, DEBUG_SHOW_REGULAR, func );

   Reset_Field(errmsg,sizeof(errmsg),0X00,NULL);

   Reset_Field(ACF2_key,sizeof(ACF2_key),init_char,reskey);

   /******************************************************************
   * Delete the ruleset                                              *
   *******************************************************************/
   if (strcmp (restype, "DSN") EQ 0)
   {
     /* SAS2IBMT
     cts2rul(delete_operation,                                       */
     (*(ASM_RTN_TYP *)&cts2rul)                           /* SAS2IBMT */
            (delete_operation,
             ACF2_key,
             NULL,
             NULL,                                        /* WS2333 */
             NULL,
             NULL,
             NULL,
             &rc1,
             errmsg);
   }
   else
   {
     /* SAS2IBMT
     cts2grs(delete_operation,                                       */
     (*(ASM_RTN_TYP *)&cts2grs)                           /* SAS2IBMT */
            (delete_operation,
             ACF2_key,
             restype,
             NULL,
             NULL,                                        /* WS2333 */
             NULL,
             NULL,
             NULL,
             NULL,
             NULL,
             &rc1,
             errmsg);
   };

   ESA_DIAG_printf(ESA_COMP_DELRES, DEBUG_SHOW_IMPORTANT,
                   "rc=(%d) errmsg(%s)",
                   rc1, errmsg);

   switch(rc1)
   {
     case 0:  break;

              /***************************************************
              * ACF2 Access Error situations                     *
              ****************************************************/
     case 4:  strncpy(ACF2_msgid,errmsg,8);
              ACF2_msgid[8] = NULL_CHAR;
              if ( (strcmp(ACF2_msgid,ACF2_ARULE_NOT_FND) EQ 0) OR
                   (strcmp(ACF2_msgid,ACF2_NOT_FOUND) EQ 0) )
                rc = ESA_ERR;
              else
              {
                rc = ESA_FATAL;
                strcpy(errmsg,"ACF2 Access Error");
              };
              break;

              /***************************************************
              * ACF2 Internal Error situations                   *
              ****************************************************/
     case 8:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Control Block Error");
              break;

              /***************************************************
              * ACF2 Not Active                                  *
              ****************************************************/
     case 12:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Not Active");
              break;

     default: rc = ESA_FATAL;
              strcpy(errmsg,"Internal error in CTS2GRS/CTS2RUL");
              break;
   };

   ESA_DIAG_exit(ESA_COMP_DELRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/******************************************************************
 * Procedure Name: Init_ACE_Handle
 ******************************************************************
 * Description   : Initialize ACE handle
 *
 * Input         : handle pointer
 *                 msgs,dest
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Init_ACE_Handle (ACF2_Get_ResACL_Handle     **h,
                         CTSAMSG_HANDLE_rec_typ     *msgs,
                         CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static         char func[]="Init_ACE_Handle";
   ESA_RC         rc = ESA_OK;

   ACF2_Get_ResACL_Handle *handle;

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   /*************************************************************
   * Allocate handle for Get_ACE operation and initialize it    *
   **************************************************************/
   handle = (ACF2_Get_ResACL_Handle *) calloc
    (sizeof(ACF2_Get_ResACL_Handle), 1);

   if (handle EQ NULL)
   {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "ACE HANDLE",
                  sizeof(ACF2_Get_ResACL_Handle));
     rc = ESA_FATAL;
     goto exit;
   };

   handle->First_Call = TRUE;

   handle->Rule_Buffer = (char *) malloc (ACF2_RULE_SOURCE_LENGTH);

   if (handle->Rule_Buffer EQ NULL)
   {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "RULE SOURCE BUFFER",
                  ACF2_RULE_SOURCE_LENGTH);
     rc = ESA_FATAL;
     goto exit;
   };

   handle->Rule_Buffer_Len = ACF2_RULE_SOURCE_LENGTH;

   handle->Current_ACE_Pos = 0;
   handle->Current_ACE_Offset = NULL;

   *h = handle;

   exit:;

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/******************************************************************
 * Procedure Name: Fill_ACE_Keywords
 ******************************************************************
 * Description   : Fill ADDINFO with all ACE keywords
 *
 * Input         : addinfo
 *********************************************************************/
 void Fill_ACE_Keywords (ADDINFO_rec_ptr addinfo)
 {
   static         char func[]="Fill_ACE_Keywords";

   char   empty_value = NULL_CHAR;
   int    i;

   /*************************************************************
   * List of all ACE keywords                                   *
   **************************************************************/
   static KEYWORDS_LIST_typ    ace_keywords[] = {
                                              "POS",       TYPE_1A,
                                              "RESMASK",   TYPE_1A,
                                              "UID",       TYPE_1A,
                                              "VOL",       TYPE_1A,
                                              "SOURCE",    TYPE_1A,
                                              "SHIFT",     TYPE_1A,
                                              "LIB",       TYPE_1A,
                                              "PGM",       TYPE_1A,
                                              "DDN",       TYPE_1A,
                                              "UNTIL",     TYPE_1A,
                                              "FOR",       TYPE_1A,
                                              "ACTIVE",    TYPE_1A,
                                              "NEXTKEY",   TYPE_1A,
                                              "READ",      TYPE_1A,
                                              "WRITE",     TYPE_1A,
                                              "EXEC",      TYPE_1A,
                                              "ALLOC",     TYPE_1A,
                                              "DATA",      TYPE_1A,
                                              "SERVICE",   TYPE_1B,
                                              "ACCESS",    TYPE_1A,
                                              "VERIFY",    TYPE_1A,
                                              "RECCHECK",  TYPE_1A,
                                              "",          TYPE_1A };

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   /*************************************************************
   * Fill ACE addinfo with all the ACE keywords                 *
   **************************************************************/
   i = 0;

   while (ace_keywords[i].keyword[0] NE NULL_CHAR)
   {
     ESA_DIAG_printf(ESA_COMP_UPDRES, DEBUG_SHOW_IMPORTANT,
                    "Insert ACE keyword(%s) type=%d",
                    ace_keywords[i].keyword, ace_keywords[i].type);

     ADDINFO_insert(ace_keywords[i].type,
                    ace_keywords[i].keyword,
                    &empty_value,
                    addinfo,
                    ACF_ADDINFO_KWD_LEN,
                    ACF_ADDINFO_VAL_LEN,
                    UNIQUE);
     i++;
   };

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,ESA_OK);
 }

/******************************************************************
 * Procedure Name: Fill_Res_Keywords
 ******************************************************************
 * Description   : Fill ADDINFO with all resource keywords
 *
 * Input         : addinfo
 *********************************************************************/
 void Fill_Res_Keywords (ADDINFO_rec_ptr addinfo)
 {
   static         char func[]="Fill_Res_Keywords";

   char   empty_value = NULL_CHAR;
   int    i;

   /*************************************************************
   * List of all resource keywords                              *
   **************************************************************/
   static KEYWORDS_LIST_typ    res_keywords[] = {
                                              "MODE",      TYPE_1A,
                                              "OWNER",     TYPE_1A,
                                              "RESOWNER",  TYPE_1A,
                                              "PREFIX",    TYPE_1A,
                                              "RECNAME",   TYPE_1A,
                                              "USERDATA",  TYPE_1A,
                                              "NOSORT",    TYPE_1A,
                                              "CHANGE",    TYPE_1B,
                                              "RCHANGE",   TYPE_1B,
                                              "",          TYPE_1A };

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   /*************************************************************
   * Fill ACE addinfo with all the ACE keywords                 *
   **************************************************************/
   i = 0;

   while (res_keywords[i].keyword[0] NE NULL_CHAR)
   {
     ESA_DIAG_printf(ESA_COMP_UPDRES, DEBUG_SHOW_IMPORTANT,
                    "Insert resource keyword(%s) type=%d",
                    res_keywords[i].keyword, res_keywords[i].type);

     ADDINFO_insert(res_keywords[i].type,
                    res_keywords[i].keyword,
                    &empty_value,
                    addinfo,
                    ACF_ADDINFO_KWD_LEN,
                    ACF_ADDINFO_VAL_LEN,
                    UNIQUE);
     i++;
   };

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,ESA_OK);
 }

/******************************************************************
 * Procedure Name: Prepare_ACF2IN_File
 ******************************************************************
 * Description   : Prepare ACF2IN file for output
 *
 * Input         : msgs,dest
 *
 * Output        : file handle
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Prepare_ACF2IN_File (FILE                      **rule_file,
                             CTSAMSG_HANDLE_rec_typ     *msgs,
                             CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static         char func[]="Prepare_ACF2IN_File";
   ESA_RC         rc = ESA_OK;

   char                        file_name[80];

   ESA_DIAG_enter(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func );

   /*****************************************************************
   * Check ddname existance                                         *
   ******************************************************************/
   /* IS10174
   rc = OS_MVS_ddinfo("ACF2IN  ", file_name, TRUE, dest, msgs);  */
   rc = OS_MVS_ddinfo("ACF2IN  ", file_name, TRUE,       /* IS10174 */
                       dest, msgs, 0);                   /* IS10174 */
   if (rc NE ESA_OK)
   {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                    dest, component,func,
                    "Missing ddname ACF2IN",
                    16,__LINE__);
      goto exit;
   };

   /*****************************************************************
   * Open file for output                                           *
   ******************************************************************/
   /* SAS2IBMT *rule_file = fopen("ACF2IN ", FILE_OPEN_WRITE_TEXT);  */
   /* BS10098 changing the way we open this file
   *rule_file = fopen("DD:ACF2IN", FILE_OPEN_WRITE_TEXT); // SAS2IBMT */
   *rule_file = fopen("DD:ACF2IN", FILE_OPEN_WRITE_BIN_RECFB); /* BS10098 */
   if (*rule_file EQ NULL)
   {
       CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                     "open","TSO services",
                     "ACF2IN  ", strerror(errno));
       rc = ESA_FATAL;
       goto exit;
   };

   exit:;

   ESA_DIAG_exit(ESA_COMP_UPDRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/******************************************************************
 * Procedure Name: ACES_Match
 ******************************************************************
 * Description   : Compare two ACEs and check if they match
 *
 * Input         : ace1
 *                 ace1_addinfo
 *                 ace2
 *                 ace2_addinfo
 *
 * Return Value  : TRUE or FALSE
 *********************************************************************/
 int ACES_Match (ACE_rec_typ        * ace1,
                 ADDINFO_rec_typ    * ace1_addinfo,
                 ACE_rec_typ        * ace2,
                 ADDINFO_rec_typ    * ace2_addinfo)
 {
   static         char func[]="ACES_Match";

   ONE_FIELD_rec_ptr  pair1 = NULL, pair2 = NULL;
   char               work_user_name1[ACF2_UID_SIZE]="";
   char               work_user_name2[ACF2_UID_SIZE]="";
   int                are_equal, i;

   ESA_DIAG_enter(ESA_COMP_UPDACE, DEBUG_SHOW_REGULAR, func );

   are_equal = TRUE;

   if (ace1->ace_type NE ace2->ace_type)
   {
     ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
              "ACE1 ace_type(%d) NE ACE2 ace_type(%d)",   /* IS10178 */
              ace1->ace_type, ace2->ace_type);            /* IS10178 */
     are_equal = FALSE;
     goto exit;
   };

   if (ace1->ace_type EQ ACE_TYPE_WORLD)                  /* PS0250 */
   {                                                      /* PS0250 */
     strcpy (work_user_name1, " ");                       /* PS0250 */
     strcpy (work_user_name2, " ");                       /* PS0250 */
   }                                                      /* PS0250 */
   else if (ace1->ace_type EQ ACE_TYPE_USER)              /* PS0250 */
   {
     Reset_Field(work_user_name1,
                 ACF2_LID_SIZE,
                 ' ',
                 ace1->user_name);

     Reset_Field(work_user_name2,
                 ACF2_LID_SIZE,
                 ' ',
                 ace2->user_name);
   }
   /************ BS10121 remove the following 3 statements **********
   else if (ace1->ace_type EQ ACE_TYPE_GROUP)              * IS10178 *
   {
     strcpy (work_user_name1, ace1->ug_name);              * IS10178 *
     strcpy (work_user_name2, ace2->ug_name);              * IS10178 *
     ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
              "ACE1 ug_name(%s) vs. ACE2 ug_name(%s)",     * IS10178 *
              ace1->ug_name, ace2->ug_name);               * IS10178 *
   } ************* BS10121 end **************************************/
   else
   {
     strcpy (work_user_name1, ace1->user_name);
     strcpy (work_user_name2, ace2->user_name);
   };

   ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                   "ACE1 user/group(%s,%d) ACE2 user/group(%s,%d)",
                   work_user_name1, strlen(work_user_name1),
                   work_user_name2, strlen(work_user_name2));

   if (strlen (work_user_name1) NE strlen (work_user_name2))
   {
     are_equal = FALSE;
     goto exit;
   };

   if (strcmp (work_user_name1, work_user_name2) NE 0)
   {
     are_equal = FALSE;
     goto exit;
   };

   for (i=0; i LT ace1_addinfo->num_pairs; i++)
   {
     pair1 = ADDINFO_get_next(ace1_addinfo, pair1);

     if (pair1 EQ NULL)
       break;

     if (pair1->value[0] NE NULL_CHAR)                    /* PS0251 */
       ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                       "Compare keyword(%s) value(%s)",
                       pair1->keyword, pair1->value);
     else                                                 /* PS0251 */
       ESA_DIAG_printf(ESA_COMP_UPDACE,                   /* PS0251 */
                       DEBUG_SHOW_IMPORTANT,              /* PS0251 */
                       "Compare keyword(%s) value=NULL",  /* PS0251 */
                       pair1->keyword);                   /* PS0251 */

     pair2 = ADDINFO_search (pair1->keyword,
                             ACF_ADDINFO_KWD_LEN,
                             ace2_addinfo->pair,
                             ace2_addinfo->num_pairs);

     if (pair2 NE NULL)                                   /* PS0251 */
     {                                                    /* PS0251 */
       if ((pair1->value[0] EQ NULL_CHAR) AND             /* PS0251 */
           (pair2->value[0] NE NULL_CHAR))                /* PS0251 */
       {
         ESA_DIAG_printf(ESA_COMP_UPDACE,
                         DEBUG_SHOW_IMPORTANT,
                         "ACE1 value is NULL, ACE2 value is not(%s)",
                         pair2->value);

         are_equal = FALSE;
         goto exit;
       };
     };

     if (pair2 EQ NULL)                                   /* PS0251 */
     {                                                    /* PS0251 */
       if (pair1->value[0] NE NULL_CHAR)                  /* PS0251 */
       {
         ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                         "ACE1 value is not NULL, ACE2 value is");

         are_equal = FALSE;
         goto exit;
       };
     }                                                    /* PS0251 */
     else if ((pair1->value[0] NE NULL_CHAR) AND          /* PS0251 */
              (pair2->value[0] EQ NULL_CHAR))             /* PS0251 */
     {
       ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                       "ACE1 value is not NULL, ACE2 value is");

       are_equal = FALSE;                                 /* PS0251 */
       goto exit;                                         /* PS0251 */
     };                                                   /* PS0251 */

     if (pair1->value[0] EQ NULL_CHAR)
       continue;

     ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                     "ACE2 Value=(%s)",
                     pair2->value);

     if (strcmp (pair1->value, pair2->value) NE 0)
     {
       are_equal = FALSE;
       goto exit;
     };
   };

   exit:;

   ESA_DIAG_exit(ESA_COMP_UPDACE, DEBUG_SHOW_REGULAR, func,ESA_OK);

   return are_equal;
 }

/* Beginning of PS0278 */

/******************************************************************
 * Procedure Name: Rule_Backup
 ******************************************************************
 * Description   : Call script to back up rule data
 *
 * Input         : function name
 *                 resource name
 *                 resource type
 *                 admin params
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Rule_Backup (char                  * funcname,
                     char                  * resname,
                     char                  * restype,
                     ADMIN_PARAMS_rec_typ  * admin_params)
 {
   static         char func[]="Rule_Backup";

   ESA_RC                       rc = ESA_OK, output_rc;
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;
   char                         exec_cmd[8192];
   char                         output_buffer[8192];
   char                         parm_get[201];
   short                        output_len;
   int                          tso_rc;
   int                          coff, clen;
   char                         eoddn[9] = EXECOUT_DDNAME; /* IS10174 */

   ESA_DIAG_enter(ESA_COMP_UPDACE, DEBUG_SHOW_REGULAR, func );

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   /*****************************************************************
   * Do we have the RULE_BACKUP flag in RSSPARM ?                   *
   ******************************************************************/

   rc = admin_params ->
    cs_func.rssprm_get_opt_ptr(admin_params -> rss_name,
                               "RULE_BACKUP",
                               sizeof(parm_get),
                               parm_get,
                               OPT_TRUE,
                               OPT_TRUE);

   if (rc EQ ESA_OK)
     if (strcmp (parm_get, "N") EQ 0)
       goto exit;

   /*****************************************************************
   * Build command                                                  *
   ******************************************************************/

   sprintf(exec_cmd,
           "%%CTSBRUL %s %s %s %s %s",                   /* IS10174 */
           eoddn,                                        /* IS10174 */
           funcname,
           admin_params -> admin_uname,
           restype,
           resname);
   /* IS10174    "%%CTSBRUL %s %s %s %s",    */

   ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                   "built command=(%s)",
                   exec_cmd);

   /*****************************************************************
   * Execute script and wait for completion                         *
   ******************************************************************/

   /* IS10174 rc = ESA_CLI_exec_wait(EXECOUT_DDNAME,   */
   rc = ESA_CLI_exec_wait(eoddn,                         /* IS10174 */
                          exec_cmd,
                          &tso_rc,
                          admin_params);                 /* IS10174 */
       /* IS10174         dest,                                     */
       /* IS10174         msgs);                                    */

   ESA_DIAG_printf(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT,
                   "rc from exec=(%d) tso_rc=(%d)", rc, tso_rc);

   /*****************************************************************
   * Check return code and script completion code                   *
   ******************************************************************/

   if (rc EQ ESA_OK)
   {
     if (tso_rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     };
   }
   else
   {
     rc = ESA_FATAL;
     goto exit;
   };

   /*****************************************************************
   * get script output and print it                                 *
   ******************************************************************/

   output_len =  sizeof(output_buffer);
   /* IS10174 output_rc = ESA_CLI_get_output(EXECOUT_DDNAME,   */
   output_rc = ESA_CLI_get_output(eoddn,                 /* IS10174 */
                                  output_buffer,
                                  &output_len,
                                  admin_params);         /* IS10174 */
       /* IS10174                 dest,                             */
       /* IS10174                 msgs );                           */

   if (output_rc EQ ESA_OK)
   {
     for (coff = 0; coff LT output_len; coff += clen )
     {
       clen = strlen (&output_buffer[coff]) + 1;

       /* suppress newline markers */
       if ( (clen GT 2) AND
            (output_buffer[coff+clen-2] EQ '\n') )
         output_buffer[coff+clen-2] = NULL_CHAR;

       CTSAMSG_print(ACF2_OUTPUT_LINE,
                     msgs,
                     NULL,
                     dest,
                     &output_buffer[coff]);

     };
   }
   else
   {
      CTSAMSG_print(ACF2_OUTPUT_ERR, msgs, NULL, dest);
      rc = ESA_FATAL;
   };

   /* IS10174
   output_rc = ESA_CLI_delete_output(EXECOUT_DDNAME, dest, msgs );  */
   output_rc = ESA_CLI_delete_output(eoddn, admin_params); /* IS10174 */

   if (output_rc NE ESA_OK)
      rc = ESA_FATAL;

   exit:;

   ESA_DIAG_exit(ESA_COMP_UPDACE, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
 }

/* End of PS0278 */

 /******************************************************************
 * Procedure Name: Find_Keywords
 *******************************************************************
 * Description   : Find all keywords in rule buffer
 *
 * Input         : buffer        - rule buffer
 *                 start_scan    - address to start scanning from
 *                 msgs,dest
 *
 * Input / Output: addinfo       - addinfo containing all keywords
 *
 * Return Value  : ESA_RC
 *********************************************************************/
static ESA_RC Find_Keywords (ADDINFO_rec_ptr             addinfo,
                             char                       *buffer,
                             char                       *start_scan,
                             CTSAMSG_HANDLE_rec_typ     *msgs,
                             CTSAMSG_DEST_TABLE_rec_typ *dest)
{
   static         char func[]="Find_Keywords";
   ESA_RC         rc = ESA_OK;

   ACF2_Automat_States_Type  curr_state;
   ACF2_Keyword_Type         curr_type;
   ONE_FIELD_rec_ptr         pair = NULL, multi_pair = NULL;

   char msg[256];
   char curr_multi_keyword[ACF_ADDINFO_KWD_LEN+1]="";
   char curr_keyword[ACF_ADDINFO_KWD_LEN+1]="";
   char value[ACF_ADDINFO_VAL_LEN+1]="";
   char *curr_pos, *keyword_start, *buffer_end;
   int   curr_col, curr_line, i, found_non_blank, depth, value_index;

   ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

   depth = 0;
   value_index = 0;
   curr_state = BEFORE_KEYWORD;
   curr_type = REG_KEYWORD;
 /************* WS10058 start ************/
 if (ESA_DIAG_get_debug_level(ESA_COMP_GETRES) GE 6)
  {
    ESA_DIAG_printf(ESA_COMP_GETRES,6,"Find_Keywords Printing addinfo");
    ADDINFO_dump(addinfo,1);
  };
 ESA_DIAG_printf(ESA_COMP_GETRES,6,
                 "start_scan=<%s>",start_scan);
 ESA_DIAG_printf(ESA_COMP_GETRES,6,                       /* WS10075 */
                 "buffer=<%s>",buffer);                   /* WS10075 */
 /************* WS10058 end  ************/

   /*****************************************************************
   * Do we start scanning from beginning of buffer or other point ? *
   ******************************************************************/
   if (start_scan EQ NULL)
   {
     curr_pos = buffer;
     curr_col = 0;
     curr_line = 0;
   }
   else
   {
     curr_pos = start_scan;
     curr_line = (start_scan-buffer) / 80;
     curr_col = (start_scan-buffer) % 80;
     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "Start from Line(%d) Col(%d)",
                     curr_line, curr_col);
   };

   buffer_end = buffer+strlen(buffer);

   while (curr_pos LT buffer_end)
   {
     ESA_DIAG_printf(ESA_COMP_GETRES,6,           /*WS10058*/
                     "State=<%d> col=<%d>,line=<%d> pos=(%c)",
                     curr_state, curr_col, curr_line, *curr_pos);
     switch(curr_state)
     {
       /*************************************************************
       * Handle BEFORE_KEYWORD state                                *
       **************************************************************/
       case BEFORE_KEYWORD:
         if (*curr_pos EQ '-' OR curr_col GT 71)   /* end of line */
         {
           curr_line++;
           curr_col = 0;
           curr_pos = buffer + (curr_line * 80);
         }
         else if (*curr_pos EQ ' ')                /* blank-skip  */
         {
           curr_pos++;
           curr_col++;
         }
         else                                      /* keyword     */
         {
           curr_state = IN_KEYWORD;
           curr_type = REG_KEYWORD;
           keyword_start = curr_pos;
         };
         break;

       /*************************************************************
       * Handle IN_KEYWORD state                                    *
       **************************************************************/
       case IN_KEYWORD:
         if (*curr_pos EQ '$' OR *curr_pos EQ '%')
         {                                       /* skip header */
           curr_pos++;
           curr_col++;
           keyword_start = curr_pos;
         }
         else if (*curr_pos EQ '(')             /* value starts */
         {
           *curr_pos = NULL_CHAR;
           strcpy (curr_keyword, keyword_start);
           ESA_DIAG_printf(ESA_COMP_GETRES,6,           /*WS10058*/
                     "curr_keyword=<%s>",curr_keyword);
           *curr_pos = '(';

           /*  IS10122 - start */
           if ( (strcmp(curr_keyword, "ROLE") EQ 0)  OR
                (strcmp(curr_keyword, "USER") EQ 0) )
           {
             rc = ESA_SKIP;
             goto exit;
           }
           /*  IS10122 - end  */

           pair = NULL;
           pair = ADDINFO_search (curr_keyword,
                                  ACF_ADDINFO_KWD_LEN,
                                  addinfo->pair,
                                  addinfo->num_pairs);

           if (pair EQ NULL)
             goto Unknown_Keyword;

           if (pair->add_typ EQ TYPE_1A)
             curr_type = REG_KEYWORD;
           else
             curr_type = LIST_KEYWORD;
           ESA_DIAG_printf(ESA_COMP_GETRES,6,           /*WS10058*/
                     "curr_type=<%d>",curr_type);

           curr_multi_keyword[0] = NULL_CHAR;
           multi_pair = NULL;
           curr_state = IN_VALUE;
           value_index = 0;
           depth = 1;
           curr_pos++;
           curr_col++;
         }
/* WS10075 else if (*curr_pos EQ ' ')         /@ flag / multi  @/ */
         else if (*curr_pos EQ ' ' OR   /* flag / multi  *//* WS10075*/
                   curr_col GT 71)      /* end of line */  /* WS10075*/
         {
           *curr_pos = NULL_CHAR;
           strcpy (curr_keyword, keyword_start);
           *curr_pos = ' ';

           pair = NULL;

           /*  IS10122 - start */
           if ( (strcmp (curr_keyword, "ROLESET") EQ 0) )
           {
             rc = ESA_SKIP;
             goto exit;
           }
           /*  IS10122 - end  */

           if ( (strcmp (curr_keyword, "ALLOW") EQ 0) OR
                (strcmp (curr_keyword, "LOG") EQ 0) OR
                (strcmp (curr_keyword, "PREVENT") EQ 0))
           {
             pair = ADDINFO_search ("ACCESS",
                                    ACF_ADDINFO_KWD_LEN,
                                    addinfo->pair,
                                    addinfo->num_pairs);

             if (pair EQ NULL)
             {
               sprintf (msg, "ACCESS keyword missing in ADDINFO");
               goto Internal_Error;
             };

             ADDINFO_addval (curr_keyword,
                             ACF_ADDINFO_VAL_LEN,
                             ADDINFO_LIST_ENTRY,
                             pair,
                             dest,
                             msgs);

             curr_multi_keyword[0] = NULL_CHAR;
             multi_pair = NULL;
             curr_state = BEFORE_KEYWORD;
             curr_pos++;
             curr_col++;
             keyword_start = curr_pos;
             curr_type = REG_KEYWORD;
             value_index = 0;
           }
           else
           {
             pair = ADDINFO_search (curr_keyword,
                                    ACF_ADDINFO_KWD_LEN,
                                    addinfo->pair,
                                    addinfo->num_pairs);

             if (pair EQ NULL)
               goto Unknown_Keyword;

             if (pair->add_typ EQ TYPE_1A)
             {
               ADDINFO_addval("Y",               /* flag keyword  */
                              ACF_ADDINFO_VAL_LEN,
                              ADDINFO_LIST_ENTRY,
                              pair,
                              dest,
                              msgs);
               ESA_DIAG_printf(ESA_COMP_GETRES,6,           /*WS10058*/
                     "Setting Y for keyword=<%s>",curr_keyword);

               curr_multi_keyword[0] = NULL_CHAR;
               multi_pair = NULL;
               curr_state = BEFORE_KEYWORD;
               curr_pos++;
               curr_col++;
               keyword_start = curr_pos;
               curr_type = REG_KEYWORD;
               value_index = 0;
             }
             else
             {
               /* Was the previous keyword a MULTI one ? */
               if (curr_multi_keyword[0] NE NULL_CHAR)
               {
                 ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                                 "Compare old(%s) new(%s)",
                                 curr_multi_keyword, curr_keyword);

                 /* Was the previous keyword different ? */
                 if (strcmp (curr_keyword, curr_multi_keyword) NE 0)
                 {
                   ESA_DIAG_printf(ESA_COMP_GETRES,
                                   DEBUG_SHOW_IMPORTANT,
                                   "Insert NULLCHAR to index(%d)",
                                   (value_index-1));

                   value[value_index-1] = NULL_CHAR;

                   if (multi_pair EQ NULL)
                     goto Internal_Error;

                   ADDINFO_addval (value,
                                   ACF_ADDINFO_VAL_LEN,
                                   ADDINFO_LIST_ENTRY,
                                   multi_pair,
                                   dest,
                                   msgs);
                   ESA_DIAG_printf(ESA_COMP_GETRES,6,   /*WS10058*/
                     "Setting value=<%s> for keyword=<%s>",
                     *value,*curr_keyword);

                   multi_pair = pair;
                   value_index = 0;
                   strcpy (curr_multi_keyword, curr_keyword);
                 };
               }
               else
               {
                 value_index = 0;
                 strcpy (curr_multi_keyword, curr_keyword);
                 multi_pair = pair;
               };

               ESA_DIAG_printf(ESA_COMP_GETRES,6,   /*WS10058*/
                  "Multi Keyword");
               curr_type = MULTI_KEYWORD;        /* multi value   */
               curr_state = IN_VALUE;
               depth = 0;
               curr_pos++;
               curr_col++;
             };
           };

           if  (curr_col GT 72) /* end of line ?    */  /* WS10075 */
                                /* 72 becasue curr_col was advanced */
           {                                            /* WS10075 */
             curr_line++;       /* skip to next line */ /* WS10075 */
             curr_col = 0;                              /* WS10075 */
             curr_pos = buffer + (curr_line * 80);      /* WS10075 */
           }                                            /* WS10075 */
         }
         else
         {
           curr_pos++;
           curr_col++;
         };
         break;

       /*************************************************************
       * Handle IN_VALUE state                                      *
       **************************************************************/
       case IN_VALUE:
       /*ESA_DIAG_printf(ESA_COMP_GETRES,6,"IN_VALUE");//WS10058*/
         if (*curr_pos EQ '-' AND curr_col GE 71)
         {                                       /*contd next line*/
           curr_line++;
           curr_col = 0;
           curr_pos = buffer + (curr_line * 80);
         }
         else if (*curr_pos EQ '-')              /* continued ?   */
         {
           found_non_blank = FALSE;              /* check if dash */
           for (i=1; i LT (72-curr_col); i++)    /* is last char  */
           {                                     /* in line       */
             if (*(curr_pos+i) NE ' ')
               found_non_blank = TRUE;
           };

           if (found_non_blank)                  /* not last char */
           {
             value[value_index] = *curr_pos;
             value_index++;
             curr_pos++;
             curr_col++;
           }
           else                                  /*last char-skip */
           {
             curr_line++;
             curr_col = 0;
             curr_pos = buffer + (curr_line * 80);
           };
         }
         else if (*curr_pos EQ ',')              /* LIST value ?  */
         {
           if (curr_type EQ LIST_KEYWORD)
             value[value_index] = ADDINFO_LIST_ENTRY;
           else
             value[value_index] = *curr_pos;

           value_index++;
           curr_pos++;
           curr_col++;
         }
         else if (*curr_pos EQ '(')              /*value has depth*/
         {
           depth++;
           value[value_index] = *curr_pos;
           value_index++;
           curr_pos++;
           curr_col++;
         }
         else if (*curr_pos EQ ')')              /* depth or end ?*/
         {
           depth--;
           if (depth LE 0)                       /* end of value  */
           {
             value[value_index] = NULL_CHAR;
             ESA_DIAG_printf(ESA_COMP_GETRES,6,           /*WS10058*/
               "Adding Value=<%s> to keyword=<%s> in addinfo.",
               value, pair->keyword);

             ADDINFO_addval (value,
                             ACF_ADDINFO_VAL_LEN,
                             ADDINFO_LIST_ENTRY,
                             pair,
                             dest,
                             msgs);

             curr_state = BEFORE_KEYWORD;
             curr_pos++;
             curr_col++;
             value_index = 0;
             multi_pair = NULL;
             curr_multi_keyword[0] = NULL_CHAR;
             keyword_start = curr_pos;
             curr_type = REG_KEYWORD;
           }
           else                                  /* part of value */
           {
             value[value_index] = *curr_pos;
             value_index++;
             curr_pos++;
             curr_col++;
           };
         }
         else if (*curr_pos EQ ' ')              /* end if multi  */
         {
           if (curr_type EQ MULTI_KEYWORD)
           {
             value[value_index] = ADDINFO_LIST_ENTRY;
             curr_state = BEFORE_KEYWORD;
             value_index++;
             curr_pos++;
             curr_col++;
             keyword_start = curr_pos;
           }
           else
           {
             value[value_index] = *curr_pos;
             value_index++;
             curr_pos++;
             curr_col++;
           };
         }
         else
         {
           value[value_index] = *curr_pos;
           value_index++;
           curr_pos++;
           curr_col++;
         };
         break;

       default:
         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                       dest, component,func,
                       "Invalid scan state",
                       16,__LINE__);
         rc = ESA_FATAL;
         goto exit;
     };
   };

   if ( (multi_pair NE NULL) AND
        (curr_multi_keyword[0] NE NULL_CHAR) AND (value_index GT 0) )
   {
     value[value_index-1] = NULL_CHAR;

     ADDINFO_addval (value,
                     ACF_ADDINFO_VAL_LEN,
                     ADDINFO_LIST_ENTRY,
                     multi_pair,
                     dest,
                     msgs);

     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "Final Index=%d Keyword(%s) Value(%s)",
                     value_index-1,
                     multi_pair->keyword,
                     multi_pair->value);
   };

   goto exit;

   Unknown_Keyword:
   sprintf (msg, "Unknown ACF2 keyword : %s", curr_keyword);
   CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                 dest, component,func,msg,
                 16,__LINE__);
   rc = ESA_FATAL;
   goto exit;

   Internal_Error:
   CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                 dest, component,func,
                 "MULTI keyword pair is null",
                 16,__LINE__);
   rc = ESA_FATAL;

   exit:;

   ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_REGULAR, func,rc);

   return rc;
}

 /******************************************************************
 * Procedure Name: Get_Ruleset_Info
 *******************************************************************
 * Description   : Convert ruleset source to addinfo format
 *
 * Input         : buffer        - ruleset source buffer
 *                 buflen        - buffer length
 *                 dest,msgs
 *
 * Output        : addinfo       - resulting ADDINFO struc
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 static ESA_RC Get_Ruleset_Info (char                       *buffer,
                                 int                         buflen,
                                 ADDINFO_rec_ptr             addinfo,
                                 CTSAMSG_HANDLE_rec_typ     *msgs,
                                 CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static         char func[]="Get_Ruleset_Info";
   ESA_RC         rc = ESA_OK;

   ADDINFO_rec_ptr   laddinfo = NULL;
   ONE_FIELD_rec_ptr pair = NULL;
   char              empty_value = NULL_CHAR;

   ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

   if (ADDINFO_alloc(func, ACF2_ADDINFO, &laddinfo, NULL, NULL)
         NE ESA_OK)
   {
      rc = ESA_FATAL;
      goto exit;
   };

   ADDINFO_empty(laddinfo);
   ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                   "Buffer strlen=(%d)", strlen (buffer));

  /*************************************************************
   * Set some non-ACF2 keywords to their default values        *
   *************************************************************/
   ACF2_Set_Keyword_Value ("COPYRES",
                           "N",
                           addinfo,
                           msgs,
                           dest);

   ACF2_Set_Keyword_Value ("RESMODEL",
                           "",
                           addinfo,
                           msgs,
                           dest);

   ADDINFO_copy(laddinfo, addinfo);

  /*************************************************************
   * Insert KEY and TYPE keywords so the rules scanning        *
   * function won't fail on non-ADDINFO-existing ACF2 keywords *
   *************************************************************/
   ADDINFO_insert(TYPE_1A,
                  "KEY",
                  &empty_value,
                  laddinfo,
                  ACF_ADDINFO_KWD_LEN,
                  ACF_ADDINFO_VAL_LEN,
                  UNIQUE);

   ADDINFO_insert(TYPE_1A,
                  "TYPE",
                  &empty_value,
                  laddinfo,
                  ACF_ADDINFO_KWD_LEN,
                  ACF_ADDINFO_VAL_LEN,
                  UNIQUE);

  /*************************************************************
   * Scan the ruleset buffer                                   *
   *************************************************************/
   rc = Find_Keywords (laddinfo,
                       buffer,
                       NULL,
                       msgs,
                       dest);

  /*************************************************************
   * Delete the previously needed ACF2 keywords                *
   *************************************************************/
   ADDINFO_delete(laddinfo, "KEY");
   ADDINFO_delete(laddinfo, "TYPE");

   ADDINFO_empty(addinfo);
   ADDINFO_copy(addinfo, laddinfo);

  /*************************************************************
   * Set the NOSORT flag to 'N' if it didn't appear in rule    *
   *************************************************************/
   pair = ADDINFO_search("NOSORT",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs);

   if (pair NE NULL)
     if (pair->value[0] EQ NULL_CHAR)
       ADDINFO_updval("N", ACF_ADDINFO_VAL_LEN, pair);

   exit:

   if (laddinfo NE NULL)
    ADDINFO_free(&laddinfo);

   ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,rc);
   return rc;
}

 /******************************************************************
 * Procedure Name: Get_Rule_Mod_Data
 *******************************************************************
 * Description   : Get rule-last-modified date and user
 *
 * Input         : buffer        - ruleset source buffer
 *
 * Output        : addinfo       - resulting ADDINFO struc
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 static ESA_RC Get_Rule_Mod_Data (char                       *buffer,
                                  ADDINFO_rec_ptr             addinfo,
                                  CTSAMSG_HANDLE_rec_typ     *msgs,
                                  CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static            char func[]="Get_Rule_Mod_Data";
   ESA_RC            rc = ESA_FATAL;

   char              Date_Pattern[9]="";
   char              ESS_Date[9]="";
   char              full_date[15]="";
   char              oldval;

   char             *pos, *pos2;

   ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

   Global_ACF2_Date_Format(Date_Pattern);

   ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                   "Date pattern=(%s)", Date_Pattern);

  /*************************************************************
   * Extract user from output buffer                           *
   *************************************************************/
   pos = strstr (buffer, "STORED BY");

   if (pos EQ NULL)
     goto exit;

   pos = pos + 10;

   pos2 = strchr (pos, ' ');

   if ( (pos2 EQ NULL) OR (pos2-pos GT ACF2_LID_SIZE-1) )
     goto exit;

   oldval = *pos2;
   *pos2 = NULL_CHAR;

   ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                   "Extracted USER=(%s)", pos);

   ACF2_Set_Keyword_Value ("DATEUSER",
                           pos,
                           addinfo,
                           msgs,
                           dest);

  /*************************************************************
   * Extract date from output buffer                           *
   *************************************************************/
   *pos2 = oldval;

   pos = pos2 + 4;
   pos2 = pos + 8;

   oldval = *pos2;
   *pos2 = NULL_CHAR;

   ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                   "Extracted DATE=(%s)", pos);

  /*************************************************************
   * Convert date to ESS format                                *
   *************************************************************/
   CTSCDAT_conv2ESS (ESA_COMP_GETRES,
                     Date_Pattern,
                     pos, ESS_Date,
                     dest, msgs);

   ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                   "Converted DATE=(%s)", ESS_Date);

  /*************************************************************
   * Extract time from output buffer                           *
   *************************************************************/
   *pos2 = oldval;

   pos = pos2 + 1;
   pos2 = pos + 2;

   oldval = *pos2;
   *pos2 = NULL_CHAR;

   strcpy (full_date, ESS_Date);
   strcat (full_date, pos);

   *pos2 = oldval;

   pos = pos2 + 1;
   pos2 = pos + 2;

   oldval = *pos2;
   *pos2 = NULL_CHAR;

   strcat (full_date, pos);
   strcat (full_date, "00\0");

   *pos2 = oldval;

   ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                   "Full date=(%s)", full_date);

   ACF2_Set_Keyword_Value ("DATELAST",
                           full_date,
                           addinfo,
                           msgs,
                           dest);

   rc = ESA_OK;

   exit:

   ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,rc);
   return rc;
}

 /******************************************************************
 * Procedure Name: ACF2_Set_Keyword_Value
 *******************************************************************
 * Description   : Set value of an existing keyword
 *
 * Input         : keyword
 *                 value
 *                 msgs, dest
 *
 * Input / Output: addinfo
 *********************************************************************/
void ACF2_Set_Keyword_Value (char                       *keyword,
                             char                       *value,
                             ADDINFO_rec_ptr            addinfo,
                             CTSAMSG_HANDLE_rec_typ     *msgs,
                             CTSAMSG_DEST_TABLE_rec_typ *dest)
{

   ONE_FIELD_rec_ptr pair = NULL;

   pair = ADDINFO_search(keyword, ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs);

   if (pair NE NULL)
     ADDINFO_updval(value, ACF_ADDINFO_VAL_LEN, pair);

 }

 /******************************************************************
 * Procedure Name: ACF2_Filter_ADDINFO
 *******************************************************************
 * Description   : Filter keywords according to resource type
 *
 * Input         : restype    - resource type
 *
 * Input / Output: addinfo
 *********************************************************************/
 void ACF2_Filter_ADDINFO (char           *restype,
                           ADDINFO_rec_ptr addinfo)
{
   static            char func[]="ACF2_Filter_ADDINFO";

   ESA_DIAG_enter(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT, func );

   if (strcmp (restype, "DSN") EQ 0)
     ADDINFO_delete(addinfo, "RECCHECK");
   else
   {
     ADDINFO_delete(addinfo, "VOL");
     ADDINFO_delete(addinfo, "LIB");
     ADDINFO_delete(addinfo, "PGM");
     ADDINFO_delete(addinfo, "DDN");
   };

   ESA_DIAG_exit(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT, func,ESA_OK);
 }

 /******************************************************************
 * Procedure Name: Check_ACE_UNTIL
 *******************************************************************
 * Description   : Check that the UNTIL keyword of an ACE is valid
 *
 * Input         : addinfo - ACE addinfo
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 ESA_RC Check_ACE_UNTIL(ADDINFO_rec_ptr addinfo)
 {
   static            char func[]="Check_ACE_UNTIL";

   ESA_RC            rc = ESA_OK;
   ONE_FIELD_rec_ptr pair = NULL;
   time_t            ltime;
   struct tm        *tm_ptr;
   char              local_date[9]="";

   ESA_DIAG_enter(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT, func );

   pair = ADDINFO_search("UNTIL", ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs);

   if (pair EQ NULL)
     goto exit;

   if (strlen(pair->value) NE 8)
     goto exit;

   time(&ltime);
   tm_ptr = localtime(&ltime);

   sprintf (local_date, "%04d%02d%02d",
            (tm_ptr->tm_year+1900),
            (tm_ptr->tm_mon+1),
            tm_ptr->tm_mday);

   if (strcmp (pair->value, local_date) LT 0)
     rc = ESA_FATAL;

   exit:;

   ESA_DIAG_exit(ESA_COMP_UPDACE, DEBUG_SHOW_IMPORTANT, func, rc);

   return rc;
 }

 /* WS2333 - Modified:
  * Function does not shift records in buffer. Instead, it returns
  * a new pointer to data within the buffer, and new buffer length */
 /******************************************************************
 * Procedure Name: Filter_Rule_Records
 *******************************************************************
 * Description   : Filter non interesting records
 *
 * Input         : ret_type   - return ruleset header or
 *                              ruleset entries
 *                 buffer     - rule source buffer
 *                 buflen     - rule source buffer length
 *
 * Output        : recbuff    - records buffer
 *                 recbufflen - records buffer length
 *
 * Return Value  : ESA_RC
 *********************************************************************/
static ESA_RC Filter_Rule_Records (ACF2_Resource_Data_Type ret_type,
                                   char                   *buffer,
                                   int                     buflen,
                                   char                  **recbuff,
                                   int                    *recbufflen)
{
   static            char func[]="Filter_Rule_Records";

   ESA_RC            rc = ESA_OK;
   char             *pos, *bufend;
   int               new_size, line_continued, control_line;

   ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

   *recbuff = NULL;

   if (ret_type EQ ACF2_Return_Ruleset)
   {
     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "Return only ruleset header records");

     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "Buffer len=(%d)", strlen(buffer));

     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "recbuff ptr(%X)",
                     recbuff);

     pos = strstr(buffer, "$KEY(");

     if (pos EQ NULL)
     {
       rc = ESA_FATAL;
       goto exit;
     };

     *recbuff = pos;

     new_size = 80;

     pos = pos + 80;

     bufend = buffer + buflen;

     line_continued = FALSE;

     while (pos LT bufend)
     {
       if (line_continued)
       {
         if (NOT Is_Line_Continued(pos))
           line_continued = FALSE;

         new_size = new_size + 80;
         pos = pos + 80;
         continue;
       };

       if (*pos EQ '$' OR *pos EQ '%')
       {
         if (Is_Line_Continued(pos))
           line_continued = TRUE;

         new_size = new_size + 80;
       }
       else
         break;

       pos = pos + 80;
     };

     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "filtered size(%d) end_addr(%X)",
                     new_size,
                     (*recbuff)+new_size);

     *recbufflen = new_size;

     if (*recbuff NE NULL)
       (*recbuff)[new_size] = NULL_CHAR;
   }
   else
   {
     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "Return only ruleset entries");

     ESA_DIAG_printf(ESA_COMP_GETRES,DEBUG_SHOW_IMPORTANT,
                     "Buffer len=(%d)", strlen(buffer));

     pos = strstr(buffer, "$KEY(");

     if (pos EQ NULL)
     {
       rc = ESA_FATAL;
       goto exit;
     };

     new_size = 0;

     pos = pos + 80;

     bufend = buffer + buflen;

     line_continued = FALSE;
     control_line = FALSE;

     while (pos LT bufend)
     {
       if (NOT line_continued AND NOT control_line)
       {
         if (*pos EQ '$' OR *pos EQ '%')
         {
           if (Is_Line_Continued(pos))
           {
             control_line = TRUE;
             pos = pos + 80;
             continue;
           };
         }
         else
         {
           if (new_size EQ 0)
             *recbuff = pos;

           new_size = new_size + 80;

           if (Is_Line_Continued(pos))
             line_continued = TRUE;

           pos = pos + 80;
           continue;
         };
       };

       if (control_line)
       {
         if (NOT Is_Line_Continued(pos))
           control_line = FALSE;
         pos = pos + 80;
         continue;
       };

       if (line_continued)
       {
         if (NOT Is_Line_Continued(pos))
           line_continued = FALSE;

         new_size = new_size + 80;
       };

       pos = pos + 80;
     };

     *recbufflen = new_size;

     if (*recbuff NE NULL)
       (*recbuff)[new_size] = NULL_CHAR;
   };

   exit:

   ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,rc);

   return rc;
}

/**************************************************************
*                                                             *
* PROCEDURE NAME : Get_Dsn_Output                             *
*                                                             *
* DESCRIPTION    : Obtain shell output from last command to   *
*                  a supplied buffer                          *
*                                                             *
* INPUT          : ddn              -  DDN of file            *
*                  p_buff           -  buffer address         *
*                  p_len            -  buffer length          *
*                  dest             -  destinations table     *
*                  msgs             -  messages buffer        *
*                                                             *
* OUTPUT         :                                            *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
static ESA_RC Get_Dsn_Output(char                       * ddn,
                             char                       * p_buff,
                             int                        * p_len,
                             CTSAMSG_DEST_TABLE_rec_ptr   dest,
                             CTSAMSG_HANDLE_rec_ptr       msgs )
{

  static char func[] = "Get_Dsn_Output";

 /* Variables */

  ESA_RC output_rc ;
  int    coff = 0 ;
  int    clen;
  int    cleft;
  char   line[81];
  char   file_name[80];
  FILE   *shell_output_file = NULL;

 /*
  *   Initialization
  */

  ESA_DIAG_enter(PLT_COMP_API_ACF2, 1, func );
  ESA_DIAG_printf(PLT_COMP_API_ACF2, 1, "Buffer at %X length %d",
                  p_buff, *p_len );

 /*
  *   Check ddname existance
  */
  /* IS10174
  output_rc = OS_MVS_ddinfo(ddn, file_name, TRUE, dest, msgs);  */
  output_rc = OS_MVS_ddinfo(ddn, file_name, TRUE,        /* IS10174 */
                            dest, msgs, 0);              /* IS10174 */
  if ( output_rc NE ESA_OK ) {
     *p_len = 0;
     goto exit;
  }

 /* SAS2IBMN
  *
  *   Check output file existance
  *

  if ( access(ddn, 0) NE 0) {
     *p_len = 0;
     output_rc = ESA_OK;
     goto exit;
  }
  */

 /*
  *   Open shell output file
  */

  /* place DD: into new variable, move ddn into new variable+3,
     and call fopen with this new variable                   SAS2IBMT */
  memset(file_name, '\0', sizeof(file_name));             /* SAS2IBMT */
  strcpy(file_name,"DD:");                                /* SAS2IBMT */
  strcpy(file_name+3,ddn);                                /* SAS2IBMT */

  /* SAS2IBMT shell_output_file = fopen( ddn, FILE_OPEN_READ_BINARY); */
  shell_output_file = fopen(file_name, FILE_OPEN_READ_BINARY);
  if (shell_output_file EQ NULL) {
      CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                    "open","TSO services",
                    ddn, strerror(errno));
      output_rc = ESA_FATAL;
      goto exit;
  }

 /* SAS2IBMN - start */
 /* Verify that the file is not empty (as done by SAS/C access() ) */
  clen = fread(line, 1, 80, shell_output_file);

  if ( feof(shell_output_file) )  /* check if file is empty */
  {
     *p_len = 0;
     output_rc = ESA_OK;
     goto exit;
  }
 /* SAS2IBMN - end */

 /*
  *   Copy shell output to buffer
  */

  cleft = *p_len - 1;  /* one character reserved for overflow */
  *p_len = 0;
  coff  = 0 ;

  /* SAS2IBMN clen = fread(line, 1, 80, shell_output_file); */
  line[clen] = NULL_CHAR;

  while (  (cleft GT 0) AND (feof(shell_output_file) EQ 0) ) {

     /* check i/o errors */

     if (ferror(shell_output_file)) {
        CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                      "get","TSO services",
                      ddn, strerror(errno) );
        output_rc = ESA_FATAL;
        goto exit;
     }

     /* copy output line (ignore the first ready prompt) */

     clen = strlen(line);
     if (clen GT cleft)
        clen = cleft;
     memcpy(p_buff+coff, line, clen);
     cleft -= clen;
     coff += clen;

     ESA_DIAG_printf(PLT_COMP_API_ACF2, 3,
                        "Read %d chars, next %d left %d",
                        clen, coff, cleft );

     /* next output line */

     clen = fread(line, 1, 80, shell_output_file);
     line[clen] = NULL_CHAR;

  } /* while */

  p_buff[coff] = NULL_CHAR;

  *p_len = coff;
  ESA_DIAG_printf(PLT_COMP_API_ACF2, 1,
                  "Buffer filled with %d chars", *p_len );

  output_rc = ESA_OK;

 /*
  *   Termination
  */

  exit: ;

  if (shell_output_file NE NULL)
     fclose(shell_output_file);

  ESA_DIAG_exit(PLT_COMP_API_ACF2, 1, func, output_rc);

  return output_rc;

}

 /******************************************************************
 * Procedure Name: Get_Rule_Entry_Info
 *******************************************************************
 * Description   : Convert rule entry data to addinfo format
 *
 * Input         : handle        - Get_ResACL_Handle
 *                 ace           - ace params
 *                 dest,msgs
 *
 * Input / Output: addinfo       - resulting ADDINFO struc
 *
 * Return Value  : ACF2_OK             - returned ace
 *                 ACF2_Not_Found      - no more aces
 *                 ACF2_Internal_Error - internal error
 *********************************************************************/
static ACF2_API_Return_Codes Get_Rule_Entry_Info(
                                   ACF2_Get_ResACL_Handle     *h,
                                         ACE_rec_typ          *ace,
                                         ADDINFO_rec_ptr       addinfo,
          /* IS10122 */                  char                 *errmsg,
                                   CTSAMSG_HANDLE_rec_typ     *msgs,
                                   CTSAMSG_DEST_TABLE_rec_typ *dest)
{
  static char func[] = "Get_Rule_Entry_Info";
  ACF2_API_Return_Codes rc = ACF2_OK;

  ESA_RC            arc;

  static KEYWORDS_LIST_typ date_keywords[] = {
                                             "UNTIL",   TYPE_1A,
                                             "ACTIVE",  TYPE_1A,
                                             "",        TYPE_1A };

  char              full_access_name[20]="";
  char              actual_user_name[ACF2_LID_SIZE]="";
  char             *curr_ace, *resmask_end = NULL;
  char             *curr_ace_end;
  char              Date_Pattern[9]="";
  char              ESS_Date[9]="";
  char              sep[3], kept_value;
  char              keyword_match[80];
  char              resource_mask[ACF_RESOURCE_NAME_LEN+1]="";
  ONE_FIELD_rec_ptr pair = NULL;
  int               i, j, increased_pos;
  int               LID_In_UID, LID_Offset, LID_Length;   /* IS10178 */

  ESA_DIAG_enter(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT, func );

  BUILD_STRING_SEPARATOR(sep, ',');

  Global_ACF2_Date_Format(Date_Pattern);

  increased_pos = FALSE;

  curr_ace_end = NULL;

  errmsg[0] = NULL_CHAR;                                  /* IS10122 */

  ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                  "Rule buff len=(%d) curr ACE pos=(%d)",
                  h->Records_Buffer_Len,                  /* WS2333 */
                  h->Current_ACE_Pos);

  /*************************************************************
   * Locate current ACE                                        *
   *************************************************************/
   if (h->Current_ACE_Offset EQ NULL)
     curr_ace = h->Records_Buffer;                        /* WS2333 */
   else
     curr_ace = (Locate_ACE_End (h->Current_ACE_Offset))+1;

   if (curr_ace GE (h->Records_Buffer+h->Records_Buffer_Len))
                                                          /* WS2333 */
   {
     rc = ACF2_Not_Found;
     goto exit;
   };

   h->Current_ACE_Offset = curr_ace;

  if (ESA_DIAG_get_debug_level(ESA_COMP_GTRSACL) GE DEBUG_SHOW_ALL)
  {
    SNAP_AREA( "curr ACE 1st line", curr_ace, 80)
  };

  /*************************************************************
   * Get end offset of current ACE                             *
   *************************************************************/
   curr_ace_end = Locate_ACE_End (curr_ace);
   kept_value = *curr_ace_end;
   *curr_ace_end = NULL_CHAR;

  /*************************************************************
   * Initialize ace params                                     *
   *************************************************************/
  ace->ug_name[0] = NULL_CHAR;
  ace->oe_name[0] = NULL_CHAR;
  ace->ace_attrs = ACE_ATTR_REGULAR;

  /*************************************************************
   * Set the RESMASK keyword of the ACE addinfo                *
   *************************************************************/
   arc = Get_ACE_Resmask (h,
                          curr_ace,
                          resource_mask,
                          &resmask_end,
                          msgs,
                          dest);

   if (arc NE ESA_OK)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                   dest, component,func,
                   "Resource/Dsn mask extraction failed",
                   16,__LINE__);
     rc = ACF2_Internal_Error;
     goto exit;
   };

   if (resource_mask[0] NE NULL_CHAR)
    ACF2_Set_Keyword_Value ("RESMASK",
                            resource_mask,
                            addinfo,
                            msgs,
                            dest);
   else
     ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                     "No resource mask");

   ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                   "Resmask end(%X)", resmask_end);

  /*************************************************************
   * Handle all ADDINFO keywords                               *
   *************************************************************/
   arc = Find_Keywords (addinfo,
                        curr_ace,
                        resmask_end,
                        msgs,
                        dest);

   if (arc NE ESA_OK)
   {
     /* IS10122 - start */
     if (arc EQ ESA_SKIP)
     {
       rc = ACF2_Not_Found;
       strcpy(errmsg, ACF2_ROLESET_IGNORED_MSG);
     }
     else
     /* IS10122 - end */
       rc = ACF2_Internal_Error;
     goto exit;
   };

  /***************************************************************
   * ACCESS must have value. default = PREVENT                   *
   ***************************************************************/
  /* ******* ******* ******* WS10075 start ******* ******* *******/
  /* We will no longer make any changes to these keywords:       */
  /* ACCESS                                                      */
  /* VERIFY                                                      */
  /* SERVICE                                                     */
  /* READ                                                        */
  /* WRITE                                                       */
  /* EXEC                                                        */
  /* ALLOC                                                       */
  /* UNTIL                                                       */
  /* ACTIVE                                                      */
  /* We will comment-out the next 125 (give or take) lines. . . .*/
  /*
   pair = ADDINFO_search("ACCESS",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs);

   // WS10058 try without a mandatory value for access
   if (pair NE NULL)
     if (pair->value[0] EQ NULL_CHAR)
       ADDINFO_updval("PREVENT", ACF_ADDINFO_VAL_LEN, pair); //

   ***************************************************************
   * VERIFY keyword must be Y or N                               *
   ***************************************************************
   pair = ADDINFO_search("VERIFY",
                         ACF_ADDINFO_KWD_LEN,
                         addinfo->pair,
                         addinfo->num_pairs);

   // WS10058 try without a mandatory value for verify
   if (pair NE NULL)
     if (pair->value[0] EQ NULL_CHAR)
       ADDINFO_updval("N", ACF_ADDINFO_VAL_LEN, pair); //

   ***************************************************************
   * For SERVICE we convert a full list to the ALL value         *
   ***************************************************************
   pair = ADDINFO_search ("SERVICE",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

   if (pair NE NULL)
     if ( (strstr (pair->value, "READ") NE NULL) AND
          (strstr (pair->value, "ADD") NE NULL) AND
          (strstr (pair->value, "UPDATE") NE NULL) AND
          (strstr (pair->value, "DELETE") NE NULL) )
       ADDINFO_updval("ALL", ACF_ADDINFO_VAL_LEN, pair);
   // Removed by BS2409
     else if (pair->value[0] EQ NULL_CHAR)
       ADDINFO_updval("ALL", ACF_ADDINFO_VAL_LEN, pair);
   //
     else;

   ***************************************************************
   * For READ, WRITE, EXEC and ALLOC we convert the one-char     *
   * values to longer ones.                                      *
   ***************************************************************
   for (i=0; i LT 4; i++)
   {
     pair = ADDINFO_search ((char *)&access_keywords[i],
                            ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);

     if (pair EQ NULL)
       continue;

     if (pair->value[0] NE NULL_CHAR)
     {
       switch (pair->value[0])
       {
         case 'A':
           strcpy (full_access_name, "ALLOW");
           break;
         case 'L':
           strcpy (full_access_name, "LOG");
           break;
         case 'P':
           strcpy (full_access_name, "PREVENT");
           break;
         default:
           CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                         dest, component,func,
                         "Unknown resource access type",
                         16,__LINE__);
           rc = ACF2_Internal_Error;
           goto exit;
       };

       ADDINFO_updval(full_access_name,
                      ACF_ADDINFO_VAL_LEN,
                      pair);
     }
   // WS10058 try without PREVENT default
     else
     {
       ADDINFO_addval("PREVENT",
                      ACF_ADDINFO_VAL_LEN,
                      ADDINFO_LIST_ENTRY,
                      pair,
                      dest,
                      msgs);
     };      end of WS10058    //
   };

   *****************************************************************
   * For UNTIL and ACTIVE we have to convert the dates             *
   *****************************************************************
   for (i=0; i LT 2; i++)
   {
     pair = ADDINFO_search ((char *)&date_keywords[i],
                            ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);

     if (pair EQ NULL)
       continue;

     if (pair->value[0] EQ NULL_CHAR)
       continue;

     *****************************************************************
     * Convert date to ESS format                                    *
     *****************************************************************
     CTSCDAT_conv2ESS (PLT_COMP_API_ACF2,
                       Date_Pattern,
                       pair->value,
                       ESS_Date,
                       dest, msgs);

     ADDINFO_updval(ESS_Date,
                    ACF_ADDINFO_VAL_LEN,
                    pair);
   };
  /* ******* ******* ******* WS10075  end  ******* ******* *******/

  /*************************************************************
   * Get the UIDMASK which is the ACE mask name                *
   *************************************************************/
   pair = ADDINFO_search ("UID",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

   if (pair EQ NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                   dest, component,func,
                   "UID keyword is missing in ADDINFO",
                   16,__LINE__);
     rc = ACF2_Internal_Error;
     goto exit;
   };

   if (pair->value[0] EQ NULL_CHAR)
   {
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                   dest, component,func,
                   "Invalid NULL UIDMASK",
                   16,__LINE__);
     rc = ACF2_Internal_Error;
     goto exit;
   };

   strcpy (ace->user_name, pair->value);

  /*************************************************************
   * Is this ACE type MASK, USER or WORLD ?                    *
   *************************************************************/
   /* WS10060 allow UIDMASK=*
   if (strcmp (ace->user_name, "*") EQ 0)                  * PS0250 *
   {                                                       * PS0250 *
     ace->user_name[0] = NULL_CHAR;                        * PS0250 *
     ace->ace_type = ACE_TYPE_WORLD;                       * PS0250 *
   }                                                       * PS0250 *
   else *** end of WS10060 */                             /* PS0250 */
   if (Is_UIDMASK_User (ace->user_name))                  /* PS0250 */
   {

     ESA_DIAG_printf(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT,
         "UIDMASK is user |%s|", ace->user_name);         /* IS10178 */

     ace->ace_type = ACE_TYPE_USER;

     /*************************************************************/
     /* * * * * * * * * * * IS10178 start * * * * * * * * * * * * */
     /*************************************************************/
     /* The old code in this routine assumed that the LID resides
        in the right-most part of the UID. This new code makes no
        assumptions about the LID at all.  The LID can be anywhere
        in the UID and can be any length.  These are the 3
        possibilities:
          1. LIDxxxxx | RightPartOfUID
          2. LeftPartOfUID | LIDxxxxx | RightPartOfUID
          3. LeftPartOfUID | LIDxxxxx

        The following 15+ lines of code is commented out and is
        replaced by code marked IS10178 several lines down.       */
     /*************************************************************/
     /* * * * * * * * * * * IS10178  end  * * * * * * * * * * * * */
     /*************************************************************/
     /* IS10178
     j = 0;
     i = 0;
     while ( i LT (ACF2_LID_SIZE-1) )
     {
       if (ace->user_name[j] NE '*')
       {
         actual_user_name[i] = ace->user_name[j];
         i++;
       };

       j++;

       if (j GE strlen(ace->user_name))
         break;
     };

     actual_user_name[i] = NULL_CHAR;
                                                                     */
     /*************************************************************/
     /* * * * * * * * * * * IS10178 start * * * * * * * * * * * * */
     /*************************************************************/
     LID_In_UID = ACF2_Is_LID_In_UID(&LID_Offset, &LID_Length);
                                    /* get LID_Offset and LID_Length */

     ESA_DIAG_printf(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT,
         "LID_In_UID = %s, LID_Offset = %d, LID_Length = %d",
         LID_In_UID ? "TRUE" : "FALSE", LID_Offset, LID_Length);
     memset (actual_user_name, 0X00, sizeof(actual_user_name));
                                           /* prepare to extract lid */
     strncpy (actual_user_name, ace->user_name+LID_Offset, LID_Length);
                                                      /* extract lid */
     /*************************************************************/
     /* * * * * * * * * * * IS10178  end  * * * * * * * * * * * * */
     /*************************************************************/
     strcpy (ace->user_name, actual_user_name);

     ESA_DIAG_printf(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT,
         "ace->user_name |%s|", ace->user_name);          /* IS10178 */
   }
   else
   {
   /* IS10178 changing ace_type to ACE_TYPE_GROUP and then
              place the full UID into the ace's ug_name field
     ace->ace_type = ACE_TYPE_MASK;                                  */
     /*ace->ace_type = ACE_TYPE_GROUP;     /* IS10178        BS10121*/
     ace->ace_type = ACE_TYPE_MASK;                       /* BS10121*/
     /*strcpy (ace->ug_name, pair->value); /*IS10178         BS10121*/
     /*ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,IS10178 *
     /*BS10121       "ACE ug_name=(%s)", ace->ug_name);    * IS10178 */
   }

   ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                   "ACE UIDMASK=(%s)", ace->user_name);

  /*************************************************************
   * Set the POS keyword of the ACE addinfo to the ACE position*
   *************************************************************/
  h->Current_ACE_Pos++;

  increased_pos = TRUE;

  sprintf (keyword_match, "%d", h->Current_ACE_Pos);

  ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                  "ACE pos value=(%s)", keyword_match);

  ACF2_Set_Keyword_Value ("POS",
                          keyword_match,
                          addinfo,
                          msgs,
                          dest);

  exit:;

  if (curr_ace_end NE NULL)
    *curr_ace_end = kept_value;

  if (NOT increased_pos)
    h->Current_ACE_Pos++;

  ESA_DIAG_exit(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT, func,rc);

  return rc;
}

 /******************************************************************
 * Procedure Name: Get_ACE_Resmask
 *******************************************************************
 * Description   : Retrieve current ACE's resource mask
 *
 * Input         : handle        - Get_ResACL_Handle
 *                 curr_ace      - current ACE offset
 *                 msgs,dest
 *
 * Output        : resmask       - ACE's resource mask
 *                 resmask_end   - resource mask end address
 *
 * Return Value  : ESA_RC
 *********************************************************************/
static ESA_RC Get_ACE_Resmask (ACF2_Get_ResACL_Handle   *h,
                               char                     *curr_ace,
                               char                     *resmask,
                               char                    **resmask_end,
                               CTSAMSG_HANDLE_rec_typ   *msgs,
                               CTSAMSG_DEST_TABLE_rec_typ *dest)
{
   static            char func[]="Get_ACE_Resmask";

   ESA_RC            rc = ESA_OK;

   char   *pos, *line_end, *start_col, *first_parent;
   char    kept_value;
   int     first_line;

   ESA_DIAG_enter(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT, func );

   kept_value = NULL_CHAR;

   pos = curr_ace;

   line_end = pos+79;
   kept_value = *line_end;
   *line_end = NULL_CHAR;

   first_parent = strchr (pos+1, '(');
   if (first_parent NE NULL)
   {
     if ( (strchr (pos+1, ' ') EQ NULL) OR
          (strchr (pos+1, ' ') GT first_parent) )
     {
       *resmask = NULL_CHAR;
       goto exit;
     };
   };

   first_line = TRUE;

   while (Is_Line_Continued(pos))
   {
     start_col = pos;

     if (first_line)
       start_col = pos + 1;

     if (strchr (start_col, ' ') NE NULL)
       break;

     if (first_line)
       strncat (resmask, start_col, 70);
     else
       strncat (resmask, start_col, 71);

     first_line = FALSE;

     ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                     "Line continued. Mask so far(%s)", resmask);

     *line_end = kept_value;
     pos = pos + 80;
     line_end = pos+79;
     kept_value = *line_end;
   };

   if (first_line)
     *resmask_end = strchr (pos+1, ' ');
   else
     *resmask_end = strchr (pos, ' ');

   if (*resmask_end EQ NULL)
   {
     rc = ESA_FATAL;
     goto exit;
   };

   **resmask_end = NULL_CHAR;

   if (first_line)
     strcat (resmask, pos+1);
   else
     strcat (resmask, pos);

   **resmask_end = ' ';

   ESA_DIAG_printf(ESA_COMP_GTRSACL,DEBUG_SHOW_IMPORTANT,
                   "Last line. Mask(%s) End(%x)",
                   resmask, *resmask_end);

   exit:;

   if (kept_value NE NULL_CHAR)
     *line_end = kept_value;

   ESA_DIAG_exit(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT, func,rc);

   return rc;
}

 /******************************************************************
 * Procedure Name: Locate_ACE_End
 *******************************************************************
 * Description   : Return end offset of current ACE
 *
 * Input         : curr_ace      - current ACE offset
 *
 * Return Value  : curr_ace_end
 *********************************************************************/
static char * Locate_ACE_End (char *curr_ace)
{
   static            char func[]="Locate_ACE_End";

   char              *curr_ace_end = NULL;
   char              curr_line[81];

   ESA_DIAG_enter(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT, func );

   curr_line[79] = NULL_CHAR;
   curr_line[80] = NULL_CHAR;

   curr_ace_end = curr_ace;

   strncpy (curr_line, curr_ace_end, 80);

   while (Is_Line_Continued(curr_line))
   {
     curr_ace_end = curr_ace_end + 80;
     strncpy (curr_line, curr_ace_end, 80);
   };

   curr_ace_end = curr_ace_end + 79;

   ESA_DIAG_exit(ESA_COMP_GTRSACL, DEBUG_SHOW_IMPORTANT, func,ESA_OK);

   return curr_ace_end;
}

 /* WS2333 */
 /******************************************************************
 * Procedure Name: Get_NEXTKEYs
 *******************************************************************
 * Description   : Recursive function to return list of nextkeys
 *
 * Input         : resname        - resource name
 *                 restype        - resource type
 *                 depth          - search depth
 *                 srcbuff        - NULL of rule source buffer
 *                 srcbuff_len    - 0 or rule source buffer length
 *                 print_depth    - depth to print in messages
 *                 print_msg      - TRUE = print messages
 *                 originator     - original resource
 *                 msgs,dest
 *
 * Input/Output  : nextkeys_list  - nextkeys list pointer
 *                 nextkeys_size  - size of nextkeys buffer
 *                 tot_nextkeys   - total number of nextkeys found
 *
 * Return Value  : ESA_RC
 *********************************************************************/
static ESA_RC Get_NEXTKEYs (char                        *resname,
                            char                        *restype,
                            int                          depth,
                            char                       **nextkeys_list,
                            int                         *nextkeys_size,
                            char                        *srcbuff,
                            int                          srcbuff_len,
                            int                          print_depth,
                            int                          print_msg,
                            int                         *tot_nextkeys,
                            char                        *originator,
                            CTSAMSG_HANDLE_rec_typ      *msgs,
                            CTSAMSG_DEST_TABLE_rec_typ  *dest)
{

  static         char func[]="Get_NEXTKEYs";

  ESA_RC         rc = ESA_OK;
  ESA_RC         max_rc = ESA_OK;                         /* IS10122 */
  char          *new_nextkeys = NULL, *curr_pos;
  char          *new_pos;
  char           curr_nextkey[ACF2_RESRULE_KEY_SIZE];
  int            i, num_nextkeys = 0;
  int            null_length = 0;
  int            first_time;
  char          *resname_pos;                            /* IS10122 */

  ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

  first_time = FALSE;

  /*****************************************************************
  * In first call we get a NULL pointer and allocate 1st extent    *
  ******************************************************************/
  if (*nextkeys_list EQ NULL)
  {
   *nextkeys_list = (char *) malloc (ACF2_NEXTKEY_LIST_EXTENT);

   if (*nextkeys_list EQ NULL)
   {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "NEXTKEYS LIST BUFFER EXTENT",
                  ACF2_NEXTKEY_LIST_EXTENT);
     rc = ESA_FATAL;
     goto exit;
   };

   ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                   "Allocated nextkeys buffer size(%d)addr(%X)ptr(%X)",
                   ACF2_NEXTKEY_LIST_EXTENT,
                   *nextkeys_list,
                   nextkeys_list);

   *nextkeys_size = ACF2_NEXTKEY_LIST_EXTENT;
   *nextkeys_list[0] = NULL_CHAR;
   first_time = TRUE;
  };

  /*****************************************************************
  * Get current resource's NEXTKEYs                                *
  ******************************************************************/
  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                  "Get NEXTKEYs for res(%s) type(%s)",
                  resname, restype);

  rc = Get_Res_NEXTKEYs (resname,
                         restype,
                         nextkeys_list,  /* ptr to nextkeys list */
                         nextkeys_size,
                         &num_nextkeys,  /* num of new nextkeys  */
                         &new_nextkeys,  /* ptr to new nextkeys  */
                         srcbuff,
                         srcbuff_len,
                         print_depth,
                         print_msg,
                         originator,
                         msgs,
                         dest);

  if ( (rc EQ ESA_OK) AND (NOT first_time) )
    *tot_nextkeys = *tot_nextkeys + 1;

  /* IS10122 - start */
  /* Case of skipped or not found resource - remove it from list */
  if ( (rc EQ ESA_SKIP  OR  rc EQ ESA_ERR)  AND
       (NOT first_time)  )
  {
    if (rc EQ ESA_SKIP)
      CTSAMSG_print(ACF2_RES_ROLESET_IGNORED, msgs, NULL, dest,
                    resname, restype);
    resname_pos = strstr(*nextkeys_list, resname);
    if (resname_pos NE NULL)
      resname_pos[0] = ' ';
    rc = ESA_OK;
  }
  /*
   * Case of RESOURCE NOT FOUND *
  if (rc EQ ESA_ERR)
    rc = ESA_OK;
  /* IS10122 - end */

  if (rc NE ESA_OK)
    goto exit;

  /* IS10122 - start */
  /*
  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                  "Num of NEXTKEYS(%d)",
                  num_nextkeys);                                     */
  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                  "Num of NEXTKEYS = %d   Tot_nextkeys = %d",
                  num_nextkeys, *tot_nextkeys);
  /* IS10122 - end */

  /*****************************************************************
  * For each NEXTKEY call Get_NEXTKEYs recursively                 *
  ******************************************************************/

  /* Have we reached lowest depth ? */
  if (depth LE 1)
    goto exit;

  if (num_nextkeys EQ 0)
    goto exit;

  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                  "Continue to next depth");

  curr_pos = new_nextkeys;

  for (i=0; i LT num_nextkeys; i++)
  {
    new_pos = strchr (curr_pos, ADDINFO_LIST_ENTRY);

    if (new_pos NE NULL)
      *new_pos = NULL_CHAR;

    strcpy (curr_nextkey, curr_pos);

    if (new_pos NE NULL)
      *new_pos = ADDINFO_LIST_ENTRY;

    curr_pos = new_pos + 1;

    rc = Get_NEXTKEYs (curr_nextkey,
                       restype,
                       depth-1,
                       nextkeys_list,
                       nextkeys_size,
                       NULL,
                       null_length,
                       print_depth+1,
                       print_msg,
                       tot_nextkeys,
                       originator,
                       msgs,
                       dest);

    /* IS10122 - start */
    /* if (rc NE ESA_OK)   */
    if (rc GT ESA_OK)
    {
      if (rc GT max_rc)
        max_rc = rc;
      if (rc GT ESA_SKIP)
    /* IS10122 - end */
        goto exit;
    }                                                  /* IS10122 */
  };

  exit: ;

  /* IS10122 - start */
  if (max_rc GT rc)
    rc = max_rc;
  /* IS10122 - end */

  ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,rc);

  return rc;
}

 /* WS2333 */
 /******************************************************************
 * Procedure Name: Get_Res_NEXTKEYs
 *******************************************************************
 * Description   : Return NEXTKEYs of one specific resource
 *
 * Input         : resname        - resource name
 *                 restype        - resource type
 *                 srcbuff        - NULL or rule source buffer
 *                 srcbuff_l      - 0 or rule source buffer length
 *                 prtdepth       - depth to print in messages
 *                 prtmsg         - TRUE = print messages
 *                 original       - original resource
 *                 msgs,dest
 *
 * Input/Output  : nextkeys       - nextkeys list pointer
 *                 nextsize       - size of nextkeys list
 *
 * Output        : numkeys        - number of nextkeys returned
 *                 newkeys        - ptr to beginning of new nextkeys
 *
 * Return Value  : ESA_RC
 *********************************************************************/
static ESA_RC Get_Res_NEXTKEYs (char                        *resname,
                                char                        *restype,
                                char                       **nextkeys,
                                int                         *nextsize,
                                int                         *numkeys,
                                char                       **newkeys,
                                char                        *srcbuff,
                                int                          srcbuff_l,
                                int                          prtdepth,
                                int                          prtmsg,
                                char                        *original,
                                CTSAMSG_HANDLE_rec_typ      *msgs,
                                CTSAMSG_DEST_TABLE_rec_typ  *dest)
{

  static         char func[]="Get_Res_NEXTKEYs";

  RESOURCE_typ   res_to_print;

  ESA_RC         rc = ESA_OK;
  RESOURCE_typ   res_to_compare;
  char           ACF2_DSN_key[ACF2_ACCRULE_KEY_SIZE];
  char           ACF2_current_DSN_key[ACF2_ACCRULE_KEY_SIZE];
  char           ACF2_RES_key[ACF2_RESRULE_KEY_SIZE];
  char           ACF2_current_RES_key[ACF2_RESRULE_KEY_SIZE];
  char          *obj_buffer = NULL;
  char          *src_buffer = NULL;
  char          *source;
  char           date_last[9];
  char           user_last[9];
  char           msg[256] = "";
  char           errmsg[256] = "";
  int            src_buffer_length = ACF2_RULE_SOURCE_LENGTH;
  int            rc1 = 0;

  ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

  Reset_Field(ACF2_DSN_key,sizeof(ACF2_DSN_key),' ',resname);
  Reset_Field(ACF2_RES_key,sizeof(ACF2_RES_key),' ',resname);

  Reset_Field(ACF2_current_DSN_key,sizeof(ACF2_current_DSN_key),
              ' ',NULL);
  Reset_Field(ACF2_current_RES_key,sizeof(ACF2_current_RES_key),
              ' ',NULL);

  memset(user_last,0X00,sizeof(user_last));
  memset(date_last,0X00,sizeof(date_last));

  /*****************************************************************
  * Have we received a rule source buffer ?                        *
  * If not, we have to read the resource data ourselves            *
  ******************************************************************/
  if (srcbuff EQ NULL)
  {
    /*************************************************************
    * Obtain storage for rule object buffer                      *
    **************************************************************/
    ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                    "Source buffer not supplied. Get resource data");

    obj_buffer = (char *) malloc (ACF2_RULE_BUFFER_LENGTH);

    if (obj_buffer EQ NULL)
    {
      CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                   "RULE OBJECT BUFFER",
                   ACF2_RULE_BUFFER_LENGTH);
      rc = ESA_FATAL;
      goto exit;
    };

    /*************************************************************
    * Obtain storage for rule source buffer                      *
    **************************************************************/
    src_buffer = (char *) malloc (ACF2_RULE_SOURCE_LENGTH);

    if (src_buffer EQ NULL)
    {
      CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                   "RULE SOURCE BUFFER",
                   ACF2_RULE_SOURCE_LENGTH);
      rc = ESA_FATAL;
      goto exit;
    };

    ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                    "Resource type(%s)",
                    restype);

    if (strcmp (restype, "DSN") EQ 0)
      /* SAS2IBMT
      cts2rul(ACF2_RETRIEVE_OP,                                      */
      (*(ASM_RTN_TYP *)&cts2rul)                          /* SAS2IBMT */
             (ACF2_RETRIEVE_OP,
              ACF2_DSN_key,
              ACF2_current_DSN_key,
              "S",                                        /* WS2333 */
              obj_buffer,
              src_buffer,
              &src_buffer_length,
              &rc1,
              errmsg);
    else
      /* SAS2IBMT
      cts2grs(ACF2_RETRIEVE_OP,                                      */
      (*(ASM_RTN_TYP *)&cts2grs)                          /* SAS2IBMT */
             (ACF2_RETRIEVE_OP,
              ACF2_RES_key,
              restype,
              ACF2_current_RES_key,
              "S",                                        /* WS2333 */
              obj_buffer,
              src_buffer,
              &src_buffer_length,
              date_last,
              user_last,
              &rc1,
              errmsg);

    if (ESA_DIAG_get_debug_level(ESA_COMP_GETRES) GE DEBUG_SHOW_ALL)
    {
      SNAP_AREA( "OBJECT buffer", obj_buffer, 256 )
      SNAP_AREA( "SOURCE buffer", src_buffer, 256 )
    };

 /******************************************************************
 * If source buffer is too small, expand it once and retry         *
 *******************************************************************/
   if (rc1 EQ 2)
   {
     ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Need to expand buffer");
     free (src_buffer);
     src_buffer = NULL;
     src_buffer = (char *) malloc (ACF2_RULE_SOURCE_INC);

     if (src_buffer EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "RULE SOURCE BUFFER",
                    ACF2_RULE_SOURCE_INC);
       rc = ESA_FATAL;
       goto exit;
     };

     src_buffer_length = ACF2_RULE_SOURCE_INC;

     if (strcmp (restype, "DSN") EQ 0)
       /* SAS2IBMT
       cts2rul(ACF2_RETRIEVE_OP,                                     */
       (*(ASM_RTN_TYP *)&cts2rul)                         /* SAS2IBMT */
              (ACF2_RETRIEVE_OP,
               ACF2_DSN_key,
               ACF2_current_DSN_key,
               "S",                                       /* WS2333 */
               obj_buffer,
               src_buffer,
               &src_buffer_length,
               &rc1,
               errmsg);
       else
         /* SAS2IBMT
         cts2grs(ACF2_RETRIEVE_OP,                                   */
         (*(ASM_RTN_TYP *)&cts2grs)                       /* SAS2IBMT */
                (ACF2_RETRIEVE_OP,
                 ACF2_RES_key,
                 restype,
                 ACF2_current_RES_key,
                 "S",                                     /* WS2333 */
                 obj_buffer,
                 src_buffer,
                 &src_buffer_length,
                 date_last,
                 user_last,
                 &rc1,
                 errmsg);

   };

   ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                   "rc from extractor(%d)", rc1);

   switch (rc1)
   {
     case 0:
              /*****************************************************
              * Get ruleset source from ACF2OUT dataset            *
              ******************************************************/
              rc = Get_Dsn_Output("ACF2OUT ",
                                  src_buffer,
                                  &src_buffer_length,
                                  dest,
                                  msgs);

              if (rc NE ESA_OK)
              {
                strcpy(errmsg,"Get_Dsn_Output failed");
                rc = ESA_FATAL;
                goto exit;
              };

              if (ESA_DIAG_get_debug_level(ESA_COMP_GETRES) GE
               DEBUG_SHOW_IMPORTANT)
              {
                SNAP_AREA( "Formatted rule", src_buffer, 400)
              };

              break;

              /*************************************************
              * Output buffer too small                        *
              **************************************************/
     case 2:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Output buffer too small");
              goto exit;

              /***************************************************
              * Decompile failed                                 *
              ****************************************************/
     case 3:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Rule Decompile failed");
              goto exit;

              /***************************************************
              * EOF Status                                       *
              ****************************************************/
     case 4:  rc = ESA_ERR;

              strcpy (res_to_compare, resname);

              Trim (res_to_compare);

              /* IS10122 - start */
              /*
               * Is current resource the original one ? *
              if (strcmp (res_to_compare, original) EQ 0)
              {
                CTSAMSG_print(ERR_RES_NOT_EXIST, msgs, NULL, dest,
                              res_to_compare);
                goto exit;
              };
              */

              /* if (prtmsg)   */
              if ( (strcmp (res_to_compare, original) NE 0)  AND
                   (prtmsg) )
              /* IS10122 - end */
              {
                if (strcmp (restype, "DSN") EQ 0)
                  strcpy (res_to_print, ACF2_DSN_key);
                else
                  strcpy (res_to_print, ACF2_RES_key);

                Trim (res_to_print);

                CTSAMSG_print(ACF2_NEXTKEY_NOT_FOUND,
                              msgs,
                              NULL,
                              dest,
                              res_to_print);
              };

              goto exit;

              /***************************************************
              * ACFRDS failed                                    *
              ****************************************************/
     case 5:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 ACFRDS process failed");
              goto exit;

              /***************************************************
              * ACF2 Internal Error situations                   *
              ****************************************************/
     case 8:  rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Control Block Error");
              goto exit;

              /***************************************************
              * ACF2 Not Active                                  *
              ****************************************************/
     case 12: rc = ESA_FATAL;
              strcpy(errmsg,"ACF2 Not Active");
              goto exit;

     default: rc = ESA_FATAL;
              strcpy(errmsg,"Unknown ACF2 return code");
              goto exit;
   };
  };

  if (rc NE ESA_OK)
    goto exit;

  /*****************************************************************
  * Accumulate the NEXTKEYs                                        *
  ******************************************************************/
  if (src_buffer NE NULL)
    source = src_buffer;
  else
  {
    source = srcbuff;
    src_buffer_length = srcbuff_l;
  };

  /* ps0298 */
  if (prtmsg)
  {
    if (strcmp (restype, "DSN") EQ 0)
      strcpy (res_to_print, ACF2_DSN_key);
    else
      strcpy (res_to_print, ACF2_RES_key);

    Trim (res_to_print);

    CTSAMSG_print(ACF2_SCANNING_RULESET,
                  msgs,
                  NULL,
                  dest,
                  res_to_print);
  };                                 /* end of ps0298 */

  rc = Accum_NEXTKEYs (nextkeys,
                       nextsize,
                       numkeys,
                       newkeys,
                       source,
                       src_buffer_length,
                       prtdepth,
                       prtmsg,
                       original,
                       msgs,
                       dest);

  if (rc NE ESA_OK)
    goto exit;

  if (*numkeys GT 0)
    ESA_DIAG_printf(ESA_COMP_GETRES,
                    DEBUG_SHOW_IMPORTANT,
                    "NEXTKEYs %X(%s) NEWKEYS %X(%s)",
                    *nextkeys,
                    *nextkeys,
                    *newkeys,
                    *newkeys);

  exit: ;

  if (obj_buffer NE NULL)
    free (obj_buffer);

  if (src_buffer NE NULL)
    free (src_buffer);

  if (rc EQ ESA_FATAL)
  {
    if (strcmp (restype, "DSN") EQ 0)
      sprintf(msg,"Get Res fail res=%s ACF2_rc=%d msg=%s",
                ACF2_current_DSN_key, rc1, errmsg);
    else
      sprintf(msg,"Get Res fail res=%s ACF2_rc=%d msg=%s",
                ACF2_current_RES_key, rc1, errmsg);

    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
           func, msg, 16,__LINE__);
  };

  ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,rc);

  return rc;
}

/* WS2333 */
 /******************************************************************
 * Procedure Name: Accum_NEXTKEYs
 *******************************************************************
 * Description   : Return NEXTKEYs from rule buffer
 *
 * Input         : srcbuff        - rule source buffer
 *                 srcbuff_l      - rule source buffer length
 *                 prtdepth       - depth to print in messages
 *                 prtmsg         - TRUE = print messages
 *                 original       - original resource
 *                 msgs,dest
 *
 * Input/Output  : nextkeys       - nextkeys list pointer
 *                 nextsize       - size of nextkeys list
 *
 * Output        : numkeys        - number of nextkeys returned
 *                 newkeys        - ptr to beginning of new nextkeys
 *
 * Return Value  : ESA_RC
 *********************************************************************/
static ESA_RC Accum_NEXTKEYs (char                       **nextkeys,
                              int                         *nextsize,
                              int                         *numkeys,
                              char                       **newkeys,
                              char                        *srcbuff,
                              int                          srcbuff_l,
                              int                          prtdepth,
                              int                          prtmsg,
                              char                        *original,
                              CTSAMSG_HANDLE_rec_typ      *msgs,
                              CTSAMSG_DEST_TABLE_rec_typ  *dest)
{

  static         char func[]="Accum_NEXTKEYs";

  ESA_RC         rc = ESA_OK;
  ACF2_Automat_States_Type  curr_state;

  char curr_keyword[ACF_ADDINFO_KWD_LEN+1]="";
  char value[ACF_ADDINFO_VAL_LEN+1]="";
  char sep[3];
  char *buffer_start, *curr_nextkey, *curr_nextkey_end;
  char *curr_pos, *keyword_start, *buffer_end;
  int   curr_col, curr_line, i, found_non_blank, depth, value_index;
  int   newkeys_offset, nextkey_exists;
  int  keyword_found_in_line;                             /* BS2416 */
  RESOURCE_typ    res_name = "";                          /* IS10122 */
  RESTYPE_typ     res_type = "";                          /* IS10122 */

  ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

  BUILD_STRING_SEPARATOR(sep, ADDINFO_LIST_ENTRY);

  *numkeys = 0;

  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
            "nextkeys len(%d) size(%d) buff(%X) ptr(%X)",
            strlen (*nextkeys),
            *nextsize,
            *nextkeys,
            nextkeys);

  ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
            "rule buffer(%X) len(%d)",
            srcbuff,
            srcbuff_l);

  *newkeys = *nextkeys + strlen(*nextkeys);

  /* we don't want to point to the ENTRY separator, but to the value */
  if (strlen(*nextkeys) NE 0)
    *newkeys = *newkeys + 1;

  curr_pos = strstr(srcbuff, "$KEY(");

  if (curr_pos EQ NULL)
  {
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component, func,
           "KEY statement not found in rule buffer", 16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
  };

  buffer_start = curr_pos;

  depth = 0;
  value_index = 0;
  curr_state = BEFORE_KEYWORD;

  curr_col = 0;
  curr_line = 0;

  buffer_end = srcbuff+srcbuff_l;

  keyword_found_in_line = FALSE;                          /* BS2416 */

  while (curr_pos LT buffer_end)
  {
    switch(curr_state)
    {
      /*************************************************************
      * Handle BEFORE_KEYWORD state                                *
      **************************************************************/
      case BEFORE_KEYWORD:
      /* BS2416 - replaced by following IF statement
        if (*curr_pos EQ '-' OR curr_col GT 71)
      */
        if ( (curr_col GT 71) OR
             (*curr_pos EQ '-' AND keyword_found_in_line) )
        {
          keyword_found_in_line = FALSE;                  /* BS2416 */
          curr_line++;
          curr_col = 0;
          curr_pos = buffer_start + (curr_line * 80);
        }
        else if (*curr_pos EQ ' ')                /* blank-skip  */
        {
          curr_pos++;
          curr_col++;
        }
        else                                      /* keyword     */
        {
          curr_state = IN_KEYWORD;
          keyword_start = curr_pos;
          keyword_found_in_line = TRUE;                   /* BS2416 */
        };
        break;

      /*************************************************************
      * Handle IN_KEYWORD state                                    *
      **************************************************************/
      case IN_KEYWORD:
        if (*curr_pos EQ '$' OR *curr_pos EQ '%')
        {                                       /* skip header */
          curr_pos++;
          curr_col++;
          keyword_start = curr_pos;
        }
        else if (*curr_pos EQ '(')             /* value starts */
        {
          *curr_pos = NULL_CHAR;
          strcpy (curr_keyword, keyword_start);
          *curr_pos = '(';
          ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                    "Found keyword(%s)", curr_keyword);
          curr_state = IN_VALUE;
          value_index = 0;
          depth = 1;
          curr_pos++;
          curr_col++;
        }
/* WS10075    else if (*curr_pos EQ ' ')        /@ flag / multi  @/ */
        else if (*curr_pos EQ ' ' OR   /* flag / multi  *//* WS10075*/
                   curr_col GT 71)      /* end of line */  /* WS10075*/
        {
          *curr_pos = NULL_CHAR;
          strcpy (curr_keyword, keyword_start);
          *curr_pos = ' ';

          /* IS10122 - start */
          /*  If this is a reolset rule, skip it */
          if ( strcmp(curr_keyword, "ROLESET") EQ 0 )
          {
            rc = ESA_SKIP;
            goto exit;
          }
          /* IS10122 - end */
          if ( (strcmp (curr_keyword, "CHANGE") NE 0) AND
               (strcmp (curr_keyword, "RCHANGE") NE 0) )
          {
            ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Found FLAG keyword(%s)", curr_keyword);
            curr_state = BEFORE_KEYWORD;
            curr_pos++;
            curr_col++;
            keyword_start = curr_pos;
            value_index = 0;
          }
          else
          {
            ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Found MULTI keyword(%s)", curr_keyword);
            curr_state = IN_VALUE;
            depth = 0;
            curr_pos++;
            curr_col++;
          };

          if  (curr_col GT 72) /* end of line ?    */  /* WS10075 */
                               /* 72 because curr_col was advanced */
          {                                            /* WS10075 */
            curr_line++;                               /* WS10075 */
            curr_col = 0;                              /* WS10075 */
            curr_pos = buffer_start + (curr_line * 80);/* WS10075 */
          }                                            /* WS10075 */
        }
        else
        {
          curr_pos++;
          curr_col++;
        };
        break;

      /*************************************************************
      * Handle IN_VALUE state                                      *
      **************************************************************/
      case IN_VALUE:
        if (*curr_pos EQ '-' AND curr_col GE 71)
        {                                       /*contd next line*/
          curr_line++;
          curr_col = 0;
          curr_pos = buffer_start + (curr_line * 80);
        }
        else if (*curr_pos EQ '-')              /* continued ?   */
        {
          found_non_blank = FALSE;              /* check if dash */
          for (i=1; i LT (72-curr_col); i++)    /* is last char  */
          {                                     /* in line       */
            if (*(curr_pos+i) NE ' ')
              found_non_blank = TRUE;
          };

          if (found_non_blank)                  /* not last char */
          {
            value[value_index] = *curr_pos;
            value_index++;
            curr_pos++;
            curr_col++;
          }
          else                                  /*last char-skip */
          {
            curr_line++;
            curr_col = 0;
            curr_pos = buffer_start + (curr_line * 80);
          };
        }
        else if (*curr_pos EQ ',')              /* LIST value ?  */
        {
          value[value_index] = *curr_pos;
          value_index++;
          curr_pos++;
          curr_col++;
        }
        else if (*curr_pos EQ '(')              /*value has depth*/
        {
          depth++;
          value[value_index] = *curr_pos;
          value_index++;
          curr_pos++;
          curr_col++;
        }
        else if (*curr_pos EQ ')')              /* depth or end ?*/
        {
          depth--;
          if (depth LE 0)                       /* end of value  */
          {
            value[value_index] = NULL_CHAR;

            ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "Keyword value(%s)", value);

            /* IS10122 - start */
            if (strcmp (curr_keyword, "KEY") EQ 0)
              strcpy(res_name, value);
            else
              if (strcmp (curr_keyword, "TYPE") EQ 0)
                strcpy(res_type, value);
              else
            /* IS10122 - end */
            /*******************************************************
            * Handle NEXTKEY value                                 *
            ********************************************************/
            if (strcmp (curr_keyword, "NEXTKEY") EQ 0)
            {
              ESA_DIAG_printf(ESA_COMP_GETRES,
                              DEBUG_SHOW_IMPORTANT,
                              "nextkeys list len(%d)size(%d)addr(%X)",
                              strlen(*nextkeys),
                              *nextsize,
                              *nextkeys);

              /*****************************************************
              * Check for loops                                    *
              ******************************************************/
              nextkey_exists = FALSE;

              /*****************************************************
              * Compare with original resource                     *
              ******************************************************/
              if (strcmp (value, original) EQ 0)
                nextkey_exists = TRUE;

              /*****************************************************
              * Compare with rest of NEXTKEYs in list              *
              ******************************************************/
              if (strlen (*nextkeys) NE 0)
              {
                curr_nextkey = *nextkeys;
                curr_nextkey_end = strchr (curr_nextkey,
                                           ADDINFO_LIST_ENTRY);

                while ( (curr_nextkey_end NE NULL) AND
                        (NOT nextkey_exists) )
                {
                  *curr_nextkey_end = NULL_CHAR;

                  if (strcmp (curr_nextkey, value) EQ 0)
                    nextkey_exists = TRUE;

                  *curr_nextkey_end = ADDINFO_LIST_ENTRY;

                  curr_nextkey = curr_nextkey_end + 1;

                  curr_nextkey_end = strchr (curr_nextkey,
                                             ADDINFO_LIST_ENTRY);
                };

                if (strcmp (curr_nextkey, value) EQ 0)
                  nextkey_exists = TRUE;
              };

              if (NOT nextkey_exists)
              {
                /* Do we have enough place for nextkey ? */
                if ( (strlen (*nextkeys)+ACF2_RESRULE_KEY_SIZE) GE
                     (*nextsize) )
                {
                  ESA_DIAG_printf(ESA_COMP_GETRES,
                                  DEBUG_SHOW_IMPORTANT,
                                  "Expand nextkeys list");

                  newkeys_offset = *newkeys - *nextkeys;
                  *newkeys = realloc(*nextkeys, *nextsize+
                                     ACF2_NEXTKEY_LIST_EXTENT);

                  if (*newkeys EQ NULL)
                  {
                    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                                  "NEXTKEYS LIST BUFFER EXTENT",
                                  ACF2_NEXTKEY_LIST_EXTENT);
                    rc = ESA_FATAL;
                    goto exit;
                  };

                  *nextsize = *nextsize + ACF2_NEXTKEY_LIST_EXTENT;
                  *nextkeys = *newkeys;
                  *newkeys = *nextkeys + newkeys_offset;

                  ESA_DIAG_printf(ESA_COMP_GETRES,
                                  DEBUG_SHOW_IMPORTANT,
                                  "New NEXTKEYs list addr(%X)",
                                  *nextkeys);
                };

                if (strlen (*nextkeys) GT 0)
                  strcat (*nextkeys, sep);

                strcat (*nextkeys, value);
                *numkeys = *numkeys + 1;

                if (prtmsg)
                  CTSAMSG_print(ACF2_OBTAINED_NEXTKEY,
                                msgs,
                                NULL,
                                dest,
                                value,
                                prtdepth);
              }
              else
              {
                if (prtmsg)
                {
                  CTSAMSG_print(ACF2_OBTAINED_NEXTKEY,
                                msgs,
                                NULL,
                                dest,
                                value,
                                prtdepth);

                  CTSAMSG_print(ACF2_IGNORING_NEXTKEY,
                                msgs,
                                NULL,
                                dest,
                                value);
                };

                ESA_DIAG_printf(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT,
                     "NEXTKEY value already found in list");
              };
            };

            curr_state = BEFORE_KEYWORD;
            curr_pos++;
            curr_col++;
            value_index = 0;
            keyword_start = curr_pos;
          }
          else                                  /* part of value */
          {
            value[value_index] = *curr_pos;
            value_index++;
            curr_pos++;
            curr_col++;
          };
        }
        else if (*curr_pos EQ ' ')              /* end if multi  */
        {
          if ( (strcmp (curr_keyword, "CHANGE") EQ 0) OR
               (strcmp (curr_keyword, "RCHANGE") EQ 0) )
          {
            curr_state = BEFORE_KEYWORD;
            value_index = 0;
            curr_pos++;
            curr_col++;
            keyword_start = curr_pos;
          }
          else
          {
            value[value_index] = *curr_pos;
            value_index++;
            curr_pos++;
            curr_col++;
          };
        }
        else
        {
          value[value_index] = *curr_pos;
          value_index++;
          curr_pos++;
          curr_col++;
        };
        break;

      default:
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                      dest, component,func,
                      "Invalid scan state",
                      16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
    };
  };

  exit: ;

  ESA_DIAG_printf(ESA_COMP_GETRES,
                  DEBUG_SHOW_IMPORTANT,
                  "Total num of added NEXTKEYs(%d)",
                  *numkeys);

  ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,rc);

  return rc;
}

/* BS2411 */
/******************************************************************
 * Procedure Name: Num_Of_Qualifiers
 ******************************************************************
 * Description   : Return number of qualifiers in a string
 *
 * Input         : qin        - qualified string
 *
 * Return Value  : int - number of qualifiers
 *********************************************************************/
 static int Num_Of_Qualifiers (char *qin)
 {
   int                          num_of_qualifiers;
   int                          i;

   num_of_qualifiers = 1;

   for (i=0; i LT strlen(qin); i++)
     if (qin[i] EQ '.')
       num_of_qualifiers++;

   return num_of_qualifiers;
 }
 /* End of BS2411 */

/* BS2411 */
/******************************************************************
 * Procedure Name: Calc_Real_Rule_Entry
 ******************************************************************
 * Description   : This function calculates the real rule entry
 *                 based on:
 *                 1. Resource Type
 *                 2. RESMASK value of new ACE
 *                 3. PREFIX value (if any) of current rule set
 *
 * Input         : res_name   - Resource name
 *                 res_type   - Resource type
 *                 res_addinfo- Current rule set addinfo
 *                 orig_entry - Original RESMASK value of new ACE
 *                 msgs,dest
 *
 * Output        : real_entry  - Calculated rule entry
 *                 quoted      - Does RESMASK contain quotes ?
 *
 * Return Value  : None
 *********************************************************************/
 static void Calc_Real_Rule_Entry (char                  *res_name,
                                   char                  *res_type,
                                   ADDINFO_rec_ptr        res_addinfo,
                                   char                  *orig_entry,
                                   char                  *real_entry,
                                   int                   *quoted,
                                  CTSAMSG_HANDLE_rec_typ     *msgs,
                                  CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static                       char func[]="Calc_Real_Rule_Entry";

   ONE_FIELD_rec_ptr            pair = NULL;
   RESOURCE_typ                 temp_rule;
   int                          rule_has_prefix;
   int                          qualifiers_to_strip;
   int                          i;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   *quoted = FALSE;
   real_entry[0] = NULL_CHAR;

   /*********************************************************
   * Search for PREFIX keyword in current rule set          *
   **********************************************************/
   pair = ADDINFO_search ("PREFIX",
                          ACF_ADDINFO_KWD_LEN,
                          res_addinfo->pair,
                          res_addinfo->num_pairs);

   rule_has_prefix = TRUE;

   if (pair EQ NULL)
     rule_has_prefix = FALSE;
   else if (pair->value[0] EQ NULL_CHAR)
     rule_has_prefix = FALSE;

   /*********************************************************
   * Does RESMASK contain quotes ?                          *
   **********************************************************/
   if ( (orig_entry[0] EQ QUOTE_CHAR) AND
        (orig_entry[strlen(orig_entry)-1] EQ QUOTE_CHAR) )
     *quoted = TRUE;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "Original RESMASK(%s)",
                 orig_entry);

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "PREFIX exists flag(%d) QUOTES exist flag(%d)",
                 rule_has_prefix, *quoted);

   /*******************************************************
   * Calculate number of qualifiers to strip              *
   ********************************************************/
   if (NOT rule_has_prefix)
   {
     if (strcmp (res_type, "DSN") EQ 0)
       qualifiers_to_strip = 1;
     else
       qualifiers_to_strip = Num_Of_Qualifiers (res_name);
   }
   else
   {
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "ruleset PREFIX(%s)",
                    pair->value);

     qualifiers_to_strip = Num_Of_Qualifiers (pair->value);
   };

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "Qualifiers to strip=(%d)",
                  qualifiers_to_strip);

   /*******************************************************
   * Prepare copy of RESMASK                              *
   ********************************************************/
   if (*quoted)
   {
     strcpy (real_entry, orig_entry+1);
     real_entry[strlen(real_entry)-1] = NULL_CHAR;
   }
   else
     strcpy (real_entry, orig_entry);

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "String to strip from(%s)",
                  real_entry);

   for (i=0; i LT qualifiers_to_strip; i++)
   {
     Strip_First_Qualifier (temp_rule, real_entry);
     strcpy (real_entry, temp_rule);
   };

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "real rule entry(%s)",
                 real_entry);

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func, 0);

 }
 /* End of BS2411 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Write_Entire_Rule
 ******************************************************************
 * Description   : This function writes an entire ruleset
 *                 (rule header+rule entries) to the rule file
 *                 and adds a new rule entry at the end.
 *
 * Input         : res_name   - Resource name
 *                 res_type   - Resource type
 *                 new_ace    - New ACE struct fields (sent from ESS)
 *                 new_addinfo- New ACE ADDINFO fields (from ESS)
 *                 rule_file
 *                 admin params
 *
 * Input/Output  : h          - ACEs handle
 *                 laddinfo   - Resource work ADDINFO
 *                 ace_addinfo- ACE work ADDINFO
 *
 * Output        : num_rules   - total number of rule entries
 *                               in modified ruleset (for compile)
 *                 errmsg      - error message description
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 static ESA_RC Write_Entire_Rule (char                 *res_name,
                                  char                 *res_type,
                                  ADDINFO_rec_ptr       laddinfo,
                                ACF2_Get_ResACL_Handle *h,
                                  ADDINFO_rec_ptr       ace_addinfo,
                                  ACE_rec_typ          *new_ace,
                                  ADDINFO_rec_ptr       new_addinfo,
                                  int                  *num_rules,
                                  FILE                 *rule_file,
                                  char                 *errmsg,
                                  ADMIN_PARAMS_rec_typ *admin_params)
 {
   /*************************************************************
   * Variables                                                  *
   **************************************************************/
   static                       char func[]="Write_Entire_Rule";

   RESOURCE_typ                current_key;
   ACE_rec_typ                 curr_ace;
   ESA_RC                      rc = ESA_OK;
   char                        msg[256]="";
   int                         iterate;

   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   Reset_Field(current_key, sizeof(RESOURCE_typ), NULL_CHAR, NULL);

   /*********************************************************
   * Write ruleset header data to file                      *
   **********************************************************/
   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "Writing ruleset header");

   rc = Build_Ruleset (res_name,
                       res_type,
                       laddinfo,
                       rule_file,
                       msgs,
                       dest);

   if (rc NE ESA_OK)
   {
     sprintf(msg,
             "Add ACE fail res=%s msg=Build ruleset header failed",
             res_name);
     CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
            func, msg, 16,__LINE__);
     rc = ESA_FATAL;
     goto exit;
   };

   iterate = TRUE;

   *num_rules = 0;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "Writing all rule entries");

   /*********************************************************
   * A loop to get all ACEs and write them to the file      *
   **********************************************************/
   while (iterate)
   {
     ADDINFO_clear(ace_addinfo);

     rc = ACF2_Get_Resource(res_name,
                            ACF2_Object_is_Not_Masked,
                            res_type,
                            ACF2_Return_Rule_Entries,
                            h,
                            NULL,
                            current_key,
                            &curr_ace,
                            ace_addinfo,
                            errmsg,
                            admin_params);

     switch(rc)
     {
        case ACF2_OK:
          break;

        case ACF2_Not_Found:
          /* IS10122 - start */
          /*
           *   Issue a message when rule is ignored or not found
           */
          if ( strcmp(errmsg, ACF2_ROLESET_IGNORED_MSG) EQ 0 )
            CTSAMSG_print(ACF2_RES_ROLESET_IGNORED, msgs, NULL, dest,
                          res_name, res_type);
          else
          /* IS10122 - end */
            CTSAMSG_print(ERR_RES_NOT_EXIST, msgs, NULL, dest,
                          res_name);
          rc = ESA_FATAL;
          goto exit;

        default:
          sprintf(msg,"Get ResACL fail res=%s rc=%d msg=%s",
                    res_name, rc, errmsg);
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                 func, msg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
     }

     if (strcmp (errmsg, "NO MORE ACES") EQ 0)
       iterate = FALSE;
     else
     {
       rc = Build_Rule_Entry (&curr_ace,
                              ace_addinfo,
                              res_type,
                              rule_file,
                              msgs,
                              dest);
       if (rc NE ESA_OK)
       {
         rc = ESA_FATAL;
         goto exit;
       };
     };
     *num_rules = *num_rules + 1;
   }; /* End of loop */

   /*********************************************************
   * Add new ACE as last (will be sorted by the compiler..) *
   **********************************************************/
   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 "Writing NEW rule entry (ACE)");

   rc = Build_Rule_Entry (new_ace,
                          new_addinfo,
                          res_type,
                          rule_file,
                          msgs,
                          dest);
   if (rc NE ESA_OK)
   {
     rc = ESA_FATAL;
     goto exit;
   };

   *num_rules = *num_rules + 1;

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func,rc);

   return rc;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Is_Access_Denied
 ******************************************************************
 * Description   : This function checks if access as defined in
 *                 one rule entry is prevented according to a second
 *                 rule entry.
 *
 * Input         : res_type    - Resource type
 *                 new_addinfo - New rule entry fields
 *                 ace_addinfo - Current rule entry fields
 *
 * Output        : full_prevent- Does new rule fully prevent access?
 *
 * Return Value  : TRUE  - Access is denied in this rule
 *                 FALSE - Access not denied in this rule
 *********************************************************************/
 static int Is_Access_Denied (char            *res_type,
                              ADDINFO_rec_ptr  new_addinfo,
                              ADDINFO_rec_ptr  ace_addinfo,
                              int             *full_prevent)
 {
   static                       char func[]="Is_Access_Denied";

   ONE_FIELD_rec_ptr           curr_pair = NULL;
  /*
   ONE_FIELD_rec_ptr           new_pair = NULL;
  */
   int                         access_denied, i;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   access_denied = TRUE;  /* 21/11/1999 change of logic */

   *full_prevent = FALSE; /* 21/11/1999 change of logic */

   /*********************************************************
   * Change in program logic (21/11/1999):                  *
   * =====================================                  *
   * Check only if access in current rule entry is fully    *
   * prevented, no matter what are the access flags in      *
   * the new rule entry.                                    *
   **********************************************************/

   /*********************************************************
   * Check if access rule or resource rule                  *
   **********************************************************/
   if (strcmp (res_type, "DSN") EQ 0)
   {
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Resource is ACCESS RULE");

     /*******************************************************
     * Compare access permissions                           *
     ********************************************************/
     for (i=0; i LT 4; i++)
     {
       curr_pair = ADDINFO_search ((char *)&access_keywords[i],
                                   ACF_ADDINFO_KWD_LEN,
                                   ace_addinfo->pair,
                                   ace_addinfo->num_pairs);

    /* Change 21/11/1999
       new_pair = ADDINFO_search ((char *)&access_keywords[i],
                                  ACF_ADDINFO_KWD_LEN,
                                  new_addinfo->pair,
                                  new_addinfo->num_pairs);
    */
       /*****************************************************
       * NULL, NULL_CHAR means the default (access=PREVENT) *
       ******************************************************/
     /* Change 21/11/1999
       if (new_pair EQ NULL)
         continue;

       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                       "%s access in new ACE=(%s)",
                       (char *)&access_keywords[i],
                       new_pair->value);

       if ( (new_pair->value[0] EQ NULL_CHAR) OR
            (new_pair->value[0] EQ 'P') )
         continue;
     */
       /*****************************************************
       * Not all access is prevented in new rule entry      *
       ******************************************************/
     /* Change 21/11/1999
       *full_prevent = FALSE;

       if (curr_pair EQ NULL)
       {
         access_denied = TRUE;
         goto exit;
       };
     */

       /* NULL means the default (PREVENT) */
       if (curr_pair EQ NULL)
         continue;

       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                       "%s access in current ACE=(%s)",
                       (char *)&access_keywords[i],
                       curr_pair->value);

       if ( (curr_pair->value[0] EQ NULL_CHAR) OR
            (curr_pair->value[0] EQ 'P') )
         continue;
       else
       {
         access_denied = FALSE;
         goto exit;
       };
     }; /* End of access keywords loop */
   }
   else
   {
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Resource is RESOURCE RULE");

     curr_pair = ADDINFO_search ("ACCESS",
                                 ACF_ADDINFO_KWD_LEN,
                                 ace_addinfo->pair,
                                 ace_addinfo->num_pairs);

    /* Change 21/11/1999
     new_pair = ADDINFO_search ("ACCESS",
                                ACF_ADDINFO_KWD_LEN,
                                new_addinfo->pair,
                                new_addinfo->num_pairs);
    */
     /*****************************************************
     * NULL, NULL_CHAR means the default (access=PREVENT) *
     ******************************************************/
    /*
     if (new_pair EQ NULL)
       goto exit;

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "ACCESS in new ACE=(%s)",
                     new_pair->value);

     if ( (new_pair->value[0] EQ NULL_CHAR) OR
          (new_pair->value[0] EQ 'P') )
       goto exit;
    */
     /*****************************************************
     * Not all access is prevented in new rule entry      *
     ******************************************************/
    /*
     *full_prevent = FALSE;

     if (curr_pair EQ NULL)
     {
       access_denied = TRUE;
       goto exit;
     };
    */

     /* NULL means the default (PREVENT) */
     if (curr_pair EQ NULL)
       goto exit;

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "ACCESS in current ACE=(%s)",
                     curr_pair->value);

     if ( (curr_pair->value[0] EQ NULL_CHAR) OR
          (curr_pair->value[0] EQ 'P') )
       goto exit;
     else
     {
       access_denied = FALSE;
       goto exit;
     };
   };

 exit:;

   if (*full_prevent)
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "New ACE fully prevents access");
   else
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                     "New ACE does not fully prevent access");

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, access_denied);

   return access_denied;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Access_Env_Matches
 ******************************************************************
 * Description   : This function checks if the access environment
 *                 of one rule entry is included in the access env.
 *                 of a second rule entry.
 *
 * Input         : new_ace     - New rule entry struct fields
 *                 res_type    - Resource type
 *                 new_addinfo - New rule entry fields
 *                 ace_addinfo - Current rule entry fields
 *                 res_addinfo - Current ruleset fields   BS2411
 *                 real_entry  - Real rule entry          BS2411
 *                 res_name    - Current rule set name    BS2411
 *                 msgs,dest
 *
 * Output        : access_match- TRUE or FALSE
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 static ESA_RC Access_Env_Matches (ACE_rec_typ             * new_ace,
                                char                       * res_type,
                                ADDINFO_rec_ptr            new_addinfo,
                                ADDINFO_rec_ptr            ace_addinfo,
     /* BS2411 */               ADDINFO_rec_ptr            res_addinfo,
                                int                     * access_match,
     /* BS2411 */               char                    * real_entry,
     /* BS2411 */               char                    * res_name,
                                CTSAMSG_HANDLE_rec_typ     * msgs,
                                CTSAMSG_DEST_TABLE_rec_typ * dest)
 {
   static                       char func[]="Access_Env_Matches";

   ONE_FIELD_rec_ptr      pair1 = NULL;
   ESA_RC                 rc = ESA_OK;
   UIDMASK                new_rule_uidmask="";
   char                   new_mask[ACF_RESOURCE_NAME_LEN+1]="";
   char                   curr_mask[ACF_RESOURCE_NAME_LEN+1]="";
   char                   qual_sep[2];
   int                    uid_error, i;
   int                    dummy;                          /* BS2411 */

   *access_match = TRUE;

   qual_sep[0] = '.';
   qual_sep[1] = NULL_CHAR;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   /*********************************************************
   * Check if access rule or resource rule                  *
   **********************************************************/
   if (strcmp (res_type, "DSN") EQ 0)
   {
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Resource is ACCESS RULE");

     /*******************************************************
     * Order of access env check:                           *
     * ==========================                           *
     * 1. Do dsn masks match ?                              *
     * 2. Do VOLs match ?         (currently N/A)           *
     * 3. Do UIDMASKS match ?                               *
     * 4. Do SOURCE, SHIFT, LIB, PGM/PROG, DDN,             *
     *    UNTIL, ACTIVE match ?   (currently N/A)           *
     ********************************************************/

     /*******************************************************
     * Get dsn mask from both rule entries                  *
     ********************************************************/
     pair1 = ADDINFO_search ("RESMASK",
                             ACF_ADDINFO_KWD_LEN,
                             ace_addinfo->pair,
                             ace_addinfo->num_pairs);

   /* Removed by BS2411
     pair2 = ADDINFO_search ("RESMASK",
                             ACF_ADDINFO_KWD_LEN,
                             new_addinfo->pair,
                             new_addinfo->num_pairs);
   */

     /*******************************************************
     * We must have a dsn mask in both rule entries         *
     ********************************************************/
   /* Changed by BS2411. See new code below
     if (pair1 EQ NULL OR pair2 EQ NULL)
       goto rule_error;

     if (pair1->value[0] EQ NULL_CHAR OR
         pair2->value[0] EQ NULL_CHAR)
       goto rule_error;
   */

     if (pair1 EQ NULL)                                   /* BS2411 */
       goto rule_error;                                   /* BS2411 */
                                                          /* BS2411 */
     if (pair1->value[0] EQ NULL_CHAR OR                  /* BS2411 */
         real_entry[0] EQ NULL_CHAR)                      /* BS2411 */
       goto rule_error;                                   /* BS2411 */

     /*******************************************************
     * Handle special case: '.' resource name received      *
     ********************************************************/
   /* Changed by BS2411
     if (strcmp (pair2->value, qual_sep) EQ 0)
   */
     if (strcmp (real_entry, qual_sep) EQ 0)              /* BS2411 */
       goto rule_error;

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Curr(%s) New(%s) BEFORE STRIP",
                    pair1->value, real_entry);            /* BS2411 */

     /*******************************************************
     * BS2411 - Handle a local rule entry with quotes       *
     ********************************************************/
     if (pair1->value[0] EQ QUOTE_CHAR)                   /* BS2411 */
     {                                                    /* BS2411 */
       Calc_Real_Rule_Entry (res_name,                    /* BS2411 */
                             res_type,                    /* BS2411 */
                             res_addinfo,                 /* BS2411 */
                             pair1->value,                /* BS2411 */
                             curr_mask,                   /* BS2411 */
                             &dummy,                      /* BS2411 */
                             msgs,                        /* BS2411 */
                             dest);                       /* BS2411 */
     }                                                    /* BS2411 */
     else                                                 /* BS2411 */
       strcpy (curr_mask, pair1->value);                  /* BS2411 */

   /* Removed by BS2411
     if (pair2->value[0] EQ QUOTE_CHAR)
       strcpy (new_mask, pair2->value+1);
     else
       strcpy (new_mask, pair2->value);

     if (new_mask[strlen(new_mask)-1] EQ QUOTE_CHAR)
       new_mask[strlen(new_mask)-1] = NULL_CHAR;
   */

     strcpy (new_mask, real_entry);                       /* BS2411 */

     /*******************************************************
     * Values like 'SYS1.' are invalid (no mask)            *
     ********************************************************/
     if (new_mask[strlen(new_mask)-1] EQ '.')             /* BS2411 */
       goto rule_error;

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Curr(%s) New(%s) AFTER STRIP",
                    curr_mask, new_mask);

     /*******************************************************
     * Check DSN masks for match                            *
     ********************************************************/
     *access_match = Full_Masks_Match (curr_mask,
                                       new_mask);

     if (NOT *access_match)
       goto exit;

     /*******************************************************
     * Check if we have any unsupported keywords            *
     ********************************************************/
     i = 0;

     while (unsupp_keywords[i].keyword[0] NE NULL_CHAR)
     {
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                      "Check if unsupported keyword(%s) appears",
                      unsupp_keywords[i].keyword);

       pair1 = ADDINFO_search (unsupp_keywords[i].keyword,
                               ACF_ADDINFO_KWD_LEN,
                               ace_addinfo->pair,
                               ace_addinfo->num_pairs);

       if (pair1 NE NULL)
         if (pair1->value[0] NE NULL_CHAR)
         {
           CTSAMSG_print(ACF2_ARI_UNSUPPORTED_KEYWORD, msgs, NULL, dest,
                         unsupp_keywords[i].keyword);
           rc = ESA_FATAL;
           goto exit;
         };

       i++;
     };

     /*******************************************************
     * Check for VOL match.                                 *
     ********************************************************/
  /* ---------------------------------------------------------- */
  /* ---------------------------------------------------------- */
  /* ---------------------------------------------------------- */
  /* -- CURRENTLY NOT SUPPORTED  !!!  (COMMENTED OUT)---------- */
  /* ---------------------------------------------------------- */
  /* ---------------------------------------------------------- */
  /* ---------------------------------------------------------- */
  /*
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "DSNMASKs match. Checking VOLs ...");
  */

     /*******************************************************
     * Do we have VOL in current rule entry ( or VOL() ? )  *
     * NO - Means full VOL mask. We have a VOL match.       *
     * YES- Requires checking of VOL in NEW rule entry...   *
     ********************************************************/
  /*
     if (pair1 NE NULL)
     {
       if (pair1->value[0] NE NULL_CHAR)
       {
  */
         /***************************************************
         * Check VOL of NEW rule entry. Do we have one ?    *
         * NO - Full VOL mask (NEW) cannot match specific   *
         *      VOL (CURR). We have NO MATCH.               *
         * YES- We need a specific match test on both VOLs  *
         ****************************************************/
  /*     pair2 = ADDINFO_search ("VOL",
                                 ACF_ADDINFO_KWD_LEN,
                                 new_addinfo->pair,
                                 new_addinfo->num_pairs);

         if (pair2 EQ NULL)
         {
           ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                          "VOL in CURR(%s), no VOL in NEW. *NO MATCH*",
                          pair1->value);
           *access_match = FALSE;
           goto exit;
         };

         if (pair2->value[0] EQ NULL_CHAR)
         {
           ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                          "VOL in CURR(%s), VOL() in NEW. *NO MATCH*",
                          pair1->value);
           *access_match = FALSE;
           goto exit;
         };

         ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                        "VOL in CURR(%s), VOL in NEW(%s). Check it",
                        pair1->value, pair2->value);

         *access_match = VOLs_Match (pair1->value, pair2->value);
       };
     };
  */
     /*******************************************************
     * Check for UIDMASK match.                             *
     ********************************************************/
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Checking UIDMASKs ...");

     /*******************************************************
     * Translate ACE Type into a regular UIDMASK            *
     ********************************************************/
     rc = Handle_ACE_Types (new_ace,
                            new_addinfo,
                            new_rule_uidmask,
                            msgs,
                            dest);

     if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     };

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "NEW rule UIDMASK=(%s)(%d)",
                    new_rule_uidmask, strlen(new_rule_uidmask));

     uid_error = FALSE;

     pair1 = ADDINFO_search ("UID",
                             ACF_ADDINFO_KWD_LEN,
                             ace_addinfo->pair,
                             ace_addinfo->num_pairs);

     if (pair1 EQ NULL)
       uid_error = TRUE;
     else
       if (pair1->value[0] EQ NULL_CHAR)
         uid_error = TRUE;

     if (uid_error)
     {
       CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                     dest, component,func,
                     "Access rule entry must have a uidmask",
                     16,__LINE__);
       rc = ESA_FATAL;
       goto exit;
     };

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "CURR rule UIDMASK=(%s)(%d)",
                    pair1->value, strlen(pair1->value));

     *access_match = UIDMASKs_Match (pair1->value, new_rule_uidmask);
   }

   else
   {
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Resource is RESOURCE RULE");

     /*******************************************************
     * Get res mask from both rule entries                  *
     ********************************************************/
     pair1 = ADDINFO_search ("RESMASK",
                             ACF_ADDINFO_KWD_LEN,
                             ace_addinfo->pair,
                             ace_addinfo->num_pairs);

   /* Removed by BS2411
     pair2 = ADDINFO_search ("RESMASK",
                             ACF_ADDINFO_KWD_LEN,
                             new_addinfo->pair,
                             new_addinfo->num_pairs);
   */

     /*******************************************************
     * Handle special case: '.' resource name received      *
     ********************************************************/
   /* Changed by BS2411
     if (strcmp (pair2->value, qual_sep) EQ 0)
   */
     if (strcmp (real_entry, qual_sep) EQ 0)              /* BS2411 */
       goto rule_error;

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Curr(%s) len(%d) New(%s) len(%d)",
                    pair1->value, strlen(pair1->value),
                    real_entry, strlen(real_entry));      /* BS2411 */

     /*******************************************************
     * BS2411 - Handle a local rule entry with quotes       *
     ********************************************************/
     if (pair1->value[0] EQ QUOTE_CHAR)                   /* BS2411 */
     {                                                    /* BS2411 */
       Calc_Real_Rule_Entry (res_name,                    /* BS2411 */
                             res_type,                    /* BS2411 */
                             res_addinfo,                 /* BS2411 */
                             pair1->value,                /* BS2411 */
                             curr_mask,                   /* BS2411 */
                             &dummy,                      /* BS2411 */
                             msgs,                        /* BS2411 */
                             dest);                       /* BS2411 */
     }                                                    /* BS2411 */
     else                                                 /* BS2411 */
       strcpy (curr_mask, pair1->value);                  /* BS2411 */

     /* Skip masks check if both entries are NULL_CHAR */
     if ( (pair1->value[0] NE NULL_CHAR) OR
          (real_entry[0] NE NULL_CHAR) )                  /* BS2411 */
     {
     /* Removed by BS2411
       strcpy (curr_mask, pair1->value);
     */
       strcpy (new_mask, real_entry);                     /* BS2411 */

       /*****************************************************
       * Check RESOURCE masks for match                     *
       ******************************************************/
       *access_match = Full_Masks_Match (curr_mask,
                                         new_mask);

       if (NOT *access_match)
         goto exit;
     };

     /*******************************************************
     * Check if we have any unsupported keywords            *
     ********************************************************/
     i = 0;

     while (unsupp_keywords[i].keyword[0] NE NULL_CHAR)
     {
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                      "Check if unsupported keyword(%s) appears",
                      unsupp_keywords[i].keyword);

       pair1 = ADDINFO_search (unsupp_keywords[i].keyword,
                               ACF_ADDINFO_KWD_LEN,
                               ace_addinfo->pair,
                               ace_addinfo->num_pairs);

       if (pair1 NE NULL)
         if (pair1->value[0] NE NULL_CHAR)
         {
           CTSAMSG_print(ACF2_ARI_UNSUPPORTED_KEYWORD, msgs, NULL, dest,
                         unsupp_keywords[i].keyword);
           rc = ESA_FATAL;
           goto exit;
         };

       i++;
     };

     /*******************************************************
     * Check for UIDMASK match.                             *
     ********************************************************/
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "Checking UIDMASKs ...");

     /*******************************************************
     * Translate ACE Type into a regular UIDMASK            *
     ********************************************************/
     rc = Handle_ACE_Types (new_ace,
                            new_addinfo,
                            new_rule_uidmask,
                            msgs,
                            dest);

     if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     };

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "NEW rule UIDMASK=(%s)(%d)",
                    new_rule_uidmask, strlen(new_rule_uidmask));

     uid_error = FALSE;

     pair1 = ADDINFO_search ("UID",
                             ACF_ADDINFO_KWD_LEN,
                             ace_addinfo->pair,
                             ace_addinfo->num_pairs);

     if (pair1 EQ NULL)
       uid_error = TRUE;
     else
       if (pair1->value[0] EQ NULL_CHAR)
         uid_error = TRUE;

     if (uid_error)
     {
       CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                     dest, component,func,
                     "Resource rule entry must have a uidmask",
                     16,__LINE__);
       rc = ESA_FATAL;
       goto exit;
     };

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "CURR rule UIDMASK=(%s)(%d)",
                    pair1->value, strlen(pair1->value));

     *access_match = UIDMASKs_Match (pair1->value, new_rule_uidmask);
   };

   goto exit;

  rule_error:;
   CTSAMSG_print(ERR_INTERNAL2,msgs, NULL,
                 dest, component,func,
                 "Access rule entry must have a dsnmask",
                 16,__LINE__);
   rc = ESA_FATAL;

  exit:;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "access_env_match=(%d)",
                  *access_match);

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, rc);

   return rc;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Full_Masks_Match
 ******************************************************************
 * Description   : Recursive function to determine if two resource
 *                 masks match
 *
 * Input         : fmask1      - First (current) resource mask
 *                 fmask2      - Second (new) resource mask
 *
 * Return Value  : is_match
 *********************************************************************/
 static int Full_Masks_Match (char *fmask1,
                              char *fmask2)
 {
   static                 char func[]="Full_Masks_Match";

   QUALIFIER              q1, q2;
   char                   t1[ACF_RESOURCE_NAME_LEN+1]="";
   char                   t2[ACF_RESOURCE_NAME_LEN+1]="";
   char                   curr_fmask[ACF_RESOURCE_NAME_LEN+1]="";
   char                   full_dash_prefix[2];
   int                    is_match, iterate;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   is_match = FALSE;

   q1[0] = NULL_CHAR;
   q2[0] = NULL_CHAR;

   full_dash_prefix[0] = '-';
   full_dash_prefix[1] = NULL_CHAR;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "mask1(%s) mask2(%s)",
                  fmask1, fmask2);

   /*********************************************************
   * Extract first qualifier from each mask                 *
   **********************************************************/
   Get_First_Qualifier (q1, fmask1, sizeof(QUALIFIER));   /* PS0398 */
   Get_First_Qualifier (q2, fmask2, sizeof(QUALIFIER));   /* PS0398 */

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "q1=(%s) q2=(%s)",
                  q1, q2);

   /*********************************************************
   * Handle all cases where one or both masks end           *
   * q1 = curr rule entry qualifier                         *
   * q2 = new rule entry qualifier                          *
   **********************************************************/
   if (q1[0] EQ NULL_CHAR OR q2[0] EQ NULL_CHAR)
   {
     if (q1[0] NE NULL_CHAR)
     {
       if (strcmp (fmask1, full_dash_prefix) NE 0)
       {
         ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                        "NEW mask ended, CURR mask has more (not -)");
         is_match = FALSE;
         goto exit;
       };
     }
   /* BS2417 - replaced by following IF statement
     else
   */
     else if (q2[0] NE NULL_CHAR)                         /* BS2417 */
     {
       /* CURR mask ended, NEW mask not */
       is_match = FALSE;
       goto exit;
     };

     /* All other cases ... */
     is_match = TRUE;
     goto exit;
   };

   /*********************************************************
   * If CURRENT mask is '-', return with MATCH              *
   **********************************************************/
   if (strcmp (fmask1, full_dash_prefix) EQ 0)
   {
     is_match = TRUE;
     goto exit;
   };

  if (strcmp (q1, full_dash_prefix) NE 0)
  {
    if (Single_Qualifiers_Match (q1,q2,TRUE))
    {
       Strip_First_Qualifier (t1, fmask1);
       Strip_First_Qualifier (t2, fmask2);

       is_match = Full_Masks_Match (t1, t2);
    }
    else
      is_match = FALSE;

    goto exit;
  }
  else
  {
    Strip_First_Qualifier (t1, fmask1);
    strcpy (t2, fmask2);

    strcpy (curr_fmask, fmask2);

    iterate = TRUE;

    while (iterate)
    {
      is_match = Full_Masks_Match (t1, t2);

      if (NOT is_match)
      {
        Strip_First_Qualifier (t2, curr_fmask);

        if (t2[0] EQ NULL_CHAR)
        {
          is_match = FALSE;
          goto exit;
        }
        else
          strcpy (curr_fmask, t2);
      }
      else
        goto exit;
    }; /* While iterate */
  };

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, is_match);

   return is_match;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Single_Qualifiers_Match
 ******************************************************************
 * Description   : Check if two single qualifiers match
 *
 * Input         : q1          - first (current) qualifier
 *                 q2          - second (new) qualifier
 *                 dash_tests  - perform dash tests ?
 *
 * Return Value  : TRUE or FALSE
 *********************************************************************/
 static int Single_Qualifiers_Match (char *q1,
                                     char *q2,
                                     int   dash_tests)
 {
   static                 char func[]="Single_Qualifiers_Match";

   char                   q_curr[ACF2_RESRULE_KEY_SIZE];
   char                   q_new[ACF2_RESRULE_KEY_SIZE];
   char                   full_dash_prefix[2];
   int                    is_match, i;
   int                    end_check;

   is_match = TRUE;

   full_dash_prefix[0] = '-';
   full_dash_prefix[1] = NULL_CHAR;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "q1=(%s,%d) q2=(%s,%d) dash_tests(%d)",
                  q1, strlen(q1), q2, strlen(q2), dash_tests);

   if (dash_tests)
   {
     /*******************************************************
     * if current qualifier is '-', there is a match        *
     ********************************************************/
     if (strcmp (q1, full_dash_prefix) EQ 0)
       goto exit;

     /*******************************************************
     * if new qualifier is '-', there is no match           *
     ********************************************************/
     if (strcmp (q2, full_dash_prefix) EQ 0)
     {
       ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                      "NEW qualifier is a full mask. NO MATCH");
       is_match = FALSE;
       goto exit;
     };

     /*******************************************************
     * Build current, new qualifiers interpretation         *
     ********************************************************/
     Build_Interpreted_Mask (q_curr, sizeof(QUALIFIER), q1);
     Build_Interpreted_Mask (q_new, sizeof(QUALIFIER), q2);

     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "interpreted q1(%s,%d) q2=(%s,%d)",
                    q_curr, strlen(q_curr),
                    q_new, strlen(q_new));
   }
   else
   {
     strcpy (q_curr, q1);
     strcpy (q_new, q2);
   };

   /*********************************************************
   * If NEW qualifier is longer than our padded one,        *
   * then there is no match. Examples:                      *
   * curr=BACK**        new=BACKUP6                         *
   * curr=AB            new=ABC                             *
   **********************************************************/
   if (strlen(q_new) GT strlen(q_curr))
   {
     is_match = FALSE;
     goto exit;
   };

   /*********************************************************
   * Perform actual match check                             *
   **********************************************************/
   end_check = FALSE;

   for (i=0; (i LT strlen(q_curr)) AND (NOT end_check); i++)
   {
     switch (q_curr[i])
     {
       case '*':
         /* If q1 is all asteriks and our '*' is the first  */
         /* then q2 must have at least one character        */
         if ( (Is_All_Asteriks(q_curr)) AND (i EQ 0) AND
              (q_new[0] EQ NULL_CHAR) )
         {
           is_match = FALSE;
           goto exit;
         };

         break;

       default:
         /* We can do a char-to-char check only if shorter than q2 */
         if (i LT strlen(q_new))
         {
           if (q_curr[i] NE q_new[i])
           {
             is_match = FALSE;
             goto exit;
           };
         }
         else
         {
           is_match = FALSE;
           goto exit;
         };
         break;
     };
   };

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, is_match);

   return is_match;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: VOLs_Match
 ******************************************************************
 * Description   : Check if two VOLs match
 *
 * Input         : v1          - first (current) VOL
 *                 v2          - second (new) VOL
 *
 * Return Value  : TRUE or FALSE
 *********************************************************************/
 static int VOLs_Match (char *v1,
                        char *v2)
 {
   static                 char func[]="VOLs_Match";

   VOLSER                 v_curr, v_new;
   char                   full_dash_prefix[2];
   int                    is_match, i;
   int                    end_check;

   is_match = TRUE;

   full_dash_prefix[0] = '-';
   full_dash_prefix[1] = NULL_CHAR;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "v1=(%s,%d) v2=(%s,%d)",
                  v1, strlen(v1), v2, strlen(v2));

   /*********************************************************
   * if current VOL is '-', there is a match                *
   **********************************************************/
   if (strcmp (v1, full_dash_prefix) EQ 0)
     goto exit;

   /*********************************************************
   * if new VOL is '-', there is no match                   *
   **********************************************************/
   if (strcmp (v2, full_dash_prefix) EQ 0)
   {
     ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                    "NEW VOL is a full mask. NO MATCH");
     is_match = FALSE;
     goto exit;
   };

   /*********************************************************
   * Build current, new VOLs interpretation                 *
   **********************************************************/
   Build_Interpreted_Mask (v_curr, sizeof(ACF2_VOLSER_SIZE), v1);
   Build_Interpreted_Mask (v_new, sizeof(ACF2_VOLSER_SIZE), v2);

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "interpreted v1(%s,%d) v2=(%s,%d)",
                  v_curr, strlen(v_curr),
                  v_new, strlen(v_new));

   /*********************************************************
   * If NEW VOL is longer than our padded one,              *
   * then there is no match.                                *
   **********************************************************/
   if (strlen(v_new) GT strlen(v_curr))
   {
     is_match = FALSE;
     goto exit;
   };

   /*********************************************************
   * Perform actual match check                             *
   **********************************************************/
   end_check = FALSE;

   for (i=0; (i LT strlen(v_curr)) AND (NOT end_check); i++)
   {
     switch (v_curr[i])
     {
       case '*':
         break;

       default:
         /* We can do a char-to-char check only if shorter than v2 */
         if (i LT strlen(v_new))
         {
           if (v_curr[i] NE v_new[i])
           {
             is_match = FALSE;
             goto exit;
           };
         }
         else
         {
           is_match = FALSE;
           goto exit;
         };
         break;
     };
   };

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, is_match);

   return is_match;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: UIDMASKs_Match
 ******************************************************************
 * Description   : Check if two UIDMASKs match
 *
 * Input         : u1          - first (current) UIDMASK
 *                 u2          - second (new) UIDMASK
 *
 * Return Value  : TRUE or FALSE
 *********************************************************************/
 static int UIDMASKs_Match (char *u1,
                            char *u2)
 {
   static                 char func[]="UIDMASKs_Match";

   UIDMASK                object, mask;
   int                    compare_size, i, is_match;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   is_match = TRUE;

   /**************************************************************
    * Flud objects with asteriks to size of the longer object    *
    **************************************************************/
   compare_size = MAX(strlen(u1),strlen(u2));
   Reset_Field(object,compare_size+1,'*',u2);
   Reset_Field(mask,compare_size+1,'*',u1);

   ESA_DIAG_printf(ESA_COMP_ADDACE,DEBUG_SHOW_IMPORTANT,
                   "object=%s  len=%d mask=%s len=%d",
                   object, strlen(object), mask, strlen(mask));

   for (i=0; i LT compare_size ; i++)
   {
     switch(mask[i])
     {
       case '*':
           break;   /* skip to next char */

       case '-':    /* Treat - as match any only if last char,
                       else, treat it as any other char */
           if (i EQ strlen(mask)-1)
             break;
           /* continue with default processing if previous condition
              not met */

       default:
           if (object[i] NE mask[i])
             is_match = FALSE;
     };
   };

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, is_match);

   return is_match;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Handle_ACE_Types
 ******************************************************************
 * Description   : Return UIDMASK according to ACE type
 *
 * Input         : ace         - ace struct fields
 *                 addinfo     - ace ADDINFO fields
 *
 * Output        : ace_uidmask - ace uidmask
 *
 * Return Value  : ESA_RC
 *********************************************************************/
 static ESA_RC Handle_ACE_Types (ACE_rec_typ     *ace,
                                 ADDINFO_rec_ptr  addinfo,
                                 char            *ace_uidmask,
                                 CTSAMSG_HANDLE_rec_typ     *msgs,
                                 CTSAMSG_DEST_TABLE_rec_typ *dest)
 {
   static                 char func[]="Handle_ACE_Types";

   ONE_FIELD_rec_ptr      pair = NULL;
   ESA_RC                 rc = ESA_OK;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   if (ace->ace_type EQ ACE_TYPE_WORLD)
   {
     strcpy (ace_uidmask, "*");
   }
   /* IS10178 The following code is incorrect/unnecessary.
              The check about user name length is not needed because
              we have extracted the LID from the UID based on the
              LID_Offset and LID_Length.
              The check about an asterisk in the LID (which was
              extracted from the UID) is incorrect because there
              can be an asterisk in the LID of a permission.
              Finally, the call to Build_UIDMASK_User (which
              sets ace_uidmask to '************user_name') is also
              incorrect.  We will treat ACE_TYPE_USER exactly as
              we treat ACE_TYPE_GROUP.

   else if (ace->ace_type EQ ACE_TYPE_USER)
   {
     if (strlen(ace->user_name) GT ACF_USER_NAME_LEN)
     {
       CTSAMSG_print(ACF2_USER_NAME_TOO_LONG, msgs, NULL, dest,
                     ace->user_name, ACF_USER_NAME_LEN);
       rc = ESA_FATAL;
       goto exit;
     };

     if (strchr(ace->user_name, '*') NE NULL)
     {
       CTSAMSG_print(ACF2_INVALID_USER_NAME, msgs, NULL, dest,
                     ace->user_name);
       rc = ESA_FATAL;
       goto exit;
     };

     rc = Build_UIDMASK_User(ace->user_name,
                             ace_uidmask);

     if (rc NE ESA_OK)
     {
       CTSAMSG_print(ACF2_LID_NOT_IN_UID, msgs, NULL, dest);
       rc = ESA_FATAL;
       goto exit;
     };

     ace_uidmask[ACF2_UID_SIZE-1] = NULL_CHAR;
   }
   else if (ace->ace_type EQ ACE_TYPE_MASK)                          */
   /* IS10178 changing ace_type to ACE_TYPE_GROUP
   else if ( (ace->ace_type EQ ACE_TYPE_MASK) OR          // IS10178 //
             (ace->ace_type EQ ACE_TYPE_USER) )           // IS10178 */
   /*else if ((ace->ace_type EQ ACE_TYPE_GROUP) OR/*IS10178  BS10121*/
   else if ( (ace->ace_type EQ ACE_TYPE_MASK) OR          /* BS10121*/
             (ace->ace_type EQ ACE_TYPE_USER) )           /* IS10178 */
   {
     pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs);

     if (pair EQ NULL)
       strcpy (ace_uidmask, "*");
     else
       strcpy (ace_uidmask, pair->value);
   }
   else
   {
     CTSAMSG_print(ACF2_INVALID_ACE_TYPE, msgs, NULL, dest);
     rc = ESA_FATAL;
     goto exit;
   };

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, rc);

   return rc;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Build_Interpreted_Mask
 ******************************************************************
 * Description   : Build interpreted mask by replacing all
 *                 dash characters used as masks
 *
 * Input         : qin          - mask
 *                 qmax         - max mask size
 *
 * Output        : qout         - interpreted mask
 *
 * Return Value  : None
 *********************************************************************/
 static void Build_Interpreted_Mask (char *qout,
                                     int   qmax,
                                     char *qin)
 {
   static                 char func[]="Build_Interpreted_Mask";

   int                    end_build, end_of_mask, i;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   Reset_Field(qout, qmax, '*', NULL);

   end_build = FALSE;
   end_of_mask = 0;

   for (i=0; (i LT strlen(qin)) AND (NOT end_build); i++)
   {
     switch (qin[i])
     {
       case '-':
         /* If dash is last then it means 0 to qmax chars   */
         /* BA- will be interpreted as BA******             */
         if ( i GE (strlen(qin)-1) )
         {
           end_build = TRUE;
           end_of_mask = 0;
         }
         else
           /* Else a dash is literally a dash */
           qout[i] = qin[i];
         break;

       default:
         /* Regular character or '*'. Just copy it */
         qout[i] = qin[i];
         break;
     };

     if (NOT end_build)
       end_of_mask = i+1;
   };

   if (end_of_mask NE 0)
     qout[end_of_mask] = NULL_CHAR;

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func, 0);

 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Is_All_Asteriks
 ******************************************************************
 * Description   : Check if a qualifier is all asteriks
 *
 * Input         : q1          - qualifier
 *
 * Return Value  : TRUE or FALSE
 *********************************************************************/
 static int Is_All_Asteriks (char *q1)
 {
   static                 char func[]="Is_All_Asteriks";

   int                    all_asteriks, i;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   all_asteriks = TRUE;

   for (i=0; i LT strlen(q1); i++)
   {
     if (q1[i] NE '*')
     {
       all_asteriks = FALSE;
       goto exit;
     };
   };

  exit:;

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                 func, all_asteriks);

   return all_asteriks;
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Get_First_Qualifier
 ******************************************************************
 * Description   : Extract first qualifier from given mask
 *
 * Input         : fmask       - full mask
 *                 maxsize     - max size of qualifier (PS0398)
 *
 * Output        : qual        - first qualifier
 *
 * Return Value  : none
 *********************************************************************/
 void Get_First_Qualifier (char *qual,
                           char *fmask,
                           int   maxsize)                 /* PS0398 */
 {
   static                 char func[]="Get_First_Qualifier";

   char                  *qual_pos;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "mask=(%s)",
                  fmask);

   Reset_Field(qual, maxsize, NULL_CHAR, NULL);           /* PS0398 */

   if (fmask EQ NULL)
     goto exit;

   if (fmask[0] EQ NULL_CHAR)
     goto exit;

   qual_pos = strchr (fmask, '.');

   if (qual_pos EQ NULL)
   {
     strcpy (qual, fmask);
     goto exit;
   };

   strncpy ( qual, fmask, (qual_pos-fmask) );

  exit:;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "qualifier=(%s) len(%d)",
                  qual, strlen(qual));

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func, 0);
 }
 /* End of WS2358 */

/* WS2358 */
/******************************************************************
 * Procedure Name: Strip_First_Qualifier
 ******************************************************************
 * Description   : Strip first qualifier from given mask
 *
 * Input         : fmask       - full mask
 *
 * Output        : trail       - Stripped mask
 *
 * Return Value  : none
 *********************************************************************/
 void Strip_First_Qualifier (char *trail,
                             char *fmask)
 {
   static                 char func[]="Strip_First_Qualifier";

   char                  *qual_pos;

   ESA_DIAG_enter(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func );

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "mask=(%s)",
                  fmask);

   Reset_Field(trail, sizeof(ACF_RESOURCE_NAME_LEN), NULL_CHAR, NULL);

   if (fmask EQ NULL)
     goto exit;

   if (fmask[0] EQ NULL_CHAR)
     goto exit;

   qual_pos = strchr (fmask, '.');

   if (qual_pos EQ NULL)
     goto exit;

   strcpy (trail, qual_pos+1);

  exit:;

   ESA_DIAG_printf(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT,
                  "stripped mask=(%s) len(%d)",
                  trail, strlen(trail));

   ESA_DIAG_exit(ESA_COMP_ADDACE, DEBUG_SHOW_IMPORTANT, func, 0);
 }
 /* End of WS2358 */

/**************************************************************
* PROCEDURE NAME : Get_Compiler_Messages                      *
*                                                             *
* DESCRIPTION    : Return compiler messages                   *
**************************************************************/
static void Get_Compiler_Messages(CTSAMSG_HANDLE_rec_typ     *msgs,
                                  CTSAMSG_DEST_TABLE_rec_typ *dest)
{

  static char func[] = "Get_Compiler_Messages";

 /* Variables */

  ESA_RC rc;
  char   line[256];
  char   file_name[80];
  FILE   *shell_output_file = NULL;

 /*
  *   Initialization
  */

  ESA_DIAG_enter(ESA_COMP_UPDRES, 1, func );

 /*
  *   Check ddname existance
  */
  /* IS10174
  rc = OS_MVS_ddinfo("ACF2MSG ", file_name, TRUE, dest, msgs);  */
  rc = OS_MVS_ddinfo("ACF2MSG ", file_name, TRUE,        /* IS10174 */
                     dest, msgs, 0);                     /* IS10174 */
  if (rc NE ESA_OK)
     goto exit;

 /*
  *   Open file
  */

  /* SAS2IBMT
  shell_output_file = fopen("ACF2MSG ", FILE_OPEN_READ_TEXT);        */
  shell_output_file = fopen("DD:ACF2MSG", FILE_OPEN_READ_TEXT);
  if (shell_output_file EQ NULL) {
      CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                    "open","TSO services",
                    "ACF2MSG ", strerror(errno));
      goto exit;
  }

  /* BS2362 - deleted
  fgets(line, sizeof(line), shell_output_file);
  fgets(line, sizeof(line), shell_output_file);
  */

  fgets(line, sizeof(line), shell_output_file);
  Trim(line);

  while (NOT feof(shell_output_file))
  {
    /* BS2362 - Instead of always skipping first two lines */
    if ( (line[0] NE NULL_CHAR) AND
         (strstr (line, "ACF70010") EQ NULL) AND
         (strstr (line, "ACF COMPILER ENTERED") EQ NULL) )
      CTSAMSG_print(ACF2_OUTPUT_LINE,   msgs, NULL, dest,
      /* IS10178    line+1);                                         */
                    line);                                /* IS10178 */

    fgets(line, sizeof(line), shell_output_file);
    Trim(line);
  };

 /*
  *   Termination
  */

  exit: ;

  if (shell_output_file NE NULL)
     fclose(shell_output_file);

  ESA_DIAG_exit(ESA_COMP_UPDRES, 1, func, ESA_OK);

}

/**************************************************************
* PROCEDURE NAME : Is_Line_Continued                          *
*                                                             *
* DESCRIPTION    : Return if a line is continued on next line *
*                                                             *
* INPUT          : text line                                  *
*                                                             *
* RETURN VALUE   : TRUE or FALSE                              *
**************************************************************/
static int Is_Line_Continued(char *curr_line)
{

  static char func[] = "Is_Line_Continued";

 /* Variables */

  int j, cont;

 /*
  *   Initialization
  */

  ESA_DIAG_enter(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func );

  cont = FALSE;

  for (j=71; (j GE 0) AND (NOT cont); j--)
  {
    if (curr_line[j] EQ '-')
      cont = TRUE;
    else if (curr_line[j] NE ' ')
      break;
  };

  ESA_DIAG_exit(ESA_COMP_GETRES, DEBUG_SHOW_IMPORTANT, func,cont);

  return cont;

}
