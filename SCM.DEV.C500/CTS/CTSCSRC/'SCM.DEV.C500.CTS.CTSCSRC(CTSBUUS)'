 /**************************************************************
 *                                                             *
 * Title            : Update A User (ACF2)                     *
 *                                                             *
 * File Name        : CTSBUUS.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 20/07/97                                 *
 *                                                             *
 * Description      : Update ACF2 User                         *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 * - The CHANGE command generated contains the object type:    *
 *   LID. This is not valid ACF2 command. It is intended to be *
 *   prepared by the command invocation REXX (ctsbcmd).        *
 *                                                             *
 * - The Update Event is checked not to disconnect a User from *
 *   a Group. This will be relevant only where ACF2 virtual    *
 *   groups are implemented. The Check is bypassed if Update API *
 *   is called with a special ADDINFO field ordering to bypass *
 *   updates.                                                  *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------- -------------------------------- *
 * BS2306   Guy      28/10/97 Added dest+msgs parms            *
 * BS2311   Guy      11/11/97 Issue correct message            *
 * PS0323   Guy      28/10/98 Support update of MUL. VAL fields*
 * PS0339   Guy      26/11/98 Return connections of all user   *
 *                            UIDs if MULTI VALUED             *
 * PS0354   Guy      09/12/98 Check Disconnect from            *
 *                            Multivalued field                *
 * PS0364   Guy      24/12/98 Remove EMULATE stuff             *
 * ws2370   RamiK    01/01/02 add support for specific user    *
 *                            profiles                         *
 * ws2459   Yonatan  03/03/02 do not issue pswd-exp for all adm*
 * BS2513   RamiK    17/03/01 added check of user existance    *
 *                            before updating user profiles    *
 * ws2456   Yonatan  17/02/02 support for VERIFY_PWD flag from *
 *                            ESS                              *
 * BS2556   AvnerL   14/10/02 send acf2 original error msg     *
 * IS10005  AvnerL   08/05/07 Support RU_LOCKED & RU_SUSPENDED.*
 * WS10005  AvnerL   17/07/07 Compile with updated UP_kdts.    *
 * WS10007  AvnerL   29/08/07 handle expire even without pswd  *
 * BS10028  Nurity   23/02/12 Create Account fails after       *
 *                            upgrade to 3.2.02.               *
 * BS10029  Nurity   12/03/12 Copy from 3.2.02 in order to     *
 *                            apply BS10028.                   *
 * IS10121  AvnerL   01/07/14 Fix addinfo printed.             *
 * IS10147A SeligT   18/06/17 Add support for password phrase  *
 * IS10147C Kailas   06/07/17 Ignore field if '3' or '/'       *
 * IS10174  NuritY   15/01/18 Dynamic EXECOUT support.         *
 * IS10182  AvnerL   17/07/19  S0C4/S0C1 due to DIAG vsprintf  *
 * WS10076A AvnerL   19/01/20 Add admin_params 2 ACF2_Get_Group*
 * BS10120  AvnerL   29/01/23 Support PWPHRASE with UpdateUser *
 * WS10082  MauriC   07/11/22 Recompile for new ADDINFO macros *
 * WS10090  Nurity   01/09/24 Allow uid collision              *
 **************************************************************/

 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDLIB
 #include   STDIO
 #include   STRING

 /*
  *   ESA include files
  */

 #include ESA_DIAG
 #include ESA_API
 #include ESA_API_CODES

 #include MVS_OS_CLI

 #include API_ADDINFO
 #include API_AUTH

 #include ACF2
 #include ACF2_CODES

 static void ACF2_Search_MULTI (ADDINFO_rec_typ *);       /* PS0323 */

 static char component[] = "CTSBUUS";

 /*
  *     MKT for Insert User
  *         (Mandatory Keywords Table)
  */

 static ADDINFO_MKTE_rec_typ mkt[] = {
    "" };      /* a null string indicate end-of-rkt */

 /*
  *     RKT for Inser User
  *         (Reserved Keywords Table)
  */

 static ADDINFO_RKTE_rec_typ rkt[] = {
    "SUSPEND",
    "CANCEL"
    "" };      /* a null string indicate end-of-rkt */


 /*
  *     KDT for Insert User Command
  *         (Keyword Decscription Table)
  *
  *     This table is partial since it is dynamically filled from actual
  *     ACF2 field definitions generated in the site
  */


 static ADDINFO_KDTE_rec_typ kdts[] =      {

  /*                                                            */
  /* keyword             type   negative       value delimiters */
  /*                             value                          */
  /* =================== ====== ============== ================ */

    {"@Identification" , KDT_IGN , ""           ,""    ,""    },
    {"@Priviliges"     , KDT_IGN , ""           ,""    ,""    },
    {"@Cancel_Suspend" , KDT_IGN , ""           ,""    ,""    },
    {"@Functions"      , KDT_IGN , ""           ,""    ,""    },
    {"@Facilities"     , KDT_IGN , ""           ,""    ,""    },
    {"@Access"         , KDT_IGN , ""           ,""    ,""    },
    {"@Password"       , KDT_IGN , ""           ,""    ,""    },
    {"@Pswd_History"   , KDT_IGN , ""           ,""    ,""    },
    {"@UADS_TSO"       , KDT_IGN , ""           ,""    ,""    },
    {"@CICS"           , KDT_IGN , ""           ,""    ,""    },
    {"@IDMS"           , KDT_IGN , ""           ,""    ,""    },
    {"@MUSASS"         , KDT_IGN , ""           ,""    ,""    },
    {"@Restrictions"   , KDT_IGN , ""           ,""    ,""    },
    {"@DFP"            , KDT_IGN , ""           ,""    ,""    },
    {"LID"             , KDT_IGN , ""           ,""    ,""    },
    {"REP"             , KDT_FLG , ""           ,""    ,""    },
    {ACF2_BYPASS_DISCONNECT_CHECK , KDT_IGN , "" ,""   ,""    },
    {"REVOKE-TYPE"      , KDT_IGN , ""           ,""    ,""      },
    {"CICS-SWITCH"      , KDT_IGN , ""           ,""    ,""      },
    {"CICS.FORCE"       , KDT_IGN , ""           ,""    ,""      },
    {"CICS.OPCLASS"     , KDT_IGN , ""           ,""    ,""      },
    {"CICS.OPIDENT"     , KDT_IGN , ""           ,""    ,""      },
    {"CICS.OPPRTY"      , KDT_IGN , ""           ,""    ,""      },
    {"CICS.TIMEOUT"     , KDT_IGN , ""           ,""    ,""      },
    {"DCE-SWITCH"       , KDT_IGN , ""           ,""    ,""      },
    {"DCE.UUID"         , KDT_IGN , ""           ,""    ,""      },
    {"DCE.DCENAME"      , KDT_IGN , ""           ,""    ,""      },
    {"DCE.HOMEUUID"     , KDT_IGN , ""           ,""    ,""      },
    {"DCE.HOMECELL"     , KDT_IGN , ""           ,""    ,""      },
    {"DCE.AUTOLOG"      , KDT_IGN , ""           ,""    ,""      },
    {"KERB-SWITCH"      , KDT_IGN , ""           ,""    ,""      },
    {"KERB.KERBNAME"    , KDT_IGN , ""           ,""    ,""      },
    {"KERB.KERB-VIO"    , KDT_IGN , ""           ,""    ,""      },
    {"KERB.MAXTKTLF"    , KDT_IGN , ""           ,""    ,""      },
    {"KERBLINK-SWITCH"  , KDT_IGN , "",""    ,""      },/*WS10005*/
    {"KERBLINK.KBLKNAME", KDT_IGN , "",""    ,""      },/*WS10005*/
    {"LANGUAGE-SWITCH"  , KDT_IGN , ""           ,""    ,""      },
    {"LANGUAGE.PRIMARY" , KDT_IGN , ""           ,""    ,""      },
    {"LANGUAGE.SECONDRY", KDT_IGN , ""           ,""    ,""      },
    {"LINUX-SWITCH"  , KDT_IGN , ""  ,""    ,""      }, /*WS10005*/
    {"LINUX.LINUXGRP" , KDT_IGN , "" ,""    ,""      }, /*WS10005*/
    {"LINUX.LINUXHOM" , KDT_IGN , "" ,""    ,""      }, /*WS10005*/
    {"LINUX.LINUXNAM" , KDT_IGN , "" ,""    ,""      }, /*WS10005*/
    {"LINUX.LINUXPGM" , KDT_IGN , "" ,""    ,""      }, /*WS10005*/
    {"LINUX.LINUXUID" , KDT_IGN , "" ,""    ,""      }, /*WS10005*/
    {"LNOTES-SWITCH"    , KDT_IGN , ""           ,""    ,""      },
    {"LNOTES.SNAME"     , KDT_IGN , ""           ,""    ,""      },
    {"NDS-SWITCH"       , KDT_IGN , ""           ,""    ,""      },
    {"NDS.UNAME"        , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW-SWITCH"   , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.IC"       , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.CONSNAME" , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.SECCTL"   , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.MSGRECVR" , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.NGMFADMN" , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.NTVCLASS" , KDT_IGN , ""           ,""    ,""      },
    {"NETVIEW.DOMAINS"  , KDT_IGN , ""           ,""    ,""      },
    {"OMVS-SWITCH"      , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.UID"         , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.HOME"        , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.OMVSPGM"     , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.CPUTIME"     , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.ASSIZE"      , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.FILEPROC"    , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.MEMLIMIT"    , KDT_IGN , "" ,""    ,""      },/*WS10005*/
    {"OMVS.PROCUSER"    , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.SHMEMMAX"    , KDT_IGN , "" ,""    ,""      },/*WS10005*/
    {"OMVS.THREADS"     , KDT_IGN , ""           ,""    ,""      },
    {"OMVS.MMAPAREA"    , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM-SWITCH"  , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.STORAGE" , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.AUTH"    , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.AUTO"    , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.MFORM"   , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.MSGLEVEL", KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.MONITOR" , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.ROUTCODE", KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.LOGCMD"  , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.MIGID"   , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.DOM"     , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.UD"      , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.KEY"     , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.CMDSYS"  , KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.ALTGROUP", KDT_IGN , ""           ,""    ,""      },
    {"OPERPARM.OPERMSCP", KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR-SWITCH"  , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WANAME"  , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WABLDG"  , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WADEPT"  , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WAROOM"  , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WAADDR1" , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WAADDR2" , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WAADDR3" , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WAADDR4" , KDT_IGN , ""           ,""    ,""      },
    {"WORKATTR.WAACCNT" , KDT_IGN , ""           ,""    ,""      },
    /* ws2459 - how to reset */
    {"EXPIRED"          , KDT_IGN , ""           ,""    ,""      },
    {"NOEXPIRED"        , KDT_IGN , ""           ,""    ,""      },
    /* ws2459 */
    /* ws2456 pass VERIFY_PWD in local addinfo to updpass             */
    {"VERIFY_PWD"         ,KDT_IGN ,""                   ,""  , " " },
    /* ws2456 */
    {"RU-LOCKED"          ,KDT_IGN ,""                   ,""  , " " },
    {"RU-SUSPENDED"       ,KDT_IGN ,""                   ,""  , " " },
    /* add support in PWPHRASE and 2 other fields    BS10120       */
    {"PWPHRASE"           ,KDT_KEY ,""                   ,"(" , ")" },
    {"PSWD-EXP"        , KDT_FLG , "NOPSWD-EXP" ,""    ,""    },
    {"PWP-EXP"         , KDT_FLG , "NOPWP-EXP"  ,""    ,""    },
    {""          , KDT_KEY ,  ""                ,""    ,""    },
    };                    /* PS0323 - Added REP keyword (FLAG) */

 /**************************************************************
 * start ws2370                                                *
 **************************************************************/
 static ADDINFO_KDTE_rec_typ empty_kdt[] =      {

  /*                                                            */
  /* keyword             type   negative       value delimiters */
  /*                             value                          */
  /* =================== ====== ============== ================ */

   {""                     ,KDT_FLG ,""            ,""   ,"" }

   };

 /**************************************************************
 * end ws2370                                                  *
 **************************************************************/
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : CTSUpdUser                                 *
 *                                                             *
 * DESCRIPTION    : Update a ACF2 user                         *
 *                                                             *
 * INPUT          : User, addinfo, admin                       *
 *                                                             *
 * OUTPUT         : err                                        *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC CTSUpdUser (USER_PARAMS_rec_typ  * user_params,
                    ADDINFO_rec_typ      * addinfo,
                    ADMIN_PARAMS_rec_typ * admin_params,
                    ERR_STRUCT_rec_typ   * err)
 {

   static char                func[]="CTSUpdUser";

  /*
   *   Static Variables
   */

   static ADDINFO_KDTE_rec_ptr kdt = NULL;

  /*
   *   Variables
   */

   ESA_RC                     rc = ESA_OK;
   ESA_RC                     check_rc, saved_rc;
   ACF2_API_Return_Codes      ACF2_rc = ACF2_OK;
   char                       cmd[MAX_API_ST];
   ADDINFO_rec_ptr            laddinfo = NULL;
   ADDINFO_rec_ptr            laddinfo1= NULL;
   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;
   UIDMASK modified_user_uid="";
   UIDMASK current_user_uid="";
   UIDMASK ALL_ASTERISK;
   char    current_user[ACF2_LID_SIZE]="";
   char    errmsg[256]="";
   char    New_UIDs_List[9600];                           /* PS0354 */
   char    Current_UIDs_List[9600];                       /* PS0354 */
   char    multi_field_name[20]="";                       /* PS0354 */
   UG_typ  cgroup="";
   GDB_Codes GDB_rc = GDB_OK;
   int     multi_field_offset=0;                          /* PS0354 */
   int     MVF_exists;                                    /* PS0354 */
   int i;
   ADDINFO_rec_ptr            UP_addinfo = NULL; /* ws2370 */
   char                       prefix[256] = "";  /* ws2370 */
   ONE_FIELD_rec_ptr          pair = NULL;       /* ws2370 */
   ONE_FIELD_rec_ptr            cpair;           /* ws2456 */
   ACF2_PARAMS_rec_typ * params_ptr = NULL;               /* IS10005 */
   int  Expire_Password = 0;                              /* WS10007 */
   int  NoExpire_Password = 0;                            /* WS10007 */
   int  password_specified = 0;                           /* BS10028 */
   int  verify_password = 0;                              /* BS10028 */
   int  uid_match = 0;       /* not 0 when UID changed       WS10090 */
   int  conmsg_uid_len = 0;                               /* WS10090 */
   char * conmsg_uid_2prt = NULL;                         /* WS10090 */
   UIDMASK conmsg_uid = "";                               /* WS10090 */
   int  conmsg_issued = FALSE;                            /* WS10090 */

   ESA_DIAG_enter(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;
   params_ptr = admin_params->apiinit_handle;             /* WS10090 */

  Reset_Field(ALL_ASTERISK,sizeof(ALL_ASTERISK),'*',NULL);

  /*
   *   Open GDB for ReadOnly (Group Processing)
   */

  if (GDB_Set_Mode(GDB_ReadOnly,admin_params,err) NE GDB_OK)
   {
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
            "Open GDB for READ failed", 16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
   };

  /*
   *   Update KDT Table with all modifiable fields (build NO part
   *   of KDT)
   */

   if (kdt EQ NULL)
     kdt = ACF2_Update_KDT(kdts,
                     ACF2_Get_ReadWrite_Fields_and_NoFlag,
                     ACF2_KDT_Merge,
                     admin_params);

   /* BS10028 - print the kdt content                                 */
   for(i=0; kdt[i].kwd[0] NE NULL_CHAR;i++)                  /*BS10028*/
   {                                                         /*BS10028*/
       ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR, /*BS10028*/
              "kwd=%s nkwd=%s",                              /*BS10028*/
              kdt[i].kwd, kdt[i].neg_kwd);                   /*BS10028*/
   }                                                         /*BS10028*/

   /* BS10028 - print the addinfo at entry                            */
   ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,     /*BS10028*/
                  "addinfo dump at entry");                  /*BS10028*/
   if (ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE DEBUG_SHOW_REGULAR)
       ADDINFO_dump(addinfo,1);                              /*BS10028*/

  /*
   *   Check that Reserved Keywords were not used
   */

   if (ADDINFO_rkt_check(func,1,&addinfo,rkt, dest, msgs) NE ESA_OK)
     {
      rc = ESA_FATAL;
      goto exit;
     };

  /*
   *   Obtain a local addinfo buffer
   */

   if (ADDINFO_alloc(func,ACF2_ADDINFO,&laddinfo, dest, msgs) NE ESA_OK)
    {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
               "laddinfo alloc failed", 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
    };

   if (ADDINFO_alloc(func,ACF2_ADDINFO,&laddinfo1,dest, msgs) NE ESA_OK)
    {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
               "laddinfo1 alloc failed", 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
    };
   /* start ws2370 */
   if (ADDINFO_alloc(func,ACF2_ADDINFO,&UP_addinfo,dest,msgs) NE ESA_OK)
    {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
               "UP_addinfo alloc failed", 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
     };
   /* end ws2370 */

   ADDINFO_copy(laddinfo,addinfo);                         /* BS10028 */

   /******************** WS10007 starts ********************************
      Handle expired and noexpired keywords even when password is not
      set from ESS side.
      It's legitimate to issue CHA userid PSWD-EXP or
      CHA user NOPSWD-EXP commands (without changing passwords).

      EXPIRED and NOEXPIRED are handled only when they are EQ 'Y' !  */

    pair = ADDINFO_search ( "EXPIRED", ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
    if ( pair NE NULL AND
       ( strcmp(pair->value,KWD_FLAG_ON) EQ 0) )
    {
       /* BS10028 - not needed because addinfo is copied to laddinfo
       ADDINFO_insert(TYPE_1A,"EXPIRED", KWD_FLAG_ON, laddinfo,
                     ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                     UNIQUE);                                     */
       Expire_Password = 1;
       /*admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_UPDUSER,3,*/
       ESA_DIAG_printf(ESA_COMP_UPDUSER,3,             /*IS10182*/
         "EXPIRED = Y received from IIQ/IDN");
    }
    pair = ADDINFO_search ( "NOEXPIRED", ACF_ADDINFO_KWD_LEN,
                           addinfo->pair,
                           addinfo->num_pairs );
    if ( pair NE NULL AND
       ( strcmp(pair->value,KWD_FLAG_ON) EQ 0) )
    {
       /* BS10028 - not needed because addinfo is copied to laddinfo
       ADDINFO_insert(TYPE_1A,"NOEXPIRED", KWD_FLAG_ON, laddinfo,
                     ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                     UNIQUE);                                     */
       NoExpire_Password = 1;
       /*admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_UPDUSER,3,*/
       ESA_DIAG_printf(ESA_COMP_UPDUSER,3,              /*IS10182*/
         "NOEXPIRED = Y received from IIQ/IDN");
    }
   /******************** WS10007 ends *******************************/

   /*  BS10028 - analyze Verify_Password                            */
    cpair = ADDINFO_search ( "VERIFY_PWD", ACF_ADDINFO_KWD_LEN,
                              addinfo->pair,
                              addinfo->num_pairs );
    if (cpair NE NULL)
     {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 2,
                      "VERIFY_PWD=%s",cpair->value);
      verify_password = 1;
     }

   /* BS10028 - check is passwsord specified                         */
   if ( (strcmp(user_params->passwd, BACKSLASH_STR) NE 0)  /*BS10028*/
    AND (strcmp(user_params->passwd, BACKSLASH_ALT) NE 0) )/*IS10147C*/
     password_specified = 1;                                /*BS10028*/

   /*
    * Set Password
    */

   /*  BS10028 - process Verify_Password separately
   if ( strcmp(user_params->passwd, BACKSLASH_STR) NE 0 AND
        verify_password)                                     * WS10007*/
   if (password_specified AND verify_password)              /*BS10028*/
     {
      /*admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_UPDUSER,3,*/
      ESA_DIAG_printf(ESA_COMP_UPDUSER,3,             /*IS10182*/
           "password <%c> and verify_password <%d> from IIQ/IDN",
            user_params->passwd, verify_password);
      /* ws2456 - start */
         rc = CTSUpdPassword (user_params, laddinfo, admin_params, err);
         goto exit;
      }
   else
     /* BS10028 - process password / EXPIRE / NOEXPIRE                *
     if ( strcmp(user_params->passwd, BACKSLASH_STR) NE 0 OR
          /* Calls CTSUpdPassword when Expired or NoExpired    WS10007*
          Expire_Password OR                                 * WS10007*
          NoExpire_Password)                                 * WS10007*/
     if (password_specified OR                              /* BS10028*/
         Expire_Password   OR                               /* BS10028*/
         NoExpire_Password)                                 /* BS10028*/
       {
        /*admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_UPDUSER,3,*/
        ESA_DIAG_printf(ESA_COMP_UPDUSER,3,             /*IS10182*/
         "password <%c> or expired <%d> or noexpired <%d> from IIQ/IDN",
          user_params->passwd,Expire_Password,
          NoExpire_Password);                               /*WS10007*/
         /* ws2456 - end */
        /* ws2459 start - pass the EXPIRED keyword to UpdPassword */
        /* WS10007 - done in any case - before the if             *
        pair = ADDINFO_search ( "EXPIRED", ACF_ADDINFO_KWD_LEN,
                               addinfo->pair,
                               addinfo->num_pairs );
        if ( pair NE NULL)
           ADDINFO_insert(TYPE_1A,"EXPIRED", pair->value, laddinfo,
                         ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                         UNIQUE);
        pair = ADDINFO_search ( "NOEXPIRED", ACF_ADDINFO_KWD_LEN,
                               addinfo->pair,
                               addinfo->num_pairs );
        if ( pair NE NULL)
           ADDINFO_insert(TYPE_1A,"NOEXPIRED", pair->value, laddinfo,
                         ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                         UNIQUE);
        /* WS10007 - done in any case - before the if             *
        /* ws2459 end */


        /* BS10028 - start                                           */
        /* Request CTSUpdPassword to append the password-related
         * parameers to the addinfo.                                 */
        ADDINFO_insert(TYPE_1A,"CTSBUPS_RETURN_KEYWORDS", "A",
                       laddinfo,
                       ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                       UNIQUE);

        /*indicate to CTSUpdPass the caller is CTSUpdUser BS10120*/
        ADDINFO_insert(TYPE_1A,"CTSBUPS_CALLER", "UpdateUser",
                       laddinfo,
                       ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                       UNIQUE);                   /*BS10120*/

        /* Print the addinfo passed to CTSUpdPassword               */
        ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,
                       "laddinfo dump before calling CTSUpdPassword");
        if (ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE
                                                   DEBUG_SHOW_REGULAR)
        /* IS10121 addinfo_dump(addinfo,1); */
            ADDINFO_dump(laddinfo,1);                    /* IS10121 */
        /* BS10028 - end                                            */

        rc = CTSUpdPassword (user_params, laddinfo, admin_params, err);

        /* BS10028 - print the addinfo after call to CTSUpdPassword */
        ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,
                       "laddinfo dump after calling CTSUpdPassword");
        if (ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE
                                                   DEBUG_SHOW_REGULAR)
            /* IS10121 ADDINFO_dump(addinfo,1); */
            ADDINFO_dump(laddinfo,1);                    /* IS10121 */
        /* BS10028 - end                                            */

        if (rc NE ESA_OK)
         {
           rc = ESA_FATAL;
           goto exit;
         };

        ADDINFO_delete(laddinfo, "CTSBUPS_RETURN_KEYWORDS"); /*BS10028*/
        ADDINFO_delete(laddinfo, "CTSBUPS_CALLER");          /*BS10120*/

       };  /* End of password update */


   /*  BS10028 -  laddinfo now contains the updated list of keywords.
    *             use laddinfo1 from now on as a work addinfo.

    *
    * Restore laddinfo to original values
    *
   ADDINFO_empty(laddinfo);
   ADDINFO_copy(laddinfo,addinfo);
                                                                  */
   ADDINFO_empty(laddinfo1);                                /*BS10028*/
   ADDINFO_copy(laddinfo1,addinfo);                         /*BS10028*/

   /*
    * Revoke / Restore User
    */

   /* BS10028
   rc = CTSRevokeUser(user_params, laddinfo, admin_params, err);     */
   rc = CTSRevokeUser(user_params, laddinfo1,               /*BS10028*/
                      admin_params, err);                   /*BS10028*/
      if (rc NE ESA_OK)
       {
         rc = ESA_FATAL;
         goto exit;
       };

  /* BS10028 - do not change laddinfo as it contains the updated
   *           list of keywords.  Empty laddinfo1 for further use.

   *
   * Restore laddinfo to original values
   *
  ADDINFO_empty(laddinfo);
  ADDINFO_copy(laddinfo,addinfo);                                    */
  ADDINFO_empty(laddinfo1);                                 /*BS10028*/

  /*
   *   Check User does not get disconnected from groups due to UID
   *   fields update
   */

  /*
   *   Preliminary Check: Is there a flag to bypass this check (i.e.
   *   Update was called from InsertConnection/DeleteConnection API)
   */

  if (ADDINFO_search(ACF2_BYPASS_DISCONNECT_CHECK,
                     ACF_ADDINFO_KWD_LEN,
                     addinfo->pair,
                     addinfo->num_pairs) NE NULL)
     goto Skip_Disconnect_Check;

  /*
   *   Calculate User UID string based on the Updated fields
   *   (set every Non-Updated UID field to '*')
   */
  rc = Calc_User_UID_String(user_params->user,            /* PS0354 */
                            laddinfo,
                            modified_user_uid,
                            New_UIDs_List,                /* PS0354 */
                            '*',
                            admin_params);                /*bs2556*/

  if (rc NE ESA_OK)                                       /* PS0354 */
    goto exit;                                            /* PS0354 */

  /*
   *   If Any UID field was Updated
   */
  MVF_exists = UID_Contains_MULTI (multi_field_name,      /* PS0354 */
                                   &multi_field_offset);  /* PS0354 */

  if ( (MVF_exists) OR                                    /* PS0354 */
       (strcmp(modified_user_uid,ALL_ASTERISK) NE 0) )
   {
   /*
    *   Get User Current UID (it will be used to establish currently
    *   connected groups)
    */
    ACF2_rc = ACF2_Get_User_UID(user_params->user,
                                current_user_uid,
                                current_user,
                                "",
                                Current_UIDs_List,        /* PS0354 */
                                laddinfo1,
                                admin_params);            /*bs2556*/
    if (ACF2_rc NE ACF2_OK)

     /* **BS2311 START** */

     if (ACF2_rc EQ ACF2_Not_Found)
     {
       CTSAMSG_print(ERR_NO_USER,msgs,NULL,dest,user_params->user);
       rc = ESA_FATAL;
       goto exit;
     }
     else

     /* **BS2311 END** */

     {
       CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                     "Get User UID failed", 16,__LINE__);
       rc = ESA_FATAL;
       goto exit;
     };

   if (Current_UIDs_List[0] EQ NULL_CHAR)                 /* PS0354 */
     strcpy (Current_UIDs_List, current_user_uid);        /* PS0354 */

   /*
    *   Check Collision of the Virtual Group with the currently
    *   connected groups of the user (user_uid used as filter)
    */
    if (NOT MVF_exists)                                   /* PS0354 */
    {                                                     /* PS0354 */
      for (i=0;i LT ACF2_UID_SIZE-1;i++)
       if (modified_user_uid[i] EQ '*')
        modified_user_uid[i] = current_user_uid[i];

     uid_match = strcmp(current_user_uid, modified_user_uid);/*WS10090*/
      /* WS10090  };                                * PS0354 *    */
    }                                                     /* WS10090 */
    else                                                  /* WS10090 */
     uid_match = strcmp(Current_UIDs_List, New_UIDs_List); /* WS10090 */

     ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,/* WS10090 */
          "MVF_exists = %d", MVF_exists);                 /* WS10090 */
     ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,/* WS10090 */
          "UID:   |%s| / |%s|  = %d",                     /* WS10090 */
          current_user_uid, modified_user_uid, uid_match);/* WS10090 */
     ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,/* WS10090 */
          "UID_list:   |%s| / |%s| = %d",                 /* WS10090 */
          Current_UIDs_List, New_UIDs_List, uid_match);   /* WS10090 */
     ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,/* WS10090 */
          "ALLOW_UID_COLLISION = %c",                     /* WS10090 */
          params_ptr->ALLOW_UID_COLLISION[0]);            /* WS10090 */

    /* Check collision only is not allowed                   WS10090 */
    if ( (params_ptr->ALLOW_UID_COLLISION[0] NE 'Y') AND  /* WS10090 */
          (uid_match NE 0) )                              /* WS10090 */
    {                                                     /* WS10090 */
      if (NOT MVF_exists)
        rc = Check_User_Force_Disconnect_from_Group(
                                      current_user_uid,
                                      modified_user_uid,
                                      cgroup,
                                      laddinfo1,            /*BS10028*/
                                      admin_params);        /*WS10076A *
                                      dest,
                                      msgs);                          */
      else                                                  /* PS0354 */
        rc = Check_Mult_Force_Disconnect_from_Group(        /* PS0354 */
                                      Current_UIDs_List,    /* PS0354 */
                                      New_UIDs_List,        /* PS0354 */
                                      cgroup,               /* PS0354 */
                                      laddinfo1,            /*BS10028*/
                                      admin_params);        /*WS10076A *
                                      dest,                  * PS0354 *
                                      msgs);                 * PS0354 */
     /*
      *   if No Collision was found, allow update
      *   else                       issue error message and deny update
      */
      if (rc NE ESA_OK)
       {
        CTSAMSG_print(ACF2_FORCE_DISCONNECT, msgs, NULL, dest,
                      user_params->user,cgroup);
        rc = ESA_FATAL;
        goto exit;
       };
     };                                                   /* WS10090 */

     /* WS10090 - start */
     /* If UID is changed, print it before the change */
     if (uid_match NE 0)
     {
       if ( (MVF_exists)   AND
            (strchr(Current_UIDs_List, ADDINFO_LIST_ENTRY) NE NULL) )
       {
         /* print all values in current multi-value UID  */
         /* find the MV delimiter and calc uid length          */
         conmsg_uid_2prt=strchr(Current_UIDs_List, ADDINFO_LIST_ENTRY);
         if (conmsg_uid_2prt EQ NULL)
            conmsg_uid_len = strlen(Current_UIDs_List);
         else
            conmsg_uid_len = conmsg_uid_2prt - Current_UIDs_List;

         conmsg_uid_2prt = Current_UIDs_List;

         /* print header  */
         CTSAMSG_print(ACF2_USER_UIDS_BEFORE, msgs, NULL, dest);

         /*   print all UIDs until end of string   */
         do
         {
           strncpy(conmsg_uid, conmsg_uid_2prt, conmsg_uid_len);
           conmsg_uid[conmsg_uid_len] = NULL_CHAR;
           CTSAMSG_print(ACF2_OUTPUT_LINE, msgs, NULL, dest,
                         conmsg_uid);
           conmsg_uid_2prt = conmsg_uid_2prt + conmsg_uid_len + 1;
         } while ( (conmsg_uid_2prt - Current_UIDs_List) LT
                                           strlen(Current_UIDs_List) );
       }
       else
       {
         /* print current UID */
         if (MVF_exists)
           conmsg_uid_2prt = Current_UIDs_List;
         else
           conmsg_uid_2prt = current_user_uid;
         CTSAMSG_print(ACF2_USER_UID_BEFORE, msgs, NULL, dest,
                       conmsg_uid_2prt);
       }
       conmsg_issued = TRUE;
     };
     /* WS10090 - end   */
   };

  /*  BS10028 - do not change laddinfo becasue it conains the
   *            updated set of keywords for the change command.
   *  BS10018
   *
   * Restore laddinfo to original values
   *
   ADDINFO_empty(laddinfo);
   ADDINFO_copy(laddinfo,addinfo);                                  */

   Skip_Disconnect_Check:;

  /* PS0323
   *   Search for MULTI VALUED fields in updated fields.
   *   If at least one is found - add the REP operand to the command.
   */

   ACF2_Search_MULTI (laddinfo);                          /* PS0323 */

  /*
   * Convert ESS dates to ACF2 Date format
   */

  ACF2_Convert_Date_Fields(laddinfo,
                     dest,
                     msgs);

   /********************* IS10005 starts **********************/
   ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                     "Search RU_LOCKED");
   pair = ADDINFO_search ( "RU_LOCKED", ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs );
   if ( pair NE NULL)
   {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                     "RU_LOCKED found");
      if (strcmp(pair->value,KWD_FLAG_OFF) EQ 0)
      {
        /* WS10090 params_ptr = admin_params->apiinit_handle;  */
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,             /* IS10147A */
                     "RU_LOCKED is N, set PSWD-VIO(0) and PWP-VIO(0)");
        ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
                     "params_ptr = <%X>",params_ptr);
        ADDINFO_insert(TYPE_1A,"PSWD-VIO", "0", laddinfo,
                    ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                    UNIQUE);
        ADDINFO_insert(TYPE_1A,"PWP-VIO", "0", laddinfo,
                    ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN,
                    UNIQUE);                             /* IS10147A */
        /**********************************************************/
        /*** IS10005 if SUSPEND_IS_LOCKED, set NOSUSPEND as well ***/
        /**********************************************************/
        if (params_ptr->rssparm_SUSPEND_IS_LOCKED[0]== 'Y')
        {
         ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
           "RU_LOCKED is N and suspend_is_locked, set NOSUSPEND");
         ADDINFO_insert(TYPE_1A, "SUSPEND", KWD_FLAG_OFF, laddinfo,
           ACF_ADDINFO_KWD_LEN, ACF_ADDINFO_VAL_LEN, UNIQUE);
        }
      /* ADDINFO_dump(laddinfo,1); */
      }
   }
   /*  BS10028 - code below is  ot needed becasue it is done by
    *            CTSUpdPassword.
    ********************** WS10007 starts *************************
    *** PSWD_EXP keyword is handled by CTSUpdPassword.          ***
    *** Drop it from laddinfo.                                  ***
   pair = ADDINFO_search ( "PSWD_EXP", ACF_ADDINFO_KWD_LEN,
                          laddinfo->pair,
                          laddinfo->num_pairs );
   if ( pair NE NULL)
   {
      ESA_DIAG_printf(ESA_COMP_UPDUSER, 3,
       "PSWD_EXP found in local addinfo and will be deleted.");
      ADDINFO_delete(laddinfo, "PSWD_EXP");
   }
    ********************* WS10007 ends ************************/

   /********************* IS10005 ends ************************/
  /*
   *   Build and issue ACF2 CHANGE command
   */

   /* BS10028 - Print the addinfo passed to ACF2cmd.                  */
   ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,
                  "laddinfo dump before calling ACF2cmd");
   if (ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE
                                              DEBUG_SHOW_REGULAR)
       ADDINFO_dump(laddinfo,1);  /* wrong addinfo was printed BS10120*/
       /*BS10120 ADDINFO_dump(addinfo,1);                             */
   /* BS10028 - end                                                   */

   sprintf(cmd,"ACF2 LID CHANGE %s ",user_params->user);
   ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT,
                   "Command header prepared (%s)", cmd);
   rc = ACF2cmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                cmd, MAX_OK_RC_0,
                1, &laddinfo, mkt, kdt, admin_params,    /* IS10174 */
                CMDOUT_YES, ACF2_YES);
    /* IS10174  1, &laddinfo, mkt, kdt, dest, msgs,                   */

   /* BS10028 - Print the addinfo returned from ACF2cmd               */
   ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,
                  "laddinfo dump returned from ACF2cmd");
   if (ESA_DIAG_get_debug_level(ESA_COMP_UPDUSER) GE
                                              DEBUG_SHOW_REGULAR)
       ADDINFO_dump(addinfo,1);
   /* BS10028 - end                                                   */

   /* WS10090 - start */
   /* If the command was processed successfully and
      connections were printed before change, print after  */
   if ( (rc EQ ESA_OK) AND  (conmsg_issued) )
   {
     if ( (MVF_exists)   AND
          (strchr(New_UIDs_List, ADDINFO_LIST_ENTRY) NE NULL) )
     {
       /* print all values in current multi-value UID  */
       /* find the MV delimiter and calc uid length          */
       conmsg_uid_2prt = strchr(New_UIDs_List, ADDINFO_LIST_ENTRY);
       if (conmsg_uid_2prt EQ NULL)
          conmsg_uid_len = strlen(New_UIDs_List);
       else
          conmsg_uid_len = conmsg_uid_2prt - New_UIDs_List;

       conmsg_uid_2prt = New_UIDs_List;

       /* print header  */
       CTSAMSG_print(ACF2_USER_UIDS_AFTER, msgs, NULL, dest);

       /*   print all UIDs until end of string   */
       do
       {
         strncpy(conmsg_uid, conmsg_uid_2prt, conmsg_uid_len);
         conmsg_uid[conmsg_uid_len] = NULL_CHAR;
         CTSAMSG_print(ACF2_OUTPUT_LINE, msgs, NULL, dest,
                       conmsg_uid);
         conmsg_uid_2prt = conmsg_uid_2prt + conmsg_uid_len + 1;
       } while ( (conmsg_uid_2prt - New_UIDs_List) LT
                                               strlen(New_UIDs_List) );
     }
     else
     {
       /* print current UID */
       if (MVF_exists)
         conmsg_uid_2prt = New_UIDs_List;
       else
         conmsg_uid_2prt = modified_user_uid;
       CTSAMSG_print(ACF2_USER_UID_AFTER, msgs, NULL, dest,
                     conmsg_uid_2prt);
     }
   };
   /* WS10090 - end   */

   /*-----------------------------------------------------------*/
   /* WS2370 - support for user profiles                        */
   /*-----------------------------------------------------------*/
   saved_rc = rc;
   for(i=0; UP_kdts[i].UP_name[0] NE NULL_CHAR;i++)  {
      ESA_DIAG_printf(ESA_COMP_UPDUSER,DEBUG_SHOW_IMPORTANT,
            "processing profile %s", UP_kdts[i].UP_name);
      strcpy(prefix,UP_kdts[i].UP_name);
      strcat(prefix,".");
      /*-----------------------------------------------------------*/
      /* checking if switch was turned off, in which case we       */
      /* delete the user profile.                                  */
      /*-----------------------------------------------------------*/
      check_rc = ACF2_UP_switch_is_activated(UP_kdts[i].UP_name,
                                             laddinfo);
      if (check_rc EQ ESA_ERR) {/*switch exists but was turned off*/
         ESA_DIAG_printf(ESA_COMP_UPDUSER,DEBUG_SHOW_REGULAR,
             "deleting profile %s",  UP_kdts[i].UP_name);
         /* checking user profile (UP) switch */
         check_rc = ACF2_UP_exists(user_params->user,
                             UP_kdts[i].UP_name,
                             ESA_COMP_UPDUSER,
                             msgs,dest);
         if (check_rc EQ ESA_OK) {
            ADDINFO_empty(UP_addinfo);
            sprintf(cmd,"ACF2 GEN-P(USER)-SYSID(%s) DELETE %s ",
                  UP_kdts[i].UP_name,user_params->user);
            ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,
                   "Delete command header (%s)", cmd);
            rc = ACF2cmd(func, EXECOUT_DDNAME,
                         admin_params->admin_uname,
                         cmd, MAX_OK_RC_0,
                         1, &UP_addinfo, mkt, empty_kdt,
                         admin_params,                   /* IS10174 */
                         CMDOUT_YES, ACF2_NO);           /* IS10174 */
             /* IS10174  dest, msgs, CMDOUT_YES, ACF2_NO);        */
            if (rc > saved_rc) {
               saved_rc = rc;
            }
            continue;
         }
         continue;
      }
      /*-----------------------------------------------------------*/
      /* checking if keywords with the user profile prefix were    */
      /* found. if yes we update the keyword.                      */
      /*-----------------------------------------------------------*/
      pair = ADDINFO_prefix_search(prefix, strlen(prefix), TRUE,
                                 laddinfo->pair, laddinfo->num_pairs);
      if (pair NE NULL) {
         ESA_DIAG_printf(ESA_COMP_UPDUSER,DEBUG_SHOW_REGULAR,
            "updating profile %s", UP_kdts[i].UP_name);
         ADDINFO_empty(UP_addinfo);
         ADDINFO_copy_by_prefix(prefix,
                 ACF_ADDINFO_KWD_LEN,
                 ACF_ADDINFO_VAL_LEN,
                 TRUE,
                 laddinfo,
                 UP_addinfo);
         ADDINFO_insert(TYPE_1A, "REP",
                        "Y",
                        UP_addinfo,
                        ACF_ADDINFO_KWD_LEN,
                        ACF_ADDINFO_VAL_LEN,
                        UNIQUE);
         check_rc = ACF2_UP_exists(user_params->user,
                             UP_kdts[i].UP_name,
                             ESA_COMP_UPDUSER,
                             msgs,dest);
         if (check_rc EQ ESA_OK) {
            sprintf(cmd,"ACF2 GEN-P(USER)-SYSID(%s) CHANGE %s ",
                  UP_kdts[i].UP_name,user_params->user);
            ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_REGULAR,
                   "Command header prepared (%s)", cmd);
            rc = ACF2cmd(func, EXECOUT_DDNAME,
                         admin_params->admin_uname,
                         cmd, MAX_OK_RC_0,
                         1, &UP_addinfo, mkt, UP_kdts[i].UP_kdt,
                         admin_params,                   /* IS10174 */
                         CMDOUT_YES, ACF2_YES);          /* IS10174 */
              /* IS10174 dest, msgs, CMDOUT_YES, ACF2_YES);  */
            if (rc > saved_rc) {
               saved_rc = rc;
            }
         }
         else {
            /* start of BS2513 */
            check_rc = ACF2_User_Exists(user_params->user,
                                        admin_params);   /*bs2556*/
            if (check_rc EQ ESA_OK) {
               sprintf(cmd,"ACF2 GEN-P(USER)-SYSID(%s) INSERT %s ",
                     UP_kdts[i].UP_name,user_params->user);
               ESA_DIAG_printf(ESA_COMP_UPDUSER,DEBUG_SHOW_REGULAR,
                      "Command header prepared (%s)", cmd);
               rc = ACF2cmd(func, EXECOUT_DDNAME,
                            admin_params->admin_uname,
                            cmd, MAX_OK_RC_0,
                            1, &UP_addinfo, mkt, UP_kdts[i].UP_kdt,
                            admin_params,                /* IS10174 */
                            CMDOUT_YES, ACF2_NO);        /* IS10174 */
                /* IS10174  dest, msgs, CMDOUT_YES, ACF2_NO);   */
               if (rc > saved_rc) {
                  saved_rc = rc;
               }
            }
            else {
               CTSAMSG_print( ERR_NO_USER, msgs, NULL, dest,
                              user_params->user );
               rc = ESA_ERR;
               saved_rc = ESA_ERR;
            }
            /* end of BS2513 */
         }
      }
   };
   rc = saved_rc;
   /*-----------------------------------------------------------*/
   /* end WS2370 - support for user profiles                    */
   /*-----------------------------------------------------------*/

   /*-----------------------------------------------------------*/
   /* Finish ...                                                */
   /*-----------------------------------------------------------*/

   exit:

   if (laddinfo NE NULL)
    ADDINFO_free(&laddinfo);
   if (laddinfo1 NE NULL)
    ADDINFO_free(&laddinfo1);
   if (UP_addinfo NE NULL) /* ws2370 */
    ADDINFO_free(&UP_addinfo);

   GDB_rc = GDB_Set_Mode(GDB_Closed,admin_params,err);

   if (GDB_rc NE GDB_OK)
    {
      sprintf(errmsg,"GDB close failed, rc = %d",GDB_rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
      rc = ESA_FATAL;
    };

   ESA_DIAG_exit(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT, func, rc);

   return rc;

 }

 /* PS0323 - New function */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : ACF2_Search_MULTI                          *
 *                                                             *
 * DESCRIPTION    : Search for MULTI VALUED fields             *
 *                                                             *
 * INPUT          : laddinfo                                   *
 *                                                             *
 * OUTPUT         : laddinfo with/without REP operand          *
 *                                                             *
 * RETURN VALUE   : None                                       *
 *                                                             *
 **************************************************************/
 static void ACF2_Search_MULTI (ADDINFO_rec_typ * addinfo)
 {

   static char                func[]="ACF2_Search_MULTI";

   ONE_FIELD_rec_ptr          pair = NULL;
   ESA_RC                     rc;
   char                       field_type = ' ', field_rw = ' ';
   char                       field_multi = ' ';
   int                        field_length = 0, field_offset = 0;
   int                        field_mvmax = 0;
   int                        i;

   ESA_DIAG_enter(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT, func);

   /* Go over all updated fields in ADDINFO */
   for(i=0; i LT addinfo->num_pairs; i++)
   {
     pair = ADDINFO_get_next(addinfo, pair);

     /* Get field information - is it MULTI ? */
     rc = ACF2_Get_Field_Information(pair->keyword,
                                     &field_type,
                                     &field_rw,
                                     &field_length,
                                     &field_offset,
                                     &field_multi,
                                     &field_mvmax);
     if (rc EQ ESA_OK)
     {
       if (field_multi EQ 'Y')
       {
         ADDINFO_insert(TYPE_1A, "REP",
                        "Y",
                        addinfo,
                        ACF_ADDINFO_KWD_LEN,
                        ACF_ADDINFO_VAL_LEN,
                        UNIQUE);
         break;
       };
     };
   };

   ESA_DIAG_exit(ESA_COMP_UPDUSER, DEBUG_SHOW_IMPORTANT, func, ESA_OK);

 }
