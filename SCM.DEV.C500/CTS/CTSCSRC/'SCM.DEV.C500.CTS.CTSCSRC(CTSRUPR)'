 /**************************************************************
 *                                                             *
 * Title            : Set RSS parameters (RACF)                *
 *                                                             *
 * File Name        : ctsrupr.c                                *
 *                                                             *
 * Author           : A.Shv                                    *
 *                                                             *
 * Creation Date    : 31/07/94                                 *
 *                                                             *
 * Description      :                                          *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------  -------------------------------- *
 * as0906   A.Shv    09/06/96 Change kdt-table.                *
 * ps0163   Alex     29/07/97 RACF security server support     *
 * WS2557   EliMY    25/05/06 RACF MIXEDCASE PASSWORD SUPPORT  *
 *                            FOR ZOS1.7                       *
 * IS10161  MeirS    09/11/17 remove calling to CTSRVRS rtns   *
 * IS10174  NuritY   31/12/17 Dynamic EXECOUT support.         *
 * WS10082  MauriC   07/11/22 Recompile for new ADDINFO macros *
 **************************************************************/

 #include   <globs.h>

/*
 *   Standard include files
 */

 #include   STDLIB
 #include   STDIO
 #include   STRING

/*
 *   ESA include files
 */

 #include ESA_DIAG
 #include ESA_API
 #include ESA_CTSAMSG
 #include ESA_API_CODES

 #include RACF_CODES
 #include API_ADDINFO
 #include RACF

 #define  MASK_VALS_MIXEDCASE_SIZE    10                 /* WS2557 */
 #define  MASK_VALS_NO_MIXEDCASE_SIZE  6                 /* WS2557 */

/*
 *     RKT for SETROPTS
 *         (Reserved Keywords Table)
 */

static ADDINFO_RKTE_rec_typ rkt[] = {
   "PASSWORD.RULE1" ,
   "PASSWORD.RULE2" ,
   "PASSWORD.RULE3" ,
   "PASSWORD.RULE4" ,
   "PASSWORD.RULE5" ,
   "PASSWORD.RULE6" ,
   "PASSWORD.RULE7" ,
   "PASSWORD.RULE8" ,
   "PASSWORD.INTERVAL",    /* from RSS_PARAMS structure */
   "PASSWORD.REVOKE",      /* from RSS_PARAMS structure */
   ""              /* a null string indicate end-of-rkt */
 };

/*
 *     MKT for SETROPTS
 *         (Mandatory Keywords Table)
 */

static ADDINFO_MKTE_rec_typ mkt[] = {
       ""         /* a null string indicate end-of-mkt */
 };

/*
 *     KDT for SETROPTS COMMAND
 *         (Keyword Decscription Table)
 */

static ADDINFO_KDTE_rec_typ kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"ADSP"               ,KDT_FLG ,"NOADSP"             ,""  , "" },
  {"APPLAUDIT"          ,KDT_FLG ,"NOAPPLAUDIT"        ,""  , "" },
  {"CATDSNS"            ,KDT_KEY ,"NOCATDSNS"          ,"(" , ")"},
  {"CMDVIOL"            ,KDT_FLG ,"NOCMDVIOL"          ,""  , "" },
  {"COMPATMODE"         ,KDT_FLG ,"NOCOMPATMODE"       ,""  , "" },
  {"EGN"                ,KDT_FLG ,"NOEGN"              ,""  , "" },
  {"NOERASE"            ,KDT_FLG ,""                   ,""  , "" },
  {"ERASE.NO_PKB"       ,KDT_FLG ,""                   ,""  , "" },
  {"ERASE.ALL"          ,KDT_FLG ,""                   ,""  , "" },
/*{"ERASE.SECLEVEL"     ,KDT_KEY ,"ERASE.NOSECLEVEL"   ,"(" , ")"}, */
  {"ERASE.SECLEVEL"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"GENERICOWNER"       ,KDT_FLG ,"NOGENERICOWNER"     ,""  , "" },
  {"GRPLIST"            ,KDT_FLG ,"NOGRPLIST"          ,""  , "" },
  {"INACTIVE"           ,KDT_KEY ,"NOINACTIVE"         ,"(" , ")"},
  {"INITSTATS"          ,KDT_FLG ,"NOINITSTATS"        ,""  , "" },
  {"JES.BATCHALLRACF"   ,KDT_FLG ,"JES.NOBATCHALLRACF" ,""  , "" },
  {"JES.EARLYVERIFY"    ,KDT_FLG ,"JES.NOEARLYVERIFY"  ,""  , "" },
  {"JES.XBMALLRACF"     ,KDT_FLG ,"JES.NOXBMALLRACF"   ,""  , "" },
  {"JES.NJEUSERID"      ,KDT_KEY ,
                              "JES.NJEUSERID(????????)","(", ")" },
  {"JES.UNDEFINEDUSER",  KDT_KEY ,
                          "JES.UNDEFINEDUSER(+++++++)" ,"(", ")" },
  {"MLACTIVE"           ,KDT_KEY ,"NOMLACTIVE"         ,"(" , ")"},
  {"MLQUIET"            ,KDT_FLG ,"NOMLQUIET"          ,""  , "" },
  {"MLS"                ,KDT_KEY ,"NOMLS"              ,"(" , ")"},
  {"MLSTABLE"           ,KDT_FLG ,"NOMLSTABLE"         ,""  , "" },
  {"NOMODEL"            ,KDT_FLG ,""                   ,""  , "" },
  {"MODEL.NO_PKB"       ,KDT_FLG ,""                   ,""  , "" },
  {"MODEL.GDG"          ,KDT_FLG ,"MODEL.NOGDG"        ,""  , "" },
  {"MODEL.GROUP"        ,KDT_FLG ,"MODEL.NOGROUP"      ,""  , "" },
  {"MODEL.USER"         ,KDT_FLG ,"MODEL.NOUSER"       ,""  , "" },
  {"OPERAUDIT"          ,KDT_FLG ,"NOOPERAUDIT"        ,""  , "" },
  {"PASSWORD.HISTORY"   ,KDT_KEY ,"PASSWORD.NOHISTORY" ,"(" , ")"},
  {"PASSWORD.INTERVAL"  ,KDT_KEY ,"PASSWORD.NOINTERVAL","(" , ")"},
  {"PASSWORD.REVOKE"    ,KDT_KEY ,"PASSWORD.NOREVOKE"  ,"(" , ")"},
  {"PASSWORD.WARNING"   ,KDT_KEY ,"PASSWORD.NOWARNING" ,"(" , ")"},

  /*
   *   PASSWORD RULES
   */

  {"PASSWORD.NORULE1"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE2"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE3"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE4"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE5"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE6"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE7"   ,KDT_FLG ,""                   ,""  , "" },
  {"PASSWORD.NORULE8"   ,KDT_FLG ,""                   ,""  , "" },

  {"PASSWORD.RULE1"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE2"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE3"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE4"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE5"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE6"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE7"     ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSWORD.RULE8"     ,KDT_KEY ,""                   ,"(" , ")"},

 /*
  *  RULE1.MINLEN ->   "PASSWORD.RULE1",
  *  RULE1.MAXLEN ->   + string should be built
  *  RULE1.MASK   ->   by internal program
  */

  {"RULE1.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE2.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE3.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE4.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE5.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE6.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE7.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE8.MINLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE1.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE2.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE3.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE4.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE5.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE6.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE7.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE8.MAXLEN"       ,KDT_IGN ,""                   ,""  , "" },
  {"RULE1.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE2.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE3.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE4.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE5.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE6.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE7.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"RULE8.MASK"         ,KDT_IGN ,""                   ,""  , "" },
  {"PREFIX"             ,KDT_KEY ,"NOPREFIX"           ,"(" , ")"},
  {"PROTECTALL"         ,KDT_KEY ,"NOPROTECTALL"       ,"(" , ")"},
  {"REALDSN"            ,KDT_FLG ,"NOREALDSN"          ,""  , "" },
  {"RETPD"              ,KDT_KEY ,"RETPD(0)"           ,"(" , ")"},
  {"SAUDIT"             ,KDT_FLG ,"NOSAUDIT"           ,""  , "" },
  {"SECLABELAUDIT"      ,KDT_FLG ,"NOSECLABELAUDIT"    ,""  , "" },
  {"SECLABELCONTROL"    ,KDT_FLG ,"NOSECLABELCONTROL"  ,""  , "" },
  {"SECLEVELAUDIT"      ,KDT_KEY ,"NOSECLEVELAUDIT"    ,"(" , ")"},
  {"SESSIONINTERVAL"    ,KDT_KEY ,"NOSESSIONINTERVAL"  ,"(" , ")"},
  {"TAPEDSN"            ,KDT_FLG ,"NOTAPEDSN"          ,"(" , ")"},
  {"TERMINAL"           ,KDT_KEY ,"TERMINAL(NONE)"     ,"(" , ")"},
  {"WHEN.PROGRAM"       ,KDT_FLG ,"NOWHEN.PROGRAM"     ,""  , "" },

  /* ps0163 */
  {"ADDCREATOR"         ,KDT_FLG ,"NOADDCREATOR"       ,""  , "" },

  /*
   *  CDT Related fields
   */

  {"AUDIT"                ,KDT_IGN ,""         ,"(" , ")"  },
  {"CLASSACT"             ,KDT_IGN ,""         ,"(" , ")"  },
  {"GENCMD"               ,KDT_IGN ,""         ,"(" , ")"  },
  {"GENERIC"              ,KDT_IGN ,""         ,"(" , ")"  },
  {"GENLIST"              ,KDT_IGN ,""         ,"(" , ")"  },
  {"GLOBAL"               ,KDT_IGN ,""         ,"(" , ")"  },
  {"RACLIST"              ,KDT_IGN ,""         ,"(" , ")"  },
  {"STATISTICS"           ,KDT_IGN ,""         ,"(" , ")"  },
  {"LOGOPTIONS.ALWAYS"    ,KDT_KEY ,""         ,"("  , ")" },
  {"LOGOPTIONS.NEVER"     ,KDT_KEY ,""         ,"("  , ")" },
  {"LOGOPTIONS.SUCCESSES" ,KDT_KEY ,""         ,"("  , ")" },
  {"LOGOPTIONS.FAILURES"  ,KDT_KEY ,""         ,"("  , ")" },
  {"LOGOPTIONS.DEFAULT"   ,KDT_KEY ,""         ,"("  , ")" },

  {""                     ,KDT_FLG ,""          ,""  ,""   }};

/*
 *     KDT for SETROPTS COMMAND per delta keywords
 *         (Keyword Decscription Table)
 */

 static ADDINFO_KDTE_rec_typ delta_kdt[] = {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"AUDIT"              ,KDT_KEY ,""         ,"(" , ")" },
  {"NOAUDIT"            ,KDT_KEY ,""         ,"(" , ")" },
  {"CLASSACT"           ,KDT_KEY ,""         ,"(" , ")" },
  {"NOCLASSACT"         ,KDT_KEY ,""         ,"(" , ")" },
  {"GENCMD"             ,KDT_KEY ,""         ,"(" , ")" },
  {"NOGENCMD"           ,KDT_KEY ,""         ,"(" , ")" },
  {"GENERIC"            ,KDT_KEY ,""         ,"(" , ")" },
  {"NOGENERIC"          ,KDT_KEY ,""         ,"(" , ")" },
  {"GENLIST"            ,KDT_KEY ,""         ,"(" , ")" },
  {"NOGENLIST"          ,KDT_KEY ,""         ,"(" , ")" },
  {"GLOBAL"             ,KDT_KEY ,""         ,"(" , ")" },
  {"NOGLOBAL"           ,KDT_KEY ,""         ,"(" , ")" },
  {"RACLIST"            ,KDT_KEY ,""         ,"(" , ")" },
  {"NORACLIST"          ,KDT_KEY ,""         ,"(" , ")" },
  {"STATISTICS"         ,KDT_KEY ,""         ,"(" , ")" },
  {"NOSTATISTICS"       ,KDT_KEY ,""         ,"(" , ")" },
  {""                   ,KDT_FLG ,""         ,""  ,""   }};

 /*
  *  Delta Keyword Table
  */

 typedef struct {
    char          kwd[RCF_ADDINFO_KWD_LEN+1];
    char          addkwd[RCF_ADDINFO_KWD_LEN+1];
    char          delkwd[RCF_ADDINFO_KWD_LEN+1];
    int           kwd_found;
    ADDINFO_typ   add_typ;
    char          oldval[RCF_ADDINFO_VAL_LEN+1];
    char          newval[RCF_ADDINFO_VAL_LEN+1];
    char          addval[RCF_ADDINFO_VAL_LEN+1];
    char          delval[RCF_ADDINFO_VAL_LEN+1];
  } DELTA_DESC_rec_typ;

 /*
  *     Delta keywords description table
  */

 static DELTA_DESC_rec_typ delta[] = {
 /*                                                            */
 /* keyword             Add to List           Delete from List */
 /* =================== ===================   ================ */

  {"AUDIT"         ,    "AUDIT"      ,       "NOAUDIT"     },
  {"CLASSACT"      ,    "CLASSACT"   ,       "NOCLASSACT"  },
  {"GENCMD"        ,    "GENCMD"     ,       "NOGENCMD"    },
  {"GENERIC"       ,    "GENERIC"    ,       "NOGENERIC"   },
  {"GENLIST"       ,    "GENLIST"    ,       "NOGENLIST"   },
  {"GLOBAL"        ,    "GLOBAL"     ,       "NOGLOBAL"    },
  {"RACLIST"       ,    "RACLIST"    ,       "NORACLIST"   },
  {"STATISTICS"    ,    "STATISTICS" ,       "NOSTATISTICS"},
  {""              ,    ""           ,       ""            } };


/*
 *     KDT for SETROPTS COMMAND per delta keywords
 *         (Keyword Decscription Table) (LOGOPTIONS. )
 */

 static ADDINFO_KDTE_rec_typ delta_logop_kdt[] = {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"LOGOPTIONS.DEFAULT",   KDT_KEY ,""                ,"("  , ")" },
  {""                     ,KDT_FLG ,""                ,""  ,""   }};

 /*
  *     Delta keywords description table(LOGOPTIONS. )
  */

 static DELTA_DESC_rec_typ delta_logop[] = {
 /*                                                              */
 /* keyword              Add to List            Delete from List */
 /* ===================  ===================    ================ */

 {"LOGOPTIONS.ALWAYS"   ,"LOGOPTIONS.ALWAYS"   ,"LOGOPTIONS.DEFAULT"},
 {"LOGOPTIONS.NEVER"    ,"LOGOPTIONS.NEVER"    ,"LOGOPTIONS.DEFAULT"},
 {"LOGOPTIONS.SUCCESSES","LOGOPTIONS.SUCCESSES","LOGOPTIONS.DEFAULT"},
 {"LOGOPTIONS.FAILURES" ,"LOGOPTIONS.FAILURES" ,"LOGOPTIONS.DEFAULT"},
 {""                    ,""                    ,""                } };

 static ESA_RC PasswordRules(ADDINFO_rec_typ            * addinfo,
                             ADDINFO_rec_typ            * laddinfo,
                             CTSAMSG_DEST_TABLE_rec_typ * dest,
                             CTSAMSG_HANDLE_rec_typ     * msgs);


 static ESA_RC CTSUpdParm_lists (DELTA_DESC_rec_typ   * delta,
                                 ADDINFO_rec_typ      * addinfo,
                                 ADMIN_PARAMS_rec_typ * admin_params,
                                 ERR_STRUCT_rec_typ   * err );

 static ESA_RC CTSUpdParm_logop (DELTA_DESC_rec_typ   * delta,
                                 ADDINFO_rec_typ      * addinfo,
                                 ADMIN_PARAMS_rec_typ * admin_params,
                                 ERR_STRUCT_rec_typ   * err );

 static char  component[] = "CTSRUPR";

/****************************************************
 * Procedure Name : strsprm
 * Description    : Set RSS parameters
 * Input          : rss_params, admin
 * Output         : err
 * Input/Output   : addinfo
 * Return Value   : ESA_RC
 * Side Effects   :
 * Comments       : RSS-dependent operations to modify
 *                  global RSS parameters.
 ***************************************************/

 ESA_RC CTSSetRSSParams (RSS_PARAMS_rec_typ   * rss_params,
                         ADDINFO_rec_typ      * addinfo,
                         ADMIN_PARAMS_rec_typ * admin_params,
                         ERR_STRUCT_rec_typ   * err)
 {

  /*
   *   Variables
   */

   ESA_RC                       rc = ESA_OK;
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;
   ADDINFO_rec_ptr              laddinfo = NULL;
   ADDINFO_rec_ptr              addinfo_vec[2] = { NULL, NULL };
   char                         cmd[MAX_API_ST];
   char                         temp[10];
   static char func[]="CTSSetRSSParams";

  /****************************************************************
   *                                                               *
   *   Initialize                                                  *
   *                                                               *
   ****************************************************************/

   ESA_DIAG_enter(ESA_COMP_STRSPRM, 1, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   cmd[0] = NULL_CHAR;  /* Clear command line */  /* ws2557 */

   if (ESA_DIAG_get_debug_level(ESA_COMP_STRSPRM) GE 5)
        ADDINFO_dump(addinfo,0);

  /*
   *   Check that Reserved Keywords were not used
   */

   if (ADDINFO_rkt_check(func, 1, &addinfo, rkt,
                         dest, msgs ) NE ESA_OK) {
      rc = ESA_FATAL;
      goto exit;
   }

  /*
   *   Obtain a local addinfo buffer
   */

   if (ADDINFO_alloc(func, 50, &laddinfo, dest, msgs) NE ESA_OK) {
      rc = ESA_FATAL;
      goto exit;
   }
   addinfo_vec[0] = laddinfo;
   addinfo_vec[1] = addinfo;

  /***********************************************************
   *                                                         *
   *   Handle lists changes (CDT related fields)             *
   *                                                         *
   ***********************************************************/

   rc = CTSUpdParm_lists ( delta, addinfo, admin_params, err);
   if (rc NE ESA_OK)
      goto exit;

   rc = CTSUpdParm_logop ( delta_logop, addinfo, admin_params, err);
   if (rc NE ESA_OK)
      goto exit;

   /****************************************************************
   *                                                               *
   *  Handle special NO_PKB flags for addinfo_concat function      *
   *                                                               *
   ****************************************************************/


   ADDINFO_insert_cond("NOERASE"        , KWD_FLAG_ON, addinfo,
                       "ERASE.NO_PKB"   , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                        laddinfo );
   ADDINFO_insert_cond("NOMODEL"        , KWD_FLAG_ON, addinfo,
                       "MODEL.NO_PKB"   , KWD_FLAG_ON,
                        RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                       laddinfo );

   /****************************************************************
   *                                                               *
   *  Build SETROPTS PASSWORD rules                                *
   *                                                               *
   ****************************************************************/

   /* PasswordRules( addinfo, laddinfo, dest, msgs );     ws2557  */
   /* ws2557 part 2 start */
   rc = PasswordRules( addinfo, laddinfo, dest, msgs );
   if ( rc NE ESA_OK )
      goto exit;
   /* ws2557 part 2 end */

   /****************************************************************
   *                                                               *
   *  Structure fields handling                                    *
   *                                                               *
   ****************************************************************/

   if ( rss_params->min_pass_len NE IGNORE_NUMBER ) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component,func,"min_pass_len not supported",
                    16, __LINE__);
   }

   if ( rss_params->max_expire NE IGNORE_NUMBER ) {
       if (rss_params->max_expire NE EMPTY_NUMBER)
          sprintf(temp, "%d", rss_params->max_expire);
       else
          strcpy(temp, "");
       ADDINFO_insert(TYPE_1A, "PASSWORD.INTERVAL",
                      temp, laddinfo,
                      RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                      UNIQUE);
   }

   if ( rss_params->max_logins NE IGNORE_NUMBER ) {
       if (rss_params->max_logins NE EMPTY_NUMBER)
          sprintf(temp, "%d", rss_params->max_logins);
       else
          strcpy(temp, "");
       ADDINFO_insert(TYPE_1A, "PASSWORD.REVOKE",
                      temp, laddinfo,
                      RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                      UNIQUE);
   }

   /****************************************************************
   *                                                               *
   *  Issue SETROPTS command                                       *
   *                                                               *
   ****************************************************************/

   strcpy(cmd,"SETROPTS ");
   ESA_DIAG_printf(ESA_COMP_STRSPRM, 1,
                   "Command header prepared (%s)", cmd);

   rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                cmd, MAX_OK_RC_4,
                2, addinfo_vec, mkt, kdt,                /* IS10174 */
                admin_params,                            /* IS10174 */
                CMDOUT_YES, RACF_YES);
     /* IS10174 2, addinfo_vec, mkt, kdt, dest, msgs,    */

   /****************************************************************
   *                                                               *
   *   Finish                                                      *
   *                                                               *
   ****************************************************************/

   exit:;

   ADDINFO_free(&laddinfo);

   ESA_DIAG_exit(ESA_COMP_STRSPRM, 1, func, rc);

   return rc;

 }

/**************************************************************
*                                                             *
* PROCEDURE NAME : CreateRule                                 *
*                                                             *
* DESCRIPTION    : Create rule strine                         *
*                                                             *
* INPUT          : rule_number                                *
*                  min_password_len                           *
*                  max_password_len                           *
*                  mask                                       *
*                                                             *
* OUTPUT         : result                                     *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CreateRule(int            rule_number,
                         char         * min_len_val,
                         char         * max_len_val,
                         char         * mask,
                         char         * result,
                         CTSAMSG_DEST_TABLE_rec_typ * dest,
                         CTSAMSG_HANDLE_rec_typ     * msgs)
{

    ESA_RC    rc = ESA_OK;
    static    char func[] = "CreateRule";
    int       min_val;
    int       max_val;
    int       i, j, m;
    char      *p;
    char      *mask_vals;                                /* ws2557 */
    int       mask_vals_size;                            /* ws2557 */
    RACF_FLAG_typ at_least_Z17;                          /* ws2557 */

    /* ws2557: this section replaced with new one
    char      mask_vals[8] = "ACLNVW* ";
    char      *mask_keys[] =  { "ALPHA("       ,
                                "CONSONANT("   ,
                                "ALPHANUM("    ,
                                "NUMERIC("     ,
                                "VOWEL("       ,
                                "NOVOWEL("     ,
                                "NOTHING(" } ;

    char      mask_work[8][20] = { {""}, {""}, {""}, {""},
                                   {""}, {""}, {""}, {""} };
    */
    /* ws2557 part 1 start */
    char   mask_vals_no_mixedcase[9] = "ACLNVW* ";
    char   *mask_keys_no_mixedcase[] =  { "ALPHA("       ,
                                          "CONSONANT("   ,
                                          "ALPHANUM("    ,
                                          "NUMERIC("     ,
                                          "VOWEL("       ,
                                          "NOVOWEL("     ,
                                          "NOTHING(" } ;

    char   mask_vals_mixedcase[13] = "ACLNVWcmv$* ";
    char   *mask_keys_mixedcase[]  =  { "ALPHA("         ,
                                        "CONSONANT("     ,
                                        "ALPHANUM("      ,
                                        "NUMERIC("       ,
                                        "VOWEL("         ,
                                        "NOVOWEL("       ,
                                        "MIXEDCONSONANT(",
                                        "MIXEDNUM("      ,
                                        "MIXEDVOWEL("    ,
                                        "NATIONAL("      ,
                                        "NOTHING(" } ;

    char   mask_work[12][20] = { {""}, {""}, {""}, {""},
                                 {""}, {""}, {""}, {""},
                                 {""}, {""}, {""}, {""} };
    /* ws2557 part 1 end */
    char      work[10];

   /*
    *   Initialize
    */

    ESA_DIAG_enter(ESA_COMP_STRSPRM, 4, func);

    ESA_DIAG_printf(ESA_COMP_STRSPRM, 4,
                    "rule%d password length(min=%s max=%s) mask=%s",
                     rule_number, min_len_val, max_len_val, mask );

    /* ws2557 part 3 start */

    /*
     *  Check if rule should be with mixedcase or not.
     *  From z/OS 1.7 password rules support mixedcase.
     *  IS10161 - remove RACF version retrieving
     */

  /*  IS10161 start - remove RACF version retrieving
    rc = RACF_version_at_least(RACFZ17, &at_least_Z17);

    if ( rc NE ESA_OK ) {
       ESA_DIAG_printf(ESA_COMP_STRSPRM, 4,
                    "Retrieve RACF version failed");
       rc = ESA_FATAL;
       goto exit;
    }

    ESA_DIAG_printf(ESA_COMP_STRSPRM, 4,
    "Detected RACF version %s RACFZ17.",
    (at_least_Z17 EQ RACF_YES) ? "at least" : "previous to");

    if ( at_least_Z17 EQ RACF_YES ) {
      IS10161 end                                           */
       mask_vals = mask_vals_mixedcase;
       mask_vals_size = MASK_VALS_MIXEDCASE_SIZE;
  /*  IS10161 start - remove RACF version retrieving
    }
    else {
       mask_vals = mask_vals_no_mixedcase;
       mask_vals_size = MASK_VALS_NO_MIXEDCASE_SIZE;
    }
      IS10161 end                                           */
    /* ws2557 part 3 end */

    ESA_DIAG_printf(ESA_COMP_STRSPRM, 4,
                   "mask_vals = %s , mask_vals_size = %d",
                    mask_vals,mask_vals_size);


   /*
    *   Check password length
    */

    /* Minimum password length */

    min_val = atoi( min_len_val );
    if ( min_val GT 8 ) {
      CTSAMSG_print(RACF_RSSPARM_ERR_MINL,msgs, NULL, dest,
                    rule_number, min_len_val );
      rc = ESA_FATAL;
      goto exit;
    }

    /* Maximum password length */

    max_val = atoi( max_len_val );
    if ( max_val GT 8 ) {
      CTSAMSG_print(RACF_RSSPARM_ERR_MAXL,msgs, NULL, dest,
                    rule_number, max_len_val );
      rc = ESA_FATAL;
      goto exit;
    }

    /* Both : minimum and maximum password length */

    if ( ( min_val GT 0 ) AND ( max_val GT 0 ) ) {
      if ( min_val GT max_val ) {
        CTSAMSG_print(RACF_RSSPARM_ERR_RNG,msgs, NULL, dest,
                      rule_number, min_len_val, max_len_val );
        rc = ESA_FATAL;
        goto exit;
      }
    }

   /*
    *  Create PASSWORD rule string ( LENGTH )
    */

    if ( ( min_val GT 0 ) AND ( max_val GT 0 ) ) {
      if ( min_val NE max_val )
        sprintf( result,"LENGTH(%s:%s) ", min_len_val, max_len_val );
      else
        sprintf( result,"LENGTH(%s) ", min_len_val);
    }
    else if ( min_val GT 0 )
        sprintf( result,"LENGTH(%s) ", min_len_val);
    else if ( max_val GT 0 )
        sprintf( result,"LENGTH(%s) ", max_len_val);

   /*
    *  Create PASSWORD rule string ( content-keywords )
    */

    j = MIN( 8, strlen(mask) );

    for ( i=0; i LT j ; i++ ) {
        p = strchr(mask_vals, mask[i]); /* Locate mask symbol */
        if (p EQ NULL) {
           CTSAMSG_print(RACF_RSSPARM_ERR_CNTT,msgs, NULL, dest,
                         rule_number, mask[i]);
           rc = ESA_FATAL;
           goto exit;
        }

        m = p - mask_vals;           /* Mask symbol index    */
        sprintf(work, "%d," ,i+1);   /* Mask symbol position */
        strcat( mask_work[m], work); /* Concat to syntax rule*/
    }

   /*
    *   Create full syntax rules string
    */

   /* for ( i=0; i LT 6; i++ ) {                      ws2557 */
    for ( i=0; i LT mask_vals_size; i++ ) {        /* ws2557 */
        if (strlen(mask_work[i]) EQ 0)
           continue;

        /* strcat(result, mask_keys[i]);                     ws2557 */

        if ( at_least_Z17 EQ RACF_YES )                   /* ws2557 */
           strcat(result, mask_keys_mixedcase[i]);        /* ws2557 */
        else                                              /* ws2557 */
           strcat(result, mask_keys_no_mixedcase[i]);     /* ws2557 */

        strcat(result, mask_work[i]);
        result[strlen(result) - 1] = ')';  /* Remove last comma */
        strcat(result, " ");

        ESA_DIAG_printf(ESA_COMP_STRSPRM, 4,
                        "RULE%d=%s", rule_number, result);

    }

    exit :;

     ESA_DIAG_exit(ESA_COMP_STRSPRM, 4, func, rc);

     return rc;
}

/**************************************************************
*                                                             *
* PROCEDURE NAME : PasswordRules                              *
*                                                             *
* DESCRIPTION    : Create SETROPTS string for PASSWORD rules  *
*                                                             *
* INPUT          : addinfo, laddinfo                          *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC PasswordRules(ADDINFO_rec_typ            * addinfo,
                            ADDINFO_rec_typ            * laddinfo,
                            CTSAMSG_DEST_TABLE_rec_typ * dest,
                            CTSAMSG_HANDLE_rec_typ     * msgs)
{

 /*
  *   Variables
  */

  ESA_RC                       rc = ESA_OK;
  char                         pswd_norule[] = "PASSWORD.NORULE%d";
  char                         pswd_rule[]   = "PASSWORD.RULE%d";
  char                         rule_minlen[] = "RULE%d.MINLEN";
  char                         rule_maxlen[] = "RULE%d.MAXLEN";
  char                         rule_mask[]   = "RULE%d.MASK";
  char                         norule_kwd[20];
  char                         rule_kwd[20];
  char                         minlen_kwd[20];
  char                         maxlen_kwd[20];
  char                         mask_kwd[20];
  char                         min_len_val[5];
  char                         max_len_val[5];
  char                         mask_val[10];
  int                          max_rules = 8;
  int                          i;
  char                         cmd[MAX_API_ST];
  ONE_FIELD_rec_ptr            cpair;
  ONE_FIELD_rec_ptr            cpair_min_len;
  ONE_FIELD_rec_ptr            cpair_max_len;
  ONE_FIELD_rec_ptr            cpair_mask;
  static char                  func[]="PasswordRules";

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_STRSPRM, 1, func);

 /*
  *   PASSWORD rules loop
  */

  for (i=1; i LE  max_rules; i++) {

    sprintf( norule_kwd, pswd_norule, i );

   /*
    *   if PASSWORD.NORULEx=Y then nothing to do
    */

    cpair = ADDINFO_search ( norule_kwd, RCF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs );
    if ( cpair NE NULL)
       if ( strcmp( cpair->value, KWD_FLAG_ON ) EQ 0 )
           continue;

   /*
    *    Analyze RULEx changes
    */

    sprintf( rule_kwd,   pswd_rule,   i );
    sprintf( minlen_kwd, rule_minlen, i );
    sprintf( maxlen_kwd, rule_maxlen, i );
    sprintf( mask_kwd,   rule_mask,   i );

    cmd[0] = NULL_CHAR;  /* Clear command line */

   /*
    *  Get  Parameters from ADDINFO
    */

    cpair_min_len = ADDINFO_search ( minlen_kwd, RCF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs );
    cpair_max_len = ADDINFO_search ( maxlen_kwd, RCF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs );
    cpair_mask    = ADDINFO_search ( mask_kwd,   RCF_ADDINFO_KWD_LEN,
                                     addinfo->pair,
                                     addinfo->num_pairs );
    if ( ( cpair_min_len EQ NULL ) AND
         ( cpair_max_len EQ NULL ) AND
         ( cpair_mask    EQ NULL )   )
       continue;

   /*
    *    Parameters processing
    */

   /*
    *  Get  Minimum password length
    */

    if ( cpair_min_len EQ NULL) {
      rc = RACF_get_option_value( minlen_kwd, TYPE_1A,
                                  min_len_val, dest, msgs );
      if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
      }
    }
    else
      strcpy( min_len_val, cpair_min_len->value);

   /*
    *  Get  Maximum password length
    */

    if (cpair_max_len EQ NULL) {
      rc = RACF_get_option_value( maxlen_kwd, TYPE_1A,
                                  max_len_val, dest, msgs );
      if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
      }
    }
    else
      strcpy( max_len_val, cpair_max_len->value);

   /*
    *  Get  Password mask
    */

    if ( cpair_mask EQ NULL) {
      rc = RACF_get_option_value( mask_kwd, TYPE_1A,
                                  mask_val, dest, msgs );
      if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
      }
    }
    else
      strcpy( mask_val, cpair_mask->value);

   /*
    *  Create PASSWORD rule string
    */

    rc = CreateRule( i, min_len_val, max_len_val, mask_val, cmd,
                     dest, msgs );
    if ( rc EQ ESA_OK )
       ADDINFO_insert(TYPE_1A, rule_kwd, cmd, laddinfo,
                      RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                      UNIQUE);
    else {                                            /* ws2557 */
       goto exit;                                     /* ws2557 */
    }                                                 /* ws2557 */

  }    /* password rules loop */

  exit :;

  ESA_DIAG_exit(ESA_COMP_STRSPRM, 1, func, rc);

  return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdParm_lists                           *
*                                                             *
* DESCRIPTION    : Update a Parameter list                    *
*                                                             *
* INPUT          :                                            *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CTSUpdParm_lists (DELTA_DESC_rec_typ   * delta,
                                ADDINFO_rec_typ      * addinfo,
                                ADMIN_PARAMS_rec_typ * admin_params,
                                ERR_STRUCT_rec_typ   * err)
{

  static char         func[]="CTSUpdParm_lists";

 /*
  *   Variables
  */

  ESA_RC                       rc;
  char                         cmd[MAX_API_ST];
  ADDINFO_rec_ptr              laddinfo = NULL;
  ONE_FIELD_rec_ptr            cpair;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;
  char                         msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];

  short i, delta_count;                         /* Delta Processing */
  ESA_RC rc_add, rc_del;                        /* Delta Processing */

  int  copy_size;                               /* WS10082 */

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_STRSPRM, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *   Check if any of the delta keywords were specified
  */

  delta_count=0;
  for (i=0; strlen(delta[i].kwd); i++) {
      delta[i].kwd_found = 0;
      strcpy( delta[i].newval, NULL_STRING);
      cpair = ADDINFO_search(delta[i].kwd, RCF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs );
      if (cpair NE NULL) {

         ESA_DIAG_printf(ESA_COMP_STRSPRM, 2,
                  "Delta %d: '%s' at %X", i, delta[i].kwd, cpair);

         if ( (cpair->add_typ NE TYPE_1B ) AND
              (cpair->add_typ NE TYPE_2B )   ) {
            sprintf(msgbuf, "Invalid type=%d for list keyword=%s",
                    cpair->add_typ,  cpair->keyword);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func, msgbuf, 0, __LINE__);
         }

        /* WS10082 - start */
         if (cpair->vallen GT RCF_ADDINFO_VAL_LEN+1)
            copy_size = RCF_ADDINFO_VAL_LEN;
         else
            copy_size = cpair->vallen;

         snprintf (delta[i].newval, copy_size, "%s", cpair->value);
        /* strcpy( delta[i].newval, cpair->value); */
        /* WS10082 - end   */

         delta[i].add_typ = cpair->add_typ;

         RACF_get_option_value(delta[i].kwd, cpair->add_typ,
                               delta[i].oldval, dest,msgs );
         delta_count++;
         delta[i].kwd_found = 1;

         strcpy( delta[i].addval, NULL_STRING);
         strcpy( delta[i].delval, NULL_STRING);

         rc_add = ADDINFO_list_diff(delta[i].newval, delta[i].oldval,
                              delta[i].addval,
                              ADDINFO_LIST_ENTRY, ADDINFO_LIST_ENTRY);
         rc_del = ADDINFO_list_diff(delta[i].oldval, delta[i].newval,
                              delta[i].delval,
                              ADDINFO_LIST_ENTRY, ADDINFO_LIST_ENTRY);

         ESA_DIAG_printf(ESA_COMP_STRSPRM, 3,
               "Add: diff rc=%d addval=%s", rc_add, delta[i].addval);

         ESA_DIAG_printf(ESA_COMP_STRSPRM, 3,
               "Del: diff rc=%d delval=%s", rc_del, delta[i].delval);

         if ( (rc_del NE ESA_OK) OR (rc_add NE ESA_OK) ) {
            CTSAMSG_print(RACF_LISTDIFF, msgs, NULL, dest,
                          delta[i].newval);
            rc = ESA_FATAL;
            goto exit;
         } /* Error in lists processing */
      }
  }

  ESA_DIAG_printf(ESA_COMP_STRSPRM, 1,
                  "Delta keywords count = %d", delta_count);

 /*
  *   If no delta keywords, finish
  */

  if ( delta_count EQ 0 ) {
     rc = ESA_OK;
     goto exit;
  }

 /*
  *   Prepare parameters for list fields processing
  */

  rc = ADDINFO_alloc(func, delta_count, &laddinfo, dest, msgs);
  if (rc NE ESA_OK) {
     rc = ESA_FATAL;
     goto exit;
  }

  for (i=0; strlen(delta[i].kwd); i++)
      ADDINFO_insert(TYPE_1B, delta[i].kwd, NULL_STRING,
                     laddinfo, RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                     UNIQUE);

  if ( ESA_DIAG_get_debug_level(ESA_COMP_STRSPRM) GT 4)
     ADDINFO_dump(laddinfo ,1);

 /*
  *   Delete deleted items
  */

  ADDINFO_empty(laddinfo);
  for (i=0; strlen(delta[i].kwd); i++) {

      ESA_DIAG_printf(ESA_COMP_STRSPRM, 3,
          "Delta %d:%s: delval=%s", i, delta[i].kwd, delta[i].delval);

      if (strlen(delta[i].delval) GT 0)
         ADDINFO_insert(TYPE_1B, delta[i].delkwd,
                        delta[i].delval, laddinfo, RCF_ADDINFO_KWD_LEN,
                        RCF_ADDINFO_VAL_LEN, UNIQUE);
  }

  if (laddinfo->num_pairs GT 0) {
     ESA_DIAG_printf(ESA_COMP_STRSPRM, 1,
                     "Deleting deleted list items");
     strcpy(cmd,"SETROPTS ");
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                  cmd, MAX_OK_RC_4,
                  1, &laddinfo, mkt, delta_kdt,          /* IS10174 */
                  admin_params,                          /* IS10174 */
                  CMDOUT_YES, RACF_YES);
       /* IS10174 1, &laddinfo, mkt, delta_kdt, dest, msgs,   */
     if (rc NE ESA_OK)
        goto exit;
  }

 /*
  *   Add added items
  */

  ADDINFO_empty(laddinfo);
  for (i=0; strlen(delta[i].kwd); i++) {

      ESA_DIAG_printf(ESA_COMP_STRSPRM, 3,
          "Delta %d:%s: addval=%s", i, delta[i].kwd, delta[i].addval);

      if (strlen(delta[i].addval) GT 0)
         ADDINFO_insert(TYPE_1B, delta[i].addkwd,
                        delta[i].addval, laddinfo, RCF_ADDINFO_KWD_LEN,
                        RCF_ADDINFO_VAL_LEN, UNIQUE);
  }

  if (laddinfo->num_pairs GT 0) {
     ESA_DIAG_printf(ESA_COMP_STRSPRM, 1,
                     "Adding added list items");
     strcpy(cmd,"SETROPTS ");
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                  cmd, MAX_OK_RC_4,
                  1, &laddinfo, mkt, delta_kdt,          /* IS10174 */
                  admin_params,                          /* IS10174 */
                  CMDOUT_YES, RACF_YES);
       /* IS10174 1, &laddinfo, mkt, delta_kdt, dest, msgs,        */
     if (rc NE ESA_OK)
        goto exit;
  }

 /*
  *    Finished delta processing
  */

  exit:;

  ADDINFO_free(&laddinfo);

  ESA_DIAG_exit(ESA_COMP_STRSPRM, 1, func, rc);

  return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : CTSUpdParm_logop                           *
*                                                             *
* DESCRIPTION    : Update a Parameter list (LOGOPTIONS. )     *
*                                                             *
* INPUT          :                                            *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/

static ESA_RC CTSUpdParm_logop (DELTA_DESC_rec_typ   * delta,
                                ADDINFO_rec_typ      * addinfo,
                                ADMIN_PARAMS_rec_typ * admin_params,
                                ERR_STRUCT_rec_typ   * err)
{

  static char         func[]="CTSUpdParm_logop";

 /*
  *   Variables
  */

  ESA_RC                       rc = ESA_OK;
  char                         cmd[MAX_API_ST];
  ADDINFO_rec_ptr              laddinfo = NULL;
  ONE_FIELD_rec_ptr            cpair;
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;
  char                         msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];

  short i, delta_count;                         /* Delta Processing */
  ESA_RC rc_add, rc_del;                        /* Delta Processing */
  ESA_RC addval_rc;

  int  copy_size;                               /* WS10082 */

 /*
  *   Initialize
  */

  ESA_DIAG_enter(ESA_COMP_STRSPRM, 1, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

 /*
  *   Check if any of the delta_logop keywords were specified
  */

  delta_count=0;
  for (i=0; strlen(delta_logop[i].kwd); i++) {
      delta_logop[i].kwd_found = 0;
      strcpy( delta_logop[i].newval, NULL_STRING);
      cpair = ADDINFO_search(delta_logop[i].kwd,RCF_ADDINFO_KWD_LEN,
                             addinfo->pair,
                             addinfo->num_pairs );
      if (cpair NE NULL) {

         ESA_DIAG_printf(ESA_COMP_STRSPRM, 2,
                  "Delta %d: '%s' at %X", i, delta_logop[i].kwd, cpair);

         if ( (cpair->add_typ NE TYPE_1B ) AND
              (cpair->add_typ NE TYPE_2B )   ) {
            sprintf(msgbuf, "Invalid type=%d for list keyword=%s",
                    cpair->add_typ,  cpair->keyword);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func, msgbuf, 0, __LINE__);
         }

        /* WS10082 - start */
         if (cpair->vallen GT RCF_ADDINFO_VAL_LEN+1)
            copy_size = RCF_ADDINFO_VAL_LEN;
         else
            copy_size = cpair->vallen;

         snprintf(delta_logop[i].newval, copy_size, "%s", cpair->value);
        /* strcpy( delta_logop[i].newval, cpair->value); */
        /* WS10082 - end   */

         delta[i].add_typ = cpair->add_typ;

         RACF_get_option_value(delta_logop[i].kwd, cpair->add_typ,
                               delta_logop[i].oldval, dest,msgs );
         delta_count++;
         delta_logop[i].kwd_found = 1;

         strcpy( delta_logop[i].addval, NULL_STRING);
         strcpy( delta_logop[i].delval, NULL_STRING);

         rc_add = ADDINFO_list_diff(delta_logop[i].newval,
                               delta_logop[i].oldval,
                               delta_logop[i].addval,
                               ADDINFO_LIST_ENTRY, ADDINFO_LIST_ENTRY);
         rc_del = ADDINFO_list_diff(delta_logop[i].oldval,
                               delta_logop[i].newval,
                               delta_logop[i].delval,
                               ADDINFO_LIST_ENTRY, ADDINFO_LIST_ENTRY);

         ESA_DIAG_printf(ESA_COMP_STRSPRM, 3,
           "Del: diff rc=%d delval=%s", rc_del, delta_logop[i].delval);

         if ( (rc_del NE ESA_OK) OR (rc_add NE ESA_OK) ) {
            CTSAMSG_print(RACF_LISTDIFF, msgs, NULL, dest,
                          delta_logop[i].newval);
            rc = ESA_FATAL;
            goto exit;
         } /* Error in lists processing */
      }
  }

  ESA_DIAG_printf(ESA_COMP_STRSPRM, 1,
                  "Delta keywords count = %d", delta_count);

 /*
  *   If no delta keywords, finish
  */

  if ( delta_count EQ 0 ) {
     rc = ESA_OK;
     goto exit;
  }

 /*
  *   Prepare parameters for list fields processing
  */

  rc = ADDINFO_alloc(func, 1, &laddinfo, dest, msgs);
  if (rc NE ESA_OK) {
     rc = ESA_FATAL;
     goto exit;
  }

 /*
  *   Delete deleted items ( LOGOPTIONS.DEFAULT )
  */

  ADDINFO_empty(laddinfo);

  ADDINFO_insert(TYPE_1B,"LOGOPTIONS.DEFAULT",
                 NULL_STRING, laddinfo,
                 RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                 UNIQUE);

  cpair = ADDINFO_search("LOGOPTIONS.DEFAULT", RCF_ADDINFO_KWD_LEN,
                         laddinfo->pair,
                         laddinfo->num_pairs );

  if (cpair EQ NULL) {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   component,func,"LOGOPTIONS.DEFAULT field not found",
                   16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }

  for (i=0; strlen(delta_logop[i].kwd); i++) {

      ESA_DIAG_printf(ESA_COMP_STRSPRM, 3,
                 "Delta %d:%s: delval=%s",
                  i, delta_logop[i].kwd, delta_logop[i].delval);

      if (strlen(delta_logop[i].delval) GT 0) {
          addval_rc = ADDINFO_addval(delta_logop[i].delval,
                                     RCF_ADDINFO_VAL_LEN,
                                     ADDINFO_LIST_ENTRY, cpair,
                                     dest, msgs );
          if (addval_rc NE ESA_OK ) {
             CTSAMSG_print(RACF_ADDINFO_VAL_OVRFLW, msgs, NULL, dest,
                           delta_logop[i].kwd, delta_logop[i].delval);
             rc = ESA_FATAL;
             goto exit;
          }
      }
  }

  /* WS10082N if (strlen(cpair->value) GT 0) {  */
  if (strlen(get_pair(cpair, ->value)) GT 0) {            /* WS10082N */

     strcpy(cmd,"SETROPTS ");
     rc = racfcmd(func, EXECOUT_DDNAME, admin_params->admin_uname,
                  cmd, MAX_OK_RC_4,
                  1, &laddinfo, mkt, delta_logop_kdt,    /* IS10174 */
                  admin_params,                          /* IS10174 */
                  CMDOUT_YES, RACF_YES);
       /* IS10174 1, &laddinfo, mkt, delta_logop_kdt, dest, msgs,  */
     if (rc NE ESA_OK)
        goto exit;
  }

 /*
  *    Finished delta processing
  */

  exit:;

  ADDINFO_free(&laddinfo);

  ESA_DIAG_exit(ESA_COMP_STRSPRM, 1, func, rc);

  return rc;

}

