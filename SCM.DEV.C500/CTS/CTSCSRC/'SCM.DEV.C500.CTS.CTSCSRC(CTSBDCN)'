 /**************************************************************
 *                                                             *
 * Title            : Del user to user group connection        *
 *                                                             *
 * File Name        : ctsrdcn.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 15/07/97                                 *
 *                                                             *
 * Description      :                                          *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 * In ACF2 we implement a virtual group concept. A group is    *
 * a set of UIDMASKs representing values that should be placed *
 * in a user's UID string to give him access rights. The UID   *
 * masks in the group definitions sets EXACTLY the same access *
 * rights. It is used as an alternative where it is impossible *
 * to impose a mask on a UID string, but another one can be    *
 * imposed.                                                    *
 *                                                             *
 * Disconnecting a user from a group means that the same       *
 * positions in the user's UID string should be blanked-out.   *
 * That is, changed to a value allowing no access right result *
 * from the group association with the user. All the Group's   *
 * UIDMASKs are checked and every one of them associated with  *
 * the User's UID is disconnected.                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------- -------------------------------- *
 * BS2306   Guy      27/10/97 added new constant for group_uid *
 *                            and dest+msgs parms to function  *
 *                                                             *
 * BS2308   Guy      30/10/97 added call to ACF2_Get_User to   *
 *                            refresh UID fields' values in    *
 *                            each loop iteration.             *
 * PS0321   Guy      28/10/98 Added UIDX field (MULTI VALUE)   *
 * PS0339   Guy      26/11/98 Return connections of all user   *
 *                            UIDs if MULTI VALUED             *
 * PS0351   Guy      07/12/98 Support Multivalued fields       *
 * PS0357   Guy      17/12/98 Remove internal error message    *
 * BS2522   Yonatan  22/04/02 when UID updated, generate       *
 *                            an update to ESS.                *
 * BS2556   AvnerL   14/10/02 send acf2 original error msg     *
 * BS10097  SeligT   19/11/18 ACF2 Group Aggregation Endless   *
 *                            Loop                             *
 * IS10178  SeligT   18/12/18 Supporting LID Anywhere in UID   *
 * WS10076A AvnerL   19/01/20 Add admin_params 2 ACF2_Get_Group*
 * WS10078T ThomaS   15/05/20 DEL LID from role or source      *
 * BS10108T ThomaS   05/10/20 Support SYSID                    *
 * WS10079  ThomaS   31/12/20 JPMC phase2                      *
 * WS10079N NuritY   13/01/21 JPMC phase2                      *
 * WS10084  ThomaS   16/07/23 ACFRPTRX replacement - recompile *
 * BS10134  AvnerL   18/02/24 S0C4 when Sources aggregation    *
 * WS10082  MauriC   07/11/22 Recompile for new ADDINFO macros *
 * WS10082N NuritY   26/11/23 No need to call to interception  *
 *                            because it is done by hotpath.   *
 * WS10089  NuritY   15/12/24 XREF - do not add the user to    *
 *                            the exclude list when no masks.  *
 * WS10090  Nurity   01/09/24 Allow uid collision              *
 * BS10144  ThomaS   06/11/24 Endless loop in del user from    *
 *                            UID with a cent sign at the end: *
 *                            UID(*********************½)      *
 **************************************************************/
 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDLIB
 #include   STDIO
 #include   STRING

 /*
  *   ESA include files
  */

 #include ESA_DIAG
 #include ESA_API
 #include ESA_API_CODES
 #include ESA_CTSAMSG                         /* WS10078T */

 #include API_ADDINFO
 #include API_AUTH

 #include MVS_OS_CLI
 #include MVS_CODES                           /* WS10078T */
 #include MVS_COMP                            /* WS10078T */

 #include ACF2_CODES
 #include ACF2
 ASM_RTN_TYP           cts2ver;                          /* WS10079T */

/* WS10079N - start */
static ESA_RC Restore_XREF_commands(
                  char                 * type,
                  char                 * xref_name,
                  char                 * command_ops_to_restore,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params);
/* WS10079N - end  */

 static char component[] = "CTSBDCN";
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : CTSDelUserFromUG                           *
 *                                                             *
 * DESCRIPTION    : Delete Connection of User to UG            *
 *                                                             *
 * INPUT          : u2ug_params - Connection Information       *
 *                  addinfo     - connection attributes        *
 *                  admin,err                                  *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/
 ESA_RC CTSDelUserFromUG (U2UG_PARAMS_rec_typ * u2ug_params,
                        ADDINFO_rec_typ      * addinfo,
                        ADMIN_PARAMS_rec_typ * admin_params,
                        ERR_STRUCT_rec_typ   * err)
 {

   static char                func[]="CTSDelUserFromUG";

  /*
   *   Variables
   */

   ESA_RC                     rc = ESA_OK;
   /* WS10082N ESA_RC                rc_notify = ESA_OK; /@ BS2522 @/*/
   GDB_Codes                  GDB_rc;
   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;
   char                       errmsg[256]="";
   char                       temp[256]="";
   char                       UIDs_List[9600];            /* PS0339 */
   char                       entry_sep[2];               /* PS0351 */
   char                       msg[81]="";                 /* PS0351 */
   char                      *current_user_uid;           /* PS0351 */
   char                      *prev_user_uid;              /* BS10144 */
   UIDMASK                    User_UID;
   UIDMASK                    Primary_UID;                /* PS0351 */
   UIDMASK                    Group_UID[ACF2_MAX_GRP_UIDMASKS];
                                                          /* BS2306 */
   int i, Group_UID_Count = 0;
   USER_PARAMS_rec_typ        user_params;
   ADDINFO_rec_ptr            laddinfo = NULL;
   ADDINFO_rec_ptr            uaddinfo = NULL;
   ONE_FIELD_rec_ptr          pair;
   int                        Match_Found = FALSE;
   int                        handle_multi;               /* PS0351 */
   int                        start_over;                 /* PS0351 */
   int                        reason_code = 0;
   ACF2_API_Return_Codes      ACF2_rc = ACF2_OK;
   int                        LID_In_UID, LID_Offset;     /* BS10097 */
   int                        LID_Length;                 /* IS10178 */
   ACF2_PARAMS_rec_typ      * params_ptr = NULL;          /* BS10097 */
   /* WS10079N ADDINFO_rec_ptr   iaddinfo[1] = {NULL};  /* WS10078T */
   /* WS10079N GET_GROUP_MODE             mode;       /@ WS10078T @ */
   ONE_FIELD_rec_ptr          include_pair = NULL;       /* WS10078T */
   ONE_FIELD_rec_ptr          exclude_pair = NULL;       /* WS10078T */
   char                       in_include = NULL_CHAR;    /* WS10078T */
   char                       in_exclude = NULL_CHAR;    /* WS10078T */
   ADDINFO_rec_ptr            caddinfo = NULL;           /* WS10078T */
   char                       xref[4]  = "";             /* WS10078T */
   char                     * ptr = NULL;                /* WS10078T */
   XBhandle_rec_typ         * xbhandle         = NULL;   /* WS10079  */
   void                     * get_xref_handle  = NULL;   /* WS10079  */
   char                       block_read    = NULL_CHAR; /* WS10079  */
   char                       xrefname_out[19] = "";     /* WS10079  */
   XREF_Cmd_Struct_typ        xref_command_struct;       /* WS10079  */
   XREF_Operations_Lists_typ  * include_op_lists = NULL; /* WS10079  */
   XREF_Operations_Lists_typ  * exclude_op_lists = NULL; /* WS10079  */
   char                  command_ops_to_restore[7] = ""; /* WS10079  */
   char                       xreftype[8] = "";          /* WS10079  */
   int                        rc_asm=0;                  /* WS10079  */
   char                       acf_version[5]="";         /* WS10079  */
   int                        dbg_lvl=0;                 /* WS10079  */
   char      from_active_roles[]="from active roles";    /* WS10079  */
   char      from_active_sources[]="from active sources";/* WS10079  */
   char                     * allowed = NULL;            /* WS10079  */
   /* WS10079
   short                      max_num;                   /@ WS10078T @/
   HAVE_MORE_typ              have_more;                 /@ WS10078T @/
   short                      actual_num;                /@ WS10078T @/
   void                     * handle = NULL;             /@ WS10078T @/
   UG_PARAMS_rec_typ          ug_prm_in[1];              /@ WS10078T @/
   UG_PARAMS_rec_typ          ug_prm_out[1];             /@ WS10078T @/
   OBJ_EXISTS_typ             obj_exists[1];             /@ WS10078T @/
   char                       cmd[100] = "";             /@ WS10078T @/
   char                     * srch = NULL;               /@ WS10078T @/
   ONE_FIELD_rec_ptr          refresh_pair = NULL;       /@ WS10078T @/
   ONE_FIELD_rec_ptr          multi_pair   = NULL;       /@ BS10108T @/
   ONE_FIELD_rec_ptr          sysid_pair   = NULL;       /@ BS10108T @/
   short                      in_num;                    /@ WS10078T @/
   char                       refresh = 'N';             /@ WS10078T @/
   char                       skip_refresh = 'Y';        /@ WS10078T @/
   ESA_RC                     ref_rc    = ESA_OK;        /@ WS10078T @/
   ESA_RC                     roll_rc   = ESA_OK;        /@ WS10078T @/
   char                       type = NULL_CHAR;          /@ WS10078T @/
      WS10079 */

  /*
   *   Initialize
   */

   ESA_DIAG_enter(ESA_COMP_DELU2UG, DEBUG_SHOW_IMPORTANT, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;
   params_ptr = admin_params->apiinit_handle;             /* WS10079N */

   entry_sep[0] = ADDINFO_LIST_ENTRY;                     /* PS0351 */
   entry_sep[1] = NULL_CHAR;                              /* PS0351 */

   /* WS10079N  - start */
   if (ESA_DIAG_get_debug_level(ESA_COMP_DELU2UG) GE 6)
   {
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 0, "Addinfo at entry");
      ADDINFO_dump(addinfo, 1);
   };
   /* WS10079N - end   */

  /*  WS10079    start   */
  xref_command_struct.add_command = NULL;
  xref_command_struct.del_command = NULL;
  xref_command_struct.rep_command = NULL;
  xref_command_struct.ref_command = NULL;
  /*  WS10079    end     */
  /*     Start WS10078T                                            */
  pair = ADDINFO_search("TYPE", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
  if (pair NE NULL)
   {
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "XREF TYPE = <%.8s> user = <%.8s> group = <%.8s>",
           pair->value,u2ug_params->user,u2ug_params->group);

      if (strcmp(pair->value,"Role") EQ 0)
       {
        /* type='R';  WS10079 */
        strcpy(xref,"ROL");
        /* WS10079N mode = GET_MANY_ROLES;  */
        /* WS10079T start */
        /*
         *   Validate ACF2 version GE 16.0
         */

         if ((int)ESA_DIAG_get_debug_level(ESA_COMP_DELU2UG) GE 6)
            dbg_lvl=1;

         rc_asm=cts2ver(&dbg_lvl, acf_version);
         acf_version[3]=NULL_CHAR;
         ESA_DIAG_printf(ESA_COMP_DELU2UG,6,"ACF2 ver=<%s>",
                         acf_version);
         if (strcmp(acf_version,"160") LT 0)
         {
          sprintf(errmsg,
           "Disconnect user %s from %s %s: ",
           u2ug_params->user,
           pair->value, u2ug_params->group);              /* BS10134 */
           /* BS10134 xreftype,u2ug_params->group);   */
          CTSAMSG_print(ACF2_MIN_VER2,
                        msgs, NULL, dest,
                        errmsg,
                        "16.0","Roles",
                        "Disconnect request rejected");
          rc = ESA_FATAL;
          goto exit;
         }
        /* WS10079T end   */
       }
      else if (strcmp(pair->value,"Source") EQ 0)
       {
        /* type='S';  WS10079 */
        strcpy(xref,"SGP");
        /* WS10079N mode = GET_MANY_SOURCES;  */
       }
      else if (strcmp(pair->value,"Group" ) EQ 0)
       {
        /* type='G';  WS10079 */
        goto skip_xref;
       }
      else
       {
       /* WS10079T start
       sprintf(errmsg,"Invalid Type in addinfo: %.40s", pair->value);*/
        sprintf(errmsg,
         "Disconnect user = %s group = %s: "
         "Invalid Type in addinfo= %.40s",
          u2ug_params->user,u2ug_params->group,pair->value);
        /* WS10079T end   */
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
       }
      strcpy(xreftype,pair->value);                      /* WS10079T */
       /*   WS100079 start         REFRESH preparation is handled
            now by Xref_Commands_Create

      refresh_pair = ADDINFO_search("REFRESH", ACF_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
      if (refresh_pair NE NULL)
       {
          ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "XREF REFRESH = <%.8s>",
           refresh_pair->value);

          if (strcmp(refresh_pair->value,"Y") EQ 0)   /@ WS10078KG @/
              refresh = 'Y';
          else if (strcmp(refresh_pair->value,"N") EQ 0) /@ WS10078KG @/
              refresh = 'N';
          else
            {
             sprintf(errmsg,"Invalid REFRESH attribute = <%.8s>",
                     refresh_pair->value);
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component,func,
                    errmsg, 16,__LINE__);
             rc = ESA_FATAL;
             goto exit;
            }
       }
      else
       {
        sprintf(errmsg,"REFRESH attribute missing");
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
       }

          WS10079  end  */
      /*  WS10079    start   */
      /*
       *   Validate that the xref name provided is valid
       */

      rc = XREF_Validate_name(u2ug_params->group,
                              ESA_COMP_DELU2UG,
                              admin_params);
      if (rc NE ESA_OK)
       {
        /* WS10079T
        sprintf(errmsg,
         "Disconnect user = %s invalid group name = %s",
          u2ug_params->user,u2ug_params->group);

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
          func, errmsg, 16, __LINE__);
          func, "xref name is not valid", 16, __LINE__);     WS10079T */
        sprintf(errmsg,                                   /* WS10079T */
        "Disconnect user %s from %s %s: %s is invalid.",  /* WS10079T */
        u2ug_params->user,                                /* WS10079T */
        xreftype,u2ug_params->group,u2ug_params->group);  /* WS10079T */
        CTSAMSG_print(ACF2_AGGR_RCMND,                    /* WS10079T */
                      msgs, NULL, dest,                   /* WS10079T */
                      errmsg,                             /* WS10079T */
                      "Account");                         /* WS10079T */

        rc = ESA_FATAL;
        goto exit;
       }
      /*  WS10079    end     */
      /* WS10079N
      if (ADDINFO_alloc(func,ACF2_ADDINFO,&iaddinfo[0],dest,msgs)
                        NE ESA_OK)                              */
      if (ADDINFO_alloc(func,ACF2_ADDINFO,&laddinfo,      /* WS10079N */
                        dest,msgs)  NE ESA_OK)            /* WS10079N */
       {
        /* WS10079N
        sprintf(errmsg,"ADDINFO_alloc of iaddinfo failed. rc=%d",rc); */
        sprintf(errmsg,                                   /* WS10079N */
           "ADDINFO_alloc of laddinfo failed. rc=%d",rc); /* WS10079N */
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
       };

      rc = ADDINFO_insert(TYPE_1B,    /* change from 1A to 1B WS10079 */
                          "IncludeList", /* becuase it multivalued now*/
                          NULL,
           /* WS10079N    iaddinfo[0],  */
                          laddinfo,                       /* WS10079N */
                          ACF_ADDINFO_KWD_LEN,
                          ACF_ADDINFO_VAL_LEN,
                          UNIQUE);

      if (rc NE ESA_OK)
         {
          sprintf(errmsg,"Insert IncludeList keyword failed. rc=%d",rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
         }

      rc = ADDINFO_insert(TYPE_1B,    /* chnage from 1A to 1B WS10079 */
                          "ExcludeList", /* becuase it multivalued now*/
                          NULL,
           /* WS10079N    iaddinfo[0],  */
                          laddinfo,                       /* WS10079N */
                          ACF_ADDINFO_KWD_LEN,
                          ACF_ADDINFO_VAL_LEN,
                          UNIQUE);

      if (rc NE ESA_OK)
         {
          sprintf(errmsg,"Insert ExcludeList keyword failed. rc=%d",rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
         }

      /* WS10079  start */
      /* We want to issue a special message if found but not active */
      rc = ADDINFO_insert(TYPE_1A,
                          "Active",
                          NULL,
                          laddinfo,
                          ACF_ADDINFO_KWD_LEN,
                          ACF_ADDINFO_VAL_LEN,
                          UNIQUE);

      if (rc NE ESA_OK)
         {
          sprintf(errmsg,"Insert active keyword failed. rc=%d",rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
         }

      xbhandle = calloc(1, sizeof(XBhandle_rec_typ));
      if (xbhandle EQ NULL)
       {
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
          "XBhandle", sizeof(XBhandle_rec_typ));
          rc = ESA_FATAL;
          goto exit;
       }
      strcpy(xbhandle->request_type,"XREFONLY");
      strcpy(xbhandle->xrefname,u2ug_params->group);
      xbhandle->PB_type        = xref[0]; /* first char of ROL or SGP */
      xbhandle->active_request = 'C';
      xbhandle->need_rec_YN    = 'Y';
      xbhandle->sysidYN        = NULL_CHAR;
      xbhandle->active_check   = NULL_CHAR;
      xbhandle->active_default = NULL_CHAR;
      xbhandle->shortest       = NULL_CHAR;
      xbhandle->XREF_PB_handle   = NULL;
      xbhandle->Groups_PB_handle = NULL;
      xbhandle->bld_err        = FALSE;
      xbhandle->bld_nf         = FALSE;                   /* WS10079N */
      xbhandle->XB_err         = FALSE;

      /* WS10079N ACF2_Get_Xref(  */
      ACF2_rc = ACF2_Get_Xref(                            /* WS10079N */
                    "GETTHIS",
                    xbhandle,
                    &get_xref_handle,
                    'X',
                    &block_read,
                    u2ug_params->group,
                    xrefname_out,
                    laddinfo,
                    ESA_COMP_DELU2UG,
                    admin_params);

      /* WS10079N
      if ( rc EQ ACF2_Not_Found)
         {
           sprintf(errmsg,
           "Disconnect user %s from %s %s: %s not found",
           u2ug_params->user,
           xreftype,u2ug_params->group,u2ug_params->group);
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component, func,
                   errmsg,
                   16, __LINE__);                                    */
      if ( ACF2_rc EQ ACF2_Not_Found)                     /* WS10079N */
         {                                                /* WS10079N */
           CTSAMSG_print(ACF2_XREF_NOT_FOUND,             /* WS10079N */
                   msgs, NULL, dest,                      /* WS10079N */
                   (xbhandle->PB_type EQ 'R'?             /* WS10079N */
                                      "Role" : "Source"), /* WS10079N */
                   u2ug_params->group);                   /* WS10079N */
           rc = ESA_FATAL;
           goto exit;
         }
      /* WS10079N if ( rc NE ESA_OK) */
      if ( ACF2_rc NE ESA_OK)                             /* WS10079N */
         {
           sprintf(errmsg,
           "Disconnect user %s from %s %s: "
           "ACF2_Get_Xref rc =%d",
           u2ug_params->user,
           xreftype,u2ug_params->group,ACF2_rc);
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component, func,
                   errmsg,
                   16, __LINE__);
           rc = ESA_FATAL;
           goto exit;
         }
      /*** BS10134 start ***/
      /* Althoiugh we did not add isIncomlete to the addinfo,   */
      /* we may get is back if the role/source is too long.     */
      /* If isIncomplete=Y, we do not have the whole role.      */
      /* We will fail the request because we cannot use it for  */
      /* validating and executing the request.                  */
      else            /* ACF2_rc EQ ESA_OK */
      {
       pair = ADDINFO_search("isIncomplete",
                ACF_ADDINFO_KWD_LEN,
                laddinfo->pair,
                laddinfo->num_pairs);
       if (pair NE NULL)
       {
        if(pair->value[0] EQ 'Y')
        {
          sprintf(errmsg,
          "Cannot disconnect user %s from %s %s becasue it is too long",
                  u2ug_params->user,
                  xreftype,u2ug_params->group);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component, func,
                   errmsg,
                   16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
        }
       }
      }
      /*** BS10134 end   ***/
      /* item found - need to verify it is active */
      pair = ADDINFO_search("Active",
                          ACF_ADDINFO_KWD_LEN,
                          laddinfo->pair,
                          laddinfo->num_pairs);
      if (pair EQ NULL)
         {
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component, func,
                   "active attribute not found",  /* we just added it!*/
                   16, __LINE__);
           rc = ESA_FATAL;
           goto exit;
         }

      if (pair->value[0] NE 'Y')
         {
           sprintf(errmsg,
           "Disconnect user %s from",
           u2ug_params->user);

           if (strcmp(xreftype,"Role") EQ 0)
              allowed = from_active_roles;
           else
              allowed = from_active_sources;
           CTSAMSG_print(ACF2_NOT_ALLOWED, msgs, NULL, dest,
                   errmsg,       /* disconnect user <user> from  */
                   xreftype,     /* Role|Source                  */
                   u2ug_params->group, /* <xref name>            */
                   u2ug_params->group, /* <xref name>            */
                   "Disconnect",
                   allowed);     /* from active roles|sources    */
           /*
           CTS3964E %s %s %s is not allowed. Reason: %s is not active.
                    %s is allowed only %s.  */

           rc = ESA_FATAL;
           goto exit;
         }
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "ACF2_Get_Xref GETTHIS for %s found %s as Active",
          u2ug_params->group,
          xrefname_out);
      /* WS10079  end   */
      /* WS10079 start
      /@ BS10108T - start  @/
      rc = ADDINFO_insert(TYPE_1A,
                          "SYSID",
                          NULL,
                          iaddinfo[0],
                          ACF_ADDINFO_KWD_LEN,
                          ACF_ADDINFO_VAL_LEN,
                          UNIQUE);

      if (rc NE ESA_OK)
         {
          sprintf(errmsg,"Insert SYSID keyword failed. rc=%d",rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
         }

      rc = ADDINFO_insert(TYPE_1A,
                          "#is#multi#rec",
                          NULL,
                          iaddinfo[0],
                          ACF_ADDINFO_KWD_LEN,
                          ACF_ADDINFO_VAL_LEN,
                          UNIQUE);

      if (rc NE ESA_OK)
         {
          sprintf(errmsg,
                  "Insert #is#multi#rec keyword failed. rc=%d",rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
         }
      /@ BS10108T - end    @/
      WS10079  end */

      if (ADDINFO_alloc(func,1,&caddinfo,dest,msgs)
                        NE ESA_OK)
       {
        sprintf(errmsg,"ADDINFO_alloc of caddinfo failed. rc=%d",rc);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
       };


      /* WS10079  start
      strcpy((char *)ug_prm_in->group,u2ug_params->group);
      max_num = 1;
      in_num = 1;

      rc= CTSGetUGs (mode,
                  NULL,
                  max_num,
                  &actual_num,
                  &have_more,
                  &handle,
                  in_num,
                  ug_prm_in,
                  ug_prm_out,
                  iaddinfo,
                  obj_exists,
                  admin_params,
                  err);


      if (rc NE ESA_OK)
        {
          sprintf(errmsg,"Call to CTSGetUGs failed. rc=%d",rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
         goto exit;
        };

  /@ BS10108T - start  @/
  /@ If there are multiple roles/sources with the same name
     (and different SYSID), we don't know which entity is the
     correct one to del the LID from, so we fail the transaction @/

  multi_pair = ADDINFO_search("#is#multi#rec",ACF_ADDINFO_KWD_LEN,
                        iaddinfo[0]->pair,
                        iaddinfo[0]->num_pairs);

  if (multi_pair NE NULL)
   {
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "#is#multi#rec=<%s>",multi_pair->value);
      if (strcmp(multi_pair->value,"Y") EQ 0)
       {
          sprintf(errmsg,
                  "DEL LID <%s> from %s <%s> rejected: "
                  "Multiple <%s> entities exist",
                  u2ug_params->user, pair->value, u2ug_params->group,
                  u2ug_params->group);
          CTSAMSG_print(WARN_INT1, msgs, NULL, dest, component,func,
                        errmsg,16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
       };
   }

  sysid_pair = ADDINFO_search("SYSID",ACF_ADDINFO_KWD_LEN,
                        iaddinfo[0]->pair,
                        iaddinfo[0]->num_pairs);


  sysid_pair = ADDINFO_search("SYSID",ACF_ADDINFO_KWD_LEN,
                        iaddinfo[0]->pair,
                        iaddinfo[0]->num_pairs);

  if (sysid_pair EQ NULL)
   {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
           func, "No SYSID attribute", 16, __LINE__);
    rc = ESA_FATAL;
    goto exit;
   }


  ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "SYSID=<%s>",sysid_pair->value);

  if (sysid_pair->vallen EQ 0)
   {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
           func, "No SYSID value", 16, __LINE__);
    rc = ESA_FATAL;
    goto exit;
   }
  /@ BS10108T - end    @/
  WS10079   end  */
  include_pair = ADDINFO_search("IncludeList",ACF_ADDINFO_KWD_LEN,
                        laddinfo->pair,                   /* WS10079N */
                        laddinfo->num_pairs);             /* WS10079N */
         /* WS10079N    iaddinfo[0]->pair,
                        iaddinfo[0]->num_pairs);  */

  in_include = 'N';
  if (include_pair NE NULL)
   {
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "IncludeList=<%s>",include_pair->value);
      /* search in the list and set in_include = 'Y' if found */
      /*   WS100079 start
      srch = NULL;
      ptr =NULL;
      IS_LID_IN_LIST(u2ug_params->user,include_pair->value,srch,ptr);
           WS10079    end    */

      /*   WS100079 start  */
      /* If the LID is not in the IncludeList, no need to del  */
      ptr = ADDINFO_list_search(
                    include_pair->value,
                    u2ug_params->user,
                    ADDINFO_LIST_ENTRY);
      /*   WS100079 end    */
      if (ptr NE NULL)
       {
        ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                  "<%s> found in include list",u2ug_params->user);
        in_include = 'Y';
        /* If this is the only item in the includelist, we can't delete
           it because ACF2 doesn't allow to be without includelist    */
        if (strlen(u2ug_params->user) EQ strlen(include_pair->value) )
         {
            sprintf(errmsg,
             "LID %s can't be deleted from the IncludeList of %s %s "
             "because it is the only LID in the list. Deleting the "
             "whole %s is the only way to do it",
             u2ug_params->user,xref,u2ug_params->group,xref);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,component,
                   func,errmsg, 16,__LINE__);
            rc = ESA_FATAL;
            goto exit;
         }
       }
   }

  exclude_pair = ADDINFO_search("ExcludeList",ACF_ADDINFO_KWD_LEN,
                        laddinfo->pair,                   /* WS10079N */
                        laddinfo->num_pairs);             /* WS10079N */
         /* WS10079N    iaddinfo[0]->pair,
                        iaddinfo[0]->num_pairs);   */

  in_exclude = 'N';
  if (exclude_pair NE NULL)
   {
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
          "ExcludeList=<%s>",exclude_pair->value);
      /* search in the list and set in_exclude = 'Y' if found */
      /*   WS100079 start
      srch = NULL;
      ptr =NULL;
      IS_LID_IN_LIST(u2ug_params->user,exclude_pair->value,srch,ptr);
           WS10079    end    */

      /*   WS100079 start  */
      /* If the LID is in the ExcludeList we don't need to remove it */
      ptr = ADDINFO_list_search(
                    exclude_pair->value,
                    u2ug_params->user,
                    ADDINFO_LIST_ENTRY);
      if (ptr NE NULL)
       {
        ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                  "<%s> found in exclude list",u2ug_params->user);
        in_exclude = 'Y';
       }
   }

   /*                                                        WS10079N
    *  If nothing to do fail or ignore according to          WS10079N
    *  MSG_CONNGRP_ERR value.                                WS10079N
    */                                                    /* WS10079N */
   if ( (in_exclude EQ 'Y')  AND    /* If in exclude...      WS10079N */
        (in_include EQ 'N') )       /*   and not in include  WS10079N */
   {                                                      /* WS10079N */
     if (params_ptr->rssparm_MSG_CONNGRP_ERR[0] EQ 'Y')   /* WS10079N */
     {                                                    /* WS10079N */
        CTSAMSG_print(ERR_ALREADY_DISCONNECTED,           /* WS10079N */
                      msgs, NULL, dest,                   /* WS10079N */
                      u2ug_params->user,                  /* WS10079N */
                      u2ug_params->group);                /* WS10079N */
        rc = ESA_FATAL;                                   /* WS10079N */
     }                                                    /* WS10079N */
     else                                                 /* WS10079N */
       rc = ESA_OK;                                       /* WS10079N */
                                                          /* WS10079N */
     goto exit;                                           /* WS10079N */
   };                                                     /* WS10079N */

   if (in_exclude EQ 'N')     /* already in the exclude list? */
    {
      /*   WS100079 start   */
      /*   Not in ExcludeList - need to add it */
      /*   only if the exclude list contains a mask            WS10089 */
      if ( (strpbrk(exclude_pair->value, "*-") NE NULL) OR  /* WS10089 */
           (strpbrk(include_pair->value, "*-") NE NULL) )   /* WS10089 */
      {                                                     /* WS10089 */
        exclude_op_lists =
                calloc(1,sizeof(XREF_Operations_Lists_typ));
        if (exclude_op_lists EQ NULL)
         {
            CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
            "exc op list", sizeof(XREF_Operations_Lists_typ));
            rc = ESA_FATAL;
            goto exit;
         }
        exclude_op_lists->del_list = NULL;
        exclude_op_lists->rep_list = NULL;
        exclude_op_lists->add_list=
                calloc(1,strlen(u2ug_params->user)+1);
        if (exclude_op_lists->add_list EQ NULL)
         {
            CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
            "op_list", strlen(u2ug_params->user)+1);
            rc = ESA_FATAL;
            goto exit;
         }
         /* Xref_Commands_Create will prepare a command to add
            the LID to the ExcludeList based on what is in the
            exclude_op_lists->add_list                         */
        strcpy(exclude_op_lists->add_list,u2ug_params->user);
      }                                                   /* WS10089 */
    }

   if (in_include EQ 'Y') /* need to remove it from includelist? */
    {
      /*   Item is in IncludeList - need to delete it from there */
      include_op_lists =
              calloc(1,sizeof(XREF_Operations_Lists_typ));
      if (include_op_lists EQ NULL)
       {
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
          "inc op list", sizeof(XREF_Operations_Lists_typ));
          rc = ESA_FATAL;
          goto exit;
       }
      include_op_lists->add_list = NULL;
      include_op_lists->rep_list = NULL;
      include_op_lists->del_list=
              calloc(1,strlen(u2ug_params->user)+1);
      if (include_op_lists->del_list EQ NULL)
       {
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
          "op_list", strlen(u2ug_params->user)+1);
          rc = ESA_FATAL;
          goto exit;
       }
       /* Xref_Commands_Create will prepare a command to del
          the LID from the IncludeList based on what is in the
          include_op_lists->del_list                         */
      strcpy(include_op_lists->del_list,u2ug_params->user);
    }
    rc = XREF_Commands_Create(
                xref,
                addinfo,
                u2ug_params->group,
                "CHA",
                include_op_lists,
                exclude_op_lists,
                &xref_command_struct,
                ESA_COMP_DELU2UG,
                admin_params);

    ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
             "XREF_Commands_Create rc = %d",rc);


    if (rc NE ESA_OK)
     {
      sprintf(errmsg,
              "Disconnect user %s from %s %s: "
              "XREF_Commands_Create rc = %d",
              u2ug_params->user,
              xreftype,u2ug_params->group,rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
          func, errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
     }


   /*
    *   If ADD created, issue it first
    */


   if (xref_command_struct.add_command NE NULL)
     {
      /*
       *   Now go issue the command created in
       *   xref_command_struct.add_command area
       */

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Calling ACF2cmd with ADD command: %s",
                       xref_command_struct.add_command);

      rc = ACF2cmd(func,
                    EXECOUT_DDNAME,
                    admin_params->admin_uname,
                    xref_command_struct.add_command,
                    MAX_OK_RC_0,
                    0,
                    &caddinfo,
                    NULL,
                    NULL,
                    admin_params,
                    CMDOUT_YES,
                    ACF2_YES);

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "ACF2cmd rc = %d", rc);

      if (rc EQ ESA_FATAL)
         {
           sprintf(errmsg,
                   "CHA ADD of LID %s to %s %s ExcludeList "
                   "failed with rc=%d.\n"
                   "Command = <%.*s>",
                   u2ug_params->user,
                   xref,
                   u2ug_params->group,
                   rc,
                   strlen(xref_command_struct.add_command),
                   xref_command_struct.add_command);
           ESA_DIAG_printf(ESA_COMP_DELU2UG, 6, errmsg);

           sprintf(errmsg,
                   "Disconnect user %s from",
                   u2ug_params->user);
           CTSAMSG_print(ACF2_CMD_FAILURE, msgs, NULL, dest,
                   errmsg,
                   xreftype,u2ug_params->group,rc);
           rc = ESA_FATAL;
           goto exit;
         };
      strcpy(command_ops_to_restore,"ADD");
     }


   /*
    *   If DEL created, issue it
    */

   if (xref_command_struct.del_command NE NULL)
     {
      /*
       *   Now go issue the command created in
       *   xref_command_struct.del_command area
       */

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Calling ACF2cmd with DEL command: %s",
                       xref_command_struct.del_command);

      rc = ACF2cmd(func,
                    EXECOUT_DDNAME,
                    admin_params->admin_uname,
                    xref_command_struct.del_command,
                    MAX_OK_RC_0,
                    0,
                    &caddinfo,
                    NULL,
                    NULL,
                    admin_params,
                    CMDOUT_YES,
                    ACF2_YES);

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "ACF2cmd rc = %d", rc);

      if (rc EQ ESA_FATAL)
         {
           sprintf(errmsg,
                   "CHA DEL of LID %s from %s %s IncludeList "
                   "failed with rc=%d.\n"
                   "Command = <%.*s>",
                   u2ug_params->user,
                   xref,
                   u2ug_params->group,
                   rc,
                   strlen(xref_command_struct.del_command),
                   xref_command_struct.del_command);
           ESA_DIAG_printf(ESA_COMP_DELU2UG, 6, errmsg);

           sprintf(errmsg,
                   "Disconnect user %s from",
                   u2ug_params->user);
           CTSAMSG_print(ACF2_CMD_FAILURE, msgs, NULL, dest,
                   errmsg,
                   xreftype,u2ug_params->group,rc);

          if (command_ops_to_restore[0] EQ NULL_CHAR)
           {
             rc = ESA_FATAL;
             goto exit;
           }
          else
           {
             if (strncmp(command_ops_to_restore,"ADD",3) NE 0)
              {
                 sprintf(errmsg,
                   "Unexpected operation to roll back = %s. "
                   "Expected = ADD. Roll back skipped",
                   command_ops_to_restore);
                   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   component,func, errmsg, 16, __LINE__);
                   rc = ESA_FATAL;
                   goto exit;
              }
             sprintf(errmsg,
                  "Disconnect user %s from",
                  u2ug_params->user);
             CTSAMSG_print(ACF2_ROLLING_BACK, msgs, NULL, dest,
                  errmsg,
                  xreftype,u2ug_params->group,
                  strlen(xref_command_struct.add_command),
                  xref_command_struct.add_command);
             rc = Restore_XREF_commands(                  /* WS10079N */
                            xref,
                            u2ug_params->group,
                            command_ops_to_restore,
                            include_op_lists,
                            exclude_op_lists,
                            ESA_COMP_DELU2UG,
                            admin_params);
             ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Restore_XREF_commands rc = %d",rc);
             rc = ESA_FATAL;
             goto exit;
           };
         }

     }

   /*
    *   If REFRESH was requested then go issue the command in
    *   xref_command_struct.ref_command area
    */

   if (xref_command_struct.ref_command NE NULL)
    {

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Calling ACF2cmd with REFRESH command: %s",
                       xref_command_struct.ref_command);

      rc = ACF2cmd(func,
                 EXECOUT_DDNAME,
                 admin_params->admin_uname,
                 xref_command_struct.ref_command,
                 MAX_OK_RC_0,
                 0,
                 &caddinfo,
                 NULL,
                 NULL,
                 admin_params,
                 CMDOUT_YES,
                 ACF2_YES);


      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "ACF2cmd rc = %d", rc);

      /*
       *   If REFRESH command failed we don't want to fail the
       *   transaction, just issue a warning
       */

      if (rc NE ESA_OK)      /* refresh failed?  */
        {
          sprintf(errmsg,
                 "Disconnect user %s from %s %s: REFRESH",
                 u2ug_params->user,
                 xreftype,u2ug_params->group);
          CTSAMSG_print(ACF2_RESULTS_UNCERTAIN,
             msgs, NULL, dest,
             errmsg,rc);
          rc = ESA_WARN;
          goto exit;
        };
    };

    goto exit;                                            /* WS10079N */

   }
   /* WS10079 end */
      /*  WS10079 start
      /@ call ACF2cmd to add the LID to the exclude list          @/

      /@ Build the cmd:                                           @/
      /@ BS10108T - start @/
      /@ ACF2 ROL/SGP CHANGE Name EXCLUDE(LID) ADD SYSID(sysid)   @/
      /@
      sprintf(cmd, "ACF2 %s CHANGE %s EXCLUDE(%s) ADD",
                   xref,u2ug_params->group,u2ug_params->user);    @/

      sprintf(cmd, "ACF2 %s CHANGE %s EXCLUDE(%s) ADD SYSID(%s)",
         xref,u2ug_params->group,u2ug_params->user,sysid_pair->value);
      /@ BS10108T - end   @/

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Command to ACF2cmd (%s)",cmd);
      rc = ACF2cmd(func,
                   EXECOUT_DDNAME,
                   admin_params->admin_uname,
                   cmd,
                   MAX_OK_RC_0,
                   0,
                   &caddinfo,
                   NULL,
                   NULL,
                   admin_params,
                   CMDOUT_YES,
                   ACF2_YES);

      if (rc NE ESA_OK)
        {
          sprintf(errmsg,
         "ADD LID <%s> to EXCLUDE of <%s> failed. Check STDMSG. rc=%d",
          u2ug_params->user,u2ug_params->group,rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
        };
      skip_refresh = 'N';
    } /@ end of adding to exclude list  @/

   /@ The LID is in the EXCLUDE list (originally or we added it)  @/
   /@ If it is in the INCLUDE list we have to delete it from it   @/

   if (in_include EQ 'Y') /@ need to remove it from includelist? @/
    {
      /@ call ACF2cmd to del the LID from the include list        @/

      /@ Build the cmd:                                           @/
      /@ BS10108T - start @/
      /@ ACF2 ROL/SGP CHANGE Name INCLUDE(LID) DEL SYSID(sysid)   @/
      /@
      sprintf(cmd, "ACF2 %s CHANGE %s INCLUDE(%s) DEL",
                   xref,u2ug_params->group,u2ug_params->user);    @/
      sprintf(cmd, "ACF2 %s CHANGE %s INCLUDE(%s) DEL SYSID(%s)",
        xref,u2ug_params->group,u2ug_params->user,sysid_pair->value);
      /@ BS10108T - end   @/

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Command to ACF2cmd (%s)",cmd);

      rc = ACF2cmd(func,
                   EXECOUT_DDNAME,
                   admin_params->admin_uname,
                   cmd,
                   MAX_OK_RC_0,
                   0,
                   &caddinfo,
                   NULL,
                   NULL,
                   admin_params,
                   CMDOUT_YES,
                   ACF2_YES);

      if (rc NE ESA_OK)         /@ delete from include failed ? @/
        {
          skip_refresh = 'Y';
          sprintf(errmsg,
          "DEL LID <%s> from INCLUDE of <%s> failed. rc=%d",
          u2ug_params->user,u2ug_params->group,rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
        };

      if ((rc EQ ESA_FATAL) AND (in_exclude EQ 'N')) /@ Roll back?    @/
          /@ We need to roll back the add to exclude list             @/
        {
          sprintf(errmsg,
          "Rolling back previous ADD LID <%s> to EXCLUDE of <%s>",
          u2ug_params->user,u2ug_params->group);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);

          /@ Build the cmd:                                           @/
          /@ BS10108T - start @/
          /@ ACF2 ROL/SGP CHANGE Name EXCLUDE(LID) DEL SYSID(sysid)   @/
          /@
          sprintf(cmd, "ACF2 %s CHANGE %s EXCLUDE(%s) DEL",
                       xref,u2ug_params->group,u2ug_params->user);    @/

          sprintf(cmd, "ACF2 %s CHANGE %s EXCLUDE(%s) DEL SYSID(%s)",
           xref,u2ug_params->group,u2ug_params->user,sysid_pair->value);
          /@ BS10108T - end   @/

          ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                          "Command to ACF2cmd (%s)",cmd);

          roll_rc = ACF2cmd(func,
                       EXECOUT_DDNAME,
                       admin_params->admin_uname,
                       cmd,
                       MAX_OK_RC_0,
                       0,
                       &caddinfo,
                       NULL,
                       NULL,
                       admin_params,
                       CMDOUT_YES,
                       ACF2_YES);

          if (roll_rc NE ESA_OK)      /@ Roll back failed?  @/
            {
              sprintf(errmsg,
             "Roll back failed, results uncertain. Check STDMSG. rc=%d",
              u2ug_params->user,u2ug_params->group,roll_rc);
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                   errmsg, 16,__LINE__);
              rc = ESA_FATAL;
              goto exit;
            };
          rc = ESA_FATAL;
          goto exit;
        };    /@  end of roll back   @/

      if ((rc NE ESA_OK) AND (rc NE ESA_FATAL)) /@ del uncertain?  @/
          /@ Tell them we don't know what happened                 @/
        {
          sprintf(errmsg,
         "DEL from INCLUDE results uncertain. Check STDMSG. rc=%d",
          u2ug_params->user,u2ug_params->group,roll_rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_FATAL;
          goto exit;
        }
    }  /@ end of delete from include @/

    if (refresh EQ 'Y' AND skip_refresh EQ 'N')
     {
      /@ Build the cmd:                                           @/
      /@ ACF2 ROL F ACF2,NEWXREF,TYPE(ROL)         @/
      /@ or                                                       @/
      /@ ACF2 SGP F ACF2,NEWXREF,TYPE(SGP)         @/

      sprintf(cmd, "ACF2 %s F ACF2,NEWXREF,TYPE(%s)",
                   xref,xref);
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "Command to ACF2cmd (%s)",cmd);

      ref_rc = ACF2cmd(func,
                   EXECOUT_DDNAME,
                   admin_params->admin_uname,
                   cmd,
                   MAX_OK_RC_0,
                   0,
                   &caddinfo,
                   NULL,
                   NULL,
                   admin_params,
                   CMDOUT_YES,
                   ACF2_YES);

      if (ref_rc NE ESA_OK)      /@ refresh failed?  @/
        {
          sprintf(errmsg,
         "REFRESH results uncertain. Check STDMSG. ref_rc=%d",
          ref_rc);
          CTSAMSG_print(WARN_INT1, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
          rc = ESA_WARN;
          goto exit;
        };
     }
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,
                      "%s Disconnectnect from %s rc=%d",
                      u2ug_params->user,u2ug_params->group,rc);
      goto exit;
   }
   skip_xref:;
  /@     End   WS10078T                                            @/
     WS10079       */

   skip_xref:;                                          /* WS10079 */

  /*
   *   Obtain a local ADDINFO buffer
   */

   if (ADDINFO_alloc(func,ACF2_ADDINFO,&laddinfo,dest,msgs) NE ESA_OK)
    {
      rc = ESA_FATAL;
      goto term;
     };

   if (ADDINFO_alloc(func,ACF2_ADDINFO,&uaddinfo,dest,msgs) NE ESA_OK)
    {
      rc = ESA_FATAL;
      goto term;
     };

  /*
   *   Open Group Database for Read
   */

   GDB_rc = GDB_Set_Mode(GDB_ReadOnly,admin_params,err);

   switch(GDB_rc)
    {
     case GDB_OK:
      break;

     case GDB_Update_Lock_Failed:
      sprintf(errmsg,"Unable to obtain lock on group database");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;

     default:
      sprintf(errmsg,"Open GDB for Update failed, rc = %d",GDB_rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
    };

  /*
   *   Get the Connection's Group UIDMASKs
   */
   ADDINFO_empty(laddinfo);
   RESTORE_ENDING_BLANK(u2ug_params->group,
                        ESA_COMP_DELU2UG);                /* BS10097 */
   rc = ACF2_Get_Group_UIDMASKS(u2ug_params->group,
                                &Group_UID_Count,
                                Group_UID,
                                laddinfo,
                                &reason_code,
                                admin_params);            /*WS10076A*
                                dest,                      * BS2306 *
                                msgs);                     * BS2306 */

   if (rc NE ESA_OK)
    {
    switch(reason_code)
     {
      case 4:
        sprintf(errmsg,"No UIDMASKS field found for GROUP (%s)",
                u2ug_params->group);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                 errmsg, 16,__LINE__);
        break;
      case 8:
        CTSAMSG_print(ERR_NO_GROUP, msgs, NULL, dest,
                      u2ug_params->group);
        break;
      default:
        sprintf(errmsg,"Error in processing GROUP (%s)",
                      u2ug_params->group);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                 errmsg, 16,__LINE__);
     }
     goto exit;
   };

  /*
   *   Get the Connection's User info (all fields)
   */
   ADDINFO_empty(uaddinfo);
   temp[0] = NULL_CHAR;
   ACF2_rc = ACF2_Get_User(u2ug_params->user,
                      ACF2_Object_is_Not_Masked,
                      "",
                      temp,
                      ACF2_GetUser_Get_Fields,
                      "",
                      uaddinfo,
                      ACF2_Return_Multi_UIDs,             /* PS0351 */
                      errmsg,
                      admin_params);                      /*bs2556*/

   switch(ACF2_rc)
    {
     case ACF2_OK:
      break;
     case ACF2_Not_Found:
      CTSAMSG_print(ERR_NO_USER, msgs, NULL, dest, u2ug_params->user);
      rc = ESA_FATAL;
      goto exit;
     default:
      sprintf(errmsg,"Error in processing USER (%s)",
              u2ug_params->user);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
               errmsg, 16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
    };

  /*
   *   Get the Connection's User UID
   */
  pair = ADDINFO_search("UID", ACF_ADDINFO_KWD_LEN,
                        uaddinfo->pair,
                        uaddinfo->num_pairs);
  if (pair NE NULL)
   strcpy (User_UID,pair->value);
  else
   {
     rc = ESA_FATAL;
     sprintf(errmsg,"UID not found for USER (%s)", u2ug_params->user);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
          errmsg, 16,__LINE__);
     goto exit;                                           /* PS0351 */
    };

  strcpy (Primary_UID, User_UID);                         /* PS0351 */

  strcpy (UIDs_List, User_UID);                           /* PS0351 */

  handle_multi = FALSE;                                   /* PS0351 */

  start_over = FALSE;

  /*
   *   PS0351 - Do we have UIDX field (multivalued) ?
   */
  pair = ADDINFO_search("UIDX", ACF_ADDINFO_KWD_LEN,
                        uaddinfo->pair,
                        uaddinfo->num_pairs);
  /*------------------------------------------------------------*/
  /* Multivalued exists - turn flag ON and print special message*/
  /*------------------------------------------------------------*/
  if (pair NE NULL)
  {
    ESA_DIAG_printf(ESA_COMP_DELU2UG, DEBUG_SHOW_IMPORTANT,
                    "Multivalue UIDs found for user");

    handle_multi = TRUE;

    strcpy (UIDs_List, pair->value);

    CTSAMSG_print(ACF2_USER_UIDS_BEFORE, msgs, NULL, dest);

    current_user_uid = strtok (UIDs_List, entry_sep);

    /*----------------------------------------------------------*/
    /* Loop to print all user UIDs before DISCONNECT            */
    /*----------------------------------------------------------*/
    while (current_user_uid NE NULL)
    {
      sprintf (msg, "(%s)", current_user_uid);

      CTSAMSG_print(ACF2_OUTPUT_LINE, msgs, NULL, dest,
                    current_user_uid);

      current_user_uid = strtok (NULL, entry_sep);
    };

    strcpy (UIDs_List, pair->value);
  }
  else
    CTSAMSG_print(ACF2_USER_UID_BEFORE, msgs, NULL, dest, User_UID);

  current_user_uid = strtok (UIDs_List, entry_sep);

  /*------------------------------------------------------------*/
  /* Common handling for both multivalued and non-multivalued   */
  /*------------------------------------------------------------*/
  while (current_user_uid NE NULL)
  {
    ESA_DIAG_printf(ESA_COMP_DELU2UG, DEBUG_SHOW_IMPORTANT,
                    "Current User UID to check is (%s)",
                    current_user_uid);

    /*----------------------------------------------------------*/
    /* Check UIDMASKS against current User UID                  */
    /*----------------------------------------------------------*/
    for (i=0;i LT Group_UID_Count;i++)
    {
      ESA_DIAG_printf(ESA_COMP_DELU2UG, DEBUG_SHOW_REGULAR,
                      "Checking GROUP (%s) UIDMASK (%s)",
                      u2ug_params->group,
                      Group_UID[i]);

      /*--------------------------------------------------------*/
      /* If no match - skip to next UIDMASK in group            */
      /* If match    - perform DISCONNECT                       */
      /*--------------------------------------------------------*/
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,            /* BS10144... */
         "Before Match i = %d  current_user_uid = (%s)  Group_UID[i] = (%s)",
                 i, current_user_uid, Group_UID[i]);  /* ...BS10144 */

      if (ACF2_Match_Id_to_Mask(UID_Object,
                                current_user_uid,
                                Group_UID[i]) EQ FALSE)
      {                                                     /* BS10144 */
        ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,   "No Match"); /* BS10144 */
        continue;
      }                                                     /* BS10144 */
      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,   "Yes Match");  /* BS10144 */

      Match_Found = TRUE;

     /*
      *   Get the Update Command ADDINFO to perform the DISC
      */
      ADDINFO_empty(laddinfo);

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,                 /* BS10144... */
         "Before Generate_UID_Update ALLOW_UID_COLLISION = (%s)",
                 params_ptr->ALLOW_UID_COLLISION);         /* ...BS10144 */

      rc = Generate_UID_Update(Disconnect_Update,
                               current_user_uid,
                               Group_UID[i],
                               uaddinfo,
                               laddinfo,                  /* WS10090 */
                /* WS10090 */  params_ptr->ALLOW_UID_COLLISION[0]);
                /* WS10090     laddinfo);                          */


      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,                 /* BS10144... */
         "After  Generate_UID_Update: rc = %d laddinfo->num_pairs = %d",
                 rc,laddinfo->num_pairs);                  /* ...BS10144 */

      /*--------------------------------------------------------*/
      /* If Generate_UID_Update returned no modifications -     */
      /* continue to next UIDMASK in group                      */
      /*--------------------------------------------------------*/
      if (laddinfo->num_pairs EQ 0)
       continue;

     /*
      *   Build USA_API CTSUpdUser command parm
      */
      strcpy(user_params.user,u2ug_params->user);
      user_params.rev_status = USER_STAT_IGNORED;
      strcpy(user_params.passwd,BACKSLASH_STR);

     /*
      *   Set Indication for the Update processing to bypass forced
      *       disconnect check (see there).
      */
      ADDINFO_insert(TYPE_1A,
                     ACF2_BYPASS_DISCONNECT_CHECK,
                     "",
                     laddinfo,
                     ACF_ADDINFO_KWD_LEN,
                     ACF_ADDINFO_VAL_LEN,
                     UNIQUE);

     /*
      *   Generate The Update
      */
      rc = CTSUpdUser(&user_params,
                      laddinfo,
                      admin_params,
                      err);

      if (rc NE ESA_OK)
      {
        rc = ESA_FATAL;                                   /* PS0357 */
        /* PS0357 - Removed
        sprintf(errmsg,"Error in Updating USER (%s)",
                user_params.user);
        CTSAMSG_print(ERR_INTERNAL2,
             msgs, NULL, dest, component,func,
             errmsg, 16,__LINE__);
        */
        goto exit;
      };

    /* WS10082N  - this is not needed anymore because hotpath
                   sends the user.
    /@ BS2522
     @ send an interception about the updated userid, so
     @ its UID will be updated in ESS
     @/

    rc_notify = (admin_params->cs_func.intercept_set_ptr)
                          (INTERCEPT_SPECIFIC,
                           INTERCEPT_USER,
                           NULL,
                           u2ug_params->user,
                           NULL);

    if (rc_notify NE ESA_OK)
      {
        CTSAMSG_print(ACF2_NOTIFY_FAILED,msgs,NULL,dest,
                      u2ug_params->user);
        ESA_DIAG_printf(ESA_COMP_DELU2UG, DEBUG_SHOW_IMPORTANT,
         "notify Failed for user: %s rc: %d",
         u2ug_params->user,rc_notify);
       }

    /@ BS2522 - end @/
        WS10082N - end   */
      temp[0]=NULL_CHAR;
      ADDINFO_empty(laddinfo);

      /*--------------------------------------------------------*/
      /* Referesh user UID / UIDs                               */
      /*--------------------------------------------------------*/
      ACF2_rc = ACF2_Get_User_UID(u2ug_params->user,
                                  User_UID,
                                  temp,
                                  "",
                                  UIDs_List,
                                  laddinfo,
                                  admin_params);        /*bs2556*/

      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,                 /* BS10144... */
         "After  ACF2_Get_User_UID: User_UID = %s UIDs_List = %s",
                 User_UID, UIDs_List);                     /* ...BS10144 */
      temp[0] = NULL_CHAR;
      ADDINFO_empty(uaddinfo);

      /*--------------------------------------------------------*/
      /* Referesh all user fields                               */
      /*--------------------------------------------------------*/
      ACF2_rc = ACF2_Get_User(u2ug_params->user,
                         ACF2_Object_is_Not_Masked,
                         "",
                         temp,
                         ACF2_GetUser_Get_Fields,
                         "",
                         uaddinfo,
                         ACF2_Return_Multi_UIDs,
                         errmsg,
                         admin_params);        /*bs2556*/

      switch(ACF2_rc)
      {
        case ACF2_OK:
         break;
        case ACF2_Not_Found:
         CTSAMSG_print(ERR_NO_USER,
                       msgs, NULL, dest, u2ug_params->user);
         rc = ESA_FATAL;
         goto exit;
        default:
         sprintf(errmsg,"Error in processing USER (%s)",
                 u2ug_params->user);
         CTSAMSG_print(ERR_INTERNAL2,
                       msgs, NULL, dest, component,func,
                  errmsg, 16,__LINE__);
         rc = ESA_FATAL;
         goto exit;
      };


      ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,                 /* BS10144... */
         "After ACF2_Get_User  handle_multi = %d ",
                 handle_multi);                            /* ...BS10144 */

      if (NOT handle_multi)
        strcpy (UIDs_List, User_UID);

      /*--------------------------------------------------------*/
      /* Start all over again with new UID / UIDs list          */
      /*--------------------------------------------------------*/
      prev_user_uid = current_user_uid;                  /* BS10144 */
      current_user_uid = strtok (UIDs_List, entry_sep);
      if (strcmp(current_user_uid,prev_user_uid) NE 0)   /* BS10144 */
      start_over = TRUE;
      break;

    }; /* for loop */


    ESA_DIAG_printf(ESA_COMP_DELU2UG, 6,                 /* BS10144... */
         "After for loop start_over = %d ",
                 start_over);                            /* ...BS10144 */

    if (NOT start_over)
      current_user_uid = strtok (NULL, entry_sep);
    else
      start_over = FALSE;

  }; /* while loop */

  /*------------------------------------------------------------*/
  /* Print all UIDs after DISCONNECT                            */
  /*------------------------------------------------------------*/
  if (handle_multi)
  {
    pair = ADDINFO_search("UIDX", ACF_ADDINFO_KWD_LEN,
                          uaddinfo->pair,
                          uaddinfo->num_pairs);

    if (pair EQ NULL)
      CTSAMSG_print(ACF2_USER_UID_AFTER, msgs, NULL, dest, User_UID);
    else
    {
      strcpy (UIDs_List, pair->value);

      CTSAMSG_print(ACF2_USER_UIDS_AFTER, msgs, NULL, dest);

      current_user_uid = strtok (UIDs_List, entry_sep);

      /*----------------------------------------------------------*/
      /* Loop to print all user UIDs before DISCONNECT            */
      /*----------------------------------------------------------*/
      while (current_user_uid NE NULL)
      {
        sprintf (msg, "(%s)", current_user_uid);

        CTSAMSG_print(ACF2_OUTPUT_LINE, msgs, NULL, dest,
                      current_user_uid);

        current_user_uid = strtok (NULL, entry_sep);
      };
    };
  }
  else
    CTSAMSG_print(ACF2_USER_UID_AFTER, msgs, NULL, dest, User_UID);

   /*
    *   If no match was found between the User's UID and the Group
    *   UIDMASKs, the user was already disconnected (thats an error).
    */
   if (Match_Found EQ FALSE)
    {
     CTSAMSG_print(ERR_ALREADY_DISCONNECTED,
                   msgs, NULL, dest,
                   u2ug_params->user,
                   u2ug_params->group);

     /* PS0351 - Removed
     for(i=0;i LT Group_UID_Count;i++)
      CTSAMSG_print(ACF2_USER_GROUP_CONFLICT, msgs, NULL, dest,
       u2ug_params->user,
       User_UID,
       u2ug_params->group,
       i+1,
       Group_UID[i]);
      */

      rc = ESA_FATAL;
    }
   else
    rc = ESA_OK;

  /*
   *   Finish
   */

   exit:;

   /*  WS10079
   if (handle NE NULL)                                  /@ WS10078T @/
      free(handle);           WS10079 */                /* WS10078T */
   /* WS10079N if (iaddinfo[0] NE NULL)              /@ WS10078T @/
             ADDINFO_free(&iaddinfo[0]);             /@ WS10078T @/  */
   if (caddinfo NE NULL)                                /* WS10078T */
    ADDINFO_free(&caddinfo);                            /* WS10078T */
   if (laddinfo NE NULL)
    ADDINFO_free(&laddinfo);
   if (uaddinfo NE NULL)
    ADDINFO_free(&uaddinfo);
   /*  WS10079  start */
   if (get_xref_handle NE NULL)
      ACF2_Get_Xref(
                    "TERM",
                    xbhandle,
                    &get_xref_handle,
                    NULL_CHAR,
                    NULL,
                    NULL,
                    NULL,
                    addinfo,
                    ESA_COMP_DELU2UG,
                    admin_params);
   if (xbhandle NE NULL)
       free(xbhandle);
   if (include_op_lists NE NULL)
   {
      if (include_op_lists->del_list NE NULL)
         free(include_op_lists->del_list);
      if (include_op_lists->rep_list NE NULL)
         free(include_op_lists->rep_list);
      if (include_op_lists->add_list NE NULL)
         free(include_op_lists->add_list);
      free(include_op_lists);
   }
   if (exclude_op_lists NE NULL)
   {
      if (exclude_op_lists->del_list NE NULL)
         free(exclude_op_lists->del_list);
      if (exclude_op_lists->rep_list NE NULL)
         free(exclude_op_lists->rep_list);
      if (exclude_op_lists->add_list NE NULL)
         free(exclude_op_lists->add_list);
      free(exclude_op_lists);
   }
   if (xref_command_struct.add_command NE NULL)
      free(xref_command_struct.add_command);
   if (xref_command_struct.del_command NE NULL)
      free(xref_command_struct.del_command);
   if (xref_command_struct.rep_command NE NULL)
      free(xref_command_struct.rep_command);
   if (xref_command_struct.ref_command NE NULL)
      free(xref_command_struct.ref_command);
   /*  WS10079  end   */

   GDB_Set_Mode(GDB_Closed,admin_params,err);

   term:;

   ESA_DIAG_exit(ESA_COMP_DELU2UG, DEBUG_SHOW_IMPORTANT, func, rc);

   return rc;

}

 /* WS10079N - start */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : Restore_XREF_commands                      *
 *                                                             *
 * DESCRIPTION    : Restore commands that failed               *
 *                                                             *
 * INPUT            type                ROL/SGP           (I)  *
 *                  xref_name                             (I)  *
 *                  command_ops_to_restore                (I)  *
 *                                   - list of 3 char ops      *
 *                                     (ADD and/or DEL)   (I)  *
 *                                     to be restored     (I)  *
 *                  include_op_lists - pointer to existing     *
 *                                      op lists          (I)  *
 *                  exclude_op_lists - pointer to existing     *
 *                                      op lists          (I)  *
 *                  diag_comp                             (I)  *
 *                  admain_params                         (I)  *
 *                                                             *
 * OUTPUT         :                                            *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 * WS10079N:                                                   *
 * =========                                                   *
 * This code in this routine was moved from                    *
 * XREF_Commands_Restore (which resides in CTSBSRV) in order   *
 * to save the need to add CTSBCMD (for Acf2Cmd) to the        *
 * LONKCARDs of CTSCONI nd CTSCOFI. Both programs have         *
 * CTSBSRV in their LINKCARD so adding a code that calls       *
 * ACf2Cmd requires changing their LINKCARDs. To save this     *
 * need, XREF_COmmands_Restore was changed to prepare the      *
 * commands and its callers will issue them.                   *
 *                                                             *
 **************************************************************/

static ESA_RC Restore_XREF_commands(
                  char                 * type,
                  char                 * xref_name,
                  char                 * command_ops_to_restore,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

 static char    func[]="Restore_XREF_commands";

/*
 *     Variables
 */

 ESA_RC                      rc                  = ESA_OK;
 int                         i                   = 0;
 char                        op[4]               = "";
 char                        rst[4]              = "";
 char                        errmsg[125]         = "";
 char                      * pos                 = NULL;
 char                      * cmd                 = NULL;
 XREF_Cmd_Struct_typ         xref_command_struct;
 ADDINFO_rec_ptr             caddinfo            = NULL;
 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);

/*
 *     Alocate an empty ADDINFO fro ACF2cmd
 */

 if (ADDINFO_alloc(func,1,&caddinfo,dest,msgs) NE ESA_OK)
 {
   sprintf(errmsg,"ADDINFO_alloc of caddinfo failed. rc=%d",rc);
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                 errmsg, 16,__LINE__);
   rc = ESA_FATAL;
   goto exit;
 };

 /*
  *    Prepare the commands
  */
 rc = XREF_Commands_Restore(
                type,
                xref_name,
                command_ops_to_restore,
                include_op_lists,
                exclude_op_lists,
                &xref_command_struct,
                diag_comp,
                admin_params);
 if (rc NE ESA_OK)      /* restore failed?  */
 {
   sprintf(errmsg,
           "Prepare roll back commands (XREF_Commands_Restore) rc=%d "
           "Roll back will not be performed.",
           rc);
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                func, errmsg, 16,__LINE__);
   rc = ESA_FATAL;
   goto exit;
 };

 /*
  *  Execute the commands
  */
 for (i = strlen(command_ops_to_restore) / 3; i GE 1; i--)
 {
   pos = command_ops_to_restore + (i-1)*3;
   if (strncmp(pos,"ADD",3) EQ 0)
      {
       cmd = xref_command_struct.del_command;
       strcpy(op,"ADD");
       strcpy(rst,"DEL");
      }
   else
   if (strncmp(pos,"DEL",3) EQ 0)
      {
       cmd = xref_command_struct.add_command;
       strcpy(op,"DEL");
       strcpy(rst,"ADD");
      }

   ESA_DIAG_printf(diag_comp, 6,
                  "Calling ACF2cmd with %s to restore %s",
                  rst,op);

   rc = ACF2cmd(func,
           EXECOUT_DDNAME,
           admin_params->admin_uname,
           cmd,
           MAX_OK_RC_0,
           0,
           &caddinfo,
           NULL,
           NULL,
           admin_params,
           CMDOUT_YES,
           ACF2_YES);

   if (rc NE ESA_OK)      /* Roll back failed?  */
     {
       CTSAMSG_print(ACF2_RESULTS_UNCERTAIN,
          msgs, NULL, dest,
          "Roll back",rc);
       rc = ESA_FATAL;
       goto exit;
     };
  }

 exit:

  if (caddinfo NE NULL)
    ADDINFO_free(&caddinfo);

  if (xref_command_struct.add_command NE NULL)
    free(xref_command_struct.add_command);

  if (xref_command_struct.del_command NE NULL)
    free(xref_command_struct.del_command);

  if (xref_command_struct.rep_command NE NULL)
    free(xref_command_struct.rep_command);

  if (xref_command_struct.ref_command NE NULL)
    free(xref_command_struct.ref_command);

  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;

}
/* WS10079N - end */
