 /**************************************************************
 *                                                             *
 * Title            : Global vars services                     *
 *                                                             *
 * File Name        : ctstglb                                  *
 *                                                             *
 * Author           : Alexander Shvartsman                     *
 *                                                             *
 * Creation Date    : 22/02/97                                 *
 *                                                             *
 * Description      : TSS global vars services                 *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------  -------------------------------- *
 * PS0388   AlexS    29/09/99 Top Secret Version 5.1 Support   *
 * WS2359   AlexS    16/11/99 New ADMIN.MISC3 filed            *
 * WS2360   AlexS    16/11/99 New FACILITY subfileds           *
 * PS0509   RamiK    17/06/02 Top Secret Version 5.2 Support   *
 * BS2602   Bellap   18/05/03 Compile only with changed macros *
 * WS2530   AmirH    17/04/04 TSS 5.3, 5.4, 5.5 Support        *
 * IS0357   YoniMa   15/08/06 TSS R8 Support                   *
 * IS0361   YoniMa   20/08/06 TSS upgrade for v3.2.03,include: *
 *                            IS0345 - Fix BS2704.Recompile .  *
 *                            BS2705 - Fix BS2704.Recompile .  *
 *                            IS0347 - Support external CFILE  *
 *                            BS2713 - Recompile for CTSTF51   *
 *                            IS0354 - Recompile for CTSTF51   *
 * BS10014  ShmuelK  25/11/08 Recompile for CTSTF51            *
 * WS10022  AvnerL   18/01/09 ADD LINUX SUPPORT & DROP PC&VAX. *
 * IS10026  AvnerL   18/01/09 Drop support in TSS earlier 5.1. *
 * BS10016  AvnerL   26/02/09 Support recids 9621 & 4538.      *
 * IS10083  NuritY   28/05/13 Support TSS R14 (IS10035) - ...  *
 *                            ...compile only                  *
 * IS10084  NuritY   30/05/13 Support recids 9624&5,4406&9...  *
 *                            ... (BS10024) - compile only     *
 * IS10086  NuritY   30/05/13 Support TSS R15 (IS10043)...     *
 *                            ...compile only                  *
 * IS10087  NuritY   30/05/13 Support recids 9641-7 (BS10026)..*
 *                            ...compile only                  *
 * IS10089  NuritY   03/06/13 Support KERBEROS (WS10032)...    *
 *                            ...compile only                  *
 * IS10091  NuritY   06/06/13 Support dynamic tsscfile records *
 *                            table (WS10036)                  *
 * WS10050  AvnerL   18/08/15 Support MISC4 - compile only.    *
 * SAS2IBMT SeligT   09/10/16 SAS/C to IBM C Conversion Project*
 * IS10171  SeligT   15/04/18 Retrieve admin acid only if      *
 *                            admin was changed.               *
 *                            This was copied from change      *
 *                            WS10065 from V3 and was tagged   *
 *                            WS10065 here.                    *
 *                            -  -  -  -  -  -  -  -  -  -  -  *
 *                            After WS10065, when no admin is  *
 *                            provided, error messages are     *
 *                            issued.                          *
 *                            This was copied from change      *
 *                            BS10075 from V3 and was tagged   *
 *                            BS10075 here.                    *
 * BS10107  AvnerL   20/08/20 Increase MAX_RDT_ENTRIES to 1024 *
 * IS10184  NuritY   29/12/21 Improve scripts performance      *
 *                            (compile only, long/short names) *
 * WS10083  MauriC   21/06/22 Support user defined fields      *
 * WS10088  AvnerL   23/01/24 Recompile to support WAEMAIL     *
 ***************************************************************/
 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDIO
 #include   STDLIB
 #include   STRING
 #include   ERRNO                    /* WS10083 */

 /*
  *   ESA include files
  */

 #include ESA_DIAG
 #include ESA_CTSAMSG
 #include ESA_API
 #include ESA_API_CODES

 /*
  *   MVS include files
  */

 #include MVS_COMP
 #include MVS_OS_MVS
 #include API_ADDINFO

 /*
  *   TSS include files
  */

 #include TSS
 #include TSS_CODES

 /*IS10026 #include TSS_USER_RTT_TABLE                              */
 #include TSS_51_RTT_TABLE                                /* PS0388 */
 #include TSS_SGM_TABLE
 /* IS10026 #include TSS_TSSCFILE_TABLE  dropped                    */
 /* IS10091 #include TSS_TSSCFILE_TABLE_51                /* PS0388 */

 static char component[] = "CTSTGLB";

 static   CTSAMSG_DEST_TABLE_rec_typ  * glb_dest = NULL;  /* PS0388 */
 static   CTSAMSG_HANDLE_rec_typ      * glb_msgs = NULL;  /* PS0388 */

 struct _tss_params_global_table {
    char             * param_k;
    char               param_v[MAX_TSS_PARAM_LEN];
    TSS_VAL_MODE_typ  exists;
 };

 static int     global_param_done = 0;

 static struct _tss_params_global_table tss_api_global_params[] = {
     { TSS_GLOBAL_ADMIN_ACID         , "" , 0 } ,
     { TSS_GLOBAL_ADMIN_ACID_TYPE    , "" , 0 } ,
     { TSS_GLOBAL_ADMIN_DEP_ACID     , "" , 0 } ,
     { TSS_GLOBAL_ADMIN_DIV_ACID     , "" , 0 } ,
     { TSS_GLOBAL_ADMIN_ZONE_ACID    , "" , 0 } ,
     { TSS_GLOBAL_ADMIN_PARENT_ACID  , "" , 0 } ,
     { TSS_GLOBAL_ADMIN_PARENT_TYPE  , "" , 0 } ,
     { TSS_GLOBAL_ROOT_NAME          , "" , 0 } ,
     { TSS_GLOBAL_VERSION            , "" , 0 } ,
     { TSS_GLOBAL_DATE_FORMAT        , "" , 0 } ,
     { TSS_GLOBAL_RELEASE            , "" , 0 } ,   /* PS0388 */
     { NULL     ,    "", 0  },
             };

 /* WS10083 - start */
 static int global_rtt_table_done = 0;     /* default to false */
 static TSS_RTT_rec_typ* dynamic_rtt_51 = NULL; /* default to NULL */
 static short dynamic_rtt_num_items_51 = 0;
 /* WS10083 - end   */

 static int     global_rdt_table_done           = 0;
 static int     global_rdt_table_entries_number = 0;
 static ESA_RC  rc_rdt_table                    = ESA_OK;
 static RDT_RESTYPE_typ rdt_table[MAX_RDT_ENTRIES];

 static char internal2_msg_buf[200];

 static  char  *  TSS_convert_version(char      *tss_ver);

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_global_dump                            *
 *                                                             *
 * DESCRIPTION    : Dump global vars                           *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static void TSS_global_dump (ESA_DIAG_COMP_typ       comp,
               struct _tss_params_global_table        glb_table[1])
 {

   static char  func[]="TSS_global_dump";
   int   i;

   ESA_DIAG_enter(comp, 5, func);

  /*
   *  Dump global parameters structure
   */

   for(i=0; glb_table[i].param_k; i++)
       ESA_DIAG_printf(comp,5,"%d %d %s=%s",
                       i, glb_table[i].exists,
                       glb_table[i].param_k,
                       glb_table[i].param_v);

  ESA_DIAG_exit(comp, 5, func, ESA_OK );

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_put_global_parameter                   *
 *                                                             *
 * DESCRIPTION    : Put global parameter                       *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  param_k       - parameter key              *
 *                  param_v       - parameter value            *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_put_global_parameter(ESA_DIAG_COMP_typ    comp,
                struct _tss_params_global_table        glb_table[1],
                char                                 * param_k,
                char                                 * param_v,
                CTSAMSG_DEST_TABLE_rec_typ           * dest,
                CTSAMSG_HANDLE_rec_typ               * msgs)
 {

   static char  func[]="TSS_put_global_parameter";
   ESA_RC rc = ESA_OK;
   int    i;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 8, func);

   ESA_DIAG_printf(comp,8, "parameter %s=(%d)%s",
                   param_k, strlen(param_v), param_v );

   for(i=0; glb_table[i].param_k; i++) {
       if ( strcmp(glb_table[i].param_k, param_k ) EQ 0 ) {
          strcpy(glb_table[i].param_v , param_v );
          glb_table[i].exists = TSS_VAL_EXISTS;
          goto exit;
       }
   }

   sprintf(internal2_msg_buf,
           "Unable to locate global parameter %s", param_k );
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                 component, func, internal2_msg_buf,
                 4, __LINE__);
   OS_MVS_btrace();
   rc = ESA_ERR;

  /*
   *    Finish
   */

 exit :;

  ESA_DIAG_exit(comp, 8, func, rc );
  return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_global_init                            *
 *                                                             *
 * DESCRIPTION    : Initialize global table                    *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  admin_params                               *
 *                  err                                        *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_global_init (ESA_DIAG_COMP_typ       comp,
                         ADMIN_PARAMS_rec_typ  * admin_params,
                         ERR_STRUCT_rec_typ    * err)
 {

   ESA_RC                       rc = ESA_OK;
   static char                  func[]="TSS_global_init";
   char                         prnt[MAX_TSS_PARAM_LEN + 1];
   char                         prnt_t[MAX_TSS_PARAM_LEN + 1];
   TSS_ACID_HEADER_rec_typ      acid_info;
   TSS_MODIFY_RET_typ           modify_info;
   char                         d_fmt[MAX_TSS_PARAM_LEN + 1];
   char                         t_ver[MAX_TSS_PARAM_LEN + 1];
   char                         t_rel[MAX_TSS_PARAM_LEN + 1];/*PS0388*/
   char                         r_nam[MAX_TSS_PARAM_LEN + 1];
   char                       tss_ver[MAX_TSS_PARAM_LEN + 1];/*IS0347*/
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;
   int                          i;
   int                          debug_level;

   /****   OS_MVS_whoami parameters  ****/

   char                         jobname[10];
   char                         jobid[10];
   char                         userid[10];
   char                         sysid[9];
   void                         *acee;

   /* WS10065 - start */
   char                         temp_admin_acid[TSS_USER_NAME_LEN + 1];
   char                         temp_admin_uname[TSS_USER_NAME_LEN + 1];
   char                       * blank_ptr;
   /* WS10065 - end  */

   /*   Assembler module. Get override TSS version */

   /* SAS2IBMT
   extern ESA_RC ctssver(int  *debug_level,
                         char *tss_override_version);                */
   extern ESA_RC ctssver();                               /* SAS2IBMT */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 8, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   glb_dest = dest;            /* PS0388 */
   glb_msgs = msgs;            /* PS0388 */

   d_fmt[0] = NULL_CHAR;
   t_ver[0] = NULL_CHAR;
   t_rel[0] = NULL_CHAR;       /* PS0388 */
   r_nam[0] = NULL_CHAR;
   acid_info.acid[0] = NULL_CHAR;                          /* WS10065 */
   acid_info.type[0] = NULL_CHAR;                          /* WS10065 */
   acid_info.dept_acid[0] = NULL_CHAR;                     /* WS10065 */
   acid_info.div_acid[0] = NULL_CHAR;                      /* WS10065 */
   acid_info.zone_acid[0] = NULL_CHAR;                     /* WS10065 */
   prnt[0] = NULL_CHAR;                                    /* WS10065 */
   prnt_t[0] = NULL_CHAR;                                  /* WS10065 */

   if (global_param_done) {
       TSS_get_global_parameter(comp,  TSS_GLOBAL_DATE_FORMAT,
                                d_fmt, dest, msgs);
       TSS_get_global_parameter(comp,  TSS_GLOBAL_VERSION,
                                t_ver, dest, msgs);
       TSS_get_global_parameter(comp,  TSS_GLOBAL_RELEASE,  /*PS0388*/
                                t_rel, dest, msgs);         /*PS0388*/
       TSS_get_global_parameter(comp,  TSS_GLOBAL_ROOT_NAME,
                                r_nam, dest, msgs);
    /* WS10065 - start */
    /*
     *  For performance improvement, keep the admin acid details
     *  so that we can re-use them if admin was not changed.
     */
     /* BS10075 - change the calls from TSS_get_global_parameter
                  to TSS_get_global_parameter_cond and pass
                  TRUE as 4th parameter.                          */
     /*
     TSS_get_global_parameter_cond(comp,  TSS_GLOBAL_ADMIN_ACID,
                              acid_info.acid, dest, msgs);        */
     rc = TSS_get_global_parameter_cond(comp,TSS_GLOBAL_ADMIN_ACID,
                              acid_info.acid, dest, msgs);
     if (rc EQ ESA_OK)   /* if acid exists, take all other   BS10075 */
     {                                                    /* BS10075 */
       TSS_get_global_parameter_cond(comp,  TSS_GLOBAL_ADMIN_ACID_TYPE,
                                acid_info.type, dest, msgs);
       TSS_get_global_parameter_cond(comp,  TSS_GLOBAL_ADMIN_DEP_ACID,
                                acid_info.dept_acid, dest, msgs);
       TSS_get_global_parameter_cond(comp,  TSS_GLOBAL_ADMIN_DIV_ACID,
                                acid_info.div_acid, dest, msgs);
       TSS_get_global_parameter_cond(comp,  TSS_GLOBAL_ADMIN_ZONE_ACID,
                                acid_info.zone_acid, dest, msgs);
       TSS_get_global_parameter_cond(comp, TSS_GLOBAL_ADMIN_PARENT_ACID,
                                prnt, dest, msgs);
       TSS_get_global_parameter_cond(comp, TSS_GLOBAL_ADMIN_PARENT_TYPE,
                                prnt_t, dest, msgs);
     }                                                    /* BS10075 */
     else                                                 /* BS10075 */
       rc = ESA_OK;                        /* reset rc       BS10075 */

     ESA_DIAG_printf(comp, 8,
          "Saved admin: %s / %s / %s / %s / %s / %s / %s",
          acid_info.acid, acid_info.type, acid_info.dept_acid,
          acid_info.div_acid, acid_info.zone_acid, prnt, prnt_t);
    /* WS10065 - end  */
   }

  /*
   *  Clear global parameters structure
   */

   for(i=0; tss_api_global_params[i].param_k; i++) {
       tss_api_global_params[i].param_v[0] = NULL_CHAR;
       tss_api_global_params[i].exists     = TSS_VAL_NOT_EXISTS;
   }

  /*
   *  Get modify parameters
   */

   if ( NOT global_param_done) {
      modify_info.version[0]     = NULL_CHAR;
      modify_info.date_format[0] = NULL_CHAR;

      rc = TSS_get_modify_info(comp, &modify_info, admin_params, err);
      if ( rc NE ESA_OK )
         goto exit;

      strcpy(d_fmt, modify_info.date_format);
      strcpy(t_ver, modify_info.version);
      strcpy(t_rel, modify_info.version);    /* PS0388 */

      /* IS0347 start */
      /* get TSS_VERSION parameter */
      rc=admin_params->cs_func.rssprm_get_opt_ptr(admin_params->rss_name,
                                              TSS_VERSION,
                                              sizeof(tss_ver),
                                              tss_ver,
                                              OPT_TRUE,
                                              OPT_TRUE) ;
      if (rc EQ ESA_OK)
      {
          strcpy(t_ver, tss_ver);
          strcpy(t_rel, tss_ver);
      }
      /* IS0347 end */
      /*** Obtain root name parameter ***/

      rc = admin_params->cs_func.rssprm_get_ptr(admin_params->rss_name,
                                                TSS_ROOT_NAME_PARM,
                                                sizeof(r_nam), r_nam);
      if ( rc NE ESA_OK )    /* Parameter not found */
        strcpy(r_nam, TSS_ROOT);
      else {          /* Examine obtained parameter */
        if ( strcmp(r_nam, "&SYSID") EQ 0 ) {
           OS_MVS_whoami(jobname, jobid, userid, sysid, &acee);
           strcpy(r_nam, "TSS");
           strcat(r_nam, sysid);
        }
      }
   }

   /***  Return back tss version parameter ***/

   if ( strlen(t_ver) GT 0 )   {

      /*   Invoke program check TSS status */

      debug_level = ESA_DIAG_get_debug_level(ESA_COMP_RSS_CHECK);

      /*   Obtain TSS override version */

      /* SAS2IBMT
      ctssver(&debug_level, t_ver);                                  */
      (*(ASM_RTN_TYP *)&ctssver)(&debug_level, t_ver);    /* SAS2IBMT */

      TSS_put_global_parameter(comp, tss_api_global_params,  /*PS0388*/
                               TSS_GLOBAL_RELEASE,           /*PS0388*/
                               t_rel,                        /*PS0388*/
                               dest, msgs );                 /*PS0388*/

      TSS_put_global_parameter(comp, tss_api_global_params,
                               TSS_GLOBAL_VERSION,
                               TSS_convert_version(t_ver),
                               dest, msgs );
   }

   /***  Return back date format parameter ***/

   if ( strlen(d_fmt) GT 0 )
      TSS_put_global_parameter(comp, tss_api_global_params,
                               TSS_GLOBAL_DATE_FORMAT,
                               d_fmt, dest, msgs );

   /***  Return back root name parameter ***/

   if ( strlen(r_nam) GT 0 )
      TSS_put_global_parameter(comp, tss_api_global_params,
                               TSS_GLOBAL_ROOT_NAME,
                               r_nam, dest, msgs );
   global_param_done = 1;

  /*
   *  Get RDT table
   */

   if (NOT global_rdt_table_done)
      rc_rdt_table = TSS_get_rdt_table(comp,
                                       &global_rdt_table_entries_number,
                                       rdt_table, admin_params, err);

   global_rdt_table_done = 1;

  /* WS10083 start
   *
   *  Get RTT table
   *  Create dynamic RTT containing static RTT and TSS FDT
   */
   if (NOT global_rtt_table_done) {
      rc = TSS_get_FDT(comp, admin_params, err);
      rc = ESA_OK;  /* rc is ignored in this case */
   }

   global_rtt_table_done = 1;
  /* WS10083 end */

  /*
   *  Get admin acid parameters
   */

   if (strlen(admin_params->admin_uname) EQ 0 )
     goto exit;

   /* WS10065 - start */
   /* Retrieve admin details only if admin was changed */
   /* Otherwise, we already have them from previous transaction */
   strcpy(temp_admin_acid, acid_info.acid);
   strcpy(temp_admin_uname,admin_params->admin_uname);
   /* IS10171 strupr(temp_admin_acid); */
   for (i=0; i LT strlen(temp_admin_acid); i++)           /* IS10171 */
     temp_admin_acid[i] = toupper(temp_admin_acid[i]);    /* IS10171 */
   blank_ptr = strrchr(temp_admin_acid, ' ');
   if (blank_ptr NE NULL)
     *blank_ptr = NULL_CHAR;
   /* IS10171 strupr(temp_admin_uname); */
   for (i=0; i LT strlen(temp_admin_uname); i++)          /* IS10171 */
     temp_admin_uname[i] = toupper(temp_admin_uname[i]);  /* IS10171 */
   blank_ptr = strrchr(temp_admin_uname, ' ');
   if (blank_ptr NE NULL)
     *blank_ptr = NULL_CHAR;

   ESA_DIAG_printf(comp, 8,
    "admin_uname = (%d)%s / (%d)%s    saved_admin = (%d)%s / (%d)%s",
     strlen(admin_params->admin_uname), admin_params->admin_uname,
     strlen(temp_admin_uname), temp_admin_uname,
     strlen(acid_info.acid), acid_info.acid,
     strlen(temp_admin_acid), temp_admin_acid);

   if (strcmp(temp_admin_uname, temp_admin_acid) NE 0)
   {
     /* clear the acid info area before retrieving the details       */
     /* of the new admin.                                            */
     acid_info.acid[0] = NULL_CHAR;
     acid_info.type[0] = NULL_CHAR;
     acid_info.dept_acid[0] = NULL_CHAR;
     acid_info.div_acid[0] = NULL_CHAR;
     acid_info.zone_acid[0] = NULL_CHAR;
     prnt[0] = NULL_CHAR;
     prnt_t[0] = NULL_CHAR;

     ESA_DIAG_printf(comp, 8, "Get acid header for %s",
                     admin_params->admin_uname);
   /* WS10065 - end  */
     rc = TSS_get_acid_header(comp, TSS_CMD_DEFAULT_MODE,
                              admin_params->admin_uname, &acid_info,
                              admin_params, err);
     if ( rc NE ESA_OK )
         goto exit;

     if ( (strcmp(acid_info.type, TSS_USER  )   EQ 0 )  OR
          (strcmp(acid_info.type, TSS_DCA   )   EQ 0 )  OR
          (strcmp(acid_info.type, TSS_PROFILE ) EQ 0 )  OR
          (strcmp(acid_info.type, TSS_GROUP )   EQ 0 )   ) {
        strcpy(prnt,   acid_info.dept_acid);
        strcpy(prnt_t, TSS_DEPARTMENT);
     }
     else if ( (strcmp(acid_info.type, TSS_VCA       ) EQ 0 ) OR
               (strcmp(acid_info.type, TSS_DEPARTMENT) EQ 0 )  ) {
        strcpy(prnt, acid_info.div_acid);
        strcpy(prnt_t, TSS_DIVISION);
     }
     else if ( (strcmp(acid_info.type, TSS_ZCA      ) EQ 0 )  OR
               (strcmp(acid_info.type, TSS_DIVISION ) EQ 0 )   ) {
        strcpy(prnt, acid_info.zone_acid);
        strcpy(prnt_t, TSS_ZONE);
     }
     else {
        strcpy(prnt,   TSS_ROOT );
        strcpy(prnt_t, "");
     }
   }    /* end of admin details retrieve                   WS10065 */

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_ACID ,
                            acid_info.acid, dest, msgs );

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_ACID_TYPE ,
                            acid_info.type, dest, msgs );

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_DEP_ACID ,
                            acid_info.dept_acid, dest, msgs );

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_DIV_ACID ,
                            acid_info.div_acid, dest, msgs );

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_ZONE_ACID ,
                            acid_info.zone_acid, dest, msgs );

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_PARENT_ACID ,
                            prnt, dest, msgs );

   TSS_put_global_parameter(comp, tss_api_global_params,
                            TSS_GLOBAL_ADMIN_PARENT_TYPE ,
                            prnt_t, dest, msgs );

  /*
   *    Finish
   */

 exit :;

  TSS_global_dump(comp, tss_api_global_params);

  ESA_DIAG_exit(comp, 8, func, rc );
  return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_global_segments                    *
 *                                                             *
 * DESCRIPTION    : Return segments table ptr                  *
 *                                                             *
 * INPUT          : none                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : segment table ptr                          *
 *                                                             *
 **************************************************************/

 TSS_SGM_rec_typ  *   TSS_get_global_segments ( void )
 {
    return tss_segments;
 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_global_rtt                         *
 *                                                             *
 * DESCRIPTION    : Return rtt      table ptr                  *
 *                                                             *
 * INPUT          : none                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : rtt     table ptr                          *
 *                                                             *
 **************************************************************/

 TSS_RTT_rec_typ  *   TSS_get_global_rtt( void )
 {
    /* IS10026 always return rtt_51 as we do not support earlier
     *         versions than CA-TSS 5.1 .                        *
    char              t_rel[MAX_TSS_PARAM_LEN + 1] = ""; /*PS0388*
    ESA_DIAG_COMP_typ comp = ESA_COMP_USAAPI;            /*PS0388*

    TSS_get_global_parameter(comp,  TSS_GLOBAL_RELEASE,  /*PS0388*
                             t_rel, glb_dest, glb_msgs); /*PS0388*
    ESA_DIAG_printf(comp,5, "Parameter %s=%s",           /*PS0388*
                    TSS_GLOBAL_RELEASE, t_rel);          /*PS0388*

    if (strcmp(t_rel, "5.0") EQ 0)                       /*IS0357*
      return rtt;                                        /*IS0357*
    /* IS0357 support tss 5.0 and above
    if (strcmp(t_rel, "5.1") EQ 0)                        *PS0388*
      return rtt_51;                                      *PS0388*
    else if (strcmp(t_rel, "5.2") EQ 0)                   *PS0509*
      return rtt_51;                                      *PS0509*
    else if (strcmp(t_rel, "5.3") EQ 0)                   *WS2530*
      return rtt_51;                                      *WS2530*
    else if (strcmp(t_rel, "5.4") EQ 0)                   *WS2530*
      return rtt_51;                                      *WS2530*
    else if (strcmp(t_rel, "5.5") EQ 0)                   *WS2530*
      return rtt_51;                                      *WS2530*
                                                   end of IS0357 *
    else                                           end of IS10026*/
   /*WS10083 return rtt_51; default is ts 5.1 and above IS0357 */
    /* WS10083 start */
    if (dynamic_rtt_51 EQ NULL) /* if dynamic table not set */
       return rtt_51;           /* use static table */
    else
      return dynamic_rtt_51; /* use new dynamic table */
    /* WS10083 start */

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_global_rtt_num_items               *
 *                                                             *
 * DESCRIPTION    : Return rtt  num items                      *
 *                                                             *
 * INPUT          : none                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : rtt  num items                             *
 *                                                             *
 **************************************************************/

 short TSS_get_global_rtt_num_items ( void )
 {
    /* IS10026 always return rtt_51 as we do not support earlier
     *         versions than CA-TSS 5.1 .                        *

    char              t_rel[MAX_TSS_PARAM_LEN + 1] = ""; /*PS0388*
    ESA_DIAG_COMP_typ comp = ESA_COMP_USAAPI;            /*PS0388*

    TSS_get_global_parameter(comp,  TSS_GLOBAL_RELEASE,  /*PS0388*
                             t_rel, glb_dest, glb_msgs); /*PS0388*
    ESA_DIAG_printf(comp,5, "Parameter %s=%s",           /*PS0388*
                    TSS_GLOBAL_RELEASE, t_rel);          /*PS0388*


    if (strcmp(t_rel, "5.0") EQ 0)                       /*IS0357*
      return rtt_num_items;                              /*IS0357*
 /* support tss 5.0 and above. default is 5.1 & +          IS0357
    if (strcmp(t_rel, "5.1") EQ 0)                        *PS0388*
      return rtt_num_items_51;                            *PS0388*
    else if (strcmp(t_rel, "5.2") EQ 0)                   *PS0509*
      return rtt_num_items_51;                            *PS0509*
    else if (strcmp(t_rel, "5.3") EQ 0)                   *WS2530*
      return rtt_num_items_51;                            *WS2530*
    else if (strcmp(t_rel, "5.4") EQ 0)                   *WS2530*
      return rtt_num_items_51;                            *WS2530*
    else if (strcmp(t_rel, "5.5") EQ 0)                   *WS2530*
      return rtt_num_items_51;                            *WS2530*
                                                   end of  IS0357*
    else                                          end of IS10026 */
    /* WS10083
      return rtt_num_items_51;  default is 5.1 and above IS0357*/
    /* WS10083 start */
    if (dynamic_rtt_num_items_51 EQ 0) /* if dynamic table cnt 0 */
       return rtt_num_items_51;     /* use static table cnt */
    else
      return dynamic_rtt_num_items_51; /* use dynamic table cnt*/
    /* WS10083 end */

 }

/*   TSS_get_global_tssc_desc removed by IS10091
  **************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_global_tssc_desc                   *
 *                                                             *
 * DESCRIPTION    : Return tssc file description table ptr     *
 *                                                             *
 * INPUT          : none                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : rtt  num items                             *
 *                                                             *
 **************************************************************

 TSSCFILE_REC_typ  ** TSS_get_global_tssc_desc(char    *req)
 {

    char              t_rel[MAX_TSS_PARAM_LEN + 1] = ""; *PS0388*
    ESA_DIAG_COMP_typ comp = ESA_COMP_USAAPI;            *PS0388*

    TSS_get_global_parameter(comp,  TSS_GLOBAL_RELEASE,  *PS0388*
                             t_rel, glb_dest, glb_msgs); *PS0388*
    ESA_DIAG_printf(comp,5, "Parameter %s=%s",           *PS0388*
                    TSS_GLOBAL_RELEASE, t_rel);          *PS0388*

    * IS10026 always return tsscf_recs_51 as we do not support
     *         earlier versions than CA-TSS 5.1 .             *
    if ( strcmp(req, "GENERAL") EQ 0 ) * IS10026{
      if      (strcmp(t_rel, "5.0") EQ 0)                *IS0357*
        return tsscf_recs;                               *IS0357*
      * support tss 5.0 and above. default is 5.1 & +      IS0357
      if      (strcmp(t_rel, "5.1") EQ 0)                 *PS0388*
        return tsscf_recs_51;                             *PS0388*
      else if (strcmp(t_rel, "5.2") EQ 0)                 *PS0509*
        return tsscf_recs_51;                             *PS0509*
      else if (strcmp(t_rel, "5.3") EQ 0)                 *WS2530*
        return tsscf_recs_51;                             *WS2530*
      else if (strcmp(t_rel, "5.4") EQ 0)                 *WS2530*
        return tsscf_recs_51;                             *WS2530*
      else if (strcmp(t_rel, "5.5") EQ 0)                 *WS2530*
        return tsscf_recs_51;                             *WS2530*
                                                    end of IS0357*
      else                                               *PS0388*
        return tsscf_recs_51; * default is 5.1 and above *IS0357*
    *IS10026 } *
    else if ( strcmp(req, "MODIFY") EQ 0 ) *IS10026 {
      if      (strcmp(t_rel, "5.0") EQ 0)                *IS0357*
        return tsscm_recs;                               *IS0357*
      * support tss 5.0 and above. default is 5.1 & +      IS0357
      if      (strcmp(t_rel, "5.1") EQ 0)                 *PS0388*
        return tsscm_recs_51;                             *PS0388*
      else if (strcmp(t_rel, "5.2") EQ 0)                 *PS0509*
        return tsscm_recs_51;                             *PS0388*
      else if (strcmp(t_rel, "5.3") EQ 0)                 *WS2530*
        return tsscm_recs_51;                             *WS2530*
      else if (strcmp(t_rel, "5.4") EQ 0)                 *WS2530*
        return tsscm_recs_51;                             *WS2530*
      else if (strcmp(t_rel, "5.5") EQ 0)                 *WS2530*
        return tsscm_recs_51;                             *WS2530*
                                                    end of IS0357*
      else                                               *PS0388*
        return tsscm_recs_51; * default is 5.1 and above   IS0357*
        return tsscm_recs_51;                            *IS10026*
    *IS10026 }   *
    else
      return NULL;
 }
 */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_global_parameter                   *
 *                                                             *
 * DESCRIPTION    : Get global parameter                       *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  param_k       - parameter key              *
 *                                                             *
 * OUTPUT         : param_v                                    *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_get_global_parameter(ESA_DIAG_COMP_typ           comp,
                      char                                 * param_k,
                      char                                 * param_v,
                      CTSAMSG_DEST_TABLE_rec_typ           * dest,
                      CTSAMSG_HANDLE_rec_typ               * msgs)
 {

   static char  func[]="TSS_get_global_parameter";
   ESA_RC rc = ESA_OK;
   /* BS10075  static struct _tss_params_global_table *glb_table;
   int    i;   */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 8, func);

   /* BS10075 - start */
   /* BS10075 - code moved to TSS_get_global_parameter_cond
   glb_table = tss_api_global_params;
   ESA_DIAG_printf(comp,8, "parameter %s", param_k);

   for(i=0; glb_table[i].param_k; i++) {
       if ( ( strcmp(glb_table[i].param_k, param_k  ) EQ 0 ) AND
            ( glb_table[i].exists EQ TSS_VAL_EXISTS      ) ) {
          strcpy(param_v, glb_table[i].param_v);
          ESA_DIAG_printf(comp,5,
                          "parameter %s=%s", param_k, param_v );
          goto exit;
       }
   }
   */
   rc = TSS_get_global_parameter_cond(comp, param_k, param_v,
                                      dest, msgs);
   /* BS10075 - start */

   if (rc NE ESA_OK)                                  /* BS10075 */
   {                                                  /* BS10075 */
     sprintf(internal2_msg_buf,
             "Unable to locate global parameter %s", param_k );
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   component, func, internal2_msg_buf,
                   4, __LINE__);
     OS_MVS_btrace();
     strcpy(param_v, "");
     rc = ESA_ERR;
   }                                                  /* BS10075 */

  /*
   *    Finish
   */

 exit :;

  ESA_DIAG_exit(comp, 8, func, rc );
  return rc;

 }

 /* BS10075 - start */
 /*                                                                  */
 /* The code in this routine was moved from TSS_get_global_parameter */
 /* but, when the parameter is not found, this routine returns a     */
 /* return code instead of producing a trace and an error message.   */
 /* This way, the caller may decide whether this is an error or not. */
 /*                                                                  */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_global_parameter_cond              *
 *                                                             *
 * DESCRIPTION    : Get global parameter                       *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  param_k       - parameter key              *
 *                                                             *
 * OUTPUT         : param_v                                    *
 *                                                             *
 * RETURN VALUE   : ESA_OK - parameter retrieved.              *
 *                  ESA_EOF - parameter does not exist.        *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_get_global_parameter_cond(ESA_DIAG_COMP_typ      comp,
                      char                                 * param_k,
                      char                                 * param_v,
                      CTSAMSG_DEST_TABLE_rec_typ           * dest,
                      CTSAMSG_HANDLE_rec_typ               * msgs)
 {

   static char  func[]="TSS_get_global_parameter_cond";
   ESA_RC rc = ESA_OK;
   static struct _tss_params_global_table *glb_table;
   int    i;

   ESA_DIAG_enter(comp, 8, func);

   glb_table = tss_api_global_params;
   ESA_DIAG_printf(comp,8, "parameter %s", param_k);

   for(i=0; glb_table[i].param_k; i++) {
       if ( ( strcmp(glb_table[i].param_k, param_k  ) EQ 0 ) AND
            ( glb_table[i].exists EQ TSS_VAL_EXISTS      ) ) {
          strcpy(param_v, glb_table[i].param_v);
          ESA_DIAG_printf(comp,5,
                          "parameter %s=%s", param_k, param_v );
          goto exit;
       }
   }

   rc = ESA_EOF;

  /*
   *    Finish
   */

 exit :;

  ESA_DIAG_exit(comp, 8, func, rc );
  return rc;

 }
 /* BS10075 - end  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_convert_version                        *
 *                                                             *
 * DESCRIPTION    : Convert TSS verssion to rss type TSS       *
 *                                                             *
 * INPUT          : tss_ver       - tss version (from MODIFY)  *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : converted TSS version                      *
 *                                                             *
 **************************************************************/

 static  char  *  TSS_convert_version(char      *tss_ver)
 {
   if ( memcmp(tss_ver, "12", 2 ) EQ 0 )         /* IS10026*/
      return TSS_VERSION_12;                     /* IS10026*/
   else if ( memcmp(tss_ver, "9", 1 ) EQ 0 )     /* IS10026*/
      return TSS_VERSION_9;                      /* IS10026*/
   else if ( memcmp(tss_ver, "8", 1 ) EQ 0 )     /* IS10026*/
      return TSS_VERSION_8;                      /* IS10026*/
   else if ( memcmp(tss_ver, "5.3", 3 ) EQ 0 )   /* WS2530 */
      return TSS_VERSION_50;                     /* WS2530 */
   /*IS10026
   else if ( memcmp(tss_ver, "5.5", 3 ) EQ 0 )   /* WS2530 *
      return TSS_VERSION_50;                     /* WS2530 *
   else if ( memcmp(tss_ver, "5.4", 3 ) EQ 0 )   /* WS2530 *
      return TSS_VERSION_50;                     /* WS2530 *
   else if ( memcmp(tss_ver, "5.0", 3 ) EQ 0 )
      return TSS_VERSION_50;
   else if ( memcmp(tss_ver, "5.1", 3 ) EQ 0 )   /* PS0388 *
      return TSS_VERSION_50;                     /* PS0388 *
   else if ( memcmp(tss_ver, "5.2", 3 ) EQ 0 )   /* PS0509 *
      return TSS_VERSION_50;                     /* PS0509 *
   else if ( memcmp(tss_ver, "4.4", 3 ) EQ 0 )   /* PS0509 *
      return TSS_VERSION_44;                     /* PS0509 */
   else
      return tss_ver;
 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_use_root_object                        *
 *                                                             *
 * DESCRIPTION    : Return root flag (TRUE - means use ROOT obj*
 *                  FALSE - means do not use ROOT object       *
 *                                                             *
 * INPUT          : none                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : root                                       *
 *                                                             *
 **************************************************************/

 int  TSS_use_root_object(ESA_DIAG_COMP_typ               comp,
                          char                          * root_name,
                          CTSAMSG_DEST_TABLE_rec_typ    * dest,
                          CTSAMSG_HANDLE_rec_typ        * msgs)
 {

   int    irc;
   ESA_RC rc;

   /* irc = FALSE;  */ /* Do not use "ROOT" object */
   irc = TRUE;         /* Use "ROOT" object        */

   if ( irc ) {        /* If use "ROOT" object, return it's name */
      rc = TSS_get_global_parameter(comp, TSS_GLOBAL_ROOT_NAME,
                                    root_name, dest, msgs);
      if ( rc NE ESA_OK )
        strcpy(root_name, TSS_ROOT);
   }
   else
      strcpy(root_name, TSS_ROOT);

   ESA_DIAG_printf(comp,4, "Root name=%s", root_name);

   return irc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_check_restype                          *
 *                                                             *
 * DESCRIPTION    : Check restype aginst RDT table             *
 *                                                             *
 * INPUT          : none                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : OK - found in RDT table, ERR - not found   *
 *                  FATAL - other errors                       *
 **************************************************************/

 ESA_RC TSS_check_restype(ESA_DIAG_COMP_typ        comp,
                          RESOURCE_typ             res_type)
 {

   static char  func[]="TSS_check_restype";
   ESA_RC       rc = ESA_OK;
   int          i;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 10, func);

   ESA_DIAG_printf(comp,5, "Entered res_type=%s", res_type);
   ESA_DIAG_printf(comp,5, "rdt_table_done=%d rc_rdt_table=%d",
                   global_rdt_table_done, rc_rdt_table );

   if (NOT global_rdt_table_done) {
      rc = ESA_FATAL;
      goto exit;
   }

   if (rc_rdt_table NE ESA_OK) {
      rc = ESA_FATAL;
      goto exit;
   }

   ESA_DIAG_printf(comp,5, "RDT table. Entries=%d",
                   global_rdt_table_entries_number);

   for (i=0; i LT global_rdt_table_entries_number; i++) {
      ESA_DIAG_printf(comp,10, "%d. RDT entry=%s res_type=%s",
                      i, rdt_table[i], res_type);

      if (strcmp(res_type, rdt_table[i]) EQ 0)
         goto exit;

   }

   rc = ESA_ERR;     /* res_type not found */

 exit :;

   ESA_DIAG_exit(comp,  10, func, rc );
   return rc;

 }



  /* WS10083 - start */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_FDT                                *
 *                                                             *
 * DESCRIPTION    : Create input command to be used by the     *
 *                : the TSSCFILE utility to list the FDT. The  *
 *                  output record is read to check for any user*
 *                  defined field records which have a record  *
 *                  type of '4110' follwed by a two character  *
 *                  ID field containing values between 01 and  *
 *                  FF. Any field names found are added to a   *
 *                  table which will be used to build a new    *
 *                  dynamic copy of the RTT containing the     *
 *                  existing RTT entries and the user defined  *
 *                  field names. The pointer to the current RTT*
 *                  is overwritten with the address of the new *
 *                  dynamic RTT.                               *
 *                                                             *
 * INPUT          : comp      - diag component                 *
 *                  admin_params - Admin parameters            *
 *                  err       - error structure                *
 *                                                             *
 * OUTPUT         : None                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_get_FDT(ESA_DIAG_COMP_typ  comp,
                         ADMIN_PARAMS_rec_typ  * admin_params,
                         ERR_STRUCT_rec_typ    * err)
 {

 /* Field name offset for 4110 record on TSSCFILE*/
 #define TSSCFILE_FDTNAME 32
 /* maimum number of user defined fields */
 #define FDT_MAX_USER_DEFS 255
 /* maximum field name length + NULL term */
 #define TSSCFILE_FDTNAME_SIZE 9

  /*
   *   Variables
   */

   static char func[]="TSS_get_FDT";
   ESA_RC                 rc = ESA_OK ;
   char                   cmd[MAX_TSS_API_ST];
   int                    nb = 0;
   int                    recnt = 0;
   char                   file_name[TSS_MAX_FILENAME_LEN + 10];
   char                   ddn_with[MAX_FILENAME_LEN];
   FILE                 * file_in = NULL ;
   FILE                 * file_out = NULL ;
   char                   record[MAX_TSSCFILE_REC_LEN] = "";
   char                   record_id_1[5]               = "";
   char                   record_id_2[3]               = "";
   char                   workname[TSSCFILE_FDTNAME_SIZE];
   int                    user_defs_cnt = 0;
   int                    user_defs_pos = 0;
   char                 * user_defs_space;
   TSS_RTT_rec_typ      * dynamic_RTT;
   short                  dynamic_RTT_size = 0;
   char                 * dynamic_RTT_fdt_names = NULL;
   int                    i = 0;
   TSS_RTT_rec_typ      * index;
   TSS_RTT_rec_typ null_RTT[] = {NULL, NULL ,0 , 0 , 0, NULL };
   TSS_RTT_rec_typ template_RTT[] =
    {"        ", "        ", TYPE_1A, RTT_KEY, RTT_REPLACE,
                 NULL,    TSS_set_simple_key };

   static char user_defs[FDT_MAX_USER_DEFS] [TSSCFILE_FDTNAME_SIZE];

   CTSAMSG_HANDLE_rec_typ     * msgs;  /* message buffer */
   CTSAMSG_DEST_TABLE_rec_typ * dest;  /* destinations table */

  /*
   *   Initialize
   */

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_enter(comp, 3, func);

   rc = OS_MVS_ddinfo(TSSCFILE_IN_DD , file_name ,
                      TRUE, dest, msgs, 0);

   ESA_DIAG_printf(comp, 2,
                  "OS_MVS_ddinfo rc=%d file name %s", rc, file_name);
   if ( rc NE ESA_OK )
      goto exit;

  /*
   *  Open file for create input for TSSCFILE
   */

   strcpy(ddn_with,"DD:");
   strcat(ddn_with, TSSCFILE_IN_DD);

   file_in = fopen(ddn_with , FILE_OPEN_WRITE_TEXT);

   if ( ferror(file_in) OR (file_in EQ NULL) ) {
       CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                     "fopen", func, TSSCFILE_IN_DD, strerror(errno));
       ESA_DIAG_printf(comp, 2,
              "file %s error %s", TSSCFILE_IN_DD, strerror(errno));
       rc = ESA_FATAL;
       goto exit;
   }

  /*
   *  Create input file for TSSCFILE utility
   */

   strcpy(cmd, " TSS LIST(FDT) \n");

   nb = fputs( cmd, file_in);

   ESA_DIAG_printf(comp, 2, "written %d bytes,TSSCFILE input cmd=%s",
                   nb, cmd);

   if ( ferror(file_in) OR (nb EQ 0) ) {
       CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                     "fputs", func, TSSCFILE_IN_DD, strerror(errno) );
       ESA_DIAG_printf(comp, 1,
                       "file %s error %s", TSSCFILE_IN_DD,
                        strerror(errno));
       rc = ESA_FATAL;
       goto exit;
   }

   fclose(file_in);
   file_in = NULL;

  /*
   * Handling end of processing
   */
   rc = TSS_cfile_activate(comp, dest, msgs );
   ESA_DIAG_printf(comp, 5,
                  "TSS_cfile_activate returned rc %d", rc);
   if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
   }

   rc = TSS_open_output_file(comp,admin_params,&file_out);
   ESA_DIAG_printf(comp, 5,
                   "TSS_open_output_file returned rc %d", rc);
   if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
   }

   fread(record, 1, MAX_TSSCFILE_REC_LEN, file_out);

   while ( rc EQ ESA_OK )  {

      if ( feof(file_out) NE 0) {
         rc = ESA_EOF;
         break;
      }

      if (ferror(file_out)) {
         CTSAMSG_print(ERR_FILE, msgs, NULL, dest,
                    "fread", func, TSSCFILE_OUT_DD, strerror(errno));
         rc = ESA_FATAL;
         goto exit;
      }

      recnt++;

      ESA_DIAG_printf(comp, 5, "%d.%s",
                      recnt, record + TSSCFILE_RESERVED_LEN );

     /*   Get RECORD ID  */

      TSS_get_rec_id( comp, record, record_id_1, record_id_2 );

      if ( (strcmp(record_id_1, "4110") EQ 0 ) AND
           (strcmp(record_id_2, "  ") NE 0 ) ) {

         memset(workname, '\0', sizeof(workname));
         user_defs_space = strchr((record + TSSCFILE_FDTNAME), ' ');
         user_defs_pos = (int)(user_defs_space -
                                (record + TSSCFILE_FDTNAME));

         memcpy(workname, (record + TSSCFILE_FDTNAME),
                          (user_defs_pos));

         /* check name lengh not greater than max */
         if (user_defs_pos GT (TSSCFILE_FDTNAME_SIZE-1)) {

             CTSAMSG_print(TSS_ERR_USER_FIELD_INVALID,
                           msgs, NULL, dest, workname);
             ESA_DIAG_printf(comp, 5,
              "field %s is greater than eight characters",
              workname);
              fread(record, 1, MAX_TSSCFILE_REC_LEN, file_out);
              continue;

         }

         strcpy(user_defs[user_defs_cnt], workname);
         user_defs_cnt++;

         ESA_DIAG_printf(comp, 6, "user_defs_cnt  %d workname %s",
                      user_defs_cnt, workname);

      }

       fread(record, 1, MAX_TSSCFILE_REC_LEN, file_out);
   }

   rc = ESA_OK;

   if (user_defs_cnt GT 0) {
   /* then found user defined fields in FDT */

      dynamic_RTT_size = sizeof(TSS_RTT_rec_typ) * user_defs_cnt;
      dynamic_RTT_size += sizeof(rtt_51);
      dynamic_RTT_size += (user_defs_cnt * TSSCFILE_FDTNAME_SIZE);

      /* allocate memory for static RTT entries, dynamic RTT entries,
         NULL entry and FDT names*/
      dynamic_RTT = (TSS_RTT_rec_typ *)malloc(dynamic_RTT_size);
      if (dynamic_RTT EQ NULL) {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "dynamic RTT table ",
                  dynamic_RTT_size);
         rc = ESA_FATAL;
         goto exit;
      }

      /* copy static RTT table to dynamic RTT without the null entry */
      memcpy(dynamic_RTT, rtt_51, sizeof(rtt_51));

      index = dynamic_RTT;
      /* point to first entry for user fields */
      index += rtt_num_items_51;
      /* point to first dynamic user field name */
      dynamic_RTT_fdt_names = (char*) index + (user_defs_cnt *
                                       sizeof(TSS_RTT_rec_typ));
      /* overwrite null entry                 */
      index--;

      for (i=0;i LT user_defs_cnt; i++) {
           memcpy(index, template_RTT, sizeof(TSS_RTT_rec_typ));
           strcpy(dynamic_RTT_fdt_names, user_defs[i]);
           index->addinfo_keyword = dynamic_RTT_fdt_names;
           index->tss_keyword = dynamic_RTT_fdt_names;

           ESA_DIAG_printf(comp, 6,
              " addinfo_keyword  %s tss_keyword %s fdt_name %s",
                index->addinfo_keyword, index->tss_keyword,
                dynamic_RTT_fdt_names);

           index ++;
           dynamic_RTT_fdt_names += TSSCFILE_FDTNAME_SIZE;

      }


      memcpy(index, null_RTT, sizeof(TSS_RTT_rec_typ));

      dynamic_rtt_51 = dynamic_RTT;
      /* number of dynamic RTT entries and NULL trailing entry */
      dynamic_rtt_num_items_51 = rtt_num_items_51 + user_defs_cnt;

      ESA_DIAG_printf(comp, 6, "dynamic_rtt_num_items_51 = %d",
                      dynamic_rtt_num_items_51);

      index = dynamic_rtt_51;
      i = 0;

      while (index->addinfo_keyword) {
           ESA_DIAG_printf(comp, 6,
              " %d Dynamic addinfo_keyword  %s tss_keyword %s index= %p",
               i++, index->addinfo_keyword, index->tss_keyword,index);
           index ++;
      }

   }

  /*
   *   Finish
   */

   exit :;

   if (rc NE ESA_OK) {
      CTSAMSG_print(TSS_ERR_DYN_RTT_FAILED, msgs, NULL, dest);
      rc = ESA_OK;
   }

   if (file_in NE NULL)
      fclose(file_in);

   if (file_out NE NULL)
      fclose(file_out);

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_global_term                            *
 *                                                             *
 * DESCRIPTION    : Terminate TSS global environment created   *
 *                  by TSS_global_init.                        *
 *                                                             *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  admin_params                               *
 *                  err                                        *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 EXT ESA_RC TSS_global_term (ESA_DIAG_COMP_typ       comp,
                             ADMIN_PARAMS_rec_typ  * admin_params,
                             ERR_STRUCT_rec_typ    * err)

 {

   ESA_RC                       rc = ESA_OK;
   static char                  func[]="TSS_global_term";
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 1, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   /* Going to free active RTT */
   ESA_DIAG_printf(comp,5,
           "rtt_table_done=%d rtt_51=%p dynamic_rtt_51=%p",
           global_rtt_table_done, rtt_51, dynamic_rtt_51);

   if (global_rtt_table_done) {
       /* When the original RTT pointer and the active RTT pointer
          are different then we must have allocated a new RTT table
          so we should free the memory. */
       if (dynamic_rtt_51) {
          free(dynamic_rtt_51);
          ESA_DIAG_printf(comp, 5,
                      "dynamic RTT freed: %p",
                       dynamic_rtt_51);
       }

       rc = ESA_OK;

   }


  /*
   *    Finish
   */

 exit :;

  ESA_DIAG_exit(comp, 1, func, rc );
  return rc;

 }

  /* WS10083 - end */
