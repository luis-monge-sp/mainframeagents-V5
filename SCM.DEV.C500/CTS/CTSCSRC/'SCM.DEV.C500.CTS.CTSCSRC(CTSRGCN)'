 /**************************************************************
 *                                                             *
 * Title            : get user to group connections (RACF)     *
 *                                                             *
 * File Name        : ctsrgcn.c                                *
 *                                                             *
 * Author           : Alexander Shvartsman                     *
 *                                                             *
 * Creation Date    : 25/04/94                                 *
 *                                                             *
 * Description      :                                          *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------  -------------------------------- *
 *
 * as3001   Alex     30/01/95 Correct treatment of INTERNAL ERR*
 *                            that ocuured in put_connect_inf  *
 *                            subroutine                       *
 *
 * AS1902   ALEX     19/02/95  Change debug component name for *
 *                             EXTRACTOR.                      *
 *                                                             *
 * as0203   Alex     02/03/95 Correct treatment of INTERNAL_ERR*
 *                            that occured in put_connect_inf  *
 *                            for fields : DFLTGRP,SPECIAL,    *
 *                                         AUDITOR             *
 *                            Treatment the same like in as3001*
 *                            changes.                         *
 *                                                             *
 * dc0905   Doron    09/05/95 Adapt to api changes (user and   *
 *                            group names are part of the      *
 *                            u2ug_params structure and        *
 *                            some renaming ) .                *
 *                                                             *
 * as1807   Alex     18/07/95 Add new DEBUG prints             *
 *                                                             *
 *                                                             *
 * spr163   Alex     05/09/95  Support Download restart        *
 *                                                             *
 * spr...   Alex     05/09/95  Correct Support Download restart*
 * spr...   Alex     03/01/96  New emplamantation of restart   *
 * ps0004   Alex     09/10/96  Adjust to new common code       *
 *                                                             *
 * BS2001   AS       09/03/97  Handling of incomplete RACF db  *
 *                             connection                      *
 * ps0165   AS       29/07/97  Remove internal error when      *
 *                             when AUTHORITY field does not   *
 *                             exist in ADDINFO area           *
 * ws2427   sk       29/01/02  Universal group support         *
 * bs2520   sk       29/01/02  Mark connection as Universal    *
 * is0297   AvnerL   30/11/04  Do not return rc=err.           *
 * ws2549   Yonatan  09/11/05 New parm MSG_CONNGRP_ERR.        *
 * BS2703   yonim    26/03/06 Support Multi subgroup keyword   *
 * IS10002  AvnerL   31/01/07 Drop CTS3121E. WS2549 improvement*
 * WS10004  AvnerL   05/06/07 Extend ICHEINTY & add SUBGROUP3  *
 * BS10008  AvnerL   24/03/08 pass connect# for malloc.        *
 * IS10076  NuritY   31/01/13 Support Custom Fields.           *
 * IS10076A AvnerL   04/02/13 Fix IS10070 compile issue & MSG. *
 * IS10100  NuritY   19/10/13 changes required because of      *
 *                            CTSACF feature support for USER. *
 * SAS2IBMT SeligT   30/06/16 SAS/C to IBM C Conversion Project*
 * WS10082  MauriC   07/11/22 Recompile for new ADDINFO macros *
 **************************************************************/

 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDIO
 #include   STDLIB
 #include   STRING
 /* ws2427  */
 /* #include LCSTRING                                        SAS2IBMT */
 #include ESA_INIT

 /*
  *   ESA include files
  */

 #include   ESA_API
 #include   ESA_DIAG
 #include   ESA_CTSAMSG
 #include   ESA_API_CODES

 /*
  *   MVS include files
  */

 #include   MVS_COMP
 #include   MVS_CODES                                /* IS10076A */

 /*
  *   RACF include files
  */

 #include   RACF_CODES
 #include   RACF

 enum { OPCODE_NEXT, OPCODE_LOCATE };    /* spr163 */

 /*
  *    Extract connections of a group
  */

 /* SAS2IBMT typedef and prototype changed for IBM C
  extern int ctsfrcn(char                         * option,
                     char                         * entry_type,
                     char                         * entry,
                     int                          * generic_flag,
                     RACF_OUTPUT_LINE_rec_typ     * output,
                     int                          * debug,
                     int                          * rc_racf,
                     int                          * reason_code,
                     char                         * sep);            */
  extern int ctsfrcn();                                   /* SAS2IBMT */

 /*
  *   Extract number of connections of a group or a user
  */

 /* SAS2IBMT typedef and prototype changed for IBM C
  extern int ctsfrnm(char                         * option,
                     char                         * entry_type,
                     char                         * entry,
                     int                          * generic_flag,
                     RACF_OUTPUT_LINE_rec_typ     * output,
                     int                          * debug,
                     int                          * rc_racf,
                     int                          * reason_code,
                     char                         * sep);            */
  extern int ctsfrnm();                                   /* SAS2IBMT */

 /*
  *   Extract a single connection of a given pair (user-group)
  */

 /* SAS2IBMT typedef and prototype changed for IBM C
  extern int ctsfruc(char                         * option,
                     char                         * entry_type,
                     char                         * entry,
                     int                          * generic_flag,
                     RACF_OUTPUT_LINE_rec_typ     * output,
                     int                          * debug,
                     int                          * rc_racf,
                     int                          * reason_code,
                     char                         * sep);            */
  extern int ctsfruc();                                   /* SAS2IBMT */

 /*
  *    Extract connections of a user
  */

 /* SAS2IBMT typedef and prototype changed for IBM C
  extern int ctsfrgc(char                         * option,
                     char                         * entry_type,
                     char                         * entry,
                     int                          * generic_flag,
                     RACF_OUTPUT_LINE_rec_typ     * output,
                     int                          * debug,
                     int                          * rc_racf,
                     int                          * reason_code,
                     char                         * sep);            */
  extern int ctsfrgc();                                   /* SAS2IBMT */

 /*
  *       Routine for mode = many_ugs
  */

  /* SAS2IBMT typedef and prototype changed for IBM C
  static ESA_RC do_manyg(RACF_ACCESS_PROG      racfprg,              */
  static ESA_RC do_manyg(ASM_RTN_TYP          *racfprg,   /* SAS2IBMT */
                 RACF_CNN_OUTPUT_LINE_rec_ptr  output,
                 char                         * entry,
                 short                          max_conns,
                 short                        * actual_num,
                 HAVE_MORE_typ                * have_more,
                 void                        ** handle,
                 short                          num_ugs_in,
                 short                          num_users_in,
                 UG_typ                         ugs_in[1],
                 USER_typ                       users_in[1],
                 U2UG_PARAMS_rec_typ            u2ug_params[1],
                 ADDINFO_rec_ptr                addinfo[1],
                 OBJ_EXISTS_typ                 objs_exist[1],
  /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
  /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
  /* IS10076  */ ADMIN_PARAMS_rec_typ         * admin_params);

 /*
  *       Routine for mode = many_users
  */

  /* SAS2IBMT typedef and prototype changed for IBM C
  static ESA_RC do_manyu(RACF_ACCESS_PROG        racfprg,            */
  static ESA_RC do_manyu(ASM_RTN_TYP           * racfprg, /* SAS2IBMT */
                 RACF_CNN_OUTPUT_LINE_rec_ptr    output,
                 char                          * entry,
                 short                           max_conns,
                 short                         * actual_num,
                 HAVE_MORE_typ                 * have_more,
                 void                         ** handle,
                 short                           num_ugs_in,
                 short                           num_users_in,
                 UG_typ                          ugs_in[1],
                 USER_typ                        users_in[1],
                 U2UG_PARAMS_rec_typ             u2ug_params[1],
                 ADDINFO_rec_ptr                 addinfo[1],
                 OBJ_EXISTS_typ                  objs_exist[1],
  /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
  /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
  /* IS10076  */ ADMIN_PARAMS_rec_typ          * admin_params);

 /*
  *       Routine for mode = all
  */

  /* SAS2IBMT typedef and prototype changed for IBM C
  static ESA_RC do_all(RACF_ACCESS_PROG         racfprg,             */
  static ESA_RC do_all(ASM_RTN_TYP            * racfprg,  /* SAS2IBMT */
                 RACF_CNN_OUTPUT_LINE_rec_ptr   output,
                 char                         * entry,
                 short                          max_conns,
                 short                        * actual_num,
                 HAVE_MORE_typ                * have_more,
                 void                        ** handle,
                 short                          num_ugs_in,
                 short                          num_users_in,
                 UG_typ                         ugs_in[1],
                 USER_typ                       users_in[1],
                 U2UG_PARAMS_rec_typ            u2ug_params[1],
                 ADDINFO_rec_ptr                addinfo[1],
                 OBJ_EXISTS_typ                 objs_exist[1],
  /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
  /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
  /* IS10076  */ ADMIN_PARAMS_rec_typ          * admin_params);

 /*
  *       Routine for mode = many_pairs
  */

  /* SAS2IBMT typedef and prototype changed for IBM C
  static ESA_RC do_pair(RACF_ACCESS_PROG     racfprg,                */
  static ESA_RC do_pair(ASM_RTN_TYP        * racfprg,     /* SAS2IBMT */
                 void                     ** handle,
                 RACF_CNN_OUTPUT_LINE_rec_ptr output,
                 char                      * entry,
                 short                       max_conns,
                 short                     * actual_num,
                 HAVE_MORE_typ             * have_more,
                 short                       num_ugs_in,
                 short                       num_users_in,
                 UG_typ                      ugs_in[1],
                 USER_typ                    users_in[1],
                 U2UG_PARAMS_rec_typ         u2ug_params[1],
                 ADDINFO_rec_ptr             addinfo[1],
                 OBJ_EXISTS_typ              objs_exist[1],
                 CTSAMSG_DEST_TABLE_rec_ptr  dest,
                 CTSAMSG_HANDLE_rec_ptr      msgs,
                 ADMIN_PARAMS_rec_typ * admin_params);  /* ws2549 */

 /*
  *       Routine to put connect information in addinfo
  */

 static void put_connect_inf(short                  max_conns,
                        void                     ** handle,
                        char                      * entry,
                        HAVE_MORE_typ             * have_more,
                        short                     * actual_num,
                        U2UG_PARAMS_rec_typ         u2ug_params[1],
                        OBJ_EXISTS_typ              objs_exist[1],
                        ADDINFO_rec_ptr             addinfo[1],
                        RACF_CONNECT_AREA_ptr     * grp_us,
         /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
         /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
         /* IS10076  */ ADMIN_PARAMS_rec_typ       * admin_params);

 static ESA_RC check_handle(void                    **handle,
                          CTSAMSG_DEST_TABLE_rec_ptr  dest,
                          CTSAMSG_HANDLE_rec_ptr      msgs);

 static void free_ugs(void                   ** handle);

 /*
  *  A list of special keywords :
  *
  *  When extracting information from RACF data base
  *  the values of these keywords will be put in the local
  *  addinfo, and copied from there to U2UG_PARAMS structure
  *
  */

 static char *spec_keywords[]={"USERID","GROUP","DFLTGRP",
                                     "SPECIAL","AUDITOR",""} ;
 static short num_spec_keywords = 10 ;

 /*
  *  Component for internal error messages
  *
  */

 static char component[]="GTUG2UC" ;

 /*
  *    Debug level for assembler programs
  */

 static int debug = 0;

 /*
  *    ws2427  global area allocated for array of users connected
  *            to universal group
  */

 static  int* unistorage = NULL;

 /****************************************************
 * Procedure Name: gtug2uc
 * Description   : Get user-group to user connections
 * Input         : mode         - ALL_UGS    - get connections of all
 *                                             ugs (all users of all
 *                                             groups)
 *                                ALL_USERS  - get connections of all
 *                                             users (same as ALL_UGS
 *                                             from different angle)
 *                                MANY_UGS   - get connections of
 *                                             supplied ugs
 *                                MANY_USERS - NOT IMPLEMENTED yet
 *                                MANY_PAIRS - get connections for
 *                                             supplied pairs.
 *                 max_conns    - # of elements in ugs,
 *                                users, objs_exist & addinfo
 *                                arrays
 *                 admin_params -
 *                 num_ugs_in   - # of input ugs
 *                 num_users_in - # of input users
 *                 ugs_in - array of num_ugs_in.
 *                                Caller fills with ugs requested
 *                                (if not GET_ALL);
 *                 users_params_in - array of num_users_in.
 *                                Caller fills with users requested.
 * Output        : actual_num   - # of connections returned
 *                 have_more    - HAVE_MORE if more conns, else NO_MORE
 *                 objs_exist   - array of max_conns:
 *                                OBJ_EXIST if connection exists, else
 *                                OBJ_NOT_EXIST.
 *                 addinfo      - array of max_conns:
 *                                add.info per connection
 *                 err          - error indication, message, etc.
 * Input/Output  : handle       - NULL on first call, filled by callee,
 *                                used by callee to keep track.
 *                                Freed by caller.
 * Return Value  : ESA_RC
 * Side Effects  : Function may allocate memory, return pointer in
 *                 *handle; Caller MUST free when done.
 * Comments      : 1. Data is returned as quartets - ug, user, obj_exist,
 *                    add.info.
 *
 ****************************************************/

 ESA_RC CTSGetConns (GET_CONN_MODE          mode,
                     short                  max_conns,
                     short                * actual_num,
                     HAVE_MORE_typ        * have_more,
                     void                ** handle,
                     short                  num_ugs_in,
                     short                  num_users_in,
                     UG_typ                 ugs_in[1],
                     USER_typ               users_in[1],
                     U2UG_PARAMS_rec_typ    u2ug_params[1],
                     ADDINFO_rec_ptr        addinfo[1],
                     OBJ_EXISTS_typ         objs_exist[1],
                     ADMIN_PARAMS_rec_typ * admin_params,
                     ERR_STRUCT_rec_typ   * err)

 {

  /*
   *   Variables
   */

   ESA_RC                     rc ;
   char entry[RCF_USER_NAME_LEN+RCF_UG_NAME_LEN+2];
   RACF_CNN_OUTPUT_LINE_rec_typ   output;
   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;
   int                        i_dump;
   int                        i;                          /* SAS2IBMT */

   static char                func[]="CTSGetConns";

   /*
    *   Variables for ws2427
    */
         char unimax[RACF_UNIDIGIT_MAX+1];
         int  usrmax;
         /*IS10076A RACF_FLAG_typ at_least_Z12; */
  /*
   *     Initialize
   */

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, 1, func);

   debug = ESA_DIAG_get_debug_level(PLT_COMP_RCFCNN_EXT);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   *have_more=NO_MORE ;
   *actual_num=0 ;

   ESA_DIAG_printf(ESA_COMP_GTUG2UC,1, "mode=%d handle=%X max_conns=%d",
                   mode, *handle , max_conns);

  /*
   *     Check entered handle
   */

   if ( mode NE GET_FREE_HANDLE_CONNS ) {
      rc = check_handle(handle, dest, msgs);
      if ( rc NE ESA_OK )
         goto exit;
  }

  /*
   *     Initialize storage for Universal groups
   */
     if (unistorage EQ NULL)  { /* not allocated*/
     /* IS10076A no need to check zOS 1.2 any more .
         rc = RACF_version_at_least(RACFZ12, &at_least_Z12);
         if (rc NE ESA_OK) {
                     rc= ESA_FATAL;
                     goto exit;
                    }
         ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
        "Detected RACF version %s RACFZ12.",
         (at_least_Z12 EQ RACF_YES) ? "at least" : "previous to");
     if (at_least_Z12 EQ RACF_YES) {  * racf at lease z12 *
                                   end of IS10076A remark */
         rc = admin_params->cs_func.rssprm_get_ptr(
                    admin_params->rss_name,"RCF_UNIGROUP_MAX",
                    RACF_UNIDIGIT_MAX, unimax);
         if  (rc EQ ESA_OK)
         ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
        "Obtained RCF_UNIGROUP_MAX parameter = %s", unimax);
         else strcpy(unimax,"0");
         /* SAS2IBMT rc = strrspn(unimax,POSITIVE_VALUE);            */
         i = 0; rc = 0;                                   /* SAS2IBMT */
         while(unimax[i])                                 /* SAS2IBMT */
            {
               if (!isdigit(unimax[i])) rc = 1;           /* SAS2IBMT */
               i++;                                       /* SAS2IBMT */
            }
         if  (rc NE 0) {
             ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
            "Invalid RCF_UNIGROUP_MAX parameter %s", unimax);
             rc = ESA_FATAL; goto exit;
            }
         usrmax = atoi(unimax);
         ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
        "About to getmain unistorage for %d users", usrmax);
         unistorage = (int*) malloc ((RCF_USER_NAME_LEN*usrmax)+8);
         if (unistorage EQ NULL) {
             ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
            "Failed to getmain unistorage for %d users", usrmax);
            CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,func,
            "Cannot malloc array of universal users",usrmax,__LINE__);
             rc = ESA_FATAL; goto exit;
            }
         else  *unistorage = usrmax;  /* can be zero, no uni support*/
   /* IS10076A } *//*RACF at least Z12*/
   }/*not allocated*/

  /*
   *     Do request according to mode
   */

   switch (mode) {

      case GET_FREE_HANDLE_CONNS :
                       if ( *handle NE NULL ) {
                          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                                "FREE_UGS:line=%d ptr=%X",
                                 __LINE__, *handle );
                          free_ugs(handle);
                          *have_more=NO_MORE;
                      }
                       break ;

      case GET_ALL_CONNS:
  /* SAS2IBMT typedef and prototype changed for IBM C
                 rc = do_all((RACF_ACCESS_PROG)&ctsfrgc, *BS10008*  */
                       rc = do_all((ASM_RTN_TYP *) &ctsfrgc, /*SAS2IBMT*/
                                   &output, entry,
                                   max_conns, actual_num, have_more,
                                   handle, num_ugs_in, num_users_in,
                                   ugs_in, users_in, u2ug_params,
                   /* IS10076      addinfo, objs_exist, dest, msgs);*/
                   /* IS10076 */   addinfo, objs_exist, admin_params);
                       break ;

      case GET_GROUPS_CONNS:
  /* SAS2IBMT typedef and prototype changed for IBM C
                  rc=do_manyg((RACF_ACCESS_PROG)&ctsfrcn, *BS10008*  */
                       rc=do_manyg((ASM_RTN_TYP *) &ctsfrcn, /*SAS2IBMT*/
                                     &output, entry,
                                     max_conns, actual_num, have_more,
                                     handle, num_ugs_in, num_users_in,
                                     ugs_in, users_in, u2ug_params,
                   /* IS10076        addinfo, objs_exist, dest, msgs);*/
                   /* IS10076 */     addinfo, objs_exist, admin_params);
                       break ;

      case GET_USERS_CONNS :
  /* SAS2IBMT typedef and prototype changed for IBM C
                   rc=do_manyu((RACF_ACCESS_PROG)&ctsfrgc, *BS10008*  */
                       rc=do_manyu((ASM_RTN_TYP *) &ctsfrgc, /*SAS2IBMT*/
                                     &output, entry,
                                     max_conns, actual_num,
                                     have_more, handle, num_ugs_in,
                                     num_users_in, ugs_in, users_in,
                                     u2ug_params, addinfo,
                   /* IS10076        objs_exist, dest, msgs);   */
                   /* IS10076 */     objs_exist, admin_params);
                       break ;

      case GET_MANY_CONNS :
  /* SAS2IBMT typedef and prototype changed for IBM C
                 rc=do_pair((RACF_ACCESS_PROG)&ctsfruc, *BS10008*  */
                       rc=do_pair((ASM_RTN_TYP *) &ctsfruc, /*SAS2IBMT*/
                                    handle,
                                    &output, entry, max_conns,
                                    actual_num, have_more,
                                    num_ugs_in, num_users_in,
                                    ugs_in, users_in, u2ug_params,
                                    addinfo, objs_exist, dest,
                                    msgs,
                                    admin_params);   /* ws2549 */
                       break ;

      default       : rc = ESA_FATAL;
                      CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,
                         component, func,"Invalid mode",mode,__LINE__);
                      goto exit;
                      break ;
  }


   ESA_DIAG_printf(ESA_COMP_GTUG2UC,1,
                   "**** max_conns=%d actual num=%d",
                   max_conns, *actual_num);

   if ( ESA_DIAG_get_debug_level(ESA_COMP_GTUG2UC) GE 1 ) {
      for (i_dump=0; i_dump LT *actual_num; i_dump++) {
        ESA_DIAG_printf(ESA_COMP_GTUG2UC,0,
                        "User=%s Group=%s exist=%d connect_data=%d",
                        u2ug_params[i_dump].user,
                        u2ug_params[i_dump].group,
                        objs_exist[i_dump],
                        u2ug_params[i_dump].u2ug_admin_data);
        if ( ( objs_exist[i_dump] EQ OBJ_EXIST ) AND
             ( ESA_DIAG_get_debug_level(ESA_COMP_GTUG2UC) GE 2 ) )
             ADDINFO_dump(addinfo[i_dump],0);
     }
  }
  /*
   *  Finish
   */

   exit : ;

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                   "Finished with rc %d actual num=%d have_more=%d",
                   rc, *actual_num, *have_more);
   ESA_DIAG_exit(ESA_COMP_GTUG2UC, 1, func, rc );
   return rc ;

}

 /**************************************************************
 *                                                             *
 * Subroutine name : do_pair                                   *
 *                                                             *
 * DESCRIPTION     : Handle mode=many_pairs                    *
 *                                                             *
 * INPUT           : 1. racfprg - Addr of racf-access program  *
 *                   2. handle  - addr. header structure       *
 *                   2. opcode  - Operation code(locate/next)  *
 *                   4. output  - Output area for extractor    *
 *                   5. entry   - Entry name                   *
 *                   6. max_conns - count of pairs             *
 *                   6. dest    - Message destination ptr      *
 *                   7. msgs    - Message handle ptr           *
 *                                                             *
 *                                                             *
 * OUTPUT          : 1. u2ug_params - connection structure     *
 *                   2. addinfo     - Addinfo                  *
 *                   3. actual_num  - count of returned datas  *
 *                   4. have_more   - continue/no parameter    *
 *                                                             *
 * RETURN VALUE    : ESA_ERR   - user not defined to racf      *
 *                   ESA_FATAL - serious error from RACF extract
 *                                                             *
 **************************************************************/
 /* SAS2IBMT typedef and prototype changed for IBM C
 static ESA_RC do_pair(RACF_ACCESS_PROG            racfprg,          */
 static ESA_RC do_pair(ASM_RTN_TYP               * racfprg, /*SAS2IBMT*/
                       void                     ** handle,
                       RACF_CNN_OUTPUT_LINE_rec_ptr output,
                       char                      * entry,
                       short                       max_conns,
                       short                     * actual_num,
                       HAVE_MORE_typ             * have_more,
                       short                       num_ugs_in,
                       short                       num_users_in,
                       UG_typ                      ugs_in[1],
                       USER_typ                    users_in[1],
                       U2UG_PARAMS_rec_typ         u2ug_params[1],
                       ADDINFO_rec_ptr             addinfo[1],
                       OBJ_EXISTS_typ              objs_exist[1],
                       CTSAMSG_DEST_TABLE_rec_ptr  dest,
                       CTSAMSG_HANDLE_rec_ptr      msgs,
                       ADMIN_PARAMS_rec_typ * admin_params) /* ws2549 */

 {

  /*
   *    Variables
   */

   ESA_RC rc_pair;
   int    i;
   short  actnum_save;
   RACF_CONNECT_AREA_ptr grp_us;    /* group-users-connect-inf */
   static char func[]="do_pair";
   /*IS10002 char   parm_get[4] = " ";                      /* ws2549 */
   /*IS10002 ESA_RC rc;                                     /* ws2549 */
   RACF_PARAMS_rec_typ * params_ptr = NULL;                /* IS10002*/

  /*
   *    Initialize
   */

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, 3, func);

  /*
   *   Obtain handle
   */

   *entry=NULL_CHAR ;
   rc_pair = RACF_alloc_output_lines(handle, &grp_us, entry,
                                     component, 1, num_spec_keywords,
                                     dest, msgs);
   if ( rc_pair NE ESA_OK )     /* Malloc error */
      goto exit;


   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                  "output_lines_ptr=%x handle=%x addinf=%x",
                  grp_us->output_lines_ptr, *handle,
                  grp_us->header.addinfo_in);

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                   "num_users_in=%d",num_users_in);
  /*
   *    Loop on input pairs users/groups
   */

   for (i=0 ; i LT num_users_in ; i++ ) {

       memset( grp_us->header.entry.f_entry_name, BLANK, 8);
       strcpy( grp_us->header.entry.f_entry_name, users_in[i]);
       strcpy( u2ug_params[i].user, users_in[i]);

       memset( grp_us->header.entry.s_entry_name, BLANK, 8);
       strcpy( grp_us->header.entry.s_entry_name, ugs_in[i]);
       strcpy( u2ug_params[i].group, ugs_in[i]);

       u2ug_params[i].u2ug_attr_data = U2UG_ATTR_REGULAR;

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                       "User-Group pair %d, Entry=%s  %s",
                       i, u2ug_params[i].user, u2ug_params[i].group);

      /*
       *      Extract information from RACF data base
       */

       grp_us->output_lines_ptr->max_len  = RACF_CNN_OUTPUT_SIZE;
       grp_us->output_lines_ptr->used_len = 0 ;
       grp_us->header.max_connect_number=1 ;              /* BS10008 */

 /* SAS2IBMT typedef and prototype changed for IBM C
     rc_pair = RACF_extract((RACF_ACCESS_PROG_E) racfprg,  *BS10008* */
       rc_pair = RACF_extract(racfprg,
                  RACF_OPERATION_LOCATE,
                  RACF_USER_PROFILE,
                  grp_us->header.entry.f_entry_name,
                  0, component,
                  (RACF_OUTPUT_LINE_rec_ptr)  grp_us->output_lines_ptr,
                  debug, RACF_NO , dest, msgs ,
                  grp_us->header.max_connect_number); /* BS10008 */
       grp_us->header.max_connect_number=1 ; /*restore val   BS10008 */
    /* max_connect_number is relevant only to CTSFRGC & CTSFRCN. BS10008
       However, parm should be passed to all RACF_extract calls. */

       grp_us->header.entry.t_entry_name[0] = NULL_CHAR ;

       if ( rc_pair EQ ESA_OK )
          {
          /*
           *         put connect information
           */

           grp_us->header.max_connect_number=1 ; /* one pair */
           grp_us->output_lines_ptr--;  /* work with tempror */
           grp_us->header.current_ptr--;/* connect area      */
                                        /* ------------------*/
           actnum_save=(*actual_num);        /* as3001 */
           put_connect_inf(num_users_in, handle, entry, have_more,
                           actual_num, u2ug_params, objs_exist,
             /* IS10076    addinfo, &grp_us, dest, msgs );     */
             /* IS10076 */ addinfo, &grp_us, admin_params);

           grp_us->header.current_ptr = grp_us->header.start_ptr;
           grp_us->output_lines_ptr   = grp_us->header.start_ptr;

          /*  as3001
           *  Check if after put connect information not changed
           *  actual num it means was ocurred internal errors
           *  after RACF_extract
           */

           if ( actnum_save EQ (*actual_num ) )  { /* as3001 */
              objs_exist[i] = OBJ_NOT_EXIST ;          /* as3001 */
              (*actual_num)++;                         /* as3001 */
          }                                            /* as3001 */
           else                                        /* as3001 */
              objs_exist[i] = OBJ_EXIST ;              /* as3001 */
           continue ;
         }

       if ( rc_pair EQ ESA_ERR ) { /* user      not defined to RACF */
          objs_exist[i] = OBJ_NOT_EXIST ;
          rc_pair = ESA_OK;
          /*** IS10002 drop most of WS2549 *****
          /********** ws2549 strats ***********
          rc = admin_params->cs_func.rssprm_get_opt_ptr(
                                          admin_params->rss_name,
                                          MSG_CONNGRP_ERR,
                                          sizeof(parm_get),
                                          parm_get,
                                          OPT_TRUE,
                                          OPT_TRUE) ;

          if (rc NE ESA_OK)
          parm_get[0] = MSG_CONNGRP_ERR_ON ;

          ESA_DIAG_printf(ESA_COMP_GTUG2UC,6,
            "parm_get = %s ,rc=%d ",
                             parm_get,rc);
          if (parm_get[0] == MSG_CONNGRP_ERR_ON)
          /********** ws2549 ends *************
           *** IS10002}of dropping ws2549 ***/
          params_ptr = admin_params->apiinit_handle;       /* IS10002*/
          if (params_ptr->rssparm_MSG_CONNGRP_ERR[0] ==    /* IS10002*/
                                          MSG_CONNGRP_ERR_ON)
                 CTSAMSG_print(ERR_ALREADY_DISCONNECTED,
                          msgs, NULL, dest, users_in[i], ugs_in[i]);
          (*actual_num)++;
          continue ;
      }

       if ( rc_pair EQ ESA_FATAL ) { /* serious error                */
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                           __LINE__, *handle );
          free_ugs(handle);
          *have_more=NO_MORE;
          goto exit ;
      }

  }/* for - loop on pairs      */

   *have_more = NO_MORE ;
   *actual_num= num_users_in;        /* as3001 */

  /*
   *    Finish
   */

   exit : ;

   if ( *handle NE NULL ) {
      ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                      "FREE_UGS:line=%d ptr=%X",
                      __LINE__, *handle );
      free_ugs(handle);
  }

   ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, rc_pair );

   return rc_pair;

}

 /**************************************************************
 *                                                             *
 * Subroutine name : do_manyg                                  *
 *                                                             *
 * DESCRIPTION     : Handle mode=many_ugs                      *
 *                                                             *
 * INPUT           : 1. max_conns  - output area counter       *
 *                   2. handle     - addr. of connect header   *
 *                   3. grp_us     - ptr to RACF out.area      *
 *                   4. entry      - entry name                *
 *                   5. dest       - msg dest ptr              *
 *                   6. msgs       - msgs handle ptr           *
 *                                                             *
 * OUTPUT          : 1. actual_num  - filling area counter     *
 *                   2. u2ug_params - connect output area      *
 *                   3. objs_exist  - exist/no vector          *
 *                   4. addinfo     - additional info          *
 *                   5. have_more   - continue/no parameter    *
 *                                                             *
 * RETURN VALUE    : ESA_RC  = ret code from subroutines :     *
 *                   RACF_get_list_count                       *
 *                   RACF_alloc_lines                          *
 *                   RACF_extract                              *
 *                   ESA_OK -  O.K.                            *
 *                   ESA_ERR                                   *
 *                   ESA_FATAL                                 *
 *                                                             *
 **************************************************************/
 /* SAS2IBMT typedef and prototype changed for IBM C
 static ESA_RC do_manyg(RACF_ACCESS_PROG           racfprg,          */
 static ESA_RC do_manyg(ASM_RTN_TYP              * racfprg, /*SAS2IBMT*/
                       RACF_CNN_OUTPUT_LINE_rec_ptr output,
                       char                      * entry,
                       short                       max_conns,
                       short                     * actual_num,
                       HAVE_MORE_typ             * have_more,
                       void                     ** handle,
                       short                       num_ugs_in,
                       short                       num_users_in,
                       UG_typ                      ugs_in[1],
                       USER_typ                    users_in[1],
                       U2UG_PARAMS_rec_typ         u2ug_params[1],
                       ADDINFO_rec_ptr             addinfo[1],
                       OBJ_EXISTS_typ              objs_exist[1],
        /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
        /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
        /* IS10076  */ ADMIN_PARAMS_rec_typ       * admin_params)

 {

  /*
   *   Variables
   */
        char user9[] = {NULL_CHAR,NULL_CHAR,NULL_CHAR,  /*ws2427*/
                        NULL_CHAR,NULL_CHAR,NULL_CHAR,
                        NULL_CHAR,NULL_CHAR,NULL_CHAR};
        RACF_FLAG_typ     universal; /*ws2427*/
        ESA_RC            uni_rc;    /*ws2427*/
        int racfret, racfres, us;    /*ws2427*/
        RACF_USERS_LIST_rec_ptr unilist;  /*ws2427*/
   ESA_RC rc_manyg = ESA_OK;
   int  i   ;
   int  request_number_i = 0;
   int  aclcnt              ;
   static char func[]="do_manyg";

   RACF_CONNECT_AREA_ptr grp_us;    /* group-users-connect-inf */

   CTSAMSG_HANDLE_rec_ptr        msgs;                     /* IS10076 */
   CTSAMSG_DEST_TABLE_rec_ptr    dest;                     /* IS10076 */

  /*
   *        Initialization
   */

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, 3, func);

   msgs = admin_params->ctsamsg_handle;                    /* IS10076 */
   dest = admin_params->ctsamsg_dest;                      /* IS10076 */

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                   "num_ugs_in=%d",num_ugs_in);
  /*
   *   If handle was passed, Continue with previous group connections
   */

   if ( *handle NE NULL ) {
       put_connect_inf(max_conns, handle, entry, have_more, actual_num,
                       u2ug_params, objs_exist, addinfo, &grp_us,
         /* IS10076    dest, msgs );             */
         /* IS10076 */ admin_params);

      /*
       *    Not enough place for connections , next time continue
       *    with the same group
       */

       if ( *have_more EQ HAVE_MORE )
          goto exit ;

      /*
       *    Finished with connections of current group, advance to
       *    next group
       */

       grp_us->header.done_request_number++ ;
       request_number_i = grp_us->header.done_request_number ;
       ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                       "FREE_UGS:line=%d ptr=%X",
                       __LINE__, *handle );
       free_ugs(handle);

  }        /* for handle NE NULL */

  /*
   *   If all groups were handled, finish
   */

   if ( request_number_i GE num_ugs_in )
      goto exit ;

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                   "num_ugs_in=%d  Request_number_i=%d",
                    num_ugs_in, request_number_i);

  /*
   *         Loop through requested groups count
   */

   for (i = request_number_i; i LT num_ugs_in; i++ ) {

       memset(entry, BLANK ,RCF_UG_NAME_LEN );
       strcpy(entry, ugs_in[i]);

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                       "Actual_num=%d", *actual_num);

      /*
       *      Get connections number ( racf field - ACLCNT )
       *                               profile    - group
       */

       /*ws2427*/
       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
          "Extracting group %s UNIVERSAL attribute",
           entry);
       uni_rc = RACF_uni_group(entry, &universal, TRUE,
                dest, msgs);
       if (uni_rc NE ESA_OK)
         /******************* is0297 starts **************************
          * rc should be 0, in order not to fail the transaction, as *
          * transaction may be download. send a diag &  msg instead. *
          ************************************************************/
         {
           rc_manyg = ESA_OK;
           objs_exist[0] = OBJ_NOT_EXIST ;
           ESA_DIAG_printf(ESA_COMP_GTUG2UC, 0,
             "Bad rc from RACF_uni_group (%d) for group %s",
             uni_rc,entry);
           /* error msg is sent by CC:
              CTS1101E Group xxx does not exist            */
           goto exit;
         }
         /******************* is0297 ends ***************************/

       if (universal EQ RACF_YES) {
       unilist = (RACF_USERS_LIST_rec_ptr) unistorage;
       if (unilist->max_users EQ 0)  {                 /*IS10076A
          CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,func,
         "Invalid RSSPARM RCF_UNIGROUP_MAX (or default) zero",
          ESA_FATAL,__LINE__); *** replace with a warning IS10076a*/
          CTSAMSG_print(WARN_INT1,msgs,NULL,dest,component,func,
"Connections not read as RCF_UNIGROUP_MAX parameter is zero or illegal",
          ESA_FATAL,__LINE__);                          /*IS10076A*/
          rc_manyg = ESA_FATAL; goto exit;
         }
       /* SAS2IBMT
       rc_manyg = ctsfrnm(RACF_OPERATION_NEXT,RACF_UNIGROUP_PROFILE, */
       rc_manyg = (*(ASM_RTN_TYP *)&ctsfrnm)              /* SAS2IBMT */
                         (RACF_OPERATION_NEXT,RACF_UNIGROUP_PROFILE,
                        entry, &aclcnt,
                        (RACF_OUTPUT_LINE_rec_ptr) unilist,
                       &debug, &racfret, &racfres, "SEP");
       if (rc_manyg NE ESA_OK) {
          CTSAMSG_print(ERR_INTERNAL2,msgs,NULL,dest,component,func,
         "Cannot count and retrieve all users of Universal Group.",
          rc_manyg,__LINE__);
          rc_manyg = ESA_FATAL; goto exit;
      }
       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
                      "Max users = %d Used users =%d",
                       unilist->max_users,
                       unilist->used_users);
       for (us = 0; us LT unilist->used_users; us++) {
       memcpy(user9,unilist->users[us],8);
       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 7,
                      "User number %d name %s",us,user9);}
      /*end of ws2427*/
     }/*universal count*/ else
      { /*not universal count*/
       output->max_len  = RACF_CNN_OUTPUT_SIZE;
       output->used_len = 0 ;
  /* SAS2IBMT typedef and prototype changed for IBM C
       rc_manyg = RACF_get_list_count(&ctsfrnm, RACF_OPERATION_LOCATE,*/
       rc_manyg = RACF_get_list_count((ASM_RTN_TYP *)&ctsfrnm,
                         RACF_OPERATION_LOCATE,
                         RACF_GROUP_PROFILE, entry, 0 ,component,
                         (RACF_OUTPUT_LINE_rec_ptr) output,
                         "ACLCNT", &aclcnt, debug, dest, msgs);
     }/*not universal count*/
       entry[RCF_UG_NAME_LEN] = NULL_CHAR ;

       ESA_DIAG_printf(ESA_COMP_GTUG2UC,1,
                       "group=%s    connect.count=%d   rc=%d",
                        entry, aclcnt, rc_manyg );

       if ( rc_manyg EQ ESA_FATAL )  /* serious error             */
          goto exit ;

       if ( rc_manyg EQ ESA_ERR ) { /* group not defined to RACF */
          rc_manyg = ESA_OK;
          continue ;
      }

       if ( aclcnt EQ 0 )            /* group without connections*/
          continue ;

      /*
       *   Allocate area for connection information for the group
       */

       rc_manyg = RACF_alloc_output_lines(handle, &grp_us, entry,
                                  component, aclcnt, num_spec_keywords,
                                  dest, msgs);
       if ( rc_manyg NE ESA_OK )    /* Malloc error */
          goto exit;

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                     "output_lines_ptr=%x", grp_us->output_lines_ptr);
      /*
       *      Extract information from RACF data base
       */

       grp_us->header.max_connect_number = aclcnt;       /*BS10008*/
       if (universal EQ RACF_YES) { /*ws2427*/
       for (us = 0; us LT unilist->used_users; us++) {

       grp_us->output_lines_ptr++;
       grp_us->output_lines_ptr->max_len  = RACF_CNN_OUTPUT_SIZE;
       grp_us->output_lines_ptr->used_len = 0 ;
       memcpy(user9,unilist->users[us],8);
       strcpy(grp_us->header.entry.f_entry_name, user9);
       strcpy(grp_us->header.entry.s_entry_name, entry);

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
                       "User-UniGroup pair %d, Entry=%s  %s", us,
                        grp_us->header.entry.f_entry_name,
                        grp_us->header.entry.s_entry_name);
      /*
       *      Extract pair info from RACF data base
       */


 /* SAS2IBMT typedef and prototype changed for IBM C
    rc_manyg = RACF_extract((RACF_ACCESS_PROG_E) &ctsfruc,  *BS10008**/
       rc_manyg = RACF_extract((ASM_RTN_TYP *) &ctsfruc,  /* SAS2IBMT */
                  RACF_OPERATION_LOCATE,
                  RACF_USER_PROFILE,
                grp_us->header.entry.f_entry_name,
                  0, component,
               (RACF_OUTPUT_LINE_rec_ptr) grp_us->output_lines_ptr,
                  debug, RACF_NO , dest, msgs ,
                  grp_us->header.max_connect_number); /* BS10008 */

       if ( rc_manyg NE ESA_OK ) break;
      }/*loop*/
      }/*universal ws2427*/
       else {
       grp_us->output_lines_ptr->max_len  = RACF_CNN_OUTPUT_SIZE;
       grp_us->output_lines_ptr->used_len = 0 ;
 /* SAS2IBMT typedef and prototype changed for IBM C
    rc_manyg = RACF_extract((RACF_ACCESS_PROG_E) racfprg,  *BS10008* */
       rc_manyg = RACF_extract(racfprg,
                  RACF_OPERATION_LOCATE,
                  RACF_GROUP_PROFILE, entry, 0, component,
                 (RACF_OUTPUT_LINE_rec_ptr) grp_us->output_lines_ptr,
                  debug, RACF_YES , dest, msgs ,
                  grp_us->header.max_connect_number); /* BS10008 */
      } /*non universal*/
       grp_us->header.max_connect_number = aclcnt;/*restore val BS10008*/

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 5,   /*ws2427*/
       "CA %s %s %s %s %d %d %s %x %x %x %x",
        grp_us->header.eyecatcher,
        grp_us->header.entry.f_entry_name,
        grp_us->header.entry.s_entry_name,
        grp_us->header.entry.t_entry_name,
        grp_us->header.max_connect_number,
        grp_us->header.done_request_number,
        grp_us->header.func,
        grp_us->header.addinfo_in,
        grp_us->header.current_ptr,
        grp_us->header.start_ptr,
        grp_us->output_lines_ptr);

       entry[RCF_UG_NAME_LEN] = NULL_CHAR ;

       if ( rc_manyg EQ ESA_ERR ) { /* group not defined to RACF */
          rc_manyg = ESA_OK;
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                          __LINE__, *handle );
          free_ugs(handle);
          continue ;
      }

       if ( rc_manyg EQ ESA_FATAL ) { /* serious error               */
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                          __LINE__, *handle );
          free_ugs(handle);
          *have_more=NO_MORE;
          goto exit ;
      }

      /*
       *         put connect information
       */

       put_connect_inf(max_conns, handle, entry, have_more, actual_num,
                       u2ug_params, objs_exist, addinfo, &grp_us,
         /* IS10076    dest, msgs );               */
         /* IS10076 */ admin_params);

      /*
       *         Have more information
       *         about current connection, but not enough place.
       */

       if ( *have_more EQ HAVE_MORE ) {
          grp_us->header.done_request_number = i ;
          goto exit ;
      }

      /*
       *         No more information
       *         about current connection
       */

       else {
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                          __LINE__, *handle );
          free_ugs(handle);
      }

 }/* loop on groups */

  rc_manyg = ESA_OK;

 /*
  *   Finish
  */

  exit : ;

  ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, rc_manyg);

  return rc_manyg ;

}

 /**************************************************************
 *                                                             *
 * Subroutine name : do_all                                    *
 *                                                             *
 * DESCRIPTION     : Handle mode=all (pass on all groups)      *
 *                                                             *
 * INPUT           : 1. max_conns  - output area counter       *
 *                   2. handle     - addr. of connect header   *
 *                   3. grp_us     - ptr to RACF out.area      *
 *                   4. entry           - entry name           *
 *                   5. dest            - msg dest ptr         *
 *                   6. msgs            - msgs handle ptr      *
 *                                                             *
 *                                                             *
 * OUTPUT          : 1. actual_num  - filling area counter     *
 *                   2. u2ug_params - connect output area      *
 *                   3. objs_exist  - exist/no vector          *
 *                   4. addinfo     - additional info          *
 *                   5. have_more   - continue/no parameter    *
 *                                                             *
 * RETURN VALUE    : ESA_RC  = ret code from subroutines :     *
 *                   RACF_get_list_count                       *
 *                   RACF_alloc_lines                          *
 *                   RACF_extract                              *
 *                   ESA_OK -  O.K.                            *
 *                   ESA_ERR                                   *
 *                   ESA_FATAL                                 *
 *                                                             *
 **************************************************************/
 /* SAS2IBMT typedef and prototype changed for IBM C
 static ESA_RC do_all(RACF_ACCESS_PROG              racfprg,         */
 static ESA_RC do_all(ASM_RTN_TYP                 * racfprg, /*SAS2IBMT*/
                       RACF_CNN_OUTPUT_LINE_rec_ptr output,
                       char                       * entry,
                       short                        max_conns,
                       short                      * actual_num,
                       HAVE_MORE_typ              * have_more,
                       void                      ** handle,
                       short                        num_ugs_in,
                       short                        num_users_in,
                       UG_typ                       ugs_in[1],
                       USER_typ                     users_in[1],
                       U2UG_PARAMS_rec_typ          u2ug_params[1],
                       ADDINFO_rec_ptr              addinfo[1],
                       OBJ_EXISTS_typ               objs_exist[1],
        /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
        /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
        /* IS10076  */ ADMIN_PARAMS_rec_typ       * admin_params)

 {

  /*
   *   Variables
   */

   ESA_RC rc_all = ESA_OK;
   int  i   ;
   int  request_number_i=0  ;
   int  cggrpct             ;
   int  opcode_flag         ;   /* spr163 */
   static char func[]="do_all";

   RACF_CONNECT_AREA_ptr grp_us;    /* group-users-connect-inf */

   CTSAMSG_HANDLE_rec_ptr        msgs;                     /* IS10076 */
   CTSAMSG_DEST_TABLE_rec_ptr    dest;                     /* IS10076 */

  /*
   *         Initialization
   */

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, 3, func);

   msgs = admin_params->ctsamsg_handle;                    /* IS10076 */
   dest = admin_params->ctsamsg_dest;                      /* IS10076 */

  /*
   *   If handle was passed, Continue from previous time
   */

   if ( *handle NE NULL ) {                   /* continue */

      put_connect_inf(max_conns, handle, entry, have_more, actual_num,
                      u2ug_params, objs_exist, addinfo, &grp_us,
       /* IS10076     dest, msgs );                   */
       /* IS10076 */  admin_params);

     /*
      *    Not enough place for putting .
      *    Will be putted to the next entry
      */

      if ( *have_more EQ HAVE_MORE )
         goto exit ;

     /*
      *    Finish put current connect information
      */

      grp_us->header.done_request_number++ ;
      request_number_i= grp_us->header.done_request_number ;
      ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                      "FREE_UGS:line=%d ptr=%X",
                      __LINE__, *handle );
      free_ugs(handle);

  }        /* if handle was passed */

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                   "request_number_i=%d",request_number_i);

   opcode_flag = OPCODE_NEXT;   /* spr163 */

   if ( request_number_i EQ 0 )  {               /* fisrt entry */
      memset(entry, BLANK ,RCF_UG_NAME_LEN);
      entry[RCF_UG_NAME_LEN]=NULL_CHAR;

      /* spr163 */

      ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
                      "entry=%d/%s num_users_in=%d num_ugs_in=%d" ,
                       strlen(entry),
                       entry, num_users_in, num_ugs_in );

      /* spr ... */
      if ( num_users_in GT 1 )
         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                       component,func,
                       "Invalid num_users_in parameter",
                       num_users_in, __LINE__);

     /*
      * GET_ALL - continue process checking
      */

     /*
      *  Start old emplamantation of get_all restart
      *
      *   if ( ( strlen(users_in[0]) GT 0)  AND
      *        users_in[0][0] NE '*'          )  {
      *       strcpy( entry, users_in[0] );
      *       opcode_flag = OPCODE_LOCATE;
      *  }
      *
      *  Start old emplamantation of get_all restart
      */

     /*
      *  New emplamantation of get_all restart
      */

      if ( num_users_in EQ 1 ) {
          strcpy( entry, users_in[0] );
          opcode_flag = OPCODE_LOCATE;
     }

  }

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,  /* spr163 */
                   "entry=%d/%s opcode=%s",
                    strlen(entry), entry,
                    ( opcode_flag ) ? "Locate" : "Next" );

  /*
   *     Loop on all users in the RACF data base
   */

   for (i = request_number_i ; ; i++ ) {

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                       "actual_num=%d", *actual_num) ;
      /*
       *  Get connections number (CGGRPCT field in user profile)
       */

       output->max_len  = RACF_CNN_OUTPUT_SIZE;
       output->used_len = 0 ;

       /* spr163 */

       if ( opcode_flag EQ OPCODE_LOCATE )  /* Locate opertaion */
  /* SAS2IBMT typedef and prototype changed for IBM C
         rc_all = RACF_get_list_count(&ctsfrnm, RACF_OPERATION_LOCATE, */
         rc_all = RACF_get_list_count((ASM_RTN_TYP *)&ctsfrnm,
                             RACF_OPERATION_LOCATE,
                             RACF_USER_PROFILE, entry, 0, component,
                             (RACF_OUTPUT_LINE_rec_ptr) output,
                             "CGGRPCT", &cggrpct, debug, dest, msgs);

       else   /* Next operation */
         /* SAS2IBMT typedef and prototype changed for IBM C
         rc_all = RACF_get_list_count(&ctsfrnm, RACF_OPERATION_NEXT, */
         rc_all = RACF_get_list_count((ASM_RTN_TYP *)&ctsfrnm,
                             RACF_OPERATION_NEXT,
                             RACF_USER_PROFILE, entry, 0, component,
                             (RACF_OUTPUT_LINE_rec_ptr) output,
                             "CGGRPCT", &cggrpct, debug, dest, msgs);

       opcode_flag = OPCODE_NEXT;    /* Next operation */
       entry[RCF_UG_NAME_LEN] = NULL_CHAR ;

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                       "user=%s   connect.count=%d  rc=%d",
                        entry, cggrpct, rc_all);

       if ( rc_all EQ ESA_ERR ) {       /* end-of-database          */
          rc_all = ESA_OK ;
          goto exit ;
      }
       if ( rc_all EQ ESA_FATAL)    /* Serious error            */
          goto exit ;

       if ( cggrpct EQ 0 )          /* user without connections*/
          continue ;

      /*
       *      Allocate memory for connect information
       */

       rc_all = RACF_alloc_output_lines(handle, &grp_us, entry,
                                  component, cggrpct, num_spec_keywords,
                                  dest, msgs);
       if ( rc_all NE ESA_OK )     /* malloc() error    */
          goto exit;

       ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                       "output_lines_ptr=%x", grp_us->output_lines_ptr);
      /*
       *      Extract information from RACF data base
       */

       grp_us->output_lines_ptr->max_len  = RACF_CNN_OUTPUT_SIZE;
       grp_us->output_lines_ptr->used_len = 0 ;
       grp_us->header.max_connect_number = cggrpct;      /*BS10008*/

 /* SAS2IBMT typedef and prototype changed for IBM C
       rc_all = RACF_extract((RACF_ACCESS_PROG_E) racfprg, *BS10008* */
       rc_all = RACF_extract(racfprg,
                    RACF_OPERATION_LOCATE,
                    RACF_USER_PROFILE, entry, 0, component,
                    (RACF_OUTPUT_LINE_rec_ptr) grp_us->output_lines_ptr,
                    debug, RACF_YES, dest, msgs ,
                    grp_us->header.max_connect_number); /* BS10008 */
       grp_us->header.max_connect_number=cggrpct;/*restore val BS10008*/

       entry[RCF_UG_NAME_LEN] = NULL_CHAR ;

       if ( rc_all EQ ESA_ERR ) {       /* Group not defined to RACF */
          rc_all = ESA_OK ;
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                          __LINE__, *handle );
          free_ugs(handle);
          continue ;
      }

       if ( rc_all EQ ESA_FATAL ) { /* Serious error                 */
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                          __LINE__, *handle );
          free_ugs(handle);
          *have_more=NO_MORE;
          goto exit ;
      }

      /*
       *         put connect information
       */

       put_connect_inf(max_conns, handle, entry, have_more, actual_num,
                       u2ug_params, objs_exist, addinfo, &grp_us,
         /* IS10076    dest, msgs );                    */
         /* IS10076 */ admin_params);
      /*
       *         Have more information
       *         about current connection, but not enough place.
       */

       if ( *have_more EQ HAVE_MORE ) {
          grp_us->header.done_request_number = i ;
          goto exit ;
      }

      /*
       *         Have not more information
       *         about current connection
       */

       else {
          ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                          "FREE_UGS:line=%d ptr=%X",
                          __LINE__, *handle );
          free_ugs(handle);
      }

  }/* for - loop on users */

   rc_all = ESA_OK;

  /*
   *      }of request many
   */
   exit : ;

   ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, rc_all);

   return rc_all ;

}


 /**************************************************************
 *                                                             *
 * Subroutine name : do_manyu                                  *
 *                                                             *
 * DESCRIPTION     : Handle mode=many_users                    *
 *                                                             *
 * INPUT           : 1. max_conns  - output area counter       *
 *                   2. handle     - addr. of connect header   *
 *                   3. grp_us     - ptr to RACF out.area      *
 *                   4. entry           - entry name           *
 *                   5. dest            - msg dest ptr         *
 *                   6. msgs            - msgs handle ptr      *
 *                                                             *
 *                                                             *
 * OUTPUT          : 1. actual_num  - filling area counter     *
 *                   2. u2ug_params - connect output area      *
 *                   3. objs_exist  - exist/no vector          *
 *                   4. addinfo     - additional info          *
 *                   5. have_more   - continue/no parameter    *
 *                                                             *
 * RETURN VALUE    : ESA_RC  = ret code from subroutines :     *
 *                   RACF_get_list_count                       *
 *                   RACF_alloc_lines                          *
 *                   RACF_extract                              *
 *                   ESA_OK -  O.K.                            *
 *                   ESA_ERR                                   *
 *                   ESA_FATAL                                 *
 *                                                             *
 *                                                             *
 **************************************************************/

 /* SAS2IBMT typedef and prototype changed for IBM C
 static ESA_RC do_manyu(RACF_ACCESS_PROG             racfprg,        */
 static ESA_RC do_manyu(ASM_RTN_TYP                * racfprg,
                        RACF_CNN_OUTPUT_LINE_rec_ptr output,
                        char                       * entry,
                        short                        max_conns,
                        short                      * actual_num,
                        HAVE_MORE_typ              * have_more,
                        void                      ** handle,
                        short                        num_ugs_in,
                        short                        num_users_in,
                        UG_typ                       ugs_in[1],
                        USER_typ                     users_in[1],
                        U2UG_PARAMS_rec_typ          u2ug_params[1],
                        ADDINFO_rec_ptr              addinfo[1],
                        OBJ_EXISTS_typ               objs_exist[1],
         /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
         /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
         /* IS10076  */ ADMIN_PARAMS_rec_typ       * admin_params)

 {

 /*
  *   Variables
  */

  ESA_RC rc_manyu =ESA_OK;
  int  i   ;
  int  request_number_i=0  ;
  int  cggrpct             ;       /* connect counter RACF field */
  static char func[]="do_manyu";

  RACF_CONNECT_AREA_ptr grp_us;    /* group-users-connect-inf */

  CTSAMSG_HANDLE_rec_ptr        msgs;                     /* IS10076 */
  CTSAMSG_DEST_TABLE_rec_ptr    dest;                     /* IS10076 */

 /*
  *   Initialization
  */

  ESA_DIAG_enter(ESA_COMP_GTUG2UC, 3, func);

  msgs = admin_params->ctsamsg_handle;                    /* IS10076 */
  dest = admin_params->ctsamsg_dest;                      /* IS10076 */

  ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                   "num_users_in=%d",num_users_in);
 /*
  *         continue put connect information
  */

  if ( *handle NE NULL ) {                   /* continue */

     put_connect_inf(max_conns, handle, entry, have_more, actual_num,
                     u2ug_params, objs_exist, addinfo, &grp_us,
      /* IS10076     dest, msgs );                 */
      /* IS10076 */  admin_params);

    /*
     *    Not enough place for putting .
     *    Will be putted to the next entry
     */

     if ( *have_more EQ HAVE_MORE )
        goto exit ;

    /*
     *    Finish put current connect information
     */

     grp_us->header.done_request_number++ ;
     request_number_i= grp_us->header.done_request_number ;
     ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                     "FREE_UGS:line=%d ptr=%X",
                     __LINE__, *handle );
     free_ugs(handle);

 }        /* for handle NE NULL */

  if ( request_number_i GE num_users_in )
     goto exit ;

  ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                  "num_users_in=%d  request_number_i=%d",
                  num_users_in, request_number_i);

 /*
  *         loop through requested groups count
  */

  for (i=request_number_i ; i LT num_users_in ; i++ ) {

      memset(entry, BLANK ,RCF_USER_NAME_LEN);
      strcpy(entry, users_in[i]) ;

      ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                      "actual_num=%d", *actual_num);

     /*
      *      Get connections number ( racf field - CGGRPCT)
      *                               profile    - user
      */

      output->max_len  = RACF_CNN_OUTPUT_SIZE;
      output->used_len = 0 ;

  /* SAS2IBMT typedef and prototype changed for IBM C
      rc_manyu = RACF_get_list_count(&ctsfrnm, RACF_OPERATION_LOCATE, */
      rc_manyu = RACF_get_list_count((ASM_RTN_TYP *)&ctsfrnm,
                          RACF_OPERATION_LOCATE,
                          RACF_USER_PROFILE, entry, 0 , component,
                          (RACF_OUTPUT_LINE_rec_ptr) output,
                          "CGGRPCT", &cggrpct, debug,
                          dest, msgs);

      entry[RCF_USER_NAME_LEN] = NULL_CHAR ;

      ESA_DIAG_printf(ESA_COMP_GTUG2UC, 1,
                      "user=%s  connect.count=%d  rc=%d",
                       entry, cggrpct, rc_manyu);

      if ( rc_manyu EQ ESA_FATAL )     /* Serious error            */
         goto exit ;

      if ( rc_manyu EQ ESA_ERR )       /* user not defined to RACF */
         continue ;

      if ( cggrpct EQ 0 )              /* user witout connections  */
          continue ;

     /*
      *      Allocate memory for connect information
      */

      rc_manyu = RACF_alloc_output_lines(handle, &grp_us,entry,
                                         component, cggrpct,
                                         num_spec_keywords, dest, msgs);
      if ( rc_manyu NE ESA_OK )      /* Malloc error  */
         goto exit;

      ESA_DIAG_printf(ESA_COMP_GTUG2UC, 4,
                      "output_lines_ptr=%x", grp_us->output_lines_ptr);
     /*
      *      Extract information from RACF data base
      */

      grp_us->output_lines_ptr->max_len  = RACF_CNN_OUTPUT_SIZE;
      grp_us->output_lines_ptr->used_len = 0 ;
      grp_us->header.max_connect_number = cggrpct ;        /*BS10008*/

 /* SAS2IBMT typedef and prototype changed for IBM C
      rc_manyu = RACF_extract((RACF_ACCESS_PROG_E) racfprg, *BS10008* */
      rc_manyu = RACF_extract(racfprg,
                    RACF_OPERATION_LOCATE,
                    RACF_USER_PROFILE, entry, 0, component,
                    (RACF_OUTPUT_LINE_rec_ptr) grp_us->output_lines_ptr,
                    debug, RACF_YES, dest, msgs ,
                    grp_us->header.max_connect_number);  /* BS10008 */
      grp_us->header.max_connect_number = cggrpct;/*restore val BS10008*/

      entry[RCF_USER_NAME_LEN] = NULL_CHAR ;

      if ( rc_manyu EQ ESA_ERR ) {      /* User not defined to RACF */
         rc_manyu=ESA_OK;
         ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                         "FREE_UGS:line=%d ptr=%X",
                         __LINE__, *handle );
         free_ugs(handle);
         continue ;
     }

      if ( rc_manyu EQ ESA_FATAL ) { /* Serious error                */
         ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                         "FREE_UGS:line=%d ptr=%X",
                         __LINE__, *handle );
         free_ugs(handle);
         *have_more=NO_MORE;
         goto exit ;
     }

     /*
      *         put connect information
      */

      put_connect_inf(max_conns, handle, entry, have_more, actual_num,
                      u2ug_params, objs_exist, addinfo, &grp_us,
       /* IS10076     dest, msgs );                 */
       /* IS10076 */  admin_params);

     /*
      *         Have more information
      *         about current connection, but not enough place.
      */

      if ( *have_more EQ HAVE_MORE ) {
         grp_us->header.done_request_number=i ;
         goto exit ;
     }

     /*
      *         Have not more information
      *         about current connection
      */

      else {
         ESA_DIAG_printf(ESA_COMP_GTUG2UC,3,
                         "FREE_UGS:line=%d ptr=%X",
                         __LINE__, *handle );
         free_ugs(handle);
     }

 }/* for - loop on groups */

  rc_manyu = ESA_OK ;

 /*
  *      }of request many
  */

  exit : ;

  ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, rc_manyu);

  return rc_manyu;

}


 /**************************************************************
 *                                                             *
 * Subroutine name : put_connect_inf                           *
 *                                                             *
 * DESCRIPTION     : Put connect information to addinfo        *
 *                                                             *
 * INPUT           : 1. max_conns  - output area counter       *
 *                   2. handle     - addr. of connect header   *
 *                   3. grp_us     - ptr to RACF out.area      *
 *                   4. entry           - entry name           *
 *                   5. dest            - msg dest ptr         *
 *                   6. msgs            - msgs handle ptr      *
 *                                                             *
 *                                                             *
 * OUTPUT          : 1. actual_num  - filling area counter     *
 *                   3. u2ug_params - connect output area      *
 *                   5. objs_exist  - exist/no vector          *
 *                   6. addinfo     - additional info          *
 *                   7. have_more   - continue/no parameter    *
 *                                                             *
 * RETURN VALUE    : ESA_RC  = ret code from subroutine:       *
 *                   fill_connect_inf                          *
 *                   ESA_OK    - O.K.                          *
 *                   ESA_ERR , ESA_FATAL                       *
 *                                                             *
 **************************************************************/

 static void put_connect_inf(short                  max_conns,
                        void                     ** handle,
                        char                      * entry,
                        HAVE_MORE_typ             * have_more,
                        short                     * actual_num,
                        U2UG_PARAMS_rec_typ         u2ug_params[1],
                        OBJ_EXISTS_typ              objs_exist[1],
                        ADDINFO_rec_ptr             addinfo[1],
                        RACF_CONNECT_AREA_ptr     * grp_us,
         /* IS10076     CTSAMSG_HANDLE_rec_typ     * msgs,      */
         /* IS10076     CTSAMSG_DEST_TABLE_rec_typ * dest);     */
         /* IS10076  */ ADMIN_PARAMS_rec_typ       * admin_params)
 {

 /*
  *   Variables
  */

  int               j,k ;
  char              dfltgrp[RCF_UG_NAME_LEN+1];
  ONE_FIELD_rec_ptr pair = NULL;
  RACF_CNN_OUTPUT_LINE_rec_ptr  output_lines_ptr;
  int               max_conn_num;
  static char       func[]="put_connect_inf";
  static char       msg_buf[100];
  RACF_FLAG_typ     universal; /*ws2427*/
  ESA_RC            uni_rc;    /*ws2427*/
  CTSAMSG_HANDLE_rec_ptr        msgs;                     /* IS10076 */
  CTSAMSG_DEST_TABLE_rec_ptr    dest;                     /* IS10076 */

 /*
  *   Initialization
  */

  ESA_DIAG_enter(ESA_COMP_GTUG2UC, 3, func );

  msgs = admin_params->ctsamsg_handle;                    /* IS10076 */
  dest = admin_params->ctsamsg_dest;                      /* IS10076 */

  *grp_us = (RACF_CONNECT_AREA_ptr)*handle ;
  max_conn_num     = (*grp_us)->header.max_connect_number;


  ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
                  "max_conns=%d max_conn_num=%d actual_num=%d",
                   max_conns, max_conn_num, *actual_num) ;

  *have_more=NO_MORE ;     /* have_more default  */

 /*
  *       Start to loop on output lines of the connections
  *       of a specific entry
  */

  strcpy(entry, (*grp_us)->header.entry.f_entry_name );
  (*grp_us)->output_lines_ptr = (*grp_us)->header.current_ptr ;
  output_lines_ptr = (*grp_us)->output_lines_ptr;

 /*
  *    Loop on count of output area, connect counter ,
  *    filling counter of output area
  */

  for (j=0; (j           LT   max_conn_num ) AND
            (*actual_num LT   max_conns    )     ; j++ ) {

      output_lines_ptr++ ;   /* ------------------------- */
                             /* Addr of RACF output area  */
                             /* Each connection has the   */
                             /* own RACF output area      */
                             /* count of areas equal count*/
                             /* of connections            */
                             /* --------------------------*/

      k = (*actual_num);

      ESA_DIAG_printf(ESA_COMP_GTUG2UC, 5,
          "j=%d k=%d actual_num=%d lines_ptr=%x addinfo_ptr=%x/%x",
           j,k,*actual_num,output_lines_ptr,addinfo[k],addinfo[k+1]);

      (*actual_num)++ ;

      u2ug_params[k].user[0] = NULL_CHAR;
      u2ug_params[k].group[0] = NULL_CHAR;

      ADDINFO_empty( (*grp_us)->header.addinfo_in );

     /*
      *      Put information in ADDINFO
      */

      ADDINFO_clear( addinfo[k] );
      RACF_output_to_addinfo((RACF_OUTPUT_LINE_rec_ptr)output_lines_ptr,
                             addinfo[k],
                             (*grp_us)->header.addinfo_in,
               /* IS10076    spec_keywords, dest, msgs);              */
      /* IS10100  IS10076 */ spec_keywords, NULL, NULL, admin_params);

      dfltgrp[0] = NULL_CHAR ;


     /*
      *   Handle special keyword - USERID
      */

      pair = ADDINFO_search("USERID",
                            RCF_ADDINFO_KWD_LEN,
                            (*grp_us)->header.addinfo_in ->pair,
                            (*grp_us)->header.addinfo_in->num_pairs );
      if (pair NE NULL)
         strcpy(u2ug_params[k].user,pair->value) ;
      else {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func,
                      "USERID field not found",0,__LINE__);
         (*actual_num)-- ;               /* as3001 */
         continue;                       /* as3001 */
     }

     /*
      *   Handle special keyword - GROUP
      */

      pair = ADDINFO_search("GROUP",
                            RCF_ADDINFO_KWD_LEN,
                            (*grp_us)->header.addinfo_in->pair,
                            (*grp_us)->header.addinfo_in->num_pairs );
      if (pair NE NULL)
         strcpy(u2ug_params[k].group,pair->value) ;
      else {
         sprintf(msg_buf,"GROUP field not found. USER=%s",
                 u2ug_params[k].user);
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func, msg_buf,0,__LINE__);
         (*actual_num)-- ;                /* as3001 */
         continue;                        /* as3001 */
     }

     /*
      *   Handling incomplete connections . BS2001
      */

           /*ws2427*/
           ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
              "Extracting group %s UNIVERSAL attribute",
               u2ug_params[k].group);
           uni_rc = RACF_uni_group(u2ug_params[k].group, &universal,
                    TRUE, dest, msgs);
           if (uni_rc NE ESA_OK) {
               ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, ESA_FATAL);
               return;}
      pair = ADDINFO_search("AUTHORITY",
                            RCF_ADDINFO_KWD_LEN,
                            addinfo[k] ->pair,
                            addinfo[k]->num_pairs );
      if ( pair ) {
        if (pair->vallen EQ 0 ) {

           if (universal EQ RACF_YES) {
              ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
             "AUTHORITY(USE) missing&added in %s-%s Univ. connection",
              u2ug_params[k].user  ,
              u2ug_params[k].group);
                                      strcpy(pair->value,"USE");
                                      pair->vallen = 3;
                                     }
          /*end ws2427*/
          else {
          sprintf(msg_buf,"AUTHORITY field empty. USER=%s GROUP=%s",
                  u2ug_params[k].user, u2ug_params[k].group);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                        component, func, msg_buf, 0,__LINE__);
          (*actual_num)-- ;
          continue;
         }/*universal no*/
       }      /* vallen not 0 */
     }        /* pair */
      /*bs2520*/
      pair = ADDINFO_search("UNIVERSAL",
                            RCF_ADDINFO_KWD_LEN,
                            addinfo[k] ->pair,
                            addinfo[k]->num_pairs );
      if ( pair ) {
        if (pair->vallen EQ 0 ) {
           if (universal EQ RACF_YES) {
              ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
             "Universal attribute missing & added in %s-%s connection",
              u2ug_params[k].user  ,
              u2ug_params[k].group);
              strcpy(pair->value,"Y");
              pair->vallen = 1;
          }
       }
    }/*of bs2520*/
     /*
      *   Handle special keyword - DFLTGRP
      */

      pair = ADDINFO_search("DFLTGRP",
                            RCF_ADDINFO_KWD_LEN,
                            (*grp_us)->header.addinfo_in->pair,
                            (*grp_us)->header.addinfo_in->num_pairs );
      if (pair NE NULL) {
         strcpy(dfltgrp,pair->value) ;
         strcpy(u2ug_params[k].def_group,pair->value);
     }
      else  {
         sprintf(msg_buf,"DFLTGRP field not found. USER=%s GROUP=%s",
                 u2ug_params[k].user, u2ug_params[k].group);
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func, msg_buf, 0,__LINE__);
         (*actual_num)-- ;               /* as0203 */
         continue;                       /* as0203 */

     }

      objs_exist[k] = OBJ_EXIST ;

      ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
                      "j=%d k=%d User=%s Group=%s",
                       j, k, u2ug_params[k].user,u2ug_params[k].group);

      u2ug_params[k].u2ug_admin_data = U2UG_ADM_NONE;

     /*
      *   Handle special keyword - SPECIAL
      */

      pair = ADDINFO_search("SPECIAL",
                            RCF_ADDINFO_KWD_LEN,
                            (*grp_us)->header.addinfo_in->pair,
                            (*grp_us)->header.addinfo_in->num_pairs );
      if (pair NE NULL) {
         if ( strcmp(pair->value,KWD_FLAG_ON) EQ 0 )
            u2ug_params[k].u2ug_admin_data = U2UG_ADM_ADMIN;
     }
      else {
        sprintf(msg_buf,"SPECIAL field not found. USER=%s GROUP=%s",
                u2ug_params[k].user, u2ug_params[k].group );
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest ,
                      component, func, msg_buf, 0,__LINE__);
        (*actual_num)-- ;               /* as0203 */
        continue;                       /* as0203 */

     }

     /*
      *   Handle special keyword - AUDITOR
      */

      pair = ADDINFO_search("AUDITOR",
                            RCF_ADDINFO_KWD_LEN,
                            (*grp_us)->header.addinfo_in->pair,
                            (*grp_us)->header.addinfo_in->num_pairs );
      if (pair NE NULL) {
        if ( strcmp(pair->value,KWD_FLAG_ON) EQ 0 ) {
          if ( u2ug_params[k].u2ug_admin_data EQ U2UG_ADM_NONE )
               u2ug_params[k].u2ug_admin_data = U2UG_ADM_AUDIT;
          else
               u2ug_params[k].u2ug_admin_data = U2UG_ADM_ALL;
       }
     }
      else {
          sprintf(msg_buf,"AUDITOR field not found. USER=%s GROUP=%s",
                  u2ug_params[k].user, u2ug_params[k].group );
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                        component, func, msg_buf, 0,__LINE__);
          (*actual_num)-- ;               /* as0203 */
          continue;                       /* as0203 */

     }
     /*
      *   Additional treatment default group data
      */

      if ( (strlen(dfltgrp) GT 0) AND
           (strcmp(dfltgrp, u2ug_params[k].group) EQ 0) )

         u2ug_params[k].u2ug_attr_data = U2UG_ATTR_DEFAULT_GROUP;

      else u2ug_params[k].u2ug_attr_data = U2UG_ATTR_REGULAR;

      (*grp_us)->header.current_ptr =  output_lines_ptr ;

 }

  (*grp_us)->header.max_connect_number -= j;

 /*
  *    Check if was processing all connect output area
  */

  if ( *actual_num GE max_conns)
     *have_more = HAVE_MORE ;
 /*
  *    Finish
  */

  exit : ;

  ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, ESA_OK);

}

 /**************************************************************
 *                                                             *
 * Subroutine name : Check_handle                              *
 *                                                             *
 * DESCRIPTION     : Check valid entering handle               *
 *                                                             *
 * INPUT           : 1. handle       - handle entering ptr     *
 *                                                             *
 * OUTPUT          : none                                      *
 *                                                             *
 * RETURN VALUE    : ESA_RC  :                                 *
 *                   ESA_OK    - O.K.                          *
 *                   ESA_ERR                                   *
 *                                                             *
 *                                                             *
 **************************************************************/

 static ESA_RC check_handle(void                    **handle,
                          CTSAMSG_DEST_TABLE_rec_ptr  dest,
                          CTSAMSG_HANDLE_rec_ptr      msgs)

 {

   RACF_CONNECT_AREA_ptr grp_us;
   ESA_RC rc=ESA_OK ;
   static char func[]="check_handle";

   ESA_DIAG_enter(ESA_COMP_GTUG2UC, 3, func );

   ESA_DIAG_printf(ESA_COMP_GTUG2UC, 3,
                   "Entering handle=%x", *handle);

   if ( *handle EQ NULL )
      goto exit;

   grp_us = (RACF_CONNECT_AREA_ptr)(*handle);

   if ( memcmp( grp_us->header.eyecatcher,
                CNN_EYECATCHER ,4 ) NE 0 ) {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component, func,
                    "Invalid handle",16,__LINE__);
      rc=ESA_ERR;
      goto exit;
  }

   exit: ;

   ESA_DIAG_exit(ESA_COMP_GTUG2UC, 3, func, rc );
   return rc ;

}

 /**************************************************************
 *                                                             *
 * Subroutine name : free_ugs                                  *
 *                                                             *
 * DESCRIPTION     : Free connect structure                    *
 *                                                             *
 * INPUT           : 1. handle       - handle entering ptr     *
 *                                                             *
 * OUTPUT          : none                                      *
 *                                                             *
 * RETURN VALUE    : none                                      *
 *                                                             *
 **************************************************************/

 static void free_ugs(void                   ** handle)
   {

     RACF_CONNECT_AREA_ptr grp_us;
     static char func[]="free_ugs";


     ESA_DIAG_enter(ESA_COMP_GTUG2UC, 4, func );

     grp_us = (RACF_CONNECT_AREA_ptr)(*handle);
     if ( grp_us->header.addinfo_in NE NULL ) {
       ESA_DIAG_printf(ESA_COMP_GTUG2UC,4,
                       "Addinfo FREE:line=%d ptr=%X",
                       __LINE__, grp_us->header.addinfo_in);

       ADDINFO_free(&(grp_us->header.addinfo_in));
    }

     ESA_DIAG_printf(ESA_COMP_GTUG2UC,4,
                     "Handle FREE:line=%d ptr=%X",
                     __LINE__, *handle);
     free(*handle);
     *handle=NULL ;

   ESA_DIAG_exit(ESA_COMP_GTUG2UC, 4, func, ESA_OK );

  }

