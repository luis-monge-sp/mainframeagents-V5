/**************************************************************
*                                                             *
* Title            : Online interceptor server                *
*                                                             *
* File Name        : ctsconi.c                                *
*                                                             *
* Author           : Doron Cohen                              *
*                                                             *
* Creation Date    : 21/08/94                                 *
*                                                             *
* Description      :                                          *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------  -------------------------------- *
* as2503   Alex     25/3/96  Send password in lower/upper case*
*                            according parameter from RSSPARM *
* dc2603   Doron    26/3/96  Added Snap in case of error      *
* ps0177   Alex     10/08/97 Fix bug                          *
* ps0219   Alex     26/10/97 Support for RSS type in EVT      *
* ps0254   Guy      21/04/98 Added argc, argv to call         *
* ps0295   Guy      16/08/98 Changes for common code 3.0.0 GA *
* ws2348   Doron    9/5/99   Support password filter option   *
* bs2388   Yonatan  6/6/99  change 'SUPRESS' to 'SUPPRESS'    *
*                           in onli_password_filter.          *
* ws2356   Yonatan  23/8/99 change the subsystem mechanism for*
*                           name/token.                       *
* ps0441   MC       21/11/00 Remove reference to SUBSYS rsspar*
* ps0452   Yonatan  02/01/01 Add encrhndl to interceptorinit  *
* ws2437   ShmuelK  02/12/01 Support password changes         *
*                            on non-managed LPARs             *
*                            and direct them to LPAR where    *
*                            agent is running                 *
* PS0505   ShmuelK  06/06/02 reset rc to 0 after missing parm *
*                           otherwise rc=6 is preserved thru  *
*                           end of Interceptor main program   *
* ws2505   BellaP   23/03/03 Filter out certain events from   *
*                            Online Interceptor.              *
*                            Load the additional parameters   *
*                            from RSSPARM member.             *
* IS0272   Michael  10/06/04 Update RACF 3.2.0 with old fixes *
* ws2529   AvnerL   12/10/04 Load SAS/C modules.              *
* ws2555   Eli MY   22/12/05 Enable memory util balancing.    *
* sas750   AvnerL   23/11/09 Clear SAS/C 7.5 warnings.        *
* IS10100  NuritY   29/07/13 Support REVOKE REASON.           *
* IS10107  NuritY   23/12/13 Support value of ASIS for        *
*                            ONLI_PASSWORD_CASE.              *
* SAS2IBMT SeligT   12/07/16 SAS/C to IBM C Conversion Project*
* SAS2IBMN NuritY   09/08/16 SAS/C to IBM C Conversion:       *
*                            replace loadm, buildm, unloadm,  *
*                            OS_DYNAM_Load and OS_DYNAM_Delete*
*                            with calls to ctsaldm and ctsadlm*
*    "       "      17/01/17 Replace sleep with ctsaslp       *
* WS10064  MeirS    04/10/17 Support Phrase.                  *
* WS10067  SeligT   30/01/18 Update GDB dynamically when      *
*                            access or resource rules are     *
*                            added/modified                   *
* IS10174  NuritY   13/05/18 Dynamic EXECOUT support.         *
* IS10184  NuritY   31/08/21 Improve scripts performance      *
* WS10085  PatilV   09/10/23 Enable RU_LOCKED for IDN with    *
*                            RACF                             *
* BS10128  PatilV   23/12/23 Change IDENTITY_PLATFORM as      *
*                            optional RSSPARM.                *
**************************************************************/

/****************************************************
* Procedure Name: ctsconi
*
* Description   : Online interceptor
*                 main routine.
*
* Input         :
*
* Return Value  : ESA_OK, ESA_FATAL
*
* Comments      :
* Scope         :
****************************************************/

#define THIS_IS_MAIN
#include <globs.h>

#include STRING
#include STDIO
#include STDLIB
 /* #include LCLIB                                           SAS2IBMT */
/* SAS2IBMN #include UNISTD                                * SAS2IBMT */
#include CTYPE                                              /* ws2555 */

#include ESA_API
#include ESA_DIAG
#include ESA_CS_OS
#include ESA_API_CODES
#include ESA_RSS
#include ESA_INIT
#include ESA_OS_CONSOLE                                     /* ws2555 */
#include API_AUTH                                         /* IS10184 */

#include MVS_CODES
#include MVS_INTERCEPTOR
#include MVS_OS_MVS
/*ws2437*/
#include MVS_OS_CLI

#include RACF_INTERCEPTOR
#include RACF
#include RACF_CODES

 /*
  *   Dynamic load files (ws2529)
  */
 /* #include <dynam.h>                                       SAS2IBMT */


/**************************************************************
*                                                             *
**************************************************************/

#define XMS_SSN_LEN  4
#define ACS_JBN_LEN  8

#define ONLI_ACS_JBN_PARAM      "ONLI_ACSJBN"
#define INSTAL_PARAM_NAME       "CTSA_ID"                /* ws2356 */
#define RQC_ELEMENTS_SIZE       "ONLI_MAX_EVENTS"        /* ws2555 */
#define RQC_OVERIDE_MINMAX_SIZE "RQC_OVERIDE_MINMAX_SIZE"/* ws2555 */
#define RQC_SIZE_DEFAULT        20000                    /* ws2555 */
#define RQC_MIN_SIZE            2000                     /* ws2555 */
#define RQC_MAX_SIZE            20999999                 /* ws2555 */
#define FREE_RQC_THRESHOLD      "ONLI_MIN_NOTIFY_EVENT%" /* ws2555 */
#define FREE_RQC_THRESH_DEFAULT "10%"                    /* ws2555 */
#define SLEEP_TIME_BEFORE_EVNT2RS    120                 /* WS2555 */
#define SLEEP_TIME_BETWEEN_MODIFY    5                   /* ws2555 */
#define MAX_PASSPHRASE               100                 /* WS10064 */

#define ONLI_MSG_DETAIL    "ONLI_DETAIL_MSGS"
#define DETAIL_ON          "Y"

#define CONSOLE_ON(msgs)              \
     if (msgs.ctsamsg_dest NE NULL)   \
        msgs.ctsamsg_dest->dests[CTSAMSG_DEST_CNSL].active = FLAG_YES;

#define CONSOLE_OFF(msgs)              \
     if (msgs.ctsamsg_dest NE NULL)    \
        msgs.ctsamsg_dest->dests[CTSAMSG_DEST_CNSL].active = FLAG_NO;

#define CONSOLE2_ON(msgs)              \
     if (msgs.ctsamsg_dest NE NULL)    \
        msgs.ctsamsg_dest->dests[CTSAMSG_DEST_CNSL2].active = FLAG_YES;

#define CONSOLE2_OFF(msgs)              \
     if (msgs.ctsamsg_dest NE NULL)     \
        msgs.ctsamsg_dest->dests[CTSAMSG_DEST_CNSL2].active = FLAG_NO;


/**************************************************************
*      xms routine and variables                              *
**************************************************************/

#define XMS_MODIFY_STOP "STOP"
#define XMS_MODIFY_DBG  "DEBUG"
#define XMS_MODIFY_SNAP "SNAP"

#define XMS_INIT        "INIT    "
#define XMS_TERM        "TERM    "
#define XMS_GETR        "GETRQC  "
#define XMS_TSTR        "TSTRQC  "                          /* ws2555 */
#define XMS_SNAP        "SNAP    "

/* ws2555 - adding parameter rqc_size to ctsaoni */
/* SAS2IBMT prototype changed for IBM C
extern int ctsaoni( char *xms_init, char *xms_ssn, char *xms_jbn,
                    int *xms_rc, int *xms_reason, int *rqc_size, ...);*/
extern int ctsaoni();                                     /* SAS2IBMT */
extern int ctsaslp();                                     /* SAS2IBMN */

static int  xms_r15=0, xms_rc=0, xms_reason=0,
            xms_time=300, xms_was_initialized=0;
static int  rqc_size, rqc_thresh, rqc_thresh_precent;       /* ws2555 */
static int  free_rqc_num; /* current # of free rqc's           ws2555 */
static int  xms_r15_snap=0;                                 /* ws2555 */

static char xms_ssn[XMS_SSN_LEN+1] = "CTSA"  ;
static char xms_jbn[] = ONLI_XMM_NAME;

static char acs_jbn[ACS_JBN_LEN+1];
static char acs_pgm[] = ONLI_ACS_PROG_NAME;

/**************************************************************
*      Abend exit routine and variables                       *
**************************************************************/

#define STAE_INIT  "INIT    "
#define STAE_TERM  "TERM    "

/* SAS2IBMT prototype changed for IBM C
extern int ctsasta( char *op, ...);                                  */
/*   remove until we know how to do recovery
extern int ctsasta();                                      * SAS2IBMT *
*/

static int  stae_r15 = 0;
static int  stae_step = 0;
static int  onli_exits_required = FALSE;

/**************************************************************
*      Termination routine and common varaibles               *
**************************************************************/

static void terminate(int p_rc);

static int  events_count = 0;
static int  events_fail_count = 0;
static int  events_ok_count = 0;
static int  debug_level;

static CTSAMSG_PARAMS_rec_typ       msgs;
static INTERCEPT_RSS_PARAMS_rec_typ rss_parm ;
static ADMIN_PARAMS_rec_typ         admin_params;         /* ps0295 */
static ENVIRONMENT_rec_typ         *envir;                /* ps0295 */

static RACF_init_done = FALSE;                            /* IS10100 */
static ACF2_init_done = FALSE;                            /* WS10067 */

/* ws2437 */
static INTERCEPT_RRSF_PARMS_rec_typ rrsfparm;
static ESA_RC ONLI_get_rrsf_parms( void );
static ESA_RC ONLI_password_propagate (INTERCEPT_EVENT_rec_ptr);

/* ps0219 */
static void build_rss_table(INTERCEPT_RSS_PARAMS_rec_typ *rss_parm,
                            CTSAMSG_HANDLE_rec_ptr        msgs,
                            CTSAMSG_DEST_TABLE_rec_ptr    dest);

/**************************************************************
*      Parameter extraction routine                           *
**************************************************************/

static ESA_RC ONLI_get_rss_params ( void );


/*************************************************************
*   Modify cases routine - ws2555                            *
**************************************************************/

static void modify_cases( char *xms_modify, int xms_modlen,
                          int *more_requests, int *dont_stop);

/*************************************************************
* Test if string contains 1 to 3 digits with % at the end    *
*                          ws2555                            *
*************************************************************/
static ESA_RC IsPrecentString(char *str);

/*************************************************************
* Test string if it contains max 10 chars of digits (full    *
*   word) - ws2555                                           *
*************************************************************/
static ESA_RC IsPosFullWordNum(char *str);

/**************************************************************
*      General                                                *
**************************************************************/

static int detail_msgs;

 char      pwdflag  = FLAG_PWD_ONLY_OFF;       /*WS2505 */
 char      usrflag  = FLAG_USERID_ON;          /*WS2505 */
 char      grpflag  = FLAG_GROUP_ON;           /*WS2505 */
 char      oeflag   = FLAG_OE_ON;              /*WS2505 */
 char      passflag = FLAG_PASSWORD_ON;        /*WS10064 */
 char      phrsflag = FLAG_PHRASE_ON;          /*WS10064 */
 char      provflag = IDNT_PLTFORM_IIQ_FLAG ;  /*WS10085 */
/**************************************************************
***************************************************************
****                                                       ****
****              Main Program                             ****
****                                                       ****
***************************************************************
**************************************************************/


int main(int argc, char **argv)                           /* SAS2IBMT */

{

 static char func[] = "ctsconi" ;

 /**************************************************************
 *      Variables                                              *
 **************************************************************/

 int                      i;   /* index for "for" loop */ /* ws2555 */
 INTERCEPT_EVENT_rec_typ  evt;
 ESA_RC                   rc = ESA_OK ;
 ESA_RC                   dref_rc;
 int                      dont_stop=1, more_requests = 0;
 char                     xms_modify[81];
 int                      xms_modlen;
 char                     rqc_size_str[50];       /* ws2555 */
 char                     parm_value_str[50];     /* ws2555 */
 char                     password_case[50];      /* as2503 */
 char                     password_case_flag;     /* as2503 */
 char                     password_filter[50]=""; /* WS2348 */
 char                     password_filter_flag=0; /* WS2348 */
 char                     event_userid[50]="";    /* WS2505 */
 char                     event_group[50]="";     /* WS2505 */
 char                     event_oe[50]="";        /* WS2505 */
 char                     event_password[50]="";  /* WS10064 */
 char                     event_phrase[50]="";    /* WS10064 */
 char                     event_pwd_only[50]="";  /* WS2505 */
 char                     platform[50]="";        /* WS10085*/
 int                      tso_r15,tso_rc,tso_rs;  /* ws2437 */
 char                     parm_get[81] = "";      /* WS10067 */
 ESA_RC                   rc1 = ESA_OK ;          /* WS10067 */
 /* SAS2IBMN
 int (*fp)(void);  *func. ptr of SAS/C loaded modules ws2529 *
 */
 char   ctsaslp_time_type = 'S';          /* S(conds)      SAS2IBMN */


/* __local void (*abend_exit_addr)(int rc) = &terminate;     SAS2IBMT */
   void (*abend_exit_addr)(int rc) = &terminate;          /* SAS2IBMT */

/**************************************************************
*      Initialization                                         *
**************************************************************/

/*
 *    Initialize rss parameters
 */

/* Removed by PS0089
 *  RACF_version_get(rss_parm.type);
 */

 if (argc GT 1)
    strcpy(rss_parm.name,argv[1]);

 strcpy(rss_parm.type, NULL_STRING);   /* ps0177 */

/* Removed by PS0089
 * else strcpy(rss_parm.name, NULL_STRING);
 */

 rss_parm.handle = NULL;
 rss_parm.msg_params = &msgs;

/*
 *    Initialize msg parameters
 */

 msgs.ctsamsg_handle = NULL;
 msgs.ctsamsg_dest = NULL;

/*
 *    Establish abend exit
 */

 /* SAS2IBMT
 stae_r15 = ctsasta(STAE_INIT, &abend_exit_addr );                   */
/*   remove until we know how to do recovery
 stae_r15 = (*(ASM_RTN_TYP *)&ctsasta)                     * SAS2IBMT *
                   (STAE_INIT, &abend_exit_addr );
*/

/*
 *    Initialize rs call
 */

 CS_get_envir_address (&envir);                           /* ps0295 */

 rc = CTSInterceptorInit( rss_parm.type, rss_parm.name,
                          &rss_parm.handle, NULL,         /* ps0452 */
                          INTERCEPT_ONLINE, NULL,
                          &admin_params,                  /* ps0295 */
                          argc, argv);
                                 /* PS0254 */

 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1, "rsinit rc =%d",rc);
 if ( rc NE ESA_OK )
 {
    rc = ESA_FATAL;
    goto exit;
 }
 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,6,                /* WS10067 */
          "admin_uname=|%s|", admin_params.admin_uname);  /* WS10067 */

 msgs.ctsamsg_handle = admin_params.ctsamsg_handle;       /* ps0295 */
 msgs.ctsamsg_dest = admin_params.ctsamsg_dest;           /* ps0295 */


   /* SAS2IBMN -
    * The code below is removed becaus it is not relevant for IBM C
    ********************* ws2529 starts *********************
    * Without this pre-load of SAS/C modules, these modules *
    * are loaded many times and great i/o activity is done  *
    * by the agent. (this is monitored by PDSMAN-BLDL.      *
    *********************************************************
   ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "Going to load SAS/C modules.");
   loadm("LSCALMT",&fp);
   if (fp NE NULL)
       ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "SAS/C LSCALMT load module was loaded successfully.");
   loadm("LSCIDDN",&fp);
   if (fp NE NULL)
       ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "SAS/C LSCIDDN load module was loaded successfully.");
   loadm("LSCRSTD",&fp);
   if (fp NE NULL)
       ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "SAS/C LSCRSTD load module was loaded successfully.");
   loadm("LSCIDSN",&fp);
   if (fp NE NULL)
       ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "SAS/C LSCIDSN load module was loaded successfully.");
   loadm("LSCOKVS",&fp);
   if (fp NE NULL)
       ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "SAS/C LSCOKVS load module was loaded successfully.");
   loadm("LSCKIO",&fp);
   if (fp NE NULL)
       ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT,6,
         "SAS/C LSCKIO load module was loaded successfully.");
    ********************** ws2529 ends **********************
   */

 /*ws2437*/

/* IS10184 - start                                             */
/*           This code was moved up to prevent failure if      */
/*           not APF-authorized.                               */
/*
 *   Ensure APF authority
 */

 rc = OS_MVS_check_apf( msgs.ctsamsg_handle,
                        msgs.ctsamsg_dest );
 if (rc NE ESA_OK)
 {
    rc = ESA_FATAL;
    goto exit;
 };
 /*  end of moved code - IS10184 */

 if (memcmp(argv[1],"RRSF",4) EQ 0)
 {

   rrsfparm.rrsf_mode = TRUE;

   rc = ONLI_get_rrsf_parms();
   if (rc NE ESA_OK)
   {
      rc = ESA_FATAL;
      goto exit;
   }

   ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
      "RRSF mode ON tnode=%s tuser=%s duser=%s",
       rrsfparm.target_node, rrsfparm.target_user, rrsfparm.dummy_user);

   rc = ESA_CLI_init_tso(&tso_r15, &tso_rc, &tso_rs);
   ESA_DIAG_printf( ESA_COMP_RSS_INTERCEPT, 1,
                   "Init tso rc=%d. Tso r15=%d rc=%d rs=%d",
                    rc, tso_r15, tso_rc, tso_rs );

   if (rc NE ESA_OK)
   {
      rc = ESA_FATAL;
      goto exit;
   }
 }
 else
 {
   rrsfparm.rrsf_mode = FALSE;          /*end-ws2437*/

   /*                                     * ps0219 *
    *  Obtain rss_name/rss_type table     * ps0219 *
    *  from environment var               * ps0219 *
    */                                   /* ps0219 */
   rss_parm.rss_num = 0;                 /* ps0219 */
   build_rss_table(&rss_parm,            /* ps0219 */
                   msgs.ctsamsg_handle,  /* ps0219 */
                   msgs.ctsamsg_dest );  /* ps0219 */
   rc = ONLI_get_rss_params();
   ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
                   "ONLI_get_rss_params rc =%d",rc);
   if (rc NE ESA_OK)
   {
      rc = ESA_FATAL;
      goto exit;
   }

 }

 ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 1, func);

 if (  ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT) GE 3)
    debug_level = 1;

 if ( memcmp( "RACF", rss_parm.type , 4) EQ 0)
 {                                                        /* IS10100 */
    onli_exits_required = TRUE;
    rc = CTSCINT_RACF_Init(ESA_COMP_RSS_INTERCEPT,        /* IS10100 */
                           &admin_params);                /* IS10100 */
    if (rc EQ ESA_OK)                                     /* IS10100 */
      RACF_init_done = TRUE;                              /* IS10100 */
    else                                                  /* IS10100 */
    {                                                     /* IS10100 */
       rc = ESA_FATAL;                                    /* IS10100 */
       goto exit;                                         /* IS10100 */
    }                                                     /* IS10100 */
 }                                                        /* IS10100 */
 else if (memcmp("ACF2", rss_parm.type, 4) EQ 0) {
    onli_exits_required = TRUE;
    /*                                                       WS10067
     *  Check whether the user wants us to process 'groups'. WS10067
     *  If yes, continue.  If not, skip the call to          WS10067
     *  CTSCINT_ACF2_Init.                                   WS10067
     */                                                   /* WS10067 */
    rc1 = rssprm_get_opt (rss_parm.name, "UDB_ACTIVE",    /* WS10067 */
                                       sizeof(parm_get),  /* WS10067 */
                                       parm_get,          /* WS10067 */
                                       OPT_TRUE,          /* WS10067 */
                                       OPT_TRUE);         /* WS10067 */
    if ( (rc1 EQ ESA_OK) AND                              /* WS10067 */
         (strcmp (parm_get, "N") EQ 0) ) goto skpinit;    /* WS10067 */
                                                          /* WS10067 */
    rc = CTSCINT_ACF2_Init(ESA_COMP_RSS_INTERCEPT,        /* WS10067 */
                           &admin_params);                /* WS10067 */
    if (rc EQ ESA_OK)                                     /* WS10067 */
       ACF2_init_done = TRUE;                             /* WS10067 */
    else {                                                /* WS10067 */
       CONSOLE_ON(msgs)                                   /* WS10067 */
       CTSAMSG_print(ERR_INTERNAL2, msgs.ctsamsg_handle,  /* WS10067 */
               NULL, msgs.ctsamsg_dest, "CTSCONI", func,  /* WS10067 */
               "ACF2_Init Failed", 16, __LINE__);         /* WS10067 */
       CONSOLE_OFF(msgs)                                  /* WS10067 */
       rc = ESA_FATAL;                                    /* WS10067 */
       goto exit;                                         /* WS10067 */
    }                                                     /* WS10067 */
 }                                                        /* WS10067 */
 skpinit:                                                 /* WS10067 */

 /* IS10184 - start                           */
 /*           Create the common_params if not alrady created.  */
 rc = OS_CS_init_cmnprms(COMMON_PARAMS_OWNER_ONLINE,
                         &admin_params);
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 1,
                 "OS_CS_init_cmnprms: rc = %d  blk = %p->%p->%p",
                 rc, &admin_params, admin_params.apiinit_handle,
                ((DUMMY_PARAMS_rec_typ  *)admin_params.apiinit_handle)->
                                                         common_params);
 if ( rc NE ESA_OK )
 {
    rc = ESA_FATAL;
    goto exit;
 };
 /* IS10184 - end  */

/* IS10184 - start
             This code was moved up to prevent failure if
             not APF-authorized.
/@
 *   Ensure APF authority
 @/

 rc = OS_MVS_check_apf( msgs.ctsamsg_handle,
                        msgs.ctsamsg_dest );
 if (rc NE ESA_OK)
 {
    rc = ESA_FATAL;
    goto exit;
 }
   end of moved code - IS10184 */

/*********************************************************************
 ***                  ws2555 - part 1 starts                       ***
 ***                  **********************                       ***
 *** Determine online interceptor memory consumption by defining   ***
 ***   number of events residing in memory.                        ***
 *** New RSSPARM parameters:                                       ***
 ***   ONLI_MAX_EVENTS - Number of rqc's to be allocated in memory ***
 ***   ONLI_MIN_EVENT_NOTIFY% - Threshold (in percents) in free    ***
 ***     chain of rqcs. When free elements number of rqc is below  ***
 ***     this threshold, warning message CTS4509W is sent.         ***
 ***   RQC_OVERIDE_MINMAX_SIZE - Internal parm which overides both ***
 ***     RQC_MIN_SIZE and RQC_MAX_SIZE.                            ***
 *** Enable modfiy/stop command while queue file is full.          ***
 *** New parm for CTSAONI called XMS_TSTR.                         ***
 *** New and updated messages when:                                ***
 ***   Queue is full. (CTS4508W)                                   ***
 ***   Below threshold of free rqc chain. (CTS4509W)               ***
 ***   Queue is full and New events are lost. (CTS4512E)           ***
 ***   New events are lost. (CTS4513E)                             ***
 ***   Shutdown request is pending (CTS4510I) and events will be   ***
 ***     lost if Online Interceptor is stopped (CTS4511W).         ***
 ***   Params ONLI_MAX_EVENTS, ONLI_MIN_EVENT_NOTIFY% with illegal ***
 ***     value. (CTS4514E)                                         ***
 *** New modify_cases function to treat modify/stop commands.      ***
 *** New IsPrecentString function for syntax testing of threshold  ***
 ***   parameter, which is a percent value.                        ***
 *** New IsPosFullWordNum function for syntax testing of a positive***
 ***   full and upto 10 digits number.                             ***
 *********************************************************************/

 dref_rc = rssprm_get_opt (rss_parm.name, RQC_ELEMENTS_SIZE,
                  sizeof(rqc_size_str),
                  rqc_size_str,
                  OPT_TRUE,
                  OPT_TRUE);
 if ( dref_rc NE ESA_OK ) {
    rqc_size = RQC_SIZE_DEFAULT;
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
     "Parameter get error or missing param=%s rc=%d. Param set to %d.",
     RQC_ELEMENTS_SIZE, dref_rc, rqc_size);
 }
 else
 {
    rqc_size = atoi(rqc_size_str);
    if ( (IsPosFullWordNum(rqc_size_str) EQ ESA_OK) AND
        rqc_size >= RQC_MIN_SIZE AND rqc_size <= RQC_MAX_SIZE ) {
        ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
               "Parameter %s set to %d.",
               RQC_ELEMENTS_SIZE, rqc_size);
    }
    else {
       rqc_size = RQC_SIZE_DEFAULT;
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
          "Parameter %s error (supplied value is %s, min value is %d,\
max value is %d. Param set to %d.",
          RQC_ELEMENTS_SIZE, rqc_size_str, RQC_MIN_SIZE, RQC_MAX_SIZE,
          rqc_size);
       /* Message to user */
       sprintf(parm_value_str,"%d events",  /* convert int to str */
               rqc_size);
       CONSOLE_ON(msgs)
       CTSAMSG_print(ERR_ONLI_ILLEGAL_PARM,
                   msgs.ctsamsg_handle, NULL,
                   msgs.ctsamsg_dest, RQC_ELEMENTS_SIZE,
                   rqc_size_str, parm_value_str);
       CONSOLE_OFF(msgs)
   }
 }
 /********************************************************************
 *  This section implements internal parameter,RQC_OVERIDE_MINMAX_SIZE,
 *  which is an internal parm only. When this parameter exists
 *  in RSSPARM it overides RQC_ELEMENTS_SIZE parameter, which can be
 *  used by customers. Both parameters determine number of events that
 *  can be accumulated in memory. RQC_OVERIDE_MINMAX_SIZE parm allows
 *  minimum value of 0 events. Be carefull when using it !
 *********************************************************************/
 dref_rc = rssprm_get_opt (rss_parm.name, RQC_OVERIDE_MINMAX_SIZE,
                  sizeof(rqc_size_str),
                  rqc_size_str,
                  OPT_TRUE,
                  OPT_TRUE);
 if ( dref_rc EQ ESA_OK ) {
    if (IsPosFullWordNum(rqc_size_str) EQ ESA_OK) {
       rqc_size = atoi(rqc_size_str);
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
              "Parameter %s set to %d (bypass parameter %s).",
               RQC_OVERIDE_MINMAX_SIZE, rqc_size, RQC_ELEMENTS_SIZE);
    }
    else {
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
          "Parameter %s error (supplied value is %s). Param is not\
 affecting (rqc_size=%d).",
           RQC_OVERIDE_MINMAX_SIZE, rqc_size_str, rqc_size);
    }
 }

 dref_rc = rssprm_get_opt (rss_parm.name, FREE_RQC_THRESHOLD,
                  sizeof(rqc_size_str),
                  rqc_size_str,
                  OPT_TRUE,
                  OPT_TRUE);
 if ( dref_rc NE ESA_OK ) {
    rqc_thresh_precent = atoi(FREE_RQC_THRESH_DEFAULT);
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
"Parameter get error or missing param=%s rc=%d. Param set to %d%%.",
    FREE_RQC_THRESHOLD, dref_rc, rqc_thresh_precent);
 }
 else {
    rqc_thresh_precent = atoi(rqc_size_str);
    if ( (IsPrecentString(rqc_size_str) EQ ESA_OK) AND
        rqc_thresh_precent >= 0 AND rqc_thresh_precent <= 100) {
        ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
            "Parameter %s set to %d%%.",
            FREE_RQC_THRESHOLD, rqc_thresh_precent);
    }
    else {
       rqc_thresh_precent = atoi(FREE_RQC_THRESH_DEFAULT);
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
         "Parameter %s error (supplied value is %s, min value is \
0%%, max value is 100%%. Param set to %d%%.",
         FREE_RQC_THRESHOLD, rqc_size_str, rqc_thresh_precent);
       /* Message to user */
       CONSOLE_ON(msgs)
       CTSAMSG_print(ERR_ONLI_ILLEGAL_PARM,
                   msgs.ctsamsg_handle, NULL,
                   msgs.ctsamsg_dest, FREE_RQC_THRESHOLD,
                   rqc_size_str, FREE_RQC_THRESH_DEFAULT);
       CONSOLE_OFF(msgs)
   }
 }
 /* Calulate real number of events for threshold */
 rqc_thresh = rqc_thresh_precent * rqc_size / 100;
 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
     "Notify threshold is %d events (%d%% of %d).",
     rqc_thresh, rqc_thresh_precent, rqc_size);

 /*********************************************************************
  ***                  ws2555 - part 1 end                          ***
  *********************************************************************/

/*
 *    Obtain cross memory and exits parameters
 */
/*
 *    Initialize cross memory and request chains environment
 */

 /* ws2555 - adding parameter rqc_size to ctsaoni */
 /* SAS2IBMT
 xms_r15 = ctsaoni( XMS_INIT, xms_ssn, xms_jbn, &debug_level,        */
 xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)                     /* SAS2IBMT */
                  ( XMS_INIT, xms_ssn, xms_jbn, &debug_level,
                    &xms_rc, &xms_reason,&rqc_size);
 xms_was_initialized = 1;

 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
                 "init r15=%d  rc=%d  rs=%d",
                 xms_r15, xms_rc, xms_reason );
 if ( xms_r15 NE 0)
 {
    CONSOLE_ON(msgs)
    CTSAMSG_print(ERR_ONLI_XMS_INIT, msgs.ctsamsg_handle, NULL,
                  msgs.ctsamsg_dest );
    CTSAMSG_print(ERR_ONLI_XMS_DETAIL, msgs.ctsamsg_handle, NULL,
                  msgs.ctsamsg_dest, "INITIALIZE", xms_r15, xms_rc,
                  xms_reason );
    CONSOLE_OFF(msgs)
    rc = ESA_FATAL;
    goto exit;
 }

/*
 *    Debug - snap control blocks
 */

 /* if (debug_level GE 4) BEGIN */ /* remarked due ws2555 */
 /* ws2555: Snap when ESA_COMP_RSS_INTERCEPT >= 20 */
 if (ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT) GE 20)
 {
    /* ws2555 - adding parameter rqc_size to ctsaoni */
    /* SAS2IBMT
    xms_r15 = ctsaoni( XMS_SNAP, xms_ssn, xms_jbn, &debug_level,     */
    xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)                  /* SAS2IBMT */
                     ( XMS_SNAP, xms_ssn, xms_jbn, &debug_level,
                       &xms_rc, &xms_reason,&rqc_size);
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                    "CTSAONI Snap on init r15=%d rc=%d rs=%d",
                    xms_r15, xms_rc, xms_reason );
 }

 /**************************************************************
 *   Install Interception Exits                                *
 **************************************************************/

 if (onli_exits_required)
 {
    rc = ONLI_exits_on ( rss_parm.name, rss_parm.type,
                         xms_ssn, xms_jbn, &msgs );
    if ( rc NE ESA_OK)
    {
       rc = ESA_FATAL;
       goto exit;
    }

 }

 /**************************************************************
 *   Loop on events                                            *
 **************************************************************/

 /* Start as2503  */
 rc = rssprm_get (rss_parm.name, PASSWORD_CASE_PARAM,
                  sizeof(password_case), password_case);
 if (rc NE ESA_OK)
 {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                     "parameter get error keyword=%s rc=%d",
                      PASSWORD_CASE_PARAM, rc );
    password_case_flag = PASSWORD_FLAG_LOWER;
 }

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                  "%s=%s", PASSWORD_CASE_PARAM, password_case);
 if ( strcmp(password_case, PASSWORD_CASE_LOWER) EQ 0 )
    password_case_flag = PASSWORD_FLAG_LOWER;
 /* IS10107
 else if ( strcmp(password_case, PASSWORD_CASE_UPPER) EQ 0 )
    password_case_flag = PASSWORD_FLAG_UPPER;                       */
 else
   if ( (strcmp(password_case, PASSWORD_CASE_UPPER) EQ 0)  /* IS10107 */
          OR                                               /* IS10107 */
        (strcmp(password_case, PASSWORD_CASE_ASIS) EQ 0) ) /* IS10107 */
     password_case_flag = PASSWORD_FLAG_ASIS;              /* IS10107 */
   else
     password_case_flag = PASSWORD_FLAG_LOWER;

 /* End   as2503  */

 password_filter_flag = PASSWORD_FILTER_OFF;              /* WS2348 */
 rc = rssprm_get_opt (rss_parm.name,                      /* WS2348 */
                  PASSWORD_FILTER_PARAM,                  /* WS2348 */
                  sizeof(password_filter),                /* WS2348 */
                  password_filter,                        /* WS2348 */
                  OPT_TRUE,                               /* WS2348 */
                  OPT_TRUE);                              /* WS2348 */
 if (rc NE ESA_OK) {                                      /* WS2348 */
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,           /* WS2348 */
         "parameter get error keyword=%s rc=%d",          /* WS2348 */
          PASSWORD_FILTER_PARAM, rc );                    /* WS2348 */
 }                                                        /* WS2348 */
                                                          /* PS0505 */
 rc=ESA_OK; /*reset rc since no parameter spec is OK*/    /* PS0505 */
                                                          /* WS2348 */
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,              /* WS2348 */
         "Checking filter option %s", password_filter);   /* WS2348 */
                                                          /* WS2348 */
 if (( strcmp(password_filter,                            /* WS2348 */
             PASSWORD_FILTER_SUPRESS) EQ 0 ) ||           /* WS2348 */
    ( strcmp(password_filter,                             /* BS2388 */
             PASSWORD_FILTER_SUPPRESS) EQ 0 )) {          /* BS2388 */
    password_filter_flag = PASSWORD_FILTER_ON;            /* WS2348 */
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,           /* WS2348 */
          "Password filter turned on" );                  /* WS2348 */
 }                                                        /* WS2348 */

 /* ws2505 - begin */
 /* load parameters from RSSPARM member and initiate
    appropriate flags accordence to parameter values.  */

 usrflag = FLAG_USERID_ON;
 rc = rssprm_get_opt (rss_parm.name,
                  EVENT_USERID_PARAM,
                  sizeof(event_userid),
                  event_userid,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
         "parameter get error keyword=%s rc=%d",
          EVENT_USERID_PARAM, rc );
 }

 rc=ESA_OK; /*reset rc since no parameter spec is OK*/

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "Checking event_user option %s", event_userid);

 if  ( strcmp(event_userid,
             EVENT_USERID_NO) EQ 0 )  {
      usrflag = FLAG_USERID_OFF;
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
          "Intercept event for user turned off" );
 }

 /* WS10064 start */
 /* get option whether password event should be accepted or not  */
 passflag = FLAG_PASSWORD_ON;
 rc = rssprm_get_opt (rss_parm.name,
                  EVENT_PASSWORD_PARAM,
                  sizeof(event_password),
                  event_password,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
         "parameter get error keyword=%s rc=%d",
          EVENT_PASSWORD_PARAM, rc );
 }
 rc=ESA_OK; /*reset rc since no parameter spec is OK*/
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "Checking event_password option %s", event_password);

 if  ( strcmp(event_password,
             EVENT_PASSWORD_NO) EQ 0 )  {
      passflag = FLAG_PASSWORD_OFF;
    CTSAMSG_print(MSG_ONLI_PSWPH_FILTERED,
                  msgs.ctsamsg_handle, NULL,
                  msgs.ctsamsg_dest,
                  "Password", EVENT_PASSWORD_PARAM);
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
          "Intercept event for password turned off" );
 }

 /* get option whether passphras event should be accepted or not */
 phrsflag = FLAG_PHRASE_ON;
 rc = rssprm_get_opt (rss_parm.name,
                  EVENT_PHRASE_PARAM,
                  sizeof(event_phrase),
                  event_phrase,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
         "parameter get error keyword=%s rc=%d",
          EVENT_PHRASE_PARAM, rc );
 }
 rc=ESA_OK; /*reset rc since no parameter spec is OK*/
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "Checking event_phrase option %s", event_phrase);

 if  ( strcmp(event_phrase,
             EVENT_PHRASE_NO) EQ 0 )    {
      phrsflag = FLAG_PHRASE_OFF;
    CTSAMSG_print(MSG_ONLI_PSWPH_FILTERED,
                  msgs.ctsamsg_handle, NULL,
                  msgs.ctsamsg_dest,
                  "Phrase", EVENT_PHRASE_PARAM);
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
          "Intercept event for phrase turned off" );
 }

 /* WS10064 end */

 grpflag = FLAG_GROUP_ON;
 rc = rssprm_get_opt (rss_parm.name,
                  EVENT_GROUP_PARAM,
                  sizeof(event_group),
                  event_group,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
         "parameter get error keyword=%s rc=%d",
          EVENT_GROUP_PARAM, rc );
 }

 rc=ESA_OK; /*reset rc since no parameter spec is OK*/

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "Checking event_group option %s", event_group);

 if  ( strcmp(event_group,
             EVENT_GROUP_NO) EQ 0 )  {
      grpflag = FLAG_GROUP_OFF;
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
          "Intercept event for group turned off" );
 }
 oeflag = FLAG_OE_ON;
 rc = rssprm_get_opt (rss_parm.name,
                  EVENT_OE_PARAM,
                  sizeof(event_oe),
                  event_oe,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
         "parameter get error keyword=%s rc=%d",
          EVENT_OE_PARAM, rc );
 }

 rc=ESA_OK; /*reset rc since no parameter spec is OK*/

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "Checking event_oe option %s", event_oe);

 if  ( strcmp(event_oe,
             EVENT_OE_NO) EQ 0 )  {
      oeflag = FLAG_OE_OFF;
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
          "Intercept event for oe turned off" );
 }
 pwdflag = FLAG_PWD_ONLY_OFF;
 rc = rssprm_get_opt (rss_parm.name,
                  EVENT_PWD_ONLY_PARAM,
                  sizeof(event_pwd_only),
                  event_pwd_only,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
         "parameter get error keyword=%s rc=%d",
          EVENT_PWD_ONLY_PARAM, rc );
 }

 rc=ESA_OK; /*reset rc since no parameter spec is OK*/

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "Checking event_user_pwd_only option %s", event_pwd_only);

 if  ( strcmp(event_pwd_only,
             EVENT_PWD_ONLY_YES) EQ 0 )  {
      pwdflag = FLAG_PWD_ONLY_ON;
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
          "Intercept event for pwd_only turned on" );
 }
 /* ws2505 - end */

 /* WS10085 start   */
 provflag = IDNT_PLTFORM_IIQ_FLAG ;
 /* BS10128 rc = rssprm_get (rss_parm.name, IDNT_PLTFORM_PARAM,
                  sizeof(platform),platform);    */
 rc = rssprm_get_opt(rss_parm.name, IDNT_PLTFORM_PARAM, /* BS10128*/
                  sizeof(platform),platform,
                  OPT_TRUE,
                  OPT_TRUE);
 if (rc NE ESA_OK)
 {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                     "parameter get error keyword=%s rc=%d",
                      IDNT_PLTFORM_PARAM, rc );
 rc=ESA_OK;        /*reset rc.   BS10128 */
 }
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 6,
    "Checking IDENTITY_PLATFORM option %s", platform);

 if  ( strcmp(platform,IDNT_PLTFORM_IDN) EQ 0 )
       provflag = IDNT_PLTFORM_IDN_FLAG ;

 /* WS10085 end   */

 CONSOLE_ON(msgs)
 CTSAMSG_print(MSG_ONLI_READY, msgs.ctsamsg_handle, NULL,
               msgs.ctsamsg_dest );
 CONSOLE_OFF(msgs)

 while ( (dont_stop) OR (more_requests) )
 {
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,4,
                    "Don't stop = %d, Not_end = %d",
                    dont_stop, more_requests );

   /*
    *   Get next event
    */

    /* ws2555 - adding parameter rqc_size to ctsaoni */
    /* SAS2IBMT
    xms_r15 = ctsaoni( XMS_GETR, xms_ssn, xms_jbn, &debug_level,     */
    xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)                  /* SAS2IBMT */
                     ( XMS_GETR, xms_ssn, xms_jbn, &debug_level,
                       &xms_rc, &xms_reason, &rqc_size, &evt,
                       &xms_time, xms_modify, &xms_modlen );
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,4,
                    "Get Request r15=%d  rc=%d  rs=%d",
                    xms_r15, xms_rc, xms_reason );

    /* ws2555 - adding snap */
    if (ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT) GE 20)
    {
       /* SAS2IBMT
       xms_r15_snap = ctsaoni( XMS_SNAP, xms_ssn, xms_jbn,           */
       xms_r15_snap = (*(ASM_RTN_TYP *)&ctsaoni)          /* SAS2IBMT */
                             ( XMS_SNAP, xms_ssn, xms_jbn,
                      &debug_level,&xms_rc, &xms_reason,&rqc_size);
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                      "CTSAONI Snap Get Request r15=%d rc=%d rs=%d",
                      xms_r15_snap, xms_rc, xms_reason );
    }

   /*
    *   Event occured
    */

    if (xms_r15 EQ 0)
    {
       events_count++;
       /*ws2437*/
       if (rrsfparm.rrsf_mode == TRUE)
       {
    /*    if ((evt.type EQ 'U') AND (evt.action EQ 'P')) */ /*WS10064 */
          if ((evt.type EQ 'U') AND ((evt.action EQ 'P') OR /*WS10064 */
                                     (evt.action EQ 'H')))  /*WS10064 */
          /* in RRSF mode, propagate only if the passphrase  *WS10064
             change is done during LOGON processing          *WS10064 */
             if ((evt.action EQ 'H') AND                    /*WS10064 */
                 (evt.caller_type EQ 'L'))                  /*WS10064 */
             {
                rc = ONLI_password_propagate(&evt);
                if (rc NE ESA_OK) goto exit;
             }
       }
       else         /*    -ws2437*/
       {

       rc = evnt2rs(&evt, &rss_parm, detail_msgs, acs_jbn, acs_pgm,
                    password_case_flag,                   /* AS2503 */
                    password_filter_flag,                 /* WS2348 */
                    &admin_params);                       /* PS0295 */

 /********************************************************************
 ***                  ws2555 - part 2 start                        ***
 *********************************************************************/

       /* get number of free memory events: FREE RQC CHAIN */
       /* SAS2IBMT
       xms_r15 = ctsaoni( XMS_TSTR, xms_ssn, xms_jbn,                */
       xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)               /* SAS2IBMT */
                        ( XMS_TSTR, xms_ssn, xms_jbn,
               &debug_level,&xms_rc, &xms_reason,&rqc_size,
               &rqc_thresh, &free_rqc_num, xms_modify, &xms_modlen);
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
              "CTSAONI Test RQC r15=%d rc=%d rs=%d free_rqc_num=%d",
              xms_r15, xms_rc, xms_reason, free_rqc_num );
       /* free memory events number under thershold alarm */
       if (free_rqc_num EQ 0) {     /* stop accumulating evnts? */
          CONSOLE_ON(msgs)          /* yes, stop accumulating */
          CTSAMSG_print(ERR_ONLI_EVENTS_LOST,
                   msgs.ctsamsg_handle, NULL, msgs.ctsamsg_dest );
          CONSOLE_OFF(msgs)
       }
       else if (rc EQ ESA_EOF) {    /* no, still acumulating */
          CONSOLE_ON(msgs)
          CTSAMSG_print(WRN_ONLI_QUEUE_FULL,
                   msgs.ctsamsg_handle, NULL, msgs.ctsamsg_dest );
          CONSOLE_OFF(msgs)
       }
       if ( xms_r15 EQ 4 ) {
          CONSOLE_ON(msgs)
          CTSAMSG_print(WRN_ONLI_FREE_RQC_LIMIT,
                      msgs.ctsamsg_handle, NULL,
                      msgs.ctsamsg_dest, free_rqc_num);
          CONSOLE_OFF(msgs)
       }

 /********************************************************************
 ***                  ws2555 - part 2 end                          ***
 *********************************************************************/

       while ( rc EQ ESA_EOF)
       {
       /* CONSOLE_ON(msgs)
          CTSAMSG_print(WRN_ONLI_QUEUE_FULL, msgs.ctsamsg_handle, NULL,
                        msgs.ctsamsg_dest );
          CONSOLE_OFF(msgs) */ /* remarked due ws2555 */

          /* sleep(120); */ /* remarked due ws2555 */

 /********************************************************************
 ***                  ws2555 - part 3 start                        ***
 *********************************************************************/

          /* This "for" was added to give operator a reasonable time
             response for modify/stop operator commands.
             The loop test each 5 second for modify/stop commands.
             Totaly loop should delay 120 sec before writing to queue */
          for (i=0;i < SLEEP_TIME_BEFORE_EVNT2RS;
                      i += SLEEP_TIME_BETWEEN_MODIFY)
          {
              /* SAS2IBMN  sleep(SLEEP_TIME_BETWEEN_MODIFY);       */
                                   /* suspend execution             */
              (*(ASM_RTN_TYP *)&ctsaslp)                 /* SAS2IBMN */
                    (SLEEP_TIME_BETWEEN_MODIFY,          /* SAS2IBMN */
                     &ctsaslp_time_type, &debug_level);  /* SAS2IBMN */
               ;
              /* SAS2IBMT
              xms_r15 = ctsaoni( XMS_TSTR, xms_ssn, xms_jbn,         */
              xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)        /* SAS2IBMT */
                               ( XMS_TSTR, xms_ssn, xms_jbn,
                 &debug_level,&xms_rc, &xms_reason,&rqc_size,
                 &rqc_thresh, &free_rqc_num, xms_modify, &xms_modlen);
              ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                "CTSAONI Test RQC r15=%d rc=%d rs=%d free_rqc_num=%d",
                 xms_r15, xms_rc, xms_reason, free_rqc_num );
              if (xms_r15 EQ 8)
              {
                 modify_cases( xms_modify, xms_modlen,
                               &more_requests, &dont_stop);
                 if (strcmp(xms_modify, XMS_MODIFY_STOP) EQ 0)
                 {
                    OS_CONSOLE_print("Control SA Agent: \
Shutdown request is pending.", /*as message INF_ONLI_SHUTDOWN_PENDING*/
                                     OS_CONS_ROLLABLE_YES,
                                     OS_CONS_SEV_NOTICE);
                    OS_CONSOLE_print("Control SA Agent: \
Events will be lost if CTSONLI is stopped.Start agent to empty queue.",
/* as message WRN_ONLI_EVENTS_LOST */
                                     OS_CONS_ROLLABLE_YES,
                                     OS_CONS_SEV_WARN);
                    CONSOLE_ON(msgs)
                    CTSAMSG_print(INF_ONLI_SHUTDOWN_PENDING,
                          msgs.ctsamsg_handle, NULL,
                          msgs.ctsamsg_dest);
                    CTSAMSG_print(WRN_ONLI_EVENTS_LOST,
                          msgs.ctsamsg_handle, NULL,
                          msgs.ctsamsg_dest);
                    CONSOLE_OFF(msgs)
                 }
              }
          }
          /* Snap after sleep and before event is written to queue */
          if (ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT) GE 20)
          {
             /* SAS2IBMT
             xms_r15_snap = ctsaoni( XMS_SNAP, xms_ssn, xms_jbn,     */
             xms_r15_snap = (*(ASM_RTN_TYP *)&ctsaoni)    /* SAS2IBMT */
                                   ( XMS_SNAP, xms_ssn, xms_jbn,
                        &debug_level,&xms_rc, &xms_reason,&rqc_size);
             ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                   "CTSAONI Snap when queue full r15=%d rc=%d rs=%d",
                   xms_r15_snap, xms_rc, xms_reason );
          }
          if (free_rqc_num EQ 0)       /* stop accumulating evnts? */
          {
             CONSOLE_ON(msgs)          /* yes, stop accumulating */
             CTSAMSG_print(ERR_ONLI_EVNT_LOST_Q_FULL,
                    msgs.ctsamsg_handle, NULL, msgs.ctsamsg_dest );
             CONSOLE_OFF(msgs)
          }
          else                         /* no, still acumulating */
          {
             CONSOLE_ON(msgs)
             CTSAMSG_print(WRN_ONLI_QUEUE_FULL,
                    msgs.ctsamsg_handle, NULL, msgs.ctsamsg_dest );
             CONSOLE_OFF(msgs)
          }
          if ( xms_r15 EQ 4 )       /* memory event reach alarm */
          {
             CONSOLE_ON(msgs)       /* treshold */
             CTSAMSG_print(WRN_ONLI_FREE_RQC_LIMIT,
                  msgs.ctsamsg_handle, NULL,
                  msgs.ctsamsg_dest, free_rqc_num);
             CONSOLE_OFF(msgs)
          }

 /********************************************************************
 ***                  ws2555 - part 3 end                          ***
 *********************************************************************/

          rc = evnt2rs(&evt, &rss_parm, 0, acs_jbn, acs_pgm,
                       password_case_flag,     /* as2503 */
                    password_filter_flag,               /* WS2348 */
                       &admin_params);                  /* ps0295 */
       }   /* end "while ( rc EQ ESA_EOF)" loop */

      /*
       *   rc:  ESA_OK , if processed
       *        ESA_skip,  if ignored
       *        ESA_FATAl, if error occured
       */
       }                         /*ws2437*/
       if (rc EQ ESA_OK)
          events_ok_count++;
       else if (rc NE ESA_SKIP)
          events_fail_count++;
       else
       {
          rc = ESA_OK;
          events_count--;
       }
       more_requests = 1;
    }

   /*
    *   Timeout occured
    */

    else if ( xms_r15 EQ 4)
    {
       more_requests = 0;
    }

   /*
    *   Modify requested
    */

    else if ( xms_r15 EQ 8)
    {
      /* handle modify/stop commands */
      modify_cases( xms_modify, xms_modlen,  /* ws2555 */
                    &more_requests, &dont_stop);
    }

   /*
    *   Error occured
    */

    else
    {
       CONSOLE_ON(msgs)
       CTSAMSG_print(ERR_ONLI_XMS_GETR, msgs.ctsamsg_handle, NULL,
                     msgs.ctsamsg_dest );
       CTSAMSG_print(ERR_ONLI_XMS_DETAIL, msgs.ctsamsg_handle, NULL,
                     msgs.ctsamsg_dest, "GETRQC", xms_r15, xms_rc,
                     xms_reason );
       CONSOLE_OFF(msgs)
       more_requests = 0;
       dont_stop = 0;
       rc = ESA_FATAL;

       /**** ERROR - SNAP For debug information ****/

       /* ws2555 - adding parameter rqc_size to ctsaoni */
       /* SAS2IBMT
       xms_r15 = ctsaoni(XMS_SNAP, xms_ssn, xms_jbn, &debug_level,   */
       xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)               /* SAS2IBMT */
                        (XMS_SNAP, xms_ssn, xms_jbn, &debug_level,
                         &xms_rc, &xms_reason,&rqc_size);
       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                       "CTSAONI Snap on error r15=%d rc=%d rs=%d",
                        xms_r15, xms_rc, xms_reason );
       if (onli_exits_required)                         /* PS0089 */
          ONLI_exits_snap ( rss_parm.name, rss_parm.type,
                            xms_ssn, xms_jbn, &msgs );
    }
 }

 /**************************************************************
 *   Termination                                               *
 **************************************************************/

 exit: ;

/*
 *   Call termination sequence
 */

 terminate(rc);

/*
 *   Return to caller
 */


 exitrc: ;
 ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 1, func, rc);

 return rc;

}

/****************************************************
* Procedure Name: IsPrecentString
* Created by:     ws2555
*
* Description   : Test if string contains between 1 to 3 digits with
*                 % sign appearing at the end.
*
* Input         : String.
*
* Return Value  : ESA_OK   : String represent 1 to 3 digits with
*                            % at the end
*                 ESA_FATAL: String not represent 1 to 3 digits
*                            with % at end
* Comments      :
* Scope         :
****************************************************/
static ESA_RC IsPrecentString(char *str)
{
   static char func[] = "IsPrecentString";
   int i, len;
   int rc = ESA_OK;

   ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

   if (str == NULL) { /* empty string not valid */
      rc = ESA_FATAL;
      goto exit;
   }

   len = strlen(str);
   if (len < 2 AND len > 4) { /* expect string between 0% to 100% */
      rc = ESA_FATAL;
      goto exit;
   }
   if (str[len-1] != '%') { /* expect last string to be % */
      rc = ESA_FATAL;
      goto exit;
   }

   for (i = 0;i < len-1;i++) { /* test if all chars are digits */
      if (isdigit(str[i]) == 0) {
         rc = ESA_FATAL;
         goto exit;
      }
   }

   exit: ;

   ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, rc);

   return rc;
}

/****************************************************
* Procedure Name: IsPosFullWordNum
* Created by:     ws2555
*
* Description   : Test if string contains integer of full
*                 word: 4 bytes, 32 bit, longest num is 10 chars.
*
* Input         : String represent full word number.
*
* Return Value  :  ESA_OK   : String represent full word integer
*                  ESA_FATAL: String not represent full word integer
*
* Comments      :
* Scope         :
****************************************************/
static ESA_RC IsPosFullWordNum(char *str)
{
   static char func[] = "IsPosFullWordNum";
   int  i;
   int  rc = ESA_FATAL;

   ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

   if (str == NULL) {   /* empty string not valid */
      rc = ESA_FATAL;
      goto exit;
   }

   for (i = 0;str[i] && i < 10;i++) { /* expect all chars are digits */
      if (isdigit(str[i]) == 0) {
         rc = ESA_FATAL;
         goto exit;
      }
   }

   if (str[i] == NULL_CHAR) {  /* expect string end          SAS2IBMT */
      rc = ESA_OK;
      goto exit;
   }

   exit: ;

   ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, rc);

   return rc;
}

/****************************************************
* Procedure Name: modify_cases
* Created by:     ws2555
*
* Description   : Perform modify/stop command according to
*                 reqeust type: Debug, Snap or Stop.
*
* Input         : xms_modify: string of command
*                 xms_modlen: length of xms_modify string
*                 more_requests,dont_stop: variables from main.
*
* Return Value  : void
*
* Comments      :
* Scope         : use in main
****************************************************/

static void modify_cases( char *xms_modify, int xms_modlen,
                          int *more_requests, int *dont_stop)
{
   static char func[] = "modify_cases";
   int  dref_rc;

   ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

   xms_modify[xms_modlen] = NULL_CHAR;
   ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
                    "modify len=%d, modify text=%s", xms_modlen,
                     xms_modify ) ;

   /**** Debug refresh ****/

   if (strcmp(xms_modify, XMS_MODIFY_DBG) EQ 0)
   {
      ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
                         "Diag level refresh requested");
      /**** Message ****/

      CONSOLE_ON(msgs)
      CTSAMSG_print(MSG_ONLI_MODIFY, msgs.ctsamsg_handle, NULL,
                       msgs.ctsamsg_dest, XMS_MODIFY_DBG );
      CONSOLE_OFF(msgs)

      /**** File refresh ****/

      dref_rc =
       ESA_DIAG_set_debug_levels_file(envir->file_diaglvl, /*sas750*/
                                      envir->p_main_name); /*sas750*/
 /*sas750 ESA_DIAG_set_debug_levels_file(envir->file_diaglvl); */
      ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,6,            /*sas750*/
         "refresh diaglvl with: <%d> <%d> <%x>",
          envir->file_diaglvl,envir->p_main_name,envir->p_main_name);
                                          /* ps0295 */
      if (dref_rc NE ESA_OK)
      {
          CONSOLE_ON(msgs)
          CTSAMSG_print(MSG_ONLI_DIAG_ERR, msgs.ctsamsg_handle, NULL,
                           msgs.ctsamsg_dest );
          CONSOLE_OFF(msgs)
      }

      if (ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT) GE 3)
             debug_level = 1;
      else debug_level = 0 ;

   }

   /**** Snap ****/

   else if (strcmp(xms_modify, XMS_MODIFY_SNAP) EQ 0)
   {
      CONSOLE_ON(msgs)
      CTSAMSG_print(MSG_ONLI_MODIFY, msgs.ctsamsg_handle, NULL,
                        msgs.ctsamsg_dest, XMS_MODIFY_SNAP);
      CONSOLE_OFF(msgs)

      /* ws2555 - adding parameter rqc_size to ctsaoni */
      /* SAS2IBMT
      xms_r15 = ctsaoni(XMS_SNAP, xms_ssn, xms_jbn, &debug_level,    */
      xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)                /* SAS2IBMT */
                       (XMS_SNAP, xms_ssn, xms_jbn, &debug_level,
                          &xms_rc, &xms_reason,&rqc_size);
      ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                         "CTSAONI Snap on modify r15=%d rc=%d rs=%d",
                          xms_r15, xms_rc, xms_reason );

      if (onli_exits_required)
          ONLI_exits_snap ( rss_parm.name, rss_parm.type,
                            xms_ssn, xms_jbn, &msgs );
   }

   /**** Shutdown requested ****/

   else if (strcmp(xms_modify, XMS_MODIFY_STOP) EQ 0)
   {
      CONSOLE_ON(msgs)
      CTSAMSG_print(MSG_ONLI_SHUTDOWN, msgs.ctsamsg_handle, NULL,
                     msgs.ctsamsg_dest );
      CONSOLE_OFF(msgs)
      *more_requests = 1;
      xms_time = 0;
      *dont_stop = 0;
   }

   /**** Uknown modify ****/

   else
   {
     CONSOLE_ON(msgs)
     CTSAMSG_print(ERR_ONLI_INVALID_MODIFY, msgs.ctsamsg_handle,
                     NULL, msgs.ctsamsg_dest, xms_modify );
     CONSOLE_OFF(msgs)
   }

   ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, ESA_OK );

}

/**************************************************************
*   Abend exit routine                                        *
**************************************************************/

static void terminate(int rc)
{
  static char func[] = "terminate";
  static int term_rc = 0;
  static int scode, ucode;
  static char abend_string[9];

  ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

  switch (stae_step)
  {
    case 0: stae_step++;

      /**** Check termination reason ****/

      ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
                      "rc = %d/%X", rc ,rc);

      /**** Abend code message ****/

      if (rc GT 100)
      {
         ucode = ( rc << 20 ) >> 20 ;
         scode = rc >> 12 ;
         ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT, 1,
                         "scode = %.3X   ucode = %.3X",scode, ucode);
         if (scode GT 0)
            sprintf(abend_string,"S%.3X",scode);
         else if (ucode GT 0)
            sprintf(abend_string,"U%.3X",ucode);
         else strcpy(abend_string, "????");

         CONSOLE2_ON(msgs)
         CTSAMSG_print(ERR_ONLI_ABEND, msgs.ctsamsg_handle, NULL,
                       msgs.ctsamsg_dest, abend_string);
         CONSOLE2_OFF(msgs)
      }

    case 1: stae_step++;

       /****  Print chains if debug level matches ****/

       /* if (debug_level GT 2) BEGIN */ /* remarked due ws2555 */
       /* ws2555: Snap if ESA_COMP_RSS_INTERCEPT >= 20 */
       if (ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT) GE 20)
       {
          /* ws2555 - adding parameter rqc_size to ctsaoni */
          /* SAS2IBMT
          xms_r15 = ctsaoni( XMS_SNAP, xms_ssn, xms_jbn, &debug_level,*/
          xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)            /* SAS2IBMT */
                           ( XMS_SNAP, xms_ssn, xms_jbn, &debug_level,
                             &xms_rc, &xms_reason,&rqc_size);
          ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
                     "CTSAONI Snap in terminate r15=%d  rc=%d  rs=%d",
                     xms_r15, xms_rc, xms_reason );
       }

    case 2: stae_step++;

       /****  Terminate dynamic exits ****/

       if ( xms_was_initialized )
       {
          if (onli_exits_required)
             ONLI_exits_off ( rss_parm.name, rss_parm.type,
                              xms_ssn, xms_jbn , &msgs );

       }

    case 3: stae_step++;

       /****  Terminate cross memory and chains  ****/

       if ( xms_was_initialized )
       {
          /* ws2555 - adding parameter rqc_size to ctsaoni */
          /* SAS2IBMT
          xms_r15 = ctsaoni( XMS_TERM, xms_ssn, xms_jbn, &debug_level,*/
          xms_r15 = (*(ASM_RTN_TYP *)&ctsaoni)            /* SAS2IBMT */
                           ( XMS_TERM, xms_ssn, xms_jbn, &debug_level,
                             &xms_rc, &xms_reason,&rqc_size);
          ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1,
                          "ctsaoni term r15=%d  rc=%d  rs=%d",
                          xms_r15, xms_rc, xms_reason );

          if (xms_r15 NE 0)
          {
             CONSOLE_ON(msgs)
             CTSAMSG_print(ERR_ONLI_XMS_TERM, msgs.ctsamsg_handle,
                           NULL, msgs.ctsamsg_dest );
             CTSAMSG_print(ERR_ONLI_XMS_DETAIL,
                           msgs.ctsamsg_handle, NULL, msgs.ctsamsg_dest,
                           "TERMINATE", xms_r15, xms_rc, xms_reason );
             CONSOLE_OFF(msgs)
          }

       }   /* xms initialized */

    case 4: stae_step++;

       /**** Termination messages ****/

       CTSAMSG_print(MSG_ONLI_STATS, msgs.ctsamsg_handle, NULL,
                     msgs.ctsamsg_dest, events_count, events_ok_count,
                     events_fail_count);

    case 5: stae_step++;

       /*                                                  * IS10100 *
        *  perform termination for RACF environment.       * IS10100 *
        */                                                /* IS10100 */
       if ( memcmp( "RACF", rss_parm.type , 4) EQ 0)      /* IS10100 */
       {                                                  /* IS10100 */
         if (RACF_init_done)                              /* IS10100 */
           rc = CTSCINT_RACF_Term(ESA_COMP_RSS_INTERCEPT, /* IS10100 */
                                  &admin_params);         /* IS10100 */
       }                                                  /* IS10100 */

       /*                                                  * WS10067 *
        *  perform termination for ACF2 environment.       * WS10067 *
        */                                                /* WS10067 */
       if (memcmp("ACF2", rss_parm.type, 4) EQ 0) {       /* WS10067 */
          if (ACF2_init_done)                             /* WS10067 */
            rc = CTSCINT_ACF2_Term(ESA_COMP_RSS_INTERCEPT,/* WS10067 */
                                   &admin_params);        /* WS10067 */
       }                                                  /* WS10067 */

       /* IS10184 - start */

       /*   Free the common_params and dummy_params, if needed */

       ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 1,
                 "Go free common_params and dummy_params: %p->%p->%p",
                  &admin_params, admin_params.apiinit_handle,
                ((DUMMY_PARAMS_rec_typ  *)admin_params.apiinit_handle)->
                                                         common_params);
       rc = OS_CS_term_cmnprms(COMMON_PARAMS_OWNER_ONLINE,
                               &admin_params);
       ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 1,
                       "OS_CS_term_cmnprms: rc = %d", rc);
       /* IS10184 - end  */

       /**** Terminate rs environment ****/

       term_rc=CTSInterceptorTerm( &rss_parm.handle, INTERCEPT_ONLINE,
                                   rc,  NULL, &admin_params);
                                                          /* ps0295 */

       ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,1, "rsterm rc = %d",
                       term_rc);

    default:

      /**** Terminate abend exit environment ****/

       /* SAS2IBMT
       stae_r15 = ctsasta(STAE_TERM);                                */
/*   remove until we know how to do recovery
       stae_r15 = (*(ASM_RTN_TYP *)&ctsasta)(STAE_TERM);   * SAS2IBMT *
 */
       break;

  }

  ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, ESA_OK );

  return ;

}

/****************************************************
* Procedure Name: ONLI_get_rss_params
*
* Description   : Obtain online interceptor rss params
*
* Input         :
*
* Return Value  : ESA_OK, ESA_FATAL
*
* Comments      :
* Scope         :
****************************************************/

static ESA_RC ONLI_get_rss_params ( void )
{

 static char func[] = "ONLI_get_rss_params";
 char parm_get[256] ;
 int  parm_len;
 ESA_RC rc = ESA_OK;

/*
 *    Initialize
 */

 ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

/*
 *    Determine rss name if none provided
 */

 if (rss_parm.name[0] EQ NULL_CHAR)
 {
    rc = rssprm_get_name (rss_parm.type ,RSS_TYPE ,parm_get) ;
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                     "Get RSS ok. %s = %s",
                     RSS_TYPE, parm_get);
       strncpy(rss_parm.name, parm_get, sizeof(rss_parm.name) - 1 );
       rss_parm.name[sizeof(rss_parm.name)-1] = NULL_CHAR;
    }
    else ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 3,
                     "Get RSS name error. keyword=%s rc=%d",
                     RSS_TYPE, rc);
 }

/*
 *    Get subsystem name
 */

 rc = rssprm_get_opt (ALL_RSS, INSTAL_PARAM_NAME,       /* ws2356 */
                  sizeof(parm_get), parm_get,           /* ws2356 */
                  OPT_TRUE,OPT_TRUE) ;                  /* ws2356 */
 if (rc NE ESA_OK)                                      /* ws2356 */
 {
  /* rc = rssprm_get (ALL_RSS, SUBSYS_PARAM_NAME, */    /* ps0441 */
  /*                  sizeof(parm_get), parm_get);*/    /* ps0441 */
  /* if (rc NE ESA_OK) BEGIN                      */    /* ps0441 */
        ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                         "parameter get error keyword=%s rc=%d",
                         INSTAL_PARAM_NAME, rc );
                     /*  SUBSYS_PARAM_NAME, rc );    ws2437   */
        rc = ESA_FATAL;
        goto exit;
 /*END                                                   /* ps0441 */
 }
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                  "subsystem parameter=%s", parm_get );

 memset(xms_ssn, BLANK, XMS_SSN_LEN);
 xms_ssn[XMS_SSN_LEN] = NULL_CHAR;
 parm_len = MIN( XMS_SSN_LEN, strlen(parm_get) );
 memcpy(xms_ssn, parm_get, parm_len);


/*
 *    Get updates messages detail option
 */

 rc= rssprm_get (rss_parm.name, ONLI_MSG_DETAIL,
                 sizeof(parm_get), parm_get);
 if (rc NE ESA_OK)
 {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                     "parameter get error keyword=%s rc=%d",
                     ONLI_MSG_DETAIL, rc );
    rc = ESA_FATAL;
    goto exit;
 }
 if (strcmp(parm_get, DETAIL_ON) EQ 0)
    detail_msgs = 1;
 else detail_msgs = 0;

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                  "Detail msgs flag set to %d (%s)",detail_msgs,
                  parm_get );
/*
 *    Get ACS Jobname details
 */

 rc = rssprm_get (rss_parm.name, ONLI_ACS_JBN_PARAM,
                  sizeof(parm_get), parm_get);
 if (rc NE ESA_OK)
 {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                     "parameter get error keyword=%s rc=%d",
                     ONLI_ACS_JBN_PARAM, rc );
    rc = ESA_FATAL;
    goto exit;
 }
 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                  "acs jobaname=%s", parm_get );

 memset(acs_jbn, BLANK, ACS_JBN_LEN);
 acs_jbn[ACS_JBN_LEN] = NULL_CHAR;
 parm_len = MIN( ACS_JBN_LEN, strlen(parm_get) );
 memcpy(acs_jbn, parm_get, parm_len);

/*
 *   Return to caller
 */

 exit: ;

 ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, rc);

 return rc;

}

/****************************************************
* Procedure Name: ONLI_get_rrsf_parms ws2437
*
* Description   : Obtain online interceptor RRSF PARMS
*
* Input         : INTERCEPT_RRSF_PARMS_rec_typ record
*                 ADMIN_params_rec_typ
*
* output:       : INTERCEPT_RRSF_PARMS_rec_typ record populated with
*                 mandatory parameters from RSSPARM member
*
* Return Value  : ESA_OK, ESA_FATAL
*
* Comments      : ws2437
* Scope         : used only by RRSF ONLI
****************************************************/

static ESA_RC ONLI_get_rrsf_parms( void)
{

 static char func[] = "ONLI_get_rrsf_parms";
 ESA_RC rc, saverc;

/*
 *    Initialize
 */

 ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

/*
 *    Get TARGET_NODE, TARGET_USER, DUMMY_USER
 */

  rc = admin_params.cs_func.rssprm_get_ptr(
             admin_params.rss_name,"TARGET_NODE",
             RCF_RRSF_NODE_LEN, rrsfparm.target_node);
  saverc = (rc NE ESA_OK) ? ESA_FATAL : rc;
  rc = admin_params.cs_func.rssprm_get_ptr(
             admin_params.rss_name,"TARGET_USER",
             RCF_USER_NAME_LEN,
             rrsfparm.target_user);
  saverc = (rc NE ESA_OK) ? ESA_FATAL : saverc;
  rc = admin_params.cs_func.rssprm_get_ptr(
             admin_params.rss_name,"DUMMY_USER",
             RCF_USER_NAME_LEN,
             rrsfparm.dummy_user);
  saverc = (rc NE ESA_OK) ? ESA_FATAL : saverc;

  if (saverc NE ESA_OK)
  CTSAMSG_print(MSG_ONLI_RRSF_PARM_FAIL, msgs.ctsamsg_handle, NULL,
  msgs.ctsamsg_dest, "TARGET_NODE", "TARGET_USER", "DUMMY_USER");


 ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, saverc);

 return saverc;

}    /*ws2437*/

/* ps0219 */
/****************************************************
* Procedure Name: build_rss_table
*
* Description   : Build rss_name/rss_type table
*                 from environment variable
* Input         : rss_parm   -   rss_parm structure
*
* Return Value  : none
*
* Comments      :
* Scope         :
****************************************************/
static void build_rss_table(INTERCEPT_RSS_PARAMS_rec_typ *rss_parm,
                            CTSAMSG_HANDLE_rec_ptr        msgs,
                            CTSAMSG_DEST_TABLE_rec_ptr    dest)
{
 static char func[] = "build_rss_table";
 char   internal2_msg_buf[100];
 int    i,k;

/*
 *    Initialize
 */

 ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                  "envir.max_rss_num=%d", envir->max_rss_num);
                                                          /* ps0295 */
 if (envir->max_rss_num LE 0)                             /* ps0295 */
  goto exit;

 k = envir->max_rss_num;                                  /* ps0295 */
 if (k GT MAX_INTERCEPT_RSS)
 {
   sprintf(internal2_msg_buf,
           "Number of rss exceed maximum %d", MAX_INTERCEPT_RSS);
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                 "CTSCONI", func, internal2_msg_buf, 4, __LINE__);
   k = MAX_INTERCEPT_RSS;
 }

 /*  Build rss names table */

 for (i=0; i LT k; i++)
 {
    ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                     "%d. rss_name=%s rss_type=%s",
                     i, envir->interest[i].rss,           /* ps0295 */
                        envir->interest[i].rss_type );    /* ps0295 */
    strcpy( rss_parm->rss_name[i], envir->interest[i].rss);
                                                          /* ps0295 */
    strcpy( rss_parm->rss_type[i], envir->interest[i].rss_type );
                                                          /* ps0295 */
 }

 rss_parm->rss_num = k;

/*
 *   Finish
 */

 exit: ;

 ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, ESA_OK );

}

/****************************************************
* Procedure Name: ONLI_password_propagate
* Created by:     ws2437
*
* Description   : Use evt data on password-change event
*                 and build a RACF ALTUSER ONLYAT command
*                 to RRSF-direct password event to managed LPAR
*
* Input         : evt fields available globally in this Main
*
* Return Value  : ESA_OK, ESA_FATAL
*
* Comments      :
* Scope         :
****************************************************/

static ESA_RC ONLI_password_propagate (INTERCEPT_EVENT_rec_ptr evtp)
{

 static char func[] = "ONLI_password_propagate";
 ESA_RC rc = ESA_OK;                             /*sas750 , tso_rc; */
 int  tso_rc;                                             /* sas750 */
 char         cmd[MAX_API_ST];
 char event_user[] =                  {NULL_CHAR, NULL_CHAR, NULL_CHAR,
      NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR};
 /* WS10064
 char event_pass[] =                  {NULL_CHAR, NULL_CHAR, NULL_CHAR,
      NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR};
 */
 /* WS10064 start */
 char event_pass[MAX_PASSPHRASE] =    {NULL_CHAR, NULL_CHAR, NULL_CHAR,
      NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR, NULL_CHAR};
 char  passtype[] = "PASSWORD";
 /* WS10064 end   */
 char* blank1;
 char  eoddn[9] = EXECOUT_DDNAME;                        /* IS10174 */

/*
 *    Initialize
 */

 ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT, 2, func);

 memcpy(event_user,evtp->user_id, sizeof(evtp-> user_id));
 blank1 = strchr(event_user, BLANK);
 if (blank1 NE NULL) *blank1 = NULL_CHAR;
 /*memcpy(event_pass,evtp->group_id,sizeof(evtp->group_id));  WS10064 * /
 /* WS10064 */
 if(evtp->action == 'H') {            /* WS10064 start */
   memcpy(event_pass,evtp->passphrase,sizeof(evtp->passphrase));
   strcpy(passtype,"PHRASE") ;
   }
 else {
   memcpy(event_pass,evtp->group_id,sizeof(evtp->group_id));
 blank1 = strchr(event_pass, BLANK);
 if (blank1 NE NULL) *blank1 = NULL_CHAR;
      }
                                      /* WS10064 end */
 /* WS10064
 sprintf(cmd,"CTSAEXC ALTUSER %s DATA('%s') PASSWORD(%s) ONLYAT(%s.%s)",
 */                                   /* WS10064 */
 sprintf(cmd,"CTSAEXC ALTUSER %s DATA('%s') %s(%s) ONLYAT(%s.%s)",
 /* rrsfparm.dummy_user,event_user,event_pass, */           /*WS10064 */
 rrsfparm.dummy_user,event_user,passtype,event_pass,        /*WS10064 */
 rrsfparm.target_node,rrsfparm.target_user);

 /* IS10174
 rc = ESA_CLI_exec_wait(EXECOUT_DDNAME, cmd, &tso_rc,
                        msgs.ctsamsg_dest, msgs.ctsamsg_handle);    */
 rc = ESA_CLI_exec_wait(eoddn, cmd, &tso_rc,             /* IS10174 */
                        &admin_params);                  /* IS10174 */

 ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
 /* WS10064
 "Password propagation command ended rc=%d tso_rc=%d", rc, tso_rc);
 */                                   /* WS10064 */
 "Password/Phrase propagation command ended rc=%d tso_rc=%d",
                                                     /*WS10064*/
 rc, tso_rc);                                        /*WS10064*/

 if  (rc NE ESA_OK)
 {
      CTSAMSG_print(MSG_ONLI_RRSF_PWD_FAIL, msgs.ctsamsg_handle, NULL,
              msgs.ctsamsg_dest, event_user);
              rc = ESA_FATAL;
 }

 else CTSAMSG_print(MSG_ONLI_RRSF_PWD_OK, msgs.ctsamsg_handle, NULL,
              msgs.ctsamsg_dest, event_user,
              rrsfparm.target_node,rrsfparm.target_user);
 exit: ;

 ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT, 2, func, rc);

 return rc;

}


