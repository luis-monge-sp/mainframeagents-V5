 /**************************************************************
 *                                                             *
 * Title            : RACF objects check functions             *
 *                                                             *
 * File Name        : ctsrchk.c                                *
 *                                                             *
 * Author           : Doron Cohen                              *
 *                    Alex Shvartsman                          *
 *                                                             *
 * Creation Date    : 30/03/94                                 *
 *                                                             *
 * Description      : Racf objects existance checks            *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------  -------------------------------- *
 * ps0460   ShmuelK  23/04/01 Support PROTECTED Racf User      *
 * ws2427   ShmuelK  23/01/02 Support UNIVERSAL GROUPs         *
 * ws2549   Yonatan  09/11/05 New parm MSG_CONNGRP_ERR.        *
 * IS10002  AvnerL   31/01/07 Drop CTS3121E. WS2549 improvement*
 * IS10096  NuritY   11/06/13 Fix compile error caused by      *
 *                            IS10070.                         *
 * SAS2IBMT SeligT   09/10/16 SAS/C to IBM C Conversion Project*
 * protect  AvnerL   13/06/17 Empty pswd 4 protected user only.*
 * IS10185  AvnerL   21/08/22 Recomp CTSRRCF & drop double     *
 **************************************************************/
 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDIO
 #include   STDLIB
 #include   STRING

 /*
  *   CONTROL-SA include files
  */

 #include ESA_DIAG
 #include ESA_CTSAMSG
 #include ESA_API_CODES
 #include ESA_RSS

 #include MVS_COMP

 #include RACF
 #include RACF_CODES
 /* IS10185 #include RACF_CODES */

 static char component[]="RACFCHK";
 static char res_desc[80];
 static char res_desc_format[] = "%s%s CLASS(%s)";
 static char when_desc[80];
 static char when_desc_format[] = "%s(%s)";

 #define VALUES_SEPARATOR_STR    ", ;"

/*
 *   Field blocking and coversion
 */

 #define BLOCK_STR(a,b)                   \
       memset(a, BLANK, sizeof(a) );      \
       if ( strlen(b) LE sizeof(a) )      \
          memcpy(a,b,strlen(b));


 /*
  *   RACF database assembler checking routine
  */

  /* SAS2IBMT prototype changed for IBM C
  extern int ctsfrch (int                * dbglvl,
                      int                * racf_rc,
                      int                * racf_reason,
                      int                * extr_rc,
                      char func[8], char object[8], ... );           */
  extern int ctsfrch ();                                  /* SAS2IBMT */

 /*
  *  Assembler cdt-service routine
  */

  /* SAS2IBMT prototype changed for IBM C
  extern int ctsfcdt (char                     * option,
                      int                      * debug,
                      ...);                                          */
  extern int ctsfcdt ();                                  /* SAS2IBMT */

 /*
  *    Global Variables
  */

/*static char function[8], object[8], class[8] , userid[8] , group[8],
 ps0460 */
  static char function[8], object[8], class[8] , group[8],
              userid[RCF_USER_NAME_LEN],        /*ps0460  */
              volume[8], profile[256] ,
              access[8], when_type[256], when_name[256],
              real_access[10];
  static char msg_buf[100];
  static int  dbglvl = 0;
  static int  racf_rc, racf_reason , extr_rc ;

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_user                              *
 *                                                             *
 * DESCRIPTION    : Check RACF user   existance                *
 *                                                             *
 * INPUT          : user     - User name                       *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Internal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_user(char                       * user,
                      OBJ_EXISTS_typ               test,
                      int                          msg_flag,
                      CTSAMSG_DEST_TABLE_rec_ptr   dest,
                      CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_user";
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "User=%s Test=%d", user, test);

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check user existance
  */

  BLOCK_STR(function, "USER")
  BLOCK_STR(object, user);

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function, object);

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf user check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print(ERR_DUP_USER, msgs, NULL, dest, user);
       }
       break;

    case 4:
       if (test EQ OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print( ERR_NO_USER, msgs, NULL, dest, user );
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "USER", user );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

 /**************************************************************
 /* Move it to new element CTSRPRO.                   *protect* *
 *                                                             *
 * PROCEDURE NAME : RACF_pro_user - added by PS0460            *
 *                                                             *
 * DESCRIPTION    : Check RACF user PROTECTED attribute        *
 *                                                             *
 * INPUT          : user     - User name                       *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : protect  - RACF_NO -Not Protected          *
 *                           - RACF_YES- No Password=Protected *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED No user             *
 *                  ESA_FATAL- Test FAILED Internal Error      *
 *                                                             *
 **************************************************************
 ESA_RC RACF_pro_user(char                       * user,
                      RACF_FLAG_typ           * protect,
                      int                      msg_flag,
                      CTSAMSG_DEST_TABLE_rec_ptr   dest,
                      CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_pro_user";
  ESA_RC pro_rc, rc;

 /*
  *   Initialize
  *

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "User=%s", user);

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check user PROTECTED
  *

  BLOCK_STR(function, "PROTECT")
  BLOCK_STR(object, user);

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            *
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT *
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function, object);

 /*
  *   Examine rc
  *

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf protected check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
      *protect = RACF_NO;
       pro_rc = ESA_OK;
       break;

    case 1:
      *protect = RACF_YES;
       pro_rc  = ESA_OK;
       break;

    case 4:
       pro_rc = ESA_ERR;
       if (msg_flag)
          CTSAMSG_print( ERR_NO_USER, msgs, NULL, dest, user );
       break;

    default:
       pro_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "USER", user );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  *

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,pro_rc );
  return pro_rc;

 }
  end of RACF_pro_user */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_uni_group - added by WS2427           *
 *                                                             *
 * DESCRIPTION    : Check RACF group UNIVERSAL attribute       *
 *                                                             *
 * INPUT          : group    - Group name                      *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : unitest  - RACF_NO - Not Universal         *
 *                           - RACF_YES- Universal             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED No Group            *
 *                  ESA_FATAL- Test FAILED Internal Error      *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_uni_group(char                      * group,
                       RACF_FLAG_typ           * unitest,
                       int                      msg_flag,
                       CTSAMSG_DEST_TABLE_rec_ptr   dest,
                       CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_uni_group";
  ESA_RC uni_rc, rc;
  /* IS10096 RACF_FLAG_typ  at_least_Z12;   */

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "Group=%s", group);

  /* IS10096 - remove support in old RACF versions
  rc = RACF_version_at_least (RACFZ12, &at_least_Z12);
  if (rc NE ESA_OK) {
      uni_rc = ESA_FATAL;goto exit;
  }
  if (at_least_Z12 EQ RACF_NO) {
  *unitest = RACF_NO;
  uni_rc = ESA_OK;
  goto exit;
  }
  */

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check group UNIVERSAL
  */

  BLOCK_STR(function, "UNIVERS")
  BLOCK_STR(object, group);

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function, object);

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf universal check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
      *unitest = RACF_NO;
       uni_rc = ESA_OK;
       break;

    case 1:
      *unitest = RACF_YES;
       uni_rc  = ESA_OK;
       break;

    case 4:
       uni_rc = ESA_ERR;
       if (msg_flag)
          CTSAMSG_print( ERR_NO_GROUP, msgs, NULL, dest, group );
       break;

    default:
       uni_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "GROUP", group );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

  exit:;
  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,uni_rc );
  return uni_rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_group                             *
 *                                                             *
 * DESCRIPTION    : Check RACF group  existance                *
 *                                                             *
 * INPUT          : group    - User name                       *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_group(char                       * group,
                       OBJ_EXISTS_typ               test,
                       int                          msg_flag,
                       CTSAMSG_DEST_TABLE_rec_ptr   dest,
                       CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_group";
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "Group=%s Test=%d", group, test);

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check group existance
  */

  BLOCK_STR(function, "GROUP")
  BLOCK_STR(object, group)

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function, object);

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf group check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print(ERR_DUP_GROUP, msgs, NULL, dest, group );
       }
       break;

    case 4:
       if (test EQ OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print( ERR_NO_GROUP, msgs, NULL, dest, group );
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "GROUP", group );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }


 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_conn                              *
 *                                                             *
 * DESCRIPTION    : Check RACF connection existance            *
 *                                                             *
 * INPUT          : group    - User name                       *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_conn(char                       * user_name,
                      char                       * group_name,
                      OBJ_EXISTS_typ               test,
                      int                          msg_flag,
                      CTSAMSG_DEST_TABLE_rec_ptr   dest,
                      CTSAMSG_HANDLE_rec_ptr       msgs,
                      ADMIN_PARAMS_rec_typ * admin_params)
 {

  static char func[]="RACF_chk_conn";
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;
  /* IS10002 char   parm_get[4] = " ";                      /* ws2549 */

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "User=%s Group=%s Test=%d",
                   user_name, group_name, test);

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check connection existance
  */

  BLOCK_STR(function,"CONNECT"  )
  BLOCK_STR(userid  , user_name )
  BLOCK_STR(group   , group_name)

 /* IS10002 ws2549 *
 rc = admin_params->cs_func.rssprm_get_opt_ptr(admin_params->rss_name,
                                          MSG_CONNGRP_ERR,
                                          sizeof(parm_get),
                                          parm_get,
                                          OPT_TRUE,
                                          OPT_TRUE) ;

  if (rc NE ESA_OK)                                /* ws2549 *
      parm_get[0] = MSG_CONNGRP_ERR_ON ;

  ESA_DIAG_printf(PLT_COMP_API_RACF,6,             /* ws2549 *
            "parm_get = %s ,rc=%d ",
                   parm_get,rc);
   end of dropped part by IS10002*/

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc ,           */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc ,
               function, userid, group);

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf conn check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST)                              /*IS10002*/
       {
        /*IS10002 if(parm_get[0]==MSG_CONNGRP_ERR_ON) {  *ws2549*/
        chk_rc = ESA_ERR;
        if (msg_flag)
           CTSAMSG_print(ERR_ALREADY_CONNECTED, msgs, NULL, dest,
                         user_name, group_name );
       }
       break;

    case 4:
       if (test EQ OBJ_EXIST)                            /*IS10002*/
       {
        chk_rc = ESA_ERR;
        if (msg_flag)
           CTSAMSG_print(ERR_ALREADY_DISCONNECTED, msgs, NULL,
                         dest, user_name, group_name );
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE_C,   msgs, NULL, dest,
                      "CONNECT", user_name, group_name);
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_res                               *
 *                                                             *
 * DESCRIPTION    : Check RACF resource existance              *
 *                                                             *
 * INPUT          : res_class   - class                        *
 *                  res_profile - profile                      *
 *                  res_volume  - volume                       *
 *                  generic_flag- generic flag                 *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_res(char                       * res_class,
                     char                       * res_profile,
                     char                       * res_volume,
                     int                          generic_flag,
                     OBJ_EXISTS_typ               test,
                     int                          msg_flag,
                     CTSAMSG_DEST_TABLE_rec_ptr   dest,
                     CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_res";
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "res_class=%s res_profile=%s Test=%d",
                   res_class, res_profile, test) ;

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check resource existance
  */

  if ( strlen(res_class)     +
       strlen(res_profile)   +
       strlen(res_desc_format) LE sizeof(res_desc)    )
    sprintf(res_desc,res_desc_format,
            res_profile, ( generic_flag ) ? "(G)" : "" ,
            res_class );
  else
    strcpy( res_desc, res_desc_format );

  BLOCK_STR(function, "RESOURCE")
  BLOCK_STR(class   , res_class)
  BLOCK_STR(profile , res_profile)
  BLOCK_STR(volume  , res_volume)

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc ,           */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc ,
               function, class, profile, &generic_flag, volume );

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf resource check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print(ERR_DUP_RES, msgs, NULL, dest, res_desc );
       }
       break;

    case 4:
       if (test EQ OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print( ERR_RES_NOT_EXIST,
                            msgs, NULL, dest, res_desc);
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "RESOURCE", res_desc );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_hilvds                            *
 *                                                             *
 * DESCRIPTION    : Check RACF HILVDS resource existance       *
 *                                                             *
 * INPUT          : res_object - object ID                     *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_hilvds(char                     *res_object,
                        OBJ_EXISTS_typ               test,
                        int                          msg_flag,
                        CTSAMSG_DEST_TABLE_rec_ptr   dest,
                        CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_hilvds";
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "Object=%s Test=%d", res_object, test) ;

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check HILVLDS existance
  */

  BLOCK_STR(function, "HILVLDS")
  BLOCK_STR(object  , res_object)

  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function, object);
 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf resource check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST)
          chk_rc = ESA_ERR;
       break;

    case 4:
       if (test EQ OBJ_EXIST)
          chk_rc = ESA_ERR;
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "RESOURCE", res_desc );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_ace                               *
 *                                                             *
 * DESCRIPTION    : Check RACF resource ace existance          *
 *                                                             *
 * INPUT          : res_class   - class                        *
 *                  res_profile - profile                      *
 *                  res_volume  - volume                       *
 *                  generic_flag- generic flag                 *
 *                  res_object  - user, group                  *
 *                  res_access  - access ( may be NULL )       *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_ace(char                       * res_class,
                     char                       * res_profile,
                     char                       * res_volume,
                     int                          generic_flag,
                     char                       * res_object,
                     char                       * res_access,
                     OBJ_EXISTS_typ               test,
                     int                          msg_flag,
                     CTSAMSG_DEST_TABLE_rec_ptr   dest,
                     CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_ace";
  char   *access_ptr = NULL;
  char   *chk_ptr;
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "res_class=%s res_profile=%s Object=%s Test=%d",
                   res_class, res_profile, res_object, test) ;
  if ( res_access )
    ESA_DIAG_printf(PLT_COMP_API_RACF,1, "access=%s", res_access );


  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *    Check that access parameter does not contain a list of values
  */

  if ( res_access )  {
    chk_ptr = strpbrk( res_access, VALUES_SEPARATOR_STR);
    if ( chk_ptr NE NULL ) {
       CTSAMSG_print(RACF_ERR_LIST_VALUE, msgs, NULL, dest,
                     "ACCESS", res_access );
       chk_rc = ESA_FATAL;
       goto exit ;
    }
  }

 /*
  *    Format parameters for assembler
  */

  if ( strlen(res_class)     +
       strlen(res_profile)   +
       strlen(res_desc_format) LE sizeof(res_desc)    )
    sprintf(res_desc,res_desc_format,
            res_profile, ( generic_flag ) ? "(G)" : "" ,
            res_class );
  else
    strcpy( res_desc, res_desc_format );

  BLOCK_STR(function, "RESCONN1")
  BLOCK_STR(class   , res_class)
  BLOCK_STR(profile , res_profile)
  BLOCK_STR(object  , res_object)
  BLOCK_STR(volume  , res_volume)

  if ( res_access NE NULL ) {
     if ( strlen(res_access) LE sizeof(access) )
        BLOCK_STR(access  , res_access )
     access_ptr = access;
  }

 /*
  *    Call assembler routine and handle return code
  */

  real_access[0]=NULL_CHAR;
  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function,class,profile,&generic_flag,
               object, access_ptr, real_access, volume);

  real_access[8]=NULL_CHAR;

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d Racf regular ace check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf resource check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)  {
              CTSAMSG_print(ERR_ACE_EXIST, msgs, NULL, dest,
                            res_desc, res_object );
              CTSAMSG_print(MSG_ACE_DETAILS, msgs, NULL, dest,
                            res_object, real_access, "");
          }
       }
       break;

    case 4:
       if (test EQ OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag) {
              CTSAMSG_print(ERR_ACE_NOT_EXIST, msgs, NULL, dest,
                            res_desc, res_object);
              if ( res_access NE NULL )
                CTSAMSG_print(MSG_ACE_DETAILS, msgs, NULL, dest,
                              res_object, res_access, "" );
              else
                CTSAMSG_print(MSG_ACE_DETAILS, msgs, NULL, dest,
                              res_object, ""  , "" );
          }
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "ACE", res_desc );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

 exit :;
  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_cond_ace                          *
 *                                                             *
 * DESCRIPTION    : Check RACF resource ace existance          *
 *                                                             *
 * INPUT          : res_class   - class                        *
 *                  res_profile - profile                      *
 *                  res_volume  - volume                       *
 *                  generic_flag- generic flag                 *
 *                  res_object  - user, group                  *
 *                  res_access  - access ( may be NULL )       *
 *                  res_wtype   - cond qulifier                *
 *                  res_wname   - cond name                    *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_cond_ace(char                       * res_class,
                          char                       * res_profile,
                          char                       * res_volume,
                          int                          generic_flag,
                          char                       * res_object,
                          char                       * res_access,
                          char                       * res_wtype,
                          char                       * res_wname,
                          OBJ_EXISTS_typ               test,
                          int                          msg_flag,
                          CTSAMSG_DEST_TABLE_rec_ptr   dest,
                          CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_cond_ace";
  char   *access_ptr = NULL;
  char   *chk_ptr;
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "res_class=%s res_profile=%s Object=%s Test=%d",
                   res_class, res_profile, res_object, test) ;
  if ( res_access )
    ESA_DIAG_printf(PLT_COMP_API_RACF,1, "access=%s", res_access );

  if ( res_wtype AND res_wname )
    ESA_DIAG_printf(PLT_COMP_API_RACF,1, "condition=%s=%s",
                    res_wtype, res_wname);

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *    Check that access parameter does not contain a list of values
  */

  if ( res_access )  {
    chk_ptr = strpbrk( res_access, VALUES_SEPARATOR_STR);
    if ( chk_ptr NE NULL ) {
       CTSAMSG_print(RACF_ERR_LIST_VALUE, msgs, NULL, dest,
                     "ACCESS", res_access );
       chk_rc = ESA_FATAL;
       goto exit ;
    }
  }

  chk_ptr = strpbrk(res_wname, VALUES_SEPARATOR_STR);
  if ( chk_ptr NE NULL ) {
      CTSAMSG_print(RACF_ERR_LIST_VALUE, msgs, NULL, dest,
                    res_wtype, res_wname );
      chk_rc = ESA_FATAL;
      goto exit ;
  }

 /*
  *    Format parameters for assembler
  */

  if ( strlen(res_class)     +
       strlen(res_profile)   +
       strlen(res_desc_format) LE sizeof(res_desc)    )
    sprintf(res_desc,res_desc_format,
            res_profile, ( generic_flag ) ? "(G)" : "" ,
            res_class );
  else
    strcpy( res_desc, res_desc_format );

  if ( strlen(res_wtype)+strlen(res_wname)+strlen(when_desc_format) LE
       sizeof(when_desc)    )
     sprintf(when_desc,when_desc_format, res_wtype, res_wname);
  else
    strcpy( when_desc, when_desc_format );

  BLOCK_STR(function  , "RESCONN2")
  BLOCK_STR(class     , res_class)
  BLOCK_STR(profile   , res_profile)
  BLOCK_STR(object    , res_object)
  BLOCK_STR(volume    , res_volume)
  BLOCK_STR(when_type , res_wtype+5 )      /* WHEN.qualifier */
  BLOCK_STR(when_name , res_wname   )

  if ( res_access NE NULL ) {
     if ( strlen(res_access) LE sizeof(access) )
        BLOCK_STR(access  , res_access )
     access_ptr = access;
  }

 /*
  *    Call assembler routine and handle return code
  */

  real_access[0]=NULL_CHAR;
  /* SAS2IBMT
  rc = ctsfrch(&dbglvl, &racf_rc, &racf_reason, &extr_rc,            */
  rc = (*(ASM_RTN_TYP *)&ctsfrch)                         /* SAS2IBMT */
              (&dbglvl, &racf_rc, &racf_reason, &extr_rc,
               function, class, profile, &generic_flag,
               object, access_ptr, when_type, when_name,real_access,
               volume );

  real_access[8]=NULL_CHAR;

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d Racf regular ace check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "racf_rc=%d-%d-%d racf resource check rc=%d",
                   racf_rc, racf_reason, extr_rc, rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)  {
              CTSAMSG_print(ERR_ACE_EXIST, msgs, NULL, dest,
                            res_desc, res_object );
              CTSAMSG_print(MSG_ACE_DETAILS, msgs, NULL, dest,
                            res_object, real_access, when_desc);
          }
       }
       break;

    case 4:
       if (test EQ OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag) {
              CTSAMSG_print(ERR_ACE_NOT_EXIST, msgs, NULL, dest,
                            res_desc, res_object);
              if ( res_access NE NULL )
                CTSAMSG_print(MSG_ACE_DETAILS, msgs, NULL, dest,
                              res_object, res_access, when_desc );
              else
                CTSAMSG_print(MSG_ACE_DETAILS, msgs, NULL, dest,
                              res_object, ""  , when_desc );
          }
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "ACE", res_desc );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      racf_rc, racf_reason, extr_rc, component);
       break;
  }

 /*
  *    Finish
  */

 exit :;
  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : RACF_chk_res_class                         *
 *                                                             *
 * DESCRIPTION    : Check RACF res class existance             *
 *                                                             *
 * INPUT          : rcls     - Resource class                  *
 *                  test     - Check type - EXIST, NOEXIST     *
 *                  msg_flag - Issue existance error message   *
 *                  dest     - Vector of error msg dests       *
 *                  msgs     - Error messages buffer           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *                  ESA_OK   - Test OK                         *
 *                  ESA_ERR  - Test FAILED                     *
 *                  ESA_FATAL- Intrenal Error                  *
 *                                                             *
 **************************************************************/
 ESA_RC RACF_chk_res_class(char                  * rcls,
                      OBJ_EXISTS_typ               test,
                      int                          msg_flag,
                      CTSAMSG_DEST_TABLE_rec_ptr   dest,
                      CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  static char func[]="RACF_chk_res_class";
  char            mode[25];
  char            cdt_entry[10];
  ESA_RC chk_rc = ESA_OK;
  ESA_RC rc;

 /*
  *   Initialize
  */

  ESA_DIAG_enter(PLT_COMP_API_RACF,1,func);

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "Res.class=%s Test=%d", rcls, test);

  dbglvl = ESA_DIAG_get_debug_level(PLT_COMP_API_RACF);

 /*
  *   Check resource class existance
  */

  BLOCK_STR(mode,      "CHK-ENTRY-INFO");
  BLOCK_STR(cdt_entry, rcls);

  if (strcmp(rcls, "DATASET") NE 0 )
     /* SAS2IBMT
     rc = ctsfcdt (mode, &dbglvl, cdt_entry);                        */
     rc = (*(ASM_RTN_TYP *)&ctsfcdt)                      /* SAS2IBMT */
                  (mode, &dbglvl, cdt_entry);
  else
     rc = ESA_OK;

 /*
  *   Examine rc
  */

  ESA_DIAG_printf(PLT_COMP_API_RACF,1,
                  "Res class check rc=%d", rc);

  switch (rc) {

    case 0:
       if (test NE OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print(ERR_DUP_RES_CLASS, msgs, NULL, dest, rcls);
       }
       break;

    case 20:
       if (test EQ OBJ_EXIST) {
          chk_rc = ESA_ERR;
          if (msg_flag)
             CTSAMSG_print(ERR_NO_RES_CLASS, msgs, NULL, dest, rcls);
       }
       break;

    default:
       chk_rc = ESA_FATAL;
       CTSAMSG_print( RACF_FAILED_EXAMINE, msgs, NULL, dest,
                      "Resource Type", rcls );
       CTSAMSG_print( RACF_EXTRACTOR_ERR_RC, msgs, NULL, dest,
                      rc, rc , rc, component);
       break;
  }

 /*
  *    Finish
  */

  ESA_DIAG_exit(PLT_COMP_API_RACF,1,func,chk_rc );
  return chk_rc;

 }

