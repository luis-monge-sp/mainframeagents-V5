 /**************************************************************
 *                                                             *
 * Title            : Service TSS  functions                   *
 *                                                             *
 * File Name        : ctstsrv                                  *
 *                                                             *
 * Author           : Alexander Shvartsman                     *
 *                                                             *
 * Creation Date    : 16/06/96                                 *
 *                                                             *
 * Description      : TSS  service functions                   *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------  -------------------------------- *
 * BS2316   Alex     24/11/97 Illegal simple list processing   *
 * WS2324   Alex     25/02/98 OPTIME field support             *
 * PS0388   AlexS    04/10/99 TSS 5.1 Support                  *
 * BS2432   AlexS    13/09/00 Supress "acid does not exist"    *
 *                            messages                         *
 * PS0483   RamiK    30/10/01 update func to add quotes when   *
 *                            string contains comma            *
 * ws2483   RamiK    18/06/02 add support for extended suspend *
 * BS2584   Yonatan  05/02/03 fix PS0483, to add quotes only   *
 *                            for the NAME keyword.            *
 * BS2675   AmirH    04/05/04 Support EXPIRED string in TSS    *
 *                            DATE field (For TSS 5.3)         *
 * IS0358   YoniMa   17/08/06 memory leak.(BS2698)             *
 * WS10009  MeirS    18/10/07 Support RU_LOCKED & RU_SUSPENDED.*
 * IS10091  NuritY   06/06/13 ParentContainer for accounts and *
 *                            Groups + dynamic tsscfile records*
 *                            table (WS10034+WS10034A+WS10036) *
 * IS10092  NuritY   10/06/13 IS10077 enhancements:            *
 *                            1. Add support for list element  *
 *                               conversion, list customized   *
 *                               sort and list from/to         *
 *                               subfields compare.            *
 *                            2. Support tss commands return   *
 *                               codes.                        *
 *                            3. Support connection between    *
 *                               TSS commands.                 *
 * IS10020  AvnerL   01/05/14 Do not use NOPW in TSS AddUser   *
 * IS10136  AvnerL   11/10/15 Fix disable when locked with IIQ *
 * SAS2IBMT SeligT   12/07/16 SAS/C to IBM C Conversion Project*
 * IS10091A NuritY   15/09/16 Handle ParentContainerName       *
 *                            (moved from TSS_do_users_list in *
 *                            CTSTGUS).                        *
 * IS10147A SeligT   10/07/17 Add support for password phrase  *
 * BS10083  AvnerL   21/03/18 S0C4 at Sync with empty container*
 * IS10173  KailasP  25/04/18 Ignore field if '3' or '/'       *
 * BS10089  SeligT   06/06/18 DFLTGRP in Provisioning Plan     *
 *                            Causes Account Creation Problem  *
 * IS10183  ThomaS   12/05/21 Don't print password in clear    *
 * IS10184  NuritY   29/12/21 Improve scripts performance      *
 *                            change a long-named rtn to static*
 * WS10082  AvnerL   18/09/23 ADDINFO_VAL_LEN to 16K if needed *
 * WS10082N NuritY   12/11/23 support new addinfo structure.   *
 ***************************************************************/
 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDIO
 #include   STDLIB
 #include   STRING
 /* #include   LCLIB                                         SAS2IBMT */

 /*
  *   ESA include files
  */

 #include ESA_DIAG
 #include ESA_CTSAMSG
 #include ESA_API
 #include ESA_API_CODES

 /*
  *   MVS include files
  */

 #include MVS_COMP
 #include MVS_OS_MVS

 #include MVS_ONLINE_INTERCEPTOR

 #include API_ADDINFO
 #include API_DATES

 /*
  *   TSS include files
  */

 #include TSS
 #include TSS_CODES

 static char component[] = "CTSTSRV";

/*
 *    macros
 */

 #define GET_ADI_PARAM(kwd)                             \
                                                        \
  /*                                                    \
   *  Get key value from get-addinfo                    \
   */                                                   \
                                                        \
   get_pair=ADDINFO_search( (kwd),                      \
            TSS_ADDINFO_KWD_LEN,                        \
            get_addinfo->pair, get_addinfo->num_pairs); \
   if ( get_pair EQ NULL ) {                            \
     sprintf(internal2_msg_buf,                         \
             "parameter %s not found",  kwd );          \
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,     \
        "CTSTSRV", func, internal2_msg_buf,             \
        8, __LINE__);                                   \
     OS_MVS_btrace();                                   \
     rc = ESA_FATAL;                                    \
     goto exit;                                         \
   }

 /*  IS10092 - start */
 /*
  *  Verify Related command
  *
  *  rcn - related command number
  *  li - varibale for index
  *  ok - related command return code:
  *     values returned in ok:
  *     0 - related command was not executed or failed.
  *     1 - no related command number, or related command
  *         was exdcuted successfully.
  *     2 - related command was not found.
  */
 #define VERIFY_RELATED_COMMAND(rcn, li, ok)                    \
                                                                \
  /*                                                            \
   *   Look for the related command (command with original      \
   *   number equal to the related_number in the current        \
   *   command.                                                 \
   *   The loop stops when the command is found (or, when       \
   *   no command has the original number).                     \
   *   When the command is found, i is the index of the         \
   *   command entry.                                           \
   */                                                           \
  if ((rcn) GT 0)                                               \
  {                                                             \
    for ((li)=0; (li) LT cmd_handle->used_entries AND           \
                 cmds_buff[(li)].org_cmd NE rel_cmd; (li)++)    \
    { }                                                         \
  }                                                             \
                                                                \
  /*                                                            \
   *   Related command is OK when:                              \
   *   - The current command does not point to a related        \
   *     command                                                \
   *                  OR                                        \
   *   - The related command pointed by the current command     \
   *     was found, and was executed successfully.              \
   */                                                           \
  if ((rcn) EQ 0           OR                                   \
       ((rcn) GT 0 AND                                          \
        (li) LT cmd_handle->used_entries AND                    \
        cmds_buff[(li)].used EQ TSS_CMD_USED_OK) )              \
    (ok) = 1;                                                   \
  else                                                          \
    if ((rcn) GT 0 AND                                          \
        (li) LT cmd_handle->used_entries AND                    \
        cmds_buff[(li)].used EQ TSS_CMD_USED_OK)                \
    (ok) = 2;                                                   \
    else                                                        \
      (ok) = 0;
 /*  IS10092 - end   */
/*
 *  Prototype for special sort list function
 */

 typedef ESA_RC TSS_SORT_LIST_typ(ESA_DIAG_COMP_typ          comp,
                                  ONE_FIELD_rec_ptr          lst_pair,
                                  CTSAMSG_DEST_TABLE_rec_ptr dest,
                                  CTSAMSG_HANDLE_rec_ptr     msgs);

 typedef TSS_SORT_LIST_typ *TSS_SORT_LIST_ptr;

 /* IS10092 - start */
 typedef ESA_RC TSS_SORT_LISTFIELD_typ(ESA_DIAG_COMP_typ     comp,
                                  TSS_LST_FIELD_typ         *lst_handle,
                                  CTSAMSG_DEST_TABLE_rec_ptr  dest,
                                  CTSAMSG_HANDLE_rec_ptr      msgs);

 typedef TSS_SORT_LISTFIELD_typ *TSS_SORT_LISTFIELD_ptr;

 typedef char * TSS_CONV_LISTFIELD_typ(ESA_DIAG_COMP_typ      comp,
                                  TSS_LST_DATA_typ           *entry,
                                  char                       *field_val,
                                  int                         field_num,
                                  CTSAMSG_DEST_TABLE_rec_ptr  dest,
                                  CTSAMSG_HANDLE_rec_ptr      msgs);

 typedef TSS_CONV_LISTFIELD_typ *TSS_CONV_LISTFIELD_ptr;
 /* IS10092 - end */

 /*
  *  Internal functions
  */

 static ESA_RC TSS_set_resumes(ESA_DIAG_COMP_typ comp,
                      ADDINFO_rec_ptr            get_addinfo,
                      ADDINFO_rec_ptr            ess_addinfo,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs);

 static ESA_RC TSS_add_resumes_field (ESA_DIAG_COMP_typ    comp,
                                TSS_CMD_typ                cmd,
                                char                     * cmd_buf,
                                ADDINFO_rec_ptr            addinfo,
                                CTSAMSG_DEST_TABLE_rec_ptr dest,
                                CTSAMSG_HANDLE_rec_ptr     msgs);

 static char * TSS_convert_addinfo_type(ADDINFO_KWD_typ addinfo_typ);

 static void   TSS_check_quotes(char  *v1, char   *v2 );

 /* BS2584 */
 static void   TSS_do_quotes(char  *v1, char   *v2 );

 static TSS_RTT_rec_typ * TSS_get_field_desc(
                           ESA_DIAG_COMP_typ          comp,
                           char                      *kwd,
                           TSS_RTT_rec_typ            rtt_table[1],
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs);

 static ESA_RC TSS_aux_create(ESA_DIAG_COMP_typ     comp,
                       TSS_ADMIN_rec_typ          * admin,
                       char                       * acid,
                       char                       * acid_type,
                       char                       * parent_acid,
                       char                       * parent_oe_type,
                       char                       * cmd,
                       CTSAMSG_DEST_TABLE_rec_ptr   dest,
                       CTSAMSG_HANDLE_rec_ptr       msgs);

 static void TSS_sort_cmd(ESA_DIAG_COMP_typ     comp,
                          TSS_CMD_HANDLE_typ   *cmd_handle);

 static int  TSS_cmd_compare (const void * cmd1,
                              const void * cmd2);

 static int TSS_lst_compare2 (const void * entry1,
                              const void * entry2);

 static char * my_strtok(char         *  sptr,
                         char         *  charset,
                         void         ** handle,
                         char         *  result);

 static ESA_RC TSS_realloc_cmd_buffer (ESA_DIAG_COMP_typ    comp,
                               TSS_CMD_HANDLE_typ         * cmd_handle,
                               CTSAMSG_DEST_TABLE_rec_ptr   dest,
                               CTSAMSG_HANDLE_rec_ptr       msgs);

 static ESA_RC TSS_separate_list(ESA_DIAG_COMP_typ           comp,
                         TSS_LST_FIELD_typ          *lst_handle,
                         char                       *value_in,
           /* IS10092 */ TSS_CONV_LISTFIELD_ptr      field_conv_func,
                         CTSAMSG_DEST_TABLE_rec_ptr  dest,
                         CTSAMSG_HANDLE_rec_ptr      msgs);

 static void TSS_sort_list(ESA_DIAG_COMP_typ            comp,
                           int                          key,
                           TSS_LST_FIELD_typ          * lst_handle,
                           CTSAMSG_DEST_TABLE_rec_ptr   dest,
                           CTSAMSG_HANDLE_rec_ptr       msgs);

 static ESA_RC TSS_sort_lst2(ESA_DIAG_COMP_typ            comp,
                             ONE_FIELD_rec_ptr            lst_pair,
                             CTSAMSG_DEST_TABLE_rec_ptr   dest,
                             CTSAMSG_HANDLE_rec_ptr       msgs);

 static int TSS_lst_compare (const void * lst1,
                             const void * lst2);

 static int TSS_compare_subfields(ESA_DIAG_COMP_typ    comp,
                                  int                  subf_cnt,
                                  TSS_LST_DATA_typ   * tss_lst1,
                                  TSS_LST_DATA_typ   * tss_lst2);

 /* IS10092 - start  */
 static int TSS_compare_fromto_subfields(ESA_DIAG_COMP_typ    comp,
                                  int                  from_subfield,
                                  int                  to_subfield,
                                  int                  do_strpblnk,
                                  TSS_LST_DATA_typ   * tss_lst1,
                                  TSS_LST_DATA_typ   * tss_lst2);
 /* IS10092 - end    */

 /* WS10009                         start                     */
static int TSS_find_suspend_type(ESA_DIAG_COMP_typ     comp,
                                 ADDINFO_rec_typ     * get_addinfo,
                                 char                * suspend_type);
static ONE_FIELD_rec_ptr  TSS_find_RU_keys(
                                 ESA_DIAG_COMP_typ     comp,
                                 char                * ru_key,
                                 ADDINFO_rec_typ     * ess_addinfo);
 /* WS10009                         end                       */

 static ESA_RC TSS_set_lst(ESA_DIAG_COMP_typ   comp,
                    TSS_SET_ITEM_ptr           item_func,
      /* IS10092    TSS_SORT_LIST_ptr          sort_func,          */
      /* IS10092 */ TSS_SORT_LIST_ptr          parm_sort_func,
      /* IS10092 */ TSS_SORT_LISTFIELD_ptr     list_sort_func,
      /* IS10092 */ TSS_CONV_LISTFIELD_ptr     field_conv_func,
                    int                        key,
                    TSS_CMD_HANDLE_typ        *cmd_handle,
                    void                      *rttv,
                    ONE_FIELD_rec_ptr          ess_pair,
                    ADDINFO_rec_ptr            get_addinfo,
                    ADDINFO_rec_ptr            addinfo,
                    TSS_SUBF_typ               subfld_names_table[1],
                    CTSAMSG_DEST_TABLE_rec_ptr dest,
                    CTSAMSG_HANDLE_rec_ptr     msgs);

 static ESA_RC TSS_list_diff(ESA_DIAG_COMP_typ           comp,
                            TSS_SET_ITEM_ptr             item_func,
                            int                          key,
                            TSS_LST_FIELD_typ          * ess_lst_handle,
                            TSS_LST_FIELD_typ          * get_lst_handle,
                            char                       * kwd,
                            TSS_CMD_typ                  add_cmd,
                            TSS_CMD_typ                  del_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_facility_diff(ESA_DIAG_COMP_typ        comp,
                            TSS_SET_ITEM_ptr             item_func,
                            int                          key,
                            TSS_LST_FIELD_typ          * ess_lst_handle,
                            TSS_LST_FIELD_typ          * get_lst_handle,
                            char                       * kwd,
                            TSS_CMD_typ                  add_cmd,
                            TSS_CMD_typ                  del_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_set_simple_item(ESA_DIAG_COMP_typ      comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_set_admin_res_item(ESA_DIAG_COMP_typ   comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_set_sub_key_item(ESA_DIAG_COMP_typ     comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_set_sub_opt_item(ESA_DIAG_COMP_typ     comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_set_facility_item(ESA_DIAG_COMP_typ    comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_set_admin_rescls_item(ESA_DIAG_COMP_typ comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs);

static ESA_RC TSS_remove_lsca_scope(ESA_DIAG_COMP_typ    comp,
                           TSS_RTT_rec_typ               rtt_table[1],
                           char                        * acid,
                           ADDINFO_rec_typ             * addinfo,
                           ADMIN_PARAMS_rec_typ        * admin_params);

static ESA_RC TSS_update_empty_segments(ESA_DIAG_COMP_typ    comp,
                                  ADDINFO_rec_ptr            addinfo,
                                  CTSAMSG_DEST_TABLE_rec_ptr dest,
                                  CTSAMSG_HANDLE_rec_ptr     msgs);

/* IS10184 - added the static definition for his routine */
static ESA_RC TSS_hidepsw_and_issue_diag(
                      ESA_DIAG_COMP_typ            comp,
                      int                          diag_lvl,
                      char                       * buffer,
                      char                       * text);
/*
 *   Global static vars
 */

 static char internal2_msg_buf[200];
 static int  key_ind_lst_fld; /* See TSS_sort_list */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_alloc_cmd_handle                       *
 *                                                             *
 * DESCRIPTION    : Allocate command handle                    *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  max_entries   - max cmd entries            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : cmd_handle    - command handle             *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_alloc_cmd_handle (ESA_DIAG_COMP_typ      comp,
                        int                          max_entries,
                        TSS_CMD_HANDLE_typ        ** cmd_handle,
                        CTSAMSG_DEST_TABLE_rec_ptr   dest,
                        CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   ESA_RC                rc = ESA_OK;
   static char           func[]="TSS_alloc_cmd_handle";
   TSS_CMD_HANDLE_typ  * tmp_cmd_handle;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

  /*
   *  Allocate cmd handle structure
   */

   tmp_cmd_handle = (TSS_CMD_HANDLE_typ  *)malloc(
                                sizeof(TSS_CMD_HANDLE_typ));
   if (tmp_cmd_handle EQ NULL ) {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "cmd handle", sizeof(TSS_CMD_HANDLE_typ));
       rc = ESA_FATAL;
       OS_MVS_btrace();
       goto exit;
   }

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                  /*IS0358*/
        "malloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(TSS_CMD_HANDLE_typ),tmp_cmd_handle,
         __LINE__, __FILE__ );
   ESA_DIAG_printf(comp,3, "cmd handle ptr=%x", tmp_cmd_handle);

  /*
   *  Fill up the handle
   */

   memcpy(tmp_cmd_handle->eyecatcher, TSS_SA_AGENT_EYECATCHER,
          sizeof(tmp_cmd_handle->eyecatcher) );
  /*
   *  Allocate cmds buffer
   */

   ESA_DIAG_printf(comp,3, "cmd buffer entries=%d", max_entries);

   tmp_cmd_handle->max_expected_entries = max_entries;
   tmp_cmd_handle->tss_cmds = (TSS_CMD_SET_rec_typ  *)malloc(
                               sizeof(TSS_CMD_SET_rec_typ) *
                               tmp_cmd_handle->max_expected_entries);

   if (tmp_cmd_handle->tss_cmds EQ NULL ) {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "cmd buffer",
                  sizeof(TSS_CMD_SET_rec_typ) *
                  tmp_cmd_handle->allocated_entries );
       rc = ESA_FATAL;
       OS_MVS_btrace();
       ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,        /*IS0358*/
        "Free address (%x) (%d,%s)",
        tmp_cmd_handle, __LINE__, __FILE__ );
       free(tmp_cmd_handle);
       goto exit;
   }

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                  /*IS0358*/
    "malloc (%d) bytes at address (%x) (%d,%s)",
    sizeof(TSS_CMD_SET_rec_typ)*tmp_cmd_handle->max_expected_entries,
    tmp_cmd_handle->tss_cmds,
    __LINE__, __FILE__ );
   ESA_DIAG_printf(comp,3,
                   "allocated cmd buffer ptr=%x",
                   tmp_cmd_handle->tss_cmds);

   tmp_cmd_handle->allocated_entries = max_entries;
   tmp_cmd_handle->used_entries      = 0;

   *cmd_handle = tmp_cmd_handle;

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /*  TSS_alloc_cmd_handle  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_free_cmd_handle                        *
 *                                                             *
 * DESCRIPTION    : Free command handle                        *
 *                                                             *
 * INPUT          : cmd_handle    -  command handle            *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 void TSS_free_cmd_handle (ESA_DIAG_COMP_typ            comp,
                           TSS_CMD_HANDLE_typ        ** cmd_handle,
                           CTSAMSG_DEST_TABLE_rec_ptr   dest,
                           CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   static char         func[]="TSS_free_cmd_handle";
   TSS_CMD_HANDLE_typ *tmp_cmd_handle = *cmd_handle;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

  /*
   *  Free command buffer
   */

   ESA_DIAG_printf(comp,5, "cmd buffer ptr=%x",
                   tmp_cmd_handle->tss_cmds);

   if (tmp_cmd_handle->tss_cmds NE NULL )
     {                                               /*IS0358*/
       ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,        /*IS0358*/
        "Free address (%x) (%d,%s)",
        tmp_cmd_handle->tss_cmds, __LINE__, __FILE__ );
       free(tmp_cmd_handle->tss_cmds);
     }                                               /*IS0358*/

  /*
   *  Free command handle
   */

   ESA_DIAG_printf(comp,5, "cmd handle ptr=%x", tmp_cmd_handle);

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,        /*IS0358*/
     "Free address (%x) (%d,%s)",
     tmp_cmd_handle, __LINE__, __FILE__ );
   free(tmp_cmd_handle);
   *cmd_handle = NULL;

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, ESA_OK);

}      /* TSS_free_cmd_handle */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_realloc_cmd_buffer                     *
 *                                                             *
 * DESCRIPTION    : RE Allocate command buffer                 *
 *                                                             *
 * INPUT          : cmd_handle    -  cmd_handle                *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_realloc_cmd_buffer (ESA_DIAG_COMP_typ    comp,
                               TSS_CMD_HANDLE_typ         * cmd_handle,
                               CTSAMSG_DEST_TABLE_rec_ptr   dest,
                               CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   ESA_RC                 rc = ESA_OK;
   TSS_CMD_SET_rec_typ  * tmp;
   static char            func[]="TSS_realloc_cmd_buffer";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   if ( (cmd_handle->used_entries + 1) GE
         cmd_handle->allocated_entries  ) {

    /*
     *  RE Allocate cmds buffer
     */

     cmd_handle->allocated_entries +=
                                  cmd_handle->max_expected_entries;

     ESA_DIAG_printf(comp,3, "cmd buffer entries=%d",
                     cmd_handle->allocated_entries);

     tmp = cmd_handle->tss_cmds;
     ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
        "Before realloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(TSS_CMD_SET_rec_typ)*cmd_handle->allocated_entries,
         cmd_handle->tss_cmds, __LINE__, __FILE__ );
     cmd_handle->tss_cmds = (TSS_CMD_SET_rec_typ  *)realloc(
                                cmd_handle->tss_cmds,
                                sizeof(TSS_CMD_SET_rec_typ) *
                                cmd_handle->allocated_entries );

     if (cmd_handle->tss_cmds EQ NULL ) {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "cmd buffer",
                    sizeof(TSS_CMD_SET_rec_typ) *
                    cmd_handle->allocated_entries );
         rc = ESA_FATAL;
         OS_MVS_btrace();
         cmd_handle->tss_cmds = tmp;
         goto exit;
     }

     ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
        "After realloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(TSS_CMD_SET_rec_typ)*cmd_handle->allocated_entries,
         cmd_handle->tss_cmds, __LINE__, __FILE__ );
     ESA_DIAG_printf(comp, 5,
                   "re-allocated cmd buffer ptr=%x",
                    cmd_handle->tss_cmds);

   }         /* realloc cmd buffer */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc;

}     /* TSS_realloc_cmd_buffer */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_do_addinfo                             *
 *                                                             *
 * DESCRIPTION    : General addinfo processing program         *
 *                                                             *
 * INPUT          : ess_addinfo   -  addinfo from ess          *
 *                  get_addinfo   -  addinfo after get         *
 *                  cmd_handle    -  cmd gathering struct      *
 *                  rtt_table     -  rtt table                 *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - need, ESA_ERR - not need          *
 *                                                             *
 **************************************************************/
 ESA_RC TSS_do_addinfo (ESA_DIAG_COMP_typ          comp,
                        TSS_CMD_HANDLE_typ        *cmd_handle,
                        TSS_RTT_rec_typ            rtt_table[1],
                        ADDINFO_rec_ptr            ess_addinfo,
                        ADDINFO_rec_ptr            get_addinfo,
                        CTSAMSG_DEST_TABLE_rec_ptr dest,
                        CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC                    rc = ESA_OK;
   ESA_RC                    func_rc;
   static char               func[]="TSS_do_addinfo";
   int                       i;
   ONE_FIELD_rec_ptr         ess_pair;
   TSS_RTT_rec_typ          *kwd_desc;
   SET_VAR_FUNC_typ         *set_var_func_ptr;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   /* addinfo pairs */

   for (i=0; i LT ess_addinfo->num_pairs; i++ ) {

     /* WS10082N ess_pair = &(ess_addinfo->pair[i]);   */
     ess_pair = get_pair(&(ess_addinfo->pair[i])); /* WS10082N */

     if ( ess_pair->keyword[0] EQ TSS_ADI_SKIP)
         continue;

     ESA_DIAG_printf(comp,10,
     /* WS10082N */  "pair no. %3d: %d kwd=%s(%3d) val=%.*s(%3d)",
                     i+1, ess_pair->add_typ,
                     ess_pair->keyword,ess_pair->keylen,
     /* WS10082N */  (ess_pair->vallen GT 100 ? 100 : ess_pair->vallen),
                     ess_pair->value, ess_pair->vallen) ;
         /* WS10082N "pair no. %3d: %d kwd=%s(%3d) val=%s(%3d)",*/
         /* WS10082N ess_pair->value,ess_pair->vallen) ;  */
    /*
     * Locate keyword description
     */

     kwd_desc = TSS_get_field_desc(comp,
                                   ess_pair->keyword, rtt_table,
                                   dest, msgs);
     if (kwd_desc EQ NULL) {
       if ( ess_pair->add_typ EQ TYPE_1A  OR
            ess_pair->add_typ EQ TYPE_1B   )   {
         ESA_DIAG_printf(comp,5, "Keyword=%s not supporetd",
                         ess_pair->keyword);
         CTSAMSG_print(ERR_ADI_KEYWORD_NOSUPP, msgs, NULL, dest,
                       ess_pair->keyword);
       }
       continue;
     }

     if (kwd_desc->rtt_typ  EQ RTT_IGN)
       continue;

    /*
     * Obtain func ptr and call to appropriate function
     */

     set_var_func_ptr = kwd_desc->set_var_func_ptr;
     if (set_var_func_ptr EQ NULL) {
        /* WS10082N sprintf(internal2_msg_buf ,
           "Unable to determine function for set keyword %s.(value=%s)",
           ess_pair->keyword, ess_pair->value);   */
        sprintf(internal2_msg_buf ,                         /*WS10082N*/
          "Unable to determine function for set keyword %s",/*WS10082N*/
          ess_pair->keyword);                               /*WS10082N*/
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                      component,func, internal2_msg_buf,
                      16,__LINE__);
        OS_MVS_btrace();
        continue;
     }

     func_rc = (set_var_func_ptr) (comp, cmd_handle, rtt_table,
                                   kwd_desc, ess_pair, get_addinfo,
                                   ess_addinfo, dest, msgs) ;
     if (func_rc NE ESA_OK) {
        rc = ESA_FATAL;
        OS_MVS_btrace();
        goto exit;
     }

   }    /* addinfo pair loop */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc;

}    /* TSS_do_addinfo */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_field_desc                         *
 *                                                             *
 * DESCRIPTION    : Search keyword in rtt table                *
 *                                                             *
 * INPUT          : comp          -  diag component            *
 *                  kwd           -  required keyword          *
 *                  rtt_table     -  rtt table                 *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : NULL - kwd not found                       *
 *                                                             *
 **************************************************************/

 static TSS_RTT_rec_typ * TSS_get_field_desc(
                           ESA_DIAG_COMP_typ          comp,
                           char                      *kwd,
                           TSS_RTT_rec_typ            rtt_table[1],
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   static char               func[]="TSS_get_field_desc";
   int                       i=0;
   TSS_RTT_rec_typ          *kwd_desc = NULL;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 10, func);

   ESA_DIAG_printf(comp,10, "search kwd=%s", kwd );

   while ( rtt_table[i].addinfo_keyword ) {
     ESA_DIAG_printf(comp, 10,
                     "pair no. %3d: %d kwd=%s",
                     i+1, rtt_table[i].addinfo_typ,
                          rtt_table[i].addinfo_keyword);

     if (strcmp(rtt_table[i].addinfo_keyword, kwd ) EQ 0 ) {
       kwd_desc = &rtt_table[i];
       goto exit;
     }
     i++;
   }

   exit:;

   ESA_DIAG_printf(comp, 10, "Keyword=%s rtt_table ptr=%x",
                   kwd, kwd_desc);

   ESA_DIAG_exit(comp, 10, func, ESA_OK);

   return kwd_desc;

}     /* TSS_get_field_desc  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_put_cmd                                *
 *                                                             *
 * DESCRIPTION    : Put TSS command into the cmd buffer        *
 *                                                             *
 * INPUT          : cmd_handle     -    cmd handle             *
 *                  cmd            -    command                *
 *                  comp           -    diag component         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_put_cmd (ESA_DIAG_COMP_typ          comp,
                     TSS_CMD_HANDLE_typ        *cmd_handle,
                     TSS_CMD_SET_rec_typ       *cmd,
                     CTSAMSG_DEST_TABLE_rec_ptr dest,
                     CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC              rc = ESA_OK;
   static char         func[]="TSS_put_cmd";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   if (TSS_realloc_cmd_buffer(comp, cmd_handle, dest, msgs) NE ESA_OK )
      goto exit;

   cmd->org_cmd = cmd_handle->used_entries + 1;   /* IS10092 */
   memcpy((char *)&cmd_handle->tss_cmds[cmd_handle->used_entries],
          (char *) cmd, sizeof(TSS_CMD_SET_rec_typ) );
   cmd_handle->used_entries++;

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc;

}     /* TSS_put_cmd */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_simple_key                         *
 *                                                             *
 * DESCRIPTION    : Set TSS key                                *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/
 ESA_RC TSS_set_simple_key(ESA_DIAG_COMP_typ          comp,
                           TSS_CMD_HANDLE_typ        *cmd_handle,
                           void                      *rtt_table,
                           void                      *rttv,
                           ONE_FIELD_rec_ptr          ess_pair,
                           ADDINFO_rec_ptr            get_addinfo,
                           ADDINFO_rec_ptr            ess_addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_simple_key";
   char                *kwd;
   ONE_FIELD_rec_ptr    get_pair;
   /* WS10082N char                 value[TSS_ADDINFO_VAL_LEN+1]; */
   char                 value[ADDINFO_16K_VAL_LEN+1];     /* WS10082N */
   /* IS10092 TSS_CMD_SET_rec_typ cmd = { 0, "", 0 };             */
   TSS_CMD_SET_rec_typ  cmd = { 0, "", 0, 0 };           /* IS10092 */
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

  /*
   * This function allowed only addinfo_typ = TYPE_1A
   */

   if (rtt->addinfo_typ NE TYPE_1A)  {
     sprintf(internal2_msg_buf,
             "Invalid TSS parameter %s type=%s",
             rtt->addinfo_keyword,
             TSS_convert_addinfo_type(rtt->addinfo_typ) );
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   "CTSTSRV", func, internal2_msg_buf,
                   8, __LINE__);
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   GET_ADI_PARAM(rtt->addinfo_keyword)

  /*
   *  Determine what kind of keyword to use
   */

   if (rtt->tss_keyword EQ NULL)
     kwd = rtt->addinfo_keyword;
   else
     kwd = rtt->tss_keyword;

  /*
   *   Put simple key processing
   */

   if ( ess_pair->vallen GT 0 ) {          /* key ess  has the value */
     if ( get_pair->vallen GT 0 ) {        /* key get  has the value */
        if (rtt->rtt_prop EQ RTT_REPLACE ) /* Allowed REPLACE        */
           cmd.type = TSS_CMD_REPLACE;
        else {                             /* Not allowed REPLACE    */
           cmd.type = TSS_CMD_REMOVE;      /* Remove "get" value     */
           TSS_check_quotes(get_pair->value, value);
           rc=TSS_check_param_overflow(comp, cmd.param, kwd, value,
                                       TSS_LENGTH_UNDEFINED,
                                       MAX_TSS_PARAM_LEN,
                                       dest,msgs);
           if ( rc NE ESA_OK )
             goto exit;
           sprintf(cmd.param, "%s(%s)", kwd, value);
           rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
           if ( rc NE ESA_OK )
             goto exit;
           else
             cmd.type = TSS_CMD_ADD;
        }    /* Not allowed REPLACE    */
     }    /* key get  has the value */
     else    /* The key parameter has not value from get function   */
        cmd.type = TSS_CMD_ADD;
   } /* key ess    has the value */
   else {       /*   The key parameter has not value from ESS   */
      /*
       *  NAME field is mandatory. cannot be empty !
       */

       if ( strcmp(kwd, "NAME") EQ 0 ) {
          CTSAMSG_print(ERR_ADI_MANDATORY_EMPTY,msgs,NULL,dest,kwd);
          goto exit;
       }

       if ( get_pair->vallen GT 0 ) { /*The key has value from get*/
         cmd.type = TSS_CMD_REMOVE;
         TSS_check_quotes(get_pair->value, value);
         rc=TSS_check_param_overflow(comp, cmd.param, kwd, value,
                                     TSS_LENGTH_UNDEFINED,
                                     MAX_TSS_PARAM_LEN,
                                     dest,msgs);
         if ( rc NE ESA_OK )
           goto exit;
         sprintf(cmd.param, "%s(%s)", kwd, value);
         rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
       }
       goto exit;
   }

   TSS_check_quotes(ess_pair->value, value);

   /* BS2584 NAME keyword contains comma - wrap with quotas */
   if ( strcmp(kwd, "NAME") EQ 0 AND
        strchr(ess_pair->value, ',') NE NULL)
          TSS_do_quotes(ess_pair->value, value);

   rc = TSS_check_param_overflow(comp, cmd.param, kwd, value,
                                 TSS_LENGTH_UNDEFINED,
                                 MAX_TSS_PARAM_LEN,
                                 dest, msgs);
   if ( rc NE ESA_OK )
    goto exit;
   sprintf(cmd.param, "%s(%s)", kwd, value);

   rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}      /* TSS_set_simple_key */

 /* WS2324 */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_optime                             *
 *                                                             *
 * DESCRIPTION    : Set OPTIME parameter                       *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/
/******************** WS10082 *********************************
/* This routine is used for OPTIME attribute so no need in    *
 * long ->value handling.                                     *
 ******************** WS10082 *********************************/
 ESA_RC TSS_set_optime(ESA_DIAG_COMP_typ          comp,
                       TSS_CMD_HANDLE_typ        *cmd_handle,
                       void                      *rtt_table,
                       void                      *rttv,
                       ONE_FIELD_rec_ptr          ess_pair,
                       ADDINFO_rec_ptr            get_addinfo,
                       ADDINFO_rec_ptr            ess_addinfo,
                       CTSAMSG_DEST_TABLE_rec_ptr dest,
                       CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_optime";
   int                  errflg = FALSE;
   char                 hhmm[5];
   char                *val;
   ONE_FIELD_rec_ptr    get_pair;
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   GET_ADI_PARAM(rtt->addinfo_keyword)

  /*
   *   OPTIME fields checking
   */

   if ( ess_pair->vallen GT 0 ) {        /* key ess  has the value */
     val = ess_pair->value;
     if ( ess_pair->vallen NE 5 ) /* format HH:MM  */
       errflg = TRUE;
     else if ( *(val+2) NE ':')
       errflg = TRUE;
     else {
       sprintf(hhmm, "%.2s%.2s", val, val+3);
       ADDINFO_updval( hhmm, TSS_ADDINFO_VAL_LEN, ess_pair );
     }
   }

   if (NOT errflg) {
     if ( get_pair->vallen GT 0 ) { /* key get has the value */
       val = get_pair->value;
       if ( get_pair->vallen NE 5 ) /* format HH:MM  */
         errflg = TRUE;
       else if ( *(val+2) NE ':')
         errflg = TRUE;
       else {
         sprintf(hhmm, "%.2s%.2s", val, val+3);
         ADDINFO_updval( hhmm, TSS_ADDINFO_VAL_LEN, get_pair );
       }
     }
   }

   /** If any errors do not put command to stack **/

   if (errflg) {
     CTSAMSG_print(TSS_OPTIME_FORMAT_ERR, msgs, NULL, dest, val);
     rc = ESA_ERR;
   }
   else
     rc = TSS_set_simple_key(comp,cmd_handle,rtt_table,rttv,ess_pair,
                             get_addinfo, ess_addinfo, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}      /* TSS_set_optime */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_simple_flag                        *
 *                                                             *
 * DESCRIPTION    : Set TSS flag                               *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/
/******************** WS10082 *********************************
/* This routine is used for flag attributes, so no need in    *
 * long ->value handling.                                     *
 ******************** WS10082 *********************************/

 ESA_RC TSS_set_simple_flag(ESA_DIAG_COMP_typ          comp,
                            TSS_CMD_HANDLE_typ        *cmd_handle,
                            void                      *rtt_table,
                            void                      *rttv,
                            ONE_FIELD_rec_ptr          ess_pair,
                            ADDINFO_rec_ptr            get_addinfo,
                            ADDINFO_rec_ptr            ess_addinfo,
                            CTSAMSG_DEST_TABLE_rec_ptr dest,
                            CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_simple_flag";
   char                *kwd;
   ONE_FIELD_rec_ptr    get_pair;
   /* IS10092 TSS_CMD_SET_rec_typ cmd = { 0, "", 0 };             */
   TSS_CMD_SET_rec_typ  cmd = { 0, "", 0, 0 };            /* IS10092 */
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

  /*
   * This function allowed only addinfo_typ = TYPE_1A
   */

   if (rtt->addinfo_typ NE TYPE_1A)  {
     sprintf(internal2_msg_buf,
             "Invalid TSS parameter %s type=%s",
             rtt->addinfo_keyword,
             TSS_convert_addinfo_type(rtt->addinfo_typ) );
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   "CTSTSRV", func, internal2_msg_buf,
                   8, __LINE__);
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   GET_ADI_PARAM(rtt->addinfo_keyword)

  /*
   *  Necessary for removing segment's flag field
   *  see TSS_set_simple_segm program
   */

   if ( get_pair->vallen EQ 0 )
      /* WS10082N strcpy(get_pair->value, KWD_FLAG_OFF); */
     ADDINFO_updval( KWD_FLAG_OFF, TSS_ADDINFO_VAL_LEN,   /* WS10082N */
                     get_pair );                          /* WS10082N */
   if ( ess_pair->vallen EQ 0 )
      /* WS10082N strcpy(ess_pair->value, KWD_FLAG_OFF); */
     ADDINFO_updval( KWD_FLAG_OFF, TSS_ADDINFO_VAL_LEN,   /* WS10082N */
                     ess_pair );                          /* WS10082N */

  /*
   *  Determine what kind of keyword to use
   */

   if (rtt->tss_keyword EQ NULL)
     kwd = rtt->addinfo_keyword;
   else
     kwd = rtt->tss_keyword;

   ESA_DIAG_printf(comp,3, "kwd=%s ess_value=%s get_value=%s",
                   kwd, ess_pair->value, get_pair->value);
   /* WS10009 - debug start */
   ESA_DIAG_printf(comp,3, "addinfo_keyword<%s>, tss_keyword<%s>",
                   rtt->addinfo_keyword,rtt->tss_keyword);
   /* WS10009 - debug end   */

   if ( ( strcmp(ess_pair->value, KWD_FLAG_ON ) EQ 0 ) AND
        ( strcmp(get_pair->value, KWD_FLAG_OFF) EQ 0 )   ) {
       strcpy(cmd.param, kwd);
       cmd.type = TSS_CMD_ADD;
   }
   else if ( ( strcmp(ess_pair->value, KWD_FLAG_OFF) EQ 0 ) AND
             ( strcmp(get_pair->value, KWD_FLAG_ON ) EQ 0 )   ) {
       strcpy(cmd.param, kwd);
       cmd.type = TSS_CMD_REMOVE;
   }
   else    /*Nothing to do */
     goto exit;

   rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_simple_flag */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_simple_lst                         *
 *                                                             *
 * DESCRIPTION    : Set TSS list data                          *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_simple_lst(ESA_DIAG_COMP_typ          comp,
                           TSS_CMD_HANDLE_typ        *cmd_handle,
                           void                      *rtt_table,
                           void                      *rttv,
                           ONE_FIELD_rec_ptr          ess_pair,
                           ADDINFO_rec_ptr            get_addinfo,
                           ADDINFO_rec_ptr            addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc;
   static char          func[]="TSS_set_simple_lst";
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;
   TSS_SUBF_typ         subfld_names_table[] = {
         { NULL       , RTT_KEY, TSS_CMD_ADD,  TSS_CMD_REMOVE},
         { NULL       , RTT_KEY, 0            ,0               }  };

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /*  Determine addinfo keyword  */

   if (rtt->tss_keyword EQ NULL)
     subfld_names_table[0].subf_name = rtt->addinfo_keyword;
   else
     subfld_names_table[0].subf_name = rtt->tss_keyword;

   subfld_names_table[0].rtt_typ   = rtt->rtt_typ;

   rc = TSS_set_lst(comp, TSS_set_simple_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    0, cmd_handle, rttv, ess_pair, get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}      /* TSS_set_simple_lst */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_replaced_lst                       *
 *                                                             *
 * DESCRIPTION    : Set TSS list data                          *
 *                  with "REPLACE" option                      *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/
/*********************** WS10082 ******************************
 * This routine is called for the following attributes so no  *
 * need to handle long ->value :                              *
 * TSOOPT                                                     *
 * MCSAUTH                                                    *
 * MSCLOGC                                                    *
 * MCSMFRM                                                    *
 * MCSMON                                                     *
 * NETVOPCL                                                   *
 * NETVDMNS                                                   *
 *********************** WS10082 ******************************/

 ESA_RC TSS_set_replaced_lst(ESA_DIAG_COMP_typ        comp,
                           TSS_CMD_HANDLE_typ        *cmd_handle,
                           void                      *rtt_table,
                           void                      *rttv,
                           ONE_FIELD_rec_ptr          ess_pair,
                           ADDINFO_rec_ptr            get_addinfo,
                           ADDINFO_rec_ptr            addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_replaced_lst";
   ONE_FIELD_rec_ptr    get_pair;
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };        */
   TSS_CMD_SET_rec_typ  main_cmd = { 0, "", 0, 0 };     /* IS10092 */
   /* WS10082N char                 value[TSS_ADDINFO_VAL_LEN+1]; */
   char                 value[ADDINFO_16K_VAL_LEN+1];     /* WS10082N */
   char                *kwd;
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /*  Determine keyword name */

   if (rtt->tss_keyword EQ NULL)
     kwd = rtt->addinfo_keyword;
   else
     kwd = rtt->tss_keyword;

   GET_ADI_PARAM(rtt->addinfo_keyword)

   /* Create command type */

   if ( ( ess_pair->vallen GT 0 ) AND
        ( get_pair->vallen GT 0 )   ) {
      main_cmd.type = TSS_CMD_REPLACE;
      TSS_check_quotes(ess_pair->value, value);
   }
   else if ( ( ess_pair->vallen GT 0 ) AND
             ( get_pair->vallen EQ 0 )   ) {
      main_cmd.type = TSS_CMD_ADD;
      TSS_check_quotes(ess_pair->value, value);
   }
   else if ( ( ess_pair->vallen EQ 0 ) AND
             ( get_pair->vallen GT 0 )   ) {
      main_cmd.type = TSS_CMD_REMOVE;
      TSS_check_quotes(get_pair->value, value);
   }
   else if ( ( ess_pair->vallen EQ 0 ) AND
             ( get_pair->vallen EQ 0 )   )
      goto exit;

   /* Build command type */

   rc = TSS_check_param_overflow(comp, main_cmd.param, kwd, value,
                                 TSS_LENGTH_UNDEFINED,
                                 MAX_TSS_PARAM_LEN,
                                 dest,msgs);
   if ( rc NE ESA_OK )
    goto exit;
   ADDINFO_convert_list_sep( value,
                             ADDINFO_LIST_ENTRY, ADDINFO_LIST_SUBFIELD,
                             ',', ',' );

   sprintf(main_cmd.param, "%s(%s)", kwd, value);
   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}      /* TSS_set_replaced_lst */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_lst                                *
 *                                                             *
 * DESCRIPTION    : Set TSS set list fields (general)          *
 *                                                             *
 * Input          : comp           -  diag component           *
 *                  key            -  subfield index of key    *
 *                  cmd_handle     -  command handle           *
 *                  rttv           -  rtt field description    *
 *                  ess_pair       -  ess addinfo pair         *
 *                  get_addinfo    -  get addinfo area         *
 *                  subf_names     -  subfield names table     *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_set_lst(ESA_DIAG_COMP_typ   comp,
                    TSS_SET_ITEM_ptr           item_func,
      /* IS10092    TSS_SORT_LIST_ptr          sort_func,          */
      /* IS10092 */ TSS_SORT_LIST_ptr          parm_sort_func,
      /* IS10092 */ TSS_SORT_LISTFIELD_ptr     list_sort_func,
      /* IS10092 */ TSS_CONV_LISTFIELD_ptr     field_conv_func,
                    int                        key,
                    TSS_CMD_HANDLE_typ        *cmd_handle,
                    void                      *rttv,
                    ONE_FIELD_rec_ptr          ess_pair,
                    ADDINFO_rec_ptr            get_addinfo,
                    ADDINFO_rec_ptr            addinfo,
                    TSS_SUBF_typ               subfld_names_table[1],
                    CTSAMSG_DEST_TABLE_rec_ptr dest,
                    CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_lst";
   ONE_FIELD_rec_ptr    get_pair;
   TSS_LST_FIELD_typ   *ess_lst_handle;
   TSS_LST_FIELD_typ   *get_lst_handle;
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;
   char                *kwd;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   GET_ADI_PARAM(rtt->addinfo_keyword)

   /*** Allocate list's field handle ***/

   rc = TSS_alloc_lst_handle (comp, MAX_TSS_LST_ENTRIES,
                              &ess_lst_handle, dest, msgs );

   if ( rc NE ESA_OK )
      goto exit;

   rc = TSS_alloc_lst_handle (comp, MAX_TSS_LST_ENTRIES,
                              &get_lst_handle, dest, msgs );

   if ( rc NE ESA_OK )
      goto exit;

   /*** Sort lists entries before separate ***/

   /* IS10092 if ( sort_func ) * Special sort function *    */
   if ( parm_sort_func )       /* sort before list separation IS10092 */
   {
     key_ind_lst_fld = key;
     /* IS10092 rc = (sort_func)(comp, ess_pair, dest, msgs); */
     rc = (parm_sort_func)(comp, ess_pair, dest, msgs);  /* IS10092 */
     if ( rc NE ESA_OK )
        goto exit;
     /* IS10092 rc = (sort_func)(comp, get_pair, dest, msgs); */
     rc = (parm_sort_func)(comp, get_pair, dest, msgs);  /* IS10092 */
     if ( rc NE ESA_OK )
        goto exit;
   }

   /*** Separate ess_pair list value ***/

   /* IS10092 rc = TSS_separate_list(comp, ess_lst_handle,
                          ess_pair->value, dest, msgs);              */
   rc = TSS_separate_list(comp, ess_lst_handle,           /* IS10092 */
                          ess_pair->value,                /* IS10092 */
                          field_conv_func,                /* IS10092 */
                          dest, msgs);                    /* IS10092 */
   if ( rc NE ESA_OK )
      goto exit;

   /*** Separate get_pair list value ***/

   /* IS10092 rc = TSS_separate_list(comp, get_lst_handle,
                          get_pair->value, dest, msgs);              */
   rc = TSS_separate_list(comp, get_lst_handle,            /* IS10092 */
                          get_pair->value,                 /* IS10092 */
                          field_conv_func,                 /* IS10092 */
                          dest, msgs);                     /* IS10092 */
   if ( rc NE ESA_OK )
      goto exit;

   /*** Sort lists entries after separate ***/

   /* IS10092 - start */
   if ( list_sort_func )
   {
     rc = (list_sort_func)(comp, ess_lst_handle, dest, msgs);
     if (rc NE ESA_OK)
       goto exit;

     rc = (list_sort_func)(comp, get_lst_handle, dest, msgs);
     if (rc NE ESA_OK)
       goto exit;
   }
   /* IS10092 - end */

   /* IS10092 if ( NOT sort_func )                              */
   if ( NOT parm_sort_func AND NOT list_sort_func)    /* IS10092 */
   {
     TSS_sort_list(comp, key, ess_lst_handle, dest, msgs);
     TSS_sort_list(comp, key, get_lst_handle, dest, msgs);
   }

   if ( ESA_DIAG_get_debug_level(comp) GE 3 )
   {
       ESA_DIAG_printf (comp,0, "IIQ/IDN field=%s",
                        rtt->addinfo_keyword);
       TSS_lst_buf_dump(comp, ess_lst_handle);

       ESA_DIAG_printf (comp,0, "get field=%s",
                        rtt->addinfo_keyword);
       TSS_lst_buf_dump(comp, get_lst_handle);
   }

   /*** Determine what kind of keyword to use ***/

   if (rtt->tss_keyword EQ NULL)
     kwd = rtt->addinfo_keyword;
   else
     kwd = rtt->tss_keyword;

   /*** Create list differences ***/

   rc = TSS_list_diff(comp, item_func, key, ess_lst_handle,
                      get_lst_handle, (char *)kwd,  TSS_CMD_ADD,
                      TSS_CMD_REMOVE, cmd_handle, subfld_names_table,
                      dest, msgs );
  /*
   *    Finish
   */

   exit:;

   /*** Free list's handle ***/

   if (ess_lst_handle)
      TSS_free_lst_handle( comp, &ess_lst_handle, dest, msgs);

   if (get_lst_handle)
      TSS_free_lst_handle( comp, &get_lst_handle, dest, msgs);

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_lst */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_admin_res                          *
 *                                                             *
 * DESCRIPTION    : Set TSS admin resource                     *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_admin_res (ESA_DIAG_COMP_typ          comp,
                           TSS_CMD_HANDLE_typ        *cmd_handle,
                           void                      *rtt_table,
                           void                      *rttv,
                           ONE_FIELD_rec_ptr          ess_pair,
                           ADDINFO_rec_ptr            get_addinfo,
                           ADDINFO_rec_ptr            addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_admin_res";
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;
   static TSS_SUBF_typ  subfld_names_table[] = {
         { NULL       , RTT_KEY, TSS_CMD_ADMIN,  TSS_CMD_DEADMIN},
         { "ACCESS"   , RTT_KEY, TSS_CMD_ADMIN,  TSS_CMD_IGNORE  },
         { NULL       , RTT_KEY, 0            ,  0               }  };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   subfld_names_table[0].subf_name = rtt->tss_keyword;

   rc = TSS_set_lst(comp, TSS_set_admin_res_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    0, cmd_handle, rttv, ess_pair, get_addinfo, addinfo,
                    subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }     /* TSS_set_admin_res */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_simple_segm                        *
 *                                                             *
 * DESCRIPTION    : Set TSS segment fields                     *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_simple_segm(ESA_DIAG_COMP_typ      comp,
                        TSS_CMD_HANDLE_typ        *cmd_handle,
                        void                      *rtt_table,
                        void                      *rttv,
                        ONE_FIELD_rec_ptr          ess_pair,
                        ADDINFO_rec_ptr            get_addinfo,
                        ADDINFO_rec_ptr            ess_addinfo,
                        CTSAMSG_DEST_TABLE_rec_ptr dest,
                        CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC                   rc = ESA_OK;
   static char              func[]="TSS_set_simple_segm";
   ONE_FIELD_rec_ptr        get_pair = NULL;
   ONE_FIELD_rec_ptr        tmp_pair = NULL;
   int                      i;
   int                      found=0;
   char                   **segment_fields;
   TSS_RTT_rec_typ         *rtt_tbl = (TSS_RTT_rec_typ *)rtt_table;
   TSS_RTT_rec_typ         *rtt = (TSS_RTT_rec_typ *)rttv;
   TSS_RTT_rec_typ         *kwd_desc;
   TSS_SGM_rec_typ         *tss_segments;
   /*empty_pair may remain as var, if ->value has no value  WS10082A*/
   /*and if it is not passed as pair to a standard addinfo  WS10082N*/
   /*routine.                                               WS10082N*/
   ONE_FIELD_rec_typ        empty_pair;
   SET_VAR_FUNC_typ        *set_var_func_ptr;
   char                    *kwd;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   tss_segments = TSS_get_global_segments();

  /*
   *   Segment will be added. Exit
   */

   ESA_DIAG_printf(comp,3, "IIQ/IDN : kwd=%s value=%s",
                   ess_pair->keyword, ess_pair->value);

   if ( strcmp(ess_pair->value, KWD_FLAG_OFF) EQ 0)
      goto exit;

  /*
   *  Remove all existing segment related fields
   */

  /*
   *  Determine what kind of keyword to use
   */

   if (rtt->tss_keyword EQ NULL)
     kwd = rtt->addinfo_keyword;
   else
     kwd = rtt->tss_keyword;

  /*
   *   Search segment description fields
   */

   for (i=0; tss_segments[i].artificial_field; i++) {

     ESA_DIAG_printf(comp,5, "%d.kwd=%s segment field=%s",
                     i, kwd, tss_segments[i].artificial_field);

     if (strcmp(tss_segments[i].artificial_field, kwd ) EQ 0 ) {
       found=1;
       break;
     }
   }

   ESA_DIAG_printf(comp,5, "found=%d", found);

   if ( NOT found ) {
     sprintf(internal2_msg_buf,
             "Not found description for segment %s",  kwd );
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   "CTSTSRV", func, internal2_msg_buf,
                   8, __LINE__);
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   segment_fields = tss_segments[i].segment_fields;

  /*
   *  Segment related fields loop
   */

   for (i=0; segment_fields[i]; i++ ) {
      /*
       *  Sign up don't use this field any more
       *  for addinfo processing (see do_addinfo proc)
       */
       tmp_pair=ADDINFO_search( segment_fields[i],
                                TSS_ADDINFO_KWD_LEN,
                                ess_addinfo->pair,
                                ess_addinfo->num_pairs);
       if ( tmp_pair NE NULL )
          tmp_pair->keyword[0] = TSS_ADI_SKIP;

       get_pair=ADDINFO_search( segment_fields[i],
                                TSS_ADDINFO_KWD_LEN,
                                get_addinfo->pair,
                                get_addinfo->num_pairs);

       ESA_DIAG_printf(comp,5, "%d.segment field=%s get_pair=%x",
                       i, segment_fields[i], get_pair );

       if ( get_pair EQ NULL )
         continue;

      /*
       *  Get description for segment field
       */

       kwd_desc = TSS_get_field_desc(comp, segment_fields[i], rtt_tbl,
                                     dest, msgs);
       if (kwd_desc EQ NULL) {
         if ( get_pair->add_typ EQ TYPE_1A  OR
              get_pair->add_typ EQ TYPE_1B   )  {
            ESA_DIAG_printf(comp,3, "Keyword=%s not supporetd",
                            segment_fields[i]);
            CTSAMSG_print(ERR_ADI_KEYWORD_NOSUPP, msgs, NULL, dest,
                          segment_fields[i]);
         }
         continue;
       }

      /*
       *  If flag field = OFF. do nothing
       */

       ESA_DIAG_printf(comp,5, "%d.field=%s value=%s typ=%d",
                       i, get_pair->keyword, get_pair->value,
                       kwd_desc->rtt_typ );

       if ( (kwd_desc->rtt_typ EQ RTT_FLG )  AND       /* flag=N */
            (strcmp(get_pair->value, KWD_FLAG_OFF) EQ 0) )
           continue;

      /*
       *  Build empty pair for REMOVE obtained value
       */

       strcpy(empty_pair.keyword, kwd_desc->addinfo_keyword);
       empty_pair.keylen    = strlen(kwd_desc->addinfo_keyword);
       empty_pair.value[0]  = NULL_CHAR;
       empty_pair.vallen    = 0;
       empty_pair.add_typ   = kwd_desc->addinfo_typ;

      /*
       * Obtain func ptr and call to appropriate function
       */

       set_var_func_ptr = kwd_desc->set_var_func_ptr;

       ESA_DIAG_printf(comp,5, "%d.set_var_func ptr=%x",
                       i, set_var_func_ptr);

       if (set_var_func_ptr EQ NULL) {
          /* WS10082N sprintf(internal2_msg_buf ,
           "Unable to determine function for set keyword %s.(value=%s)",
           ess_pair->keyword, ess_pair->value);  */
          sprintf(internal2_msg_buf ,                       /*WS10082N*/
         "Unable to determine function for set keyword %s.",/*WS10082N*/
           empty_pair.keyword);                             /*WS10082N*/
          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                        component,func, internal2_msg_buf,
                        16,__LINE__);
          OS_MVS_btrace();
          continue;
       }

       rc = (set_var_func_ptr) (comp, cmd_handle, rtt_table,
                                kwd_desc, &empty_pair, get_addinfo,
                                ess_addinfo, dest, msgs) ;
       if (rc NE ESA_OK)
          goto exit;
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}      /* TSS_set_simple_segm */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_admin_simple                       *
 *                                                             *
 * DESCRIPTION    : Set TSS simple admin fields                *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_admin_simple (ESA_DIAG_COMP_typ       comp,
                           TSS_CMD_HANDLE_typ        *cmd_handle,
                           void                      *rtt_table,
                           void                      *rttv,
                           ONE_FIELD_rec_ptr          ess_pair,
                           ADDINFO_rec_ptr            get_addinfo,
                           ADDINFO_rec_ptr            addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_admin_simple";
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;
   static TSS_SUBF_typ  subfld_names_table[] = {
     { NULL,   RTT_KEY,   TSS_CMD_ADMIN,  TSS_CMD_DEADMIN },
     { NULL,   RTT_KEY,   0            ,  0             } };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /*  Determine addinfo keyword  */

   if (rtt->tss_keyword EQ NULL)
     subfld_names_table[0].subf_name = rtt->addinfo_keyword;
   else
     subfld_names_table[0].subf_name = rtt->tss_keyword;

   subfld_names_table[0].rtt_typ   = rtt->rtt_typ;

   rc = TSS_set_lst(comp, TSS_set_simple_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    0, cmd_handle, rttv, ess_pair, get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }    /* TSS_set_admin_scp */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_user_lst                           *
 *                                                             *
 * DESCRIPTION    : Set TSS user list field                    *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_user_lst (ESA_DIAG_COMP_typ          comp,
                           TSS_CMD_HANDLE_typ        *cmd_handle,
                           void                      *rtt_table,
                           void                      *rttv,
                           ONE_FIELD_rec_ptr          ess_pair,
                           ADDINFO_rec_ptr            get_addinfo,
                           ADDINFO_rec_ptr            addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr dest,
                           CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_user_lst";
   static TSS_SUBF_typ  subfld_names_table[] = {
     { "USER"     , RTT_SUB_KEY     , TSS_CMD_ADD,  TSS_CMD_REMOVE },
     { "RESOURCE" , RTT_SUB_KEY_LAST, TSS_CMD_ADD,  TSS_CMD_REMOVE },
     { NULL    , RTT_KEY, 0      ,    0               }  };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   rc = TSS_set_lst(comp, TSS_set_sub_key_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    1, cmd_handle, rttv, ess_pair, get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }    /* TSS_set_usr_lst */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_command                            *
 *                                                             *
 * DESCRIPTION    : Set TSS command, xcommand                  *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_command(ESA_DIAG_COMP_typ          comp,
                        TSS_CMD_HANDLE_typ        *cmd_handle,
                        void                      *rtt_table,
                        void                      *rttv,
                        ONE_FIELD_rec_ptr          ess_pair,
                        ADDINFO_rec_ptr            get_addinfo,
                        ADDINFO_rec_ptr            addinfo,
                        CTSAMSG_DEST_TABLE_rec_ptr dest,
                        CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_command";
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;
   static TSS_SUBF_typ  subfld_names_table[] = {
     { NULL       , RTT_SUB_KEY,      TSS_CMD_ADD,  TSS_CMD_REMOVE  },
     { "NAME"     , RTT_SUB_KEY_LASTB,TSS_CMD_ADD,  TSS_CMD_REMOVE  },
     { NULL       , RTT_KEY, 0                   ,  0            }  };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   subfld_names_table[0].subf_name = rtt->tss_keyword;

   rc = TSS_set_lst(comp, TSS_set_sub_key_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    1, cmd_handle, rttv, ess_pair, get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }     /* TSS_set_command */

 /*  IS10091 - TSS_set_facility is dropped because support for
  *         tss ealier than 5.1 was dropped.                       */

 /* WS2359 */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_fac51                              *
 *                                                             *
 * DESCRIPTION    : Set TSS facility  (TSS 5.1)                *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_fac51(ESA_DIAG_COMP_typ          comp,
                      TSS_CMD_HANDLE_typ        *cmd_handle,
                      void                      *rtt_table,
                      void                      *rttv,
                      ONE_FIELD_rec_ptr          ess_pair,
                      ADDINFO_rec_ptr            get_addinfo,
                      ADDINFO_rec_ptr            addinfo,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_fac51";
   static TSS_SUBF_typ  subfld_names_table[] = {
     { "FACILITY"          , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "ACTION"            , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "UNTIL"             , RTT_KEYT_FACILITY,
                                      TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "DAYS"              , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "TIMES"             , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "SYSID"             , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "CALENDAR"          , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { "TIMEREC"           , RTT_KEY, TSS_CMD_ADD,    TSS_CMD_REMOVE },
     { NULL                , RTT_KEY, 0      , 0            }  };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   rc = TSS_set_lst(comp,  TSS_set_facility_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    0, cmd_handle, rttv, ess_pair, get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}    /* TSS_set_facility */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_ltime                              *
 *                                                             *
 * DESCRIPTION    : Set TSS ltime                              *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_ltime(ESA_DIAG_COMP_typ          comp,
                      TSS_CMD_HANDLE_typ        *cmd_handle,
                      void                      *rtt_table,
                      void                      *rttv,
                      ONE_FIELD_rec_ptr          ess_pair,
                      ADDINFO_rec_ptr            get_addinfo,
                      ADDINFO_rec_ptr            addinfo,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_ltime";
   static TSS_SUBF_typ  subfld_names_table[] = {
     { "LTIME" ,   RTT_SUB_KEY_FRST, TSS_CMD_ADD,  TSS_CMD_REMOVE },
     { "FACILITY", RTT_SUB_KEY_OPT , TSS_CMD_ADD,  TSS_CMD_REMOVE },
     { NULL ,      RTT_KEY,          0          ,  0              }  };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   rc = TSS_set_lst(comp, TSS_set_sub_opt_item, TSS_sort_lst2,
                    NULL, NULL,                           /* IS10092 */
                    1,cmd_handle, rttv, ess_pair,get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }    /* TSS_set_ltime */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_admin_resclass                     *
 *                                                             *
 * DESCRIPTION    : Set TSS admin.resclass keyword             *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_admin_resclass(ESA_DIAG_COMP_typ comp,
                      TSS_CMD_HANDLE_typ        *cmd_handle,
                      void                      *rtt_table,
                      void                      *rttv,
                      ONE_FIELD_rec_ptr          ess_pair,
                      ADDINFO_rec_ptr            get_addinfo,
                      ADDINFO_rec_ptr            addinfo,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
 {


   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_admin_resclass";
   static TSS_SUBF_typ  subfld_names_table[] = {
         { NULL     , RTT_FLDN, TSS_CMD_ADMIN, TSS_CMD_DEADMIN },
         { NULL     , RTT_FLDV, TSS_CMD_ADMIN, TSS_CMD_DEADMIN },
         { "ACCESS" , RTT_KEY,  TSS_CMD_ADMIN, TSS_CMD_IGNORE  },
         { NULL     , RTT_KEY,  0            , 0               }  };
  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   rc = TSS_set_lst(comp, TSS_set_admin_rescls_item, NULL,
                    NULL, NULL,                           /* IS10092 */
                    0, cmd_handle, rttv, ess_pair, get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_admin_resclass */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_sitran                             *
 *                                                             *
 * DESCRIPTION    : Set TSS sitran                             *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_sitran(ESA_DIAG_COMP_typ          comp,
                       TSS_CMD_HANDLE_typ        *cmd_handle,
                       void                      *rtt_table,
                       void                      *rttv,
                       ONE_FIELD_rec_ptr          ess_pair,
                       ADDINFO_rec_ptr            get_addinfo,
                       ADDINFO_rec_ptr            addinfo,
                       CTSAMSG_DEST_TABLE_rec_ptr dest,
                       CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_sitran";
   static TSS_SUBF_typ  subfld_names_table[] = {
     {"TRANSACTION", RTT_SUB_KEY_FRST, TSS_CMD_ADD, TSS_CMD_REMOVE},
     {"FACILITY",    RTT_SUB_KEY_OPT,  TSS_CMD_ADD, TSS_CMD_REMOVE},
     {NULL,          RTT_KEY,          0          , 0          }  };

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   rc = TSS_set_lst(comp, TSS_set_sub_opt_item, TSS_sort_lst2,
                    NULL, NULL,                           /* IS10092 */
                    1,cmd_handle, rttv, ess_pair,get_addinfo,
                    addinfo, subfld_names_table, dest, msgs);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }    /* TSS_set_sitran */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_ConvertDateTSS2ESS                     *
 *                                                             *
 * DESCRIPTION    : Convert date from TSS format to ESS format *
 *                                                             *
 * INPUT          : comp        - diag component               *
 *                  tssdate     - tss date                     *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : tssdate     - ess date                     *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_ConvertDateTSS2ESS(ESA_DIAG_COMP_typ            comp,
                               char                       * tss_date,
                               CTSAMSG_DEST_TABLE_rec_ptr   dest,
                               CTSAMSG_HANDLE_rec_ptr       msgs)
 {

  /*
   *   Variables
   */

   ESA_RC                  rc = ESA_OK ;
   static  char            func[]="TSS_ConvertDateTSS2ESS";
   char                    ess_date[MAX_TSS_PARAM_LEN];
   char                    date_format[20];
   char                  * date_ptr;                        /* BS2675 */
   char                  * date_expire_flag = "09/09/99";

  /*
   *  Initialize
   */

   ESA_DIAG_enter(comp, 5, func );

   ESA_DIAG_printf(comp, 5, "tss date=(%s)", tss_date);

   strcpy( ess_date, tss_date);
   if (strlen(ess_date) EQ 0 )
     goto exit;

   /*
    * If date field contains EXPIRED string, send to ESS a flag date
    * (09/09/99) to indicate that the real experation date was not
    * specified by TSS.                                        BS2675
    */
   if ( strncmp(tss_date, TSS_DATE_EXPIRED, 7) EQ 0 ) { /* BS2675 */
      strcpy( date_format, TSS_DATE_FORMAT_DEFAULT);        /* BS2675 */
      date_ptr = date_expire_flag;                          /* BS2675 */
   }                                                        /* BS2675 */
   else { /* Normal date handling */                        /* BS2675 */
     /*
      *    Get TSS RSS Option "DATE" ( format of date )
      */
      rc = TSS_get_global_parameter(comp,  TSS_GLOBAL_DATE_FORMAT,
                                    date_format, dest, msgs);
      if ( rc NE ESA_OK ) {
         rc = ESA_OK;
         strcpy( date_format, TSS_DATE_FORMAT_DEFAULT);
      }
      date_ptr = tss_date;                                  /* BS2675 */
   }

   ESA_DIAG_printf(comp, 5, "date format=%s", date_format);

   rc = CTSCDAT_conv2ESS( comp, date_format,
                          date_ptr, ess_date, dest, msgs);  /* BS2675 */

   ESA_DIAG_printf(comp, 5, "rc=%d IIQ/IDN date=%s", rc, ess_date);

   if ( rc NE ESA_OK ) {
     rc = ESA_FATAL;
     goto exit;
   }

   strcpy(tss_date, ess_date);

  /*
   *  Finish
   */

   exit : ;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc ;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_expires                            *
 *                                                             *
 * DESCRIPTION    : Set TSS expires keyword                    *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_expires(ESA_DIAG_COMP_typ        comp,
                      TSS_CMD_HANDLE_typ        *cmd_handle,
                      void                      *rtt_table,
                      void                      *rttv,
                      ONE_FIELD_rec_ptr          ess_pair,
                      ADDINFO_rec_ptr            get_addinfo,
                      ADDINFO_rec_ptr            ess_addinfo,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_expires";
   TSS_RTT_rec_typ     *rtt = (TSS_RTT_rec_typ *)rttv;
   /* IS10092 TSS_CMD_SET_rec_typ cmd = { 0, "", 0 };           */
   TSS_CMD_SET_rec_typ  cmd = { 0, "", 0, 0 };          /* IS10092 */
   ONE_FIELD_rec_ptr    get_pair = NULL;
   char                 date_format[20];
   char                 ess_tss_date[20] ="" ;
   char                 get_tss_date[20] ="" ;
   char                *kwd;
   /* WS10082N char                 value[TSS_ADDINFO_VAL_LEN+1]; */
   char                 value[ADDINFO_16K_VAL_LEN+1];     /* WS10082N */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   kwd = rtt->tss_keyword;
   GET_ADI_PARAM(rtt->addinfo_keyword)

   ESA_DIAG_printf(comp,3, "kwd=%s ess_value=%s get_value=%s",
                   kwd, ess_pair->value, get_pair->value);

  /*
   *    Get TSS RSS Option "DATE" ( format of date )
   */

   rc = TSS_get_global_parameter(comp,  TSS_GLOBAL_DATE_FORMAT,
                                 date_format, dest, msgs);
   if ( rc NE ESA_OK ) {
      strcpy( date_format, TSS_DATE_FORMAT_DEFAULT);
      rc = ESA_OK;
   }

   ESA_DIAG_printf(comp, 3, "date format=%s", date_format);

  /*
   *   Convert date (ess_addinfo)
   */

   if ( ess_pair->vallen GT 0 ) {
     rc = TSS_ConvertDateESS2TSS( comp, date_format, ess_pair->value,
                                  ess_tss_date, dest, msgs );
     if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
     }

     ESA_DIAG_printf(comp, 3,
                     "date format=%s ess_date=%s ess_tss_date=%s",
                      date_format, ess_pair->value, ess_tss_date);

     ADDINFO_updval( ess_tss_date, TSS_ADDINFO_VAL_LEN, ess_pair );
   }

  /*
   *   Convert date (get_addinfo)
   */

   if ( get_pair->vallen GT 0 ) {
     rc = TSS_ConvertDateESS2TSS( comp, date_format, get_pair->value,
                                  get_tss_date, dest, msgs );
     if ( rc NE ESA_OK ) {
        rc = ESA_FATAL;
        goto exit;
     }

     ESA_DIAG_printf(comp, 3,
                     "date format=%s get_date=%s get_tss_date=%s",
                      date_format, get_pair->value, get_tss_date);

     ADDINFO_updval( get_tss_date, TSS_ADDINFO_VAL_LEN, get_pair );
   }

  /*
   *  Build commands
   */

   if ( ( ess_pair->vallen GT 0 ) AND
        ( get_pair->vallen GT 0 )   ) {
      cmd.type = TSS_CMD_REPLACE;
      TSS_check_quotes(ess_tss_date, value);
      rc=TSS_check_param_overflow(comp, cmd.param, kwd, value,
                                  TSS_LENGTH_UNDEFINED,
                                  MAX_TSS_PARAM_LEN,
                                  dest,msgs);
      if ( rc NE ESA_OK )
        goto exit;
      sprintf(cmd.param, "%s(%s)", kwd, ess_pair->value);
      rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
      if ( rc NE ESA_OK )
        goto exit;
   }
   else if ( ( ess_pair->vallen GT 0 ) AND
             ( get_pair->vallen EQ 0 )   ) {
      cmd.type = TSS_CMD_ADD;
      TSS_check_quotes(ess_tss_date, value);
      rc=TSS_check_param_overflow(comp, cmd.param, kwd, value,
                                  TSS_LENGTH_UNDEFINED,
                                  MAX_TSS_PARAM_LEN,
                                  dest, msgs);
      if ( rc NE ESA_OK )
        goto exit;
      sprintf(cmd.param, "%s(%s)", kwd, ess_pair->value);
      rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
      if ( rc NE ESA_OK )
        goto exit;
   }
   else if ( ( ess_pair->vallen EQ 0 ) AND
             ( get_pair->vallen GT 0 )   ) {
      cmd.type = TSS_CMD_REMOVE;
      TSS_check_quotes(get_tss_date, value);
      rc=TSS_check_param_overflow(comp, cmd.param, kwd, value,
                                  TSS_LENGTH_UNDEFINED,
                                  MAX_TSS_PARAM_LEN,
                                  dest, msgs);
      sprintf(cmd.param, "%s", kwd);
      rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
      if ( rc NE ESA_OK )
        goto exit;
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_expires */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_resumes                            *
 *                                                             *
 * DESCRIPTION    : Set TSS until keyword                      *
 *                  Only set converted dates for further work  *
 *                  by do_revoke_status program                *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_set_resumes(ESA_DIAG_COMP_typ comp,
                      ADDINFO_rec_ptr            get_addinfo,
                      ADDINFO_rec_ptr            ess_addinfo,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_set_resumes";
   ONE_FIELD_rec_ptr    get_pair = NULL;
   ONE_FIELD_rec_ptr    ess_pair = NULL;
   char                 date_format[20];
   char                 ess_tss_date[20] = "";
   char                 get_tss_date[20] = "";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

  /*
   *    Get TSS RSS Option "DATE" ( format of date )
   */

   rc = TSS_get_global_parameter(comp,  TSS_GLOBAL_DATE_FORMAT,
                                 date_format, dest, msgs);
   if ( rc NE ESA_OK ) {
      strcpy( date_format, TSS_DATE_FORMAT_DEFAULT);
      rc = ESA_OK;
   }

   ESA_DIAG_printf(comp, 3, "date format=%s", date_format);

   ess_pair=ADDINFO_search( "RESUMES",
                             TSS_ADDINFO_KWD_LEN,
                             ess_addinfo->pair,
                             ess_addinfo->num_pairs);

   get_pair=ADDINFO_search( "RESUMES",
                             TSS_ADDINFO_KWD_LEN,
                             get_addinfo->pair,
                             get_addinfo->num_pairs);

  /*
   *   Convert date (ess_addinfo)
   */

   if ( ess_pair NE NULL ) {
     if ( ess_pair->vallen GT 0 ) {
       rc = TSS_ConvertDateESS2TSS( comp, date_format, ess_pair->value,
                                    ess_tss_date, dest, msgs );
       if ( rc NE ESA_OK ) {
          rc = ESA_FATAL;
          goto exit;
       }

       ESA_DIAG_printf(comp, 3,
                       "date format=%s ess_date=%s ess_tss_date=%s",
                        date_format, ess_pair->value, ess_tss_date);

       ADDINFO_updval( ess_tss_date, TSS_ADDINFO_VAL_LEN, ess_pair );
     }
   }

  /*
   *   Convert date (get_addinfo)
   */

   if ( get_pair NE NULL ) {
     if ( get_pair->vallen GT 0 ) {
        rc = TSS_ConvertDateESS2TSS( comp, date_format, get_pair->value,
                                     get_tss_date, dest, msgs );
        if ( rc NE ESA_OK ) {
           rc = ESA_FATAL;
           goto exit;
        }

        ESA_DIAG_printf(comp, 4,
                        "date format=%s get_date=%s get_tss_date=%s",
                        date_format, get_pair->value, get_tss_date);

        ADDINFO_updval( get_tss_date, TSS_ADDINFO_VAL_LEN, get_pair );
     }
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_resumes */


 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_add_resumes_field                      *
 *                                                             *
 * DESCRIPTION    : Set Additional parameters related to       *
 *                  RESUMES field                              *
 *                                                             *
 * INPUT          : see func prototype                         *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_add_resumes_field (ESA_DIAG_COMP_typ    comp,
                                TSS_CMD_typ                cmd,
                                char                     * cmd_buf,
                                ADDINFO_rec_ptr            addinfo,
                                CTSAMSG_DEST_TABLE_rec_ptr dest,
                                CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_add_resumes_field";
   ONE_FIELD_rec_ptr    pair = NULL;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   pair=ADDINFO_search( "RESUMES",
                        TSS_ADDINFO_KWD_LEN,
                        addinfo->pair,
                        addinfo->num_pairs);
   if ( pair EQ NULL )
     goto exit;

   if ( pair->vallen EQ 0 )
     goto exit;

   if ( cmd EQ TSS_CMD_ADD) {
     strcat(cmd_buf, "UNTIL(");
     strcat(cmd_buf, pair->value);
     strcat(cmd_buf, ") ");
   }
   if ( cmd EQ TSS_CMD_REMOVE) {
     strcat(cmd_buf, "UNTIL ");
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_add_resumes_field   */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_do_cmd                                 *
 *                                                             *
 * DESCRIPTION    : Set TSS issue TSS commands                 *
 *                                                             *
 * INPUT          : acid        - object                       *
 *                  cmd_handle  - command handle               *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_do_cmd(ESA_DIAG_COMP_typ           comp,
                   char                      * acid,
                   OBJECT_TYPE_typ             onli_acid_type,
                   char                        onli_evnt_action,
                   TSS_CMD_HANDLE_typ        * cmd_handle,
                   ADMIN_PARAMS_rec_typ      * admin_params)
 {

   ESA_RC                     rc = ESA_OK;
   static char                func[]="TSS_do_cmd";
   CTSAMSG_DEST_TABLE_rec_ptr dest;
   CTSAMSG_HANDLE_rec_ptr     msgs;
   TSS_CMD_BUF_rec_typ        cmd = { 0, 0, "" };
   int                        i;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(comp,3, "ACID=%s", acid );

   if ( ESA_DIAG_get_debug_level(comp) GE 5 )
   {
       ESA_DIAG_printf (comp,0, "Cmd buffer before sort");
       TSS_cmd_buf_dump(comp, cmd_handle, acid);
   }

   TSS_sort_cmd(comp, cmd_handle);   /* Sort cmd buffer */

   if ( ESA_DIAG_get_debug_level(comp) GE 3 )
   {
       ESA_DIAG_printf (comp,0, "Cmd buffer after sort");
       TSS_cmd_buf_dump(comp, cmd_handle, acid);
   }

  /*
   *   Issuing commands
   */

   for (i=0; i LT cmd_handle->used_entries; i++)
   {
     /* IS10092 if ( NOT cmd_handle->tss_cmds[i].used) */
     if (cmd_handle->tss_cmds[i].used EQ TSS_CMD_NOT_USED) /* IS10092 */
     {
       sprintf(cmd.buffer, "%s(%s) %s",
               TSS_convert_cmd(cmd_handle->tss_cmds[i].type),
               acid,
               cmd_handle->tss_cmds[i].param);

       cmd.max_len = strlen(cmd.buffer);
       cmd.use_len = strlen(cmd.buffer);
       /* IS10092 cmd_handle->tss_cmds[i].used = 1;           */
       cmd_handle->tss_cmds[i].used = TSS_CMD_USED;   /* IS10092 */
       rc = TSS_issue_cmd(comp, &cmd, acid,
                          onli_acid_type, onli_evnt_action,
                          admin_params);
       /* IS10092 if ( rc NE ESA_OK )
          goto exit;                        */
       if ( rc EQ ESA_OK )                                 /* IS10092 */
         cmd_handle->tss_cmds[i].used = TSS_CMD_USED_OK;   /* IS10092 */
       else                                                /* IS10092 */
       {                                                   /* IS10092 */
         cmd_handle->tss_cmds[i].used = TSS_CMD_USED_FAILED; /*IS10092*/
         break;                                            /* IS10092 */
       }                                                   /* IS10092 */
     }
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_do_cmd */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_cmd_buf_dump                           *
 *                                                             *
 * DESCRIPTION    : Dump command buffer                        *
 *                                                             *
 * INPUT          : cmd_handle  - command handle               *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 void TSS_cmd_buf_dump(ESA_DIAG_COMP_typ     comp,
                       TSS_CMD_HANDLE_typ   *cmd_handle,
                       char                 *acid)
 {

   ESA_RC                       rcd= ESA_OK;         /* IS10183 */
   int                  i;
   static char          func[]="TSS_cmd_buf_dump";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 0, func);

   ESA_DIAG_printf(comp,0,
           "cmd handle: alloc entries=%d used=%d",
           cmd_handle->allocated_entries,
           cmd_handle->used_entries);

   for (i=0; i LT cmd_handle->used_entries; i++)  {
       ESA_DIAG_printf(comp,0,
      /* IS10092 "%3d %2d %s(%s) %s",               */
         /* IS10183
         "%3d %3d %2d %s(%s) %s",    /@ IS10092 @/
         */
         "%3d %3d %2d %s(%s)",       /* IS10183 */
         i,
         cmd_handle->tss_cmds[i].org_cmd, /* IS10092 */
         cmd_handle->tss_cmds[i].used,
         TSS_convert_cmd(cmd_handle->tss_cmds[i].type),
         acid);                           /* IS10183 */
         /* IS10183
         acid, cmd_handle->tss_cmds[i].param);
         */
         /* IS10183 - start */
         rcd = TSS_hidepsw_and_issue_diag(
                 comp,
                 0,
                 cmd_handle->tss_cmds[i].param,
                 "cmd param = ");

         if (rcd NE ESA_OK)
            ESA_DIAG_printf(comp, 0,"cmd param = <%s>",
                 cmd_handle->tss_cmds[i].param);
         /* IS10183 - end   */
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 0, func, ESA_OK);

}     /* TSS_cmd_buf_dump  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_lst_buf_dump                           *
 *                                                             *
 * DESCRIPTION    : Dump list buffer                           *
 *                                                             *
 * INPUT          : lst_handle  - command handle               *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 void TSS_lst_buf_dump(ESA_DIAG_COMP_typ    comp,
                       TSS_LST_FIELD_typ   *lst_handle)
 {

   int                  i;
   int                  j;
   static char          func[]="TSS_lst_buf_dump";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 0, func);

   ESA_DIAG_printf(comp,0,
           "lst handle: alloc entries=%d used=%d subfield cntr=%d",
           lst_handle->allocated_entries,
           lst_handle->used_entries,
           lst_handle->subf_cnt);

   for (i=0; i LT lst_handle->used_entries; i++) {
     for (j=0; j LT lst_handle->subf_cnt; j++) {
         ESA_DIAG_printf(comp,0, "%3d %3d %s",
                         i, j, lst_handle->lst_data[i].field[j]);
     }
     ESA_DIAG_printf(comp,0, "-----------");
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 0, func, ESA_OK);

}     /* TSS_lst_buf_dump  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_convert_cmd                            *
 *                                                             *
 * DESCRIPTION    : Convert cmd enum to string                 *
 *                                                             *
 * INPUT          : cmd_type    - command type                 *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : string cmd                                 *
 *                                                             *
 **************************************************************/

 char * TSS_convert_cmd (TSS_CMD_typ   cmd)
 {

     switch(cmd)  {
       case TSS_CMD_ADMIN   :   return("ADMIN");
       case TSS_CMD_DEADMIN :   return("DEADMIN");
       case TSS_CMD_ADD     :   return("ADD");
       case TSS_CMD_REMOVE  :   return("REMOVE");
       case TSS_CMD_REPLACE :   return("REPLACE");
       case TSS_CMD_PERMIT  :   return("PERMIT");
       case TSS_CMD_REVOKE  :   return("REVOKE");
       default              :   return("UNKNOWN");
     }
 }     /* TSS_convert_cmd  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_convert_addinfo_typ                    *
 *                                                             *
 * DESCRIPTION    : Convert addinfo enum to string             *
 *                                                             *
 * INPUT          : addinfo_type - addinfo type                *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static char * TSS_convert_addinfo_type(ADDINFO_KWD_typ addinfo_typ)
 {

     switch(addinfo_typ)  {
       case    TYPE_1A  :  return("TYPE_1A");
       case    TYPE_1B  :  return("TYPE_1B");
       case    TYPE_2A  :  return("TYPE_2A");
       case    TYPE_2B  :  return("TYPE_2B");
       default          :  return("UNKNOWN");
     }
 }       /* TSS_convert_addinfo_typ */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_convert_restype                        *
 *                                                             *
 * DESCRIPTION    : Convert restype                            *
 *                                                             *
 * INPUT          : ess_restype - resource type                *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : tss_restype (converted)                    *
 *                                                             *
 **************************************************************/

 char * TSS_convert_restype(char     * ess_restype)
 {

   static char  tss_restype[TSS_RESTYPE_NAME_LEN + 1];

   strcpy( tss_restype, ess_restype );

   if ( strcmp(tss_restype, "DATASET" ) EQ 0 )
      strcpy(tss_restype, "DSN" );

   return tss_restype;
 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_rtt_2_addinfo                          *
 *                                                             *
 * DESCRIPTION    : Convert cmd enum to string                 *
 *                                                             *
 * INPUT          : cmd_type    - command type                 *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_rtt_2_addinfo(ESA_DIAG_COMP_typ          comp,
                          TSS_RTT_rec_typ            rtt_table[1],
                          ADDINFO_rec_ptr            addinfo,
                          CTSAMSG_DEST_TABLE_rec_ptr dest,
                          CTSAMSG_HANDLE_rec_ptr     msgs)

 {

  /*
   *  Variables
   */

   ESA_RC      rc = ESA_OK;
   static char func[] = "TSS_rtt_2_addinfo";
   int         i=0;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   while ( rtt_table[i].addinfo_keyword ) {
     rc = ADDINFO_insert(rtt_table[i].addinfo_typ,
                         (char *)rtt_table[i].addinfo_keyword,
                         "", addinfo,
                         TSS_ADDINFO_KWD_LEN,
                         TSS_ADDINFO_VAL_LEN,
                         UNIQUE);
     ESA_DIAG_printf(comp,10,
                     "pair no. %3d: %d kwd=%s   rc=%d",
                     i+1, rtt_table[i].addinfo_typ,
                          rtt_table[i].addinfo_keyword, rc);

     if (rc NE ESA_OK) {
       sprintf(internal2_msg_buf,  "Insert parameter '%s' failed",
               rtt_table[i].addinfo_keyword);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     "CTSTSRV", func, internal2_msg_buf,
                     4, __LINE__);
       rc = ESA_FATAL;
       OS_MVS_btrace();
       goto exit;
     }
     i++;
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc;

}       /* TSS_rtt_2_addinfo */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_empty_flags                        *
 *                                                             *
 * DESCRIPTION    : Set empty flags vars to FLAG_OFF           *
 *                                                             *
 * INPUT          : addinfo     - addinfo ptr                  *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_empty_flags(ESA_DIAG_COMP_typ          comp,
                            ADDINFO_rec_ptr            addinfo,
                            CTSAMSG_DEST_TABLE_rec_ptr dest,
                            CTSAMSG_HANDLE_rec_ptr     msgs)
 {

  /*
   *  Variables
   */

   ESA_RC             rc = ESA_OK;
   static char        func[] = "TSS_set_empty_flags";
   TSS_RTT_rec_typ  * rtt_table;
   ONE_FIELD_rec_ptr  tmp_pair = NULL;
   int                i=0;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   rtt_table    = TSS_get_global_rtt();

   while ( rtt_table[i].addinfo_keyword ) {
     if  ( rtt_table[i].rtt_typ  EQ RTT_FLG ) {
       tmp_pair=ADDINFO_search( rtt_table[i].addinfo_keyword,
                                TSS_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);
       if ( tmp_pair NE NULL ) {
         if (tmp_pair->vallen EQ 0 ) {
           if (rtt_table[i].deflt)
             ADDINFO_updval(rtt_table[i].deflt,
                            TSS_ADDINFO_VAL_LEN, tmp_pair);
           else {
               sprintf(internal2_msg_buf ,
                       "Missing default value for flag field '%s'",
                        rtt_table[i].addinfo_keyword);
               CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                             component,func, internal2_msg_buf,
                             4,__LINE__);
               OS_MVS_btrace();
           }
         }    /* empty flag field */
       }    /* Field found in addinfo area */
     }    /* Flag field */
     i++;
   }

   TSS_update_empty_segments(comp, addinfo, dest, msgs); /* PS0388 */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc;

}       /* TSS_set_empty_flags */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_do_create                              *
 *                                                             *
 * DESCRIPTION    : Build and issue "CREATE" command           *
 *                                                             *
 * INPUT          : comp        - diag component               *
 *                  cmd_handle  - command handle               *
 *                  acid        - object ID                    *
 *                  parent      - parent                       *
 *                  acid_type   - type of acid                 *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_do_create(ESA_DIAG_COMP_typ            comp,
                      TSS_CMD_HANDLE_typ         * cmd_handle,
      /*IS10020*/     USER_PARAMS_rec_typ        * essu_params,
                      char                       * acid,
                      char                       * parent_acid,
                      char                       * acid_type,
                      OBJECT_TYPE_typ              onli_acid_type,
                      ADMIN_PARAMS_rec_typ       * admin_params,
                      ERR_STRUCT_rec_typ         * err)
 {

   ESA_RC                       rc = ESA_OK;
   ESA_RC                       rcd= ESA_OK;         /* IS10183 */
   static char                  func[]="TSS_do_create";
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;
   TSS_CMD_BUF_rec_typ          cmd = { 0, 0, "" };
   TSS_ADMIN_rec_typ            admin;
   char                         parent_oe_type[TSS_ACID_TYPE_LEN];
   TSS_PARAMS_rec_typ * params_ptr = NULL;                  /*IS10020*/
   char  *p          = NULL;                              /* IS10183 */
   char  *p1         = NULL;                              /* IS10183 */
   char  *hide_start = NULL;                              /* IS10183 */
   char  *post_start = NULL;                              /* IS10183 */
   char   astrx[101];                                     /* IS10183 */
   int    j = 0;                                          /* IS10183 */
   int    pre_len = 0;                                    /* IS10183 */
   int    pw_len = 0;                                     /* IS10183 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(comp,3, "ACID=%s type=%s parent=%s",
                   acid, acid_type, parent_acid );

  /*
   *  Create command header
   */

   /* BS10089 Start */
   if ( (onli_acid_type EQ TYPE_USER) AND
        (strcmp(essu_params->def_group, "") NE 0) )
      sprintf(cmd.buffer, "CREATE(%s) NAME(%s) TYPE(%s) GROUP(%s) ",
              acid, TSS_DUMMY_NAME_FOR_CREATE, acid_type,
              essu_params->def_group);
   else
   /* BS10089 End */
     sprintf(cmd.buffer, "CREATE(%s) NAME(%s) TYPE(%s) ",
             acid, TSS_DUMMY_NAME_FOR_CREATE, acid_type);

  /*
   *   For acid_type USER, DCA, VCA, ZCA, LSCA, SCA
   *   should be added PASSWORD keyword
   */

   if ( (strcmp(acid_type, TSS_USER) EQ 0 ) OR
        (strcmp(acid_type, TSS_DCA ) EQ 0 ) OR
        (strcmp(acid_type, TSS_VCA ) EQ 0 ) OR
        (strcmp(acid_type, TSS_ZCA ) EQ 0 ) OR
        (strcmp(acid_type, TSS_LSCA) EQ 0 ) OR
        (strcmp(acid_type, TSS_SCA ) EQ 0 )  )
    { /************* IS10020 start **************/
     params_ptr = admin_params->apiinit_handle;
     ESA_DIAG_printf(comp, 5, "rssparm_NOPW = %s",
                     params_ptr->rssparm_NOPW);
     if (params_ptr->rssparm_NOPW[0] EQ 'N')
      { /*  Add password to the TSS CREATE command         IS10020*/
       rc = TSS_set_password(ESA_COMP_ADDUSER,cmd.buffer,essu_params,
                             dest, msgs );
       if ( rc NE ESA_OK )
        goto exit;
      }
     else /* NOPW = Y *********** IS10020 end ************/
      strcat(cmd.buffer, TSS_INITIAL_PASSWORD_PRM);
    }

   /* IS10183 - start */
   rcd = TSS_hidepsw_and_issue_diag(
                 comp,
                 5,
                 cmd.buffer,
                 "cmd.buffer = ");

   if (rcd NE ESA_OK)
   /* IS10183 - end   */
    ESA_DIAG_printf(comp, 5,"cmd.buffer = <%s>", cmd.buffer);

 /*dropped by IS10020 strcat(cmd.buffer, TSS_INITIAL_PASSWORD_PRM);*/

   rc = TSS_get_admin_details(comp, &admin, dest, msgs );
   if ( rc NE ESA_OK ) {
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   rc = TSS_validate_acid_type(comp, acid_type, parent_oe_type,
                               parent_acid, admin_params, err);
   if ( rc NE ESA_OK ) {
     rc = ESA_FATAL;
     goto exit;
   }

  /*
   *  Build additional parameters for CREATE command
   */

   rc = TSS_aux_create(comp, &admin, acid, acid_type, parent_acid,
                       parent_oe_type, cmd.buffer, dest, msgs );

   cmd.max_len = strlen(cmd.buffer);
   cmd.use_len = strlen(cmd.buffer);
   /* printf (" cmd buffer and len |%s| %d \n",
           cmd.buffer, cmd.use_len);                                 */

   rc = TSS_issue_cmd(comp, &cmd, acid, onli_acid_type,
                      TSS_EVNT_ACTION_ADD, admin_params);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_do_create */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_check_quotes                           *
 *                                                             *
 * DESCRIPTION    : Include,quotas if necessary                *
 *                                                             *
 * INPUT          : v1          - entered value                *
 *                                                             *
 * OUTPUT         : v2          - converted value              *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static void  TSS_check_quotes (char     *v1, char   *v2 )
 {

    int   do_it=0;
    /* int   i, j , k; BS2584 */

    if (strchr(v1, ' ') NE NULL )
      do_it = 1;
    else if (strstr(v1, "'") NE NULL )
      do_it = 1;
    /* BS2584
    else if (strchr(v1, ',') NE NULL )  *PS0483*
      do_it = 1;
    */

    if (do_it) {
      TSS_do_quotes(v1,v2);
      /* BS2584 - moved to a general routine
      v2[0] = QUATE_CHAR;
      j = 1;
      k = strlen(v1);
      for (i=0; i LT k; i++) {
        v2[j] = v1[i];
        if (v2[j] EQ QUATE_CHAR) {
          v2[j+1] = QUATE_CHAR;
          j++;
        }
        j++;
      }
      v2[j] = QUATE_CHAR;
      j++;
      v2[j] = NULL_CHAR;
      */
    }
    else
      strcpy(v2, v1);

 }     /* TSS_check_quotes */

 /**************************************************************
 *BS2584                                                       *
 * PROCEDURE NAME : TSS_do_quotes                              *
 *                                                             *
 * DESCRIPTION    : add quotas to a string                     *
 *                                                             *
 * INPUT          : v1          - entered value                *
 *                                                             *
 * OUTPUT         : v2          - converted value              *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static void  TSS_do_quotes (char     *v1, char   *v2 )
 {

    int   i, j , k;

    v2[0] = QUATE_CHAR;
    j = 1;
    k = strlen(v1);
    for (i=0; i LT k; i++) {
      v2[j] = v1[i];
      if (v2[j] EQ QUATE_CHAR) {
        v2[j+1] = QUATE_CHAR;
        j++;
      }
      j++;
    }
    v2[j] = QUATE_CHAR;
    j++;
    v2[j] = NULL_CHAR;

 }     /* TSS_check_quotes */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_get_admin_details                      *
 *                                                             *
 * DESCRIPTION    : Get SA-Agent administrator details         *
 *                                                             *
 * INPUT          : dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : admin       - admin structure              *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_get_admin_details(ESA_DIAG_COMP_typ            comp,
                              TSS_ADMIN_rec_typ          * admin,
                              CTSAMSG_DEST_TABLE_rec_ptr   dest,
                              CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_get_admin_details";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   rc = TSS_get_global_parameter(comp, TSS_GLOBAL_ADMIN_ACID_TYPE,
                                 admin->type, dest, msgs);
   if ( rc NE ESA_OK )
      goto exit;

   rc = TSS_get_global_parameter(comp, TSS_GLOBAL_ADMIN_PARENT_TYPE,
                                 admin->parent_type, dest, msgs);
   if ( rc NE ESA_OK )
      goto exit;

   rc = TSS_get_global_parameter(comp, TSS_GLOBAL_ADMIN_PARENT_ACID,
                                 admin->parent, dest, msgs);
   if ( rc NE ESA_OK )
      goto exit;

  /* printf ("admin type %s admin parent_type %s admin parent %s \n",
           admin->type, admin->parent_type, admin->parent);          */
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_get_admin_details */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_validate_acid_type                     *
 *                                                             *
 * DESCRIPTION    : Validate acid type                         *
 *                                                             *
 * INPUT          : comp        - diag component               *
 *                  acid_type   - acid type                    *
 *                  parent_acid - parent acid                  *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : parent_oe_typ - oe typ                     *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_validate_acid_type(ESA_DIAG_COMP_typ           comp,
                             char                      * acid_type,
                             char                      * parent_oe_typ,
                             char                      * parent_acid,
                             ADMIN_PARAMS_rec_typ      * admin_params,
                             ERR_STRUCT_rec_typ        * err)
 {

   ESA_RC                       rc = ESA_OK;
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;
   char                         root_name[MAX_TSS_PARAM_LEN];
   TSS_ACID_HEADER_rec_typ      acid_info;
   int                          verr;
   static char                  func[]="TSS_validate_acid_type";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(comp, 3, "parent_acid=%s", parent_acid);

   TSS_use_root_object(comp,root_name,dest,msgs);

  /*
   *  parent_acid checking
   */
   /* printf ("parent acid %s root name %s \n",
          parent_acid, root_name);                                   */

   if ( strcmp(parent_acid, root_name ) EQ 0 )
      strcpy(parent_oe_typ, TSS_ROOT_TYPE);
   else {
     /*
      *  Get parent acid parameters
      */

      rc = TSS_get_acid_header(comp,
                               TSS_CMD_DEFAULT_MODE,   /* BS2432 */
                   /* BS2432   TSS_CMD_WEAK_QUIET_MODE, */
                               parent_acid, &acid_info,
                               admin_params, err);
      if ( rc NE ESA_OK )
         goto exit;

      ESA_DIAG_printf(comp, 3, "ACID=%s",      acid_info.acid);
      ESA_DIAG_printf(comp, 3, "ACID_TYPE=%s", acid_info.type);
      ESA_DIAG_printf(comp, 3, "DEPT_ACID=%s", acid_info.dept_acid);
      ESA_DIAG_printf(comp, 3, "DIV_ACID=%s",  acid_info.div_acid);
      ESA_DIAG_printf(comp, 3, "ZONE_ACID=%s", acid_info.zone_acid);
      /* printf ("acid %s type %s dept %s div %s zone %s \n",
          acid_info.acid, acid_info.type, acid_info.dept_acid,
          acid_info.div_acid, acid_info.zone_acid);                  */

      ESA_DIAG_printf(comp, 3, "parent acid=%s/%s",
                      parent_acid, acid_info.acid);

      if ( strcmp(parent_acid, acid_info.acid) NE 0 ) {
         CTSAMSG_print(TSS_ERR_NO_ACID, msgs, NULL,
                       dest, acid_type, parent_acid );
         rc = ESA_ERR;
         goto exit;
      }
      strcpy (parent_oe_typ, acid_info.type);
   }

   ESA_DIAG_printf(comp, 3, "acid_type=%s parent_type=%s",
                   acid_type, parent_oe_typ);
   /* printf ("acid type %s parent oe typ %s \n",
          acid_type, parent_oe_typ);                                 */

  /*
   *   parent_oe_typ validation
   *   1. General
   */

   if ( ( strcmp(parent_oe_typ, TSS_DEPARTMENT) NE 0 ) AND
        ( strcmp(parent_oe_typ, TSS_DIVISION  ) NE 0 ) AND
        ( strcmp(parent_oe_typ, TSS_ZONE      ) NE 0 ) AND
        ( strcmp(parent_oe_typ, TSS_ROOT_TYPE ) NE 0 )   ) {
      CTSAMSG_print(ERR_ADI_UNDEF_OPTION, msgs, NULL, dest,
                    TSS_ACID_PARENT_CONTAINER, parent_oe_typ);
      rc = ESA_FATAL;
      goto exit;
   }

   verr = 0;   /* Validation err flag */

  /*
   *   parent_oe_typ validation
   *   2. TSS Root Administrators
   */

   if ( ( strcmp(acid_type, TSS_MSCA )  EQ 0 )  OR
        ( strcmp(acid_type, TSS_SCA  )  EQ 0 )  OR
        ( strcmp(acid_type, TSS_LSCA )  EQ 0 )   ) {
      if ( strcmp(parent_oe_typ, TSS_ROOT_TYPE) NE 0 )
        verr = 1;   /* Validation err flag */
      else
        strcpy(parent_oe_typ, "");
   }

  /*
   *   parent_oe_typ validation
   *   3. TSS Other Administrators
   */

   else if (strcmp(acid_type, TSS_ZCA  ) EQ 0 ) {
      if ( strcmp(parent_oe_typ, TSS_ZONE) NE 0 )
        verr = 1;   /* Validation err flag */
   }
   else if (strcmp(acid_type, TSS_VCA  ) EQ 0 ) {
      if ( strcmp(parent_oe_typ, TSS_DIVISION ) NE 0 )
        verr = 1;   /* Validation err flag */
   }
   else if (strcmp(acid_type, TSS_DCA  ) EQ 0 ) {
      if ( strcmp(parent_oe_typ, TSS_DEPARTMENT ) NE 0 )
        verr = 1;   /* Validation err flag */
   }

  /*
   *   parent_oe_typ validation
   *   4. TSS Simple objects
   */

   else if ( ( strcmp(acid_type, TSS_USER )     EQ 0 ) OR
             ( strcmp(acid_type, TSS_PROFILE  ) EQ 0 ) OR
             ( strcmp(acid_type, TSS_GROUP )    EQ 0 )  ) {
      if ( strcmp(parent_oe_typ, TSS_DEPARTMENT ) NE 0 )
        verr = 1;   /* Validation err flag */
   }

  /*
   *   parent_oe_typ validation
   *   5. TSS Containers
   */

   else if ( strcmp(acid_type, TSS_CONTAINER ) EQ 0 ) {
     /* strcpy (parent_oe_typ, acid_info.type); */
     /* ?????????? */
   }
   else if ( strcmp(acid_type, TSS_ZONE ) EQ 0 ) {
      if ( strcmp(parent_oe_typ, TSS_ROOT_TYPE) NE 0 )
        verr = 1;   /* Validation err flag */
      else
        strcpy(parent_oe_typ, "");
   }
   else if ( strcmp(acid_type, TSS_DIVISION ) EQ 0 ) {
      if ( strcmp(parent_oe_typ, TSS_ROOT_TYPE) EQ 0 )
        strcpy(parent_oe_typ, "");
      else if ( strcmp(parent_oe_typ, TSS_ZONE) EQ 0 )
        ;
      else
        verr = 1;   /* Validation err flag */
   }
   else if ( strcmp(acid_type, TSS_DEPARTMENT ) EQ 0 ) {
      if ( strcmp(parent_oe_typ, TSS_ROOT_TYPE) EQ 0 )
        strcpy(parent_oe_typ, "");
      else if ( strcmp(parent_oe_typ, TSS_DIVISION) EQ 0 )
        ;
      else
        verr = 1;   /* Validation err flag */
   }

   if ( verr EQ 1 )  {       /* Validation err flag */
      CTSAMSG_print(TSS_ERR_PARENT_ACID , msgs, NULL, dest,
                    acid_type, parent_oe_typ, parent_acid);
   /* printf ("acid type %s parent oe typ %s parent acid %s \n",
          acid_type, parent_oe_typ, parent_acid);                    */
      rc = ESA_ERR;
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }     /* TSS_validate_acid_type  */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_aux_create                             *
 *                                                             *
 * DESCRIPTION    : Additional "CREATE" cmd parameter process  *
 *                                                             *
 * INPUT          : comp             - diag component          *
 *                  admin            - admin details           *
 *                  acid             - acid                    *
 *                  acid_type        - acid type               *
 *                  parent_acid      - parent acid             *
 *                  parent_oe_type   - parent oe type          *
 *                  aux_cmd          - additional cmd          *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : cmd              - command string          *
 *                                                             *
 * RETURN VALUE   : ESA_OK, ESA_FATAL                          *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_aux_create(ESA_DIAG_COMP_typ     comp,
                       TSS_ADMIN_rec_typ          * admin,
                       char                       * acid,
                       char                       * acid_type,
                       char                       * parent_acid,
                       char                       * parent_oe_type,
                       char                       * cmd,
                       CTSAMSG_DEST_TABLE_rec_ptr   dest,
                       CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_aux_create";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   ESA_DIAG_printf(comp,3,
            "admin:type=%s parent_type=%s parent acid=%s",
             admin->type,  admin->parent_type, admin->parent);
   /* printf ("admin type %s admin parent type %s admin parent %s \n",
          admin->type,  admin->parent_type, admin->parent);          */

   ESA_DIAG_printf(comp,3,
            "object:type=%s parent_type=%s parent acid=%s",
             acid_type, parent_oe_type, parent_acid);
   /* printf ("acid type %s parent oe typ %s parent acid %s \n",
          acid_type, parent_oe_type, parent_acid);                   */

   if ( (strcmp(admin->parent_type, parent_oe_type) EQ 0 ) AND
        (strcmp(admin->parent, parent_acid        ) EQ 0 )   )
     goto exit;

   if ( strlen(parent_oe_type) EQ 0 )
      goto exit;

  /*
   *  Some additional checking
   */

  /*
   *  DCA administrator can create :
   *  USER, GROUP, PROFILE
   */

   if (strcmp(admin->type, TSS_DCA) EQ 0 ) {
     if ( (strcmp(acid_type, TSS_USER)    NE 0 ) AND
          (strcmp(acid_type, TSS_GROUP)   NE 0 ) AND
          (strcmp(acid_type, TSS_PROFILE) NE 0 )   ) {
         CTSAMSG_print(TSS_INSUFF_ADMIN_AUTH , msgs, NULL, dest,
                       admin->type, acid);
         rc = ESA_FATAL;
         goto exit;
     }

    /*
     *  DCA cannot enter DEPARTMENT keyword in their create command
     */

     else
       if (strcmp(parent_oe_type, TSS_DEPARTMENT) EQ 0 )
         goto exit;
   }

  /*
   *  VCA administrator can create :
   *  DCA, DEPARTMENT,
   *  USER, GROUP, PROFILE
   */

   if (strcmp(admin->type, TSS_VCA) EQ 0 ) {
     if ( (strcmp(acid_type, TSS_DCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DEPARTMENT)  NE 0 ) AND
          (strcmp(acid_type, TSS_USER)        NE 0 ) AND
          (strcmp(acid_type, TSS_GROUP)       NE 0 ) AND
          (strcmp(acid_type, TSS_PROFILE)     NE 0 )   ) {
         CTSAMSG_print(TSS_INSUFF_ADMIN_AUTH , msgs, NULL, dest,
                       admin->type, acid);
         rc = ESA_FATAL;
         goto exit;
     }

    /*
     *  VCA cannot enter DIVISION keyword in their create command
     */

     else
       if (strcmp(parent_oe_type, TSS_DIVISION) EQ 0 )
         goto exit;
   }

  /*
   *  ZCA administrator can create :
   *  VCA, DIVISION,
   *  DCA, DEPARTMENT,
   *  USER, GROUP, PROFILE
   */

   if (strcmp(admin->type, TSS_ZCA) EQ 0 ) {
     if ( (strcmp(acid_type, TSS_VCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DIVISION)    NE 0 ) AND
          (strcmp(acid_type, TSS_DCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DEPARTMENT)  NE 0 ) AND
          (strcmp(acid_type, TSS_USER)        NE 0 ) AND
          (strcmp(acid_type, TSS_GROUP)       NE 0 ) AND
          (strcmp(acid_type, TSS_PROFILE)     NE 0 )   ) {
         CTSAMSG_print(TSS_INSUFF_ADMIN_AUTH , msgs, NULL, dest,
                       admin->type, acid);
         rc = ESA_FATAL;
         goto exit;
     }

    /*
     *  ZCA cannot enter ZONE keyword in their create command
     */

     else
       if (strcmp(parent_oe_type, TSS_ZONE) EQ 0 )
         goto exit;
   }

  /*
   *  LSCA administrator can create :
   *  ZCA,
   *  VCA, DIVISION,
   *  DCA, DEPARTMENT,
   *  USER, GROUP, PROFILE
   */

   if (strcmp(admin->type, TSS_LSCA) EQ 0 ) {
     if ( (strcmp(acid_type, TSS_ZCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_VCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DIVISION)    NE 0 ) AND
          (strcmp(acid_type, TSS_DCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DEPARTMENT)  NE 0 ) AND
          (strcmp(acid_type, TSS_USER)        NE 0 ) AND
          (strcmp(acid_type, TSS_GROUP)       NE 0 ) AND
          (strcmp(acid_type, TSS_PROFILE)     NE 0 )   ) {
         CTSAMSG_print(TSS_INSUFF_ADMIN_AUTH , msgs, NULL, dest,
                       admin->type, acid);
         rc = ESA_FATAL;
         goto exit;
     }
   }

  /*
   *  SCA administrator can create :
   *  ZCA, ZONE
   *  VCA, DIVISION,
   *  DCA, DEPARTMENT,
   *  USER, GROUP, PROFILE
   */

   if (strcmp(admin->type, TSS_SCA) EQ 0 ) {
     if ( (strcmp(acid_type, TSS_ZCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_ZONE)        NE 0 ) AND
          (strcmp(acid_type, TSS_VCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DIVISION)    NE 0 ) AND
          (strcmp(acid_type, TSS_DCA)         NE 0 ) AND
          (strcmp(acid_type, TSS_DEPARTMENT)  NE 0 ) AND
          (strcmp(acid_type, TSS_USER)        NE 0 ) AND
          (strcmp(acid_type, TSS_GROUP)       NE 0 ) AND
          (strcmp(acid_type, TSS_PROFILE)     NE 0 )   ) {
         CTSAMSG_print(TSS_INSUFF_ADMIN_AUTH , msgs, NULL, dest,
                       admin->type, acid);
         rc = ESA_FATAL;
         goto exit;
     }
   }

  /*
   *  Append parameter to create command
   */

   /* printf ("command buffer before %s \n", cmd);                   */
   strcat(cmd, parent_oe_type);
   strcat(cmd, "(");
   strcat(cmd, parent_acid);
   strcat(cmd, ")");
   /* printf ("command buffer after  %s \n", cmd);                   */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }       /* TSS_aux_create */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_ConvertDateESS2TSS                     *
 *                                                             *
 * DESCRIPTION    : Convert ESS date to TSS format             *
 *                                                             *
 * INPUT          : date_format                                *
 *                  ess_date                                   *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : tss_date                                   *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_ConvertDateESS2TSS( ESA_DIAG_COMP_typ       comp,
                            char                       *date_format,
                            char                       *ess_date,
                            char                       *tss_date,
                            CTSAMSG_DEST_TABLE_rec_ptr  dest,
                            CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   static char       func[]="TSS_ConvertDateESS2TSS";
   ESA_RC            rc = ESA_OK;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp,5,func);

   ESA_DIAG_printf(comp, 5, "date_format=%s ess_date=%s",
                   date_format, ess_date);

   rc = CTSCDAT_conv2RSS(comp, date_format, ess_date, tss_date,
                         dest, msgs );

   ESA_DIAG_printf(comp, 5, "rc=%d tss_date=%s", rc, tss_date);

  /*
   *    Finish
   */

   exit :;

   ESA_DIAG_exit(comp,4, func, rc );

   return rc;

 }      /* TSS_ConvertDateESS2TSS */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_sort_cmd                               *
 *                                                             *
 * DESCRIPTION    : Sort command buffer                        *
 *                                                             *
 * INPUT          : cmd_handle  - command handle               *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static void TSS_sort_cmd(ESA_DIAG_COMP_typ     comp,
                          TSS_CMD_HANDLE_typ   *cmd_handle)
 {

   static char          func[]="TSS_sort_cmd";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   ESA_DIAG_printf(comp,3,
           "cmd handle: alloc entries=%d used=%d",
           cmd_handle->allocated_entries,
           cmd_handle->used_entries);

   qsort(cmd_handle->tss_cmds,        /* sort area     */
         cmd_handle->used_entries,    /* num elements  */
         sizeof(TSS_CMD_SET_rec_typ), /* element size  */
         &TSS_cmd_compare);           /* compare func  */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, ESA_OK);

}      /* TSS_sort_cmd  */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_cmd_compare                          *
*                                                             *
* Description      : Compare routine for qsort                *
*                                                             *
* Input            : 1) cmd entry 1                           *
*                    2) cmd entry 2                           *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : negative - cmd1 less than cmd2           *
*                  : zero     - cmd1 equal to  cmd2           *
*                  : positive - cmd1 greater than cmd2        *
*                                                             *
**************************************************************/

static int TSS_cmd_compare (const void * cmd1,
                            const void * cmd2)
{

  int     rc;
  TSS_CMD_SET_rec_typ * tss_cmd1 = (TSS_CMD_SET_rec_typ *)cmd1;
  TSS_CMD_SET_rec_typ * tss_cmd2 = (TSS_CMD_SET_rec_typ *)cmd2;

  if ( tss_cmd1->type EQ tss_cmd2->type )
     rc = 0;
  else if ( tss_cmd1->type LT tss_cmd2->type )
     rc = -1;
  else
     rc = 1;

  return rc;

}    /* TSS_cmd_compare */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_separate_list                        *
*                                                             *
* Description      : Separate lists fields                    *
*                                                             *
* Input            : ess_lst_handle - list handle             *
*                    value          - list value              *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
**************************************************************/

static ESA_RC TSS_separate_list(ESA_DIAG_COMP_typ    comp,
                         TSS_LST_FIELD_typ          *lst_handle,
                         char                       *value_in,
           /* IS10092 */ TSS_CONV_LISTFIELD_ptr      field_conv_func,
                         CTSAMSG_DEST_TABLE_rec_ptr  dest,
                         CTSAMSG_HANDLE_rec_ptr      msgs)
{

   ESA_RC               rc = ESA_OK;
   static char          func[]="TSS_separate_list";
   /*WS10082 char       value [TSS_ADDINFO_VAL_LEN+1];
             char       entry [TSS_ADDINFO_VAL_LEN+1];
             char       result[TSS_ADDINFO_VAL_LEN+1];          */
   char                 value [ADDINFO_16K_VAL_LEN+1]; /*WS10082*/
   char                 entry [ADDINFO_16K_VAL_LEN+1]; /*WS10082*/
   char                 result[ADDINFO_16K_VAL_LEN+1]; /*WS10082*/
   char                *token;
   char                 sep_entry[3]; /* Entries separator    */
   char                 sep_subf[3];  /* Subfield separator   */
   int                  i_subf  = 0;  /* Number of subfields  */
   int                  i;
   int                  k;
   void                *entry_handle;
   void                *subf_handle;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   BUILD_STRING_SEPARATOR(sep_entry, ADDINFO_LIST_ENTRY)
   BUILD_STRING_SEPARATOR(sep_subf , ADDINFO_LIST_SUBFIELD)

  /*
   *  Separate obtained field
   */

   strcpy(value, value_in);

   ESA_DIAG_printf(comp,3, "entered value=%s", value);
   if ( strlen(value) EQ 0 )
      goto exit;

  /*
   *  Get entry
   */

   token = my_strtok(value, sep_entry, &entry_handle,    result);

   ESA_DIAG_printf(comp,3, "start token=%x result=%s", token, result);

   while ( token )
   {
     /*
      * Check whether need reallocate list fields buffer
      */
      rc = TSS_realloc_lst_buffer (comp, lst_handle, dest, msgs );
      if (rc NE ESA_OK)
         goto exit;

      strcpy(entry, result);            /* copy current entry   */
      k = lst_handle->used_entries;     /* keep prev entry cntr */
      lst_handle->used_entries++;       /* incr entries counter */

      ESA_DIAG_printf(comp,3, "entry=%d token=%x result=%s",
                      lst_handle->used_entries, token, result);

     /*
      *  Clear subfields for current entry
      *  index of current entry = k
      */

      for (i=0; i LT MAX_TSS_SUBFIELD; i++)
          lst_handle->lst_data[k].field[i][0] = NULL_CHAR;

      i      = lst_handle->used_entries - 1; /* current entry index */
      i_subf = 0;  /* Number of subfields  */

     /*
      * Separate current entry to subfields
      */

      token  = my_strtok(entry, sep_subf, &subf_handle, result);

      ESA_DIAG_printf(comp,3, "start subfield token=%x result=%s",
                      token, result);
      while ( token )
      {
         /* Special "Set functions" conversion */

         /* IS10092 - start */
         if (field_conv_func)
           strcpy(result,
                  (field_conv_func)(comp, &lst_handle->lst_data[k],
                                    result, i_subf, dest, msgs) );
         else       /* default conversion    */
         /* IS10092 - end   */

         if (strcmp(result, "*ALL*") EQ 0 )
            strcpy(result, "");

         /* Subfields overflow checking */

         if ( (i_subf+1) GE MAX_TSS_SUBFIELD)
         {
           sprintf(internal2_msg_buf,
            "SubFieldCounter=%d.Maximum of subfield reached.Allowed=%d",
            (i_subf+1), MAX_TSS_SUBFIELD);
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                         func, internal2_msg_buf,
                         16, __LINE__);
           rc = ESA_FATAL;
           OS_MVS_btrace();
           goto exit;
         }

         ESA_DIAG_printf(comp,3, "entry=%d subf=%d data=%s",
                         i, i_subf, result);

         /*  Save current subfield */

         strcpy(lst_handle->lst_data[i].field[i_subf], result );
         i_subf++;  /* incr number of subfields  */

         /*  Determine max subfields number  */

         lst_handle->subf_cnt = MAX(lst_handle->subf_cnt, i_subf);

         /*  Get next subfield  */

         token = my_strtok(NULL, sep_subf, &subf_handle, result);
      }

     /*
      * If any subfields found.
      * The entry == first subfield
      * (case simple list without subfields)
      */

      if (i_subf EQ 0)        /* No subfields were found */
      {
         ESA_DIAG_printf(comp,3, "entry=%d subf=%d data=%s",
                         i, 0, result);

         strcpy(lst_handle->lst_data[i].field[0], entry);
         lst_handle->subf_cnt = MAX(lst_handle->subf_cnt, 1);
      }

      /*  Get next entrty  */

      token = my_strtok(NULL, sep_entry, &entry_handle,  result);
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_separate_list  */

/**************************************************************
*                                                             *
* Subroutine name : my_strtok                                 *
*                                                             *
* DESCRIPTION     : strtok                                    *
*                                                             *
* INPUT           : sptr        - ptr to string               *
*                   charset     - ptr to char set             *
*                   handle      - ptr to handle               *
*                                                             *
* OUTPUT          : none                                      *
*                                                             *
* RETURN VALUE    : ptr to current token                      *
*                                                             *
**************************************************************/

static char * my_strtok(char         *  sptr,
                        char         *  charset,
                        void         ** handle,
                        char         *  result)
{

    char    *rptr;                  /* Return ptr          */
    int     len;                    /* Item length         */
    int     k;                      /* Work var            */

    *result = '\0';                 /* Clear result field  */

    if ( !sptr )                    /* Get ptr from handle */
      sptr = (char *)(*handle);

    if ( !sptr ) {                  /* End-of-string */
      rptr = sptr;
      goto exit;
    }

    k = strspn(sptr, charset);      /* How many symbols            */
    if ( k > 0 ) {                  /* Field missing. Result empty */
       rptr = sptr;
       strcpy(result, "");
       *handle = rptr + 1;
       return rptr;
    }

    rptr  = strpbrk(sptr, charset); /* Search end-of-item */
    if (!rptr) { /* No characters from charset occurs in string */
      strcpy(result, sptr);         /* Copy until end-of-string     */
      *handle = rptr;
      rptr    = sptr;
      goto exit;
    }

    len    = rptr - sptr;           /* End-of-item found   */
    memcpy( result, sptr, len );    /* Copy item to result */
    *(result + len) = '\0';

    *rptr   = '\0';           /* Set end-of-string */
    *handle = rptr + 1;       /* Keep ptr for the next strtok */
    rptr    = sptr;           /* Start ptr to string */

   exit :;
     return rptr;

}     /* my_strtok */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_alloc_lst_handle                       *
 *                                                             *
 * DESCRIPTION    : Allocate list fields handle                *
 *                                                             *
 * INPUT          : comp          - diag component             *
 *                  max_entries   - max cmd entries            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : cmd_handle    - command handle             *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_alloc_lst_handle (ESA_DIAG_COMP_typ            comp,
                              int                          max_entries,
                              TSS_LST_FIELD_typ         ** lst_handle,
                              CTSAMSG_DEST_TABLE_rec_ptr   dest,
                              CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   ESA_RC                rc = ESA_OK;
   static char           func[]="TSS_alloc_lst_handle";
   TSS_LST_FIELD_typ   * tmp_lst_handle;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

  /*
   *  Allocate lst handle structure
   */

   tmp_lst_handle = (TSS_LST_FIELD_typ  *)malloc(
                                sizeof(TSS_LST_FIELD_typ));
   if (tmp_lst_handle EQ NULL ) {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "lst handle", sizeof(TSS_LST_FIELD_typ));
       rc = ESA_FATAL;
       OS_MVS_btrace();
       goto exit;
   }

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                  /*IS0358*/
    "malloc (%d) bytes at address (%x) (%d,%s)",
    sizeof(TSS_LST_FIELD_typ), tmp_lst_handle,
    __LINE__, __FILE__ );
   ESA_DIAG_printf(comp,3, "lst handle ptr=%x", tmp_lst_handle);

  /*
   *  Allocate lsts buffer
   */

   tmp_lst_handle->max_expected_entries = max_entries;

   ESA_DIAG_printf(comp,3, "lst buffer entries=%d",
                   tmp_lst_handle->max_expected_entries);

   tmp_lst_handle->lst_data = (TSS_LST_DATA_typ  *)malloc(
                               sizeof(TSS_LST_DATA_typ) *
                               tmp_lst_handle->max_expected_entries);

   if (tmp_lst_handle->lst_data EQ NULL ) {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "lst buffer",
                  sizeof(TSS_LST_DATA_typ) *
                  tmp_lst_handle->max_expected_entries);
       rc = ESA_FATAL;
       OS_MVS_btrace();
       ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,          /*IS0358*/
        "Free address (%x) (%d,%s)",
        tmp_lst_handle, __LINE__, __FILE__ );
       free(tmp_lst_handle);
       goto exit;
   }

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                  /*IS0358*/
    "malloc (%d) bytes at address (%x) (%d,%s)",
    sizeof(TSS_LST_DATA_typ) * tmp_lst_handle->max_expected_entries,
    tmp_lst_handle->lst_data,
    __LINE__, __FILE__ );
   ESA_DIAG_printf(comp,3,
                   "allocated lst buffer ptr=%x",
                   tmp_lst_handle->lst_data);

   tmp_lst_handle->allocated_entries = max_entries;
   tmp_lst_handle->used_entries      = 0;
   tmp_lst_handle->subf_cnt          = 0;

   *lst_handle = tmp_lst_handle;

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_alloc_lst_handle */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_realloc_lst_buffer                     *
 *                                                             *
 * DESCRIPTION    : RE Allocate list buffer                    *
 *                                                             *
 * INPUT          : lst_handle    -  cmd_handle                *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_realloc_lst_buffer (ESA_DIAG_COMP_typ    comp,
                        TSS_LST_FIELD_typ          * lst_handle,
                        CTSAMSG_DEST_TABLE_rec_ptr   dest,
                        CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   ESA_RC              rc = ESA_OK;
   TSS_LST_DATA_typ  * tmp;
   static char         func[]="TSS_realloc_lst_buffer";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp,10, func);

   if ( (lst_handle->used_entries + 1) GE
         lst_handle->allocated_entries  ) {

    /*
     *  RE Allocate lsts buffer
     */

     lst_handle->allocated_entries += lst_handle->max_expected_entries;

     ESA_DIAG_printf(comp,3, "lst buffer entries=%d",
                     lst_handle->allocated_entries);

     tmp = lst_handle->lst_data;
     ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
        "Before realloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(TSS_LST_DATA_typ)*lst_handle->allocated_entries,
         lst_handle->lst_data, __LINE__, __FILE__ );
     lst_handle->lst_data = (TSS_LST_DATA_typ  *)realloc(
                                lst_handle->lst_data,
                                sizeof(TSS_LST_DATA_typ) *
                                lst_handle->allocated_entries );

     if (lst_handle->lst_data EQ NULL ) {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "lst buffer",
                    sizeof(TSS_LST_DATA_typ) *
                    lst_handle->allocated_entries );
         rc = ESA_FATAL;
         OS_MVS_btrace();
         goto exit;
     }

     ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
        "After realloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(TSS_LST_DATA_typ)*lst_handle->allocated_entries,
         lst_handle->lst_data, __LINE__, __FILE__ );
     ESA_DIAG_printf(comp,10,"re-allocated lst buffer ptr=%x",
                     lst_handle->lst_data);

   }    /* realloc lst buffer */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp,10, func, rc);

   return rc;

}     /* TSS_realloc_lst_buffer */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_free_lst_handle                        *
 *                                                             *
 * DESCRIPTION    : Free lst handle                            *
 *                                                             *
 * INPUT          : lst_handle    -  command handle            *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 void TSS_free_lst_handle (ESA_DIAG_COMP_typ            comp,
                           TSS_LST_FIELD_typ         ** lst_handle,
                           CTSAMSG_DEST_TABLE_rec_ptr   dest,
                           CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   static char         func[]="TSS_free_lst_handle";
   TSS_LST_FIELD_typ  *tmp_lst_handle = *lst_handle;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   ESA_DIAG_printf(comp, 4,
                   "***free(2)             %X-%X (%d,%s)",
                   tmp_lst_handle, tmp_lst_handle->lst_data,
                   __LINE__, __FILE__ );
  /*
   *  Free list buffer
   */

   ESA_DIAG_printf(comp,5, "lst buffer ptr=%x",
                   tmp_lst_handle->lst_data);

   if (tmp_lst_handle->lst_data NE NULL )
     {
      ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
      "Free address (%x) (%d,%s)",
       tmp_lst_handle->lst_data, __LINE__, __FILE__ );
       free(tmp_lst_handle->lst_data);
     }

  /*
   *  Free list handle
   */

   ESA_DIAG_printf(comp,5, "lst handle ptr=%x", tmp_lst_handle);

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
      "Free address (%x) (%d,%s)",
       tmp_lst_handle, __LINE__, __FILE__ );
   free(tmp_lst_handle);
   *lst_handle = NULL;

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, ESA_OK);

}      /* TSS_free_lst_handle */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_sort_list                              *
 *                                                             *
 * DESCRIPTION    : Sort list                                  *
 *                                                             *
 * INPUT          : lst_handle    -  cmd_handle                *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/

 static void TSS_sort_list(ESA_DIAG_COMP_typ            comp,
                           int                          key,
                           TSS_LST_FIELD_typ          * lst_handle,
                           CTSAMSG_DEST_TABLE_rec_ptr   dest,
                           CTSAMSG_HANDLE_rec_ptr       msgs)
 {

   static char         func[]="TSS_sort_list";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   key_ind_lst_fld = key;

   ESA_DIAG_printf(comp,3,
           "lst handle: alloc entries=%d used=%d",
            lst_handle->allocated_entries,
            lst_handle->used_entries);

   ESA_DIAG_printf(comp,3, "index of key=%d", key);

   qsort(lst_handle->lst_data,        /* sort area     */
         lst_handle->used_entries,    /* num elements  */
         sizeof(TSS_LST_DATA_typ),    /* element size  */
         &TSS_lst_compare);           /* compare func  */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, ESA_OK );

}     /* TSS_sort_list */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_sort_lst2                              *
 *                                                             *
 * DESCRIPTION    : Sort list items                            *
 *                                                             *
 * INPUT          : lst_handle    -  cmd_handle                *
 *                  comp          -  diag component            *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK, ESA_FATAL - err               *
 *                                                             *
 **************************************************************/
 static ESA_RC TSS_sort_lst2(ESA_DIAG_COMP_typ          comp,
                             ONE_FIELD_rec_ptr          lst_pair,
                             CTSAMSG_DEST_TABLE_rec_ptr dest,
                             CTSAMSG_HANDLE_rec_ptr     msgs)
 {

   static char         func[]="TSS_sort_lst2";
   ESA_RC              rc = ESA_OK;
   /* WS10082N char                value [TSS_ADDINFO_VAL_LEN+1]; */
   char                value [ADDINFO_16K_VAL_LEN+1];     /* WS10082N */
   char               *token;
   char                sep_entry[3]; /* Entries separator */
   char              **list_entries = NULL;
   char              **work;
   int                 entries_counter = 0;
   int                 allocated_counter;
   int                 i;

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   ESA_DIAG_printf(comp,3, "lst_value=%s", lst_pair->value);

   /* WS10082N if ( strlen(lst_pair->value) EQ 0 ) */
   if ( lst_pair->vallen EQ 0 )
      goto exit;

   /*** Allocate area for entries ptrs ***/

   list_entries=(char **)malloc(sizeof(char *) * MAX_TSS_LST_ENTRIES);
   if (NOT list_entries) {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                   "lst work area",
                   (sizeof(char *) * MAX_TSS_LST_ENTRIES) );
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                  /*IS0358*/
    "malloc (%d) bytes at address (%x) (%d,%s)",
    sizeof(char *) * MAX_TSS_LST_ENTRIES, list_entries,
    __LINE__, __FILE__ );
   allocated_counter = MAX_TSS_LST_ENTRIES;
   BUILD_STRING_SEPARATOR(sep_entry, ADDINFO_LIST_ENTRY)

   /*** Separate obtained field to entries only ***/

   strcpy(value, lst_pair->value);

   /*** Get entry ***/

   token = strtok(value, sep_entry);

   while ( token ) {

      ESA_DIAG_printf(comp,4, "%d.token=%X/%s",
                      entries_counter, token, token);

      /*** Check whether need reallocate save ptrs area ***/

      if (entries_counter GE allocated_counter) {
        work = list_entries;
        allocated_counter += MAX_TSS_LST_ENTRIES;
        ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,             /*IS0358*/
        "Before realloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(char *) * allocated_counter,
         list_entries, __LINE__, __FILE__ );
        list_entries=(char **)realloc(list_entries,
                                  sizeof(char *) * allocated_counter);
        if (NOT list_entries) {
           CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                         "lst work area",
                         (sizeof(char *) * allocated_counter) );
           rc = ESA_FATAL;
           list_entries = work; /* Return previous ptr value */
           OS_MVS_btrace();
           goto exit;
        }
      }
      ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
        "After realloc (%d) bytes at address (%x) (%d,%s)",
         sizeof(char *) * allocated_counter,
         list_entries, __LINE__, __FILE__ );

      /*** Save entry ptr ***/

      list_entries[entries_counter] = token;
      entries_counter++;

      /*** Get next entrty ***/

      token = strtok(NULL, sep_entry);
   }

   /*** Sort obtained entries ***/

   qsort((char *)list_entries,        /* sort area     */
         entries_counter,             /* num elements  */
         sizeof(char *),              /* element size  */
         &TSS_lst_compare2);          /* compare func  */

   /*** Put sorted list back ***/

   ADDINFO_updval( "", TSS_ADDINFO_VAL_LEN, lst_pair );
   for(i=0; i LT entries_counter; i++) {
     token = list_entries[i];
     ESA_DIAG_printf(comp,4, "Put %d.token=%X/%s",
                     i, token, token);
     ADDINFO_addval(token, TSS_ADDINFO_VAL_LEN,
                    ADDINFO_LIST_ENTRY, lst_pair, dest, msgs );
   }

  /*
   *    Finish
   */

   exit:;

   if (list_entries)
    {
      ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,                 /*IS0358*/
        "Free address (%x) (%d,%s)",
        list_entries, __LINE__, __FILE__ );
      free(list_entries);
    }

   ESA_DIAG_exit(comp, 3, func, rc );
   return rc;

}     /* TSS_sort_lst2 */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_lst_compare                          *
*                                                             *
* Description      : Compare routine for qsort                *
*                                                             *
* Input            : 1) lst entry 1                           *
*                    2) lst entry 2                           *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : negative - cmd1 less than cmd2           *
*                  : zero     - cmd1 equal to  cmd2           *
*                  : positive - cmd1 greater than cmd2        *
*                                                             *
**************************************************************/

static int TSS_lst_compare (const void * lst1,
                            const void * lst2)
{

  int     i = key_ind_lst_fld;
  TSS_LST_DATA_typ * tss_lst1 = (TSS_LST_DATA_typ *)lst1;
  TSS_LST_DATA_typ * tss_lst2 = (TSS_LST_DATA_typ *)lst2;

  return
     strcmp(tss_lst1->field[i], tss_lst2->field[i] );

}    /* TSS_lst_compare */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_lst_compare2                         *
*                                                             *
* Description      : Compare routine for qsort                *
*                    Invoked by TSS_sort_lst2                 *
*                                                             *
* Input            : 1) lst entry 1                           *
*                    2) lst entry 2                           *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : negative - cmd1 less than cmd2           *
*                  : zero     - cmd1 equal to  cmd2           *
*                  : positive - cmd1 greater than cmd2        *
*                                                             *
**************************************************************/

static int TSS_lst_compare2 (const void * entry1,
                             const void * entry2)
{

  char    *ptr1;   /* ptr to first record  */
  char    *ptr2;   /* ptr to second record */

  memcpy( (char *)&ptr1, entry1, sizeof(char *));
  memcpy( (char *)&ptr2, entry2, sizeof(char *));

  ESA_DIAG_printf(0, 5, "%X-%X", ptr1, ptr2);

  return strcmp(ptr1, ptr2);

}    /* TSS_lst_compare2 */

/* IS10092 - start   */
/**************************************************************
*                                                             *
* Procedure Name   : TSS_compare_fromto_subfields             *
*                                                             *
* Description      : Subfields compare routine                *
*                                                             *
* Input            : 1) first subfield to compare.            *
*                    2) last subfield to compare.             *
*                    3) list entry 1                          *
*                    4) list entry 2                          *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : negative - entry 1 less than entry 2     *
*                  : zero     - entry 1 equal to entry 2      *
*                  : positive - entry 1 greater than entry 2  *
*                                                             *
**************************************************************/

static int TSS_compare_fromto_subfields(ESA_DIAG_COMP_typ    comp,
                                 int                  from_subfield,
                                 int                  to_subfield,
                   /* IS10092 */ int                  do_strpblnk,
                                 TSS_LST_DATA_typ   * tss_lst1,
                                 TSS_LST_DATA_typ   * tss_lst2)
{

   int     i;
   int     res;
   static  char  func[] = "TSS_compare_fromto_subfields";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   for (i=from_subfield-1; i LT to_subfield; i++ )
   {
     if (do_strpblnk)
     {
       TSS_strip_val(tss_lst1->field[i], ' ', TSS_STRIP_BOTH);
       TSS_strip_val(tss_lst2->field[i], ' ', TSS_STRIP_BOTH);
     }

     res = strcmp(tss_lst1->field[i], tss_lst2->field[i]);
     if (res NE 0 )
       break;
   }

  /*
   *    Finish
   */

  exit:;

   ESA_DIAG_printf(comp,3, "rc=%d", res);
   ESA_DIAG_exit(comp, 3, func, ESA_OK );

   return res;

}    /* TSS_compare_fromto_subfields */
/* IS10092 - end */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_compare_subfields                    *
*                                                             *
* Description      : Subfields compare routine                *
*                                                             *
* Input            : 1) lst entry 1                           *
*                    2) lst entry 2                           *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : negative - cmd1 less than cmd2           *
*                  : zero     - cmd1 equal to  cmd2           *
*                  : positive - cmd1 greater than cmd2        *
*                                                             *
**************************************************************/

static int TSS_compare_subfields(ESA_DIAG_COMP_typ    comp,
                                 int                  subf_cnt,
                                 TSS_LST_DATA_typ   * tss_lst1,
                                 TSS_LST_DATA_typ   * tss_lst2)
{

   int     i;
   int     res;
   static  char  func[] = "TSS_compare_subfields";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   res = 1;   /* Not Equal */
   for (i=0; i LT subf_cnt; i++ ) {
     if (strcmp(tss_lst1->field[i], tss_lst2->field[i] ) NE 0 )
       goto exit;
   }

   res = 0;   /* Equal */

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_printf(comp,3, "rc=%d", res);
   ESA_DIAG_exit(comp, 3, func, ESA_OK );

   return res;

}    /* TSS_compare_subflds */

 /* WS10009                         start                     */
/**************************************************************
*                                                             *
* Procedure Name   : TSS_find_suspend_type                    *
*                                                             *
* Description      : Find which SUSPEND type user has (i.e.   *
*                    SUSPEND, ASUSPEND, PSUSPEND, VSUSPEND or *
*                    XSUSPEND)                                *
*                                                             *
* Input            : get user info                            *
*                                                             *
* Output           : SUSPEND type                             *
*                                                             *
* Return Value     : rc = 0                                   *
*                                                             *
**************************************************************/

static int TSS_find_suspend_type(ESA_DIAG_COMP_typ     comp,
                                 ADDINFO_rec_typ     * get_addinfo,
                                 char                * suspend_type)
{
   ESA_RC              rc = ESA_OK;
   static char         func[]="TSS_find_suspend_type";
   ONE_FIELD_rec_ptr   cpair;

   ESA_DIAG_enter(comp, 1, func);
  /*
   *  Check INFO.SUSPEND_TYPE field
   */

   cpair=ADDINFO_search("INFO.SUSPEND_TYPE", TSS_ADDINFO_KWD_LEN,
                     get_addinfo->pair, get_addinfo->num_pairs);

   ESA_DIAG_printf(comp,3, "INFO.SUSPEND_TYPE=%x", cpair);
   if ( cpair NE NULL )
      ESA_DIAG_printf(comp,3, "INFO.SUSPEND_TYPE=%s",
                      cpair->value);
   if ( cpair EQ NULL )
      strcpy(suspend_type,"SUSPEND ");
   else if (strcmp(cpair->value, "ASUSPEND") EQ 0 )
      strcpy(suspend_type,"ASUSPEND ");
   else if (strcmp(cpair->value, "XSUSPEND") EQ 0 )
      strcpy(suspend_type,"XSUSPEND ");
   else if (strcmp(cpair->value, "VSUSPEND") EQ 0 )
      strcpy(suspend_type,"VSUSPEND ");
   else if (strcmp(cpair->value, "PSUSPEND") EQ 0 )
      strcpy(suspend_type,"PSUSPEND ");
   else
      strcpy(suspend_type,"SUSPEND ");

   ESA_DIAG_exit(comp, 3, func, ESA_OK );
   return rc;
}
static ONE_FIELD_rec_ptr  TSS_find_RU_keys(
                                 ESA_DIAG_COMP_typ     comp,
                                 char                * ru_key,
                                 ADDINFO_rec_typ     * ess_addinfo)
{
   static char         func[]="TSS_find_RU_keys";
   ONE_FIELD_rec_ptr   cpair;

   ESA_DIAG_enter(comp, 1, func);

   ESA_DIAG_printf(comp, 3,
                     "Search %s",
                     ru_key);
   cpair = ADDINFO_search ( ru_key, TSS_ADDINFO_KWD_LEN,
                          ess_addinfo->pair,
                          ess_addinfo->num_pairs );
   if ( cpair NE NULL)
     ESA_DIAG_printf(comp, 3,
                    "%s found = %x",
                    ru_key,
                    cpair) ;
   ESA_DIAG_exit(comp, 3, func, ESA_OK );

   return cpair;
}
 /* WS10009                         end                       */
/**************************************************************
*                                                             *
* Procedure Name   : TSS_facility_diff                        *
*                                                             *
* Description      : Create list differences (FACILITY)       *
*                                                             *
* Input            : comp           -  diag component         *
*                    key            -  subfield index of key  *
*                    ess_lst_handle -  ess list handle        *
*                    get_lst_handle -  get list handle        *
*                    kwd            -  main keyword name      *
*                    add_cmd        -  command for add item   *
*                    del_cmd        -  command for del item   *
*                    cmd_handle     -  command handle         *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : main keyword name use instead subfield   *
*                    field name in case that one is NULL      *
*                                                             *
**************************************************************/

static ESA_RC TSS_facility_diff(ESA_DIAG_COMP_typ        comp,
                            TSS_SET_ITEM_ptr             item_func,
                            int                          key,
                            TSS_LST_FIELD_typ          * ess_lst_handle,
                            TSS_LST_FIELD_typ          * get_lst_handle,
                            char                       * kwd,
                            TSS_CMD_typ                  add_cmd,
                            TSS_CMD_typ                  del_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

#define MAX_REM_FAC     100

   ESA_RC               rc = ESA_OK;
   int                  i, j, k, m, n;
   int                  compare;
   int                  size;
   struct _rm_fac {
        char   rem_fac[MAX_TSS_PARAM_LEN];
   };

   struct _rm_fac       *rmv_fac   = NULL;
   struct _rm_fac       *add_fac   = NULL;
   struct _rm_fac       *tmp       = NULL;

   #define ALLOC_FACILITY_WORK_AREA(wa)                  \
     size = MAX_REM_FAC * sizeof(struct _rm_fac);        \
     (wa) = (struct _rm_fac *)malloc( size );            \
     if ( NOT (wa) ) {                                   \
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,      \
                      "Facility work area", size);       \
        rc = ESA_FATAL ;                                 \
        goto exit ;                                      \
     }                                                   \
     ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1, /*IS0358*/   \
      "malloc (%d) bytes at address (%x) (%d,%s)",       \
       size,(wa), __LINE__, __FILE__ );

   #define REALLOC_FACILITY_WORK_AREA(a,u,wa)            \
     if ( ( (u)+1 ) GT (a) ) {                           \
        (a) += MAX_REM_FAC;                              \
        size = (a) * sizeof(struct _rm_fac);             \
        ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1, /*IS0358*/   \
         "Before realloc (%d) bytes at address (%x) (%d,%s)", \
         size,(wa), __LINE__, __FILE__ );                \
        tmp = (struct _rm_fac *)realloc( (wa), size );   \
        if ( NOT tmp ) {                                 \
           CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,   \
                         "Facility work area", size);    \
           rc = ESA_FATAL ;                              \
           goto exit ;                                   \
        }                                                \
        else                                             \
           (wa) = tmp;                                   \
        ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1, /*IS0358*/   \
         "After realloc (%d) bytes at address (%x) (%d,%s)", \
         size,(wa), __LINE__, __FILE__ );                \
     }

   #define FREE_FACILITY_WORK_AREA(wa)                   \
     if ( (wa) )                                         \
       {                                                 \
        ESA_DIAG_printf(PLT_COMP_TSS_MEMORY,1,/*IS0358*/ \
         "Free address (%x) (%d,%s)",                    \
         (wa), __LINE__, __FILE__ );                \
        free( (wa) );                                    \
       }

   int                  allc_rmv_fac;
   int                  used_rmv_fac;
   int                  allc_add_fac;
   int                  used_add_fac;
   int                  all_facility_removed = FALSE;
   char                 rem_fac[MAX_TSS_PARAM_LEN] = "";
   static char          func[]="TSS_facility_diff";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   ALLOC_FACILITY_WORK_AREA(rmv_fac)
   ALLOC_FACILITY_WORK_AREA(add_fac)

   allc_rmv_fac = MAX_REM_FAC;
   used_rmv_fac = 0;

   allc_add_fac = MAX_REM_FAC;
   used_add_fac = 0;

   m = get_lst_handle->subf_cnt;

  /*
   *   Special FACILITY list processing
   *   Empty facility name field means : "ALL"
   */

   for (i=0; i LT ess_lst_handle->used_entries; i++) {
       if (strlen(ess_lst_handle->lst_data[i].field[0] ) EQ 0 )
         strcpy(ess_lst_handle->lst_data[i].field[0], "ALL" );
   }

   for (i=0; i LT get_lst_handle->used_entries; i++) {
       if (strlen(get_lst_handle->lst_data[i].field[0] ) EQ 0 )
         strcpy(get_lst_handle->lst_data[i].field[0], "ALL" );
   }

  /*
   *   List compare loop
   *   Determine added facilities
   */

   strcpy(rem_fac, "");
   for (i=0; i LT ess_lst_handle->used_entries ; i++ ) {
     compare = 1;
     for (j=0; j LT get_lst_handle->used_entries ; j++ ) {
        compare =  TSS_lst_compare(&ess_lst_handle->lst_data[i],
                                   &get_lst_handle->lst_data[j]);
        ESA_DIAG_printf(comp, 5,
                        "i=%d j=%d compare=%d", i, j, compare);

        if (compare EQ 0) {
          compare = TSS_compare_subfields(comp,
                                   get_lst_handle->subf_cnt,
                                   &ess_lst_handle->lst_data[i],
                                   &get_lst_handle->lst_data[j]);
          if (compare EQ 0 ) /* Subfields eq also */
            break;
        }
     }
     if (compare NE 0) {

       ESA_DIAG_printf(comp,5, "already added fac=%s now=%s",
                       rem_fac,
                       ess_lst_handle->lst_data[i].field[0]);

       if (strcmp(rem_fac,
                  ess_lst_handle->lst_data[i].field[0] ) NE 0 ) {
         REALLOC_FACILITY_WORK_AREA(allc_add_fac, used_add_fac, add_fac)
         strcpy( rem_fac, ess_lst_handle->lst_data[i].field[0]);
         strcpy( add_fac[used_add_fac].rem_fac, rem_fac);
         used_add_fac++;
         ESA_DIAG_printf(comp,5, "1.Saved added fac %d.%s",
                         used_add_fac, rem_fac);
       }
     }
   }

  /*
   *   List compare loop
   *   Determine removed facilities
   */

   strcpy(rem_fac, "");
   for (i=0; i LT get_lst_handle->used_entries ; i++ ) {
     compare = 1;
     for (j=0; j LT ess_lst_handle->used_entries ; j++ ) {
        compare =  TSS_lst_compare(&ess_lst_handle->lst_data[j],
                                   &get_lst_handle->lst_data[i]);
        ESA_DIAG_printf(comp, 5,
                        "i=%d j=%d compare=%d", i, j, compare);

        if (compare EQ 0) {
          compare = TSS_compare_subfields(comp,
                                   get_lst_handle->subf_cnt,
                                   &ess_lst_handle->lst_data[j],
                                   &get_lst_handle->lst_data[i]);
          if (compare EQ 0 ) /* Subfields eq also */
            break;
        }
     }
     if (compare NE 0) {

       ESA_DIAG_printf(comp,5, "already removed fac=%s now=%s",
                       rem_fac,
                       get_lst_handle->lst_data[i].field[0]);

       if (strcmp(rem_fac,
                  get_lst_handle->lst_data[i].field[0] ) NE 0 ) {
         REALLOC_FACILITY_WORK_AREA(allc_rmv_fac, used_rmv_fac, rmv_fac)
         strcpy( rem_fac, get_lst_handle->lst_data[i].field[0]);
         strcpy( rmv_fac[used_rmv_fac].rem_fac, rem_fac);
         used_rmv_fac++;
         if ( strcmp(rem_fac, "ALL") EQ 0 )
            all_facility_removed = TRUE;
         ESA_DIAG_printf(comp,5, "1.Saved removed fac %d.%s",
                         used_rmv_fac, rem_fac);
       }
     }
   }

  /*
   *  Dump added facilities list
   */

   ESA_DIAG_printf(comp,5, "Added facilities");
   for (k=0; k LT used_add_fac; k++ ) {
     ESA_DIAG_printf(comp,5, "Added fac=%s", add_fac[k].rem_fac);
   }

  /*
   *  Dump removed facilities list
   */

   ESA_DIAG_printf(comp,5, "Removed facilities");
   for (k=0; k LT used_rmv_fac; k++ ) {
     ESA_DIAG_printf(comp,5, "Removed fac=%s", rmv_fac[k].rem_fac);
   }

  /*
   *  Remove facilities
   */

   for (k=0; k LT used_rmv_fac; k++ ) {
     for (i=0; i LT get_lst_handle->used_entries ; i++ ) {

       /* Facility was removed */

       if(strcmp(get_lst_handle->lst_data[i].field[0],
                 rmv_fac[k].rem_fac) EQ 0 ) {

         ESA_DIAG_printf(comp,5, "Remove fac=%s", rmv_fac[k].rem_fac);

        /*
         * When we are going to delete ALL facility by
         * any reason, (delete, or update )
         * quite enought to put cmd for REMOVE facility (ALL)
         */

         if ( all_facility_removed AND
              (strcmp(rmv_fac[k].rem_fac, "ALL") NE 0 ) )
           continue;

         /*  Delete "GET" entry  */

         rc = (item_func)(comp,TSS_ITEM_DEL,
                          kwd, del_cmd, cmd_handle,
                          get_lst_handle->subf_cnt,
                          &get_lst_handle->lst_data[i],
                          subf_names, dest, msgs);
         if (rc NE ESA_OK)
           goto exit;
         else
           break;
       }
     }
   }

  /*
   *  Add facilities. New   (from ESS list)
   */

   for (k=0; k LT used_add_fac; k++ ) {
     for (i=0; i LT ess_lst_handle->used_entries ; i++ ) {
       if (strcmp(ess_lst_handle->lst_data[i].field[0],
                                "$$LIST_DONE$$") EQ 0 )
         continue;

       /* Add Facility */

       if(strcmp(ess_lst_handle->lst_data[i].field[0],
                 add_fac[k].rem_fac) EQ 0 ) {

         ESA_DIAG_printf(comp,5, "1.Add fac=%s", add_fac[k].rem_fac);

         for (n=0; n LT ess_lst_handle->subf_cnt; n++) {
            ESA_DIAG_printf(comp,5, "%3d %3d %s",  i, n,
                            ess_lst_handle->lst_data[i].field[n]);
         }

         /*  Add "ESS" entry  */

         rc = (item_func)(comp,TSS_ITEM_ADD,
                          kwd, add_cmd, cmd_handle,
                          ess_lst_handle->subf_cnt,
                          &ess_lst_handle->lst_data[i],
                          subf_names, dest, msgs);
         if (rc NE ESA_OK)
           goto exit;

         strcpy(ess_lst_handle->lst_data[i].field[0],"$$LIST_DONE$$");
       } /* Add facility */
     }
   }

  /*
   *  Add facilities. From removed list (from ESS list).
   *  In case duplicate facilities items.
   */

   for (k=0; k LT used_rmv_fac; k++ ) {
     for (i=0; i LT ess_lst_handle->used_entries ; i++ ) {
       if (strcmp(ess_lst_handle->lst_data[i].field[0],
                                "$$LIST_DONE$$") EQ 0 )
         continue;

       /* Add Facility */

       if ( all_facility_removed OR
            (strcmp(ess_lst_handle->lst_data[i].field[0],
                   rmv_fac[k].rem_fac) EQ 0 )            ) {

         ESA_DIAG_printf(comp,5, "1.Add fac=%s", rmv_fac[k].rem_fac);

         for (n=0; n LT ess_lst_handle->subf_cnt; n++) {
            ESA_DIAG_printf(comp,5, "%3d %3d %s",  i, n,
                            ess_lst_handle->lst_data[i].field[n]);
         }

         /*  Add "ESS" entry  */

         rc = (item_func)(comp,TSS_ITEM_ADD,
                          kwd, add_cmd, cmd_handle,
                          ess_lst_handle->subf_cnt,
                          &ess_lst_handle->lst_data[i],
                          subf_names, dest, msgs);
         if (rc NE ESA_OK)
           goto exit;

         strcpy(ess_lst_handle->lst_data[i].field[0],"$$LIST_DONE$$");
       } /* Add facility */
     }
   }

  /*
   *    Finish
   */

   exit:;

   FREE_FACILITY_WORK_AREA(rmv_fac)
   FREE_FACILITY_WORK_AREA(add_fac)

   if ( rc EQ ESA_FATAL ) {
       OS_MVS_btrace();
   }
   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}    /* TSS_facility_diff */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_convert_rescls_names                   *
 *                                                             *
 * DESCRIPTION    : Special convert resclass names routine     *
 *                                                             *
 * INPUT          : lst_handle  - command handle               *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static void TSS_convert_rescls_names(ESA_DIAG_COMP_typ    comp,
                                      TSS_LST_FIELD_typ   *lst_handle)
 {

   int                  i;
   int                  j;
   static char          func[]="TSS_convert_rescls_names";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   ESA_DIAG_printf(comp,5,
           "lst handle: alloc entries=%d used=%d subfield cntr=%d",
           lst_handle->allocated_entries,
           lst_handle->used_entries,
           lst_handle->subf_cnt);

   j=0;
   for (i=0; i LT lst_handle->used_entries; i++) {
     ESA_DIAG_printf(comp,5, "%3d %3d %s -> %s",
         i, j, lst_handle->lst_data[i].field[j],
         TSS_convert_restype(lst_handle->lst_data[i].field[j]) ) ;
     strcpy(lst_handle->lst_data[i].field[j],
            TSS_convert_restype(lst_handle->lst_data[i].field[j]) ) ;
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, ESA_OK);

}     /* TSS_convert_rescls_names  */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_list_diff                            *
*                                                             *
* Description      : Create list differences                  *
*                                                             *
* Input            : comp           -  diag component         *
*                    key            -  subfield index of key  *
*                    ess_lst_handle -  ess list handle        *
*                    get_lst_handle -  get list handle        *
*                    kwd            -  main keyword name      *
*                    add_cmd        -  command for add item   *
*                    del_cmd        -  command for del item   *
*                    cmd_handle     -  command handle         *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : main keyword name use instead subfield   *
*                    field name in case that one is NULL      *
*                                                             *
**************************************************************/

static ESA_RC TSS_list_diff(ESA_DIAG_COMP_typ            comp,
                            TSS_SET_ITEM_ptr             item_func,
                            int                          key,
                            TSS_LST_FIELD_typ          * ess_lst_handle,
                            TSS_LST_FIELD_typ          * get_lst_handle,
                            char                       * kwd,
                            TSS_CMD_typ                  add_cmd,
                            TSS_CMD_typ                  del_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC               rc = ESA_OK;
   int                  i, j, n;
   int                  compare;
   int                  rescl_compare;
   static char          func[]="TSS_list_diff";

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   key_ind_lst_fld = key;

   ESA_DIAG_printf(comp,3, "kwd ptr=%s", kwd);

   ESA_DIAG_printf(comp,3,
           "ess_lst_handle: used entries=%d subfield cntr=%d",
            ess_lst_handle->used_entries, ess_lst_handle->subf_cnt);

   ESA_DIAG_printf(comp,3,
           "get_lst_handle: used entries=%d subfield cntr=%d",
            get_lst_handle->used_entries, get_lst_handle->subf_cnt);

   /*** Special "FACILITY" keyword processing ***/

   if ( strcmp(kwd, "FACILITY") EQ 0 ) {
     rc = TSS_facility_diff(comp, item_func, key, ess_lst_handle,
                            get_lst_handle, (char *)kwd,  TSS_CMD_ADD,
                            TSS_CMD_REMOVE, cmd_handle, subf_names,
                            dest, msgs );
     goto exit;
   }

   /*** Special "RESCLASS" keyword processing ***/

   if ( strcmp(kwd, "ADMIN.RESCLASS") EQ 0 ) {
     TSS_convert_rescls_names(comp, ess_lst_handle);
     TSS_convert_rescls_names(comp, get_lst_handle);
   }

   /*** List compare loop ***/

   for (i=0; i LT ess_lst_handle->used_entries ; i++ ) {

     for (j=0; j LT get_lst_handle->used_entries ; j++ ) {

        if(strcmp(get_lst_handle->lst_data[j].field[0], "$$LIST_DONE$$")
                                           EQ 0 )
          continue;

        compare =  TSS_lst_compare(&ess_lst_handle->lst_data[i],
                                   &get_lst_handle->lst_data[j]);
        ESA_DIAG_printf(comp, 5,
                        "i=%d j=%d compare=%d", i, j, compare);

        /***  ADMIN.RESCLASS special processing ***/

        if ( strcmp(kwd, "ADMIN.RESCLASS") EQ 0 ) {
           compare = abs(compare);
           key_ind_lst_fld = key + 1; /* Change key index */
           rescl_compare=TSS_lst_compare(&ess_lst_handle->lst_data[i],
                                         &get_lst_handle->lst_data[j]);
           ESA_DIAG_printf(comp, 5,
                           "i=%d j=%d rescl_compare=%d",
                           i, j, rescl_compare);
           compare += abs(rescl_compare);
           key_ind_lst_fld = key; /* Return back key index */
        }

        if (compare EQ 0) {
          compare = TSS_compare_subfields(comp,
                                   get_lst_handle->subf_cnt,
                                   &ess_lst_handle->lst_data[i],
                                   &get_lst_handle->lst_data[j]);
          if (compare NE 0 )   { /* Subfields changes detected */

             /*  Delete "GET" entry  */

             ESA_DIAG_printf(comp, 5, "Delete");
             for (n=0; n LT get_lst_handle->subf_cnt; n++) {
                ESA_DIAG_printf(comp,5, "%3d %3d %s", j ,n,
                                get_lst_handle->lst_data[j].field[n]);
             }

             rc = (item_func)(comp,TSS_ITEM_DEL,
                              kwd, del_cmd, cmd_handle,
                              get_lst_handle->subf_cnt,
                              &get_lst_handle->lst_data[j],
                              subf_names, dest, msgs);
             if (rc NE ESA_OK)
               goto exit;

             /*  Add "ESS" entry  */

             ESA_DIAG_printf(comp, 5, "Add");
             for (n=0; n LT ess_lst_handle->subf_cnt; n++) {
                ESA_DIAG_printf(comp,5, "%3d %3d %s", i, n,
                                ess_lst_handle->lst_data[i].field[n]);
             }

             rc = (item_func)(comp,TSS_ITEM_ADD,
                              kwd, add_cmd, cmd_handle,
                              ess_lst_handle->subf_cnt,
                              &ess_lst_handle->lst_data[i],
                              subf_names, dest, msgs);
             if (rc NE ESA_OK)
               goto exit;

          }    /* Subfields changes detected */
          strcpy(ess_lst_handle->lst_data[i].field[0],"$$LIST_DONE$$");
          strcpy(get_lst_handle->lst_data[j].field[0],"$$LIST_DONE$$");
          break;   /*  BS2316  */
        }      /* The main kwd fields are Equal */
     }
   }

   /*** Check ESS list ***/

   for (i=0; i LT ess_lst_handle->used_entries ; i++ ) {
     if(strcmp(ess_lst_handle->lst_data[i].field[0], "$$LIST_DONE$$")
                                           EQ 0 )
          continue;

     /*  Add "ESS" entry  */

     ESA_DIAG_printf(comp, 5, "Add");
     for (n=0; n LT ess_lst_handle->subf_cnt; n++) {
        ESA_DIAG_printf(comp,5, "%3d %3d %s",  i, n,
                        ess_lst_handle->lst_data[i].field[n]);
     }

     rc = (item_func)(comp,TSS_ITEM_ADD,
                      kwd, add_cmd, cmd_handle,
                      ess_lst_handle->subf_cnt,
                      &ess_lst_handle->lst_data[i],
                      subf_names, dest, msgs);
     if (rc NE ESA_OK)
       goto exit;

   }

   /*** Check GET list ***/

   for (j=0; j LT get_lst_handle->used_entries ; j++ ) {
     if(strcmp(get_lst_handle->lst_data[j].field[0], "$$LIST_DONE$$")
                                           EQ 0 )
          continue;

     /*  Delete "GET" entry  */

     ESA_DIAG_printf(comp, 5, "Delete");
     for (n=0; n LT get_lst_handle->subf_cnt; n++) {
        ESA_DIAG_printf(comp,5, "%3d %3d %s",  j, n,
                        get_lst_handle->lst_data[j].field[n]);
     }

     rc = (item_func)(comp,TSS_ITEM_DEL,
                      kwd, del_cmd, cmd_handle,
                      get_lst_handle->subf_cnt,
                      &get_lst_handle->lst_data[j],
                      subf_names, dest, msgs);
     if (rc NE ESA_OK)
       goto exit;

   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}    /* TSS_list_diff */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_set_simple_item                      *
*                                                             *
* Description      : Set simple item                          *
*                                                             *
* Input            : comp           -  diag component         *
*                    item_mode      -  mode ADD/DELETE        *
*                    kwd            -  main keyword name      *
*                    item_cmd       -  command for set item   *
*                    subf_cnt       -  subfields number       *
*                    cmd_handle     -  command handle         *
*                    lst_data       -  current list data      *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : List description looks like :            *
*                                                             *
*  { NULL       , RTT_KEY, TSS_CMD_ADD,  TSS_CMD_REMOVE},     *
*                                                             *
**************************************************************/

static ESA_RC TSS_set_simple_item(ESA_DIAG_COMP_typ      comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst_data,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC                rc = ESA_OK;
   int                   key = key_ind_lst_fld;
   char                 *main_kwd  = NULL;
   static char           func[]="TSS_set_simple_item";
   /* WS10082N char                  value[TSS_ADDINFO_VAL_LEN+1]; */\
   char                  value[ADDINFO_16K_VAL_LEN+1];    /* WS10082N */
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };    */
   TSS_CMD_SET_rec_typ  main_cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   key = 0;       /* Always for simple item ! */
   subf_cnt = 0;  /* Always for simple item ! */

   /*  Key must has the value, no value means "ALL"  */

   if ( strlen(lst_data->field[key]) EQ 0)
     strcpy(lst_data->field[key], "ALL" );

  /*
   *  Build command with main keyword from list
   *  The main_keyword can be :
   *   - general keyword "kwd" from parameter to function
   */

   if ( kwd NE NULL )  /* main_kwd = kwd from parameter */
      main_kwd = kwd;
   else {
      if (subf_names[key].subf_name EQ NULL) {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "CTSTSRV",
                       func, "Cannot be obtained main field name",
                       8, __LINE__);
         rc = ESA_FATAL;
         OS_MVS_btrace();
         goto exit;
      }
       else   /* main_kwd = key subfield name  */
         main_kwd = (char *)subf_names[key].subf_name;
   }

   /*  Set command type  */

   if (item_mode EQ TSS_ITEM_ADD)
     main_cmd.type = subf_names[key].add_cmd;
   else
     main_cmd.type = subf_names[key].del_cmd;

   TSS_check_quotes(lst_data->field[key], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param, main_kwd, value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest,msgs);
   if ( rc NE ESA_OK )
     goto exit;

   /*  Build main_cmd in form : main_kwd(main_subf_value)  */

   sprintf(main_cmd.param, "%s(%s) ", main_kwd, value);

   ESA_DIAG_printf(comp,3, "main_cmd=%s", main_cmd.param);

   /*  Put command to buffer  */

   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_simple_item  */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_set_admin_res_item                   *
*                                                             *
* Description      : Set admin  resource item                 *
*                                                             *
* Input            : comp           -  diag component         *
*                    item_mode      -  mode ADD/DELETE        *
*                    kwd            -  main keyword name      *
*                    item_cmd       -  command for set item   *
*                    subf_cnt       -  subfields number       *
*                    cmd_handle     -  command handle         *
*                    lst_data       -  current list data      *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : List descriptions looks like :           *
*                                                             *
*  { NULL       , RTT_KEY, TSS_CMD_ADMIN,  TSS_CMD_DEADMIN},  *
*  { "ACCESS"   , RTT_KEY, TSS_CMD_ADMIN,  TSS_CMD_IGNORE  }, *
*                                                             *
**************************************************************/

static ESA_RC TSS_set_admin_res_item(ESA_DIAG_COMP_typ   comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst_data,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC                rc = ESA_OK;
   int                   i;
   int                   key = key_ind_lst_fld;
   char                 *main_kwd  = NULL;
   char                 *item_name = NULL;
   static char           func[]="TSS_set_admin_res_item";
   /* WS10082N char                  value[TSS_ADDINFO_VAL_LEN+1]; */
   char                  value[ADDINFO_16K_VAL_LEN+1];    /* WS10082N */
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };      */
   TSS_CMD_SET_rec_typ  main_cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   key = 0;       /* Always for admin item ! */
   subf_cnt = 1;  /* Always for admin item ! */

   /*  Key must has the value, no value means "ALL"  */

   if ( strlen(lst_data->field[key]) EQ 0)
      strcpy(lst_data->field[key], "ALL");

   if ( kwd NE NULL )  /* main_kwd = kwd from parameter */
      main_kwd = kwd;
   else {
      if (subf_names[key].subf_name EQ NULL) {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "CTSTSRV",
                       func, "Cannot be obtained main field name",
                       8, __LINE__);
         rc = ESA_FATAL;
         OS_MVS_btrace();
         goto exit;
      }
      else   /* main_kwd = key subfield name  */
         main_kwd = (char *)subf_names[key].subf_name;
   }

   TSS_check_quotes(lst_data->field[key], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param, main_kwd, value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest,msgs);
   if ( rc NE ESA_OK )
     goto exit;

   /*  Build main_cmd in form : main_kwd(main_subf_value) */

   sprintf(main_cmd.param, "%s(%s) ", main_kwd, value);

   ESA_DIAG_printf(comp,3, "main_cmd=%s", main_cmd.param);

   i = subf_cnt;

   /*  Check subfield name for append parameter to main_cmd */

   if (subf_names[i].subf_name EQ NULL) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    "CTSTSRV", func,
                    "Cannot be obtained sub field name",
                    i, __LINE__);
      rc = ESA_FATAL;
      OS_MVS_btrace();
      goto exit;
   }
   else   /* subfield name */
      item_name = (char *)subf_names[i].subf_name;

   ESA_DIAG_printf(comp,3, "%3d %s=%s",
                   i, item_name, lst_data->field[i]);

   if (item_mode EQ TSS_ITEM_ADD)
      main_cmd.type = subf_names[0].add_cmd;
   else
      main_cmd.type = subf_names[0].del_cmd;

   /* Add subparameter */

   if ( (item_mode EQ TSS_ITEM_ADD)         AND
        (strlen(lst_data->field[i]) GT 0 )    ) {

       ESA_DIAG_printf(comp,3, "i=%d rtt_type=%d value=%d/%s",
                       i, subf_names[i].rtt_typ,
                       strlen(lst_data->field[i]),
                       lst_data->field[i]);

       TSS_check_quotes(lst_data->field[i], value);
       rc=TSS_check_param_overflow(comp, main_cmd.param,item_name,value,
                                   TSS_LENGTH_UNDEFINED,
                                   MAX_TSS_PARAM_LEN,
                                   dest, msgs);
       if ( rc NE ESA_OK )
         goto exit;

       strcat(main_cmd.param, item_name);
       strcat(main_cmd.param, "(");
       strcat(main_cmd.param, value);
       strcat(main_cmd.param, ") ");
   }

   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_admin_res_item  */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_set_sub_key_item                     *
*                                                             *
* Description      : Set admin scope ,... items               *
*                                                             *
* Input            : comp           -  diag component         *
*                    item_mode      -  mode ADD/DELETE        *
*                    kwd            -  main keyword name      *
*                    item_cmd       -  command for set item   *
*                    subf_cnt       -  subfields number       *
*                    cmd_handle     -  command handle         *
*                    lst_data       -  current list data      *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : List description looks like :            *
*                                                             *
**************************************************************/

static ESA_RC TSS_set_sub_key_item(ESA_DIAG_COMP_typ     comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst_data,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC                rc = ESA_OK;
   int                   i;
   int                   key = key_ind_lst_fld;
   char                 *main_kwd  = NULL;
   char                 *item_name = NULL;
   static char           func[]="TSS_set_sub_key_item";
   /* WS10082N char                  value[TSS_ADDINFO_VAL_LEN+1]; */
   char                  value[ADDINFO_16K_VAL_LEN+1];    /* WS10082N */
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };     */
   TSS_CMD_SET_rec_typ  main_cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /* Update key, subf_cnt parameters */

   ESA_DIAG_printf(comp,3, "key=%d subf_cnt=%d", key, subf_cnt);

   key      = 0;
   subf_cnt = 1;

   /* Get main cmd */

   if ( kwd NE NULL )  /* main_kwd = kwd from parameter */
      main_kwd = kwd;
   else {
      if (subf_names[key].subf_name EQ NULL) {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "CTSTSRV",
                       func, "Cannot be obtained main field name",
                       8, __LINE__);
         rc = ESA_FATAL;
         OS_MVS_btrace();
         goto exit;
      }
      else   /* main_kwd = key subfield name  */
        main_kwd = (char *)subf_names[key].subf_name;
   }

   main_cmd.type = item_cmd;
   TSS_check_quotes(lst_data->field[key], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param, main_kwd, value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest,msgs);
   if ( rc NE ESA_OK )
     goto exit;

   /*  Build main_cmd in form : main_kwd(main_subf_value, */

   sprintf(main_cmd.param, "%s(%s,", main_kwd, value);

   ESA_DIAG_printf(comp,3, "main_cmd=%s", main_cmd.param);

   i = subf_cnt;

   /*  Check subfield name for append parameter to main_cmd */

   if (subf_names[i].subf_name EQ NULL) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    "CTSTSRV", func,
                    "Cannot be obtained sub field name",
                    i, __LINE__);
      rc = ESA_FATAL;
      OS_MVS_btrace();
      goto exit;
   }
   else   /* subfield name */
      item_name = (char *)subf_names[i].subf_name;

   if ( strlen(lst_data->field[i]) EQ 0 ) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    "CTSTSRV", func,
                    "Subfield value missing",
                    i, __LINE__);
      rc = ESA_FATAL;
      OS_MVS_btrace();
      goto exit;
   }

   ESA_DIAG_printf(comp,3, "%3d %s=%s",
                   i, item_name, lst_data->field[i]);

   ESA_DIAG_printf(comp,3, "i=%d rtt_type=%d value=%d/%s",
                   i, subf_names[i].rtt_typ,
                   strlen(lst_data->field[i]),
                   lst_data->field[i]);

   TSS_check_quotes(lst_data->field[i], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param,item_name,value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest, msgs);
   if ( rc NE ESA_OK )
     goto exit;

  /*
   *   Subfield parameter - SUB_KEY_LAST, SUB_KEY_LASTB
   *   if field value not empty append like sub parameter
   *   The difference between : SUB_KEY_LAST, SUB_KEY_LASTB
   *   SUB_KEY_LAST   -  append parameter
   *   SUB_KEY_LASTB  -  append parameter with brackets
   */

   if ( (subf_names[i].rtt_typ  EQ RTT_SUB_KEY_LAST ) OR
        (subf_names[i].rtt_typ  EQ RTT_SUB_KEY_LASTB)  ) {
      if (subf_names[i].rtt_typ  EQ RTT_SUB_KEY_LAST ) {
          strcat(main_cmd.param, value);
          strcat(main_cmd.param, ") ");
      }
      else if (subf_names[i].rtt_typ  EQ RTT_SUB_KEY_LASTB) {
          strcat(main_cmd.param, "(");
          strcat(main_cmd.param, value);
          strcat(main_cmd.param, ")) ");
      }
   }

   /*   Change command type */

   if (item_mode EQ TSS_ITEM_ADD)
     main_cmd.type = subf_names[i].add_cmd;
   else
     main_cmd.type = subf_names[i].del_cmd;

   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_sub_key_item */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_set_facility_item                    *
*                                                             *
* Description      : Set facility item                        *
*                                                             *
* Input            : comp           -  diag component         *
*                    item_mode      -  mode ADD/DELETE        *
*                    kwd            -  main keyword name      *
*                    item_cmd       -  command for set item   *
*                    subf_cnt       -  subfields number       *
*                    cmd_handle     -  command handle         *
*                    lst_data       -  current list data      *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : List description looks like :            *
* {"FACILITY"       ,RTT_KEY, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"ACTION"         ,RTT_KEY, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"UNTIL"          ,RTT_KEYT_FACILITY,                       *
*                             TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"DAYS"           ,RTT_KEY, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"TIMES"          ,RTT_KEY, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* ----------------------------------------------------------- *
* {"AUDIT"          ,RTT_FLG, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"NOTIFY"         ,RTT_FLG, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"DENY"           ,RTT_FLG, TSS_CMD_ADD,   TSS_CMD_REMOVE },*
* {"MODE"           ,RTT_KEY, TSS_CMD_PERMIT,TSS_CMD_REVOKE },*
*                                                             *
**************************************************************/

static ESA_RC TSS_set_facility_item(ESA_DIAG_COMP_typ    comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst_data,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC                rc = ESA_OK;
   int                   i;
   int                   key = key_ind_lst_fld;
   int                   first_action_flag = 1;
   char                 *wptr;
   char                 *main_kwd  = NULL;
   char                 *item_name = NULL;
   static char           func[]="TSS_set_facility_item";
   /*WS10082 char        value[TSS_ADDINFO_VAL_LEN+1];            */
   char                  value[ADDINFO_16K_VAL_LEN+1];   /*WS10082*/
   /*WS10082 char        tmp[TSS_ADDINFO_VAL_LEN+1];              */
   char                  tmp[MAX_TSS_PARAM_LEN+1];       /*WS10082*/
   char                  date_format[20];
   char                  tss_date[20];
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };        */
   TSS_CMD_SET_rec_typ  main_cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /*   Check entered parameters */

   /*   1. Does not obtained kwd ptr and subfields ptr */

   if ( (kwd EQ NULL ) AND  (subf_names EQ NULL) ) {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               "CTSTSRV", func, "Cannot be obtained item field name",
               8, __LINE__);
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   /*   2. Key index exceed a maximum sub field counter */

   if ( key GE subf_cnt ) {
     if (subf_names[key].rtt_typ NE RTT_SUB_KEY_OPT ) {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     "CTSTSRV", func,
                     "Cannot be obtained main field name",
                     8, __LINE__);
       rc = ESA_FATAL;
       OS_MVS_btrace();
       goto exit;
     }
   }

   /*   3. Key subfield must has the value */
   /*      If no, its means value "ALL"    */

   if ( strlen(lst_data->field[key]) EQ 0)
      strcpy(lst_data->field[key], "ALL");

  /*
   *  For building command we use the following terms :
   *  main_keyword - the keyword ,
   *                 appeared first in form main_key(main_subf_value)
   *  main_cmd     - command structure, consists string above
   *  Each subfield of list appended to main command and saved in
   *  command buffer.
   */

   /*  Determine main keyword value  */

   if ( kwd NE NULL )  /* main_kwd = kwd from parameter */
      main_kwd = kwd;
   else {
      if (subf_names[key].subf_name EQ NULL) {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "CTSTSRV",
                       func, "Cannot be obtained main field name",
                       8, __LINE__);
         rc = ESA_FATAL;
         OS_MVS_btrace();
         goto exit;
      }
      else   /* main_kwd = key subfield name  */
        main_kwd = (char *)subf_names[key].subf_name;
   }

   main_cmd.type = item_cmd;
   TSS_check_quotes(lst_data->field[key], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param, main_kwd, value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest, msgs);
   if ( rc NE ESA_OK )
     goto exit;

   /*  Build main_cmd in form : main_kwd(main_subf_value) */

   sprintf(main_cmd.param, "%s(%s) ", main_kwd, value);

   ESA_DIAG_printf(comp,3, "main_cmd=%s", main_cmd.param);

   ESA_DIAG_printf(comp,3,
                   "ADD=%d DEL=%d: entering cmd mode=%d subf_cnt=%d",
                    TSS_ITEM_ADD, TSS_ITEM_DEL, item_mode, subf_cnt);

   if ( item_mode EQ TSS_ITEM_ADD ) {

      /*  Subfields loop */

      for (i=1; i LT subf_cnt; i++) {

        /*  Check subfield name for append parameter to main_cmd */

        if (subf_names[i].subf_name EQ NULL) {
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                         "CTSTSRV", func,
                         "Cannot be obtained sub field name",
                         i, __LINE__);
           rc = ESA_FATAL;
           OS_MVS_btrace();
           goto exit;
        }
        else   /* subfield name */
          item_name = (char *)subf_names[i].subf_name;

        ESA_DIAG_printf(comp,3, "%3d %s=%s",
                        i, item_name, lst_data->field[i]);

        ESA_DIAG_printf(comp,3, "i=%d rtt_type=%d value=%d/%s",
                        i, subf_names[i].rtt_typ,
                        strlen(lst_data->field[i]),
                        lst_data->field[i]);

        TSS_check_quotes(lst_data->field[i], value);
        rc=TSS_check_param_overflow(comp,main_cmd.param,item_name,value,
                                    TSS_LENGTH_UNDEFINED,
                                    MAX_TSS_PARAM_LEN,
                                    dest, msgs);
        if ( rc NE ESA_OK )
         goto exit;

        /*  Subfield parameter - FLAG (OLD version)*/
        /*  ACTION subfield                        */

        if (subf_names[i].rtt_typ  EQ RTT_FLG ) {
          if (strcmp(lst_data->field[i], KWD_FLAG_OFF) EQ 0 )
            continue;

          if (first_action_flag) {               /* First ACTION val */
            strcat(main_cmd.param, " ACTION(" ); /* Build field */
            first_action_flag = 0;
          }
          else {                                 /* Append ACTION val*/
            wptr = strrchr(main_cmd.param, ')'); /* Remove prev delim*/
            if ( wptr ) {
              *wptr     = ',';
              *(wptr+1) = NULL_CHAR;
            }
          }

          strcat(main_cmd.param, item_name);     /* Append parameter */
          strcat(main_cmd.param, ") ");
        }    /* RTT_FLG */

        /*  Subfield parameter - KEY */

        else if (subf_names[i].rtt_typ  EQ RTT_KEY ) {
          if ( strlen(lst_data->field[i]) EQ 0 )
              continue;
         /*
          *  Special DAYS, TIMES fiels processing
          */

          if ( ( (strcmp(item_name, "DAYS")  EQ 0 ) AND
                 (strcmp(value,     "ALL" )  EQ 0 )   )
                      OR
               ( (strcmp(item_name, "TIMES") EQ 0 ) AND
                 (strcmp(value,     "ANY" )  EQ 0 )   ) )
              continue;

         /*
          *  WS2360
          *  Special CALENDAR, TIMERES processing
          */

          if ( ( (strcmp(item_name, "CALENDAR")  EQ 0 ) AND
                 (strcmp(value,     "*NONE*"  )  EQ 0 )   )
                      OR
               ( (strcmp(item_name, "TIMEREC")   EQ 0 ) AND
                 (strcmp(value,     "*NONE*" )   EQ 0 )   ) )
              continue;

          /*  Put parameter */

          strcat(main_cmd.param, item_name);
          strcat(main_cmd.param, "(");
          strcat(main_cmd.param, value);
          strcat(main_cmd.param, ") ");
        }     /* RTT_KEY */

        /*  Subfield parameter - KEYT          (time subfield) */
        /*  Subfield parameter - KEYT_FACILITY (time subfield) */

        else if ( (subf_names[i].rtt_typ  EQ RTT_KEYT ) OR
                  (subf_names[i].rtt_typ  EQ RTT_KEYT_FACILITY)) {
          if ( strlen(lst_data->field[i]) EQ 0 )
              continue;

          /*  Get TSS RSS Option "DATE" ( format of date )  */

          rc = TSS_get_global_parameter(comp,  TSS_GLOBAL_DATE_FORMAT,
                                        date_format, dest, msgs);
          if ( rc NE ESA_OK )  {
             strcpy( date_format, TSS_DATE_FORMAT_DEFAULT);
             rc = ESA_OK;
          }

          ESA_DIAG_printf(comp, 3, "date format=%s", date_format);

          if (subf_names[i].rtt_typ  EQ RTT_KEYT_FACILITY ) {

             /*  Special FACILITY UNTIL field processing */

             memcpy( tmp,      lst_data->field[i],     4 );   /* YYYY */
             memcpy(&tmp[4], &(lst_data->field[i][5]), 2 );   /* MM   */
             memcpy(&tmp[6], &(lst_data->field[i][8]), 2 );   /* DD   */
             tmp[8] = NULL_CHAR;
          }
          else
             strcpy(tmp, lst_data->field[i]);

          /*  Convert date (ess_addinfo) */

          rc = TSS_ConvertDateESS2TSS( comp, date_format, tmp, tss_date,
                                       dest, msgs );
          if ( rc NE ESA_OK )
            goto exit;

          strcat(main_cmd.param, item_name);
          strcat(main_cmd.param, "(");
          strcat(main_cmd.param, tss_date);
          strcat(main_cmd.param, ") ");
        }    /* RTT_KEYT, RTT_KEYT_FACILITY */
      }      /* for (i=1; i LT subf_cnt; i++) */
   }       /* TSS_ITEM_ADD */

   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);
   if ( rc NE ESA_OK ) {
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_facility_item  */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_set_sub_opt_item                     *
*                                                             *
* Description      : Set optional items                       *
*                                                             *
* Input            : comp           -  diag component         *
*                    item_mode      -  mode ADD/DELETE        *
*                    kwd            -  main keyword name      *
*                    item_cmd       -  command for set item   *
*                    subf_cnt       -  subfields number       *
*                    cmd_handle     -  command handle         *
*                    lst_data       -  current list data      *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : List description looks like :            *
*                                                             *
* {"LTIME" ,  RTT_SUB_KEY_FRST,TSS_CMD_ADD,TSS_CMD_REMOVE },  *
* {"FACILITY",RTT_SUB_KEY_OPT ,TSS_CMD_ADD,TSS_CMD_REMOVE },  *
*                                                             *
**************************************************************/

static ESA_RC TSS_set_sub_opt_item(ESA_DIAG_COMP_typ     comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst_data,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC                rc = ESA_OK;
   int                   i;
   int                   key = key_ind_lst_fld;
   char                 *main_kwd  = NULL;
   char                 *item_name = NULL;
   static char           func[]="TSS_set_sub_opt_item";
   /* WS10082N char                  value[TSS_ADDINFO_VAL_LEN+1]; */
   char                  value[ADDINFO_16K_VAL_LEN+1];    /* WS10082N */
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };    */
   TSS_CMD_SET_rec_typ  main_cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   key = 1;       /* Always for simple item ! */
   subf_cnt = 0;  /* Always for simple item ! */

   /*  Determine main keyword value  */

   if ( kwd NE NULL )  /* main_kwd = kwd from parameter */
      main_kwd = kwd;
   else {
      if (subf_names[key].subf_name EQ NULL) {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "CTSTSRV",
                       func, "Cannot be obtained main field name",
                       8, __LINE__);
         rc = ESA_FATAL;
         OS_MVS_btrace();
         goto exit;
      }
      else   /* main_kwd = key subfield name  */
        main_kwd = (char *)subf_names[key].subf_name;
   }

   main_cmd.type = item_cmd;
   TSS_check_quotes(lst_data->field[key], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param,main_kwd,value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest,msgs);
   if ( rc NE ESA_OK )
     goto exit;

   /* Build command header  */

   sprintf(main_cmd.param, "%s(", main_kwd);

   ESA_DIAG_printf(comp,3, "main_cmd=%s", main_cmd.param);

   i = subf_cnt;

   ESA_DIAG_printf(comp,3, "i=%d rtt_type=%d value=%d/%s",
                   i, subf_names[i].rtt_typ,
                   strlen(lst_data->field[i]),
                   lst_data->field[i]);

   TSS_check_quotes(lst_data->field[i], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param,item_name,value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest,msgs);
   if ( rc NE ESA_OK )
     goto exit;

   /*   Append parameter  */

   strcat(main_cmd.param, value);

   /*   Check optional parameter val length */

   if  (strlen(lst_data->field[i+1]) EQ 0 )
       strcat(main_cmd.param, ") ");
   else {         /* SYB_KEY_OPT will bring facility name */
       strcat(main_cmd.param, ",");
       TSS_check_quotes(lst_data->field[i+1], value);
       rc=TSS_check_param_overflow(comp,main_cmd.param,item_name,value,
                                   TSS_LENGTH_UNDEFINED,
                                   MAX_TSS_PARAM_LEN,
                                   dest, msgs);
       if ( rc NE ESA_OK )
        goto exit;
       strcat(main_cmd.param, value);
       strcat(main_cmd.param, ") ");
   }

   /*  Determine command type */

   if (item_mode EQ TSS_ITEM_ADD)
     main_cmd.type = subf_names[i].add_cmd;
   else
     main_cmd.type = subf_names[i].del_cmd;

   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_sub_opt_item  */

/**************************************************************
*                                                             *
* Procedure Name   : TSS_set_admin_rescls_item                *
*                                                             *
* Description      : Set admin resclass item                  *
*                                                             *
* Input            : comp           -  diag component         *
*                    item_mode      -  mode ADD/DELETE        *
*                    kwd            -  main keyword name      *
*                    item_cmd       -  command for set item   *
*                    subf_cnt       -  subfields number       *
*                    cmd_handle     -  command handle         *
*                    lst_data       -  current list data      *
*                    subf_names     -  subfield names table   *
*                                                             *
* Output           : None                                     *
*                                                             *
* Return Value     : ESA_OK, ESA_FATAL                        *
*                                                             *
* Notes            : List description looks like :            *
*                                                             *
* { NULL     , RTT_FLDN, TSS_CMD_ADMIN, TSS_CMD_DEADMIN },    *
* { NULL     , RTT_FLDV, TSS_CMD_ADMIN, TSS_CMD_DEADMIN },    *
* { "ACCESS" , RTT_KEY,  TSS_CMD_ADMIN, TSS_CMD_IGNORE  },    *
*                                                             *
**************************************************************/

static ESA_RC TSS_set_admin_rescls_item(ESA_DIAG_COMP_typ   comp,
                            TSS_ITEM_MODE_typ            item_mode,
                            char                       * kwd,
                            TSS_CMD_typ                  item_cmd,
                            TSS_CMD_HANDLE_typ         * cmd_handle,
                            int                          subf_cnt,
                            TSS_LST_DATA_typ           * lst_data,
                            TSS_SUBF_typ                 subf_names[1],
                            CTSAMSG_DEST_TABLE_rec_ptr   dest,
                            CTSAMSG_HANDLE_rec_ptr       msgs)
{

   ESA_RC                rc = ESA_OK;
   int                   i;
   int                   key = key_ind_lst_fld;
   char                 *main_kwd  = NULL;
   char                 *item_name = NULL;
   static char           func[]="TSS_set_admin_rescls_item";
   /* WS10082N char                  value[TSS_ADDINFO_VAL_LEN+1]; */
   char                  value[ADDINFO_16K_VAL_LEN+1];    /* WS10082N */
   /* IS10092 TSS_CMD_SET_rec_typ main_cmd = { 0, "", 0 };        */
   TSS_CMD_SET_rec_typ   main_cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   key      = 0;       /* Always for admin resclass item ! */
   subf_cnt = 2;       /* Always for admin resclass item ! */

   /*  1. Key subfield must has the value */

   if ( strlen(lst_data->field[key]) EQ 0) {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, "CTSTSRV", func,
                   "Main field value missing", 8, __LINE__);
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
   }

   /* Obtain main keyword name */

   main_kwd      = lst_data->field[key];

   /*  Main cmd value  */

   if ( strlen(lst_data->field[key+1]) EQ 0)
      strcpy(lst_data->field[key+1], "ALL");

   TSS_check_quotes(lst_data->field[key+1], value);
   rc=TSS_check_param_overflow(comp, main_cmd.param, main_kwd, value,
                               TSS_LENGTH_UNDEFINED,
                               MAX_TSS_PARAM_LEN,
                               dest, msgs);
   if ( rc NE ESA_OK )
     goto exit;
   sprintf(main_cmd.param, "%s(%s) ", main_kwd, value);

  /*
   *  Index 0 - main key name
   *  Index 1 - main key value
   */

   i = subf_cnt;

   /*  Check subfield name for append parameter to main_cmd */

   if (subf_names[i].subf_name EQ NULL) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    "CTSTSRV", func,
                    "Cannot be obtained sub field name",
                    i, __LINE__);
      rc = ESA_FATAL;
      OS_MVS_btrace();
      goto exit;
   }
   else   /* subfield name */
     item_name = (char *)subf_names[i].subf_name;

   ESA_DIAG_printf(comp,3, "%3d %s=%s",
                   i, item_name, lst_data->field[i]);

   if (item_mode EQ TSS_ITEM_ADD)
      main_cmd.type = TSS_CMD_ADMIN;
   else
      main_cmd.type = TSS_CMD_DEADMIN;

   /* Add subparameter */

   if ( ( strlen(lst_data->field[i] ) GT 0 ) AND
        ( main_cmd.type NE TSS_CMD_DEADMIN)    ) {
      ESA_DIAG_printf(comp,3, "i=%d rtt_type=%d value=%d/%s",
                      i, subf_names[i].rtt_typ,
                      strlen(lst_data->field[i]),
                      lst_data->field[i]);

      TSS_check_quotes(lst_data->field[i], value);
      rc=TSS_check_param_overflow(comp,main_cmd.param,item_name, value,
                                  TSS_LENGTH_UNDEFINED,
                                  MAX_TSS_PARAM_LEN,
                                  dest, msgs);
      if ( rc NE ESA_OK )
        goto exit;

      /* Append parameter */

       strcat(main_cmd.param, item_name);
       strcat(main_cmd.param, "(");
       strcat(main_cmd.param, value);
       strcat(main_cmd.param, ") ");
   }

   rc = TSS_put_cmd(comp, cmd_handle, &main_cmd, dest, msgs);

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}     /* TSS_set_admin_rescls_item   */

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_do_revoke_status                       *
 *                                                             *
 * DESCRIPTION    : User params (revoke status) processing     *
 *                                                             *
 * INPUT          : user_params                                *
 *                  addinfo                                    *
 *                  get_user_params                            *
 *                  get_addinfo                                *
 *                  cmd_handle                                 *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/
/********************** WS10082 *******************************
 * This function handles onlyrevoke status attriute. so no    *
 * need to handle long values.                                *
 ********************** WS10082 *******************************/

 ESA_RC TSS_do_revoke_status(ESA_DIAG_COMP_typ           comp,
                             TSS_CMD_HANDLE_typ        * cmd_handle,
                             USER_PARAMS_rec_typ       * essu_params,
                             ADDINFO_rec_typ           * ess_addinfo,
                             USER_PARAMS_rec_typ       * getu_params,
                             ADDINFO_rec_typ           * get_addinfo,
                             CTSAMSG_DEST_TABLE_rec_ptr  dest,
               /* WS10009    CTSAMSG_HANDLE_rec_ptr      msgs); */
               /* WS10009 */ CTSAMSG_HANDLE_rec_ptr      msgs,
               /* WS10009 */ ADMIN_PARAMS_rec_typ      * admin_params)
 {

   ESA_RC              rc = ESA_OK;
   static char         func[]="TSS_do_revoke_status";
   ONE_FIELD_rec_ptr   cpair;
   /* IS10092 TSS_CMD_SET_rec_typ cmd = { 0, "", 0 };               */
   TSS_CMD_SET_rec_typ  cmd = { 0, "", 0, 0 };            /* IS10092 */
   char                 valc[TSS_ADDINFO_VAL_LEN+1];
   ONE_FIELD_rec_ptr    ess_pair = NULL;
   ONE_FIELD_rec_ptr    get_pair = NULL;
   TSS_PARAMS_rec_typ * params_ptr = NULL;               /* WS10009 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);


   rc = TSS_set_resumes(comp, get_addinfo, ess_addinfo, dest, msgs);
   if ( rc NE ESA_OK )
    goto exit;

  /*
   *  User revoke status changes
   */

   if ( essu_params->rev_status NE USER_STAT_IGNORED ) {

 /* IS10136: If a User_STA user_params'rev_status received from ess/iiq
    is revoked, we issue ADD SUSPEND in any event without checking
    current rev_status in TSS.
      if ( (essu_params->rev_status EQ USER_STAT_REVOKED) AND
           (getu_params->rev_status EQ USER_STAT_ACTIVE )   ) { */
      if ( (essu_params->rev_status EQ USER_STAT_REVOKED)){ /*IS10136*/
         cmd.type = TSS_CMD_ADD;
         strcpy(cmd.param, "SUSPEND ");
         TSS_add_resumes_field(comp, TSS_CMD_ADD,
                               cmd.param, ess_addinfo, dest, msgs);
         rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
         if ( rc NE ESA_OK )
           goto exit;
      }
      else if ( (essu_params->rev_status EQ USER_STAT_ACTIVE ) AND
                (getu_params->rev_status EQ USER_STAT_REVOKED) ) {

        /*
         *  Check INFO.SUSPEND_TYPE field
         */
     /*  WS10009 - The following code replaced by calling to a new
         function: TSS_find_suspend_type                              */
     /*  cpair=ADDINFO_search("INFO.SUSPEND_TYPE", TSS_ADDINFO_KWD_LEN,
                           get_addinfo->pair, get_addinfo->num_pairs);

         ESA_DIAG_printf(comp,3, "INFO.SUSPEND_TYPE=%x", cpair);
         if ( cpair NE NULL )
            ESA_DIAG_printf(comp,3, "INFO.SUSPEND_TYPE=%s",
                            cpair->value);  */
         /* WS10009  - use function: TSS_find_suspend_type  - start   */
         rc = TSS_find_suspend_type(comp, get_addinfo, cmd.param);
         ESA_DIAG_printf(comp,3, "1. SUSPEND_TYPE=%s", cmd.param);
         /* WS10009  - use function: TSS_find_suspend_type  - end     */
         cmd.type = TSS_CMD_REMOVE;
     /*  WS10009: continue: replacing code                          */
     /*  if ( cpair EQ NULL )
            strcpy(cmd.param,"SUSPEND ");
         else if (strcmp(cpair->value, "ASUSPEND") EQ 0 )
            strcpy(cmd.param,"ASUSPEND "); */
         /* start of ws2483 */
     /*  else if (strcmp(cpair->value, "XSUSPEND") EQ 0 )
            strcpy(cmd.param,"XSUSPEND ");
         else if (strcmp(cpair->value, "VSUSPEND") EQ 0 )
            strcpy(cmd.param,"VSUSPEND ");
         else if (strcmp(cpair->value, "PSUSPEND") EQ 0 )
            strcpy(cmd.param,"PSUSPEND "); */
         /* end of ws2483 */
     /*  else
            strcpy(cmd.param,"SUSPEND ");  */
     /*  WS10009: end replacing code                              */

         TSS_add_resumes_field(comp, TSS_CMD_REMOVE,
                               cmd.param, get_addinfo, dest, msgs);
         rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
         if ( rc NE ESA_OK )
           goto exit;
      }
   }     /* essu_params->rev_status NE USER_STAT_IGNORED */
   else {      /* Check resumes field */

    ess_pair=ADDINFO_search( "RESUMES",
                             TSS_ADDINFO_KWD_LEN,
                             ess_addinfo->pair,
                             ess_addinfo->num_pairs);
    get_pair=ADDINFO_search( "RESUMES",
                             TSS_ADDINFO_KWD_LEN,
                             get_addinfo->pair,
                             get_addinfo->num_pairs);

    if ( get_pair EQ NULL ) {
      sprintf(internal2_msg_buf,
              "Unable to locate parameter '%s'",  "RESUMES" );
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    "CTSTSRV", func, internal2_msg_buf,
                    8, __LINE__);
      OS_MVS_btrace();
      rc = ESA_FATAL;
      goto exit;
    }

    if ( ess_pair EQ NULL )          /* WS10009 */
      goto find_ru_locked;           /* WS10009 */
    ESA_DIAG_printf(comp,3, "RESUMES: get=%d/%s IIQ/IDN=%d/%s",
                    get_pair->vallen, get_pair->value,
                    ess_pair->vallen, ess_pair->value);

  /*  WS10009 - The following code replaced by calling to a new
      function: TSS_find_suspend_type                            */
  /*cpair=ADDINFO_search("INFO.SUSPEND_TYPE", TSS_ADDINFO_KWD_LEN,
                         get_addinfo->pair, get_addinfo->num_pairs);

    ESA_DIAG_printf(comp,3, "INFO.SUSPEND_TYPE=%x", cpair);
    if ( cpair NE NULL )
       ESA_DIAG_printf(comp,3, "INFO.SUSPEND_TYPE=%s",
                       cpair->value);

    if ( cpair EQ NULL )
      strcpy(valc, "SUSPEND ");
    else if (strcmp(cpair->value, "ASUSPEND") EQ 0 )
      strcpy(valc, "ASUSPEND ");  */
    /* start of ws2483 */
  /*else if (strcmp(cpair->value, "XSUSPEND") EQ 0 )
      strcpy(valc, "XSUSPEND ");
    else if (strcmp(cpair->value, "VSUSPEND") EQ 0 )
      strcpy(valc, "VSUSPEND ");
    else if (strcmp(cpair->value, "PSUSPEND") EQ 0 )
      strcpy(valc, "PSUSPEND "); */
    /* end of ws2483 */
  /*else
      strcpy(valc, "SUSPEND ");  */
  /*  WS10009: end replacing code                              */

   /*
    *  Build commands
    *  This code is activated when RESUMES (date) field is cleared
    */

    /* WS10009  - use function: TSS_find_suspend_type  - start   */
    rc = TSS_find_suspend_type(comp, get_addinfo, valc);
    ESA_DIAG_printf(comp,3, "2. SUSPEND_TYPE=%s", valc);
    /* WS10009  - Use function: TSS_find_suspend_type  - end     */
    if ( ( ess_pair->vallen EQ 0 ) AND
         ( get_pair->vallen GT 0 )   ) {
    /* RESUMES date is cleared */
       cmd.type = TSS_CMD_REMOVE;
       sprintf(cmd.param, "%s %s", valc, "UNTIL");
       rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
       if ( rc NE ESA_OK )
         goto exit;
      /*
       * Return back revoke status
       */
       /* WS10009  - find if RU_SUSPENDED is on    - start  */
       cpair = TSS_find_RU_keys(comp,"RU_SUSPENDED",ess_addinfo);
       if ( cpair NE NULL)
         if (strcmp(cpair->value,KWD_FLAG_OFF) NE 0)
           cpair = NULL ;
       if ( cpair EQ NULL)
         {
       /* WS10009  - find if RU_SUSPENDED is on    - end    */
         cmd.type = TSS_CMD_ADD;
         strcpy(cmd.param, "SUSPEND");
         rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
         if ( rc NE ESA_OK )
           goto exit;
         }         /* WS10009 */
    }
    else if ( ( ess_pair->vallen GT 0 ) AND
              ( get_pair->vallen GT 0 )   ) {
       cmd.type = TSS_CMD_ADD;
       sprintf(cmd.param, "%s %s(%s)",
               "SUSPEND", "UNTIL", ess_pair->value);
       rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
       if ( rc NE ESA_OK )
         goto exit;
    }
    else if ( ( ess_pair->vallen GT 0 ) AND
              ( get_pair->vallen EQ 0 )   ) {
       if (getu_params->rev_status EQ USER_STAT_REVOKED) {
          cmd.type = TSS_CMD_REMOVE;
          strcpy(cmd.param, valc);
          rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
          if ( rc NE ESA_OK )
            goto exit;
       }

      /*
       * Set suspend until status
       */

       cmd.type = TSS_CMD_ADD;
       sprintf(cmd.param, "%s %s(%s)",
               "SUSPEND", "UNTIL", ess_pair->value);
       rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
       if ( rc NE ESA_OK )
         goto exit;
    }

   }
   /********************* WS10009 starts **********************/
   find_ru_locked:;

   params_ptr = admin_params->apiinit_handle;
   ESA_DIAG_printf(comp, 3,
                  "params_ptr = <%X>",params_ptr);
   ESA_DIAG_printf(comp, 3,
        "vector values are: A<%c>, P<%c>, V<%c>, X<%c>",
        params_ptr->rssparm_REVOKE_TYPES['A'],
        params_ptr->rssparm_REVOKE_TYPES['P'],
        params_ptr->rssparm_REVOKE_TYPES['V'],
        params_ptr->rssparm_REVOKE_TYPES['X']);

   cpair = TSS_find_RU_keys(comp,"RU_LOCKED",ess_addinfo);
   if ( cpair NE NULL)
     {
     if (strcmp(cpair->value,KWD_FLAG_OFF) EQ 0)
       {
        ESA_DIAG_printf(comp, 3,
                     "RU_LOCKED is off");
        /*******************************************************/
        /* create TSS command to remove SUSPEND attribute      */
        /* only for LOCKED_TYPES                               */
        /*******************************************************/
        rc = TSS_find_suspend_type(comp, get_addinfo, cmd.param);
        /* match RSSPARM's LOCKED_TYPES with suspend type
           value in TSS */
        if ((strcmp(cmd.param, "PSUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['P'] == 'L') OR
            (strcmp(cmd.param, "VSUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['V'] == 'L') OR
            (strcmp(cmd.param, "XSUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['X'] == 'L') OR
            (strcmp(cmd.param, "ASUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['A'] == 'L'))
        {
          cmd.type = TSS_CMD_REMOVE;
          rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
          if ( rc NE ESA_OK )
            goto exit;
        }
      }
   }
   cpair = TSS_find_RU_keys(comp,"RU_SUSPENDED",ess_addinfo);
   if ( cpair NE NULL AND
        essu_params->rev_status EQ USER_STAT_IGNORED)
                           /* no revoke status changed */
     {
      /*******************************************************/
      /* create TSS command to remove SUSPEND attribute      */
      /* only for SUSPENDED_TYPES                            */
      /*******************************************************/
      if (strcmp(cpair->value,KWD_FLAG_OFF) EQ 0)
        {
        rc = TSS_find_suspend_type(comp, get_addinfo, cmd.param);
        /* match RSSPARM's SUSPENDED_TYPES with suspend type
           value in TSS */

        if ((strcmp(cmd.param, "PSUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['P'] == 'S') OR
            (strcmp(cmd.param, "VSUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['V'] == 'S') OR
            (strcmp(cmd.param, "XSUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['X'] == 'S') OR
            (strcmp(cmd.param, "ASUSPEND ") EQ 0 AND
             params_ptr->rssparm_REVOKE_TYPES['A'] == 'S'))
          cmd.type = TSS_CMD_REMOVE;
        }
      else
          {
          cmd.type = TSS_CMD_ADD;
          strcpy(cmd.param,"SUSPEND ");
          }
        rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
        if ( rc NE ESA_OK )
          goto exit;
   }
   /********************* WS10009 end    **********************/

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_do_password                            *
 *                                                             *
 * DESCRIPTION    : User params password fields processing     *
 *                                                             *
 * INPUT          : user_params                                *
 *                  addinfo                                    *
 *                  cmd_handle                                 *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_do_password(ESA_DIAG_COMP_typ           comp,
                        TSS_CMD_HANDLE_typ        * cmd_handle,
                        USER_PARAMS_rec_typ       * user_params,
                        ADDINFO_rec_typ           * addinfo,
                        CTSAMSG_DEST_TABLE_rec_ptr  dest,
                        CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC              rc = ESA_OK;
   ESA_RC              rcd= ESA_OK;                       /* IS10183 */
   static char         func[]="TSS_do_password";
   ONE_FIELD_rec_ptr   cpair;
   int                 passwd_life_updated;
   int                 password_updated;
   int                 interval_updated;
   /* IS10092 TSS_CMD_SET_rec_typ cmd = { 0, "", 0 };             */
   TSS_CMD_SET_rec_typ  cmd = { 0, "", 0, 0 };     /* IS10092 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   cmd.type = TSS_CMD_REPLACE;

  /*
   *    user_params->passwd field processing
   */

   /* IS10173 - start */
   /*if ( strcmp( user_params->passwd,"\\") NE 0 )     */
   if ( (strcmp(user_params->passwd, BACKSLASH_STR) NE 0)
    AND (strcmp(user_params->passwd, BACKSLASH_ALT) NE 0) )
    /* IS10173 - end */
   {
     ESA_DIAG_printf(comp, 3, "password updated");        /*IS10091*/
     password_updated = TRUE;
     if (strlen(user_params->passwd) GE MIN_RSS_PSWDPHRS_LEN) /*IS10147A*/
       sprintf(cmd.param, "PHRASE('%s'", user_params->passwd);/*IS10147A*/
     /* IS10147A if (strlen(user_params->passwd) GT 0 )               */
     if ( (strlen(user_params->passwd) GT 0) AND          /* IS10147A */
          (strlen(user_params->passwd) LT MIN_RSS_PSWDPHRS_LEN) ) /*IS10147A*/
         sprintf(cmd.param, "PASSWORD(%s", user_params->passwd);
     /* IS10147A else                                                 */
     if (strlen(user_params->passwd) EQ 0)                /* IS10147A */
       strcpy(cmd.param, "PASSWORD(NOPW");
     /* IS10183
     ESA_DIAG_printf(comp,3,"password cmd: <%s>",cmd.param);/@IS10091@/
     */
   }
   else
   {
     password_updated = FALSE;
     strcpy(cmd.param, "PASSWORD(*");
     /* IS10183
     ESA_DIAG_printf(comp,3,"pswd false: <%s>",cmd.param); /@IS10091@/
     */
     ESA_DIAG_printf(comp,3,"pswd false");                 /*IS10183*/
   }

  /*
   *    INTERVAL field processing
   */

   cpair=ADDINFO_search("INTERVAL", TSS_ADDINFO_KWD_LEN,
                        addinfo->pair, addinfo->num_pairs);
   if ( cpair NE NULL )
   {
      ESA_DIAG_printf(comp,3,"INTERVAL exists");       /*IS10091*/
      interval_updated = TRUE;
      strcat(cmd.param, ",");
      if ( (cpair->vallen EQ 0 )            OR
           (strcmp(cpair->value, "NO" ) EQ 0 )  )
        strcat(cmd.param, "0");
      else
        strcat(cmd.param, cpair->value);

     /* IS10183
     ESA_DIAG_printf(comp,3,"pswd updated <%s>",cmd.param);/@IS10091@/
     */
     ESA_DIAG_printf(comp,3,"pswd updated with INTERVAL"); /*IS10183*/
   }
   else
     interval_updated = FALSE;

  /*
   *    user_params->passwd_life field processing
   */

   if (user_params->passwd_life EQ PASS_LIFE_RESET)
   {
     passwd_life_updated = TRUE;
     ESA_DIAG_printf(comp,3,"PASS_LIFE_RESET");/*IS10091*/
     if ( NOT interval_updated )
       strcat(cmd.param, ",");
     strcat(cmd.param, ",EXPIRED) ");

     /* IS10183
     ESA_DIAG_printf(comp,3,"pswd at reset <%s>",cmd.param);/@IS10091@/
     */
     ESA_DIAG_printf(comp,3,"pswd reset");                 ;/*IS10183*/
   }
   else if (user_params->passwd_life EQ PASS_LIFE_PERMANENT )
   {
     ESA_DIAG_printf(comp,3,"PASS_LIFE_PERMANENT");         /*IS10091*/
     passwd_life_updated = TRUE;
     strcat(cmd.param, ") ");
   }
   else
   {
     ESA_DIAG_printf(comp,3,"No PASS_LIFE_PERMANENT");      /*IS10091*/
     passwd_life_updated = FALSE;
     strcat(cmd.param, ") ");
   }

   /* IS10183 - start */
   rcd = TSS_hidepsw_and_issue_diag(
                 comp,
                 3,
                 cmd.param,
                 "password cmd = ");

   if (rcd NE ESA_OK)
     ESA_DIAG_printf(comp,3,"password cmd: <%s>",cmd.param);
   /* IS10183 - end   */

   if (passwd_life_updated OR password_updated OR interval_updated )
   {
     ESA_DIAG_printf(comp,3,"Call TSS_put_cmd");            /*IS10091*/
     rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}

 /********************* IS10020 start **************************
 *                                                             *
 * PROCEDURE NAME : TSS_set_password                           *
 *                                                             *
 * DESCRIPTION    : User params password fields processing     *
 *                                                             *
 * INPUT          : user_params                                *
 *                  addinfo                                    *
 *                  cmd_handle                                 *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_set_password(ESA_DIAG_COMP_typ           comp,
                         char                      * cmd_buffer,
                         USER_PARAMS_rec_typ       * user_params,
        /*               ADDINFO_rec_typ           * addinfo, */
                         CTSAMSG_DEST_TABLE_rec_ptr  dest,
                         CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC              rc = ESA_OK;
   ESA_RC              rcd= ESA_OK;                /* IS10183 */
   static char         func[]="TSS_set_password";
   int                 passwd_life_updated=0;
   int                 password_updated=0;
   int                 interval_updated=0;
   /* IS10077 TSS_CMD_SET_rec_typ cmd = { 0, "", 0 };             */
   TSS_CMD_SET_rec_typ  cmd = { 0, "", 0, 0 };     /* IS10077 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   /* IS10020 cmd.type = TSS_CMD_REPLACE; set already */

  /*
   *    user_params->passwd field processing
   */
   /* IS10173 - start */
   /*if ( strcmp( user_params->passwd,"\\") NE 0 )*/
   if ( (strcmp(user_params->passwd, BACKSLASH_STR) NE 0)
    AND (strcmp(user_params->passwd, BACKSLASH_ALT) NE 0) )
   /* IS10173 - end */
   {
     ESA_DIAG_printf(comp, 3, "password updated");        /*WS10034A*/
     password_updated = TRUE;
     if (strlen(user_params->passwd) GE MIN_RSS_PSWDPHRS_LEN) /*IS10147A*/
       sprintf(cmd.param, "PHRASE('%s'", user_params->passwd);/*IS10147A*/
     /* IS10147A if (strlen(user_params->passwd) GT 0 )               */
     if ( (strlen(user_params->passwd) GT 0) AND          /* IS10147A */
          (strlen(user_params->passwd) LT MIN_RSS_PSWDPHRS_LEN) ) /*IS10147A*/
       sprintf(cmd.param, "PASSWORD(%s", user_params->passwd);
     /* IS10147A else                                                 */
     if (strlen(user_params->passwd) EQ 0)                /* IS10147A */
       strcpy(cmd.param, "PASSWORD(NOPW");
     /* IS10183
     ESA_DIAG_printf(comp,3,"password cmd: <%s>",cmd.param);/@WS10034A@/
     */
   }
   else
   {
     password_updated = FALSE;
     strcpy(cmd.param, "PASSWORD(*");
     /* IS10183
     ESA_DIAG_printf(comp,3,"pswd false: <%s>",cmd.param); /@WS10034A@/
     */
     ESA_DIAG_printf(comp,3,"pswd false");                /* IS10183 */
   }
  /*
   *    user_params->passwd_life field processing
   */

   if (user_params->passwd_life EQ PASS_LIFE_RESET)
   {
     passwd_life_updated = TRUE;
     ESA_DIAG_printf(comp,3,"PASS_LIFE_RESET");/*WS10034A*/
     if ( NOT interval_updated )
       strcat(cmd.param, ",");
     strcat(cmd.param, ",EXPIRED) ");
     /* IS10183
     ESA_DIAG_printf(comp,3,"pswd at reset <%s>",cmd.param);/@WS10034A@/
     */
     ESA_DIAG_printf(comp,3,"pswd reset");                 /* IS10183 */
   }
   else if (user_params->passwd_life EQ PASS_LIFE_PERMANENT )
   {
     ESA_DIAG_printf(comp,3,"PASS_LIFE_PERMANENT");         /*WS10034A*/
     passwd_life_updated = TRUE;
     strcat(cmd.param, ") ");
   }
   else
   {
     ESA_DIAG_printf(comp,3,"No PASS_LIFE_PERMANENT");      /*WS10034A*/
     passwd_life_updated = FALSE;
     strcat(cmd.param, ") ");
   }
   strcat(cmd_buffer, cmd.param);                          /*IS10020*/
   /* IS10183 - start */
   rcd = TSS_hidepsw_and_issue_diag(
                 comp,
                 3,
                 cmd_buffer,
                 "cmd_buffer = ");

   if (rcd NE ESA_OK)
   /* IS10183 - end   */
   ESA_DIAG_printf(comp,3,"cmd_buffer=<%s>",cmd_buffer);   /*IS10020*/
   /* IS10020
   if (passwd_life_updated OR password_updated OR interval_updated )
    {
     ESA_DIAG_printf(comp,3,"Call TSS_put_cmd");             *WS10034A*
     rc = TSS_put_cmd(comp, cmd_handle, &cmd, dest, msgs);
    } ************************************IS10020*/

  /*
   *    Finish
   */

  exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_remove_lsca_scope                      *
 *                                                             *
 * DESCRIPTION    : Remove LSCA scope                          *
 *                                                             *
 * INPUT          : user_params                                *
 *                  addinfo                                    *
 *                  dest                                       *
 *                  msgs                                       *
 *                                                             *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_remove_lsca_scope(ESA_DIAG_COMP_typ   comp,
                           TSS_RTT_rec_typ               rtt_table[1],
                           char                        * acid,
                           ADDINFO_rec_typ             * addinfo,
                           ADMIN_PARAMS_rec_typ        * admin_params)
 {

   ESA_RC                        rc = ESA_OK;
   static char                   func[]="TSS_remove_lsca_scope";
   CTSAMSG_DEST_TABLE_rec_ptr    dest;
   CTSAMSG_HANDLE_rec_ptr        msgs;
   ONE_FIELD_rec_ptr             admin_scope;
   ONE_FIELD_rec_typ             empty_pair;
   TSS_CMD_HANDLE_typ           *cmd_handle  = NULL;
   TSS_RTT_rec_typ              *kwd_desc;
   SET_VAR_FUNC_typ             *set_var_func_ptr;


  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

  /*
   *   Get ADMIN.SCOPE field value
   */

   admin_scope = ADDINFO_search("ADMIN.SCOPE", TSS_ADDINFO_KWD_LEN,
                                addinfo->pair, addinfo->num_pairs);
   if (admin_scope EQ NULL)
     goto exit;

   ESA_DIAG_printf(comp, 3,
                   "ADMIN.SCOPE keyword located %d/%s",
                    strlen(admin_scope->value), admin_scope->value);

   if ( strlen(admin_scope->value) EQ 0 )
     goto exit;

   /*  Create command handle  */

   rc = TSS_alloc_cmd_handle (ESA_COMP_ADDUSER,
                              MAX_TSS_CMD_USER_ENTRIES,
                              &cmd_handle, dest, msgs );
   if ( rc NE ESA_OK )
      goto exit;

   /*  Locate keyword description  */

   kwd_desc = TSS_get_field_desc(comp, "ADMIN.SCOPE", rtt_table,
                                 dest, msgs);
   if (kwd_desc EQ NULL) {
      ESA_DIAG_printf(comp,3, "Keyword=%s not supporetd",
                      "ADMIN.SCOPE");
      CTSAMSG_print(ERR_ADI_KEYWORD_NOSUPP, msgs, NULL, dest,
                    "ADMIN.SCOPE");
      goto exit;
   }

   /*  Prepare parameters for create command */

   strcpy(empty_pair.keyword, kwd_desc->addinfo_keyword);
   empty_pair.keylen    = strlen(kwd_desc->addinfo_keyword);
   empty_pair.value[0]  = NULL_CHAR;
   empty_pair.vallen    = 0;
   empty_pair.add_typ   = kwd_desc->addinfo_typ;

   /* Obtain func ptr and call to appropriate function */

   set_var_func_ptr = kwd_desc->set_var_func_ptr;
   if (set_var_func_ptr EQ NULL) {
      sprintf(internal2_msg_buf ,
           "Unable to determine function for set keyword %s.(value=%s)",
           admin_scope->keyword, admin_scope->value);
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component,func, internal2_msg_buf,
                    16,__LINE__);
      OS_MVS_btrace();
      goto exit;
   }

   rc = (set_var_func_ptr) (comp, cmd_handle, rtt_table,
                            kwd_desc, &empty_pair, addinfo,
                            addinfo, dest, msgs) ;
   if (rc NE ESA_OK)
     goto exit;

   rc = TSS_do_cmd( comp, acid, TYPE_USER, TSS_EVNT_ACTION_UPDATE,
                    cmd_handle, admin_params);
  /*
   *    Finish
   */

   exit:;

   if (cmd_handle)
      TSS_free_cmd_handle( comp, &cmd_handle, dest, msgs);

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_check_moving                           *
 *                                                             *
 * DESCRIPTION    : Check whether need MOVE operation          *
 *                                                             *
 * INPUT          : ess_acid          -   user/group           *
 *                  ess_parent_acid   -   parent_oe    ess     *
 *                  ess_addinfo       -   addinfo from ess     *
 *                  get_parent_acid   -   parent_oe    get     *
 *                  get_addinfo       -   addinfo from get     *
 *                  admin_params                               *
 *                  err                                        *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC TSS_check_moving(ESA_DIAG_COMP_typ             comp,
                         char                        * obj_type,
                         TSS_RTT_rec_typ               rtt_table[1],
                         char                        * ess_acid,
                         char                        * ess_parent_acid,
                         ADDINFO_rec_typ             * ess_addinfo,
                         char                        * get_acid,
                         char                        * get_parent_acid,
                         ADDINFO_rec_typ             * get_addinfo,
                         OBJECT_TYPE_typ               onli_acid_type,
                         ADMIN_PARAMS_rec_typ        * admin_params,
                         ERR_STRUCT_rec_typ          * err)
 {

   ESA_RC                       rc = ESA_OK;
   static char                  func[]="TSS_check_moving";
   char                       * acid_type;
   char                       * parent_acid;
   int                          do_move = 0;
   char                         parent_type[TSS_ACID_TYPE_LEN];
   char                         p_acid[TSS_ACID_TYPE_LEN];
   char                         root_name[MAX_TSS_PARAM_LEN];
   CTSAMSG_HANDLE_rec_typ     * msgs;
   CTSAMSG_DEST_TABLE_rec_typ * dest;
   TSS_CMD_BUF_rec_typ          cmd = { 0, 0, "" };
   TSS_ACID_HEADER_rec_typ      acid_info;
   ONE_FIELD_rec_ptr            ess_obj_type;
   ONE_FIELD_rec_ptr            get_obj_type;
   ONE_FIELD_rec_ptr            pair = NULL;                /*IS10091*/
   int                          move_due_to_type_upd = 0;   /*IS10091*/
   int                          move_due_to_acid_upd = 0;   /*IS10091*/
   int           move_due_to_ParentContainerACID_upd = 0;   /*IS10091*/

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 3, func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   TSS_use_root_object(comp,root_name,dest,msgs);

  /*
   *  Determine whether USER_TYPE/UG_TYPE/OE_TYPE has been changed
   */

   get_obj_type=ADDINFO_search( obj_type,
                                TSS_ADDINFO_KWD_LEN,
                                get_addinfo->pair,
                                get_addinfo->num_pairs);
   if ( get_obj_type EQ NULL )
   {
      rc = ESA_FATAL;
      sprintf(internal2_msg_buf,
              "Unable to locate parameter %s", obj_type);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    "CTSTSRV", func, internal2_msg_buf,
                    8, __LINE__);
      OS_MVS_btrace();
      goto exit;
   }

   acid_type = get_obj_type->value;   /* keep ptr to TYPE val */

   ESA_DIAG_printf(comp,3, "get_addinfo: %s=%s",
                   obj_type, get_obj_type->value);

   ess_obj_type=ADDINFO_search(  obj_type,
                                 TSS_ADDINFO_KWD_LEN,
                                 ess_addinfo->pair,
                                 ess_addinfo->num_pairs);
   if ( ess_obj_type NE NULL )
   {
       acid_type = ess_obj_type->value; /*keep ptr to TYPE val*/

       ESA_DIAG_printf(comp,3, "ess_addinfo: %s=%s",
                       obj_type, ess_obj_type->value);

       do_move   = 1;
       move_due_to_type_upd = 1;                           /*IS10091*/
   }

  /*
   *  Determine whether parent has been changed
   */

   parent_acid = get_parent_acid;

   ESA_DIAG_printf(comp,3, "get_parent acid=%s", get_parent_acid);
   ESA_DIAG_printf(comp,3, "ess_parent acid=%s", ess_parent_acid);

   /* IS10173 - start */
   /*if (strcmp(ess_parent_acid, "\\") NE 0 )*/
   if ( (strcmp(ess_parent_acid, BACKSLASH_STR) NE 0)
   AND  (strcmp(ess_parent_acid, BACKSLASH_ALT) NE 0) )
   /* IS10173 - end */
   {
      parent_acid = ess_parent_acid;
      do_move   = 1;
      move_due_to_acid_upd = 1;                            /*IS10091*/
   }

   /* IS10091 start */
   if (NOT move_due_to_acid_upd)
   {/*if decided to move already based on acid upd, disregard new kw*/
    pair = ADDINFO_search( "ParentContainerACID", TSS_ADDINFO_KWD_LEN,
                           ess_addinfo->pair, ess_addinfo->num_pairs );

    if ( pair NE NULL ) /*ParentContainerACID received from ESS/IIQ*/
    {
     ESA_DIAG_printf(comp,3,"essParentContainerACID=<%s>",pair->value);
     if (strcmp(get_parent_acid,pair->value) NE 0 ) /*old = new ?*/
     {
      ESA_DIAG_printf(comp,3, "essParentContainerACID NE current");
      parent_acid = pair->value;
      ess_parent_acid = parent_acid;
      ESA_DIAG_printf(comp,3,"ess_parent acid=%s",ess_parent_acid);
      do_move   = 1;
      move_due_to_ParentContainerACID_upd = 1;
      ESA_DIAG_printf(comp,3,
                      "Going to MOVE based on ParentContainerACID");
     }
     else
      ESA_DIAG_printf(comp,3,"new = old ParentContainer");

    }
   }
   /* IS10091 end */

  /*
   *  MOVE command not necessary
   */

   ESA_DIAG_printf(comp,3, "do_move=%d", do_move);

   if ( NOT do_move )
      goto exit;

   strcpy(p_acid, parent_acid);

  /*
   *  Here we determine that should be done move.
   *  Check next time whether was obtained parent acid
   *  if no, we must determine it ourself
   */

   /* IS10173 - start */
   /*if (strcmp(ess_parent_acid, "\\") EQ 0 )*/
   if ( (strcmp(ess_parent_acid, BACKSLASH_STR) EQ 0)
     OR (strcmp(ess_parent_acid, BACKSLASH_ALT) EQ 0) )
   /* IS10173 - end */
   {
      /*  Be aware : Root ! */

      if ( strcmp (get_parent_acid, root_name) EQ 0 )
      {
        strcpy(acid_info.acid,      root_name);
        strcpy(acid_info.type,      TSS_ROOT_TYPE);
        strcpy(acid_info.dept_acid, "");
        strcpy(acid_info.div_acid,  "");
        strcpy(acid_info.zone_acid, "");
      }
      else
      {
        /*  Get parent acid parameters */

        rc = TSS_get_acid_header(comp, TSS_CMD_DEFAULT_MODE,
                                 get_parent_acid, &acid_info,
                                 admin_params, err);
        if ( rc NE ESA_OK )
           goto exit;
      }

      ESA_DIAG_printf(comp, 3, "ACID=%s",      acid_info.acid);
      ESA_DIAG_printf(comp, 3, "ACID_TYPE=%s", acid_info.type);
      ESA_DIAG_printf(comp, 3, "DEPT_ACID=%s", acid_info.dept_acid);
      ESA_DIAG_printf(comp, 3, "DIV_ACID=%s",  acid_info.div_acid);
      ESA_DIAG_printf(comp, 3, "ZONE_ACID=%s", acid_info.zone_acid);

      ESA_DIAG_printf(comp, 3, "parent acid=%s/%s",
                      get_parent_acid, acid_info.acid);

      if ( strcmp(get_parent_acid, acid_info.acid) NE 0 )
      {
         CTSAMSG_print(TSS_ERR_NO_ACID, msgs, NULL,
                       dest, acid_type, get_parent_acid );
         rc = ESA_ERR;
         goto exit;
      }

     /*
      * Set p_acid according acid_type
      */

      if ( strcmp(acid_type, TSS_DCA) EQ 0 )
      {
         if ( strlen(acid_info.dept_acid) GT 0 )
         {
           strcpy (p_acid, acid_info.dept_acid);
           strcpy (parent_type, TSS_DEPARTMENT);
         }
         else if ( strcmp(acid_info.type, TSS_DEPARTMENT) EQ 0 )
         {
           strcpy (p_acid, acid_info.acid);
           strcpy (parent_type, TSS_DEPARTMENT);
         }
         else
         {
           strcpy (p_acid, root_name);
           strcpy (parent_type, TSS_ROOT_TYPE);
         }
      }
      else if ( strcmp(acid_type, TSS_VCA) EQ 0 )
      {
         if ( strlen(acid_info.div_acid) GT 0 )
         {
           strcpy (p_acid, acid_info.div_acid);
           strcpy (parent_type, TSS_DIVISION);
         }
         else if ( strcmp(acid_info.type, TSS_DIVISION) EQ 0 )
         {
           strcpy (p_acid, acid_info.acid);
           strcpy (parent_type, TSS_DIVISION);
         }
         else
         {
           strcpy (p_acid, root_name);
           strcpy (parent_type, TSS_ROOT_TYPE);
         }
      }
      else if ( strcmp(acid_type, TSS_ZCA) EQ 0 )
      {
         if ( strlen(acid_info.zone_acid) GT 0 )
         {
           strcpy (p_acid, acid_info.zone_acid);
           strcpy (parent_type, TSS_ZONE);
         }
         else if ( strcmp(acid_info.type, TSS_ZONE) EQ 0 )
         {
           strcpy (p_acid, acid_info.acid);
           strcpy (parent_type, TSS_ZONE);
         }
         else
         {
           strcpy (p_acid, root_name);
           strcpy (parent_type, TSS_ROOT_TYPE);
         }
      }
      else if ( strcmp(acid_type, TSS_DEPARTMENT) EQ 0 )
      {
         if ( strlen(acid_info.div_acid) GT 0 )
         {
           strcpy (p_acid, acid_info.div_acid);
           strcpy (parent_type, TSS_DIVISION);
         }
         else
         {
           strcpy (p_acid, root_name);
           strcpy (parent_type, TSS_ROOT_TYPE);
         }
      }
      else if ( strcmp(acid_type, TSS_DIVISION) EQ 0 )
      {
         if ( strlen(acid_info.zone_acid) GT 0 )
         {
           strcpy (p_acid, acid_info.zone_acid);
           strcpy (parent_type, TSS_ZONE);
         }
         else
         {
           strcpy (p_acid, root_name);
           strcpy (parent_type, TSS_ROOT_TYPE);
         }
      }
      else if ( strcmp(acid_type, TSS_USER) EQ 0 )
      {
         if ( strlen(acid_info.acid) GT 0 )
         {
           strcpy (p_acid, acid_info.acid);
           strcpy (parent_type, TSS_DEPARTMENT);
         }
         else
         {
           strcpy (p_acid, root_name);
           strcpy (parent_type, TSS_ROOT_TYPE);
         }
      }
      else
      {
         strcpy (p_acid, root_name);
         strcpy (parent_type, TSS_ROOT_TYPE);
      }

      /** Now validation ... **/

      rc = TSS_validate_acid_type(comp, acid_type, parent_type,
                                  p_acid, admin_params, err );
      if ( rc NE ESA_OK )
      {
        rc = ESA_FATAL;
        goto exit;
      }
   }
   else
   {
      rc = TSS_validate_acid_type(comp, acid_type, parent_type,
                                  p_acid, admin_params, err );
      if ( rc NE ESA_OK )
      {
        rc = ESA_FATAL;
        goto exit;
      }
   }

  /*
   *  If ACID was LSCA type and has a "ADMIN.SCOPE" parameter
   *  before MOVE command his scope must be removed
   */

   ESA_DIAG_printf(comp,3, "%s (LSCA ?) = %s/%s",
                   obj_type, get_obj_type->value, TSS_LSCA );

   if (strcmp(get_obj_type->value, TSS_LSCA ) EQ 0 )
   {
      rc = TSS_remove_lsca_scope(comp, rtt_table, ess_acid, get_addinfo,
                                 admin_params);
      if ( rc NE ESA_OK )
         goto exit;
   }

  /*
   *  Create command header
   */

   if ( strcmp (p_acid, root_name) NE 0 )
      sprintf(cmd.buffer, "MOVE(%s) %s(%s) TYPE(%s) ",
              ess_acid, parent_type, p_acid, acid_type);
   else
      sprintf(cmd.buffer, "MOVE(%s) TYPE(%s) ",
              ess_acid, acid_type);

   ESA_DIAG_printf(comp,3, "cmd.buffer=%s", cmd.buffer);

   cmd.max_len = strlen(cmd.buffer);
   cmd.use_len = strlen(cmd.buffer);

   rc = TSS_issue_cmd(comp, &cmd, ess_acid, onli_acid_type,
                      TSS_EVNT_ACTION_UPDATE, admin_params);
  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 3, func, rc);

   return rc;

}

/**************************************************************
*                                                             *
* PROCEDURE NAME : TSS_get_parent_oe                          *
*                                                             *
* DESCRIPTION    : Fill up the parent_oe field                *
*                                                             *
* INPUT          : addinfo         - addinfo area             *
*                  laddinfo        - local addinfo area       *
*                  dest                                       *
*                  msgs                                       *
*                                                             *
* OUTPUT         : parent_oe                                  *
*                  user_type                                  *
*                                                             *
* RETURN VALUE   : ESA_OK, ESA_FATAL                          *
*                                                             *
/**************************************************************/

ESA_RC TSS_get_parent_oe(ESA_DIAG_COMP_typ             comp,
                         char                        * t_kwd,
                         char                        * acid_type,
                         char                        * parent_oe,
                         ADDINFO_rec_ptr               addinfo,
                         ADDINFO_rec_ptr               laddinfo,
      /*IS10091          CTSAMSG_DEST_TABLE_rec_typ  * dest,
                         CTSAMSG_HANDLE_rec_typ      * msgs,
       * IS10091 */      ADMIN_PARAMS_rec_typ      *admin_params)
{

 static char func[]="TSS_get_parent_oe";

/*
 *   Variables
 */

 ESA_RC                rc = ESA_OK ;
 int                   i;
 ONE_FIELD_rec_ptr     pair;
 ONE_FIELD_rec_ptr     pair1;                             /* IS10091A */
 char                  acid[TSS_ADDINFO_KWD_LEN + 1]   = "";
 char                  root_name[MAX_TSS_PARAM_LEN + 1];
 char                 *parents[] = {
                                    "DEPT_ACID"  ,
                                    "DIV_ACID"   ,
                                    "ZONE_ACID"  ,
                                    NULL
                                   };

 char                 *parents_name[] = {                 /* IS10091A */
                                    "DEPT_NAME"  ,        /* IS10091A */
                                    "DIV_NAME"   ,        /* IS10091A */
                                    "ZONE_NAME"  ,        /* IS10091A */
                                    NULL                  /* IS10091A */
                                   };                     /* IS10091A */

 char                 *acid_types[] = {           /*IS10091*/
                                    "DEPT"  ,
                                    "DIV"   ,
                                    "ZONE"  ,
                                    NULL
                                   };
 CTSAMSG_HANDLE_rec_typ     * msgs;                    /*IS10091*/
 CTSAMSG_DEST_TABLE_rec_typ * dest;                    /*IS10091*/

/*
 *  Initialize
 */

 ESA_DIAG_enter(comp, 3, func );
 msgs = admin_params->ctsamsg_handle;                    /*IS10091*/
 dest = admin_params->ctsamsg_dest;                      /*IS10091*/

 strcpy(acid_type, "");

 pair = ADDINFO_search( "ACID", TSS_ADDINFO_KWD_LEN,
                        laddinfo->pair, laddinfo->num_pairs );
 if ( pair NE NULL )
    strcpy(acid, pair->value);

 pair = ADDINFO_search( "ACID_TYPE", TSS_ADDINFO_KWD_LEN,
                        laddinfo->pair, laddinfo->num_pairs );
 if ( pair EQ NULL )
 {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                   component, func,
                   "Unable to locate ACID_TYPE",
                   8, __LINE__);
     rc = ESA_FATAL;
     OS_MVS_btrace();
     goto exit;
 }

 ESA_DIAG_printf(comp, 3, "ACID_TYPE=%s", pair->value);

 strcpy(acid_type, pair->value);

 pair = ADDINFO_search( t_kwd, TSS_ADDINFO_KWD_LEN,
                        addinfo->pair, addinfo->num_pairs );
 if ( pair NE NULL )
   ADDINFO_addval(acid_type, TSS_ADDINFO_VAL_LEN,
                  ADDINFO_LIST_ENTRY, pair, dest, msgs );

/*
 *   Looking for parent
 */

 for (i=0; parents[i]; i++ )
 {
    pair = ADDINFO_search( parents[i], TSS_ADDINFO_KWD_LEN,
                           laddinfo->pair, laddinfo->num_pairs );
    if ( pair NE NULL )
    {
       strcpy(parent_oe, pair->value);
       /* IS10091 start */
       pair = ADDINFO_search("ParentContainerACID",
                             TSS_ADDINFO_KWD_LEN,
                             addinfo->pair, addinfo->num_pairs );
       if ( pair NE NULL )
         {
           ADDINFO_addval(parent_oe, TSS_ADDINFO_VAL_LEN,
                          ADDINFO_LIST_ENTRY, pair, dest, msgs );
           ESA_DIAG_printf(comp, 3, "ParentContainerACID=<%s>",
                           parent_oe);
         }
       pair = ADDINFO_search("ParentContainerType",
                             TSS_ADDINFO_KWD_LEN,
                             addinfo->pair, addinfo->num_pairs );
       if ( pair NE NULL )
         {
           ADDINFO_addval(acid_types[i], TSS_ADDINFO_VAL_LEN,
                          ADDINFO_LIST_ENTRY, pair, dest, msgs );
           ESA_DIAG_printf(comp, 3, "ParentContainerType=<%s>",
                           acid_types[i]);
         }
       /* IS10091 end  */
       /* IS10091A - start */
       pair = ADDINFO_search("ParentContainerName",
                             TSS_ADDINFO_KWD_LEN,
                             addinfo->pair, addinfo->num_pairs );
       if ( pair NE NULL )
         {
           pair1 = ADDINFO_search(parents_name[i],
                                  TSS_ADDINFO_KWD_LEN,
                    /*BS10083*/   laddinfo->pair,laddinfo->num_pairs );
                    /* BS10083  laddinfo->pair, addinfo->num_pairs );*/
           if ( pair1 NE NULL        AND
                pair1->vallen GT 0 )
                 ADDINFO_addval(pair1->value, TSS_ADDINFO_VAL_LEN,
                                ADDINFO_LIST_ENTRY, pair, dest, msgs );

           ESA_DIAG_printf(comp, 3, "ParentContainerName=<%s>",
                           acid_types[i]);
         }
       /* IS10091A - end   */
       goto exit;
    }
 }

/*
 *  The parent not found. So, ROOT
 */

 if ( TSS_use_root_object(comp,root_name,dest,msgs) )
 {                                                  /*IS10091*/
   ESA_DIAG_printf(comp, 3,"Root");                /*IS10091*/
   strcpy(parent_oe, root_name);
   /*IS10091 start */
   pair = ADDINFO_search("ParentContainerACID",TSS_ADDINFO_KWD_LEN,
                         addinfo->pair, addinfo->num_pairs );
   if ( pair NE NULL )
   {
    ADDINFO_addval(parent_oe, TSS_ADDINFO_VAL_LEN,
                   ADDINFO_LIST_ENTRY, pair, dest, msgs );
    ESA_DIAG_printf(comp, 3,
                    "ParentContainerACID is root=<%s>", parent_oe);
   }
   /*IS10091 end */
 }                                                   /*IS10091*/
 else
    strcpy(parent_oe, "" );

/*
 *  Finish
 */

 exit : ;

 ESA_DIAG_printf(comp, 3, "parent_oe=%s", parent_oe);

 ESA_DIAG_exit(comp, 3, func, rc);

 return rc ;

}

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_update_empty_segments                  *
 *                                                             *
 * DESCRIPTION    : Set empty segments                         *
 *                                                             *
 * INPUT          : addinfo     - addinfo ptr                  *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : none                                       *
 *                                                             *
 **************************************************************/

 static ESA_RC TSS_update_empty_segments(ESA_DIAG_COMP_typ    comp,
                                   ADDINFO_rec_ptr            addinfo,
                                   CTSAMSG_DEST_TABLE_rec_ptr dest,
                                   CTSAMSG_HANDLE_rec_ptr     msgs)
 {

  /*
   *  Variables
   */

   ESA_RC              rc = ESA_OK;
   static char         func[] = "TSS_update_empty_segments";
   ONE_FIELD_rec_ptr   pair = NULL;
   int                 i=0;
   int                 j=0;
   int                 len=0;
   int                 found;
   TSS_SGM_rec_typ   * tss_segments;
   char             ** segment_fields;


  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 5, func);

   tss_segments = TSS_get_global_segments();

   found = 0;

   for (i=0; tss_segments[i].artificial_field; i++) {
     segment_fields = tss_segments[i].segment_fields;
     len = 0;

    /*
     * Calculate total len of segment related fields
     */

     for (j=0; segment_fields[j]; j++) {
         pair = ADDINFO_search( segment_fields[j],
                                TSS_ADDINFO_KWD_LEN,
                                addinfo->pair, addinfo->num_pairs );
         if (pair NE NULL)
           len += pair->vallen;
     }

    /*
     * Set artificial segment field value
     */

     pair = ADDINFO_search( tss_segments[i].artificial_field,
                            TSS_ADDINFO_KWD_LEN,
                            addinfo->pair, addinfo->num_pairs );
     if ( pair NE NULL ) {
       if ( len EQ 0 )
         ADDINFO_updval(KWD_FLAG_ON,  TSS_ADDINFO_VAL_LEN, pair);
       else
         ADDINFO_updval(KWD_FLAG_OFF, TSS_ADDINFO_VAL_LEN, pair);
     }
   }

  /*
   *    Finish
   */

   exit:;

   ESA_DIAG_exit(comp, 5, func, rc);

   return rc;

}
 /*  IS10183 - start  */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TSS_hidepsw_and_issue_diag                 *
 *                                                             *
 * DESCRIPTION    : hide password/phrase and issue diag        *
 *                                                             *
 * INPUT          : comp        - diag component               *
 *                  diag_lvl    - diag level                   *
 *                  buffer      - the buffer to print          *
 *                  text        - text to add                  *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - OK  , ESA_FATAL - err             *
 *                                                             *
 **************************************************************/

 /* IS10184 ESA_RC TSS_hidepsw_and_issue_diag(  */
 static ESA_RC TSS_hidepsw_and_issue_diag(                /* IS10184 */
                      ESA_DIAG_COMP_typ            comp,
                      int                          diag_lvl,
                      char                       * buffer,
                      char                       * text)
 {

   ESA_RC                       rc = ESA_OK;
   static char                  func[]="TSS_hidepsw_and_issue_diag";
   char  *p          = NULL;
   char  *p1         = NULL;
   char  *hide_start = NULL;
   char  *post_start = NULL;
   char   astrx[101];
   int    j = 0;
   int    pre_len = 0;                                    /* IS10183 */
   int    pw_len = 0;                                     /* IS10183 */

  /*
   *    Initialize
   */

   ESA_DIAG_enter(comp, 1, func);


   if (ESA_DIAG_get_debug_level(comp)  GE diag_lvl)
   {
    p = strstr(buffer,"PASSWORD(");
    if (p NE NULL)
    {
       pre_len = strlen("PASSWORD(");
       hide_start = p + pre_len;
       pre_len = hide_start - buffer;
       p1 = strpbrk(hide_start,",)");
       if (p1 NE NULL)
          pw_len = p1 - hide_start;
    }
    else
    {
       p = strstr(buffer,"PHRASE('");
       if (p NE NULL)
       {
          pre_len = strlen("PHRASE('");
          hide_start = p + pre_len;
          pre_len = hide_start - buffer;
          p1 = strstr(hide_start,"'");
          if (p1 NE NULL)
             pw_len = p1 - hide_start;
       }
    }

    if (  (p NE NULL) AND (pw_len NE 0) )
    {
       post_start = hide_start + pw_len;
       pw_len= pw_len < sizeof(astrx) ? pw_len : sizeof(astrx)-1;
       for (j=0; j LE pw_len-1; j++)
           astrx[j] = '*';

           astrx[j] = NULL_CHAR;
           ESA_DIAG_printf( comp,0,
             "%s<%.*s%.*s%s>",
             text, pre_len, buffer, pw_len, astrx, post_start);
    }
    else
       rc = ESA_FATAL;
   }
   ESA_DIAG_exit(comp, 1, func, rc);
   return rc;
 }
 /*  IS10183 - end    */
