/**************************************************************
*                                                             *
*  <!><!> ATTENTION <!><!>                                    *
*  =-=-=-=-=-=-=-=-=-=-=-=                                    *
*                                                             *
*  When updating this member, do not forget to update         *
*  CTSORSS in ALL.CSRC as well.                               *
*                                                             *
*                                                             *
**************************************************************/
/**************************************************************
*                                                             *
*                                                             *
* Title            : API service functions for RACF           *
*                                                             *
* File Name        : ctsrrss.c                                *
*                                                             *
* Author           : Doron Cohen                              *
*                                                             *
* Creation Date    : 02/08/94                                 *
*                                                             *
* Description      :                                          *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------  -------------------------------- *
* ps0004   Alex     10/09/96 Adjust to new common code        *
* ps0117   Alex     23/06/97 Ignore non authorized callers    *
* ps0166   Alex     29/07/97 Minor changes to _set_authority  *
*                            program                          *
* ps0173   Alex     04/08/97 Fix bug                          *
* ps0320   Guy      22/10/98 Added new ACEE "CREATE" mode for *
*                            ACF2 6.2                         *
* bs2390   Alex     02/06/99 TSS commands fail with rc = 8    *
*                            return code 8 in SA-Agent scripts*
* ps0383   Alex     22/06/99 Change Login mechanizm for TSS   *
* bs2421   Yoni     21/02/00 Handle ACEE failure from create  *
* ws2380   Yoni     15/02/01 CTSversion added                 *
* PS0468   Yoni     29/05/01 release 3.1.01 GA                *
* ws2403   Rami     23/07/01 support for ACF2 V6.4 + DIAG     *
* is0003   shmuel     /02/03 release 3.1.06                   *
* is0066   AvnerL   13/01/04 release 3.2.00                   *
* is0263   AvnerL   15/07/04 set CREATE2 as default for ACF2  *
* ws2490   AvnerL   05/10/04 verify password at rss login.    *
* ws2531   AmirH    13/10/04 Moved CTSVersion                 *
* is0292   AvnerL   28/10/04 uppercase rss-admin.             *
* ws2557   EliMY    24/05/06 RACF MIXEDCASE PASSWORD SUPPORT  *
*                            FOR ZOS 1.7                      *
* WS2565   EliMY    12/11/06 ACF2 v3202, mixedcase password + *
*                            adding RSS admin. verfication    *
* IS10002  AvnerL   30/01/07 verify_pass_login def is Y       *
* WS10020  AvnerL   01/02/09 verify password for TSS as well. *
* IS10068  AvnerL   25/01/12 prevent empty password-MSAdmin.  *
* IS10073  AvnerL   31/01/12 revert IS10068.                  *
* IS10066  NuritY   14/02/12 Verify password succeeds even    *
*                            when the user is revoked /       *
*                            expired.                         *
* IS10119  AvnerL   17/03/14 Support ACCREL# as release src.  *
* SAS2IBMT SeligT   30/06/16 SAS/C to IBM C Conversion Project*
* IS10147B AvnerL   24/05/17 Empty pswd 4 protected only.     *
* SAS2IBMN NuritY   08/07/16 SAS/C to IBM C Conversion Project*
* IS10147B AvnerL   06/07/17 Empty pswd 4 acf2 restrict.      *
* BS10078  NuritY   01/02/18 Prevent storage accumulation     *
* IS10174  NuritY   25/12/17 1. Common_params support for     *
*                               all caller types.             *
*                            2. Admins list support (for      *
*                               dynamic EXECOUT)              *
*                            3. Take VERIFY_PASSWORD_BY_LOGIN *
*                               from common_params.           *
*                            4. Replace RACF_YES and RACF_NO  *
*                               with MS_YES and MS_NO         *
* WS10073  SeligT   08/07/17 Update Logon Statistics When     *
*                            Verifying MS Administrator       *
* BS10095  SeligT   10/10/18 CS Initializat'n Routine Failure *
*                            caused by Common_params_Handle   *
*                            routine not returning an rc to   *
*                            the caller                       *
* WS10074  NuritY   07/10/18 Login to userid for change pwd   *
* BS10100  NuritY   10/04/19 Handle security violation.       *
* BS10102  KailasP  31/07/19 Recompile for init_allowed_admins*
* BS10111  NuritY   15/12/20 Supportruob above the bar.       *
* IS10183  ThomaS   04/05/21 Don't call unprintable string    *
*                            in pswd field PASSWORD in diag   *
* BS10117  NuritY   19/09/21 abend SDC2-0049 -  RUOB utoken   *
*                            collided with ATB cellpool.      *
* IS10184  NuritY   31/08/21 Improve scripts performance      *
* WS10082  AvnerL   29/11/22 Drop include of CTSCADI          *
**************************************************************/

#include   <globs.h>
                                 /* for strupr function is0292 */
#include   <strings.h>                                    /* SAS2IBMT */
#include   <dynit.h>                                     /* IS10174 */

/*
 *   Standard include files
 */

#include   STDLIB
#include   STDIO
#include   STRING
#include   CTYPE                                          /* SAS2IBMT */

/*
 *   CONTROL-SA include files
 */

#include ESA_API
#include ESA_API_CODES
#include ESA_DIAG
#include ESA_CTSAMSG

#include MVS_CODES
#include MVS_OS_MVS
#include MVS_OS_DYNAM                                    /* ws2490 */

#include RACF_CODES
/* WS10082 #include API_ADDINFO                                    */
#include API_AUTH
/* IS10174 #include RACF                                           */
/* IS10174 #include ACF2                                           */
/* IS10174 #include <CTSCSRV.h>      * for MS_pro_user    * IS10147B*/

/*
 *   Assembler service routine
 */

#define LOGON_CREATE "CREATE  "
#define LOGON_CREATE2 "CREATE2 "
#define LOGON_DELETE "DELETE  "
#define LOGON_SWITCH "SWITCH  "
/*BS10111 #define ADMIN_WOUT_PSWD_DFLT 'Y'     * BS10100 *   */
/* IS10174 #define LOGON_CLEAR  "CLEAR   "   */
/* IS10174 #define LOGON_CHECK  "CHECK   "    */

/*
 *   Logon/Logout managment
 */

/* SAS2IBMT prototype changed for IBM C
extern int ctsalgn(char *func, int *dbg, int *rout_rc,
                     int *racf_rc, int *racf_reason, ... );          */
extern int ctsalgn();                                     /* SAS2IBMT */

typedef enum {LOGIN_SWITCH_MODE, LOGOUT_SWITCH_MODE} SWITCH_MODE_typ;

typedef struct uid_struct {
    USER_typ         admin;
    UG_typ           admin_group;
    void           * acee;
    void           * acee_prev;
    LOGIN_MODE_typ   allow_mode[2];
} RACF_UID_rec_typ;

/*
 *   Issue operator commands
 *   for rss_start_intercept
 */

/* SAS2IBMT prototype changed for IBM C
extern ESA_RC ctsaopr(int       *debug_level,
                      int       *cmd_len,
                      char      *command);                           */
extern ESA_RC ctsaopr();                                  /* SAS2IBMT */

/*
 *   Keyword for obtaining from rss parameters
 *   procedure name for start offline interceptor
 */

#define OFLI_STCNAME            "OFLI_STCNAME"

/*  BS10100 - start */
static ESA_RC  Verify_APPL (char                    * appl_name,
                            ESA_DIAG_COMP_typ         diag_comp,
                            ADMIN_PARAMS_rec_typ    * admin_params);
/*  BS10100 - end   */

/*  IS10174 - start */

/*
 *   Activate an administrator.
 */
 static ESA_RC ActAdmin (USER_typ                         admin,
                         UG_typ                           admin_group,
          /* WS10074 */  char                             admin_type,
          /* BS10100 */  char                           * appl_name,
                         RACF_UID_rec_typ               * login_handle,
                         RSS_ADMINS_LIST_ENTRY_rec_typ ** p_ent,
                         ADMIN_PARAMS_rec_typ           * admin_params);

/*
 *   Get and verify admin entry.
 */
 static ESA_RC VerAdmin (USER_typ                         admin,
                         UG_typ                           admin_group,
                         void                           * acee,
                         RSS_ADMINS_LIST_ENTRY_rec_typ ** p_admin_ent,
                         ESA_DIAG_COMP_typ                diag_comp,
                         ADMIN_PARAMS_rec_typ           * admin_params);

/*
 *   Terminate an Admin.
 */
 static ESA_RC TermAdmin (RSS_ADMINS_LIST_ENTRY_rec_typ * admin_ent,
                          ESA_DIAG_COMP_typ               diag_comp,
                          ADMIN_PARAMS_rec_typ          * admin_params);

/*
 *   Handle the EXECOUT dd
 */
 static ESA_RC Admin_EXECOUTDD_Handling (char          * function,
                               RSS_ADMINS_LIST_rec_typ * admins_list,
                               USER_typ                  admin,
                               char                    * ddname,
                               char                    * is_dyn,
                               ESA_DIAG_COMP_typ         diag_comp,
                               ADMIN_PARAMS_rec_typ    * admin_params);
  /*
   *  Initialize Admin_list entries.
   *  ent -> admin entry.
   *
   *  Required fields:
   *  i - int.
   *  admins_list - should point to admins list.
   *
   */
 /* IS10184 #define GET_ADMINSLIST_ADDR(p, c, a)                 \  */
 #define GET_ADMINSLIST_ADDR(c, a)                 /* IS10184 */   \
                                                                   \
 {           /* make it a block for gaarc scope.      IS10184 */   \
   ESA_RC   gaarc = ESA_OK;                        /* IS10184 */   \
   (a) = NULL;                                                     \
   /* IS10184 - replace the code below with a call to GET_P_CMNPRMS\
   (p) = (DUMMY_PARAMS_rec_typ *)admin_params->apiinit_handle;     \
                                                                   \
   if ( (p) NE NULL )                                              \
   {                                                               \
     c = (p)->common_params;                                       \
     if ( (c) NE NULL AND                                          \
           strncmp((c)->commp_eyec, COMMON_PARAMS_EYEC,            \
                strlen(COMMON_PARAMS_EYEC) ) EQ 0 )            */  \
   GET_P_CMNPRMS(admin_params, (c), gaarc, NULL)   /* IS10184 */   \
   if (gaarc EQ ESA_OK)                            /* IS10184 */   \
   {                                                               \
     (a)=(c)->RSS_Admins_list;                                     \
     if ( ((a) EQ NULL)  OR                                        \
        ( (a) NE NULL  AND                                         \
           strncmp((a)->eyec, ADMINS_LIST_EYEC,                    \
                   strlen(ADMINS_LIST_EYEC) ) NE 0) )              \
      (a) = NULL;                                                  \
   }                                                               \
  }


  /*
   *  Initialize Admin_list entries.
   *  ent -> admin entry.
   *
   */
 #define INIT_ADMIN_ENTRY(ent)                                    \
                                                                  \
     (ent)->seq_num = 0;                           /* WS10074 */  \
     (ent)->uid[0] = NULL_CHAR;                                   \
     (ent)->group[0] = NULL_CHAR;                                 \
     (ent)->acee = NULL;                                          \
     /* WS10074 (ent)->acee = NULL_CHAR;  */                      \
     (ent)->type = ADMIN_TYPE_NONE;                /* WS10074 */  \
     (ent)->allowed = ALLOWED_ADMIN_NONE;          /* BS10100 */  \
     (ent)->EXECOUT_ddname[0] = NULL_CHAR;                        \
     (ent)->EXECOUT_dynamic = ' ';


  /*
   *  FInd admin in table
   *  u - admin name. (i)
   *  g - admin group. (i)
   *  o - entry address. (o)
   *  d - diag component. (i)
   *
   *  Required fields:
   *  i - int.
   *  admins_list - should point to admins list.
   *
   */
 #define FIND_ADMIN(u, g, o, d)                                       \
   (o) = NULL;                                                        \
         ESA_DIAG_printf((d), 1,                                      \
             "FIND_ADMIN: (%d)%s - (%d)%s",                           \
             strlen( (u) ), (u) , strlen( (g) ), (g) );               \
   for (i = 0; i LT admins_list->used_entries; i++)                   \
   {                                                                  \
     ESA_DIAG_printf((d), 1,                                          \
       "FIND_ADMIN: Entry = (%d)%s - (%d)%s",                         \
       strlen( admins_list->admin_entry[i].uid ),                     \
       admins_list->admin_entry[i].uid,                               \
       strlen( admins_list->admin_entry[i].group ),                   \
       admins_list->admin_entry[i].group);                            \
     if ( strcmp(admins_list->admin_entry[i].uid, (u) ) EQ 0)         \
     {                                                                \
       if ( (strlen( (g) ) NE 0)     AND                              \
            (strlen( admins_list->admin_entry[i].group ) NE 0)  AND   \
            ( strcmp(admins_list->admin_entry[i].group, (g) ) NE 0) ) \
         continue;                                                    \
                                                                      \
       (o) = &admins_list->admin_entry[i];                            \
       break;                                                         \
     }                                                                \
   }


  /*
   *  Fill Admin entry
   *  ent -> admin entry.
   */

 /* WS10074 - start */
 /*
 #define FILL_ADMIN_ENTRY(ent, admin, grp, stc, pacee, dd, dyn)    \ */
 /* BS10100
 #define FILL_ADMIN_ENTRY(ent, seq, admin, grp, typ, pacee, dd, dyn) \*/
 #define FILL_ADMIN_ENTRY(ent, seq, admin,        /* BS10100 */    \
                          grp, typ, alw,          /* BS10100 */    \
                          pacee, dd, dyn)         /* BS10100 */    \
 /* WS10074 - end  */                                              \
                                                                   \
     (ent)->seq_num = (seq);                       /* WS10074 */   \
     strcpy((ent)->uid, (admin));                                  \
     strcpy((ent)->group, (grp));                                  \
     (ent)->acee = (pacee);                                        \
     /* WS10074 (ent)->is_stc = (stc);   */                        \
     (ent)->type = (typ);                          /* WS10074 */   \
     (ent)->allowed = (alw);                       /* BS10100 */   \
     strcpy((ent)->EXECOUT_ddname, (dd));                          \
     (ent)->EXECOUT_dynamic = (dyn);


  /*
   *  Convert a string to uppercase
   *  The string should terminate with a terminator,
   *
   *  Required fields:
   *  i - int.
   */

 #define TO_UPPER(in, out)                                         \
                                                                   \
     for (i=0; (in)[i] NE NULL_CHAR; i++)                          \
        out[i] = toupper(in[i]);                                   \
                                                                   \
     out[i] = NULL_CHAR;

/*  IS10174 - end   */

/* BS10100 - start */
  /*
   *  Call TermAdmin
   */
 #define DO_TERMADMIN(ent, comp, errm, retc)             \
                                                         \
   if ((ent) NE NULL)                                    \
   {                                                     \
     (retc) = TermAdmin((ent), (comp), admin_params);    \
     ESA_DIAG_printf((comp), 6,                          \
          "TermAdmin for entry <%8X>-><%s> - rc = %s",   \
          (ent), (ent)->uid,                             \
          ESA_rc2str(rc));                               \
                                                         \
     if ((retc) NE ESA_OK)                               \
     {                                                   \
       sprintf((errm), "TermAdmin failed for %8X->%s",   \
               (ent), (ent)->uid);                       \
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,    \
                component, func, (errm),                 \
                (retc), __LINE__);                       \
       (retc) = ESA_FATAL;                               \
     }                                                   \
   }

  /*
   *  Get VERIFY_PASSWORD_BY_LOGIN value
   */
 #define GETVERBYLOGIN(out, retc)                                 \
                                                                  \
   (out)[0] = NULL_CHAR;                                          \
   (out)[1] = NULL_CHAR;                                          \
   (retc) = admin_params->cs_func.rssprm_get_opt_ptr(             \
                 admin_params->rss_name,                          \
                 VERIFY_PASSWORD_BY_LOGIN,                        \
                 sizeof((out)),                                    \
                 (out),                                           \
                 OPT_TRUE,                                        \
                 OPT_TRUE) ;                                      \
   ESA_DIAG_printf(ESA_COMP_APIINIT, 6,                           \
          "VERIFY_PASSWORD_BY_LOGIN = <%s>  rc = <%d> ",          \
           (out));                                                \
                                                                  \
   /* If not specified or incorrect set default according  */     \
   /* to RSS type:                                         */     \
   /* - RACF - N                                           */     \
   /* - other (ACF2, TSS) - Y                              */     \
                                                                  \
   if (((retc) NE ESA_OK) OR                                      \
       ((retc) EQ ESA_OK  AND                                     \
        (out)[0] NE 'N' AND  (out)[0] NE 'Y' ))                   \
   {                                                              \
     if (strncmp (admin_params->rss_type, "RACF", 4) EQ 0 )       \
       (out)[0] = 'N';                                            \
     else                                                         \
       (out)[0] = 'Y';                                            \
                                                                  \
     (out)[1] = NULL_CHAR;                                        \
                                                                  \
     ESA_DIAG_printf(ESA_COMP_APIINIT, 6,                         \
          "Default VERIFY_PASSWORD_BY_LOGIN for %s = <%s>",       \
          admin_params->rss_type, (out));                         \
     (retc) = ESA_OK; /*parm is not mandatory, set rc=0 */        \
                                                                  \
   }
/* BS10100 - end   */

static char component[] = "CTSCRSS";

/************ ws2490 defines *****************************/
#define VERIFY_PASSWORD_BY_LOGIN "VERIFY_PASSWORD_BY_LOGIN"
#define UPDATE_LOGON_STATS       "UPDATE_LOGON_STATS"     /* WS10073 */
#define RACF_FUNCTION_OK_RC      0
#define RACF_USER_NOT_EXIST_RC   4
/* IS10066 #define RACF_FUNCTION_FAILED_RC  8      */
/* IS10066 #define RACF_PASSWORD_EXPIRED_RC 12     */
#define RACF_USER_REVOKED_RC     28
#define RACF_GROUP_REVOKED_RC    36
#define RACF_PASSWORD_EXPIRED_RC 12
#define RACF_WRONG_PASSWORD_RC   8
/************ ws2490 ends ********************************/
#define APPL_NAME             "APPL_NAME"                 /* BS10100 */
#define ALLOW_ADMIN_WOUT_PSWD "ALLOW_ADMIN_WITHOUT_PSWD"  /* BS10100 */


/****************************************************
 * Procedure Name: CreateACEE
 *
 * Description   : Create new ACEE
 *
 * Input         : uid  - ptr to login internal structure
 *                 crmode - CREATE mode:   CREATE / CREATE2
 *                 update_logon_stats: Y or N             // WS10073 //
 *
 * Output        : saved acee into structure
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 * Comments      :
 * Scope         :
 ****************************************************/

 static ESA_RC CreateACEE(RACF_UID_rec_typ           *uid,
      /* ps0320 */        char                       *crmode,
      /*WS10073*/         char                      *update_logon_stats,
      /*BS10100*/         char                       *appl_name,
                          CTSAMSG_DEST_TABLE_rec_ptr  dest,
                          CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC               rc = ESA_OK;
   int                  lgn_rc;
   int                  dbg_lvl=0;
   int                  racf_rc=0, racf_reason=0, rout_rc=0;
   static char func[] = "CreateACEE";

  /*---------------------------------------------------------------
   *
   *   Initialize
   *
   *--------------------------------------------------------------*/

   ESA_DIAG_enter ( ESA_COMP_RSS_LOGIN, 1 , func);

   dbg_lvl = (int)ESA_DIAG_get_debug_level(ESA_COMP_RSS_LOGIN);
   if ( dbg_lvl GT 0 )
      dbg_lvl = 1;

   /*********** Create new acee **********/

   /* SAS2IBMT
   lgn_rc = ctsalgn (crmode,                              // ps0320 */
   /* BS10100 - start */
   /*
   lgn_rc = (*(ASM_RTN_TYP *)&ctsalgn)(crmode,             * SAS2IBMT *
                     &dbg_lvl, &rout_rc, &racf_rc, &racf_reason,
                     update_logon_stats,                   * WS10073 *
                     uid->admin, uid->admin_group, &uid->acee);
   */
   /* BS10100 - start */
   lgn_rc = (*(ASM_RTN_TYP *)&ctsalgn)(crmode,            /* SAS2IBMT */
                                       &dbg_lvl,
                                       &rout_rc,
                                       &racf_rc,
                                       &racf_reason,
                                       uid->admin,
                                       uid->admin_group,
                                       &uid->acee,
                                       update_logon_stats, /* WS10073 */
                                       appl_name);
   /* BS10100 - end   */

   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1,
                 "Create rc=%d, router=%d, rc=%d, reason=%d, acee=%X",
                  lgn_rc, rout_rc, racf_rc, racf_reason, uid->acee );

   /*** Create failure ***/

   if ( (lgn_rc GT 0) OR ((lgn_rc EQ 0) AND (rout_rc GT 0))) {

      /*** General login failure message ***/

      if (strlen(uid->admin_group) GT 0)
         CTSAMSG_print(RACF_LOGIN_GROUP_FAIL,   msgs, NULL, dest,
                       uid->admin, uid->admin_group );
         else CTSAMSG_print(RACF_LOGIN_FAIL,msgs,NULL,dest,uid->admin);

         /*** Detail login failure message ***/

         /* WS10074 - the code below was moved down
          * start of BS2421 *
         if (lgn_rc GT 0) {
           switch (lgn_rc) {
                 case 12:
                    CTSAMSG_print(RACF_RACF_NO_ACEE,msgs,NULL, dest);
                 break;
                 case 16:
                    CTSAMSG_print(RACF_RACF_NO_ACEE_EC,msgs,NULL,dest);
                 break;
           }
           }  * login failure *
          * end of BS2421 *
         */

         /* WS10074 if ((lgn_rc EQ 0) AND (rout_rc GT 0)) { */
         if (rout_rc EQ 4)
            switch (racf_rc) {
               case 4:
                  CTSAMSG_print(RACF_RACF_NO_USER,msgs,NULL, dest);
               break;
            }
         else if (rout_rc EQ 8)
            switch (racf_rc) {
               case 20:
                  CTSAMSG_print(RACF_RACF_NO_GROUP,msgs,NULL, dest);
                  break;
               case 28:
                  CTSAMSG_print(RACF_RACF_REVOKED,msgs,NULL, dest);
                  break;
               case 36:
                  CTSAMSG_print(RACF_RACF_GROUP_REVOKED,msgs,NULL,
                                dest);
                  break;
               /* BS10100 - start */
               case 52:
                  CTSAMSG_print(ADMIN_NOT_ALLOWED_APPL,msgs,NULL,
                                dest,uid->admin,appl_name);
                  break;
               /* BS10100 - start */
            }
           else                                          /* WS10074 */
           {                                             /* WS10074 */
             CTSAMSG_print(RACF_RACROUTE_RC,   msgs, NULL, dest,
                       rout_rc, racf_rc, racf_reason);
             /* WS10074 - start - code moved from above */
             /* start of BS2421 */
             if (lgn_rc GT 0) {
               switch (lgn_rc) {
                     case 12:
                        CTSAMSG_print(RACF_RACF_NO_ACEE,msgs,
                                      NULL, dest);
                     break;
                     case 16:
                        CTSAMSG_print(RACF_RACF_NO_ACEE_EC,msgs,
                                      NULL,dest);
                     break;
               }
             } /* login failure */
             /* end of BS2421 */
             /* WS10074 - end  */
         } /* detail messages */

         rc = ESA_FATAL;
         goto exit;

   } /* login failed */

   exit:;

   ESA_DIAG_exit ( ESA_COMP_RSS_LOGIN, 1, func, rc );
   return rc;

 }

/****************************************************
 * Procedure Name: SwitchACEE
 *
 * Description   : Switch ACEE
 *
 * Input         : uid - ptr to login internal structure
 *
 * Output        : none
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 * Comments      :
 * Scope         :
 ****************************************************/

 static ESA_RC SwitchACEE(RACF_UID_rec_typ           *uid,
                          void                      **acee,
                          void                      **acee_prev,
                          SWITCH_MODE_typ             switch_mode,
                          ESA_DIAG_COMP_typ           diag_comp,
                          CTSAMSG_DEST_TABLE_rec_ptr  dest,
                          CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC               rc = ESA_OK;
   int                  lgn_rc;
   int                  dbg_lvl=0;
   int                  racf_rc=0, racf_reason=0, rout_rc=0;
   static char func[] = "SwitchACEE";

  /*---------------------------------------------------------------
   *
   *   Initialize
   *
   *--------------------------------------------------------------*/

   ESA_DIAG_enter ( diag_comp, 1 , func);

   dbg_lvl = (int)ESA_DIAG_get_debug_level(diag_comp);
   if ( dbg_lvl GT 0 )
      dbg_lvl = 1;

   /* Switch address space active acee */

   /* SAS2IBMT
   lgn_rc = ctsalgn (LOGON_SWITCH,                                   */
   lgn_rc = (*(ASM_RTN_TYP *)&ctsalgn)(LOGON_SWITCH,      /* SAS2IBMT */
                     &dbg_lvl, &rout_rc, &racf_rc, &racf_reason,
                     acee, acee_prev);

   ESA_DIAG_printf (diag_comp, 1,
                    "Switch rc=%d, acee=%X, old acee=%X",
                     lgn_rc, *acee, *acee_prev);

   if (lgn_rc GT 0) {
     switch (switch_mode) {
       case LOGIN_SWITCH_MODE:
            if (strlen(uid->admin_group) GT 0)
               CTSAMSG_print(RACF_LOGIN_GROUP_FAIL,   msgs, NULL, dest,
                             uid->admin, uid->admin_group );
            else CTSAMSG_print(RACF_LOGIN_FAIL,msgs,NULL,
                               dest, uid->admin);
            CTSAMSG_print(RACF_SWITCH_FAIL,   msgs, NULL, dest, lgn_rc,
                          acee);
            rc = ESA_FATAL;
            break;

       case LOGOUT_SWITCH_MODE:
            if (strlen(uid->admin_group) GT 0)
               CTSAMSG_print(RACF_LOGOUT_GROUP_FAIL,msgs,NULL,dest,
                             uid->admin, uid->admin_group);
            else CTSAMSG_print(RACF_LOGOUT_FAIL,msgs,NULL,
                               dest, uid->admin);
            CTSAMSG_print(RACF_RACROUTE_RC,msgs,NULL,dest,rout_rc,
                          racf_rc, racf_reason);
            rc = ESA_FATAL;
            break;
     } /* switch_mode */
   }    /* logn_rc > 0 */

   exit:;

   ESA_DIAG_exit ( diag_comp, 1, func, rc );
   return rc;

 }

/****************************************************
 * Procedure Name: CheckLoginHandle
 *
 * Description   : Check login handle
 *
 * Input         : uid - ptr to login internal structure
 *
 * Output        : none
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 * Comments      :
 * Scope         :
 ****************************************************/

 static ESA_RC  CheckLoginHandle(void                      **handle,
                                 RACF_UID_rec_typ          **uid,
                                 LOGIN_MODE_typ            login_mode,
                                 USER_typ                  admin,
                                 UG_typ                    admin_group,
                                 ESA_DIAG_COMP_typ         diag_comp,
                                 CTSAMSG_DEST_TABLE_rec_ptr  dest,
                                 CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC               rc = ESA_OK;
   RACF_UID_rec_typ     *uidw;
   static char func[] = "CheckLoginHandle";

  /*---------------------------------------------------------------
   *
   *   Initialize
   *
   *--------------------------------------------------------------*/

   ESA_DIAG_enter ( diag_comp, 1 , func);

  /*
   *  Obtain login handle
   */

   *uid = (RACF_UID_rec_typ *)(*handle);
   if ( *uid EQ NULL ) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Invalid login/logout sequence",
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   }

   uidw = *uid;

  /*
   *  Sequence checking
   */

   ESA_DIAG_printf(diag_comp, 1,
                   "Entering login/logout mode=%d allowed modes=%d/%d",
                   login_mode,
                   uidw->allow_mode[0], uidw->allow_mode[1]);

   if ( ( (uidw->allow_mode[0] GT 0 )         AND
          (uidw->allow_mode[0] NE login_mode)   )   AND
        ( (uidw->allow_mode[1] GT 0 )         AND
          (uidw->allow_mode[1] NE login_mode)   )     ) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Invalid login/logout sequence",
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   }

  /*---------------------------------------------
   *                                            *
   * Issue error message if admin parameters    *
   * do not corresponding to login admin params *
   * (Thus we have an orphan acee)              *
   *                                            *
   *--------------------------------------------*/

   if ( (strcmp(uidw->admin,  admin)            NE 0 ) OR
        (strcmp(uidw->admin_group, admin_group) NE 0 )  ) {
      if (strlen(admin_group) GT 0)
         CTSAMSG_print(RACF_LOGOUT_GROUP_FAIL,msgs,NULL,dest,
                       uidw->admin, uidw->admin_group );
         else CTSAMSG_print(RACF_LOGOUT_FAIL,msgs,NULL,
                            dest, uidw->admin);
         CTSAMSG_print(RACF_ORPHAN_ACEE, msgs, NULL,
                       dest, uidw->acee);
         rc = ESA_FATAL;
         goto exit;
   }


   exit:;

   ESA_DIAG_exit (diag_comp, 1, func, rc );
   return rc;

 }


/****************************************************
 * Procedure Name: GetLoginHandle
 *
 * Description   : Create login handle
 *
 * Input         : uid - ptr to login internal structure
 *
 * Output        : none
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 * Comments      :
 * Scope         :
 ****************************************************/

 static ESA_RC  GetLoginHandle(void                      **handle,
                               RACF_UID_rec_typ          **uid,
                               USER_typ                  admin,
                               UG_typ                    admin_group,
                               CTSAMSG_DEST_TABLE_rec_ptr  dest,
                               CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC               rc = ESA_OK;
   RACF_UID_rec_typ     *uidw;
   static char func[] = "GetLoginHandle";

  /*-------------------*
   *   Initialize      *
   *-------------------*/

   ESA_DIAG_enter ( ESA_COMP_RSS_LOGIN, 1 , func);

   if (*handle NE NULL) {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    "Invalid login/logout sequence",
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   }

  /*
   *  Allocate login handle
   */

   *uid = (RACF_UID_rec_typ *)malloc(sizeof(RACF_UID_rec_typ));
   if (*uid EQ NULL) {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                   "Login handle",
                   sizeof(RACF_UID_rec_typ));
     rc = ESA_FATAL;
     goto exit;
   }

   uidw = *uid;

  /*
   *  To fill up the login handle
   */

   strcpy(uidw->admin,       admin);
   strcpy(uidw->admin_group, admin_group);
   uidw->acee          = NULL;
   uidw->acee_prev     = NULL;
   uidw->allow_mode[0] = LOGIN_MODE;
   uidw->allow_mode[1] = LOGOUT_MODE_LAST;

   exit:;

   ESA_DIAG_exit ( ESA_COMP_RSS_LOGIN, 1, func, rc );
   return rc;

 }


/****************************************************
 * Procedure Name: ReleaseACEE
 *
 * Description   : Logout and Free login handle
 *
 * Input         : uid - ptr to login internal structure
 *
 * Output        : none
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 * Comments      :
 * Scope         :
 ****************************************************/

 static ESA_RC ReleaseACEE(RACF_UID_rec_typ           *uid,
           /* IS10174 */   ESA_DIAG_COMP_typ           diag_comp,
                           CTSAMSG_DEST_TABLE_rec_ptr  dest,
                           CTSAMSG_HANDLE_rec_ptr      msgs)
 {

   ESA_RC               rc = ESA_OK;
   int                  lgn_rc;
   int                  dbg_lvl=0;
   int                  racf_rc=0, racf_reason=0, rout_rc=0;
   static char func[] = "ReleaseACEE";

  /*---------------------------------------------------------------
   *
   *   Initialize
   *
   *--------------------------------------------------------------*/

   /* IS10174 ESA_DIAG_enter ( ESA_COMP_RSS_LOGOUT, 1 , func);  */
   ESA_DIAG_enter (diag_comp, 1 , func);                 /* IS10174 */

   /* IS10174
   dbg_lvl = (int)ESA_DIAG_get_debug_level(ESA_COMP_RSS_LOGOUT); */
   dbg_lvl = (int)ESA_DIAG_get_debug_level(diag_comp);
   if ( dbg_lvl GT 0 )
      dbg_lvl = 1;

   /* SAS2IBMT
   lgn_rc = ctsalgn (LOGON_DELETE, &dbg_lvl, &rout_rc,               */
   lgn_rc = (*(ASM_RTN_TYP *)&ctsalgn)                    /* SAS2IBMT */
                    (LOGON_DELETE, &dbg_lvl, &rout_rc,
                     &racf_rc, &racf_reason, &uid->acee );

   /* IS10174 ESA_DIAG_printf(ESA_COMP_RSS_LOGOUT, 1,  */
   ESA_DIAG_printf(diag_comp, 1,
                   "Delete rc=%d, rout_rc=%d, rc=%d, reason=%d",
                    lgn_rc, rout_rc, racf_rc, racf_reason );
   if (lgn_rc NE 0) {
     CTSAMSG_print(RACF_RACF_CLEANUP_FAIL, msgs, NULL, dest,
                          uid->admin, uid->admin_group, uid->acee );
   }
   else if (rout_rc NE 0) {
     CTSAMSG_print(RACF_RACF_CLEANUP_FAIL,   msgs, NULL, dest,
                   uid->admin, uid->admin_group, uid->acee );
     CTSAMSG_print(RACF_RACROUTE_RC,   msgs, NULL, dest,
                   rout_rc, racf_rc, racf_reason);
   }

   exit:;

   /* IS10174 ESA_DIAG_exit ( ESA_COMP_RSS_LOGOUT, 1, func, rc ); */
   ESA_DIAG_exit ( diag_comp, 1, func, rc );             /* IS10174 */
   return rc;

 }


/****************************************************
 * Procedure Name: rss_login
 *
 * Description   : log in under the permisions and
 *                 limitation of the requsted administrator.
 *
 * Input         : rss name
 *                 administrator name and group
 *                 admin structure stuff
 *
 * Output        : CTSAMSG error structure
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 *
 * Comments      : Warning:
 *                 Do not return rc ESA_NOT_SUPP becasue
 *                 it is handled by some callers as ESA_OK.
 *
 * Scope         :
 ****************************************************/

 ESA_RC CTSRSSLogin (RSS_typ                rss_name,
                     USER_typ               admin,
                     UG_typ                 admin_group,
                     PASSWD_typ             admin_passwd,
                     LOGIN_MODE_typ         login_mode,
                     void                ** handle,
                     ADMIN_PARAMS_rec_typ * admin_params,
                     ERR_STRUCT_rec_typ   * err)
 {

   ESA_RC               rc = ESA_OK;
   int                  load_rc = 0;          /*IS10147B*/
   RACF_UID_rec_typ    *uid = NULL;
   static char func[]="CTSRSSLogin";

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;


   /* IS10174 static char acf2_type[]="ACF2";            * ps0320 * */
   /* IS10174 char acf_version[5]="";                    * ps0320 * */
   char crmode[9]="";                                     /* ps0320 */
   /* IS10002 drop it as no use:     int  prm_rc          /* ws2490 */
   int  dbg_lvl, verify_password_rc;                      /* ws2490 */
   /* IS10174 char      * how_to_verify = " ";           * ws2490 * */
   char        how_to_verify[2] = "";                    /* IS10174 */
   /* SAS2IBMN
   int create_racf_rc,create_racf_out,create_racf_reason;  * ws2490 *
   */
   int create_racf_rc = 0;                                /* SAS2IBMN */
   int create_racf_out = 0;                               /* SAS2IBMN */
   int create_racf_reason = 0;                            /* SAS2IBMN */
   /* SAS2IBMN
   int delete_racf_rc,delete_racf_out,delete_racf_reason;  * ws2490 *
   */
   int delete_racf_rc = 0;                                /* SAS2IBMN */
   int delete_racf_out = 0;                               /* SAS2IBMN */
   int delete_racf_reason = 0;                            /* SAS2IBMN */
   /* IS10174 ACF2_PARAMS_rec_typ * params_ptr = NULL;   * IS10002 * */
   /* IS10184 DUMMY_PARAMS_rec_typ * params_ptr = NULL;  * IS10174 * */
   char         errmsg1[128] = "";                        /*IS10147B*/
   int            i;                                      /* SAS2IBMT */
   USER_typ       temp_admin;                             /* SAS2IBMT */
   ESA_RC         pro_rc = ESA_OK;                        /*IS10147B*/
   int            dummy_pswd = ADMIN_DUMMY_PSWD;          /*IS10147B*/
   MS_FLAG_typ    protect;                               /*IS10147B*/
   /* IS10147B MS_FLAG_typ  restrict;                      IS10147B*/
   char           restrict = 'N';                        /*IS10147B*/
   char           admin_type = ADMIN_TYPE_ADMIN; /* default WS10074 */
   LOGIN_MODE_typ input_login_mode;                      /* WS10074 */
   char           curr_jobname[9] = "";                  /* WS10074 */
   char           curr_jobid[9]   = "";                  /* WS10074 */
   char           curr_userid[9]  = "";                  /* WS10074 */
   char           curr_sysid[5]  = "";                   /* WS10074 */
   void         * curr_acee = NULL;                      /* WS10074 */
   int            pass_char;                               /* BS10100 */
   COMMON_PARAMS_rec_typ  *cmnprms = NULL;                 /* BS10100 */
   char           allow_prot = NULL_CHAR;                  /* BS10100 */
   char           appl_name[9] = "";                       /* BS10100 */
   char           appl_OK = NULL_CHAR;                     /* BS10100 */
   RSS_ADMINS_LIST_ENTRY_rec_typ * admin_ent = NULL;       /* BS10100 */

 /* following is the RACF_pro_user call                IS10147B */
 typedef ESA_RC (*FP_API)(char                     * user,
                          MS_FLAG_typ           * protect,
         /* IS10147B      int                      msg_flag, */
         /* IS10147B      CTSAMSG_DEST_TABLE_rec_ptr   dest, */
         /* IS10147B      CTSAMSG_HANDLE_rec_ptr       msgs);*/
         /* IS10147B */   ADMIN_PARAMS_rec_typ * admin_params);
 /* if the ; above is dropped, IBM/C compiler abends with S0C4 */
 static FP_API            api_ptr;                        /* IS10147B */

  /*---------------------*
   *   Initialize        *
   *---------------------*/

   ESA_DIAG_enter ( ESA_COMP_RSS_LOGIN, 1 , func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1 ,
                   "rss_name=%s admin=%s/%s login_mode=%d",
                    rss_name, admin, admin_group, login_mode);

  /*-----------------------*
   *  Check APF authority  *
   *-----------------------*/

   rc = OS_MVS_check_apf( msgs, dest );
   if (rc NE ESA_OK) {
      rc = ESA_OK;
      goto exit;
   }

  /*------------------------------*
   *   Login mode processing      *
   *------------------------------*/
   input_login_mode = login_mode;                          /* WS10074 */

   switch ( login_mode ) {
    /* WS10074 - start */
    case LOGIN_MODE_FIRST_USER:
      admin_type = ADMIN_TYPE_USER;   /* Set admin type            */
      login_mode = LOGIN_MODE_FIRST;  /* Set logn mode.            */
    /* WS10074 - start */

    case LOGIN_MODE_FIRST:

     /* BS10100 - start */
     ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
            "login mode = %d   input-login_mode=%d  admin_type = %c",
             login_mode, input_login_mode, admin_type);
     /* BS10100 - end   */

    /************************ ws2490 starts ********************
     When Add_Rss_Admin, verify that password received from ESS
     is a correct password. (Without this code, there is a
     security leak in our agent, as anyone with an access to
     ess-gui, may add an rss_admin and do what ever he wants...
     ***********************************************************/

    /* ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
            "admin_passwd and def_admin_passwd=<%s>/<%s>",
            admin_passwd,admin_params->def_admin_passwd); */

    /* BS10100 - start */
    /*
     *  Verify password only if not type U
     */
    if (admin_type NE ADMIN_TYPE_USER)
    {

      /*
       *  Take parameters
       */
      /* IS10184 - the code below is replaced with a call to
                   GET_P_CMNPRMS
      params_ptr = admin_params->apiinit_handle;
      if (params_ptr NE NULL   AND
          params_ptr->common_params NE NULL)
        cmnprms = params_ptr->common_params;
      else
        cmnprms = NULL;
        end of replaced code */

      GET_P_CMNPRMS(admin_params, cmnprms, rc, NULL)
      /* If common_params was created, get Allowed Admins and     */
      /* and ALLOW_PROTECTED information.                          */
      if (rc EQ ESA_OK)
      {
        allow_prot = cmnprms->rssparm_ALLOW_ADMIN_WITHOUT_PSWD[0];
        strcpy(appl_name, cmnprms->rssparm_APPL_NAME);
        if (cmnprms->is_APPL_OK NE 'Y')
        {
          rc = Verify_APPL (appl_name,
                            ESA_COMP_RSS_LOGIN,
                            admin_params);
          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                          "Verify_APPL for APPL %s returned rc = %d",
                          appl_name, ESA_rc2str(rc));
          if (rc EQ ESA_OK)
            cmnprms->is_APPL_OK = 'Y';
          else
          {
            cmnprms->is_APPL_OK = 'N';
            rc = ESA_FATAL;
            goto exit;
          }
        }
      }
      /* If common_params was not created, call Init_Alloed_Admins */
      /* to get "allow protected", appl name, and whether the appl */
      /* is defined or not.                                        */
      else
      {
        rc = Init_Allowed_Admins(&allow_prot,
                                 appl_name,
                                 &appl_OK,
                                 ESA_COMP_RSS_LOGIN,
                                 admin_params);
        ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                 "Init_Allowed_Admins returned: rc = %s   %c / %s / %c",
                  ESA_rc2str(rc), allow_prot,
                  appl_name, appl_OK);
        if (rc EQ ESA_OK)
        {
          if (appl_name[0] NE NULL_CHAR   AND  /* If APPL not ...     */
              appl_OK NE 'Y')       /* ...defined in security product */
          {
            rc = ESA_FATAL;
            goto exit;
          }
        }
        else           /* Init_Allowed_Admins failed.  */
        {
          rc = ESA_FATAL;
          goto exit;
        }
      }
     /* BS10100 - start */
     ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                     "allow_prot = %c   appl_name = %s",
                     allow_prot, appl_name);
     /* BS10100 - end   */

      /*
       *   Get admin entry, if exists.
       *
       *   If active, not allowed and STC, fail the login request.
       */
      rc = VerAdmin (admin, admin_group, NULL, &admin_ent,
                     ESA_COMP_RSS_LOGIN, admin_params);
      ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                 "VerAdmin for <%s>/<%s>: rc = %s  admin_ent = %8X",
                 admin, admin_group, ESA_rc2str(rc), admin_ent);
      if (rc EQ ESA_SKIP  AND        /* entry for stc     AND     */
          admin_ent->allowed EQ ALLOWED_ADMIN_NO) /* not Allowed? */
      {
        ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
            "admin %.8s is active as STC with ALLOWED=NO",
             admin);
        CTSAMSG_print(ADMIN_NOT_ALLOWED_APPL, msgs, NULL, dest,
                      admin, appl_name);
        rc = ESA_FATAL;
        goto exit;
      }
      /* BS10100  - end  */

      /* Print the password only if non-printable */       /* BS10100 */
      pass_char = admin_passwd[0];                         /* BS10100 */
      if (isprint(pass_char) EQ 0)  /* If non-printable */ /* BS10100 */
        ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,6,
                         /* "pswd received as:<%2X%2X%2X%2X>",IS10183 */
                           "internal flag:<%2X%2X%2X%2X>", /* IS10183 */
                            admin_passwd[0],
                            admin_passwd[1],
                            admin_passwd[2],
                            admin_passwd[3]);

      if (strlen(admin_passwd) GT 0)
      {                                       /* is0292 starts */
       /* ws2557
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 11,
              "rss_admin name and password before uppercase=%s/%s",
              admin,admin_passwd);
       */

       /*
       admin = strupr(admin);                           SAS2IBMT */
       i = 0;                                        /* SAS2IBMT */
       strcpy(temp_admin,admin);                     /* SAS2IBMT */
       while(admin[i])                               /* SAS2IBMT */
          {                                          /* SAS2IBMT */
             temp_admin[i] = toupper(admin[i]);      /* SAS2IBMT */
             i++;                                    /* SAS2IBMT */
          }                                          /* SAS2IBMT */
       strcpy(admin,temp_admin);                     /* SAS2IBMT */
       /* ws2557: password is not needed to be upper because
          this is done by CTSAVPS if necessary (depends on
          rss version and password mixcase option)
       admin_passwd = strupr(admin_passwd);
       */

       /* ws2557
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 11,
              "rss_admin name and password after uppercase=%s/%s",
              admin,admin_passwd);
       */
                                              /* is0292 ends */
       /* WS2565 start here */
        ESA_DIAG_printf (ESA_COMP_RSS_LOGIN, 5, "RSS Type: %s",
                         admin_params->rss_type);
       /******** IS10147B start ********/
       dbg_lvl =                                            /*IS10147B*/
         (int)ESA_DIAG_get_debug_level(ESA_COMP_RSS_LOGIN); /*IS10147B*/
       if ( dbg_lvl GT 0 ) dbg_lvl = 1;                     /*IS10147B*/
       /* IS10147B - start */
       /*
        *   Dummy password - check if protected
        */
       if ( (strlen(admin_passwd) EQ 4) AND
            (memcmp(admin_passwd, &dummy_pswd, 4) EQ 0) )
       { /* dummy pswd found */
         ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,6,"dummy_pswd found");

          /* BS10100 - start  */
          /*
           *   Dummy password supplied - if PROTECTED not allowed
           *   fail the login.
           *   If protected allowed, verify the user is protected.
           */
          if (allow_prot EQ 'N')
          {
            CTSAMSG_print(PROTECTED_NOT_ALLOWED, msgs, NULL, dest,
                      admin, ALLOW_ADMIN_WOUT_PSWD, allow_prot);
            if (admin_ent NE NULL)                         /* BS10100 */
            {                                              /* BS10100 */
              DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN,  /* BS10100 */
                           errmsg1, rc)                    /* BS10100 */
            }                                              /* BS10100 */
            rc = ESA_FATAL ;
            goto exit;
          }

          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,6,
                          "Admin without password is allowed");

         /* BS10100 - end    */

         /*
          *   RACF - check PROTECTED
          */
         if (strncmp (admin_params->rss_type, "RACF", 4) EQ 0 )
         {
          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
              "Dummy pswd.Chk whether user=<%.8s> is protected",
              temp_admin);

          load_rc = (*(ASM_RTN_TYP *)&ctsaldm) /* load RACF_pro_user  */
                           ("CTSRPRO ", "       ", &api_ptr);
          if (load_rc EQ 0)
          {                                                /* BS10078 */
          /* pro_rc=RACF_pro_user(temp_admin,   * chk whether user is */
            pro_rc = (*api_ptr)(temp_admin,    /* chk whether user is */
                               &protect,       /* protected.          */
                               admin_params);  /* IS10147B */
                               /* protect TRUE,dest,msgs); */
            /* BS10078 - start */
            /* Delete CTSRPRO */
            load_rc = (*(ASM_RTN_TYP *)&ctsadlm)("CTSRPRO ");
            if (load_rc NE 0)
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, func,
                      "Delete of CTSRPRO failed",
                      4, __LINE__);
          }
          /* BS10078 - end   */
          else {
           CTSAMSG_print(ERR_API_LOAD, msgs,
                         NULL, dest,rss_name,"CTSRPRO");
           rc = ESA_FATAL ;
            goto exit;                                     /* BS10100 */
          }
          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
           "protect=<%d> pro_rc=<%d>", protect,pro_rc);
          if (pro_rc EQ ESA_OK) {
            /* IS10174 if (protect EQ RACF_NO) {          */
            if (protect EQ MS_NO) {                        /* IS10174 */
              /*user not protected and empty password*/
              ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                 "user=<%.8s> not protected. cannot use empty pswd",

                 admin);
              sprintf(errmsg1,"Function=%s MSAdmin=%s \n",func,admin);
              CTSAMSG_print(ERR_PASSWORD_EMPTY,msgs,NULL,dest,errmsg1);
              if (admin_ent NE NULL)                       /* BS10100 */
              {                                            /* BS10100 */
                DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN, /*BS10100 */
                             errmsg1, rc)                  /* BS10100 */
              }                                            /* BS10100 */
              rc = ESA_FATAL;
              goto exit;  /* or break; */
              }
            /* IS10174 else if (protect EQ RACF_YES)    */
            else if (protect EQ MS_YES)                    /* IS10174 */
                 ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6, /*IS10002*/
                   "user=<%.8s> is protected", admin);
          } /* end of pro_rc EQ ESA_OK */
          else if (pro_rc EQ ESA_ERR) {
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
              "user=<%.8s> does not exist.", admin); /*IS10147B*/
           CTSAMSG_print(ERR_NO_USER,msgs,NULL,dest,admin); /*IS10147B*/
            if (admin_ent NE NULL)                         /* BS10100 */
            {                                              /* BS10100 */
              DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN,  /* BS10100 */
                           errmsg1, rc)                    /* BS10100 */
            }                                              /* BS10100 */
            rc = ESA_FATAL;                                 /*IS10147B*/
            goto exit;                                      /*IS10147B*/
          } /* end of pro_rc EQ ESA_ERR */
         } /* end of RACF part in the else */

         /*
          *   ACF2 - check RESTRICTED
          */
         if (strncmp (admin_params->rss_type, "ACF2", 4) EQ 0 )
         { /* IS10147B start */
          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,6,
                          "dummy_pswd found 4 ACF2");
          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                "Dummy pswd.Chk whether user=<%.8s> is restrict",
                temp_admin);
          pro_rc = (*(ASM_RTN_TYP *)&OS_DYNAM_call)
                   ("CTS2RST ", /*rtn 2 link */
                   1,           /*rtn has parms*/
                   temp_admin,  /*user 2 check*/
                   &restrict,   /*restrict=Y/N */
  /* IS10147B      admin_params);                                     */
                   &dbg_lvl);
          ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
           "restrict=<%c> pro_rc=<%d>", restrict,pro_rc);
          if (pro_rc EQ ESA_OK) {
            /* IS10147B if (restrict EQ RACF_NO) {                    */
            if (restrict EQ 'N') {                          /*IS10147B*/
              /*user not restrict and empty password*/
              ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                 "user=<%.8s> not restrict. cannot use empty pswd",
                 admin);
              sprintf(errmsg1,"Function=%s MSAdmin=%s \n",func,admin);
              CTSAMSG_print(ERR_PASSWORD_EMPTY,msgs,NULL,dest,errmsg1);
              if (admin_ent NE NULL)                       /* BS10100 */
              {                                            /* BS10100 */
                DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN, /*BS10100 */
                             errmsg1, rc)                  /* BS10100 */
              }                                            /* BS10100 */
              rc = ESA_FATAL;
              goto exit;  /* or break; */
              }
            /* IS10147B else if (restrict EQ RACF_YES)                */
            else if (restrict EQ 'Y')                       /*IS10147B*/
                 ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                   "user=<%.8s> is restrict. empty pswd okay", admin);
          } /* end of pro_rc EQ ESA_OK */
          /* IS10147B else if (pro_rc EQ ESA_ERR) {                   */
          else if (pro_rc NE ESA_OK) {                      /*IS10147B*/
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
              "user=<%.8s> does not exist.", admin);
            CTSAMSG_print(ERR_NO_USER,msgs,NULL,dest,admin);
            if (admin_ent NE NULL)                         /* BS10100 */
            {                                              /* BS10100 */
              DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN,  /* BS10100 */
                           errmsg1, rc)                    /* BS10100 */
            }                                              /* BS10100 */
            rc = ESA_FATAL;                                 /*IS10147B*/
            goto exit;                                      /*IS10147B*/
          } /* end of pro_rc NE ESA_OK */
         } /* end of IS10147B --- ACF2 */

         if (strncmp (admin_params->rss_type, "TSS", 3) EQ 0 )
         {
           ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,6,
                           "dummy_pswd found 4 TSS");
         }

       } /* end of dummy pswd found */
              /* IS10147B - end */
              /* WS2565 ends here */

       /* IS10147B Remove the following else and call CTSAVPS when the
                 password is not a dummy password or when we are
                 running under TSS (even when we have a dummy password).
       else   // handles real password now              *IS10147B*/
       if ( (memcmp  (admin_passwd, &dummy_pswd, 4) NE 0) OR
        (strncmp (admin_params->rss_type, "TSS", 3) EQ 0) ) /*IS10147B*/
       {
        /* BS10100
        params_ptr = admin_params->apiinit_handle;    * IS10002 *
        */

        /* IS10174 - start */
        /* how_to_verify = params_ptr->rssparm_VERIFY_PASS_LOGIN ; */
        /* BS10100
        if (params_ptr NE NULL   AND
            params_ptr->common_params NE NULL)
        */
        if (cmnprms NE NULL)                               /* BS10100 */
          strcpy(how_to_verify,
                cmnprms->rssparm_VERIFY_PASS_LOGIN) ;      /* BS10100 */
    /* BS10100  params_ptr->common_params->rssparm_VERIFY_PASS_LOGIN);*/
        else    /* If no params or common params, get parm value */
        {
          /* BS10100 - start */
          /* Get parm value insted of setting a default
          how_to_verify[0] = 'Y';
          how_to_verify[1] = NULL_CHAR;
          */
         /* IS10184 - although comon_params is created now earlier in */
         /*           the process, this might not be do in utilities  */
         /*           so we keep this code as-is to support all       */
         /*           environments.                                   */
          GETVERBYLOGIN(how_to_verify, rc )
          /* BS10100 - end   */
        }
        /* IS10174 - end   */
        ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 3, /*IS10002*/
          "VERIFY_PASSWORD_BY_LOGIN = %c", *how_to_verify);
        rc=ESA_FATAL;
        dbg_lvl =
           (int)ESA_DIAG_get_debug_level(ESA_COMP_RSS_LOGIN);
        if ( dbg_lvl GT 0 ) dbg_lvl = 1;

        /* SAS2IBMT
        verify_password_rc =  OS_DYNAM_call("CTSAVPS ",1,       */
        verify_password_rc = (*(ASM_RTN_TYP *)&OS_DYNAM_call)
                                  ("CTSAVPS ",1,     /* SAS2IBMT */
                                  admin,
                                  admin_passwd,
                                  how_to_verify,
                                  admin_params->rss_type,
                                  &dbg_lvl,
                                  &create_racf_out,
                                  &create_racf_rc,
                                  &create_racf_reason,
                                  &delete_racf_out,
                                  &delete_racf_rc,
                                  &delete_racf_reason);

        ESA_DIAG_printf (ESA_COMP_RSS_LOGIN, 2,
       "CTSAVPS ret-codes: VerPassRC=%d, RC=%d  rc=%d, rs=%d, howto=%c",
        verify_password_rc,create_racf_out, create_racf_rc,
        create_racf_reason, *how_to_verify);              /* IS10002 */

        switch(create_racf_rc) {
          case 0:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6, /* IS10147B */
              "Verify pswd for user=<%.8s> is successfull.", admin);
            break;
          case RACF_USER_NOT_EXIST_RC:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
              "user=<%.8s> does not exist.", admin); /*IS10147B*/
           CTSAMSG_print(ERR_NO_USER,msgs,NULL,dest,admin); /*IS10147B*/
            break;
          case RACF_USER_REVOKED_RC:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,2,"User <%s> is revoked",
                            admin);     /*this & next line IS10147B */
            CTSAMSG_print(MSG_ONLI_USER_REVOKED,msgs,NULL,dest,admin,
                          admin_params->rss_type);     /* IS10147B */
            break;
          case RACF_GROUP_REVOKED_RC:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,2, /*add diag IS10147B */
                           "Default group of user <%s> is revoked",
                           admin);
            CTSAMSG_print(RACF_RACF_GROUP_REVOKED,msgs,NULL,dest,admin);
            break;
          case RACF_PASSWORD_EXPIRED_RC:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,2,
                           "Password of user <%s> is expired",admin);
            CTSAMSG_print(PASSWORD_EXPIRED,msgs,NULL,dest,admin);
            break;
          case RACF_WRONG_PASSWORD_RC:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,2,
                           "Password of user <%s> is wrong",admin);
            CTSAMSG_print(WRONG_PASSWORD,msgs,NULL,dest,admin);
            break;
          default:
            ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,2,
                           "Internal error when verifying password");
            CTSAMSG_print(VERIFY_PSWD_FAIL,msgs,NULL,dest, /*IS10147B*/
              verify_password_rc,create_racf_out,create_racf_rc,
              create_racf_reason,delete_racf_out,delete_racf_rc,
              delete_racf_reason);
            break;
        } /* end of switch */
        if (verify_password_rc EQ RACF_FUNCTION_OK_RC) /* IS10066 */
             rc = ESA_OK;
        else                                               /* BS10100 */
        {                                                  /* BS10100 */
          if (admin_ent NE NULL)                           /* BS10100 */
          {                                                /* BS10100 */
            DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN,    /* BS10100 */
                         errmsg1, rc)                      /* BS10100 */
          }                                                /* BS10100 */
          rc = ESA_FATAL;                                  /* BS10100 */
        }                                                  /* BS10100 */

        if (rc NE ESA_OK) goto exit;

        } /* end of RACF & ACF2 & TSS verify password */
        /********************************************************
         * CTSRSSLogin of DB2 is seperated in CTSDRSS.
         * Password is not checked for DB2 (we trust APF).
         ********************************************************/
       } /* end of if(strlen(admin_passwd) GT 0)             */

       /************************ ws2490 ends *********************/
       /************************ IS10073 starts ******************
        * password-length is zero with all transactions, so we   *
        * have to handle transactions with password-length=0.    *
        * at least until we can distinguish between AddMSAdmin   *
        * transaction and other transactions. I think with ver5  *
        * ServicesManager there is a transactionType field which *
        * may allow us distinguish...                            *
        ************************ IS10068 starts ******************/
       else
      {
        ESA_DIAG_printf(ESA_COMP_RSS_LOGIN,2,
                        "Password is still empty");
         /*send a msg that password is required...*
         sprintf(errmsg1,"Function=%s MSAdmin=%s \n",func,admin);
         CTSAMSG_print(ERR_PASSWORD_EMPTY,msgs,NULL,dest,errmsg1);
         rc = ESA_FATAL;
         goto exit;  */
        }
       /************************ IS10068 ends ********************/
       /******** IS10073 sets IS10068 as a long remark ends *******/

     }  /* End of non-user admin type processing           /* BS10100 */

     /*
      *  Activate the admin (all types).
      */
     rc = GetLoginHandle(handle, &uid,
                         admin, admin_group, dest, msgs);
     if ( rc NE ESA_OK ) {
       rc = ESA_FATAL;
       goto exit;
     }

     /************************ IS10174 - start *****************/
     /****  The code below is removed because it is done now
      ****   by ActAdmin

    @*  ps0320 -
     *  Decide which CREATE mode to use acc. to rss type & ver
     *@
    @*  is0263 -
     *  Default is CREATE2.
     *  TSS & old ACF2 vers, use CREATE.
     *@

 @*  strcpy (crmode, "CREATE  ");    is0263 *@
     strcpy (crmode, "CREATE2 "); @* is0263 *@

     if (strncmp (admin_params->rss_type, "TSS", 3 ) EQ 0)
        strcpy (crmode, "CREATE  ");  @* is0263 *@
     if (strncmp (admin_params->rss_type, acf2_type, 4) EQ 0)
     {
       rc = ACF2_version_get (acf_version,
                              admin_params);       @*IS10119*@
       @*IS10119 if (rc NE ESA_OK)
       {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func,
                       "ACF2 not active/version not supported",
                       16, __LINE__);
         rc = ESA_FATAL;
         if (uid)
           free(uid);
         goto exit;
       }                                                  *@

       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1 ,
           "ACF2 version is <%s>",acf_version);

       @* Start of ws2403 *@

       @*is0263*@ if (strcmp (acf_version, "6.2 ") LT 0)
               strcpy (crmode, "CREATE  ");

       @*is0263*  if ( (strcmp (acf_version, "6.2 ") EQ 0) OR
                  (strcmp (acf_version, "6.3 ") EQ 0) OR
                  (strcmp (acf_version, "6.4 ") EQ 0) )
               strcpy (crmode, "CREATE2 ");
             @* } of ws2403 & is0263 *@
      }

      @* end of PS0320 *@
      @* Start of bs2390 *@
      @* Deleted by ps0383
       * if (strncmp (admin_params->rss_type, "TSS", 3 ) EQ 0)
       *    strcpy (crmode, "CREATE2 ");
       *@
      @* end     of bs2390 *@
      @* Start of ps0382 *@
      @* is0263 racf is like default
      if (strncmp (admin_params->rss_type, "RACF", 4 ) EQ 0)
         strcpy (crmode, "CREATE2 "); is0263 *@

      @* end     of ps0382 *@

      @*
       *  Create ACEE and keep login handle
       *@

       rc = CreateACEE(uid, crmode, dest, msgs);      @* ps0320 *@
        ***  end of removed code     IS10174   */

      /*
       *    Activate the Administrstor.
       *    If Admin is found and active - use it.
       *    If Admin is not found, or not active - activate and
       *       add to the Admins list.
       *    If no Amdins list, activate.
       */
       /* WS10074
       rc = ActAdmin(admin, admin_group, uid, NULL, admin_params);
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                "ActAdmin for <%s>/<%s>: rc = %s",
                 admin, admin_group, ESA_rc2str(rc));   */
       rc = ActAdmin(admin, admin_group, admin_type,     /* WS10074 */
       /* BS10100 */ appl_name,uid, NULL, admin_params); /* WS10074 */
       /* BS10100    uid, NULL, admin_params);            * WS10074 * */
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,            /* WS10074 */
                "ActAdmin for <%s>/<%s>/<%c>: rc = %s",  /* WS10074 */
                 admin, admin_group, admin_type,         /* WS10074 */
                 ESA_rc2str(rc));                        /* WS10074 */
       if (rc EQ ESA_OK  OR
           rc EQ ESA_SKIP)      /* Error in ActAdmin ? */
         rc = ESA_OK;           /* No - all OK         */
       else
       {
         /* WS10074 - start */
         if (rc NE ESA_ERR)
         {
           /* sprintf(errmsg1,
                  "LOGIN_FIRST: ActAdmin failed.  admin = %s   rc = %s",
                   admin, ESA_rc2str(rc) );   */
           sprintf(errmsg1,
                  "%S: ActAdmin failed.  %s = %s   rc = %s",
                   (input_login_mode EQ LOGIN_MODE_FIRST_USER ?
                         "LOGIN_FIRST_USER" : "LOGIN_FIRST"),
                   (input_login_mode EQ LOGIN_MODE_FIRST_USER ?
                         "user" : "admin"),
                   admin, ESA_rc2str(rc) );
           /* WS10074 - end  */
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func, errmsg1,
                    16, __LINE__);
         }                                               /* WS10074 */
         rc = ESA_FATAL;
       }
     /************************ IS10174 - end   *****************/

       if ( rc EQ ESA_OK )
          *handle = uid;
       else {
           rc = ESA_FATAL;
           if (uid)
             free(uid);
           goto exit;
       }


       break;

      case LOGIN_MODE:

           rc = CheckLoginHandle(handle, &uid, login_mode,
                                 admin, admin_group,
                                 ESA_COMP_RSS_LOGIN,
                                 dest, msgs);
           if ( rc NE ESA_OK ) {
             rc = ESA_FATAL;
             goto exit;
           }

           /* IS10174 - start */
           /*  Verify the admin against admins list  */
           rc = VerAdmin (admin, admin_group, uid->acee, NULL,
                          ESA_COMP_RSS_LOGIN, admin_params);
           ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                "VerAdmin for <%s>/<%s> with acee = %8X: rc = %s",
                 admin, admin_group, uid->acee, ESA_rc2str(rc));

          /*
           *  We allow switching when admins list does not exists or
           *  when the admin entry exists and is active, even if
           *  it is for STC, because we need to allow using the
           *  stc userid as admin, or logging on with the stc userid
           *  as type 'user', when needed (for example, for password
           *  update). The order of the login/logout is managed by
           *  by the allowed_mode, so if the mode is OK we have to
           *  honor the login request.
           */
           if (rc EQ ESA_OK   OR         /* Entry found             */
               rc EQ ESA_NOT_SUPP   OR   /* no admins list          */
               rc EQ ESA_SKIP)           /* entry for stc           */
   /* WS10074  rc EQ ESA_EOF        OR    * entry not found         * */
           {
             /* WS10074 - start */
             /*
             if (rc NE ESA_SKIP)       * admin is not stc - switch   *
             {   */
             /*
              *  Check is switch will be done to the active user.
              *  If yes, skip the switch. The acee_prev in
              *  the login_handle will be set with current acee.
              */
             OS_MVS_whoami( curr_jobname, curr_jobid,
                            curr_userid, curr_sysid, &curr_acee );
             ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                    "WhoAmI: %s / %s / %s / %s / %8X",
                    curr_jobname, curr_jobid, curr_userid,
                    curr_sysid, curr_acee);
             if (uid->acee NE curr_acee) /* we need to switch      */
             {
             /* WS10074 - end   */
             /* IS10174 - end   */
              /*
               *  Switch ACEE
               */
               rc = SwitchACEE(uid,&uid->acee,&uid->acee_prev,
                               LOGIN_SWITCH_MODE,
                               ESA_COMP_RSS_LOGIN,
                               dest,msgs);
               if ( rc NE ESA_OK ) {
                   rc = ESA_FATAL;
                   goto exit;
               }
             /* WS10074 - start */
             }                                           /* IS10174 */
             else
             {
               ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                               "Same acee - switch not required");
               uid->acee_prev = uid->acee;
             }
             /* WS10074 - end  */

           uid->allow_mode[0] = LOGOUT_MODE;
           uid->allow_mode[1] = -1;
           rc = ESA_OK;                                /* IS10174 */

           /* IS10174 - start */
           }
           else
           {
             sprintf(errmsg1,
               "Administrator verification failed. VerAdmin rc = %s",
               ESA_rc2str(rc) );

             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component, func, errmsg1,
                      login_mode, __LINE__);
             rc = ESA_FATAL;
           }
           /* IS10174 - end   */

           break;

      default              :
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                         component, func,
                         "Invalid login mode",
                         input_login_mode, __LINE__);    /* WS10074 */
            /* WS10074   login_mode, __LINE__); */
           rc = ESA_FATAL;
   } /* switch login_mode */

  /*------------------*
   *   Finish         *
   *------------------*/

   exit:;

   ESA_DIAG_exit ( ESA_COMP_RSS_LOGIN, 1, func, rc );
   return rc;

 }

/****************************************************
 * Procedure Name: rss_logout
 * Description   : logout back to initial login
 *
 * Input         : rss name
 *                 administrator name and group
 *                 CTSAMSG stuff
 *
 * Output        : CTSAMSG error structure
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 *
 * Comments      :
 * Scope         :
 ****************************************************/

 ESA_RC CTSRSSLogout (RSS_typ                rss_name,
                      USER_typ               admin,
                      UG_typ                 admin_group,
                      LOGIN_MODE_typ         logout_mode,
                      void                ** handle,
                      ADMIN_PARAMS_rec_typ * admin_params,
                      ERR_STRUCT_rec_typ   * err)
 {

  /*---------------------*
   *   Variables         *
   *---------------------*/

   static char func[]="CTSRSSLogout";

   ESA_RC               rc = ESA_OK;
   ESA_RC               ver_rc = ESA_OK;                 /* IS10174 */
   RACF_UID_rec_typ    *uid  = NULL;
   void                *acee = NULL;
   int                  dbg_lvl;

   char                 errmsg[128] = "";                /* IS10174 */

   RSS_ADMINS_LIST_ENTRY_rec_typ  * admin_ent = NULL;    /* IS10174 */

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;

  /*---------------------*
   *   Initialize        *
   *---------------------*/

   ESA_DIAG_enter ( ESA_COMP_RSS_LOGOUT, 1 , func);


   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   dbg_lvl = (int)ESA_DIAG_get_debug_level(ESA_COMP_RSS_LOGOUT);
   if ( dbg_lvl GT 0 )
      dbg_lvl = 1;

  /*-----------------------*
   *  Check APF authority  *
   *-----------------------*/

   rc = OS_MVS_check_apf( msgs, dest );
   if (rc NE ESA_OK) {
      rc = ESA_OK;
      goto exit;
   }

  /*----------------------------*
   *   Logout mode processing   *
   *----------------------------*/

   ESA_DIAG_printf(ESA_COMP_RSS_LOGOUT, 1,
                   "rss_name=%s admin=%s/%s logout_mode=%d",
                    rss_name, admin, admin_group, logout_mode);

   switch ( logout_mode ) {
      case LOGOUT_MODE:

             rc = CheckLoginHandle(handle, &uid, logout_mode,
                                   admin, admin_group,
                                   ESA_COMP_RSS_LOGOUT,
                                   dest, msgs);
             if ( rc NE ESA_OK ) {
               rc = ESA_FATAL;
               goto exit;
             }

             /* IS10174 - start */
             /*  Verify the admin against admins list  */
             ver_rc = VerAdmin (admin, admin_group, uid->acee, NULL,
                            ESA_COMP_RSS_LOGOUT, admin_params);
             ESA_DIAG_printf(ESA_COMP_RSS_LOGOUT, 6,
                  "VerAdmin for <%s>/<%s> with acee = %8X - rc = %s",
    /* WS10074 */ admin, admin_group, uid->acee, ESA_rc2str(ver_rc));
    /* WS10074    admin, admin_group, uid->acee, ESA_rc2str(rc));  */
             /* WS10074 - start */
             /*
             if (ver_rc NE ESA_SKIP)   * If admin is not stc    *
             */
             if (ver_rc EQ ESA_OK   OR  /* Entry found             */
                 ver_rc EQ ESA_SKIP  OR    /* STC entry               */
                 ver_rc EQ ESA_NOT_SUPP)   /* no admins list          */
             {
               /*
                *  Check is switch willbe done to the active user.
                *  If yes, skip the switch. The acee_prev in
                *  the login_handle will be set with current acee.
                */
               if (uid->acee NE uid->acee_prev)
             /* WS10074 - end   */
               {
             /* IS10174 - end   */
              /*
               *  Switch ACEE
               */

                 rc = SwitchACEE(uid,&uid->acee_prev,&acee,
                                 LOGOUT_SWITCH_MODE,
                                 ESA_COMP_RSS_LOGOUT,
                                 dest,msgs);
                 if ( rc NE ESA_OK ) {
                     rc = ESA_FATAL;
                     goto exit;
                 }

                /*-------------------------------------------------*
                 *   Issue error message if acee is not in cache   *
                 *   (Thus we have an orphan acee)                 *
                 *-------------------------------------------------*/

                 if ( acee NE uid->acee ) {
                   if (strlen(admin_group) GT 0)
                     CTSAMSG_print(RACF_LOGOUT_GROUP_FAIL,msgs,NULL,
                                   dest, uid->admin, uid->admin_group );
                   else CTSAMSG_print(RACF_LOGOUT_FAIL,msgs,NULL,
                                      dest, uid->admin);
                   CTSAMSG_print(RACF_ORPHAN_ACEE, msgs, NULL, dest,
                                 acee);
                   rc = ESA_FATAL;
                   goto exit;
                 }

               /* WS10074 - the code below moved to the else because
                * the change in the if condition.
                * IS10174 - start *
                *  Verify the admin against admins list  *
               ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                    "VerAdmin for <%s>/<%s> with acee = %8X - rc = %s",
                     admin, admin_group, uid->acee, ESA_rc2str(rc));
                * Issue an error messae if error in admins list entry *
               if (ver_rc NE ESA_OK         AND
                   ver_rc NE ESA_NOT_SUPP   AND
                   ver_rc NE ESA_EOF)
               {
                 sprintf(errmsg,
                   "Administrator verification failed. VerAdmin rc = %s",
                   ESA_rc2str(rc) );

                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func, errmsg,
                          logout_mode, __LINE__);
                 rc = ESA_FATAL;
                 goto exit;
               }
                * IS10174 - end   *
               */

                /* WS10074 - the command below us removed because we
                            get here when these fields are equal.
                 *
                 *   Save ACEE
                 *

                 uid->acee          = acee;
                 */
               /* WS10074 - start */
               }
               else
                 ESA_DIAG_printf(ESA_COMP_RSS_LOGOUT, 6,
                                 "Same acee - switch not required");
               /* WS10074 - end  */
             }                                           /* IS10174 */
             /* WS10074 - start */
             else
             {
               /* Issue an error messae if error in admins list entry */
               sprintf(errmsg,
                 "Administrator verification failed. VerAdmin rc = %s",
                 ESA_rc2str(ver_rc) );

               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                        component, func, errmsg,
                        logout_mode, __LINE__);
               rc = ESA_FATAL;
               goto exit;
             }
             /* WS10074 - end  */

             uid->allow_mode[0] = LOGIN_MODE;
             uid->allow_mode[1] = LOGOUT_MODE_LAST;
             rc = ESA_OK;                                /* IS10174 */

           break;

      case LOGOUT_MODE_LAST:
               rc = CheckLoginHandle(handle, &uid, logout_mode,
                                     admin, admin_group,
                                     ESA_COMP_RSS_LOGOUT,
                                     dest, msgs);
               if ( rc NE ESA_OK ) {
                 rc = ESA_FATAL;
                 goto exit;
               }

               /*  IS10174 - start   */
               /*  Verify the admin against admins list  */
   /* WS10074  ver_rc = VerAdmin (admin, admin_group, uid->acee, NULL,*/
               ver_rc = VerAdmin (admin, admin_group,    /* WS10074 */
                                  uid->acee, &admin_ent, /* WS10074 */
                              ESA_COMP_RSS_LOGOUT, admin_params);
               ESA_DIAG_printf(ESA_COMP_RSS_LOGOUT,6,
                    "VerAdmin for <%s>/<%s> with acee = %8X - rc = %s",
   /* WS10074 */     admin, admin_group, uid->acee, ESA_rc2str(ver_rc));
   /* WS10074        admin, admin_group, uid->acee, ESA_rc2str(rc)); */

               /* WS10074 - start */
               if (ver_rc EQ ESA_OK  AND   /* if entry exists  AND  */
                   admin_ent NE NULL AND   /* address returned AND  */
                   admin_ent->type EQ ADMIN_TYPE_USER) /* user entry */
               {
                 rc = TermAdmin(admin_ent,              /* Terminate */
                                ESA_COMP_RSS_LOGOUT, admin_params);
                 ESA_DIAG_printf(ESA_COMP_RSS_LOGOUT, 6,
                         "TermAdmin for entry <%8X>-><%s> - rc = %s",
                         admin_ent, admin_ent->uid,
                         ESA_rc2str(rc));

                 if (rc NE ESA_OK)
                   rc = ESA_FATAL;
               }
               else
               /* WS10074 - end  */

                 if (ver_rc NE ESA_OK  AND /* no valid entry - logoff */
                     ver_rc NE ESA_SKIP)   /* and not stc entry.      */
                 {
                 /* IS10174 - end   */

                  /*
                   *  Release ACEE and free login handle
                   */

  /* IS10174       rc = ReleaseACEE(uid, dest, msgs);                */
                   rc = ReleaseACEE(uid,                 /* IS10174 */
                                    ESA_COMP_RSS_LOGOUT, /* IS10174 */
                                    dest, msgs);         /* IS10174 */
                   if (rc NE ESA_OK)                     /* IS10174 */
                   {                                     /* IS10174 */
                     rc = ESA_FATAL;                     /* IS10174 */
                     goto exit;                          /* IS10174 */
                   }                                     /* IS10174 */
                 }                                       /* IS10174 */

               /* If ReleaseACEE was not done, or was done */
               /* successfully, free the handle.           */
/* IS10174                                                          */
/* IS10174     if ( rc EQ ESA_OK ) {                                */
               free(uid);
               *handle = NULL;
/* IS10174     }                                                    */
/* IS10174     else {                                               */
/* IS10174         rc = ESA_FATAL;                                  */
/* IS10174         goto exit;                                       */
/* IS10174     }                                                    */

               /* IS10174 - start */
               /* Issue an error messae if error in admins list entry */
               if (ver_rc NE ESA_OK         AND
                   ver_rc NE ESA_NOT_SUPP   AND
                   ver_rc NE ESA_SKIP)
     /* WS10074    ver_rc NE ESA_EOF        AND   */
               {
                 sprintf(errmsg,
                 "Administrator verification failed. VerAdmin rc = %s",
                 ESA_rc2str(ver_rc) );

                 CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                          component, func, errmsg,
                          logout_mode, __LINE__);
                 rc = ESA_FATAL;
                 goto exit;
               }
               /* IS10174 - end   */
           break;

      default :
           CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                         component, func,
                         "Invalid logout mode",
                         logout_mode, __LINE__);
           rc = ESA_FATAL;
   }    /* switch logout mode */

  /*-------------------------
   *   Finish               *
   *-------------------------*/

   exit:;

   ESA_DIAG_exit ( ESA_COMP_RSS_LOGOUT, 1,func, rc );
   return rc;

 }

/****************************************************
 * Procedure Name: rss_start_intercept
 * Description   : Submit the offline interceptor
 *
 * Input         : RSS name
 *
 * Output        : None
 *
 * Input/Output  : admin, err
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 ****************************************************/

 ESA_RC CTSInterceptorStart (RSS_typ                rss_name,
                             char                 * host_name,
                             ADMIN_PARAMS_rec_typ * admin_params,
                             ERR_STRUCT_rec_typ   * err)
  {

  /*
   *     Variables
   */

   char   command[130];
   int    cmd_len ;
   /* char   def_procedure[10]="CTSOFI"; */
   char   procedure[10];
   int    debug_level;
   ESA_RC rc = ESA_ERR ;
   static char func[]="CTSInterceptorStart";

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;



  /*---------------------------------------------------------------
   *
   *   Initialize
   *
   *--------------------------------------------------------------*/

   ESA_DIAG_enter ( ESA_COMP_RSS_INTERCEPT,1,func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   debug_level = ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT );

   rc = admin_params->cs_func.rssprm_get_ptr(admin_params->rss_name,
                                         OFLI_STCNAME,
                                         sizeof(procedure), procedure);
   if (rc NE ESA_OK) {
      CTSAMSG_print(ERR_OFLI_PROC_NOTFND, msgs, NULL, dest,
                    OFLI_STCNAME);
      rc=ESA_FATAL ;
      goto exit;
   }

   ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 1,
                    "Get offline start proc name rc=%s proc=%s",
                    ESA_rc2str(rc), procedure );

   if ( strlen(rss_name) EQ 0 )
        sprintf(command, "S %s", procedure);
   else
        sprintf(command, "S %s,RSS=%s", procedure, rss_name);

   cmd_len=strlen(command);

   /* SAS2IBMT
   rc=ctsaopr(&debug_level,&cmd_len,command);                        */
   rc=(*(ASM_RTN_TYP *)&ctsaopr)                          /* SAS2IBMT */
             (&debug_level,&cmd_len,command);

   if ( rc NE 0 ) {
      CTSAMSG_print(ERR_OFLI_START_FAIL, msgs, NULL, dest, rc);
      rc=ESA_FATAL ;
   }

  /*---------------------------------------------------------------
   *
   *   Finish
   *
   *--------------------------------------------------------------*/
  exit :;

   ESA_DIAG_exit ( ESA_COMP_RSS_INTERCEPT,1, func, rc );

   return rc;

  }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : CTSCRSS_set_authority                      *
 *                                                             *
 * DESCRIPTION    : Set started authority, and return back to  *
 *                  administrator aurhority                    *
 *                                                             *
 * INPUT          : logout_done - ptr to control var           *
 *                : mode        - authority set mode           *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC CTSCRSS_set_authority(int                 * logout_done,
                          AUTHORITY_MODE_typ        mode,
                          ADMIN_PARAMS_rec_typ    * admin_params,
                          ERR_STRUCT_rec_typ      * err)
 {

  ESA_RC   rc = ESA_OK;

  *logout_done = FALSE;

  switch ( mode ) {
     case SET_TO_STARTED_TASK_AUTH :

         /*
          * Determine currently authority status :
          * rc = ESA_OK  (under started task authority)
          * rc = ESA_ERR (under administrator login   )
          */

          rc = OS_MVS_chkid(admin_params->os_proc_handle);
          if ( rc EQ ESA_ERR   ) {

            /*  Back to CS - server authority */

            rc = CTSRSSLogout (admin_params->rss_name,
                               admin_params->admin_uname,
                               admin_params->admin_gname,
                               LOGOUT_MODE,
                               &(admin_params->login_handle),
                               admin_params, err);
            if ( rc NE ESA_OK ) {
              OS_MVS_btrace();
              rc = ESA_FATAL;
              goto exit;
            }
            *logout_done = TRUE;
          }
          break;

     case RETURN_FROM_STARTED_TASK_AUTH :

         /*
          * Determine currently authority status :
          * rc = ESA_OK  (under started task authority)
          * rc = ESA_ERR (under administrator login   )
          */

          rc = OS_MVS_chkid(admin_params->os_proc_handle);
          if ( rc EQ ESA_OK ) {

            /*  Back to administrator authority */

            rc = CTSRSSLogin (admin_params->rss_name,
                              admin_params->admin_uname,
                              admin_params->admin_gname,
                              "",
                              LOGIN_MODE,
                              &(admin_params->login_handle),
                              admin_params, err);
            if ( rc NE ESA_OK ) {
              OS_MVS_btrace();
              rc = ESA_FATAL;
              goto exit;
            }
            *logout_done = TRUE;
          }
          else               /* ps0173 */
            rc = ESA_OK;     /* ps0173 */
          break;

     default : break;
     }

  exit :;
     return rc;

 }

/****************************************************
 * Procedure Name : CTSVersion
 * Description    : return API version
 * Input          :
 * Output         : api_version
 * Return Value   : ESA_RC
 * Comments       : Platform-dependent operations to be performed
 *                  prior to any API call.     ws2380
 ***************************************************/
/* WS2531 Moved to CTSxRSS of the USA-API
 ESA_RC CTSVersion (RSS_vers_typ  version)

 {

   ESA_RC rc = ESA_OK;
   strcpy (version, "3.2.00");    *is0066*
   return (rc) ;

 }
*/

 /* IS10174 - start */
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : CTSCRSS_AdminsList_Handle                  *
 *                                                             *
 * DESCRIPTION    : Handle the administrators list.            *
 *                                                             *
 * INPUT          : function     - INIT(ialize)                *
 *                               - INC(rease)                  *
 *                               - TERM(inate)                 *
 *                               - TERMF - reminate and free.  *
 *                                                             *
 *                : p_adminsList -                             *
 *                   INIT - pointer to area for Admins list    *
 *                          address.                           *
 *                   INC  - Pointer to Admins list address.    *
 *                   TERM - pointer to Admins list address     *
 *                          or NULL or pointer to NULL;        *
 *                   TERMF -pointer to Admins list address.    *
 *                                                             *
 *                : Admin params                               *
 *                                                             *
 * OUTPUT         : Area pointed by p_adminsList               *
 *                  INIT - admin list address.                 *
 *                  INC  - new admin list address.             *
 *                  TERMF- NULL.                               *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

 ESA_RC CTSCRSS_AdminsList_Handle ( char              * function,
                             RSS_ADMINS_LIST_rec_typ ** p_admins_list,
                             ESA_DIAG_COMP_typ          diag_comp,
                             ADMIN_PARAMS_rec_typ     * admin_params)
 {


  /*
   *  Initialize Admin_list entries.
   *  s  - index of first entry.
   *  e  - number of last entry.
   *
   *  Required fields:
   *  i - int.
   *  admins_list - should point to admins list.
   *
   */
 #define INIT_ENTRIES(s,  e)                                       \
                                                                   \
   for (i = (s); i LT (e); i++)                                    \
   {                                                               \
     INIT_ADMIN_ENTRY(&admins_list->admin_entry[i])                \
   }

  /*
   *  CAlculate admins list length.
   *  num - number of entries.
   *
   */
 #define ADMIN_TAB_SIZE(num)                                       \
     ( ( sizeof(RSS_ADMINS_LIST_ENTRY_rec_typ) * ((num) - 1) ) +   \
               sizeof(RSS_ADMINS_LIST_rec_typ) )

   static  char       func[] = "CTSCRSS_AdminsList_Handle";

   ESA_RC                     rc = ESA_OK;
   ESA_RC                     max_rc = ESA_OK;
   char                       errmsg[80] = "";
   int                        size = 0;
   int                        i;
   RSS_ADMINS_LIST_rec_typ  * admins_list;

   /* IS10184 DUMMY_PARAMS_rec_typ     * params_ptr = NULL;  */
   COMMON_PARAMS_rec_typ    * common_params = NULL;

   char     curr_jobname[9] = "";
   char     curr_jobid[9]   = "";
   char     curr_userid[9]  = "";
   char     curr_sysid[5]  = "";
   void   * curr_acee = NULL;

   char     vio_name[9] = "VIO     ";
   int      vio_rc = 0;

   char     recfm_name[9] = "RECFM   ";
   int      recfm_rc = 0;

   char     lrecl_name[9] = "LRECL   ";
   int      lrecl_rc = 0;

   char     blksize_name[9] = "BLKSIZE ";
   int      blksize_rc = 0;

   char     pspace_name[9] = "PSPACE ";
   int      pspace_rc = 0;

   char     sspace_name[9] = "SSPACE ";
   int      sspace_rc = 0;

   char     tspace_name[9] = "TSPACE ";
   int      tspace_rc = 0;

   char     avgblk_name[9] = "AVGBLK ";
   int      avgblk_rc = 0;

   RSS_ADMINS_LIST_ENTRY_rec_typ  * admin_ent;

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;


  /*
   *   Initialization
   */
   ESA_DIAG_enter ( diag_comp, 1 , func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(diag_comp, 6,
                 "Function = %s   p_admins_list = %8X",
                  function, p_admins_list);

  /*
   *   Allocate and initialize the list
   */
   if (strcmp(function, "INIT") EQ 0)
   {
     if (p_admins_list EQ NULL)
     {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     component, func,
                     "Admins List pointer not provided",
                   16, __LINE__);
       rc = ESA_FATAL;
       goto exit;
     }


     /*   Allocate the list .    */
     ESA_DIAG_printf(diag_comp, 6,
                    "Adminlist: Header len = %d   Entry len = %d",
                    sizeof(RSS_ADMINS_LIST_rec_typ),
                    sizeof(RSS_ADMINS_LIST_ENTRY_rec_typ) );
     size = ADMIN_TAB_SIZE(RSS_ADMINS_ENT_NUM);
     ESA_DIAG_printf(diag_comp, 6,
                    "Admins list size = %d", size);

     admins_list = (RSS_ADMINS_LIST_rec_typ *) malloc(size);
     ESA_DIAG_printf(diag_comp, 6,
                    "Admins list = %8X", admins_list);
     if  (admins_list  EQ NULL)
     {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "Admins List", size);
       rc = ESA_FATAL;
       goto exit;
     }

     /*   Initialize the header   */
     strcpy(admins_list->eyec, ADMINS_LIST_EYEC);
     admins_list->max_entries = RSS_ADMINS_ENT_NUM;
     admins_list->used_entries = 0;
     strcpy(admins_list->static_EXECOUT, EXECOUT_DDNAME_STATIC);
     strcpy(admins_list->prefix_EXECOUT, EXECOUT_DDNAME_PREFIX);
     admins_list->Next_EXECOUT_num = 0;
     admins_list->execout_vio = ' ';
     admins_list->execout_lrecl = 0;
     memset(admins_list->execout_recfm, NULL_CHAR,
            sizeof(admins_list->execout_recfm));
     admins_list->execout_blksize = 0;
     admins_list->execout_pspace = 0;
     admins_list->execout_sspace = 0;
     admins_list->execout_tspace = ' ';
     admins_list->execout_avgblk = 0;


     /*  Retrieve EXECOUT details  */
     rc = OS_MVS_ddinfo(admins_list->static_EXECOUT,
              NULL, TRUE, dest, msgs, 8,
              vio_name,     &admins_list->execout_vio,      &vio_rc,
              lrecl_name,   &admins_list->execout_lrecl,    &lrecl_rc,
              recfm_name,    admins_list->execout_recfm,    &recfm_rc,
              blksize_name, &admins_list->execout_blksize,  &blksize_rc,
              pspace_name,  &admins_list->execout_pspace,   &pspace_rc,
              sspace_name,  &admins_list->execout_sspace,   &sspace_rc,
              tspace_name,  &admins_list->execout_tspace,   &tspace_rc,
              avgblk_name,  &admins_list->execout_avgblk,   &avgblk_rc);

     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo:  ddn = %s   rc = %s",
             admins_list->static_EXECOUT, ESA_rc2str(rc) );
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: vio = %s / %c / %d",
             vio_name, admins_list->execout_vio, vio_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: recfm = %s / %s / %d",
             recfm_name, admins_list->execout_recfm, recfm_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: lrecl = %s / %d / %d",
             lrecl_name, admins_list->execout_lrecl, lrecl_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: blksize = %s / %d / %d",
             blksize_name, admins_list->execout_blksize, blksize_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: pspace = %s / %d / %d",
             pspace_name, admins_list->execout_pspace, pspace_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: sspace = %s / %d / %d",
             sspace_name, admins_list->execout_sspace, sspace_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: tspace = %s / %c / %d",
             tspace_name, admins_list->execout_tspace, tspace_rc);
     ESA_DIAG_printf(diag_comp, 6,
             "OS_MVS_ddinfo: avgblk = %s / %d / %d",
             avgblk_name, admins_list->execout_avgblk, avgblk_rc);

     if (rc EQ ESA_OK)     /* EXECOUT was found   */
     {
       if (admins_list->execout_tspace   EQ '?'  OR
           admins_list->execout_recfm[0] EQ '?')
       {
         sprintf(errmsg, "unknown %s value",
               (admins_list->execout_tspace EQ '?' ?
                                           "space type" : "recfm"));
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func, errmsg,
                       16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
       }
     }
     else
       if (rc EQ ESA_NOT_SUPP)    /* EXECOUT was not found */
       {
         admins_list->static_EXECOUT[0] = NULL_CHAR;
         admins_list->prefix_EXECOUT[0] = NULL_CHAR;
       }
       else                  /* error */
       {
         sprintf(errmsg, "OS_MVS_ddinfo return code is %s",
                          ESA_rc2str(rc) );
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func, errmsg,
                       16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
       }


     /*   Initialize the entries  */
     INIT_ENTRIES(0, RSS_ADMINS_ENT_NUM)

     ESA_DIAG_printf(diag_comp, 6,
                    "Admins list = %d / %d / %s / %s / %d",
                    admins_list->max_entries,
                    admins_list->used_entries,
                    admins_list->static_EXECOUT,
                    admins_list->prefix_EXECOUT,
                    admins_list->Next_EXECOUT_num);

     /*   Set an entry for STC userid  */
     /*  Get jobname, jobid and userid who sent a job   */
     OS_MVS_whoami( curr_jobname, curr_jobid, curr_userid,
                    curr_sysid, &curr_acee );
     ESA_DIAG_printf(diag_comp, 6,
            "WhoAmI: %s / %s / %s / %s / %8X",
            curr_jobname, curr_jobid, curr_userid,
            curr_sysid, curr_acee);

     /* WS10074 admins_list->used_entries++; */
     admins_list->used_entries = 1;                      /* WS10074 */
     admin_ent = &admins_list->admin_entry[0];
     /* WS10074 - start */
     /*
     FILL_ADMIN_ENTRY(admin_ent,
                      curr_userid, "", 'Y', curr_acee,
                      admins_list->static_EXECOUT, 'N')
     ESA_DIAG_printf(diag_comp, 6,
          "Admin entry = %s / %s / %8X / %c / %s / %c",
           admin_ent->uid, admin_ent->group,
           admin_ent->acee, admin_ent->is_stc,
           admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);
     */
     FILL_ADMIN_ENTRY(admin_ent, admins_list->used_entries,
       /* BS10100     curr_userid, "", ADMIN_TYPE_STC, curr_acee, */
                      curr_userid, "", ADMIN_TYPE_STC,     /* BS10100 */
                      ALLOWED_ADMIN_NONE, curr_acee,       /* BS10100 */
                      admins_list->static_EXECOUT, 'N')

     ESA_DIAG_printf(diag_comp, 6,
 /* BS10100 "Admin entry = %8X -> %d / %s / %s / %8X / %c / %s / %c", */
        "Admin entry = %8X -> %d / %s / %s / %8X / %c / %c / %s / %c",
             admin_ent, admin_ent->seq_num,
             admin_ent->uid, admin_ent->group,
             admin_ent->acee, admin_ent->type,
             admin_ent->allowed,                           /* BS10100 */
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);
     /* WS10074 - end  */

     /*   Return addressd to caller. */
     *p_admins_list = admins_list;
     rc = ESA_OK;
   }
   else
   {
    /*
     *   Increase list size
     */
     if (strcmp(function, "INC") EQ 0)
     {
       if ( p_admins_list EQ NULL   OR
            (p_admins_list NE NULL  AND *p_admins_list EQ NULL) )
       {
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func,
                       "Admins List address not provided",
                       16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
       }

       ESA_DIAG_printf(diag_comp, 6,
                 "Input Admins list = %8X /%d / %d / %s / %s / %d",
                 *p_admins_list,
                 (*p_admins_list)->max_entries,
                 (*p_admins_list)->used_entries,
                 (*p_admins_list)->static_EXECOUT,
                 (*p_admins_list)->prefix_EXECOUT,
                 (*p_admins_list)->Next_EXECOUT_num);

       /*   Re-allocate the list    */
       ESA_DIAG_printf(diag_comp, 6,
                      "Adminlist: Header len = %d   Entry len = %d",
                      sizeof(RSS_ADMINS_LIST_rec_typ),
                      sizeof(RSS_ADMINS_LIST_ENTRY_rec_typ) );

       size = ADMIN_TAB_SIZE(
              (*p_admins_list)->max_entries + RSS_ADMINS_ENT_NUM) ;
       ESA_DIAG_printf(diag_comp, 6,
                      "New Admins list size = %d", size);

       admins_list = (RSS_ADMINS_LIST_rec_typ *)realloc(*p_admins_list,
                                                         size);
       if  (admins_list  EQ NULL)
       {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                       "Realloc of Admins List", size);
         rc = ESA_FATAL;
         goto exit;
       }

       /*   Initialize the entries  */
       INIT_ENTRIES(admins_list->max_entries,
                     admins_list->max_entries + RSS_ADMINS_ENT_NUM)

       /*   Initialize the header   */
       admins_list->max_entries += RSS_ADMINS_ENT_NUM;

       ESA_DIAG_printf(diag_comp, 6,
                    "New Admins list = %8X / %d / %d / %s / %s / %d",
                    admins_list,
                    admins_list->max_entries,
                    admins_list->used_entries,
                    admins_list->static_EXECOUT,
                    admins_list->prefix_EXECOUT,
                    admins_list->Next_EXECOUT_num);

       /*   Return addressd to caller. */
       *p_admins_list = admins_list;
       rc = ESA_OK;
     }
     else
     {
      /*
       *   Terminate all admins
       */
       if (strncmp(function, "TERM", 4) EQ 0)
       {
         if ( p_admins_list EQ NULL   OR
              (p_admins_list NE NULL  AND *p_admins_list EQ NULL) )
         {
           if (strcmp(function, "TERMF") EQ 0)
           {
             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                           component, func,
                           "Admins List address not provided",
                           16, __LINE__);
             rc = ESA_FATAL;
             goto exit;
           }
           else
           {
             /* iS10184 - start */
             /*
             GET_ADMINSLIST_ADDR(params_ptr, common_params, admins_list)
             ESA_DIAG_printf(diag_comp, 6,
                "PTRs:  params = %8X   common = %8X   adminlist = %8X",
                params_ptr, common_params, admins_list);
             */
             GET_ADMINSLIST_ADDR(common_params, admins_list)
             ESA_DIAG_printf(diag_comp, 6,
                "PTRs:  common = %8X   adminlist = %8X",
                common_params, admins_list);
             /* iS10184 - end   */

             if (admins_list EQ NULL)
             {
               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                             component, func,
                             "Admins List address not found",
                             16, __LINE__);
               rc = ESA_FATAL;
               goto exit;
             }
           }
         }
         else
           admins_list = *p_admins_list;

         /* Terminate all admins   */
         for (i = 0; i LT admins_list->used_entries; i++)
         {
            rc = TermAdmin(&admins_list->admin_entry[i], diag_comp,
                           admin_params);
            ESA_DIAG_printf(diag_comp, 6,
                    "TermAdmin for entry <%8X>-><%s> - rc = %s",
                    &admins_list->admin_entry[i],
                    admins_list->admin_entry[i].uid, ESA_rc2str(rc));

            if (rc NE ESA_OK)
              max_rc = ESA_FATAL;
         }

         /* Free the list, if requested  */
         if (function[4] EQ 'F')   /* TERMF ?  */
         {
           free (admins_list);

           /* IS10184 -  this code is not relevant because
                         TERMF isnot supported when admins_list
                         address is not passed
           if (p_admins_list EQ NULL   OR
              (p_admins_list NE NULL  AND *p_admins_list EQ NULL) )
           {
             common_params->RSS_Admins_list = NULL;
           }
           else
             if (p_admins_list NE NULL)
              end of non-relevant code  - IS10184 */
           *p_admins_list = NULL;
         }

         rc = max_rc;

       }
       else
       {
        /*
         *   unknown request
         */
         sprintf(errmsg, "Invalid function %s", function);
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                       component, func, errmsg,
                       16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
       }
     }
   }


  exit:;
   if (strcmp(function, "INIT") EQ 0   AND
       rc NE ESA_OK)
   {
     if (admins_list NE NULL)
       free (admins_list);
   }

   ESA_DIAG_exit ( diag_comp, 1, func, rc );
   return rc;

 }


 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : ActAdmin                                   *
 *                                                             *
 * DESCRIPTION    : Activate an administrator, if not already  *
 *                  active.                                    *
 *                                                             *
 * INPUT          : admin        - userid of the admin to be   *
 *                                 added to the list.          *
 *                : admin_group  - Admin group name.           *
 *                : admin_type   - admin entry type:           *
 *                : appl_name    - APPL name                   *
 *                : in_handle    - Handle received by caller.  *
 *                : admin_params                               *
 *                                                             *
 * OUTPUT         : p_ent        - -> area for Admin entry     *
 *                                    address.                 *
 *                                 NULL - do not return.       *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                  ESA_OK - added successfully.               *
 *                  ESA_SKIP - No table. Admin activated       *
 *                             successfully.                   *
 *     WS10074      ESA_ERR   - Error - a message was issued   *
 *     WS10074                  and no more messages are req.  *
 *                  ESA_FATAL - Error - a message is issued.   *
 *                                                             *
 *                                                             *
 **************************************************************/

 static ESA_RC ActAdmin (USER_typ                         admin,
                         UG_typ                           admin_group,
          /* WS10074 */  char                             admin_type,
          /* BS10100 */  char                           * appl_name,
                         RACF_UID_rec_typ               * login_handle,
                         RSS_ADMINS_LIST_ENTRY_rec_typ ** p_ent,
                         ADMIN_PARAMS_rec_typ           * admin_params)
 {
   static char      func[] = "ActAdmin";

   ESA_RC                     rc = ESA_OK;
   USER_typ                   up_admin= "";
   UG_typ                     up_admin_group = "";
   char                       crmode[9] = "";
   char                       update_logon_stats[2] = ""; /* WS10073 */
   /* IS10184 DUMMY_PARAMS_rec_typ     * params_ptr = NULL; */
   COMMON_PARAMS_rec_typ    * common_params = NULL;
   RSS_ADMINS_LIST_rec_typ  * admins_list = NULL;
   RSS_ADMINS_LIST_ENTRY_rec_typ  * admin_ent = NULL;
   int                        i;
   int                        is_act = FALSE;
   /* BS10100 char                       errmsg[80] = "";         */
   char                       errmsg[180] = "";            /* BS10100 */
   short                      seq_num = 0;                 /* BS10100 */
   char                       allowed = ALLOWED_ADMIN_NONE; /*BS10100 */
   int                        ver_rc;                      /* BS10100 */
   int                        saf_rc, racf_rc, racf_rs;    /* BS10100 */
   int                        dbg_lvl = 0;                 /* BS10100 */
   short                      seq;                         /* BS10100 */

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;


  /*
   *   Initialization
   */
   ESA_DIAG_enter (ESA_COMP_RSS_LOGIN, 1 , func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1,
               "ActAdmin:  admin = %s   group = %s",
               admin, admin_group);

   dbg_lvl = (int)ESA_DIAG_get_debug_level(                /* BS10100 */
                                    ESA_COMP_RSS_LOGIN);   /* BS10100 */
   if ( dbg_lvl GT 0 )                                     /* BS10100 */
      dbg_lvl = 1;                                         /* BS10100 */

   TO_UPPER(admin, up_admin)
   if (admin_group NE NULL)
     TO_UPPER(admin_group, up_admin_group)

  /*
   *   Get Admins list address.
   */
   /* IS10184
   GET_ADMINSLIST_ADDR(params_ptr, common_params, admins_list)
   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                 "PTRs:  params = %8X   common = %8X   adminlist = %8X",
                 params_ptr, common_params, admins_list);   */
   GET_ADMINSLIST_ADDR(common_params, admins_list)        /* IS10184 */

   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,                 /* IS10184 */
                 "PTRs:   common = %8X   adminlist = %8X",/* IS10184 */
                 common_params, admins_list);             /* IS10184 */

   if ( admins_list NE NULL )
   {
    /*
     *   If Admins list exists, Look for Admin entry
     *   - if entry does not exist - init a new entry.
     *   - if entry exists and is not active - reuse.
     *   - if entry exists and active - adjust type, if needed
     *     and take acee.
     */
     FIND_ADMIN(up_admin, up_admin_group, admin_ent, ESA_COMP_RSS_LOGIN)
     ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                     "Find Amdin:  ent = %8X",
                     admin_ent);

     if (admin_ent EQ NULL)          /* Not found - add to the list */
     {
       /*  If not enough space in admins list - increase */
       /*  and update pointer from common_params         */
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                       "Amdins list:  max = %d   used = %d",
                       admins_list->max_entries,
                       admins_list->used_entries);
       if (admins_list->used_entries EQ admins_list->max_entries)
       {
         rc = CTSCRSS_AdminsList_Handle ("INC", &admins_list,
                                         ESA_COMP_RSS_LOGIN,
                                         admin_params);
         ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
          "CTSCRSS_AdminsList_Handle<INC>: rc = %s  admins_list = %8X",
           ESA_rc2str(rc), admins_list);

         if (rc NE ESA_OK)
         {
           rc = ESA_FATAL;
           goto exit;
         }

         common_params->RSS_Admins_list = admins_list;
       }

       admin_ent =
             &admins_list->admin_entry[admins_list->used_entries];
     }
     else                          /* Admin exists           */
     {
       /* BS10100 - start */
       /*
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                     admin_ent->uid, admin_ent->group,
           * WS10074   admin_ent->acee, admin_ent->is_stc, *
                     admin_ent->acee, admin_ent->type,  * WS10074 *
                     admin_ent->EXECOUT_ddname,
                     admin_ent->EXECOUT_dynamic);
       */
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                "Admin found:  %d - %s / %s / %8X / %c / %c / %s / %c",
                 admin_ent->seq_num,
                 admin_ent->uid, admin_ent->group,
                 admin_ent->acee, admin_ent->type, /* WS10074 */
                 admin_ent->allowed,
                 admin_ent->EXECOUT_ddname,
                 admin_ent->EXECOUT_dynamic);

       /*  The code below was removed by BS10100
       if ((int)admin_ent->acee EQ RSS_ADMINS_INACT_ENT)  * inact? *
       {
         INIT_ADMIN_ENTRY(admin_ent)
       }
       else
       */
       if ( (int)admin_ent->acee NE RSS_ADMINS_INACT_ENT  AND
            admin_ent->acee NE NULL )    /* Entry is active ?  */
       {
         ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                         "Admin %s is active", admin_ent->uid);

         /*
         *  We have an active entry for the admin:
         *
         *  If requested type is Admin, and we have to verify if
         *  the admin is allowed:
         *  - If entry type Admin:
         *    - If entry is allowed - use it.
         *    - If entry not allowed (NONE or NO) - this is an
         *      error - issue an error message, and terminate the
         *      admin to allow re-login.
         *  - If entry type STC:
         *    - If entry is allowd - use it.
         *    - If entry is not allowed - reject the request.
         *    - If unknown (NONE) - call CTSAFAT check if the
         *      admin is allowed to use the appl name.
         *      - If it is, set allowed=YES in the entry and use it.
         *      - If it is not, set allowed=NO in the entry and
         *        reject the request.
         *  - If entry type User
         *    Terminate the entry to allow re-login as admin.
         */

         /* If required type is Admin and we have to check if allowed */
         if ( admin_type EQ ADMIN_TYPE_ADMIN  AND
              appl_name[0] GT ' ' )
         {
           ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                           "Admin = %s (%c), allowed = %c",
                           admin_ent->uid, admin_ent->type,
                           admin_ent->allowed);

           switch (admin_ent->type)
           {
             case ADMIN_TYPE_ADMIN:  /* If entry type is A:          */
               /* If entry is allowed - use it.                     */
               if ( admin_ent->allowed EQ ALLOWED_ADMIN_YES )
               {
                 ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                                 "Admin = %s (%c)  allowed",
                                  admin_ent->uid, admin_ent->type);
                 rc = ESA_OK;
               }
               else
               {
                 /* If entry not allowed - issue an error         */
                 /* message and fail the request.                 */
                  sprintf(errmsg,
                      "Admin entry for %s, type %c, has allowed=<%c>",
                     admin, admin_ent->uid);
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                                component, func, errmsg,
                                16, __LINE__);
                  ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1,
                                  "Admin entry error - %s", errmsg);

                  rc = ESA_FATAL;
               }
               break;

             case ADMIN_TYPE_STC:      /* If entry type is S:       */
               switch (admin_ent->allowed) /* Check is allowed      */
               {
                 case ALLOWED_ADMIN_YES:  /* Allowed - use it       */
                   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                                   "Admin = %s (%c)  allowed",
                                   admin_ent->uid, admin_ent->type);
                   rc = ESA_OK;
                   break;

                 case ALLOWED_ADMIN_NO:  /* No Allowed - Reject.    */
                   CTSAMSG_print(ADMIN_NOT_ALLOWED_APPL,
                                 msgs, NULL, dest,
                                 admin, appl_name);
                   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                                   "Admin = %s (%c)  not allowed",
                                   admin_ent->uid, admin_ent->type);
                   rc = ESA_ERR;
                   break;

                 case ALLOWED_ADMIN_NONE:  /* Unknown - verify.     */
                   /* Call CTSAFAT to check if admin is allowed     */
                   /* to access the APPL name.                      */
                   ver_rc = (*(ASM_RTN_TYP *)&OS_DYNAM_call)
                             ("CTSAFAT ",
                              1,         /* routine has parameters */
                              "APPL",
                              "LOGASIS", /* LOG=ASIS */
                              appl_name,
                              admin_ent->acee,
                              &dbg_lvl,
                              &saf_rc,
                              &racf_rc,
                              &racf_rs);
                   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                "CTSAFAT for %s / %8X and APPL %s: rc = %d - %d/%d/%d",
                       admin_ent->uid, admin_ent->acee,
                       appl_name, ver_rc,
                       saf_rc, racf_rc, racf_rs);

                   if (ver_rc EQ 0)    /* Allowed */
                   {
                      admin_ent->allowed = ALLOWED_ADMIN_YES;

                      ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                                      "Admin = %s (%c) allowed",
                                      admin_ent->uid, admin_ent->type);
                      rc = ESA_OK;
                   }
                   else
                     if (ver_rc EQ 8)     /* Not allowed */
                     {
                       admin_ent->allowed = ALLOWED_ADMIN_NO;

                       CTSAMSG_print(ADMIN_NOT_ALLOWED_APPL,
                                     msgs, NULL, dest,
                                     admin, appl_name);
                       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                       "Admin = %s (%c) not allowed for APPL %s",
                        admin_ent->uid, admin_ent->type, appl_name);
                       rc = ESA_ERR;
                     }
                     else          /* Error               */
                     {
                       sprintf(errmsg,
                        "CTSAFAT for APPL %s returned rc %d - %d/%d/%d",
                        appl_name, ver_rc,
                        saf_rc, racf_rc, racf_rs);
                       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                                     component, func,
                                     errmsg, ver_rc,  __LINE__);
                       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                                       "Admin = %s (%c): %s",
                                       admin_ent->uid, admin_ent->type,
                                       errmsg);
                       rc = ESA_FATAL;
                     }
                   break;

                 default:    /* Invalid "allowed" value - error */
                   sprintf(errmsg,
                     "Admin %s Entry=%8X: Allowed=%s/%2X is invalid",
                      admin_ent->uid, admin_ent, admin_ent->allowed,
                      admin_ent->allowed, admin_ent->allowed);
                   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                                 component, func,
                                 errmsg, 16,  __LINE__);
                   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1,
                            "Admin entry error: %s with rc = %d",
                             errmsg, ver_rc);
                   rc = ESA_FATAL;
                   break;
               }
               break;

             case ADMIN_TYPE_USER:     /* If entry type is U:   */
               DO_TERMADMIN(admin_ent, ESA_COMP_RSS_LOGIN,
                            errmsg, rc)
               break;

             default:      /* Entry type unknown - error */
               sprintf(errmsg,
                 "Admin %s Entry=%8X: type=%s/%2X is invalid",
                  admin_ent->uid, admin_ent, admin_ent->allowed,
                  admin_ent->type, admin_ent->type);
               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                             component, func,
                             errmsg, 16,  __LINE__);
               ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 1,
                        "Admin entry error: %s", errmsg);
               rc = ESA_FATAL;
               break;
           }

       /* The code below was moved down by BS10100

          * Adjust entry type, if needed.                   WS10074 *
         if (admin_ent->type EQ ADMIN_TYPE_USER  AND      * WS10074 *
             admin_type EQ ADMIN_TYPE_ADMIN)              * WS10074 *
           admin_ent->type = ADMIN_TYPE_ADMIN;            * WS10074 *

          * Copy acee address to handle                            *
         login_handle->acee = admin_ent->acee;
         rc = ESA_OK;
         goto exit;
       */
         }      /* type=admin and appl   */
       }        /* Active entry found    */
       /* BS10100 - end   */
     }         /* Admin Entry Exists   */
   }           /* Admins list exists  */

   /* BS10100 - start */
   /*
    *  - If any error - out.
    *  - If all is OK and entry is active - take the entry,
    *  - Else - do login.
    */
   if ( rc EQ ESA_OK)
   {
     /* If entry exists and is active, use it.   */
     if (admin_ent NE NULL                            AND
         (int)admin_ent->acee NE RSS_ADMINS_INACT_ENT AND
            admin_ent->acee NE NULL )
     {
       /* Adjust entry type, if needed.                   WS10074 */
       if (admin_ent->type EQ ADMIN_TYPE_USER  AND     /* WS10074 */
           admin_type EQ ADMIN_TYPE_ADMIN)             /* WS10074 */
         admin_ent->type = ADMIN_TYPE_ADMIN;           /* WS10074 */

       /* Copy acee address to handle                            */
       login_handle->acee = admin_ent->acee;
       goto exit;
     }
   }
   else       /* RC is not OK  */
     goto exit;
   /* BS10100 - end   */

  /*
   *   Activate the Admin, if inactive or if no admin table.
   *
   *   When activated, the acee address is put direclty in login_handle
   */

   if (strncmp (admin_params->rss_type, "TSS", 3 ) EQ 0)
     strcpy(crmode, LOGON_CREATE);
   else
     strcpy(crmode, LOGON_CREATE2);

   /* * * * * * * WS10073 start * * * * * * */
   if (common_params NE NULL)
     strcpy(update_logon_stats,
           common_params->rssparm_UPDATE_LOGON_STATS);
   else    /* If no common params, set default to N  */
   {
     update_logon_stats[0] = 'N';
     update_logon_stats[1] = NULL_CHAR;
   }
   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 3,
     "UPDATE_LOGON_STATS = %c", *update_logon_stats);

   /* WS10073 rc = CreateACEE(login_handle, crmode, dest, msgs); */
   /* BS10100
   rc = CreateACEE(login_handle, crmode, update_logon_stats,
                   dest, msgs);
   */
   rc = CreateACEE(login_handle, crmode,                   /* BS10100 */
                   update_logon_stats,                     /* BS10100 */
                   appl_name, dest, msgs);                 /* BS10100 */

   /* * * * * * * WS10073 end * * * * * * */

   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                   "CreateACEE: mode=%s  update=%s  rc=%s  acee=%8X",
                   crmode, update_logon_stats,            /* WS10073 */
                   ESA_rc2str(rc), login_handle->acee);

   if ( rc NE ESA_OK )
   {
     /* WS10074 rc = ESA_FATAL;  */
     rc = ESA_ERR;                                       /* WS10074 */
     goto exit;
   }

  /*
   *  If Admin entry is used - fill, if needed, and return.
   */
   if (admin_ent NE NULL)
   {
     /* WS10074 FILL_ADMIN_ENTRY(admin_ent, up_admin, up_admin_group,
                      'N', login_handle->acee, "", ' ')              */
     if (admin_ent->seq_num NE 0)   /* If inactive entry *//* BS10100 */
       seq = admin_ent->seq_num;    /* Use its num       *//* BS10100 */
     else                           /* New Entry         *//* BS10100 */
     {                                                     /* BS10100 */
       admins_list->used_entries++;     /* Increase num  *//* BS10100 */
       seq = admins_list->used_entries;                    /* BS10100 */
     }                                                     /* BS10100 */

     if (appl_name[0] GT ' ')   /* If APPL was supplied  *//* BS10100 */
       allowed = ALLOWED_ADMIN_YES; /* admin allowed     *//* BS10100 */
     else                           /* else              *//* BS10100 */
       allowed = ALLOWED_ADMIN_NONE; /* we don't know    *//* BS10100 */

     /* WS10074 - start */
     /* BS10100 - start */
     /*
     FILL_ADMIN_ENTRY(admin_ent,
                  admins_list->used_entries,
                  up_admin, up_admin_group, admin_type,
                  login_handle->acee, "", ' ')
     */
     FILL_ADMIN_ENTRY(admin_ent, seq,
                      up_admin, up_admin_group, admin_type,
                      allowed, login_handle->acee, "", ' ')
     /* BS10100 - end   */

     /* ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
            "Admin entry = %8X -> %s / %s / %8X / %c / %s / %c",
             admin_ent, admin_ent->uid, admin_ent->group,
             admin_ent->acee, admin_ent->is_stc,
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic); */
     ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
  /* BS10100 "Admin entry = %8X -> %d / %s / %s / %8X / %c / %s / %c",*/
          "Admin entry = %8X -> %d / %s / %s / %8X / %c / %c / %s / %c",
          admin_ent, admin_ent->seq_num,
             admin_ent->uid, admin_ent->group,
             admin_ent->acee, admin_ent->type,
             admin_ent->allowed,                           /* BS10100 */
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);
     /* WS10074 - end  */

     if (p_ent NE NULL)
       *p_ent = admin_ent;
     rc = ESA_OK;
   }
   else
   {
     if (p_ent NE NULL)
       *p_ent = NULL;       /* No admin entry  */
     rc = ESA_SKIP;
   }


  /*
   *  Return
   */

  exit:;
   ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
            "return:  rc = %s", ESA_rc2str(rc));

   ESA_DIAG_exit (ESA_COMP_RSS_LOGIN, 1, func, rc );

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : VerAdmin                                   *
 *                                                             *
 * DESCRIPTION    : Verify Administrator entry if exists       *
 *                  in the administrastors list.               *
 *                                                             *
 * INPUT          : Admin        - userid of the admin whose   *
 *                                 entry is requested. If NULL *
 *                                 take current userid and     *
 *                                 verify current acee against *
 *                                 the entry.                  *
 *                : Admin_group  - group for admin.            *
 *                                 If NULL and Admin is not    *
 *                                 null, set empty string.     *
 *                : acee         - acee address to be          *
 *                                 verified againstthe entry.  *
 *                                 NULL - no compare is done.  *
 *                : diag_comp                                  *
 *                : Admin_params                               *
 *                                                             *
 * OUTPUT         : p_admin_entry- - -> area for Admin entry   *
 *                                      address.               *
 *                                   NULL - do not return.     *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                  - ESA_OK - entry found, active and OK.     *
 *                  - ESA_NOT_SUPP - No Admins list.           *
 *                  - ESA_SKIP - Entry is for stc userid.      *
 *                  - ESA_WARN - entry found inactive.         *
 *                  - ESA_ERR - acee's do not match.           *
 *                  - ESA_EOF - entry not found.               *
 *                                                             *
 **************************************************************/

 static ESA_RC VerAdmin (USER_typ                         admin,
                         UG_typ                           admin_group,
                         void                           * acee,
                         RSS_ADMINS_LIST_ENTRY_rec_typ ** p_admin_ent,
                         ESA_DIAG_COMP_typ                diag_comp,
                         ADMIN_PARAMS_rec_typ           * admin_params)
 {

   static char      func[] = "VerAdmin";

   ESA_RC                     rc = ESA_OK;
   /* IS10184 DUMMY_PARAMS_rec_typ     * params_ptr = NULL;  */
   COMMON_PARAMS_rec_typ    * common_params = NULL;
   RSS_ADMINS_LIST_rec_typ  * admins_list = NULL;
   RSS_ADMINS_LIST_ENTRY_rec_typ  * admin_ent = NULL;
   int                        i;
   void     * acee4ver = NULL;   /* acee for verification     BS10100 */

   char       curr_jobname[9] = "";
   char       curr_jobid[9] = "";
   USER_typ   curr_userid = "";
   char       curr_sysid[5] = "";
   void     * curr_acee = NULL;
   USER_typ   up_admin = "";
   UG_typ     up_admin_grp = "";

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;

  /*
   *   Initialization
   */
   ESA_DIAG_enter (diag_comp, 1 , func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(diag_comp, 6,
               "Input:  admin = %s  group = %s  acee = %8X",
               admin, admin_group, acee);

   /*   If admin was not provided, get current userid   */
   if (admin EQ NULL)
   {
     OS_MVS_whoami( curr_jobname, curr_jobid, curr_userid,
                    curr_sysid, &curr_acee );
     ESA_DIAG_printf(diag_comp, 6,
          "WhoAmI: %s / %s / %s / %s / %8X",
          curr_jobname, curr_jobid, curr_userid,
          curr_sysid, curr_acee);
     TO_UPPER(curr_userid, up_admin)
     acee4ver = curr_acee;                                 /* BS10100 */
   }
   else    /* look for admin provided   */
   {
     TO_UPPER(admin, up_admin)

     if (admin_group NE NULL)
       TO_UPPER(admin_group, up_admin_grp)

     acee4ver = acee;                                      /* BS10100 */
   }


  /*
   *   Get Admins list address.
   */
   /* IS10184
   GET_ADMINSLIST_ADDR(params_ptr, common_params, admins_list)
   ESA_DIAG_printf(diag_comp, 6,
               "PTRs:  params = %8X   common = %8X   adminlist = %8X",
               params_ptr, common_params, admins_list);  */
   GET_ADMINSLIST_ADDR(common_params, admins_list)        /* IS10184 */

   ESA_DIAG_printf(diag_comp, 6,                          /* IS10184 */
               "PTRs: common = %8X   adminlist = %8X",    /* IS10184 */
               common_params, admins_list);               /* IS10184 */

  /*
   *   If Admins list does not exist, return NULLs.
   */
   if ( admins_list EQ NULL )
   {
     if (p_admin_ent NE NULL)
       *p_admin_ent = NULL;

     rc = ESA_NOT_SUPP;
     goto exit;
   }

  /*
   *   Admins list exist, look for the admin.
   */
   FIND_ADMIN(up_admin, up_admin_grp, admin_ent, diag_comp)
   ESA_DIAG_printf(diag_comp, 6,
                   "Find Amdin:  ent = %8X",
                   admin_ent);

   if (admin_ent EQ NULL)          /* Admin not found.       */
   {
     if (p_admin_ent NE NULL)
       *p_admin_ent = NULL;

     rc = ESA_EOF;
   }
   else                            /* Admin found...          */
   {
     /* WS10074 - start */
     /*
     ESA_DIAG_printf(diag_comp, 6,
            "Admin entry = %s / %s / %8X / %c / %s / %c",
             admin_ent->uid, admin_ent->group,
             admin_ent->acee, admin_ent->is_stc,
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);  */
     ESA_DIAG_printf(diag_comp, 6,
  /* BS10100 "Admin entry = %8X -> %d / %s / %s / %8X / %c / %s / %c",*/
          "Admin entry = %8X -> %d / %s / %s / %8X / %c / %c / %s / %c",
             admin_ent, admin_ent->seq_num,
             admin_ent->uid, admin_ent->group,
             admin_ent->acee, admin_ent->type,
             admin_ent->allowed,                           /* BS10100 */
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);
     /* WS10074 - end  */

   /* WS10074  if (admin_ent->is_stc EQ 'Y')   *stc?*   */
     if (admin_ent->type EQ ADMIN_TYPE_STC)   /* stc ?      WS10074 */
     {
       ESA_DIAG_printf(diag_comp, 6,
                       "Admin <%s> - STC entry",
                        admin_ent->uid);

       rc = ESA_SKIP;
     }
     else
       if ((int)admin_ent->acee EQ RSS_ADMINS_INACT_ENT) /*inactive?*/
       {
         ESA_DIAG_printf(diag_comp, 6,
                         "Admin <%s> - Entry inactive",
                          admin_ent->uid);

         rc = ESA_WARN;
       }
       else                         /* active...                   */
       {
         /*   Verify acee, if needed    */
         /* BS10100 - start */
         /*
         if ( (acee EQ NULL  OR   @* no acee to verify       OR      *@
              (acee NE NULL  AND  @* acee provided = acee in entry   *@
               admin_ent->acee  EQ  acee) )  AND  /*    AND     *@
              (curr_acee EQ NULL  OR  @* no current acee     OR      *@
              (curr_acee NE NULL  AND  @* current acee = acee in entry*@
               admin_ent->acee  EQ  curr_acee) ) )
         */
         if ( acee4ver EQ NULL OR  /* no acee to verify      OR      */
              (acee4ver NE NULL AND /* acee provided or found =      */
               admin_ent->acee  EQ  acee4ver) ) /*   scee in entry   */
         /* BS10100 - end   */
           rc = ESA_OK;             /* ...all is OK                   */
         else
           rc = ESA_ERR;            /* else, error.                   */
       }

     if (p_admin_ent NE NULL)     /* If requested...   .            */
       *p_admin_ent = admin_ent;  /* ... return admin entry.        */
   }

  exit :;

   ESA_DIAG_printf(diag_comp, 6,
            "return:  rc = %s", ESA_rc2str(rc) );

   ESA_DIAG_exit (diag_comp, 1, func, rc );

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : TermAdmin                                  *
 *                                                             *
 * DESCRIPTION    : Terminate an administrator environment     *
 *                  and deactivate its entry in the            *
 *                  administrators list.                       *
 *                                                             *
 * INPUT          : admin_ent    - Admin entry to terminate.   *
 *                : diag_comp                                  *
 *                : Admin_params                               *
 *                                                             *
 * OUTPUT         : none                                       *
 *                                                             *
 * RETURN VALUE   : ESA_OK - terminated successfully.          *
 *                : ESA_FATAL - error.                         *
 *                                                             *
 **************************************************************/

 static ESA_RC TermAdmin (RSS_ADMINS_LIST_ENTRY_rec_typ  * admin_ent,
                          ESA_DIAG_COMP_typ                diag_comp,
                          ADMIN_PARAMS_rec_typ           * admin_params)
 {

  /*
   *  Deactivate an admin entry
   *  ent -> admin entry.
   *
   *  BS10100:  We do not change the "allowed" field as long
   *            as the Allowed Admins file cannot be refreshed
   *            dynamically. So, when an entry is re-activated
   *            we will alreay know if the admin is allowed or not.
   */
 #define DEACT_ADMIN_ENTRY(ent)                                   \
                                                                  \
     (ent)->acee = (void *)RSS_ADMINS_INACT_ENT;                  \
     (ent)->type = ADMIN_TYPE_NONE;                               \
     (ent)->allowed = ALLOWED_ADMIN_NONE;          /* BS10100 */  \
     (ent)->EXECOUT_ddname[0] = NULL_CHAR;                        \
     (ent)->EXECOUT_dynamic = ' ';

   static char      func[] = "TermAdmin";

   ESA_RC               rc = ESA_OK;
   ESA_RC               saved_rc = ESA_OK;
   RACF_UID_rec_typ   * handle = NULL;

   char                 curr_jobname[9] = "";
   char                 curr_jobid[9] = "";
   USER_typ             curr_userid = "";
   char                 curr_sysid[5]  = "";
   void               * curr_acee = NULL;

   RACF_UID_rec_typ   * login_handle = NULL;
   void               * acee;              /* for logout switch */
   char                 errmsg[80] = "";

   /* IS10184 DUMMY_PARAMS_rec_typ   * params_ptr = NULL; * WS10074 * */
   COMMON_PARAMS_rec_typ    * common_params = NULL;      /* WS10074 */
   RSS_ADMINS_LIST_rec_typ  * admins_list = NULL;        /* WS10074 */

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;

  /*
   *   Initialization
   */
   ESA_DIAG_enter (diag_comp, 1 , func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(diag_comp, 6,
               "Input:  admin_ent = %8X", admin_ent);

  /*
   *   Validate entry
   */
   if (admin_ent EQ NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func,
               "Admin entry address is missing",
                16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
   }

   /* WS10074 - start */
   /*
   ESA_DIAG_printf(diag_comp, 6,
          "Admin entry = %s / %s / %8X / %c / %s / %c",
           admin_ent->uid, admin_ent->group,
           admin_ent->acee, admin_ent->is_stc,
           admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic); */
   ESA_DIAG_printf(diag_comp, 6,
 /* BS10100 "Admin entry = %8X -> %d / %s / %s / %8X / %c / %s / %c",*/
          "Admin entry = %8X -> %d / %s / %s / %8X / %c / %c / %s / %c",
           admin_ent, admin_ent->seq_num,
           admin_ent->uid, admin_ent->group,
           admin_ent->acee, admin_ent->type,
           admin_ent->allowed,                             /* BS10100 */
           admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);
   /* WS10074 - end  */

   /* WS10074 if (admin_ent->is_stc EQ 'Y')    * stc userid  ? * */
   if (admin_ent->type EQ ADMIN_TYPE_STC) /* stc userid  ?  WS10074 */
   {
     ESA_DIAG_printf(diag_comp, 6,
            "TermAdmin cannot be done for <%s> - stc userid",
             admin_ent->uid);
     rc = ESA_OK;               /* Nothing to do     */
     goto exit;
   }

   if ((int)admin_ent->acee EQ RSS_ADMINS_INACT_ENT) /* inactive ? */
   {
     ESA_DIAG_printf(diag_comp, 6,
            "TermAdmin cannot be done for <%s> - already inactive",
             admin_ent->uid);
     rc = ESA_OK;      /*  nothing to do  */
     goto exit;
   }

  /*
   *   Make sure we are not deactivating the current userid
   */
   OS_MVS_whoami( curr_jobname, curr_jobid, curr_userid,
                  curr_sysid, &curr_acee );
   ESA_DIAG_printf(diag_comp, 6,
        "WhoAmI: %s / %s / %s / %s / %8X",
        curr_jobname, curr_jobid, curr_userid,
        curr_sysid, curr_acee);

   if (admin_ent->acee EQ curr_acee)
   {
     sprintf(errmsg,
            "TermAdmin cannot be done for <%s> - active userid",
             admin_ent->uid);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func, errmsg,
                16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
   }

   /* WS10074 - start */
  /*
   *  If end-user entry - locate the admins list address.
   *  We will use it to reset the number of used entries, or the next
   *  EXECOUT number, if possible.
   */
   if (admin_ent->type EQ ADMIN_TYPE_USER)
   {
     /* IS10184
     GET_ADMINSLIST_ADDR(params_ptr, common_params, admins_list)
     ESA_DIAG_printf(diag_comp, 6,
           "PTRs:  params = %8X   common = %8X   adminlist = %8X",
            params_ptr, common_params, admins_list);              */
     GET_ADMINSLIST_ADDR(common_params, admins_list)      /* IS10184 */
     ESA_DIAG_printf(diag_comp, 6,                        /* IS10184 */
           "PTRs:   common = %8X   adminlist = %8X",      /* IS10184 */
            common_params, admins_list);                  /* IS10184 */

     if (admins_list EQ NULL)
     {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     component, func,
                     "Admins List address not found",
                     16, __LINE__);
       rc = ESA_FATAL;
       goto exit;
     }
   }
   /* WS10074 - end  */

  /*
   *   Create a login handle for SwitchACEE and ReleaseACEE
   *   and put the acee in it.
   */
   rc = GetLoginHandle((void **)&login_handle, &login_handle,
                       admin_ent->uid, admin_ent->group,
                       dest, msgs);
   if ( rc EQ ESA_OK )
     login_handle->acee = admin_ent->acee;
   else
   {
     rc = ESA_FATAL;
     goto exit;
   }


  /****************************************************************
   *  Deallocate the EXECOUT, if not static
   *  - do SwitchAcee
   *  - Deallocate the execout.
   *  - do SwitchAcee
   *
   ****************************************************************/

   if (admin_ent->EXECOUT_dynamic EQ 'Y')
   {
     rc = SwitchACEE(login_handle, &login_handle->acee,
                     &login_handle->acee_prev,
                     LOGIN_SWITCH_MODE,
                     diag_comp, dest,msgs);
     if ( rc EQ ESA_OK )
     {
       /* WS10074
       rc = Admin_EXECOUTDD_Handling ("FREE", NULL, admin_ent->uid, */
       rc = Admin_EXECOUTDD_Handling ("FREE", admins_list, /* WS10074 */
                                      admin_ent->uid,      /* WS10074 */
                                      admin_ent->EXECOUT_ddname,
                                      &admin_ent->EXECOUT_dynamic,
                                      diag_comp,
                                      admin_params);
       saved_rc = rc;
       rc = SwitchACEE(login_handle, &login_handle->acee_prev,
                       &acee, LOGOUT_SWITCH_MODE,
                       diag_comp,dest,msgs);

     }
     else
       saved_rc = ESA_FATAL;

     if (rc NE ESA_OK    OR    saved_rc NE ESA_OK)
       saved_rc = ESA_FATAL;
   }

   /*
    *  Release ACEE and free login handle
    */

   rc = ReleaseACEE(login_handle, diag_comp, dest, msgs);

   free(login_handle);

   if ( rc EQ ESA_OK )
   {
     /* WS10074 - start */
       /*
        *  If this entry is for end-user, and is the last used,
        *  init the entry and decrease the use count.
        */
     if (admin_ent->type EQ ADMIN_TYPE_USER  AND
         admin_ent->seq_num EQ admins_list->used_entries)
     {
       INIT_ADMIN_ENTRY(admin_ent);
       admins_list->used_entries--;
     }
     else
       DEACT_ADMIN_ENTRY(admin_ent)

     /*
     ESA_DIAG_printf(diag_comp, 6,
            "Admin entry = %s / %s / %8X / %8X / %s / %c",
             admin_ent->uid, admin_ent->group,  admin_ent->acee,
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);*/
     ESA_DIAG_printf(diag_comp, 6,
 /* BS10100 "Admin entry = %8X -> %d / %s / %s / %8X / %c / %s / %c", */
        "Admin entry = %8X -> %d / %s / %s / %8X / %c / %c / %s / %c",
             admin_ent, admin_ent->seq_num,
             admin_ent->uid, admin_ent->group,
             admin_ent->acee, admin_ent->type,
             admin_ent->allowed,                           /* BS10100 */
             admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);

     if (admins_list NE NULL)
       ESA_DIAG_printf(diag_comp, 6,
                      "Admins list = %d / %d / %s / %s / %d",
                      admins_list->max_entries,
                      admins_list->used_entries,
                      admins_list->static_EXECOUT,
                      admins_list->prefix_EXECOUT,
                      admins_list->Next_EXECOUT_num);
     /* WS10074 - end  */

     rc = ESA_OK;
     goto exit;
   }
   else
   {
     rc = ESA_FATAL;
     goto exit;
   }


  exit :;

   rc = saved_rc;

   ESA_DIAG_exit (diag_comp, 1, func, rc );

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : CTSCRSS_Admin_GetEXECOUTDD                 *
 *                                                             *
 * DESCRIPTION    : Get the ddname for the EXECOUT file for    *
 *                  the requested administrator.               *
 *                                                             *
 * INPUT          : Admin                                      *
 *                : component name for diags.                  *
 *                : Admin params                               *
 *                                                             *
 * OUTPUT         : ddname - for rc ESA_OK and ESA_SKIP        *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                  ESA_OK - EXECOUT for admin is returned,    *
 *                  ESA_SKIP - no admins list - static         *
 *                             EXECOUT ddname is returned.     *
 *                  ESA_FATAL - Message is issued.             *
 *                                                             *
 *                                                             *
 **************************************************************/

 ESA_RC CTSCRSS_Admin_GetEXECOUTDD (USER_typ               admin,
                                    char                 * ddname,
                                    ESA_DIAG_COMP_typ      diag_comp,
                                    ADMIN_PARAMS_rec_typ * admin_params)
 {

   static  char       func[] = "CTSCRSS_Admin_GetEXECOUTDD";

   static  char       stat_execout_ok = ' ';    /* Y / N */

   ESA_RC                     rc = ESA_OK;
   char                       errmsg[80] = "";
   int                        i;
   RSS_ADMINS_LIST_rec_typ  * admins_list = NULL;

   /* IS10184 DUMMY_PARAMS_rec_typ     * params_ptr = NULL;   */
   COMMON_PARAMS_rec_typ    * common_params = NULL;

   char       curr_jobname[9] = "";
   char       curr_jobid[9]   = "";
   char       curr_userid[9]  = "";
   char       curr_sysid[5]  = "";
   void     * curr_acee = NULL;
   char       curr_group[9]  = "";
   USER_typ   up_admin = "";
   UG_typ     up_admin_grp = "";

   char       eo_ddn[9] = "";
   char       eo_is_dyn = ' ';

   RSS_ADMINS_LIST_ENTRY_rec_typ  * admin_ent;

   CTSAMSG_HANDLE_rec_ptr     msgs;
   CTSAMSG_DEST_TABLE_rec_ptr dest;

  /*
   *   Initialization
   */
   ESA_DIAG_enter ( diag_comp, 1 , func);

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_printf(diag_comp, 6,
                 "Admin = %s", admin);

  /*
   *  Locate admins list.
   */
   if (admin_params NE NULL)
   {
     /* IS10184
     GET_ADMINSLIST_ADDR(params_ptr, common_params, admins_list)
     ESA_DIAG_printf(diag_comp, 6,
           "PTRs:  params = %8X   common = %8X   adminlist = %8X",
           params_ptr, common_params, admins_list);              */
     GET_ADMINSLIST_ADDR(common_params, admins_list)      /* IS10184 */
     ESA_DIAG_printf(diag_comp, 6,                        /* IS10184 */
           "PTRs:  common = %8X   adminlist = %8X",       /* IS10184 */
            common_params, admins_list);                  /* IS10184 */
   }

   if (admins_list EQ NULL)  /* No admins list - return static name  */
   {
     if (stat_execout_ok EQ ' ')
     {
       /*  Verify EXECOUT exists   */
       rc = OS_MVS_ddinfo(EXECOUT_DDNAME_STATIC,
                NULL, FALSE, dest, msgs, 0);
       ESA_DIAG_printf(diag_comp, 6,
           "OS_MVS_ddinfo for <%s>: rc = %s",
           EXECOUT_DDNAME_STATIC, ESA_rc2str(rc));

       if (rc EQ ESA_OK)
         stat_execout_ok = 'Y';
       else
         stat_execout_ok = 'N';
     }

     if (stat_execout_ok EQ 'Y')
     {
       strcpy(ddname, EXECOUT_DDNAME_STATIC);
       rc = ESA_SKIP;
       goto exit;
     }
     else
     {
       sprintf(errmsg, "DD %s does not exist", EXECOUT_DDNAME_STATIC );
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                     component, func, errmsg,
                     16, __LINE__);
       rc = ESA_FATAL;
       goto exit;
     }
   }

   ESA_DIAG_printf(diag_comp, 6,
                  "Admins list = %d / %d / %s / %s / %d",
                  admins_list->max_entries,
                  admins_list->used_entries,
                  admins_list->static_EXECOUT,
                  admins_list->prefix_EXECOUT,
                  admins_list->Next_EXECOUT_num);

  /*
   *  Validate ddname in header.
   *  If no ddname - error.
   */
   if (admins_list->static_EXECOUT[0] EQ NULL_CHAR)
   {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func,
               "EXECOUT DD statement is missing",
                16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
   }

  /*
   *  Take admin name
   *   If admin was not provided, get current userid
   */
   if (admin NE NULL    AND
       admin[0] NE NULL_CHAR)
   {
     TO_UPPER(admin, up_admin)
   }
   else
   {
     OS_MVS_whoami( curr_jobname, curr_jobid, curr_userid,
                    curr_sysid, &curr_acee );
     ESA_DIAG_printf(diag_comp, 6,
          "WhoAmI: %s / %s / %s / %s / %8X",
          curr_jobname, curr_jobid, curr_userid,
          curr_sysid, curr_acee);

     TO_UPPER(curr_userid, up_admin)
   }

  /*
   *  Find Admin entry.
   */
   FIND_ADMIN(up_admin, up_admin_grp, admin_ent, diag_comp)
   ESA_DIAG_printf(diag_comp, 6,
                   "Find Amdin:  ent = %8X",
                   admin_ent);

   if (admin_ent EQ NULL)          /* Admin not found.       */
   {
     sprintf(errmsg,
            "<%s>/<%s> was not found in administrators list",
            up_admin, up_admin_grp);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func, errmsg,
                16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
   }

   /* WS10074 - start */
   /*
   ESA_DIAG_printf(diag_comp, 6,
          "Admin entry = %s / %s / %8X / %c / %s / %c",
           admin_ent->uid, admin_ent->group,
           admin_ent->acee, admin_ent->is_stc,
           admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic); */
   ESA_DIAG_printf(diag_comp, 6,
/* BS10100 "Admin entry = %8X -> %d / %s / %s / %8X / %c / %s / %c", */
        "Admin entry = %8X -> %d / %s / %s / %8X / %c / %c / %s / %c",
           admin_ent, admin_ent->seq_num,
           admin_ent->uid, admin_ent->group,
           admin_ent->acee, admin_ent->type,
           admin_ent->allowed,                           /* BS10100 */
           admin_ent->EXECOUT_ddname, admin_ent->EXECOUT_dynamic);
   /* WS10074 - end  */

  /*
   *  Verify the entry is active
   */
   if ((int)admin_ent->acee EQ RSS_ADMINS_INACT_ENT) /*inactive?*/
   {
     sprintf(errmsg,
            "<%s> is inactive", admin_ent->uid);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
               component, func, errmsg,
                16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
   }

  /*
   *   The admin is active
   *   If ddname does not exist, go get one.
   */
   if (admin_ent->EXECOUT_ddname[0] EQ NULL_CHAR)
   {
     rc = Admin_EXECOUTDD_Handling ("ALLOC", admins_list,
                                    admin_ent->uid,  eo_ddn,
                                    &eo_is_dyn, diag_comp,
                                    admin_params);
     ESA_DIAG_printf(diag_comp, 6,
           "Admin_EXECOUTDD_Handling - ALLOC: rc = %s  ddn = %s / %c",
            ESA_rc2str(rc), eo_ddn, eo_is_dyn);
     if (rc NE ESA_OK)
     {
       rc = ESA_FATAL;
       goto exit;
     }

     strcpy(admin_ent->EXECOUT_ddname, eo_ddn);
     admin_ent->EXECOUT_dynamic = eo_is_dyn;
   }

  /*
   *   Return the ddname to the caller.
   */
   strcpy(ddname, admin_ent->EXECOUT_ddname);
   rc = ESA_OK;

  /*
   *   Return
   */
  exit :;

   ESA_DIAG_printf(diag_comp, 6,
                  "return:  rc = %s  ddn = %s",
                   ESA_rc2str(rc), ddname);
   ESA_DIAG_exit (diag_comp, 1, func, rc );

   return rc;

 }

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : Admin_EXECOUTDD_Handling                   *
 *                                                             *
 * DESCRIPTION    : Handle the EXECOUT DD for each admin -     *
 *                : decide on ddname, and allocte and free     *
 *                  when needed.                               *
 *                                                             *
 * INPUT          : Funciton     -  ALLOC / FREE               *
 *                : Admin_list   - for ALLOC - mandartory.     *
 *                : ddname       - ddname                      *
 *                :                ALLOC - see OUTPUT          *
 *                :                FREE - EXECOUT ddname.      *
 *                : is_dyn -     - static/dynamic indication.  *
 *                :                ALLOC - see OUTPUT          *
 *                :                FREE - Y / N                *
 *                : diag_comp    - for diags..                 *
 *                : Admin params                               *
 *                                                             *
 * OUTPUT         : ddname - returned for ALLOC, when          *
 *                           rc is ESA_OK                      *
 *                : is_dyn - Y (dynamic) / N (static)          *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                  ESA_OK - EXECOUT for admin is returned,    *
 *                  ESA_SKIP - no admins list - sttaic         *
 *                             EXECOUT ddname is returned.     *
 *                  ESA_FATAL - Message is issued.             *
 *                                                             *
 *                                                             *
 **************************************************************/

 static ESA_RC Admin_EXECOUTDD_Handling (char            * function,
                                 RSS_ADMINS_LIST_rec_typ * admins_list,
                                 USER_typ                  admin,
                                 char                    * ddname,
                                 char                    * is_dyn,
                                 ESA_DIAG_COMP_typ         diag_comp,
                                 ADMIN_PARAMS_rec_typ    * admin_params)
 {

  static  char       func[] = "Admin_EXECOUTDD_Handling";

  ESA_RC             rc = ESA_OK;
  char               errmsg[80] = "";
  int                i;
  char               dsn[10] = "";
  char               ddn[9] = "";
  __dyn_t            dynalc;
  int                dyn_rc;

  CTSAMSG_HANDLE_rec_ptr     msgs;
  CTSAMSG_DEST_TABLE_rec_ptr dest;

 /*
  *   Initialization
  */
  ESA_DIAG_enter ( diag_comp, 1 , func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_printf(diag_comp, 6,
                  "Function = %s", function);

 /*
  *   DD is required.
  */
  if ( strcmp(function, "ALLOC") EQ 0 )
  {
    ddname[0] = NULL_CHAR;
    *is_dyn = ' ';

    ESA_DIAG_printf(diag_comp, 6,
           "admins_list header: ddnames = %s /%s  next# = %d  vio = %c",
           admins_list->static_EXECOUT, admins_list->prefix_EXECOUT,
          admins_list->Next_EXECOUT_num, admins_list->execout_vio);
    ESA_DIAG_printf(diag_comp, 6,
            "admins_list header: DCB = %d / %d / %c",
            admins_list->execout_lrecl, admins_list->execout_blksize,
            admins_list->execout_recfm);
    ESA_DIAG_printf(diag_comp, 6,
            "admins_list header: space = %s / %d / %d / %d",
            admins_list->execout_tspace, admins_list->execout_pspace,
            admins_list->execout_sspace, admins_list->execout_avgblk);
   /*
    *  Validate ddname in header.
    *  If no ddname - error.
    */
    if (admins_list->static_EXECOUT[0] EQ NULL_CHAR)
    {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                component, func,
                "EXECOUT DD statement is missing",
                 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }

   /*
    *  If static DD is VIO, use it.
    */
    if (admins_list->execout_vio EQ 'Y')
    {
      strcpy(ddname, admins_list->static_EXECOUT);
      *is_dyn = 'N';
      rc = ESA_OK;
      ESA_DIAG_printf(diag_comp, 6,
            "Static DD is VIO, use it - ddname = %d", ddname);
      goto exit;
    }


   /*
    *   Static DD is not VIO, we need to allocate a DD for
    *   this admin.
    */


    /*   If number of DDs exceeded - error. */
    if (admins_list->Next_EXECOUT_num GT 999)
    {
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                component, func,
                "Dynamic EXECOUT number exceeds 999",
                 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }

    /*   Allocate a new DD for execout      */
    strcpy(ddn, admins_list->prefix_EXECOUT);  /* Take prefix        */
    sprintf(&ddn[strlen(ddn)], "%.*d",         /* Add the number     */
             sizeof(ddn)-strlen(ddn)-1,
             admins_list->Next_EXECOUT_num);
    ddn[sizeof(ddn)-1] = NULL_CHAR;            /* Set termionator.   */
    ESA_DIAG_printf(diag_comp, 6,
            "New ddname = %s", ddn);

    strcpy(dsn, "&");
    strcat(dsn, admin);

    dyninit(&dynalc);

    dynalc.__ddname = ddn;
    dynalc.__dsname = dsn;
    dynalc.__status = __DISP_NEW;
    dynalc.__normdisp = __DISP_DELETE;

    dynalc.__unit = "SYSALLDA";

    switch (admins_list->execout_tspace)
    {
      case 'T':
        dynalc.__alcunit = __TRK;
        break;
      case 'C':
        dynalc.__alcunit = __CYL;
        break;
      case 'B':
        dynalc.__avgblk = admins_list->execout_avgblk;
        break;
      default:
        goto exit;
    }

    dynalc.__primary = admins_list->execout_pspace;
    dynalc.__secondary = admins_list->execout_sspace;

    dynalc.__lrecl= (unsigned short)admins_list->execout_lrecl;
    dynalc.__blksize = admins_list->execout_blksize;

    switch (admins_list->execout_recfm[0])
    {
      case 'F':
        dynalc.__recfm = _F_;
        break;
      case 'V':
        dynalc.__recfm = _V_;
        break;
      default:
        dynalc.__recfm = _U_;
        break;
    }

    for (i = 1;
         ( admins_list->execout_recfm[i] NE ' '      AND
           i LT strlen(admins_list->execout_recfm) );
         i++)
    {
      switch (admins_list->execout_recfm[i])
      {
        case 'B':
            dynalc.__recfm += _B_;
            break;
        case 'S':
            dynalc.__recfm += _S_;
            break;
        case 'A':
            dynalc.__recfm += _A_;
            break;
        case 'M':
            dynalc.__recfm += _M_;
            break;
        default:
          break;
      }
    }

   /*
    *   Dynalloc the file.
    */
    dyn_rc = dynalloc(&dynalc);
    ESA_DIAG_printf(diag_comp, 6,
            "dynalloc for <%s>: rc = %d   err/info = %d / %d",
            ddn, dyn_rc, dynalc.__errcode, dynalc.__infocode);

    if (dyn_rc EQ 0)
    {
      admins_list->Next_EXECOUT_num++;
      strcpy(ddname, ddn);
      *is_dyn = 'Y';
      rc = ESA_OK;

      ESA_DIAG_printf(diag_comp, 6,
                    "DD <%s> was successfully allocated", ddname);
      goto exit;
    }
    else
    {
      sprintf(errmsg,
          "Dynalloc for %s failed with error code %d, info code %d",
          ddn, dynalc.__errcode, dynalc.__infocode);

      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                component, func, errmsg,
                 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }
  }
  else
    if ( strcmp(function, "FREE") EQ 0 )
    {
       ESA_DIAG_printf(diag_comp, 6,
                       "ddname = %s   is_dyn = %c",
                       ddname, *is_dyn);

      if (ddname[0] EQ NULL_CHAR)
      {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                  component, func,
                  "Parameter ddname is missing",
                   16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }

     /*
      *  If is_dyn is Y, deallocate the file.
      */
      if (*is_dyn EQ 'Y')      /* dynamic - dealloate */
      {
        /*
         *   Dealloc the file.
         */
        dyninit(&dynalc);
        dynalc.__ddname = ddname;

        dyn_rc = dynfree(&dynalc);
        ESA_DIAG_printf(diag_comp, 6,
                "Dealloc for <%s>: rc = %d   err/info = %d / %d",
                 ddname, dyn_rc, dynalc.__errcode, dynalc.__infocode);
        if (dyn_rc EQ 0)
        {
          rc = ESA_OK;
          ESA_DIAG_printf(diag_comp, 6,
                    "DD <%s> was successfully deallocated", ddname);

          /* WS10074 - start */
          /*
           *  If this is the last allocated EXECOUT, reset the
           *  "next" number to reuse the ddname.
           */
          if (admins_list NE NULL)
          {
            ESA_DIAG_printf(diag_comp, 6,
                   "Check if ddname %s can be reused.  Next = %d",
                   ddname, admins_list->Next_EXECOUT_num);
            if (atoi(ddname+strlen(admins_list->prefix_EXECOUT)) EQ
                (admins_list->Next_EXECOUT_num-1))
            {
              ESA_DIAG_printf(diag_comp, 6,
                  "Ddname %s will be reused", ddname);
              admins_list->Next_EXECOUT_num--;
            }
          }
          /* WS10074 - end  */
          goto exit;
        }
        else
        {
          sprintf(errmsg,
              "Dealloc for %s failed with error code %d, info code %d",
              ddn, dynalc.__errcode, dynalc.__infocode);

          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func, errmsg,
                     16, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }
      }
      else
        if (*is_dyn EQ 'N')     /* static - nothing to do */
        {
          rc = ESA_OK;
          goto exit;
        }
        else                    /* unknown - error */
        {
          sprintf(errmsg,
                 "Parameter is_dyn is incorrect (%c)", is_dyn);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func, errmsg,
                     16, __LINE__);
          rc = ESA_FATAL;
          goto exit;
        }
    }
    else
    {
      sprintf(errmsg, "Incorrect function <s>", function);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                component, func, errmsg,
                 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }

  exit :;

   ESA_DIAG_exit (diag_comp, 1, func, rc );

   return rc;

 }

/****************************************************
 * Procedure Name: Common_params_Handle
 *
 * Description   : Init / term the common_params area.
 *
 * parameters    : operation - INIT/TERM
 *               : owner_id  - COMMON_PARAMS_OWNER_xxx
 *               : p_common_params -
 *                 - INIT - area in which commonm params
 *                          address will be returned.
 *                 - TERM - pointer to common params
 *                          address to be terminated.
 *                          Will be changed to 0.
 *
 * Return Value  : ESA_OK
 *               : ESA_NOT_SUPP - TERM - not yours         * IS10184 *
 *               : ESA_FATAL
 *
 * Side Effects  :
 *
 ****************************************************/
ESA_RC  Common_params_Handle (char                   *  operation,
        /* IS10184 */         char                      owner_id,
                              COMMON_PARAMS_rec_typ **  p_common_params,
                              ADMIN_PARAMS_rec_typ   *  admin_params)
{

  static char func[] = "Common_params_Handle";

  ESA_RC                  rc = ESA_OK;
  char                    err_msg[81] = "";
  COMMON_PARAMS_rec_typ * common_ptr = NULL;
  char                    allow_prot = NULL_CHAR;          /* BS10100 */
  char                    appl_name[9]="";                 /* BS10100 */
  char                    appl_OK = NULL_CHAR;             /* BS10100 */
  int                     int_rc = 0;                      /* BS10111 */
  SCRIPT_NAME_typ         script_dd_dsn = "";              /* IS10184 */
  SCRIPT_NAME_typ         script_dir_parm = "";            /* IS10184 */
  int                     no_dd = FALSE;                   /* IS10184 */
  int                     i = 0;                           /* IS10184 */
  COMMON_PROGS_LIST_rec_typ * progs_ptr = NULL;            /* IS10184 */
  COMMON_PROGS_ENT_rec_typ  * p_prog_entry = NULL;         /* IS10184 */
  RSS_ADMINS_LIST_rec_typ   * admins_list = NULL;          /* IS10184 */

  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

 /*
  *   Initialization
  */
  ESA_DIAG_enter(ESA_COMP_APIINIT, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /* IS10184 - start  */
  /* ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
                  "Operation = %s    p_common_params = %8X -> %8X",
                  operation, p_common_params,
                  (p_common_params NE NULL ? *p_common_params : NULL) );
  */
  ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
          "Prms: op = %s    blk_ptr = %8X -> %8X  owner = %c / %c",
           operation, p_common_params,
           (p_common_params NE NULL ? *p_common_params : NULL),
           owner_id,
           (p_common_params NE NULL AND *p_common_params NE NULL ?
                (*p_common_params)->commp_owner : ' ') );
  /* IS10184 - end    */

  if (p_common_params NE NULL)
  {
    if ( strcmp(operation, "INIT") EQ 0 )
    {
     /*
      *   INIT - Allocate and initialize
      */
      /* BS10111 - replace malloc with calloc which initializes the
         area with x'00'.
      common_ptr = malloc(sizeof(COMMON_PARAMS_rec_typ));  */
      common_ptr = calloc(1,                              /* BS10111 */
                          sizeof(COMMON_PARAMS_rec_typ)); /* BS10111 */
      if (common_ptr EQ NULL)
      {
        sprintf(err_msg,"COMMON_PARAMS in comp=%s fn=%s",
                component, func);
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     err_msg, sizeof(COMMON_PARAMS_rec_typ));
        rc = ESA_FATAL;
        goto exit;
      }
      else   /* common params allocated - init and return */
      {
        ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
                        "COMMON_PARAMS allocated: area = %8X (%d)",
                        common_ptr, sizeof(COMMON_PARAMS_rec_typ));

        strcpy(common_ptr->commp_eyec, COMMON_PARAMS_EYEC);
        common_ptr->commp_owner = owner_id;               /* IS10184 */

       /*
        *    INIT - Set verify_password_by_login indication
        *           according to RSSPARM parameter value and
        *           caller type.
        */
        /* BS10100 - start */
        /* The code below is moved to a macro

        common_ptr->rssparm_VERIFY_PASS_LOGIN[0] = NULL_CHAR;
        rc = admin_params->cs_func.rssprm_get_opt_ptr(
                      admin_params->rss_name,
                      VERIFY_PASSWORD_BY_LOGIN,
                      sizeof(common_ptr->rssparm_VERIFY_PASS_LOGIN),
                      common_ptr->rssparm_VERIFY_PASS_LOGIN,
                      OPT_TRUE,
                      OPT_TRUE) ;
        ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
               "VERIFY_PASSWORD_BY_LOGIN = <%s>  rc = <%d> ",
                common_ptr->rssparm_VERIFY_PASS_LOGIN, rc);

         * If not specified or incorrect set default according to *
         * RSS type:                                              *
         * - RACF - N                                             *
         * - other (ACF2, TSS) - Y                                *

        if ((rc NE ESA_OK) OR
          (rc EQ ESA_OK  AND
           common_ptr->rssparm_VERIFY_PASS_LOGIN[0] NE 'N' AND
           common_ptr->rssparm_VERIFY_PASS_LOGIN[0] NE 'Y'))
        {
          if (strncmp (admin_params->rss_type, "RACF", 4) EQ 0 )
            common_ptr->rssparm_VERIFY_PASS_LOGIN[0] = 'N';
          else
            common_ptr->rssparm_VERIFY_PASS_LOGIN[0] = 'Y';

          common_ptr->rssparm_VERIFY_PASS_LOGIN[1] = NULL_CHAR;

          ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
               "Default VERIFY_PASSWORD_BY_LOGIN for %s = <%s>",
               admin_params->rss_type,
               common_ptr->rssparm_VERIFY_PASS_LOGIN);
          rc = ESA_OK;  *parm is not mandatory, set rc=0 *

        }
        */
        GETVERBYLOGIN(common_ptr->rssparm_VERIFY_PASS_LOGIN,
                      rc)
        /* BS10100 - end  */

        /* * * * * * * WS10073 start * * * * * * */
        common_ptr->rssparm_UPDATE_LOGON_STATS[0] = NULL_CHAR;
        rc = admin_params->cs_func.rssprm_get_opt_ptr(
                      admin_params->rss_name,
                      UPDATE_LOGON_STATS,
                      sizeof(common_ptr->rssparm_UPDATE_LOGON_STATS),
                      common_ptr->rssparm_UPDATE_LOGON_STATS,
                      OPT_TRUE,
                      OPT_TRUE) ;
        ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
               "UPDATE_LOGON_STATS = <%s>  rc = <%d> ",
                common_ptr->rssparm_UPDATE_LOGON_STATS, rc);

        /* If not specified or incorrect, set default to N */

        if ((rc NE ESA_OK) OR
          (rc EQ ESA_OK  AND
           common_ptr->rssparm_UPDATE_LOGON_STATS[0] NE 'N' AND
           common_ptr->rssparm_UPDATE_LOGON_STATS[0] NE 'Y'))
        {
          common_ptr->rssparm_UPDATE_LOGON_STATS[0] = 'N';

          common_ptr->rssparm_UPDATE_LOGON_STATS[1] = NULL_CHAR;

          ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
                          "Default UPDATE_LOGON_STATS = <%s>",
                          common_ptr->rssparm_UPDATE_LOGON_STATS);
          rc = ESA_OK; /*parm is not mandatory, set rc=0 */

        }
        /* * * * * * * WS10073 end * * * * * * */

        /* IS10184 - start */

       /********************************************************
        *                                                      *
        *  create amd Fill the programs list                   *
        *                                                      *
        ********************************************************/

        /*  Allocate the programs list */
        progs_ptr = malloc(sizeof(common_programs));
        if (progs_ptr EQ NULL)
        {
          sprintf(err_msg,"COMMON_PROGS_LIST in comp=%s fn=%s",
                  component, func);
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                       err_msg, sizeof(COMMON_PARAMS_rec_typ));
          rc = ESA_FATAL;
          goto exit;
        };

        /* Copy the static list into the program list  */
        memcpy(progs_ptr, &common_programs, sizeof(common_programs));
        p_prog_entry = &progs_ptr->program;

        /* Load the programs and set their addresses in the
           programs list                                        */
        for (i = 0;
               p_prog_entry[i].prog_name[0] NE '\0';
                 i++)
        {
          int_rc = (*(ASM_RTN_TYP *)&ctsaldm)(
                            p_prog_entry[i].prog_name,  "        ",
                            &(p_prog_entry[i].prog_ep));
          ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
                       "(%d) - Load %s   rc = %d    ep = %p",
                       i, p_prog_entry[i].prog_name,
                       int_rc, p_prog_entry[i].prog_ep);
          if (int_rc NE 0)
          {
            CTSAMSG_print(DYNAMIC_LOAD_FAILED, msgs,
                          NULL, dest,
                          p_prog_entry[i].prog_name);
            rc = ESA_FATAL;
            goto exit;
          };
        }

        /*  Set common_params to point to the programs list.  */
        common_ptr->p_common_programs = progs_ptr;
        /* IS10184 - end   */

        /* BS10100 - start */
        /* Initialize the Allowed Admins list and set the data   */
        /* in COMMON_PARAMS.                                     */
        rc = Init_Allowed_Admins(&allow_prot,
                                 appl_name,
                                 &appl_OK,
                                 ESA_COMP_APIINIT,
                                 admin_params);
        ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                 "Init_Allowed_Admins returned: rc = %s   %c / %s / %c",
                  ESA_rc2str(rc), allow_prot,
                  appl_name, appl_OK);
        if (rc NE ESA_OK)
        {
          rc = ESA_FATAL;
          goto exit;
        }
        /* IS10184 else
        {                                     /@ BS10111 @/          */
        if (appl_OK EQ 'Y')
        {
          common_ptr->rssparm_ALLOW_ADMIN_WITHOUT_PSWD[0] = allow_prot;
          common_ptr->rssparm_ALLOW_ADMIN_WITHOUT_PSWD[1] = NULL_CHAR;
          strcpy(common_ptr->rssparm_APPL_NAME, appl_name);
          common_ptr->is_APPL_OK = appl_OK;
       /* BS10100 - end   */

       /*  BS10111  - these 2 commands are moved down
       /@ Return common params address to caller.  @/
          *p_common_params = common_ptr;
          rc = ESA_OK;
          End of moved part   */
        }                                                /* BS10100 */
        else                                             /* BS10100 */
        {                                                /* BS10100 */
          /* BS10111 if(appl_name[0] NE NULL_CHAR         * BS10100 *
                            AND appl_OK EQ 'Y')   * BS10100  *    */
          if (appl_name[0] NE NULL_CHAR)                 /* BS10111 */
          {                                              /* BS10111 */
            rc = ESA_FATAL;                              /* BS10100 */
            goto exit;                                   /* BS10111 */
          };                                             /* BS10111 */
        }                                                /* BS10100 */
        /* IS10184 }                                   /@ BS10111 @/ */

        /* IS10184 - start                                          */
        /*           initialize the Admins_List. This code was      */
        /*           moved here from CTSxINI because the            */
        /*           common_params might now be created by CC so    */
        /*           we need to ensure that it is complete even     */
        /*           when CTSxINI was not (yet) called.             */
        rc = CTSCRSS_AdminsList_Handle ("INIT",
                         (RSS_ADMINS_LIST_rec_typ **)&admins_list,
                          ESA_COMP_APIINIT,
                          admin_params);

        ESA_DIAG_printf(
                        ESA_COMP_APIINIT, 3,
                        "AdminsLIst_Handle(INIT): rc = %d   area=%8X",
                        rc, admins_list);
        if (rc NE ESA_OK)
          goto exit;
        common_ptr->RSS_Admins_list = (void *)admins_list;
        /* End of admins list initialization - IS10184 */

        /* IS10184 - the code below is removed  because
           CTSARUH address was moved to the programs list
           and it will be loaded when the programs list
           is filled
        /@ Load CTSARUH.                                  BS10111 @/
        int_rc = (*(ASM_RTN_TYP *)&ctsaldm)               /@ BS10111 @/
                   ("CTSARUH ", "       ",                /@ BS10111 @/
                    &common_ptr->p_ctsaruh);              /@ BS10111 @/
        ESA_DIAG_printf(ESA_COMP_APIINIT, 6,              /@ BS10111 @/
                        "CTASRUH address = %.8X",         /@ BS10111 @/
                        common_ptr->p_ctsaruh);           /@ BS10111 @/
        if (int_rc NE 0)                                  /@ BS10111 @/
        {                                                 /@ BS10111 @/
          CTSAMSG_print(DYNAMIC_LOAD_FAILED, msgs,        /@ BS10111 @/
                        NULL, dest, "CTSARUH ");          /@ BS10111 @/
          rc = ESA_FATAL;                                 /@ BS10111 @/
          goto exit;                                      /@ BS10111 @/
        }                                                 /@ BS10111 @/
             end of removed code - IS10184 */

        /* BS10117 use CTSx as utoken where x runs from 1 to 255
        common_ptr->ruob_utkn = 0;   * init the ruob token. BS10111 * */
        common_ptr->ruob_utkn = 0xC3E3E200; /* Init the...    BS10117 */
                                            /* ... ruob token BS10117 */



       /********************************************************
        *                                                      *
        * Set script library name in common params.            *
        *                                                      *
        * Check the SCRIPT_DIR RSSPARM parameter and the       *
        * USRSCRPT DD statement in order to get the script     *
        * library name:                                        *
        *                                                      *
        * - if SCRIPT_DIR parameter exists, we will use its    *
        *   value as the scripts library name.  If USRSCRPT DD *
        *   statement exists and points to a different         *
        *   library, a warning messgae will be issued asking   *
        *   to change them to be equasl, or to remove the      *
        *   SCRIPT_DIR parameter from RSSPARM.                 *
        *                                                      *
        * - If SCRIPT_DIR parameter does not exist, we will    *
        *   take the lirary name from the USRSCRPT DD          *
        *   statement.                                         *
        *                                                      *
        * If SCRIPT_DIR does not exist and DD USRSCRPT does    *
        * not exist or it exists but we failed to retrieve its *
        * dtaaset name, we will set an error indication in the *
        * common_params with the code of the message to be     *
        * issued. when there will be a need to invoke a        *
        * script, the error message will be displayed.         *
        * We do it this way to prevent issueing error messages *
        * for scripts in address spaces that create the        *
        * common_params but do not invoke scripts and do not   *
        * not the USRSCRPT DD (like CTSC100, online, etc.).    *
        *                                                      *
        ********************************************************/

        /*    Get SCRIPT_DIR parameter */
        rc = admin_params->cs_func.rssprm_get_opt_ptr(
                       admin_params->rss_name,
                       SCRIPT_DIR,
                       sizeof(script_dir_parm),
                       script_dir_parm,
                       OPT_TRUE,
                       OPT_FALSE);
        ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
                 "SCRIPT_DIR parm value = %s", script_dir_parm);

        if (rc EQ ESA_OK)             /* SCRPIT_DIR parm exists */
          strcpy(common_ptr->script_libname,
                                         script_dir_parm); /* use it. */
        else
          common_ptr->script_libname[0] = NULL_CHAR;

        /*    Get the dsn from the DD  */
        rc = OS_MVS_ddinfo(SCRIPT_DIR_DDN, script_dd_dsn, 1,
                           dest, msgs, 0);

        ESA_DIAG_printf(ESA_COMP_APIINIT, 6,
               "OS_MVS_ddinfo call for %s:  rc = %d   dsn = %s",
               SCRIPT_DIR_DDN, rc, script_dd_dsn);

        if (rc EQ ESA_OK)   /* We have a valid DD */
        {
          /* If no parm, take the DD dsname */
          if (common_ptr->script_libname[0] EQ NULL_CHAR)
            strcpy(common_ptr->script_libname, script_dd_dsn);
          else
          {
            /* If SCRIPT_DIR exists, compare the names */
            if (strcmp(common_ptr->script_libname,
                                         script_dd_dsn) NE 0)
              CTSAMSG_print(MSG_SCRIPT_LIB_MISMATCH, msgs, NULL, dest,
                            SCRIPT_DIR_DDN, script_dd_dsn,
                            script_dir_parm);
          }
        }
        else     /* No DD - issue message if no SCRIPT_DIR */
        {
          if (common_ptr->script_libname[0] EQ NULL_CHAR)
          {
            common_ptr->script_lib_error = 0XFF;     /* mark error */
            if (rc EQ ESA_NOT_SUPP)  /* No dd */
              strcpy(common_ptr->script_lib_error_code,
                                                  ERR_NO_SCRIPT_LIB);
            else                     /* Failed to retrieve dsn */
              strcpy(common_ptr->script_lib_error_code,
                                                 ERR_FAIL_SCRIPT_DD);
          }
        }

      /* IS10184 - end */

     /* Return common params address to caller.  */
        *p_common_params = common_ptr;
        rc = ESA_OK;

      }
    }
    else
      if ( strcmp(operation, "TERM") EQ 0 )
      {
       /*
        *    TERM - deallocate the common params.
        */
        /* IS10184
        ESA_DIAG_printf(ESA_COMP_APITERM, 6,
                  "Operation = %s    commom_params = %8X",
                  operation, *p_common_params);             */

        if (*p_common_params NE NULL)
        {

          common_ptr = *p_common_params;                  /* BS10111 */

          /* IS10184 - start */
          ESA_DIAG_printf(ESA_COMP_APITERM, 6,
               "eyec = %.*s   owner_id = %c ",
               sizeof(common_ptr->commp_eyec), common_ptr->commp_eyec,
               common_ptr->commp_owner);

          /* Verify it is ours */
          if (strncmp(common_ptr->commp_eyec, COMMON_PARAMS_EYEC,
                                    strlen(COMMON_PARAMS_EYEC)) NE 0)
          {
             rc = ESA_FATAL;    /* not out eye-catcher - can't free */
             goto exit;
          };

          if (common_ptr->commp_owner NE owner_id)
          {
             rc = ESA_NOT_SUPP;  /* Not ours - can't free           */
             goto exit;
          };
          /* IS10184 - end */

          /* IS10184 - the code below is removed  because
             CTSARUH address was moved to the programs list
             and it will be deleted shen the programs list
             is deleted.
          /@   If CTSARUH was loaded, delete it.             BS10111 @/
          if (common_ptr->p_ctsaruh NE NULL)              /@ BS10111 @/
          {                                               /@ BS10111 @/
            int_rc = (*(ASM_RTN_TYP *)&ctsadlm)(          /@ BS10111 @/
                                           "CTSARUH ");   /@ BS10111 @/
            ESA_DIAG_printf(ESA_COMP_APITERM, 6,          /@ BS10111 @/
                            "Delete CTSARUH - rc = %d",   /@ BS10111 @/
                             rc);                         /@ BS10111 @/
            if (int_rc EQ 0)                              /@ BS10111 @/
              common_ptr->p_ctsaruh = NULL;               /@ BS10111 @/
            else                                          /@ BS10111 @/
               CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,   /@,BS10111 @/
                             dest, component, func,       /@ BS10111 @/
                            "Delete of CTSARUH failed",   /@ BS10111 @/
                            4, __LINE__);                 /@ BS10111 @/
          }                                               /@ BS10111 @/
             end of removed code - IS10184 */

          /* IS10184 - start */


          /* This was moved from CTSxTRM because it is now created  */
          /* when common_params is created and therefore should     */
          /* shold be freed when comon_params is freed.             */
          if (common_ptr->RSS_Admins_list NE NULL)
          {
            rc = CTSCRSS_AdminsList_Handle ("TERMF",
               (RSS_ADMINS_LIST_rec_typ **)&common_ptr->RSS_Admins_list,
                ESA_COMP_APITERM, admin_params);

            ESA_DIAG_printf(                            /*IS10182*/
                         ESA_COMP_APITERM, 3,
                         "AdminsLIst_Handle(TERMF): rc = %d", rc);
          };
          /*  End of code moved from CTSxTRM */

         /********************************************************
          *                                                      *
          *  Delete the programs loaded into the programs list   *
          *  and free the programs list.                         *
          *                                                      *
          ********************************************************/

          progs_ptr = common_ptr->p_common_programs;
          if (progs_ptr NE NULL)
          {
            p_prog_entry = &progs_ptr->program;
            for (i = 0;
                   p_prog_entry[i].prog_name[0] NE '\0';
                     i++)
            {
              if (p_prog_entry[i].prog_ep NE NULL)
              {
                int_rc = (*(ASM_RTN_TYP *)&ctsadlm)(
                                            p_prog_entry[i].prog_name);
                ESA_DIAG_printf(ESA_COMP_APITERM, 6,
                             "(%d) - Delete %s  rc = %d    ep = %p",
                              i, p_prog_entry[i].prog_name,
                              int_rc, p_prog_entry[i].prog_ep);
                if (int_rc NE 0)
                {
                  sprintf(err_msg, "Delete of %s failed",
                                   p_prog_entry[i].prog_name);
                  CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                                dest, component, func,
                                err_msg, 4, __LINE__);
                };
              };
            }

            free(progs_ptr);
            common_ptr->p_common_programs = NULL;
          };
          /* IS10184 - end  */

          free(*p_common_params);
          *p_common_params = NULL;
        }

        rc = ESA_OK;
      }
      else
      {
       /*
        *    Undefined operation requested.
        */
        sprintf(err_msg, "Operation '%s' incorrect", operation);

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                      err_msg , 16, __LINE__ );
        rc = ESA_FATAL;
      }
  }
  else    /* no common_params ptr - error   */
  {
    sprintf(err_msg, "%s - Missing parameter p_common_params",
            operation);

    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                  err_msg , 16, __LINE__ );
    rc = ESA_FATAL;
  }

 exit:;

  if (rc NE ESA_OK   AND
      rc NE ESA_NOT_SUPP   AND                            /* IS10184 */
      common_ptr NE NULL)
    free (common_ptr);

  ESA_DIAG_exit(ESA_COMP_APIINIT, 1, func, rc );

  /* BS10095 return; */
  return rc;                                              /* BS10095 */
}
 /* IS10174 - end   */

/* BS10100 -  start */
/****************************************************
 * Procedure Name: Init_Allowed_Admins
 *
 * Description   : Prepare the environment for handling
 *                 allowed admins:
 *                 1. Return the value of ALLOW_ADMIN_WITHOUT_PSWD
 *                    from RSSPARM.
 *                 2. Get the value of APPL_NAME from RSSPARM. and
 *                    verify it is defined in the security product.
 *
 * Parameters    : operation:
 *               : allow_prot (O) - 1 char Y/N
 *                   ALLOW_ADMIN_WITHOUT_PSWD value from RSSPARM.
 *                             Default: Y
 *                             If not required, address is NULL
 *               : appl_name - 9 chars
 *                   APPL_NAME value from RSSPARM.
 *                   If not required, address is NULL
 *               : appl_OK
 *                   Y - appl is defined in rssparm and exists
 *                       in RSS, or appl does not exist in
 *                       rssparm.
 *                   N - appli is defined in rssparm but doesn
 *                       not exist in RSS.
 *
 * Return Value  : ESA_OK
 *               : ESA_FATAL
 *
 * Considerations: This function should be called when:
 *                 - COMMON_PARAMS is created.
 *                 - Login_first should be done but COMMON_PARAMS
 *                   does not exist.
 *
 ****************************************************/
ESA_RC  Init_Allowed_Admins (
                         char                    * allow_prot,
                         char                    * appl_name,
                         char                    * appl_OK,
                         ESA_DIAG_COMP_typ         diag_comp,
                         ADMIN_PARAMS_rec_typ    * admin_params)
{

 /*  BS10100 - end   */

  static char func[] = "Init_Allowed_Admins";

  ESA_RC                     rc = ESA_OK;
  char                       prot_parm[2];
  char                       appl_parm[9];
  char                       errmsg[256] = "";

  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

 /*
  *   Initialization
  */
  ESA_DIAG_enter(diag_comp, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /* BS10100 - Start Initialize *appl_OK to 'Y' by default */
  if (appl_OK NE NULL)
  {
     /* BS10111 *appl_OK = ADMIN_WOUT_PSWD_DFLT;  */
     *appl_OK = 'Y';                                      /* BS10111 */
  }
  /* BS10100 - End */

 /*
  *  Hanlde ALLOW_ADMIN_WITHOUT_PSWD parameter, if requested.
  */
  if (allow_prot NE NULL)
  {
    *allow_prot = NULL_CHAR;  /* Initialize returned value */

    prot_parm[0] = NULL_CHAR;
    rc = admin_params->cs_func.rssprm_get_opt_ptr(
                  admin_params->rss_name,
                  ALLOW_ADMIN_WOUT_PSWD,
                  sizeof(prot_parm),
                  prot_parm,
                  OPT_TRUE,
                  OPT_FALSE) ;
    ESA_DIAG_printf(diag_comp, 6,
           "%s = <%s>  rc = <%d> ",
           ALLOW_ADMIN_WOUT_PSWD, prot_parm, rc);

    /* If not specified or incorrect set default as N.        */

    if ((rc EQ ESA_KEY_NOT_FOUND)  OR
      (rc EQ ESA_OK  AND  prot_parm[0] NE 'N' AND  prot_parm[0] NE 'Y'))
    {
      prot_parm[0] = 'N';
      prot_parm[1] = NULL_CHAR;

      CTSAMSG_print(MSG_PRM_SET_DEF_VALUE, msgs, NULL, dest,
                    ALLOW_ADMIN_WOUT_PSWD, prot_parm);
      ESA_DIAG_printf(diag_comp, 6,
           "Default %s = <%s>",
           ALLOW_ADMIN_WOUT_PSWD, prot_parm);
      rc = ESA_OK;      /* Parm is not mandatory, considerred OK */

    }
    else
      if (rc NE ESA_OK)       /* Error retrieving parameter    */
      {
         rc = ESA_FATAL;
         goto exit;
      }

    *allow_prot = prot_parm[0]; /* Return parameter or default value */
    ESA_DIAG_printf(diag_comp, 6,
           "allow_prot = <%c>", *allow_prot);
  }

 /*
  *  Hanlde APPL_NAME parameter, if requested.
  */
  if (appl_name NE NULL)
  {
    appl_name[0] = NULL_CHAR;   /* Initialize returned value */

    rc = admin_params->cs_func.rssprm_get_opt_ptr(
                  admin_params->rss_name,
                  APPL_NAME,
                  sizeof(appl_parm),
                  appl_parm,
                  OPT_TRUE,
                  OPT_FALSE) ;
    ESA_DIAG_printf(diag_comp, 6,
           "%s = <%s>  rc = <%d> ",
           APPL_NAME, appl_parm, rc);

    /* If not specified, issue a warning                      */

    if (rc EQ ESA_KEY_NOT_FOUND)
    {
      CTSAMSG_print(APPL_IS_MISSING, msgs, NULL, dest,
                    APPL_NAME);
      ESA_DIAG_printf(diag_comp, 6,
           "Parameter %s is missing", APPL_NAME);
      if (appl_OK NE NULL)                                /* BS10111 */
         *appl_OK = 'Y';                                  /* BS10111 */
      rc = ESA_OK;      /* Parm is not mandatory, considerred OK */

    }
    else    /* Specified, verify the appl is defined  */
    {
      strcpy(appl_name, appl_parm);            /* return APPL name */
      ESA_DIAG_printf(diag_comp, 6,
                      "appl_name = <%s>", appl_name);

      rc = Verify_APPL (appl_name,
                        diag_comp,
                        admin_params);
      ESA_DIAG_printf(diag_comp, 6,
                      "Verify_APPL for APPL %s returned rc = %s",
                      appl_name, ESA_rc2str(rc));
      if (rc EQ ESA_OK)
        if (appl_OK NE NULL)                              /* BS10111 */
          *appl_OK = 'Y';
      else
      {
        if (appl_OK NE NULL)                              /* BS10111 */
          *appl_OK = 'N';

        if (rc EQ ESA_SKIP)          /* appl is not defined in RSS */
          rc = ESA_OK;
        else                         /* error */
          rc = ESA_FATAL;
      }
    }
  }

  ESA_DIAG_printf (diag_comp, 6,
     "Return: ALLOW_PROT = %c, APPL = %s, APPL_OK = %c",
     (allow_prot NE NULL? allow_prot[0] : ' '),
     (appl_name NE NULL? appl_name : " "),
     (appl_OK   NE NULL? *appl_OK : ' ') ); /*BS10100*/

 exit:;


  ESA_DIAG_exit(diag_comp, 1, func, rc );

  return rc;
}

/****************************************************
 * Procedure Name: Verify_APPL
 *
 * Description   : Verify that the APPL specified in RSSPARM is
 *                 defined in the security product.
 *
 * Parameters    : appl_name - 9 chars
 *                             APPL_NAME value from RSSPARM.
 *
 *
 * Return Value  : ESA_OK       - defined
 *               : ESA_SKIP     - not defined
 *               : ESA_FATAL    - error.
 *
 * Considerations: This function should be called when:
 *                 - COMMON_PARAMS is created.
 *                 - Login_first should be done but COMMON_PARAMS
 *                   does not exist.
 *
 ****************************************************/
static ESA_RC  Verify_APPL (char                    * appl_name,
                            ESA_DIAG_COMP_typ         diag_comp,
                            ADMIN_PARAMS_rec_typ    * admin_params)
{

  static char func[] = "Verify_APPL";

  ESA_RC          rc = ESA_OK;
  int             dbg_lvl = 0;
  int             ver_rc = 0;

  int             saf_rc = 0;
  int             racf_rc = 0;
  int             racf_rs = 0;

  char            curr_jobname[9] = "";
  char            curr_jobid[9]   = "";
  char            curr_userid[9]  = "";
  char            curr_sysid[5]  = "";
  void          * curr_acee = NULL;

  char            errmsg[256] = "";
  CTSAMSG_HANDLE_rec_typ     * msgs;
  CTSAMSG_DEST_TABLE_rec_typ * dest;

 /*
  *   Initialization
  */
  ESA_DIAG_enter(diag_comp, 1, func );

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  /* Verity if there is anything to check    */
  if ( appl_name EQ NULL OR
      (appl_name NE NULL AND appl_name[0] EQ NULL_CHAR) )
  {
    rc = ESA_OK;
    goto exit;
  }

  /*  Find address space details */
  OS_MVS_whoami( curr_jobname, curr_jobid,
                  curr_userid, curr_sysid, &curr_acee );
  ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                  "WhoAmI: %s / %s / %s / %s / %8X",
                  curr_jobname, curr_jobid, curr_userid,
                  curr_sysid, curr_acee);

  dbg_lvl = (int)ESA_DIAG_get_debug_level(diag_comp);
  if ( dbg_lvl GT 0 )
    dbg_lvl = 1;
  /*
   *  Check if current ACEE has access to the APPL
   *
   *  We ar enot actually interested in the permission, whether the
   *  APPL is defined ot not, and we will get this information by the
   *  return cpde returned form RACF.
   *
   */
  ver_rc = (*(ASM_RTN_TYP *)&OS_DYNAM_call)
             ("CTSAFAT ",
              1,                         /* routine has parameters */
              "APPL",
              "LOGNONE",                 /* LOG=NONE */
              appl_name,
              curr_acee,
              &dbg_lvl,
              &saf_rc,
              &racf_rc,
              &racf_rs);
  ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
        "CTSAFAT for user %s (%8X) APPL %s returned rc %d - %d/%d/%d",
        curr_userid, curr_acee, appl_name, ver_rc,
        saf_rc, racf_rc, racf_rs);

  switch (ver_rc)
  {
    case 0:                    /* Allowed */
    case 8:                    /* Not Allowed */
       ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                       "APPL %s is defined in the security system",
                       appl_name);

      rc = ESA_OK;
      break;
    case 4:                    /* Not defined */
      ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                   "APPL %s is not defined in the security system",
                   appl_name);
      CTSAMSG_print(ERR_APPL_NOTDEF,
                    msgs, NULL, dest,
                    appl_name, admin_params->rss_type);
      rc = ESA_SKIP;
      break;
    default:                   /* Any other return code - error */
      ESA_DIAG_printf(ESA_COMP_RSS_LOGIN, 6,
                "CTSAFAT for user %s APPL %s return an error rc = %d",
                 curr_userid, appl_name, ver_rc);

      sprintf(errmsg,
        "CTSAFAT for user %s (%8X) APPL %s returned rc %d - %d/%d/%d",
        curr_userid, curr_acee, appl_name, ver_rc,
        saf_rc, racf_rc, racf_rs);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                    component, func,
                    errmsg, ver_rc,  __LINE__);

      rc = ESA_FATAL;
      break;
  }

 exit:
  ESA_DIAG_exit(diag_comp, 1, func, rc );
  return (rc);
}
/* BS10100 -  end   */
