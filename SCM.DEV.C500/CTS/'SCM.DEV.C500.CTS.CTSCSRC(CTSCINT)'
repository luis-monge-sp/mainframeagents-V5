/**************************************************************
*                                                             *
* Title            : Interceptor functions                    *
*                                                             *
* File Name        : ctscint.c                                *
*                                                             *
* Author           : Alexander Shvartsman                     *
*                                                             *
* Creation Date    : 10/08/94                                 *
*                                                             *
**************************************************************/

/*****************************************************************
* Mod.Id   Who      When     Description                         *
* -------- -------- -------  ----------------------------------- *
* dc2902   Doron    29/2/96  Send password in lower case         *
*                            and remove diag printing of pass    *
* as2503   Alex     25/3/96  Send password in lower/upper case   *
*                            according parameter from RSSPARM    *
* ps0089   Doron    20/5/97  restructure to separate RACF        *
*                            dependent code and support TSS      *
*                            dependent code to CTSRINT and       *
*                            CTSTINT .                           *
* ps0219   Alex     26/10/97 Support for rss_type in EVT         *
* ps0295   Guy      13/08/98 Changes for common code 3.0.0 GA    *
* ws2348   Doron    9/5/99   Support password filter option      *
* bs2388   Yonatan  6/6/99   change 'SUPRESS' to 'SUPPRESS'      *
*                            in onli_password_filter and skip    *
*                            statistics.                         *
* ws2372   Yonatan  4/7/00   transfer password update            *
*                            originating program                 *
* ws2431   Michael  22/11/01 Send connection updates for ACF2    *
* ws2240   RamiK    02/12/01 verify password change with RSS     *
* ws2451   Yonatan  15/01/02 make password violation optional    *
* ws2460   Yonatan  05/03/02 verify without logon (optional)     *
* BS2538   AvnerL   24/07/02 4 acf2 suspend user, no verify pswd *
* BS2562   AmirH    27/10/02 Revoked/expired ID verify pswd      *
*                            should fail under TSS and ACF2      *
* is0041   AvnerL   02/03/03 ver_pass without logon 4 acf2       *
* IS0121   MichaelC 2/10/03  add support for DB2 ONLI            *
*                            including enlarged EVT              *
* IS0231   AmirH    25/1/04  Add support for multiple Online     *
*                            Intercetpors for DB2 subsystems     *
* BS2663   AmirH    25/2/04  Add the following changes done      *
*                            for C350:                           *
*                     WS2504 Filter passwords of netlock (eds)   *
*                     WS2505 Filter Online interceptor events    *
*                     BS2601 Ignore change password events of ESS*
*                     WS2509 Filter user_update (netlock-eds)    *
* bs2618   AmirH    18/11/03 Send connections after rename       *
* IS0272   Michael  10/06/04  Update RACF 3.2.0 with old fixes   *
* bs2648   AvnerL   22/08/04 handle empty userid revoke case.    *
* IS0328   yonatan  01/12/05 update new parent group's SUBGROUP  *
* WS2557   EliMY    23/05/06 RACF MIXEDCASE PASSWORD SUPPORT     *
*                            FOR ZOS1.7                          *
* is0351   EliMY    14/09/06 upgrade to ACF2 v3102, bs2685 -     *
*                            fix bs2648. Eye catcher: bs2685.    *
* IS10002  AvnerL   31/01/07 VERIFY_PASSWORD_BY_LOGIN val is kept*
* IS10008  AvnerL   20/08/07 vrfy pswd without login only 4 RACF *
* WS10013  AvnerL   29/10/07 Intercept LOGIN events.             *
* IS10018  AvnerL   15/06/08 Onli intercepts ESS ChangPass-bs2707*
* IS10028  AvnerL   22/02/09 Set verify_password_counter parm.   *
* IS10066  NuritY   14/02/12 Verify password succeeds wvwn when  *
*                            the user is revoked / expired.      *
* IS10100  NuritY   29/07/13  Support CTSA internal custom       *
*                             fields (CTSACFs) and revoke        *
*                             reason.                            *
* IS10107  NuritY   23/12/13 Support value of ASIS for           *
*                            ONLI_PASSWORD_CASE - compile only.  *
* WS10048  AvnerL   30/03/15 Enable userid first letter filter   *
* SAS2IBMT SeligT   12/07/16 SAS/C to IBM C Conversion Project   *
* SAS2IBMN NuritY   12/01/17 Remove DB2 support - code was       *
*                            deleted.                            *
*    "       "      17/01/17 Replace sleep with ctsaslp          *
* WS10064  MeirS    04/10/17 Support Phrase.                     *
* WS10067  SeligT   18/01/18 Update GDB dynamically when access  *
*                            or resource rules are added/modified*
* IS10170  AvnerL   01/04/18 Verify-password fails with blank    *
* WS10072  SeligT   12/06/18 Notify When a Password Event Is     *
*                            Ignored                             *
* IS10182  AvnerL   17/07/19 S0C4/S0C1 due to DIAG vsprintf      *
* IS10183  Thomas   06/05/21 Don't print passwords in diag       *
* IS10184  NuritY   02/09/21 Improve scripts performance.        *
* WS10085  PatilV   09/10/23 Enable RU_LOCKED for IDN with RACF  *
******************************************************************/

#include <globs.h>

/*
 *   Standard header files
 */

#include STRING
#include STDIO
#include STDLIB
#include CTYPE
 /* #include LCLIB                                           SAS2IBMT */
/* SAS2IBMN #include UNISTD                                * SAS2IBMT */

/*
 *   Common code header files
 */

#include ESA_API
#include ESA_DIAG
#include ESA_API_CODES

/*
 *   Platform header files
 */

#include MVS_CODES
#include MVS_INTERCEPTOR
#include MVS_ONLINE_INTERCEPTOR                 /* BS2663 */

/*
 *   RACF header files
 */

#include RACF_CODES
#include RACF                                    /* IS10002 */

/*
 *   WS2240 defines for password verify
 */

/* IS10184
#define VERIFY_PASSWORD_BY_LOGIN "VERIFY_PASSWORD_BY_LOGIN" /@ws2460@/
*/
#define VERIFY_PASSWORD_LOOP_PARAM "ONLI_PASSWORD_DELAY"
#define DEFAULT_LOOP_DELAY    1
#define MAX_LOOP_COUNTER      4
#define RACF_FUNCTION_OK_RC      0
/* IS10066 #define RACF_FUNCTION_FAILED_RC  8    */
/* IS10066 #define RACF_PASSWORD_EXPIRED_RC 12   */
/* IS10066 #define RACF_USER_REVOKED_RC     28   */
#define PASSWORD_EVENT_FILTER "PASSWORD_EVENT_FILTER"   /*BS2663*/
#define USERS_TO_FILTER       "USERS_TO_FILTER"         /*WS10048*/

/*
 *   WS10013 define for ACT_LOGIN
 *   ACT_LOGIN should have been set in esaapi.h in ACTION_typ struct.
 *   It has been set internally here, to save the overhead of
 *   updating CC object in v3.1.08.
 *   MS - Defined in esaapi.h 27/09/17 WS10064
 */

 /* #define ACT_LOGIN   7    WS10064 */          /*WS10013*/

/*
 *   IOA masking routine
 */

/* SAS2IBMT prototype changed for IBM C
int ctsamsk (char *text, int *text_length,
             char *mask, int *mask_length,
             int  *opcode, char *work_area);                         */
int ctsamsk ();                                           /* SAS2IBMT */
int ctsaslp ();                                           /* SAS2IBMN */

/* ps0219 */
static ESA_RC CTSCINT_write_event_rec(char                 type,
                            char                         * group,
                            char                         * user,
                            ACTION_typ                     action,
                            int                            msg_flag,
                            RSS_typ                        rss_name,
                            RSS_typ                        rss_type,
                            void                         * handle,
               /* WS10064    ADMIN_PARAMS_rec_typ         * admin_prms);
               */           /* ps0295 */
               /* WS10064 */ ADMIN_PARAMS_rec_typ         * admin_prms,
               /* WS10064 */ char                         * pwphrase);

/* WS2240 */
/* IS10018 starts
/*        Move verify_password routine to CMAC, to allow access
/*        from CTSTINT as well.
static ESA_RC verify_password(char                         * user,
                              char                         * password,
                              INTERCEPT_RSS_PARAMS_rec_typ * rss_parm,
                *IS10002*     ADMIN_PARAMS_rec_typ       *admin_params);
*/
/* IS10018 ends */

/* SAS2IBMT prototype changed for IBM C
extern int ctsavps(char *user,
                   char *password,
                   char *how_to_verify, // ws2460 //
                   char *rss_type, // ws2460 //
                   int  *debug_level,
                   int  *create_racf_out,
                   int  *create_racf_rc,
                   int  *create_racf_reason,
                   int  *delete_racf_out,
                   int  *delete_racf_rc,
                   int  *delete_racf_reason);                        */
extern int ctsavps();                                     /* SAS2IBMT */

static char comp[]= "CTSCINT";

extern char      pwdflag;                        /* BS2663 */
extern char      usrflag;                        /* BS2663 */
extern char      grpflag;                        /* BS2663 */
extern char      oeflag;                         /* BS2663 */
extern char      passflag;                       /* WS10064 */
extern char      phrsflag;                       /* WS10064 */
extern char      provflag;                       /* WS10085 */

/* ps0219 */
/**************************************************************
*                                                             *
* Subroutine name : CTSCINT_write_event                       *
*                                                             *
* DESCRIPTION     : Notify of event to Control-SA             *
*                                                             *
* INPUT           :                                           *
*                                                             *
* OUTPUT          : none                                      *
*                                                             *
* RETURN VALUE    : ESA_RC                                    *
*                                                             *
**************************************************************/

ESA_RC CTSCINT_write_event (char                           type,
                            char                         * group,
                            char                         * user,
                            ACTION_typ                     action,
                            int                            msg_flag,
                            INTERCEPT_RSS_PARAMS_rec_typ * rss_parm,
               /* WS10064   ADMIN_PARAMS_rec_typ         * admin_parms);
                            /* ps0295 - added ADMIN_PARAMS parameter */
               /* WS10064 */ ADMIN_PARAMS_rec_typ         * admin_parms,
               /* WS10064 */ char                         * pwphrase)
{

  static char func[] = "CTSCINT_write_event";
  ESA_RC      rc = ESA_OK ;
  int         i                   = 0;
  int         use_evt_rss_prefix  = 0;
  RSS_typ     rss_name;
  RSS_typ     rss_type;

  ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT,1, func);

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                  "rss_parm->rss_num=%d rss_pfx length=%d",
                  rss_parm->rss_num, strlen(rss_parm->rss_pfx) );

  /* WS10085 start */
  /* Do not write event in Queue when its RACF and IDN */
  if (( memcmp( rss_parm->type, "RACF", 4) EQ 0) AND
     (provflag EQ IDNT_PLTFORM_IDN_FLAG))
   {
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
          "RACF Events not written to Queue for IDN");
    goto exit;
    }
  /* WS10085 end   */

  if ( (rss_parm->rss_num GT 0) AND (strlen(rss_parm->rss_pfx) GT 0) )
    use_evt_rss_prefix = 1;

  /* Do not use EVT rss prefix name */

  if ( NOT use_evt_rss_prefix ) {
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                    "NOT use_evt_rss_prefix: rss_name=%s rss_type=%s",
                    rss_parm->name, rss_parm->type);
    rc = CTSCINT_write_event_rec(type, group, user, action, msg_flag,
                                 rss_parm->name, rss_parm->type,
                                 rss_parm->handle,
  /*                             admin_parms);  WS10064       ps0295 */
                                 admin_parms, /*WS10064       ps0295 */
                                 pwphrase);  /*WS10064              */
    goto exit;
  }

  /* Use EVT rss prefix name */

  for (i=0; i LT rss_parm->rss_num; i++ ) {
      strcpy(rss_name, rss_parm->rss_name[i]);
      strcpy(rss_type, rss_parm->rss_type[i]);

      ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                      "%d. rss_name=%s rss_type=%s",
                      i, rss_name, rss_type);

      if ( memcmp( rss_type,
                   rss_parm->rss_pfx,
                   strlen(rss_parm->rss_pfx) ) EQ 0 ) {
         ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                    "use_evt_rss_prefix:%d. rss_name=%s rss_type=%s",
                     i, rss_name, rss_type);
         rc = CTSCINT_write_event_rec(type, group, user, action,
                                      msg_flag, rss_name, rss_type,
                                      rss_parm->handle,
  /*                                  admin_parms);  WS10064  ps0295 */
                                      admin_parms, /*WS10064  ps0295 */
                                      pwphrase);   /*WS10064         */
         if (rc NE ESA_OK)
           goto exit;
      }
   }

  /**************************************************************
  *   Finish                                                    *
  **************************************************************/

  exit:

  ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT,1, func, rc );

  return rc;

}

/**************************************************************
*                                                             *
* Subroutine name : CTSCINT_write_event_rec                   *
*                                                             *
* DESCRIPTION     : Notify of event to Control-SA             *
*                                                             *
* INPUT           :                                           *
*                                                             *
* OUTPUT          : none                                      *
*                                                             *
* RETURN VALUE    : ESA_RC                                    *
*                                                             *
**************************************************************/

static ESA_RC CTSCINT_write_event_rec(char                 type,
                            char                         * group,
                            char                         * user,
                            ACTION_typ                     action,
                            int                            msg_flag,
                            RSS_typ                        rss_name,
                            RSS_typ                        rss_type,
                            void                         * handle,
               /* WS10064   ADMIN_PARAMS_rec_typ         * admin_parms);
                               ps0295 */
               /* WS10064 */ ADMIN_PARAMS_rec_typ         * admin_parms,
               /* WS10064 */ char                         * pwphrase)
{

  static char func[] = "CTSCINT_write_event_rec";
  ESA_RC      rc = ESA_OK ;
  ADDINFO_rec_typ empty_addinfo = { 0 , 0 } ;

  CTSAMSG_HANDLE_rec_ptr     msgs;                        /* ps0295 */
  CTSAMSG_DEST_TABLE_rec_ptr dest;                        /* ps0295 */
  char login_intercept[2];                               /* WS10013 */

  ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT,1, func);

  msgs = admin_parms->ctsamsg_handle;                     /* ps0295 */
  dest = admin_parms->ctsamsg_dest;                       /* ps0295 */

  ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 3,              /*WS10013*/
         "type=<%c> action=<%s/%x> user=<%s>",
         type,action,action,user);
  switch ( type ) {

    /************* Connect changed ************/

    case 'C' :
         if (( usrflag EQ FLAG_USERID_OFF ) ||           /*BS2663*/
           (( usrflag EQ FLAG_USERID_ON ) &&             /*BS2663*/
            ( pwdflag EQ FLAG_PWD_ONLY_ON )))            /*BS2663*/
         {   rc = ESA_SKIP;
         break;  }                                       /*BS2663*/

         if (msg_flag) {
            switch (action) {
              case (ACT_ADD) :
                   CTSAMSG_print(MSG_ONLI_U2UG_ADDED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, group, rss_name);
                   break;
              case (ACT_DELETE) :
                   CTSAMSG_print(MSG_ONLI_U2UG_DELETED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, group, rss_name);
                   break;
              default :
                   CTSAMSG_print(MSG_ONLI_U2UG_UPDATED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, group, rss_name);
                   break;
            }
         }

         rc = CTSConnEvent(rss_type, rss_name, handle, group, user,
                           action, admin_parms);          /* ps0295 */
         break;

    /************* container (OE) changed ************/

    case 'O'   :
         if (oeflag EQ FLAG_OE_OFF)            /*BS2663*/
         {  rc = ESA_SKIP;                     /*BS2663*/
         break;   }                            /*BS2663*/

         if (msg_flag) {
            switch (action) {
              case (ACT_ADD) :
                   CTSAMSG_print(MSG_ONLI_OE_ADDED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
              case (ACT_DELETE) :
                   CTSAMSG_print(MSG_ONLI_OE_DELETED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
              default :
                   CTSAMSG_print(MSG_ONLI_OE_UPDATED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
            }
         }
         rc = CTSOEEvent(rss_type, rss_name, handle, user, action,
                         admin_parms);                    /* ps0295 */
         break;

    /************* Group changed ************/

    case 'G'   :
         if (grpflag EQ FLAG_GROUP_OFF)                  /*BS2663*/
         {  rc = ESA_SKIP;                               /*wd2505*/
         break;    }                                     /*BS2663*/

         if (msg_flag) {
            switch (action) {
              case (ACT_ADD) :
                   CTSAMSG_print(MSG_ONLI_UG_ADDED,
                           msgs, NULL, dest,              /* ps0295 */
                           group, rss_name);
                   break;
              case (ACT_DELETE) :
                   CTSAMSG_print(MSG_ONLI_UG_DELETED,
                           msgs, NULL, dest,              /* ps0295 */
                           group, rss_name);
                   break;
              default :
                   CTSAMSG_print(MSG_ONLI_UG_UPDATED,
                           msgs, NULL, dest,              /* ps0295 */
                           group, rss_name);
                   break;
            }
         }
         rc = CTSUGEvent(rss_type, rss_name, handle, group, action,
                         admin_parms);                    /* ps0295 */
         break;

    /************* User changed ************/

    case 'U'   :
      ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 3,/*WS10013*/
         "type is U (user).action=<%x> user=<%s>",
         action,user);
      if  (usrflag EQ FLAG_USERID_OFF )                   /*BS2663*/
          { rc = ESA_SKIP;                                /*BS2663*/
            break;      }                                 /*BS2663*/


         if (msg_flag) {
            switch (action) {
              case (ACT_ADD) :
                if  ( pwdflag EQ FLAG_PWD_ONLY_ON )       /*BS2663*/
                 { rc = ESA_SKIP;                         /*BS2663*/
                   break;      }                          /*BS2663*/

                   CTSAMSG_print(MSG_ONLI_USER_ADDED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
              case (ACT_DELETE) :
                if  ( pwdflag EQ FLAG_PWD_ONLY_ON )       /*BS2663*/
                 { rc = ESA_SKIP;                         /*BS2663*/
                 break;      }                            /*BS2663*/

                   CTSAMSG_print(MSG_ONLI_USER_DELETED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
              /* login event from IEFU84 exit rty=30        WS10013*/
              case (ACT_LOGIN) :
                /****************** WS10013 start ******************/
                /* send event only if rssparm's parm is set WS10013*/
                rc = admin_parms->cs_func.rssprm_get_opt_ptr(
                    admin_parms->rss_name,
                    "LOGIN_INTERCEPT",
                    sizeof(login_intercept),
                    login_intercept,
                    OPT_TRUE,
                    OPT_TRUE) ;
                /*IS10182 admin_parms->cs_func.DIAG_printf_ptr( */
                ESA_DIAG_printf(                    /*IS10182*/
                    ESA_COMP_RSS_INTERCEPT, 3,
                    "LOGIN_INTERCEPT = <%s> ,rc = <%d> ",
                    login_intercept, rc);
                if (rc NE ESA_OK) { /*default is 'Y' */
                    login_intercept[0] = 'Y';
                    rc = ESA_OK; /*parm is not mandatory, set rc=0 */
                }

                if(login_intercept[0] == 'Y')
                  {
                   CTSAMSG_print(MSG_ONLI_USER_LOGIN,
                   msgs, NULL, dest, user, rss_name);
                   ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 3,
                     "LOGIN event for user <%s> is written to Q.",
                     user);
                  }
                else /*login_intercept[0]=='N'*/
                  {
                   rc = ESA_SKIP;
                   ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 3,
                     "LOGIN_INTERCEPT=N ==> skip event.");
                  }
                   break;
              /****************** end of WS10013 *********************/
              case (ACT_PWD_UPD):
                if (passflag EQ FLAG_PASSWORD_OFF )       /*WS10064*/
                 { rc = ESA_SKIP;                         /*WS10064*/
                   ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,/*WS10064*/
            "password event is filtered due to ONLI_EVENT_PASSWORD=N.");
                   CTSAMSG_print(MSG_ONLI_PSWD_EVENT_IGNORED,/*WS10072*/
                           msgs, NULL, dest, "", user,       /*WS10072*/
                           "ONLI_EVENT_PASSWORD=N");         /*WS10072*/
                   break; }                               /*WS10064*/
                   CTSAMSG_print(MSG_ONLI_USER_PASSWORD,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
              /* WS10064 start */
              case (ACT_PWPH_UPD):
                if (phrsflag EQ FLAG_PHRASE_OFF )
                 { rc = ESA_SKIP;
                   ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,
            "passphrase event is filtered due to ONLI_EVENT_PHRASE=N.");
                   CTSAMSG_print(MSG_ONLI_PSWD_EVENT_IGNORED,/*WS10072*/
                           msgs, NULL, dest, "phrase", user, /*WS10072*/
                           "ONLI_EVENT_PHRASE=N");           /*WS10072*/
                   break; }
                   CTSAMSG_print(MSG_ONLI_USER_PASSPHRASE,
                           msgs, NULL, dest,
                           user, rss_name);
                   break;
              /* WS10064 end   */
              case (ACT_REVOKE):
                if  ( pwdflag EQ FLAG_PWD_ONLY_ON )       /*BS2663*/
                 { rc = ESA_SKIP;                         /*BS2663*/
                 break;      }                            /*BS2663*/

                   CTSAMSG_print(MSG_ONLI_USER_REVOKED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
              default :
               if  ( pwdflag EQ FLAG_PWD_ONLY_ON )        /*BS2663*/
                 { rc = ESA_SKIP;                         /*BS2663*/
                 break;      }                            /*BS2663*/

                   CTSAMSG_print(MSG_ONLI_USER_UPDATED,
                           msgs, NULL, dest,              /* ps0295 */
                           user, rss_name);
                   break;
            } /* end of switch */
         } /* end if (msg_flag) */

         ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 3,
             "switch (action) follows.");                 /*ws10013*/
         switch (action) {

           case ACT_REVOKE:
               if ( pwdflag EQ FLAG_PWD_ONLY_ON )         /*BS2663*/
                 { rc = ESA_SKIP;                         /*BS2663*/
                 break;      }                            /*BS2663*/

                rc = CTSUserRevokedEvent(rss_type, rss_name, handle,
                            user, admin_parms);           /* ps0295 */
                break;

           case ACT_PWD_UPD:
               if ( rc EQ ESA_SKIP ) {                    /*WS10064*/
                ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3, /*WS10064*/
                   "Password: Skip CTSPassModEvent as rc=SKIP");
                   break;                                 /*WS10064*/
               }
                rc = CTSPassModEvent(rss_type, rss_name, handle, user,
                            group, &empty_addinfo, admin_parms);
                                                          /* ps0295 */
                break;

            /* WS10064 start */
           case ACT_PWPH_UPD:
               if ( rc EQ ESA_SKIP ) {
                ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,
                   "Phrase: Skip CTSPassModEvent as rc=SKIP");
                   break;
               }
                rc = CTSPassModEvent(rss_type, rss_name, handle, user,
                            pwphrase, &empty_addinfo, admin_parms);

                break;
            /* WS10064 end   */

           default:

            if ( ( pwdflag EQ FLAG_PWD_ONLY_ON ) OR        /*BS2663*/
                 ( rc EQ ESA_SKIP ) )                     /*WS10013*/
                 { rc = ESA_SKIP;                         /*BS2663*/
                   ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,/*ws10013*/
                   "Skip CTSUserEvent rc=<%i> pwdflag=<%c>",rc,pwdflag);
                   break;                                   /*BS2663*/
                  }
            rc = CTSUserEvent(rss_type, rss_name, handle, user,
                            action, admin_parms);         /* ps0295 */
            break;
         }

         break;

    /************* RSS parameters changed ************/

    case 'R'   :

         CTSAMSG_print(MSG_ONLI_RSSP_UPDATED,
                       msgs, NULL, dest,                  /* ps0295 */
                       rss_name);

         rc = CTSParamsModEvent(rss_type,
                                rss_name,
                                handle,
                                admin_parms);             /* ps0295 */
         break;

    /************* Unidentified object changed ************/

    default:

         CTSAMSG_print(ERR_INTERNAL,
                       msgs, NULL, dest,                  /* ps0295 */
                       comp,__FILE__,2,__LINE__);
         rc = ESA_FATAL;
         break;
  }

  /**************************************************************
  *   Finish                                                    *
  **************************************************************/

  exit:

  ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT,1, func, rc );

  return rc;

}

/**************************************************************
*                                                             *
* WS2240                                                      *
*                                                             *
* Subroutine name : verify_password                           *
*                                                             *
* DESCRIPTION     : verify that the changed password          *
*                   was excepted by the RSS.                  *
*                                                             *
* INPUT           : user  -   the changed passwords user      *
*                   password - the new passowrd               *
*                                                             *
* OUTPUT          : none                                      *
*                                                             *
* RETURN VALUE    : ESA_RC                                    *
*                                                             *
* written by      : RamiK                                     *
*                                                             *
* note: although some vars names contain RACF this code is    *
* relevant also for ACF2 and TSS. they also return RACF codes *
* and reasons.                                                *
*                                                             *
**************************************************************/

/*IS10018 drop static - static ESA_RC verify_password(char * user, */
ESA_RC verify_password(char                         * user,
                       char                         * password,
                       INTERCEPT_RSS_PARAMS_rec_typ * rss_parm,
        /*IS10002*/    ADMIN_PARAMS_rec_typ         * admin_params)
{
  static char func[]="verify_password";
  ESA_RC      rc;
  char       *loop_delay_time_char = "0000000001";
  int         loop_delay_time;
  char       *verify_password_number_char = "04";           /*IS10028*/
  int         verify_password_number;                       /*IS10028*/
  int         loopc, dbg_lvl;
  int         create_racf_rc, create_racf_out, create_racf_reason;
  int         delete_racf_rc, delete_racf_out, delete_racf_reason;
  int         verify_password_rc;
  int         password_verified = 0;
  /* SAS2IBMN char      * how_to_verify = " ";             *ws2460*/
  char        how_to_verify[2] = " ";          /*ws2460  SAS2IBMN */
  /*IS10008   RACF_PARAMS_rec_typ * params_ptr = NULL;    /* IS10002 */
  char        ctsaslp_time_type = 'S';     /* S(conds)      SAS2IBMN */
  char        errmsg[150] = "";                           /* IS10184 */
  COMMON_PARAMS_rec_typ  *cmnprms = NULL;                 /* IS10184 */

  CTSAMSG_HANDLE_rec_ptr     msgs;                        /* IS10184 */
  CTSAMSG_DEST_TABLE_rec_ptr dest;                        /* IS10184 */

  /**************************************************************
  *    start of program                                         *
  **************************************************************/

  ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT,1, func);

  msgs = admin_params->ctsamsg_handle;                    /* IS10184 */
  dest = admin_params->ctsamsg_dest;                      /* IS10184 */

  /************************ IS10028 *****************************
  * Get verify_password_counter parm value from RSSPARM.        *
  * Allow customer to change the default of verify password     *
  * attempts which is 4.                                        *
  **************************************************************/
  rc = rssprm_get_opt (rss_parm->name, "VERIFY_PASSWORD_NUMBER",
                   sizeof(verify_password_number_char),
                   verify_password_number_char,
                   OPT_TRUE,
                   OPT_FALSE);

  if (rc EQ ESA_OK) {
     ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                   "verify password number parm = <%s>",
                   verify_password_number_char);
     verify_password_number = atoi(verify_password_number_char);
  }
  else
     verify_password_number = MAX_LOOP_COUNTER;

  ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                   "verify password number = <%d>",
                   verify_password_number);
  /********************** end of IS10028 ***********************/

  /**************************************************************
  *    getting loop delay parameters from rssparm               *
  **************************************************************/
  rc = rssprm_get_opt (rss_parm->name, VERIFY_PASSWORD_LOOP_PARAM,
                   sizeof(loop_delay_time_char),
                   loop_delay_time_char,
                   OPT_TRUE,
                   OPT_FALSE);

  if (rc EQ ESA_OK) {
     ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                   "verify password loop delay parm = %s",
                   loop_delay_time_char);
     loop_delay_time = atoi(loop_delay_time_char);
  }
  else
     loop_delay_time = DEFAULT_LOOP_DELAY;

  ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
                   "verify password loop delay = %d",
                   loop_delay_time);

  /*ws2460
   * Check how to verify the password. By default, don't do login
   * At this stage: RACF only
   */

  /* IS10184 - start                                           */
  /*           Get VERIFY_PASSWORD_BY_LOGIN value from         */
  /*           common_params instead of getting the            */
  /*           parameter and deciding on default.              */

  /*   the code below is replaced by IS10184
  if ((strncmp(rss_parm->type,"RACF",4) EQ 0) OR
      (strncmp(rss_parm->type,"ACF2",4) EQ 0))   /@ is0041 @/
  {
   /@ IS10008: APIInit is not called by Interceptor, so IS10002 @/
   /@          has created a bug here. Restore old code + improvements@/
   /@ Following 2 lines are dropped by IS10008                        @/
   /@params_ptr = admin_params->apiinit_handle;             /@IS10002@/
   /@how_to_verify = params_ptr->rssparm_VERIFY_PASS_LOGIN; /@IS10002@/
    rc = rssprm_get_opt (rss_parm->name, /@ re-set by IS10008       @/
                       VERIFY_PASSWORD_BY_LOGIN,
                       sizeof(how_to_verify),
                       how_to_verify,
                       OPT_TRUE,
                       OPT_FALSE);
    /@admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_RSS_INTERCEPT,3,@/
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,              /@IS10182@/
      "VERIFY_PASSWORD_BY_LOGIN = <%s> ,rc = <%d> ",
      how_to_verify, rc);

    if ((strncmp(rss_parm->type,"RACF",4) EQ 0) AND /@ is10008 @/
        (rc NE ESA_OK) OR  /@ default for RACF is 'N' @/
        (rc EQ ESA_OK  AND                                  /@IS10005@/
         how_to_verify[0] NE 'N' AND
         how_to_verify[0] NE 'Y')) {
      how_to_verify[0] = 'N';
      how_to_verify[1] = NULL_CHAR;                       /@ SAS2IBMT @/
      rc = ESA_OK; /@parm is not mandatory, set rc=0 @/
      }
    else /@ ACF2 @/
     if((rc NE ESA_OK) OR  /@ default for ACF2 is 'Y' @/
        (rc EQ ESA_OK  AND                                  /@IS10005@/
         how_to_verify[0] NE 'N' AND
         how_to_verify[0] NE 'Y')) {
      how_to_verify[0] = 'Y';
      how_to_verify[1] = NULL_CHAR;                       /@ SAS2IBMT @/
      rc = ESA_OK; /@parm is not mandatory, set rc=0 @/
      }


     /@ dropped by IS10008 if (rc NE ESA_OK)
       how_to_verify = "N"; IS10002 @/
  }
  else /@ not RACF not ACF2 ... @/
  /@ SAS2IBMN - start @/
  /@ how_to_verify = "Y";  * verify using login by default *   @/
  {
    how_to_verify[0] = 'Y'; /@ verify using login by default @/
    how_to_verify[1] = NULL_CHAR;
  }
  /@ SAS2IBMN - end   @/
    /@admin_params->cs_func.DIAG_printf_ptr(ESA_COMP_RSS_INTERCEPT,3,@/
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,             /@IS10182@/
      "VERIFY_PASSWORD_BY_LOGIN final value = <%c> ",
      *how_to_verify);
    rc = ESA_OK; /@parm is not mandatory, set rc=0 @/
        end of code replaced by iS10184 */

  GET_P_CMNPRMS(admin_params, cmnprms, rc, errmsg)
  if (rc EQ ESA_OK)
  {
    how_to_verify[0] = cmnprms->rssparm_VERIFY_PASS_LOGIN[0];
    how_to_verify[1] = NULL_CHAR;
  }
  else   /* no common_params - error */
  {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                  comp, func, errmsg, 16, __LINE__);
    goto exit;
  }
    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,
      "VERIFY_PASSWORD_BY_LOGIN final value = <%c> ",
      *how_to_verify);
  /* IS10184 - end */
  /* ws2460 - end */

  /**************************************************************
  * loop runs MAX_LOOP_COUNTER & checks the password every time *
  * if password not verified returns ESA_ERROR                  *
  **************************************************************/
  loopc = 0;
  verify_password_rc = ESA_ERR;

  dbg_lvl = (int)ESA_DIAG_get_debug_level(ESA_COMP_RSS_INTERCEPT);
  if ( dbg_lvl GT 0 )
     dbg_lvl = 1;

  ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT, 2,
    "calling CTSAVPS. how_to_verify=%c",*how_to_verify); /*is10002*/

  /* IS10028 for (loopc = 0; loopc < MAX_LOOP_COUNTER ; loopc++) */
  for (loopc = 0; loopc < verify_password_number; loopc++)  /*IS10028*/
  {
     /* SAS2IBMT
     verify_password_rc = ctsavps(user,                              */
     verify_password_rc = (*(ASM_RTN_TYP *)&ctsavps)      /* SAS2IBMT */
                                 (user,
                                  password,
                                  how_to_verify,
                                  rss_parm->type,
                                  &dbg_lvl,
                                  &create_racf_out,
                                  &create_racf_rc,
                                  &create_racf_reason,
                                  &delete_racf_out,
                                  &delete_racf_rc,
                                  &delete_racf_reason);

     ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT,2,
                     "CTSAVPS create: FRC=%d, RC=%d  rc=%d, rs=%d",
                     verify_password_rc,create_racf_out,
                     create_racf_rc,create_racf_reason);

     if (verify_password_rc EQ RACF_FUNCTION_OK_RC) {
        password_verified = 1;
        ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT,2,
                        "CTSAVPS delete: FRC=%d, RC=%d  rc=%d, rs=%d",
                        verify_password_rc,delete_racf_out,
                        delete_racf_rc,delete_racf_reason);
        break;
     }
     /* is10066 - remove the special process for racf.
     else {
         * BS2562 *
         *
         * Under RACF, failure might be accepted
         *
        if ( (verify_password_rc EQ RACF_FUNCTION_FAILED_RC ) AND
             (strncmp(rss_parm->type,RACF_RSS_TYPE,4) EQ 0) ) {
            *
            * Accept RACF revoked/expired user password verification
            *
           if ( (create_racf_rc EQ RACF_PASSWORD_EXPIRED_RC ) OR
                (create_racf_rc EQ RACF_USER_REVOKED_RC ) ) {
               password_verified = 1;
               break;
           }
        }
         * BS2562 End *
     }
     */

     /*IS10028 if ( loopc EQ MAX_LOOP_COUNTER - 1 )*/
     if ( loopc EQ verify_password_number - 1 )          /*IS10028*/
        break;

     ESA_DIAG_printf (ESA_COMP_RSS_INTERCEPT,2,
                     "sleeping for %d seconds",loop_delay_time);
     /* SAS2IBMN sleep(loop_delay_time);                            */
     (*(ASM_RTN_TYP *)&ctsaslp)                         /* SAS2IBMN */
      (&loop_delay_time, &ctsaslp_time_type, &dbg_lvl); /* SAS2IBMN */
  }

  exit:

  if (password_verified)
     rc = ESA_OK;
  else
     rc = ESA_SKIP;

  ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT,1, func, rc );

  return rc;
} /* end of verify_password */
/**************************************************************
*                                                             *
* Subroutine name : evnt2rs                                   *
*                                                             *
* DESCRIPTION     : Notify of event to Control-SA             *
*                                                             *
* INPUT           : evt -        smf event structure          *
*                   rss_parms    rss parameters               *
*                   admin_params                              *
*                                                             *
* OUTPUT          : none                                      *
*                                                             *
* RETURN VALUE    : ESA_RC                                    *
*                                                             *
**************************************************************/

ESA_RC  evnt2rs (INTERCEPT_EVENT_rec_typ      * evt,
                 INTERCEPT_RSS_PARAMS_rec_typ * rss_parm,
                 int                            msg_flag,
                 char                         * acs_jbn,
                 char                         * acs_pgm,
/* as2503 */     char                           password_case_flag,
/* ws2348 */     char                           password_filter_flag,
/* ps0295 */     ADMIN_PARAMS_rec_typ         * admin_params)
{

  static char func[]="evnt2rs";

  /**************************************************************
  *    Variables                                                *
  **************************************************************/

  char        user[9];
  char        group[9];
  char        pwphrase[101];                    /*WS10064*/
  char        passtype[10]; /* password or phrase WS10064*/
  char        supgroup[9];                                 /* IS0328 */
  char        admin[9];
  char        jobname[9];
  char        terminal[9];
  char        program[9];
  char        rss_pfx[21];
  ESA_RC      rc = ESA_OK ;
  ACTION_typ  action;

  char msk_work[256];
  int  rc_msk_jbn = -1 , rc_msk_pgm = -1 ;
  int  rc_msk_filter = -1 ;                         /* BS2663 */
  int  text_len, mask_len ;
  int  one = 1, i = 0;
  int  is_change_password_event = 0;

  CTSAMSG_HANDLE_rec_ptr     msgs;                        /* ps0495 */
  CTSAMSG_DEST_TABLE_rec_ptr dest;                        /* ps0495 */
  char origin_to_filter[9] = ""; /*netlock jobname in eds case BS2663*/
  char users_to_filter[60];                                 /*WS10048*/
  int  userid_first_letter;                                 /*WS10048*/

  /**************************************************************
  *    Initialize                                               *
  **************************************************************/

  ESA_DIAG_enter(ESA_COMP_RSS_INTERCEPT,1, func);

  msgs = admin_params->ctsamsg_handle;                    /* ps0495 */
  dest = admin_params->ctsamsg_dest;                      /* ps0495 */

  /* SAS2IBMN - start  */
  /* Print the input. A high diagnostic level was set so
   * it can be turned on only when needed.
   */
  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,12,
    "evt = %8X", evt);
  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,12,
    "Origin1 admin=%.8s user=%.8s jobname=%.8s program=%.8s",
    evt->o_user, evt->user_id, evt->o_jobname, evt->o_program);
  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,12,
    "Origin2 terminal=%.8s rss=%.8s",
    evt->o_terminal, evt->rss_type_prefix);
  /* SAS2IBMN - end    */

  /* WS10064   - start  */
  /* IS10183
  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
      "Password Phrase = %s, length = %d",
                  evt->passphrase,strlen(evt->passphrase));  */

  /* WS10064   - end    */
  FIELD_BLOCK(user, evt->user_id)
  FIELD_BLOCK(group, evt->group_id)
  FIELD_BLOCK_WITH_BLANK(pwphrase, evt->passphrase)       /* IS10170 */
/*FIELD_BLOCK(pwphrase, evt->passphrase)                   * WS10064 */
  FIELD_BLOCK(supgroup, evt->sup_group_id)                 /* IS0328 */
  FIELD_BLOCK(admin,evt->o_user)
  FIELD_BLOCK(jobname,evt->o_jobname)
  FIELD_BLOCK(program,evt->o_program)
  FIELD_BLOCK(terminal,evt->o_terminal)
  FIELD_BLOCK(rss_pfx,evt->rss_type_prefix)

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
    "Origin user=%s user=%s jobname=%s program=%s terminal=%s rss=%s",
        admin, user, jobname, program, terminal, rss_pfx );

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
      "Password Case=%c, Filter=%c",
                  password_case_flag, password_filter_flag );

  /**************************************************************
  *    Filter Control-SA modifications                          *
  **************************************************************/

  /*** Filter Netlock's password events  BS2663 ***/

  rc = rssprm_get_opt (rss_parm->name,
                    PASSWORD_EVENT_FILTER,
                    sizeof(origin_to_filter),
                    origin_to_filter,
                    OPT_TRUE,
                    OPT_FALSE);

  if (rc NE ESA_OK)
    strcpy(origin_to_filter,NULL);

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
      "Origin_to_filter=%s ",  origin_to_filter );

  if ( origin_to_filter NE NULL ) {
     mask_len = strlen(origin_to_filter);
     text_len = strlen(jobname);
     if ( (mask_len GT 0) AND (jobname[0] NE BLANK) )
        /* SAS2IBMT
        rc_msk_filter = ctsamsk(jobname, &text_len,                  */
        rc_msk_filter = (*(ASM_RTN_TYP *)&ctsamsk)        /* SAS2IBMT */
                               (jobname, &text_len,
                            origin_to_filter, &mask_len,
                            &one, msk_work);
  }

  /*** end of BS2663 (main part) ***/

  /*** Check jobname match acs jobname mask ***/

  if ( acs_jbn NE NULL ) {
     mask_len = strlen(acs_jbn);
     text_len = strlen(jobname);
     if ( (mask_len GT 0) AND (jobname[0] NE BLANK) )
        /* SAS2IBMT
        rc_msk_jbn = ctsamsk(jobname, &text_len, acs_jbn, &mask_len, */
        rc_msk_jbn = (*(ASM_RTN_TYP *)&ctsamsk)           /* SAS2IBMT */
                            (jobname, &text_len, acs_jbn, &mask_len,
                            &one, msk_work);
  }

  /*** Check program match acs progname mask ***/

  if (acs_pgm NE NULL) {
     mask_len = strlen(acs_pgm);
     text_len = strlen(program);
     if ( (mask_len GT 0) AND (program[0] NE BLANK) )
        /* SAS2IBMT
        rc_msk_pgm = ctsamsk(program, &text_len, acs_pgm, &mask_len, */
        rc_msk_pgm = (*(ASM_RTN_TYP *)&ctsamsk)           /* SAS2IBMT */
                            (program, &text_len, acs_pgm, &mask_len,
                            &one, msk_work);
  }

  /*** Check mask results ***/

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
    "ACS matching results : jbn_rc=%d pgm_rc=%d flt_rc=%d", /*BS2663*/
     rc_msk_jbn, rc_msk_pgm, rc_msk_filter );               /*BS2663*/
  /* rc_msk_filter is relevant only for password_event. c later */

  if ( (rc_msk_jbn EQ 0) OR (rc_msk_pgm EQ 0) )  {
     rc = ESA_SKIP;
     goto exit;
  }

  /*** Filter userids based on their first letter ***         WS10048*/
  rc = rssprm_get_opt (rss_parm->name,
                    USERS_TO_FILTER,
                    sizeof(users_to_filter),
                    users_to_filter,
                    OPT_TRUE,
                    OPT_FALSE);

  if (rc NE ESA_OK)
    strcpy(users_to_filter,NULL);

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
      "users_to_filter=%s ",  users_to_filter );

  if ( users_to_filter NE NULL ) {
    users_to_filter[59] = NULL_CHAR;                      /* SAS2IBMT */
    userid_first_letter = user[0];
    if(memchr(users_to_filter,userid_first_letter,
      strlen(users_to_filter))) {
        ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
        "Filterring user=<%s>",  user );
      rc = ESA_SKIP;
      goto exit;
    }
  }
  /*** End of WS10048 ***                                            */

  /**************************************************************
  *    Convert action type                                      *
  **************************************************************/

  switch  (evt->action) {

       case '?': action = ACT_UNKNOWN;
                 break;

       case 'A': action = ACT_ADD;
                 break;

       case 'D': action = ACT_DELETE;
                 break;

       case 'L': action = ACT_LOGIN;                        /*WS10013*/
                 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,3,
                 "LOGIN event is set as 7." );
                 break;

       case 'U': action = ACT_UPDATE;
                 /* BS2663 filter user_update events when
                  PASSWORD_EVENT_FILTER is set with relevant jobname
                  or job prefix */
                 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
             "Checking password Filter to filter UserUpdate as well." );

                 if ( rc_msk_filter EQ 0 )          {
                    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                    "Ignoring UserUpdate event" );
                    rc = ESA_SKIP;
                    goto exit;
                    }
                 break;

       case 'R': action = ACT_REVOKE;
                 /* BS2648/BS2685 starts */
     /* BS2685   if( strcmp(user,NULL)  EQ 0 OR
                     user[0] EQ BLANK )   drop BS2648 part */
                 ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,6, /* BS2685 */
                    "Action = REVOKE. User=<<%s>>",user);
                 if( strlen(user) EQ 0 OR /* no user ... BS2685 */
                     user[0] EQ NULL_CHAR )               /* SAS2IBMT */
                   {
                    FIELD_BLOCK(user, evt->o_user) /* use originate
                                                      user instead */
                    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,6,
                    "Userid not in RUTKN of SMF record, set %s instead",
                     user);
                   }
                 /* BS2648/BS2685 ends */
                 break;

       case 'P': action = ACT_PWD_UPD;

                is_change_password_event = TRUE;

                ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                                 "Checking password Filter" );

                 if ( password_filter_flag EQ           /* WS2348 */
                      PASSWORD_FILTER_ON  OR /* BS2663   * WS2348 */
                 /*   rc_msk_filter EQ 0 ) WS10064  {      WS2348 */
                      rc_msk_filter EQ 0 OR             /*WS10064 */
                      passflag EQ FLAG_PASSWORD_OFF) {  /*WS10064 */

                    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                                    "Ignoring password event" );
                   CTSAMSG_print(MSG_ONLI_PSWD_EVENT_IGNORED,/*WS10072*/
                           msgs, NULL, dest, "", user,       /*WS10072*/
                           "ONLI_EVENT_PASSWORD=N");         /*WS10072*/
                    /* rc = ESA_OK;                        WS2348 */
                    rc = ESA_SKIP;                      /* BS2388 */
                    goto exit;                          /* WS2348 */
                 }                                      /* WS2348 */

                 /* ws2557: Remarked due need to verify password
                            before convert password to lower case.
                 if ( password_case_flag EQ PASSWORD_FLAG_LOWER ) BEGIN
                   for (i=0; i<sizeof(group); i++)
                       group[i] = tolower(group[i]);
                 END
                 */
                 break;
       /* WS10064   - start                                       */
       case 'H': action = ACT_PWPH_UPD;

                is_change_password_event = TRUE;

                ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                                 "Checking phrase Filter" );

                 if ( password_filter_flag EQ
                      PASSWORD_FILTER_ON  OR
                 /*   rc_msk_filter EQ 0 )          {     WS10064 */
                      rc_msk_filter EQ 0 OR             /*WS10064 */
                      phrsflag EQ FLAG_PHRASE_OFF) {    /*WS10064 */

                    ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
                                    "Ignoring passphrase event" );
                   CTSAMSG_print(MSG_ONLI_PSWD_EVENT_IGNORED,/*WS10072*/
                           msgs, NULL, dest, "phrase", user, /*WS10072*/
                           "ONLI_EVENT_PHRASE=N");           /*WS10072*/
                    rc = ESA_SKIP;
                    goto exit;
                 }

                 break;
       /* WS10064   - end                                         */

       default : CTSAMSG_print(ERR_INTERNAL,
                               rss_parm->msg_params->ctsamsg_handle,
                               NULL, rss_parm->msg_params->ctsamsg_dest,
                               comp,__FILE__,1,__LINE__);
                 action = ACT_UNKNOWN ;
                 break;
  }

  /*                                         WS10064
  if ( action NE ACT_PWD_UPD)                WS10064   /* dc2902 */
  if ( action NE ACT_PWD_UPD AND                       /* WS10064*/
       action NE ACT_PWPH_UPD)                         /* WS10064*/
     ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
         "Type=%c  action=%c  userid=%s group=%s rss_pfx=%s",
         evt->type, evt->action, user, group, rss_pfx );

  else                                                 /* dc2902 */
  {
     ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,         /* dc2902 */
         "Type=%c  action=%c  userid=%s rss_pfx=%s",   /* dc2902 */
         evt->type, evt->action, user, rss_pfx );      /* dc2902 */
     ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,100,       /*IS10008*/
         "group=%c", group);                           /*IS10008*/
  }

  /**************************************************************
  * WS2240                                                      *
  * if event is change password, verify the change with the RSS *
  **************************************************************/

/*if (is_change_password_event) {                    BS2663 */

  /* BS2663 - begin - don't execute verify_password for
              notification event with RSS type is TSS  */

  /************************ IS10018 *****************************
  * Move the verify_password for TSS to function                *
  * 'CTSCINT_TSS_event' (in CTSTINT) instead of here.           *
  *                                                             *
  * Fix bs2663 was wrong, as it skips only the first event which*
  * the usa-api of TSS issues with special indications of       *
  * TSS_CS_NOTIFY_PROG & TSS_CS_NOTIFY_TERM.                    *
  * However, the "regular" 2nd event, which is intercepted by   *
  * the Online Interceptor, passes through the usuall code and  *
  * ESS ChangePassword transaction is intercepted as a MF event.*
  * In addition, if VerifyPassword fails, messages are being    *
  * sent by Online Interceptor.                                 *
  **************************************************************/

/*IS10018 if (NOT ((memcmp( rss_parm->type, "TSS", 3) EQ 0) AND
      (strcmp(program,TSS_CS_NOTIFY_PROG) EQ 0)   AND
      (strcmp(terminal,TSS_CS_NOTIFY_TERM) EQ 0)))  {   /*end-BS2663*/

  if (NOT (memcmp( rss_parm->type, "TSS", 3) EQ 0)) /* IS10018 */
/*IS10018 end */
  {
/* BS2663 -     don't execute verify-password if RSS parameter
                ONLI_EVENT_USER equal N.       */

  if ((is_change_password_event) && (usrflag EQ FLAG_USERID_ON)) {
     ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
      "verifying the change password event with the RSS %s",
      rss_parm->name);
     /* IS10002 rc = verify_password(user, group, rss_parm); */
     /* WS10064   - start                                       */
     if (action EQ ACT_PWPH_UPD) {
        strcpy(passtype, "Phrase") ;
        rc = verify_password(user, pwphrase,rss_parm,admin_params);
     }
     else {
        strcpy(passtype, "Password") ;
     /* WS10064   - end                                         */
        rc = verify_password(user, group,rss_parm,admin_params);
                                                          /* IS10002*/
     }                                                    /* WS10064*/
     if (rc NE ESA_OK) {
        ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,
           "the password for user %s was not accepted",user );
        CTSAMSG_print(MSG_ONLI_USER_PASS_NOT_VERIFIED,
        /*            msgs, NULL, dest, user);               WS10064*/
                      msgs, NULL, dest, passtype, user);  /* WS10064*/
        CTSAMSG_print(MSG_ONLI_EVENT_IGNORED,
                      msgs, NULL, dest);
        goto exit;
     }
  }
  } /* not TSS */
  /* end of BS2663 */
  /* end of ws2240 */

  /* ws2557 part 1 start: Convert password to lower case after
                          password verification */
  if (evt->action == 'P') {
     if ( password_case_flag EQ PASSWORD_FLAG_LOWER ) {
        for (i=0; i<sizeof(group); i++)
           group[i] = tolower(group[i]);
     }
  }
  /* ws2557 part 1 end */

  /**************************************************************
  *    Call event handling routine base on the RSS_TYPE         *
  **************************************************************/

  /* Copy rss_type prefix from EVT to rss_param area */

  FIELD_BLOCK(rss_parm->rss_pfx, evt->rss_type_prefix)

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,         /* ws2372 */
        "o_program = %s   type =%c  user = %s conn flag = (%c)",
         evt->o_program,evt->type,user, evt->conn[0]); /* BS2618 */

  ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,2,      /*ws2431*/
        "RSS type (%s)",                         /*ws2431*/
         rss_parm->type);                        /*ws2431*/

/*IS0328 if ( memcmp( rss_parm->type, "RACF", 4) EQ 0) */

  if ( memcmp( rss_parm->type, "RACF", 4) EQ 0) {     /* IS0328 */
     rc = CTSCINT_RACF_event (evt->type, group, user, action ,
                              msg_flag, rss_parm, admin_params,
                              evt->o_program,      /* ws2372 */
                              evt);                /* IS10100 */
                                               /* ps0295 */
/************************** IS0328 **********************************
 * When SUPGROUP field is updated by AG,ALG or DG RACF commands,    *
 * we need to update the relevant SUBGROUP field in the relevant    *
 * parent/s group/s. For this purpose, we have added a new field    *
 * to the EVT called  EVTSUPG.                                      *
 * When a group's SUPGROUP is updated (AG or ALG), we write update  *
 * group event for the new parent group, so the CD will retrieve    *
 * its new SUBGROUP from RACF.                                      *
 * Unfortanetly, we only have the new group name in the SMF record. *
 * Therefore, in ADDGROUP and ALTGROUP commands, we update the new  *
 * parent group's SUBGROUP field.                                   *
 * However, in ALTGROUP and DELGROUP commands, we do NOT update old *
 * parent group's SUBGROUP field.                                   *
 ************************** IS0328 **********************************/
     if (strcmp(supgroup,"") NE 0)
     {
         ESA_DIAG_printf(ESA_COMP_RSS_INTERCEPT,10,
                         "write event for SUPGROUP %s",
                         supgroup);

         if (evt->type EQ 'G')
             switch  (action)
             {
                case ACT_ADD :
                case ACT_UPDATE :
                      rc = CTSCINT_RACF_event (evt->type,
                                               supgroup,
                                               user,
                                               ACT_UPDATE,
                                               msg_flag,
                                               rss_parm,
                                               admin_params,
                                               evt->o_program,
                               /* IS10100 */   evt);
                break ;
             }
     }
  }
  /* IS0328 end */

  else if ( memcmp( rss_parm->type, "TSS", 3) EQ 0)
     rc = CTSCINT_TSS_event (evt->type, group, user, action,
                             evt->date, evt->time, admin, terminal,
                             msg_flag, rss_parm, admin_params,
                             evt->conn[0]);      /* bs2618 */
                                                 /* ps0295 */

  else if ( memcmp( rss_parm->type, "ACF2", 4) EQ 0)
     rc = CTSCINT_ACF2_event (evt->type, group, user, action,
                              msg_flag, rss_parm, admin_params,
                              evt->conn, evt->old_uid_string,
                              evt->pswd_vio,     /*ws2451  */
 /*pass res_type & res_name*/ evt->res_type, evt->res_name); /*WS10067*/
  else
     rc = CTSCINT_write_event (evt->type, group, user, action,
     /* WS10064                msg_flag, rss_parm, admin_params); */
                                                  /* ps0295 */
     /* WS10064           */   msg_flag, rss_parm, admin_params,
     /* WS10064           */   pwphrase) ;

  /**************************************************************
  *   Finish                                                    *
  **************************************************************/

  exit:

  ESA_DIAG_exit(ESA_COMP_RSS_INTERCEPT,1, func, rc );

  return rc;

}    /* evnt2rs */
