/**************************************************************
*                                                             *
*  <!><!> ATTENTION <!><!>                                    *
*  =-=-=-=-=-=-=-=-=-=-=-=                                    *
*                                                             *
*  When updating this member, do not forget to update         *
*  CTSOQUE in ALL.CSRC as well.                               *
*                                                             *
*                                                             *
**************************************************************/
/**************************************************************
*                                                             *
* Title            : Control-SA Queue OS functions            *
*                                                             *
* File Name        : ctscque.c                                *
*                                                             *
* Author           : Moshe Meiseles                           *
*                    Alex  Shvartsman                         *
*                                                             *
* Creation Date    : 26.07.94                                 *
*                                                             *
* Description      : Queue package for Control-SA             *
*                                                             *
* Assumptions and                                             *
*   Considerations : None.                                    *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who     When      Description                      *
* -------  ------  --------  -------------------------------- *
* a1911    Alex    19/11/95  Add debug's print                *
* ps0406   Alex    04/10/00  Adjustments to compiler 6.50     *
* bs2626   AvnerL  25/11/03  Return original rc.              *
* SAS2IBMT SeligT  12/07/16  SAS/C to IBM C Conversion Project*
* SAS2IBMN NuritY  25/01/17  SAS/c to ibm c conversion:       *
*                            - Identify file full.            *
*                            - Corret the error formatting.   *
*                            - Remove unused variables.       *
*                            - fflush() after fread does not  *
*                              flush the buffer. Bypass by    *
*                              reading another block.         *
**************************************************************/

/**********************************************************************
* SAS2IBMT: All of the osdcb, osopen, osclose, osget, osput, and      *
*          osflush SAS/C functions were changed to fopen, fclose,     *
*          fread, fwrite, fseek, ftell, and fflush IBM C functions.   *
*          Also, we are now in 'byteseek' mode so all I/O and posi-   *
*          tioning are done using relative byte offsets. This means   *
*          that all reading, writing, seeking, and telling are done   *
*          with byte offsets.  Records and blocks are not used and    *
*          the get_ttr, get_block_pos, and ctsattr routines are no    *
*          longer called. 'Byteseek' mode means that the queue file   *
*          is being treated as 1 long binary stream - not several     *
*          blocks or records.  We read and write n bytes each time    *
*          where the os_handle->position field is pointing to. Thus,  *
*          the local_buffer_pos field is no longer used because we    *
*          will no longer be filling/writing blocks. However, as I    *
*          wrote, the os_handle->position field is critical.  It      *
*          tells us the next position to read/write.                  *
*                                                                     *
* Notes / Reminders:  1) After every logical block written to the     *
*                        queue, we must do a flush (or a close).      *
*                        This is exactly what ESAQUE does now but     *
*                        we should leave this comment here so we      *
*                        should remember this for the future.         *
*                     2) - An fread will always be issued after an    *
*                          fseek or after a previous fread.           *
*                        - An fwrite will always be issued after an   *
*                          fseek or after an fopen.                   *
*                        - An fseek must always be issued after the   *
*                          OS_FILE_flush call because (for some       *
*                          reason) the os_handle->position field is   *
*                          set to 0.                                  *
**********************************************************************/
/* #pragma options copts(bitfield(1))                        SAS2IBMT */

#include   "globs.h"

/*
 *   Standard include files
 */

 /* #include   OSIO                                          SAS2IBMT */
 /* #include   OS                                            SAS2IBMT */
 /* #include   LCLIB                                         SAS2IBMT */
#include   CTYPE
#include   ERRNO
#include   FCNTL
#include   STDARG
#include   STDIO
#include   STDLIB
#include   STRING
#include   TIME

/*
 *   CONTROL-SA include files
 */

#include   ESA_API
#include   ESA_CTSAMSG
#include   ESA_DIAG
#include   ESA_QUEUE
#include   ESA_QUEUE_OS
#include   ESA_CS_OS
#include   ESA_API_CODES

#include   MVS_CODES

#include   RACF_CODES

/* SAS2IBMN
static const char sccsid [] = "@(#)esaqos.c 1.2 4D 94/08/10-15:02:25";*/
static const char component[]="OSQUE";

/**************************************************************
*                                                             *
*   typedef's  , #defines                                     *
*                                                             *
**************************************************************/

#define    MAX_LONG       2147483647 /* see SAS/C 3-d edition     */
                                     /* Compiler and library      */
                                     /* Users's Guide . p.20      */
#define QUE_EYECATCHER    "QUE "
/* We need these 2 #defines for IBM C                        SAS2IBMT */
#define QUE_READWRITE_BS  "r+b,abend=recover,byteseek,recfm=*"
#define QUE_WRITE_BS      "wb,abend=recover,byteseek,recfm=*"

typedef struct {
   char       eyecatcher[4];         /*  eyecatcher 'QUE'         */
   /* SAS2IBMT DCB_t   * fh;         // File   DCB                */
   FILE     * QUE;                   /* File stream handle SAS2IBMT*/
   long int   position ;             /* current file position     */
   int        blksize;               /* blksize                   */
   /* SAS2IBMT
   void     * io_buffer;             // I/O buffer from BSAM      //
   int        block_per_track;       // block-per-track           //
   char     * local_buffer;          // ptr to local I/O buffer   //
   int        local_buffer_pos;      // pos in local buffer       //
   short      seek_flag;                                          */
   } OS_FILE_HANDLE_typ;

/* SAS2IBMT These 2 #defines are no longer necessary
#define BUFNO              "BUFNO=1,NCP=1"
#define RECFM_F            0x80                                      */


/* SAS2IBMT No DCB ABEND exit processing in IBM C
struct abend_info { // Register 1 to DCB ABEND exit //
    unsigned abend_code:    12 ;
    unsigned :4;
    unsigned char return_code;
    union {
       struct {
           unsigned  :4;
           unsigned  recover: 1 ;
           unsigned  ignore:  1 ;
           unsigned  delay :  1 ;
           unsigned  :1;
               } ok_to;
       char action;
 } ;

 DCB_t *dcbp;
 void  *O_C_EOV_workarea;
 void  *recovery_work_area;
 } ;

// PS0406. Compiler 6.00 prototype
 * static int abend_exit(struct abend_info     *reg1,
 *                       void                  *reg0);
 //

// PS0406. Compiler 6.50 prototype //
   static int abend_exit(void                  *reg1,
                         void                  *reg0);               */

/*
 *   Assembler routine calculate block-per-track value
 *   for TTR calculations
 */

/* SAS2IBMT These routines are no longer in use
extern ESA_RC ctsattr(int    *debug,        // input debug level  //
                      DCB_t  *dcb,          // input addr dcb     //
                      int    *bptrk);       // outp  block-per-trk//


static void get_block_pos(long int         position,
                          int              blksize,
                          int             *block,
                          int             *pos) ;


static void get_ttr(int          block,
                    int          block_per_track,
                    ospos_t      *position) ;                        */

/* SAS2IBMT - start */
static void print_amrc(CTSAMSG_PARAMS_rec_typ * msg_params);
/* SAS2IBMT - end   */

/* SAS2IBMN - start */

/* Macro to read and check rc - used by OS_FILE_read and
   OS_FILE_flush because of the need to fake flush.                  */
#define FREAD(file, buff, size, rdrc, rc)                             \
(rdrc) = fread( (buff), 1, (size), (file) );           /* SAS2IBMT */ \
                                                                      \
if ( (rdrc) LT (size) )                                /* SAS2IBMT */ \
{                                                                     \
 print_amrc(msg_params);                               /* SAS2IBMT */ \
 ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                   /* SAS2IBMT */ \
                  "fread() failed rc=%d prog=%s line=%d",             \
                  (rdrc), __FILE__, __LINE__);                        \
 CTSAMSG_print(QUEUE_IOERR,                            /* SAS2IBMT */ \
               msg_params->ctsamsg_handle, NULL,                      \
               msg_params->ctsamsg_dest, "FREAD", (rdrc));            \
 CTSAMSG_print(QUEUE_IOERR_DETAIL,                     /* SAS2IBMT */ \
               msg_params->ctsamsg_handle, NULL,                      \
               msg_params->ctsamsg_dest, func, __LINE__ );            \
 if (feof( (file) ) )                                  /* SAS2IBMT */ \
  {                                                                   \
   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"EOF in QUEUE."); /* SAS2IBMT */ \
   (rc) = ESA_EOF;                                     /* SAS2IBMT */ \
  }                                                                   \
 else                                                  /* SAS2IBMT */ \
   if (ferror( (file) ) )                              /* SAS2IBMT */ \
     (rc) = ESA_FATAL;                                 /* SAS2IBMT */ \
}                                                                     \
else                                                   /* SAS2IBMN */ \
  (rc) = ESA_OK;                                       /* SAS2IBMN */


/* Macro to do seek and check rc - used by OS_FILE_seek and
   OS_FILE_flush because of the need to fake flush.                  */
#define FSEEK(file, start, offset, skrc, rc)                          \
(skrc) = fseek( (file), (offset), (start) );           /* SAS2IBMT */ \
if ((skrc) NE 0)                                                      \
{                                                                     \
 print_amrc(msg_params);                               /* SAS2IBMT */ \
 ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                                  \
                  "fseek() failed rc=%d prog=%s line=%d",             \
                  (skrc), __FILE__, __LINE__);                        \
 CTSAMSG_print(QUEUE_IOERR,                                           \
               msg_params->ctsamsg_handle, NULL,                      \
               msg_params->ctsamsg_dest, "FSEEK",(skrc));             \
 CTSAMSG_print(QUEUE_IOERR_DETAIL,                                    \
               msg_params->ctsamsg_handle, NULL,                      \
               msg_params->ctsamsg_dest, func, __LINE__ );            \
 (rc) = ESA_FATAL;                                                    \
}                                                                     \
else                                                                  \
  (rc) = ESA_OK;

/* SAS2IBMN - end   */

/****************************************************
* Procedure Name: OS_FILE_format
* Description   : Format Queue file according to
*                 allocated space and size parameter
*
* Input         : none
*
* Output        : none
*
* Return Value  : size of file
*
****************************************************/

ESA_RC OS_FILE_format (char                   * filename,
                       long                   * q_size,
                       CTSAMSG_PARAMS_rec_typ * msg_params)
{

   /*
    *    Variables
    */

   long                 size = 0 ;
   /* SAS2IBMT DCB_t  * fh;                                          */
   FILE               * QUE_local;     /* File stream handle SAS2IBMT */
   /* SAS2IBMT exit_t   abend_exlst[1]={ LAST | ABEND , &abend_exit };*/
   int                  blksize = 0;
   char               * local_buffer=NULL;
   char                 lcl_filename[44];
   fldata_t             info;
   ESA_RC               rc = ESA_OK;
   int                  osrc;
   int                  block_count = 0;
   int                  file_full;
   static char          func[]="OS_FILE_format";

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

   /***** create DCB ****/

   /* SAS2IBMT The following is not needed in IBM C.
   fh = osdcb(filename,BUFNO,abend_exlst,0);

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "DCB ptr=%x", fh );

   fh->DCBMACR1 |= DCBMRPT1;       // set bits for possibility //
   fh->DCBMACR2 |= DCBMRPT2;          use ostell               */

   /***** open file *****/

   /* SAS2IBMT The following was changed from osopen to fopen.
   if ( osopen(fh,"output",0)  )  {                                  */

   strcpy(lcl_filename,"dd:");                            /* SAS2IBMT */
   strcat(lcl_filename,filename);                         /* SAS2IBMT */
   QUE_local = fopen(lcl_filename,QUE_WRITE_BS);          /* SAS2IBMT */
   if (QUE_local EQ NULL)                                 /* SAS2IBMT */
   {
      print_amrc(msg_params);                             /* SAS2IBMT */
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "fopen()  failed prog=%s line=%d",
                        __FILE__, __LINE__);
      CTSAMSG_print(QUEUE_IOERR,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, "FOPEN",16);
      CTSAMSG_print(QUEUE_IOERR_DETAIL,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, func, __LINE__ );

      /* SAS2IBMT osclose(fh,"");                                    */
      /* SAS2IBMN - no need for close because the file is NULL
      if (fclose(QUE_local)) print_amrc(msg_params);      * SAS2IBMT *
      */
      rc = ESA_FATAL;
      goto exit;
   }

   /* SAS2IBMT We are using the fldata function instead
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "fopen successfull recfm=%x",
                     fh->DCBRECFM );                                 */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "fopen successful");                  /* SAS2IBMT */

   /* SAS2IBMT We are using the fldata function instead
   if (fh->DCBRECFM NE RECFM_F) { // Only RECFM=F is support         */

   osrc = fldata(QUE_local, lcl_filename, &info);         /* SAS2IBMT */
   if (osrc NE 0)                                         /* SAS2IBMT */
   {
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                 /* SAS2IBMT */
                       "fldata() failed prog=%s line=%d",
                        __FILE__, __LINE__);
      CTSAMSG_print(QUEUE_IOERR,                          /* SAS2IBMT */
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, "FLDATA",16);
      CTSAMSG_print(QUEUE_IOERR_DETAIL,                   /* SAS2IBMT */
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, func, __LINE__ );
      /* SAS2IBMT osclose(fh,"");                                    */
      /* SAS2IBMN - will be closed before return
      if (fclose(QUE_local)) print_amrc(msg_params);       * SAS2IBMT *
      */
      rc = ESA_FATAL ;                                    /* SAS2IBMT */
      goto exit ;                                         /* SAS2IBMT */
   }

   if ((osrc EQ 0) AND ( NOT (info.__recfmF)))           /* SAS2IBMT */
   {
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "Invalid RECFM prog=%s line=%d",
                        __FILE__, __LINE__);
      if (info.__recfmV)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=V");
      if (info.__recfmU)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=U");
      if (info.__recfmS)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=S");
      if (info.__recfmBlk)                                /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=Blk");
      if (info.__recfmASA)                                /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=ASA");
      if (info.__recfmM)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=M");
      CTSAMSG_print(QUEUE_INVALID_RECFM,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest);
      /* SAS2IBMT osclose(fh,"");                                    */
      /* SAS2IBMN - will be closed before return
      if (fclose(QUE_local)) print_amrc(msg_params);       * SAS2IBMT *
      */
      rc = ESA_FATAL ;
      goto exit ;
   }
   /* SAS2IBMT We are using the fldata function results instead
   blksize = fh->DCBBLKSI;

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "recfm=%x blksize=%d",
                     fh->DCBRECFM, fh->DCBBLKSI);                    */
   blksize = info.__blksize;                              /* SAS2IBMT */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "maxreclen=%d blksize=%d",            /* SAS2IBMT */
                     info.__maxreclen, blksize);          /* SAS2IBMT */
   if (info.__recfmF)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=F");
   if (info.__recfmV)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=V");
   if (info.__recfmU)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=U");
   if (info.__recfmS)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=S");
   if (info.__recfmBlk) ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=Blk");
   if (info.__recfmASA) ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=ASA");
   if (info.__recfmM)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=M");



   /********* Create local buffer *************/

   local_buffer = (char *)malloc(blksize);
   if ( local_buffer EQ NULL )
   {
      CTSAMSG_print(ERR_MALLOC,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, func,  blksize);
      rc = ESA_FATAL;
      goto exit;
   }
   memset(local_buffer,'0',blksize-1);
   strcpy(local_buffer,"dummy queue item");

   /*********** Format QUEUE file *************/

   osrc = 0;
   file_full = 0;
   /* SAS2IBMN - start  */
   /* while ((osrc EQ 0) AND ((*q_size LT 0) OR (size LT *q_size)) ) */
   while ( NOT(file_full) AND ((*q_size LT 0) OR (size LT *q_size)) )
   /* SAS2IBMN - end    */
   {
      /* SAS2IBMT We used the fldata function above
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "dcb=%x recfm=%x blksize=%d/%d",
                        fh, fh->DCBRECFM, fh->DCBBLKSI, blksize);    */

      /* SAS2IBMT The following was changed from osput to fwrite.
      osrc = osput(fh, local_buffer, blksize);                       */
      osrc = fwrite(local_buffer, 1, blksize, QUE_local); /* SAS2IBMT */
      if (osrc LT blksize)                                /* SAS2IBMT */
      {

        /* SAS2IBMN - if abend x37, we reached end of file            */
        if (errno EQ 92 AND                               /* SAS2IBMN */
            (__amrc->__code.__abend.__syscode EQ 0X0B37  OR
             __amrc->__code.__abend.__syscode EQ 0X0D37  OR
             __amrc->__code.__abend.__syscode EQ 0X0E37) )
          file_full = 1;                                  /* SAS2IBMN */
        else                 /* Write error               /* SAS2IBMN */
        {
          print_amrc(msg_params);                         /* SAS2IBMT */
          ESA_DIAG_printf (ESA_COMP_QUEUE, 4,             /* SAS2IBMT */
                           "fwrite() failed rc=%d prog=%s line=%d",
                           osrc, __FILE__, __LINE__);
          CTSAMSG_print(QUEUE_IOERR,                      /* SAS2IBMT */
                        msg_params->ctsamsg_handle, NULL,
                        msg_params->ctsamsg_dest, "FWRITE",osrc);
          CTSAMSG_print(QUEUE_IOERR_DETAIL,               /* SAS2IBMT */
                        msg_params->ctsamsg_handle, NULL,
                        msg_params->ctsamsg_dest, func, __LINE__ );
          /* SAS2IBMT osclose(fh,"");                                  */
          /* SAS2IBMN - will be closed before return
          if (fclose(QUE_local)) print_amrc(msg_params);   * SAS2IBMT *
          */
          ESA_DIAG_printf (ESA_COMP_QUEUE, 4,             /* SAS2IBMT */
                           "fwrite osrc=%d", osrc);       /* SAS2IBMT */
          rc = ESA_FATAL;                                 /* SAS2IBNM */
          break;                /* error - leave the loop    SAS2IBMN */
        }
      }
      else
      {
         block_count++;
         if ( (MAX_LONG-size) LT blksize ) { /* verify no int overflow*/
            CTSAMSG_print(ERR_INTERNAL2,
                          msg_params->ctsamsg_handle, NULL,
                          msg_params->ctsamsg_dest, component, func,
                          "QUEUE overflow", block_count, __LINE__ );
            /* SAS2IBMN osrc=16 ;                                   */
            break;    /* The file is not full, but can be used.      */
         }
         size += blksize;
         ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                          "Num blocks=%d  Total size=%d",
                          block_count, size);
      }    /* fwrite success */
      /* SAS2IBMN  - not needed anu more as we do not have an
                     abend exit and we handle it here.
      if ( file_full NE 0 )
         osrc=16;     * file is full *
      */
      /* SAS2IBMT We are doing this above
      if ( osrc NE 0 )
         osclose(fh,"");                                           */
   } /* while */

   /* SAS2IBMN - this is done at exit (below)
   free(local_buffer);
   */

  exit :;

   /* SAS2IBMN - start */
   if (local_buffer NE NULL)       /* Free buffer, if allocated    */
     free(local_buffer);

   if (QUE_local NE NULL)
     if (fclose(QUE_local))        /* close file, if open          */
       print_amrc(msg_params);
   /* SAS2IBMN - end   */

   *q_size = size;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc);
   return rc;

}

/* SAS2IBMT No DCB ABEND exit processing in IBM C
/****************************************************
* Procedure Name: abend_exit
* Description   : Treatment abend code during format QUEUE file
*
* Input         : none
*
* Output        : none
*
* Return Value  : none
*
****************************************************/

/* PS0406. Compiler 6.00 prototype
 * static int abend_exit(struct abend_info     *reg1,
 *                       void                  *reg0)
 */

/* PS0406. Compiler 6.50 prototype //
   static int abend_exit(void                  *reg1_650,
                         void                  *reg0)
{
  struct abend_info  *reg1;   // ps0406 //
  static char func[]="abend_exit";

  ESA_DIAG_enter  (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

  reg1 = (struct abend_info *)reg1_650;   // ps0406 //

  ESA_DIAG_printf (ESA_COMP_QUEUE, 1,
                   "Abend code=%X", reg1->abend_code);

  if ( ( (reg1->abend_code EQ 0xb37) OR (reg1->abend_code EQ 0xd37) OR
         (reg1->abend_code EQ 0xe37)    )  AND
       (reg1->ok_to.ignore) ) {
       file_full=1;
       reg1->action = 4; // Tell BSAM to ignore ABEND   //
  }
  else reg1->action = 0 ;    // Let any other ABEND proceed //

  ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, ESA_OK);

  return 0;

}                                                                    */

/****************************************************
* Procedure Name: OS_FILE_open
* Description   : Open a file
*
* Input         : file name
*                 open mode (same as for fopen)
*
* Output        : pointer to handle
*
* Return Value  : ESA_OK     upon success
*                 ESA_FATAL  on any fail situation
*
* Note (!!!)    : The file should be opened in such a way that the
*                 sequence read+seek+read-again will access the file.
*                 This implies the use of: setbuf( NULL )
*
****************************************************/

ESA_RC OS_FILE_open (const char             * filename,
                     const char             * mode,
                     void                  ** handle,
                     CTSAMSG_PARAMS_rec_typ * msg_params)
{
   /* SAS2IBMT DCB_t      * fh;                                      */
   FILE                   * QUE_local; /* File stream handle SAS2IBMT */
   OS_FILE_HANDLE_typ     * os_handle;
   ESA_RC                   rc = ESA_OK;
   char                     lcl_filename[44];
   fldata_t                 info;                       /* SAS2IBMT */
   int                      osrc = 0;
   int                      debug_level;
   static char              func[]="OS_FILE_open";

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

   /***** create DCB ****/

   /* SAS2IBMT The following is not needed in IBM C.
   fh = osdcb(filename,BUFNO,0,0);
   fh->DCBMACR1 |= DCBMRPT1;       // set bits for possibility //
   fh->DCBMACR2 |= DCBMRPT2;       // use ostell               */

   /***** open file *****/

   /* SAS2IBMT The following was changed from osopen to fopen.
   if ( osopen(fh,"updat",0)  )  {                                   */

   strcpy(lcl_filename,"dd:");                            /* SAS2IBMT */
   strcat(lcl_filename,filename);                         /* SAS2IBMT */
   QUE_local = fopen(lcl_filename,QUE_READWRITE_BS);      /* SAS2IBMT */
   if (QUE_local EQ NULL)                                 /* SAS2IBMT */
    {
      print_amrc(msg_params);                             /* SAS2IBMT */
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "fopen()  failed prog=%s line=%d",
                        __FILE__, __LINE__);
      CTSAMSG_print(QUEUE_IOERR,
                  msg_params->ctsamsg_handle, NULL,
                  msg_params->ctsamsg_dest, "FOPEN", 16);
      CTSAMSG_print(QUEUE_IOERR_DETAIL,
                  msg_params->ctsamsg_handle, NULL,
                  msg_params->ctsamsg_dest, func, __LINE__ );
      /* SAS2IBMT osclose(fh,"");                                  */
      /* SAS2IBMN - no need for close because the file is NULL
      if (fclose(QUE_local)) print_amrc(msg_params);     * SAS2IBMT *
      */
      rc = ESA_FATAL;
      goto exit;
   }

   /* SAS2IBMT We are using the fldata function instead
   if (  fh->DCBRECFM  NE RECFM_F ) { // Only RECFM=F is support*/

   osrc = fldata(QUE_local, lcl_filename, &info);         /* SAS2IBMT */
   if (osrc NE 0)                                         /* SAS2IBMT */
   {
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                 /* SAS2IBMT */
                       "fldata() failed prog=%s line=%d",
                        __FILE__, __LINE__);
      CTSAMSG_print(QUEUE_IOERR,                          /* SAS2IBMT */
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, "FLDATA",16);
      CTSAMSG_print(QUEUE_IOERR_DETAIL,                   /* SAS2IBMT */
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, func, __LINE__ );
      /* SAS2IBMT osclose(fh,"");                                    */
      if (fclose(QUE_local)) print_amrc(msg_params);      /* SAS2IBMT */
      rc = ESA_FATAL ;                                    /* SAS2IBMT */
      goto exit ;                                         /* SAS2IBMT */
   }
   if ((osrc EQ 0) AND ( NOT (info.__recfmF)))            /* SAS2IBMT */
   {
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "Invalid RECFM prog=%s line=%d",
                        __FILE__, __LINE__);
      if (info.__recfmV)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=V");
      if (info.__recfmU)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=U");
      if (info.__recfmS)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=S");
      if (info.__recfmBlk)                                /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=Blk");
      if (info.__recfmASA)                                /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=ASA");
      if (info.__recfmM)                                  /* SAS2IBMT */
                 ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=M");
      CTSAMSG_print(QUEUE_INVALID_RECFM,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest);
      /* SAS2IBMT osclose(fh,"");                                    */
      if (fclose(QUE_local)) print_amrc(msg_params);      /* SAS2IBMT */
      rc = ESA_FATAL ;
      goto exit ;
   }

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "after osopen. file: %s fh: %#x",
                    filename, fh);                                   */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "after fopen. file: %s",
                    lcl_filename);                        /* SAS2IBMT */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                    /* SAS2IBMT */
                    "maxreclen=%d blksize=%d",            /* SAS2IBMT */
                     info.__maxreclen, info.__blksize);   /* SAS2IBMT */
   if (info.__recfmF)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=F");
   if (info.__recfmV)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=V");
   if (info.__recfmU)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=U");
   if (info.__recfmS)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=S");
   if (info.__recfmBlk) ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=Blk");
   if (info.__recfmASA) ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=ASA");
   if (info.__recfmM)   ESA_DIAG_printf (ESA_COMP_QUEUE,4,"recfm=M");

   /***** allocate handle *****/

   os_handle = malloc(sizeof(OS_FILE_HANDLE_typ));

   if ( os_handle EQ NULL ) {                             /* SAS2IBMT */
       ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                /* SAS2IBMT */
                        "malloc() failed prog=%s line=%d",
                        __FILE__, __LINE__);
       CTSAMSG_print(ERR_MALLOC,                          /* SAS2IBMT */
                     msg_params->ctsamsg_handle, NULL,
                     msg_params->ctsamsg_dest, func,
                     sizeof(OS_FILE_HANDLE_typ));
       rc=ESA_FATAL;                                      /* SAS2IBMT */
       goto exit;                                         /* SAS2IBMT */
    }

   memcpy(os_handle->eyecatcher,QUE_EYECATCHER, 4 );
   /* SAS2IBMT
   os_handle->fh          = fh;        // addr DCB           //
   os_handle->blksize     = fh->DCBBLKSI;  // BLKSIZE        */
   os_handle->QUE         = QUE_local; /* File stream handle SAS2IBMT */
   os_handle->blksize     = info.__blksize; /* BLKSIZE       SAS2IBMT */
   os_handle->position    = 0   ;      /* curr file position */
   /* SAS2IBMT
   os_handle->local_buffer=NULL;       // addr Local buffer  //
   os_handle->local_buffer_pos=0;      // pos in local buffer//
   os_handle->seek_flag=1;             // Need read block 0  //

   ////// allocate local buffer ///////

   os_handle->local_buffer = (char *)malloc(os_handle->blksize);

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                   "main handle ptr=%x local_buffer ptr=%x",
                   os_handle, os_handle->local_buffer);              */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                   "main handle ptr=%x", os_handle);      /* SAS2IBMT */

  /*
   *    Check if allocate local buffer is successfull
   */

   /* SAS2IBMT
   if ( os_handle->local_buffer EQ NULL ) {
       ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                        "malloc() failed prog=%s line=%d",
                        __FILE__, __LINE__);
       CTSAMSG_print(ERR_MALLOC,
                  msg_params->ctsamsg_handle, NULL,
                  msg_params->ctsamsg_dest, func,  os_handle->blksize);
       free(os_handle);
       rc=ESA_FATAL;
       goto exit;
    }                                                                */

  /*
   *   Definition debug level for assembler module
   */

   debug_level = ESA_DIAG_get_debug_level(ESA_COMP_QUEUE);

  /*
   *    Get block-per-track value
   */

   /* SAS2IBMT This calculation and this routine is no longer needed.
   osrc=ctsattr(&debug_level,os_handle->fh,
                &(os_handle->block_per_track));
   if ( osrc NE 0 ) {
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "ctsattr() failed rc=%d prog=%s line=%d",
                       rc, __FILE__, __LINE__);
      CTSAMSG_print(QUEUE_IOERR,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest,
                    "blk/trk info", 16);
      CTSAMSG_print(QUEUE_IOERR_DETAIL,
                     msg_params->ctsamsg_handle, NULL,
                     msg_params->ctsamsg_dest, func, __LINE__ );
      free(os_handle->local_buffer);
      free(os_handle);
      rc=ESA_FATAL;
      goto exit;
   }                                                                 */

   *handle = os_handle;          /* store handle addr */

   /* SAS2IBMT This is no longer needed/used or it is printed above
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "after open. fh: %#x ", os_handle->fh);

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "blksize=%d block-per-track=%d",
                    os_handle->blksize, os_handle->block_per_track); */

   exit:;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc );
   return rc;

}

/****************************************************
* Procedure Name: OS_FILE_close
* Description   : Close a file
*
* Input         : handle
*
* Output        : pointer to handle is cleared
*                 (this function should free the handle)
*
* Return Value  : ESA_OK     upon success
*                 ESA_FATAL  on any fail situation
*
****************************************************/


ESA_RC OS_FILE_close (void                  ** handle,
                      CTSAMSG_PARAMS_rec_typ * msg_params)
{

   ESA_RC                    rc = ESA_OK;
   int                       osrc;
   OS_FILE_HANDLE_typ      * os_handle = *handle;
   static char               func[]="OS_FILE_close";

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func );

   if (os_handle EQ NULL) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, component, func,
                    "Invalid handle", 16, __LINE__);
      rc=ESA_FATAL;
      goto exit;
   }

  /*
   *   Eye catcher checking
   */

   if ( memcmp(os_handle->eyecatcher, QUE_EYECATCHER, 4) NE 0) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, component, func,
                    "Invalid handle", 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   }

   /***** close file *****/

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "before osclose. fh: %#x",
                    os_handle->fh);                                  */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "before fclose");  /* SAS2IBMT */

   /* SAS2IBMT The following was changed from osclose to fclose.
   if (os_handle->fh NE NULL) {
      osrc = osclose (os_handle->fh, "");
      if (osrc) {                                                    */
   if (os_handle->QUE NE NULL)                            /* SAS2IBMT */
   {
      osrc = fclose(os_handle->QUE);                      /* SAS2IBMN */
      if (osrc NE 0)                                      /* SAS2IBMN */
      {
        print_amrc(msg_params);                           /* SAS2IBMT */
        ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                         "fclose() failed prog=%s line=%d",
                         __FILE__, __LINE__);
        CTSAMSG_print(QUEUE_IOERR,
                      msg_params->ctsamsg_handle, NULL,
                      msg_params->ctsamsg_dest, "FCLOSE", 16);
        CTSAMSG_print(QUEUE_IOERR_DETAIL,
                      msg_params->ctsamsg_handle, NULL,
                      msg_params->ctsamsg_dest, func, __LINE__ );
        rc = ESA_FATAL;
      }
   }

   /***** free handle *****/

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "main handle ptr=%x local_buffer ptr=%x",
                    os_handle, os_handle->local_buffer);

   free(os_handle->local_buffer);   // free local buffer */

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                    /* SAS2IBMT */
                    "about to free main handle ptr=%x", os_handle);
   free( os_handle );               /* free os I/O handle*/
   *handle = NULL;

   exit:;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc );
   return rc;
}

/****************************************************
* Procedure Name: OS_FILE_write
* Description   : Write data to file.
*
* Input         : data buffer
*                 buffer size
*                 handle
*
* Output        : none
*
* Return Value  : ESA_OK     upon success
*                 ESA_FATAL  on any fail situation
*
****************************************************/

ESA_RC OS_FILE_write (const void            * buff,
                     size_t                   size,
                     void                   * handle,
                     CTSAMSG_PARAMS_rec_typ * msg_params)
{

   ESA_RC           rc = ESA_OK ;
   int              osrc = 0;
   /* SAS2IBMT These variables are not needed
   int              pos ;
   int              len;
   int              rem;                                             */
   char             *buf =(char *) buff;
   /* SAS2IBMN size_t           requested_size;                      */
   static char      func[]="OS_FILE_write";

   OS_FILE_HANDLE_typ *os_handle = handle;

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func );

  /*
   *   Eye catcher checking
   */

   if ( memcmp(os_handle->eyecatcher, QUE_EYECATCHER, 4) NE 0) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, component, func,
                    "Invalid handle", 16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
   }

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "before osput. fh: %#x len: %d buff_position=%d ",
                    os_handle->fh, size,
                    os_handle->local_buffer_pos);                    */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                    /* SAS2IBMT */
                    "before fwrite. len=%d ", size);

   /* SAS2IBMT
   pos            = os_handle->local_buffer_pos;
   rem            = size ;                                           */
   /* SAS2IBMN requested_size = size ;                               */

  /*
   *    Need read current block  because was issued osseek
   *    or current block is full
   */

   /* SAS2IBMT We are in 'byteseek' mode so this code is not needed.
              We will always be called after an fseek or after an
              fopen. An fread will never be needed.
   if ( (os_handle->seek_flag)              OR
        ((os_handle->blksize - pos) EQ 0) ) {
      os_handle->seek_flag = 0;
      osrc = osget(os_handle->fh, &(os_handle->io_buffer), &len );
      if ( osrc NE 0 )  {
         ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                          "osget() failed rc=%d prog=%s line=%d",
                          osrc, __FILE__, __LINE__);
         CTSAMSG_print(QUEUE_IOERR,
                       msg_params->ctsamsg_handle, NULL,
                       msg_params->ctsamsg_dest, "GET",osrc);
         CTSAMSG_print(QUEUE_IOERR_DETAIL,
                       msg_params->ctsamsg_handle, NULL,
                       msg_params->ctsamsg_dest, func, __LINE__ );
         // bs2626 starts //
         if (osrc EQ -1)
           {
             ESA_DIAG_printf (ESA_COMP_QUEUE, 4,"EOF in QUEUE.");
             rc = ESA_EOF;
           }
         else rc = ESA_FATAL;
         // bs2626 ends //
         goto exit;
      }

     //
      *    osget was finished successfull. Move reading block
      *    to local buffer for filling.
      *    If osget was done because current block is full ->
      *    current local buffer position = 0
      //

      else  {
         memcpy(os_handle->local_buffer, os_handle->io_buffer,
                os_handle->blksize);
         if ( ( os_handle->blksize - pos ) EQ 0 )  {
            pos = 0 ;
            os_handle->local_buffer_pos = 0;
         }
      }
   }                                                                 */

  /*
   *     Main loop : put information
   */

   /* SAS2IBMT We are in 'byteseek' mode so this code is not needed.
              We will always have enough room in the file to write
              the record (unless we are in wrap mode - which is
              dealt with by the caller, ESAQUE).
   do {


     ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                      "Write request: position=%d size=%d", pos, size );

     //
      *   In current reading and moving in local buffer block
      *   enough place.
      //

      if ( os_handle->blksize - pos  GE size ) {

          //
           *   Move information from buffer to local buffer.
           *   Increase in 'size' byte  :local buffer position
           //

           ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                            "Move to i/o buffer pos=%d size=%d",
                            pos, size );

           memcpy( os_handle->local_buffer + pos ,buf,size);
           os_handle->local_buffer_pos+= size;
           size=0;

           ////////// Put current block ///////////

           osrc=osput(os_handle->fh,os_handle->local_buffer,
                      os_handle->blksize);
           if ( osrc NE 0 ) {
              ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                               "osput() failed rc=%d prog=%s line=%d",
                               osrc, __FILE__, __LINE__);
              CTSAMSG_print(QUEUE_IOERR,
                            msg_params->ctsamsg_handle, NULL,
                            msg_params->ctsamsg_dest, "PUT",osrc);
              CTSAMSG_print(QUEUE_IOERR_DETAIL,
                          msg_params->ctsamsg_handle, NULL,
                          msg_params->ctsamsg_dest, func, __LINE__ );
              rc = ESA_FATAL ;
              goto exit ;
           }
      }

     //
      *   In current reading and moving in local buffer block
      *   not enough place.
      //

      else {

          //
           *   Definition free space and move from buffer
           *   only count of free space bytes
           *   Incr in 'count of free space' : ptr of input buffer
           *   Decr in 'count of free space' : total size of input buff
           //

           rem   = os_handle->blksize - pos  ;

           ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                            "Move to i/o buffer pos=%d size=%d",
                            pos, rem  );

           memcpy( os_handle->local_buffer + pos ,buf,rem);
           buf  += rem;
           size -= rem;

           //////////// Put current block /////////////

           osrc=osput(os_handle->fh,os_handle->local_buffer,
                      os_handle->blksize);
           if ( osrc NE 0 ) {
              ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                               "osput() failed rc=%d prog=%s line=%d",
                               osrc, __FILE__, __LINE__);
              CTSAMSG_print(QUEUE_IOERR,
                          msg_params->ctsamsg_handle, NULL,
                          msg_params->ctsamsg_dest, "PUT",osrc);
              CTSAMSG_print(QUEUE_IOERR_DETAIL,
                          msg_params->ctsamsg_handle, NULL,
                          msg_params->ctsamsg_dest, func, __LINE__ );
              rc = ESA_FATAL ;
              goto exit ;
           }

          //
           *    Get next block for filling
           //

           osrc=osget(os_handle->fh, &(os_handle->io_buffer), &len );
           if ( osrc NE 0 )  {
              ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                               "osget() failed rc=%d prog=%s line=%d",
                               osrc, __FILE__, __LINE__);
              CTSAMSG_print(QUEUE_IOERR,
                            msg_params->ctsamsg_handle, NULL,
                            msg_params->ctsamsg_dest, "GET",osrc);
              CTSAMSG_print(QUEUE_IOERR_DETAIL,
                            msg_params->ctsamsg_handle, NULL,
                           msg_params->ctsamsg_dest, func, __LINE__ );
              // bs2626 starts //
              if (osrc EQ -1)
                {
                  ESA_DIAG_printf (ESA_COMP_QUEUE, 4,"EOF in QUEUE.");
                  rc = ESA_EOF;
                }
              else rc = ESA_FATAL;
              // bs2626 ends //
              goto exit;
           }

          //
           *   osget was done successfull. Move current reading
           *   block to local buffer for filling
           *   now local buffer position = 0
           //

           else  {
              memcpy(os_handle->local_buffer,os_handle->io_buffer,
                     os_handle->blksize);
              os_handle->local_buffer_pos= 0;
              pos   = 0 ;
           }
      }
   } while ( size NE 0 ) ;     // Do loop while all information //
                               // will be writed                */

  /******************** Write to the file ****************************/

  osrc = fwrite(buff, 1, size, os_handle->QUE);           /* SAS2IBMT */
  if (osrc LT size)                                       /* SAS2IBMT */
   {
    print_amrc(msg_params);                               /* SAS2IBMT */
    ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                   /* SAS2IBMT */
                     "fwrite() failed rc=%d prog=%s line=%d",
                     osrc, __FILE__, __LINE__);
    CTSAMSG_print(QUEUE_IOERR,                            /* SAS2IBMT */
                  msg_params->ctsamsg_handle, NULL,
                  msg_params->ctsamsg_dest, "FWRITE",osrc);
    CTSAMSG_print(QUEUE_IOERR_DETAIL,                     /* SAS2IBMT */
                msg_params->ctsamsg_handle, NULL,
                msg_params->ctsamsg_dest, func, __LINE__ );
    rc = ESA_FATAL ;                                      /* SAS2IBMT */
    goto exit;                                            /* SAS2IBMT */
   };

  /********* Current position in file after write */

   /* SAS2IBMN os_handle->position += requested_size ;               */
   os_handle->position += size ;                         /* SAS2IBMN */

   exit :;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc );
   return rc;

}

/****************************************************
* Procedure Name: OS_FILE_read
* Description   : Read data from a file.
*
* Input         : length of data to read
*                 handle
*
* Output        : data in buffer
*
* Return Value  : ESA_OK     upon success
*                 ESA_FATAL  on any fail situation
*
****************************************************/

ESA_RC OS_FILE_read (void                   * buff,
                     size_t                   size,
                     void                   * handle,
                     CTSAMSG_PARAMS_rec_typ * msg_params)
{

   ESA_RC            rc = ESA_OK;
   int               osrc = 0 ;
   /* SAS2IBMT These variables are not needed
   int               pos ;
   int               len;
   int               rem;                                            */
   /* SAS2IBMN size_t            requested_size;                     */
   char              *buf=(char *)buff ;
   static char       func[]="OS_FILE_read";

   OS_FILE_HANDLE_typ *os_handle = handle;

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

  /*
   *   Eye catcher checking
   */

   if ( memcmp(os_handle->eyecatcher, QUE_EYECATCHER,4) NE 0) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, component, func,
                    "Invalid handle",16,__LINE__);
      rc=ESA_FATAL;
      goto exit;
   }

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "before osget. fh: %#x len: %d buff_position=%d",
                    os_handle->fh, size,
                    os_handle->local_buffer_pos);                    */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                    /* SAS2IBMT */
                    "before fread. len=%d" , size);

   /* SAS2IBMT
   pos = os_handle->local_buffer_pos;
   rem            = size ;                                           */
   /* SAS2IBMN requested_size = size ;                               */

   /*
    * Need read current block  because was issued osseek
    * or current block is finished for read
    */

   /* SAS2IBMT We are in 'byteseek' mode so this code is not needed.
              We will always be called after an fseek.
   if (  ( os_handle->seek_flag EQ 1 )   OR
         ( ( os_handle->blksize - pos ) EQ 0 ) ) {
      os_handle->seek_flag=0;
      osrc = osget(os_handle->fh, &(os_handle->io_buffer), &len );
      if ( osrc NE 0 )  {
         ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                          "osget() failed rc=%d prog=%s line=%d",
                          osrc, __FILE__, __LINE__);
         CTSAMSG_print(QUEUE_IOERR,
                       msg_params->ctsamsg_handle, NULL,
                       msg_params->ctsamsg_dest, "GET",osrc);
         CTSAMSG_print(QUEUE_IOERR_DETAIL,
                       msg_params->ctsamsg_handle, NULL,
                       msg_params->ctsamsg_dest, func, __LINE__ );
         // bs2626 starts //
         if (osrc EQ -1)
           {
             ESA_DIAG_printf (ESA_COMP_QUEUE, 4,"EOF in QUEUE.");
             rc = ESA_EOF;
           }
         else rc = ESA_FATAL;
         // bs2626 ends //
         goto exit;
      }

     //
      *    osget was finished successfull.
      *    If osget was done because current block is finished for read
      *    current local buffer position = 0
      //

      else if ( ( os_handle->blksize - pos ) EQ 0 )  {
         pos = 0 ;
         os_handle->local_buffer_pos = 0;
      }

   }                                                                 */

  /*
   *     Main loop : get information
   */

   /* SAS2IBMT We are in 'byteseek' mode so this code is not needed.
              We will always have the data we need when we do an
              fread (unless we are in wrap mode - which is dealt
              with by the caller, ESAQUE).
   do {

     ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                      "Read request: position=%d size=%d", pos, size );

     //
      *   Current reading block include all requested information
      //

      if ( os_handle->blksize - pos GE size ) {

        //
         *   Move information from BSAM buffer to output buff
         *   Increase in 'size' byte  :local buffer position
         //

         ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                          "Move from i/o buffer pos=%d size=%d",
                          pos, size );

         memcpy(buf,(char *)os_handle->io_buffer + pos,size);
         os_handle->local_buffer_pos += size;
         size=0;
      }

     //
      *   Current reading block not include all requested inform
      //

      else {

          //
           *   Definition size of including part in current block
           *   Incr in 'size of part' : ptr of input buffer
           *   Decr in 'size of part' : total requested size
           //

           rem   = os_handle->blksize - pos  ;

           ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                            "Move from i/o buffer pos=%d size=%d",
                            pos, rem  );

           memcpy(buf,(char *)os_handle->io_buffer + pos,rem);
           buf  += rem;
           size -= rem;

           //
            *    Get next block
            //

           osrc=osget(os_handle->fh, &(os_handle->io_buffer), &len );
           if ( osrc NE 0 )  {
              ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                               "osget() failed rc=%d prog=%s line=%d",
                               osrc, __FILE__, __LINE__);
              CTSAMSG_print(QUEUE_IOERR,
                            msg_params->ctsamsg_handle, NULL,
                            msg_params->ctsamsg_dest, "GET",osrc);
              CTSAMSG_print(QUEUE_IOERR_DETAIL,
                            msg_params->ctsamsg_handle, NULL,
                            msg_params->ctsamsg_dest, func, __LINE__ );
              // bs2626 starts //
              if (osrc EQ -1)
                {
                  ESA_DIAG_printf (ESA_COMP_QUEUE, 4,"EOF in QUEUE.");
                  rc = ESA_EOF;
                }
              else rc = ESA_FATAL;
              // bs2626 ends //
              goto exit;
           }

          //
           *   osget was done successfull.
           *   now local buffer position = 0
           //

           else {
              pos = 0 ;
              os_handle->local_buffer_pos = 0;
           }
      }
   } while ( size NE 0 )    ;  // Do loop while all requested //
                                // will be moved to output buff*/

  /******************** Read from the file ***************************/

  FREAD(os_handle->QUE, buff, size, osrc, rc);            /* SAS2IBMN */
  if (rc NE ESA_OK)                                       /* SAS2IBMN */
    goto exit;                                            /* SAS2IBMT */

  /********* Current position in file after read  */

  /* SAS2IBMN os_handle->position += requested_size ;                */
  os_handle->position += size ;                          /* SAS2IBMN */

  exit :;
  ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc );
  return rc;

}

/****************************************************
* Procedure Name: OS_FILE_tell
* Description   : Return the current position in file (like ftell)
*
* Input         : handle
*
* Output        : none
*
* Return Value  : current position in file
*
****************************************************/

long int OS_FILE_tell (void                   * handle,
                       CTSAMSG_PARAMS_rec_typ * msg_params)
{

   OS_FILE_HANDLE_typ       *os_handle = handle;
   long int                  file_pos = 0;
   static char               func[]="OS_FILE_tell";

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

  /*
   *   Eye catcher checking
   */

   if ( memcmp(os_handle->eyecatcher,
               QUE_EYECATCHER , 4 ) NE 0 ) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, component, func,
                    "Invalid handle", 16, __LINE__);
      goto exit;
   }

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "ftell. fh: %#x pos=%d",
                    os_handle->fh,os_handle->position);              */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "ftell. pos=%d",
                    os_handle->position);

   file_pos = os_handle->position;

  exit :;

  /********* Return current position in file after I/O operations */

  ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, ESA_OK );

  return file_pos;

}

/****************************************************
* Procedure Name: OS_FILE_seek
* Description   : Changes the position in file (like fseek)
*
* Input         : handle
*                 offset - the position to seek
*                 where  - defines the offset
*
* Output        : none
*
* Return Value  : ESA_OK     upon success
*                 ESA_FATAL  on any fail situation
*
****************************************************/

ESA_RC OS_FILE_seek (void                   * handle,
                     long int                 offset,
                     int                      where,
                     CTSAMSG_PARAMS_rec_typ * msg_params)
{

   ESA_RC            rc = ESA_OK;
   int               osrc;
   /* SAS2IBMT These variables are not needed
   int               block,pos;
   ospos_t           position;                                       */
   static char       func[]="OS_FILE_seek";

   OS_FILE_HANDLE_typ *os_handle = handle;

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

  /*
   *   Eye catcher checking
   */

   if ( memcmp(os_handle->eyecatcher,QUE_EYECATCHER, 4) NE 0 ) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle,
                    NULL,
                    msg_params->ctsamsg_dest,
                    component,func,"Invalid handle",16,__LINE__);
      rc=ESA_FATAL;
      goto exit;
   }

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                   "before fseek. fh: %#x offset: %d where: %d",
                    os_handle->fh, offset, where);                   */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                    /* SAS2IBMT */
                   "before fseek. offset: %d where: %d",
                    offset, where);

  /*
   *   Get block number
   */

   /* SAS2IBMT We are in 'byteseek' mode so this code is not needed.
              All of our positioning is done using relative byte
              offsets.
   get_block_pos(offset,os_handle->blksize,&block,&pos);

  //
   *   Get TTR
   //

   get_ttr(block,os_handle->block_per_track,&position);

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                   "position=%#x",position._blkaddr);                */

  /*
   *     Reposition a file
   */

   /* SAS2IBMT
   osrc = osseek(os_handle->fh,position);                            */
   FSEEK(os_handle->QUE, SEEK_SET, offset, osrc, rc);    /* SAA2IBMN */
   if (rc NE ESA_OK)                                     /* SAS2IBMN */
     goto exit;                                          /* SAS2IBMN */

  /*
   *     Reposition a file was done successfull.
   *     now: current file position - requested
   *          flag_seek=1 means , before any I/O operation
   *          need read block.
   */

   else {
         os_handle->position = offset ;
         /* SAS2IBMT
         os_handle->local_buffer_pos = pos ;
         os_handle->seek_flag=1;  // Need read current block //

         ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                          "local_buffer_pos=%d offset=%d",
                          os_handle->local_buffer_pos,
                          os_handle->position );                     */
         ESA_DIAG_printf (ESA_COMP_QUEUE, 4,              /* SAS2IBMT */
                          "offset=%d", os_handle->position );

   }

   exit :;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc );
   return rc;

}

/****************************************************
* Procedure Name: OS_FILE_flush
* Description   : Flushes file buffers
*
* Input         : handle
*
* Output        : none
*
* Return Value  : ESA_OK     upon success
*                 ESA_FATAL  on any fail situation
*
****************************************************/

ESA_RC OS_FILE_flush (void                   * handle,
                      CTSAMSG_PARAMS_rec_typ * msg_params)
{
/* SAS2IBMN - start */
/* Make this a macro because it is called twice...                  */
#define FFLUSH()                                                       \
 osrc = fflush(os_handle->QUE);                         /* SAS2IBMT */ \
 if (osrc NE 0)                                                        \
 {                                                                     \
    print_amrc(msg_params);                             /* SAS2IBMT */ \
    ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                                \
                     "fflush() failed rc=%d prog=%s line=%d",          \
                     osrc, __FILE__, __LINE__);                        \
    CTSAMSG_print(QUEUE_IOERR,                                         \
                  msg_params->ctsamsg_handle, NULL,                    \
                  msg_params->ctsamsg_dest, "FFLUSH",osrc);            \
    CTSAMSG_print(QUEUE_IOERR_DETAIL,                                  \
                  msg_params->ctsamsg_handle, NULL,                    \
                  msg_params->ctsamsg_dest, func, __LINE__ );          \
    rc = ESA_FATAL;                                                    \
 }                                                                     \
 else                                                                  \
    rc= ESA_OK;

/* SAS2IBMN - end   */

   ESA_RC                rc = ESA_OK;
   int                   osrc;
   OS_FILE_HANDLE_typ   *os_handle = handle;
   int                   pos;                            /* SAS2IBMN */
   char                  temp_buf[2];                    /* SAS2IBMN */
   static char           func[]="OS_FILE_flush";

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

  /*
   *   Eye catcher checking
   */

   if ( memcmp(os_handle->eyecatcher, QUE_EYECATCHER, 4) NE 0 ) {
      CTSAMSG_print(ERR_INTERNAL2,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, component, func,
                    "Invalid handle", 16, __LINE__);
      rc=ESA_FATAL;
      goto exit;
   }

   /* SAS2IBMT
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "before fflush. fh: %#x",
                    os_handle->fh);                                  */
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "before fflush.");

  /*
   *   Flushes pending I/O so the file can ( must ) be repositioned
   */
  /*   SAS2IBMN - start */
   FFLUSH();
   if (rc NE ESA_OK)
     goto exit;

  /*   Fake flush
   *   ==========
   *   Unfortunately, fflush() does not flush the buffers so we need
   *   to fake flush by reading another block so that, when a block
   *   is re-read, it will be brought from file.
   *
   *   This logic is needed because fflush does not refresh the
   *   buffer so the next read does not bring the updated block
   *   from the file.
   *
   *   Although we handle the file as byte stream, the file is
   *   actually accessed using BSAM operations. C translates the
   *   byte position into file position and reads the required
   *   block to the buffer. Therefore, when reading a block for
   *   the fake flush, we must ensure that we are reading a block
   *   that is not in the buffer now, and will not be read on the
   *   next read request.
   *
   *   This logic is good as long as the callers, when reading the
   *   file, need an updated version of the same block they had
   *   before the flush, or block 0. If random reading is done, this
   *   logic is not good, because, the block we read for the "flush"
   *   might be the block needed later by the caller...
   *
   *   We never re-read block 0.
   *
   *   Faked flush logic:
   *   If current position is somewhere before or on the beginning of
   *   the third block, go read the last block.
   *   When not on the 2 first blocks, or on the beginning of the 3rd
   *   block, we can go backwards:
   *   1. If the current position is on block start (from 4th block on),
   *      go back to the block before the last that was read, so the
   *      block in buffer will be flushed.
   *   2. if the current position is not on block start, go back
   *      1 block.
   *
   */

   /* Position on required block */
   if (os_handle->position LE os_handle->blksize*2) /*In first 2 blks?*/
   {
     FSEEK(os_handle->QUE, SEEK_END, -10, osrc, rc); /* read from end */
   }
   else                                    /* otherwise...            */
     if (os_handle->position % os_handle->blksize EQ 0) /* blk start? */
     {
       FSEEK(os_handle->QUE, SEEK_CUR, -(os_handle->blksize + 1),
             osrc, rc);            /* go 2 blolcks back to force read */
     }
     else                        /* not block start, go back 1 block. */
     {
       FSEEK(os_handle->QUE, SEEK_CUR, -os_handle->blksize, osrc, rc);
     }

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4, "fseek rc = %d", rc);

   if (rc NE ESA_OK)
   {
     rc = ESA_FATAL;
     goto exit;
   }

   pos = ftell(os_handle->QUE);
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "position after seek = %d  blk/off = %d / %d",
                     pos, pos/os_handle->blksize,
                     pos % os_handle->blksize);

   /* Read the block (1 byte)    */
   FREAD(os_handle->QUE, temp_buf, 1, osrc, rc);
   if (rc NE ESA_OK)
   {
     rc = ESA_FATAL;
     goto exit;
   }

  /* SAS2IBMN - end   */


   /* SAS2IBMT
   osrc = osflush(os_handle->fh,PURGE);                              */
   FFLUSH();                                            /* SAS2IBMN */
   if (rc NE ESA_OK)                                    /* SAS2IBMN */
     goto exit;                                         /* SAS2IBMN */
   /* SAS2IBMN else {  */

     /*
      *    Flush was done successfull. After this operation
      *    Need perform OS_FILE_seek  or may cause incorrect
      *    result later in processing
      *    current file position = 0, local buffer position=0
      */
/*           7) Why are we setting os_handle->position to 0 at the
                end of the OS_FILE_flush routine?  Why not leave it
                as is?  Why be forced to issue an fseek?             */

      /* SAS2IBMT os_handle->local_buffer_pos =0;                    */

   os_handle->position=0;
   /* SAS2IBMN } */

   exit :;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc );
   return rc;

}

/****************************************************
 * Procedure Name: OS_FILE_getfh
 * Description   : Retrieve file handle from OS_FILE_HANDLE
 *
 * Input         : handle
 *                 message params
 *
 * Output        : file handle
 *
 * Return Value  : ESA_OK     upon success
 *                 ESA_FATAL  on any fail situation
 *
 ****************************************************/

ESA_RC OS_FILE_getfh (void                   * handle,
                      FILE                  ** fh,
                      CTSAMSG_PARAMS_rec_typ * msg_params)
{

   static char func[]="OS_FILE_getfh";
   ESA_RC rc = ESA_OK;

   /*
    *   Start of code
    */

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

   *fh = NULL;

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, rc);
   return rc;

}
/****************************************************
* Procedure Name: get_block_pos
* Description   : Return the current block and pos according
*                 file position
*
* Input         : position    -  file position
*                 blksize     -  blksize
*
* Output        : block       -  block number
*                 pos         -  position in block
*
* Return Value  : none
*
****************************************************/
/* SAS2IBMT This routine is no longer in use
static void get_block_pos(long int         position,
                          int              blksize,
                          int             *block,
                          int             *pos)
{

    div_t  d;
    static char func[]="get_block_pos";

    //
     *   Start of code
     //

    ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL,func);

    d=div(position,blksize);
    *block = d.quot;         // block number //
    *pos   = d.rem;          // pos in block //

    ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "position %d block=%d pos=%d",
                    position, *block, *pos ) ;

    ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL,func, ESA_OK );
    return;

}                                                                  */

/****************************************************
* Procedure Name: get_ttr
* Description   : Return ttr info according block number
*                 and block-per-track value
*
* Input         : position    -  file position
*                 blksize     -  blksize
*
* Output        : block       -  block number
*                 pos         -  position in block
*
* Return Value  : none
*
****************************************************/
/* SAS2IBMT This routine is no longer in use
static void get_ttr(int          block,
                    int          block_per_track,
                    ospos_t      *position)
{

   div_t  d;
   static char func[]="get_ttr";

   //
    *   Start of code
    //

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

   position->_recno = 0 ;    // (block) record  number //
   d=div(block,block_per_track);

  //
   *     Create TTRz
   //
   position->_blkaddr=0;
   position->_blkaddr=(d.quot << 16 ) | ( ( d.rem +1 ) << 8 ) ;

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                   "block=%d block_per_trk=%d ttr=%#x",
                   block, block_per_track,position->_blkaddr) ;


   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, ESA_OK );
   return;

}                                                                  */

/* SAS2IBMT - start   */
/********************************************** Routine added - SAS2IBMT
* Procedure Name: print_amrc
* Description   : Routine which prints I/O error
*                 information.  Most of this routine
*                 was copied from the z/OS XL C/C++
*                 Programming Guide.
*
* Input         : none
*
* Output        : none
*
* Return Value  : none
*
****************************************************/

static void print_amrc(CTSAMSG_PARAMS_rec_typ * msg_params)
{

   static char  func[]="print_amrc";
   __amrc_type  currErr  = *__amrc;
   __amrc2_type currErr2 = *__amrc2;
   char         desc[25];
   char         filename[44];
   fldata_t     info;
   int          save_errno = errno;                  /* SAS2IBMN */

   ESA_DIAG_enter (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func);

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "* * * I/O Error Information * * *");
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "%s", strerror(errno));
   CTSAMSG_print(QUEUE_AMRC1,
                 msg_params->ctsamsg_handle, NULL,
                 msg_params->ctsamsg_dest);

   CTSAMSG_print(QUEUE_AMRC2,
                 msg_params->ctsamsg_handle, NULL,
                 msg_params->ctsamsg_dest, strerror(errno));

   /* The following #defines are defined in CEE.SCEEH.H(STDIO) */
   switch(currErr.__last_op)
   {
     case __BSAM_BLDL:
          strcpy(desc,"BSAM_BLDL");
          break;
     case __BSAM_CLOSE:
          strcpy(desc,"BSAM_CLOSE");
          break;
     case __BSAM_CLOSE_T:
          strcpy(desc,"BSAM_CLOSE_T");
          break;
     case __BSAM_NOTE:
          strcpy(desc,"BSAM_NOTE");
          break;
     case __BSAM_OPEN:
          strcpy(desc,"BSAM_OPEN");
          break;
     case __BSAM_POINT:
          strcpy(desc,"BSAM_POINT");
          break;
     case __BSAM_READ:
          strcpy(desc,"BSAM_READ");
          break;
     case __BSAM_STOW:
          strcpy(desc,"BSAM_STOW");
          break;
     case __BSAM_WRITE:
          strcpy(desc,"BSAM_WRITE");
          break;
     case __SVC99_ALLOC:
          strcpy(desc,"SVC99_ALLOC");
          break;
     case __OS_OPEN:
          strcpy(desc,"OS_OPEN");
          break;
     case __OS_CLOSE:
          strcpy(desc,"OS_CLOSE");
          break;
     default:
          strcpy(desc,"not defined");
          break;
   }

   if (fldata(currErr2.__fileptr, filename, &info) EQ 0)
   {
      ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                       "Error on file %s",filename);

      CTSAMSG_print(QUEUE_AMRC3,
                    msg_params->ctsamsg_handle, NULL,
                    msg_params->ctsamsg_dest, filename);
   }

   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "Last I/O function attempted = %d = %s",
                    currErr.__last_op, desc);
   ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                    "R15 value = %d   Reason code = %d",
                    currErr.__code.__feedback.__rc,
                    currErr.__code.__feedback.__fdbk);

   CTSAMSG_print(QUEUE_AMRC4,
                 msg_params->ctsamsg_handle, NULL,
                 msg_params->ctsamsg_dest,
                 currErr.__last_op, desc);

   if (save_errno EQ 92) /* If abend, print abend code       SAS2IBMN */
   {                                                      /* SAS2IBMN */
     CTSAMSG_print(QUEUE_AMRC6,                           /* SAS2IBMN */
                   msg_params->ctsamsg_handle, NULL,      /* SAS2IBMN */
                   msg_params->ctsamsg_dest,              /* SAS2IBMN */
                   currErr.__code.__abend.__syscode,      /* SAS2IBMN */
                   currErr.__code.__abend.__rc);          /* SAS2IBMN */
     CTSAMSG_print(QUEUE_AMRC6,                           /* SAS2IBMN */
                   msg_params->ctsamsg_handle, NULL,      /* SAS2IBMN */
                   msg_params->ctsamsg_dest,              /* SAS2IBMN */
                   currErr.__code.__abend.__syscode,      /* SAS2IBMN */
                   currErr.__code.__abend.__rc);          /* SAS2IBMN */
     ESA_DIAG_printf (ESA_COMP_QUEUE, 4,                  /* SAS2IBMN */
                      "Abend code = %04X   rc = %04X",    /* SAS2IBMN */
                      currErr.__code.__abend.__syscode,   /* SAS2IBMN */
                      currErr.__code.__abend.__rc);       /* SAS2IBMN */
   }                                                      /* SAS2IBMN */
   else                  /* no abend, print feefback      /* SAS2IBMN */
   {                                                      /* SAS2IBMN */
     CTSAMSG_print(QUEUE_AMRC5,
                   msg_params->ctsamsg_handle, NULL,
                   msg_params->ctsamsg_dest,
                   currErr.__code.__feedback.__rc,
                   currErr.__code.__feedback.__fdbk);

     /* rplfdbwd is defined as 'unsigned char __rplfdbwd[4];' in     */
     /* STDIO.  It is important that it is printed as a 4-byte hex   */
     /* value in order to see all its 4 bytes: RPLSTAT, RPLRTNCD,    */
     /* RPLCMPON,and RPLERRCD.                                       */
     ESA_DIAG_printf (ESA_COMP_QUEUE, 4,
                      "RPL feedback code = %02X%02X%02X%02X",
                      currErr.__rplfdbwd[0],currErr.__rplfdbwd[1],
                      currErr.__rplfdbwd[2],currErr.__rplfdbwd[3]);
   }                                                      /* SAS2IBMN */

   ESA_DIAG_exit (ESA_COMP_QUEUE, DIAG_ENTER_LEVEL, func, ESA_OK );
   return;
}
/* SAS2IBMT - end   */

