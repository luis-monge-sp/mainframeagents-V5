 /**************************************************************
 *                                                             *
 * Title            : ACF2 Service functions                   *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 04/06/97                                 *
 *                                                             *
 * Description      : General ACF2 API functions               *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/

 /**************************************************************
 * Mod.Id   Who      When     Description                      *
 * -------- -------- -------- -------------------------------- *
 * BS2306   Guy      27/10/97 Added check for vec overflow     *
 *                            in Convert_Multi_To_Vec          *
 *                            + some errors printing           *
 * BS2309   Guy      02/11/97 Match UIDMASKs to uppercase      *
 * BS2307   Guy      02/11/97 Check in UIDMASK that not all    *
 *                            non-LID fields are masked        *
 * PS0234   Guy      20/01/98 Truncate UIDMASKs (resources fix)*
 *                            Added UNTIL keyword to list of   *
 *                            date fields                      *
 *                            Added ACF2_Convert_Access_Levels *
 *                            Added Build_LID_Array function   *
 *                            Added Is_UIDMASK_User function   *
 *                            Added Build_UIDMASK_User function*
 *                            Added Is_LID_In_UID function     *
 * PS0345   Guy      02/12/98 Add MULTIVALUE limits            *
 * PS0354   Guy      09/12/98 Check Disconnect from Multivalued*
 *                            field in Update User             *
 * PS0458   Michael  18/03/01 User to UG conn fix              *
 * BS2593   AvnerL   07/04/03 trunc blanks from res-name       *
 * bs2607   AvnerL   25/05/03 support user defined date fields *
 * bs2620   AvnerL   13/10/03 Prevent partial multi-value flds.*
 * BS2665   AvnerL   09/03/04 S0c4 at Federal Reserve.         *
 * IS10009  AvnerL   29/08/07 EXPIRE date field is not handled.*
 * BS10019  AvnerL  03DEC2009 Date fields table is not found.  *
 *                            Set NORENTEXT for compile.       *
 * BS10029  Nurity 12/03/2012 Copy from 3.2.02 in order to     *
 *                            apply BS10019.                   *
 * IS10088  NuritY 03/06/2013 Abend S0C4 when uid mask in group*
 *                            is longer than max uid. (BS10030)*
 * IS10128  AvnerL   28/09/14 Allow correlated UIDs for IIQ.   *
 * BS10049  AvnerL   30/05/16 check multi value blank issue.   *
 * BS10050  AvnerL   13/06/16 Drop trail '*' but leave blank/s *
 * SAS2IBMA AvnerL   17/07/16 SAS/C to IBM/C                   *
 * WS10067  SeligT   18/01/18 Update GDB dynamically when      *
 *                            access or resource rules are     *
 *                            added/modified                   *
 * IS10174  NuritY   15/01/18 Dynamic EXECOUT support.         *
 * BS10093  SeligT   12/08/18 Add and Delete Group Functions   *
 *                            Not Working After CCID BS10091   *
 * IS10178  SeligT   18/12/18 Supporting LID Anywhere in UID   *
 * WS10075S SeligT   11/08/19 Manage Permissions as Account    *
 *                            and Group Attributes             *
 * WS10075K KailasP  13/11/19 Build Permission from data receiv*
 *                   25/11/19 add Get_rule_line_from_memory    *
 * WS10075A AvnerL   17/11/19 add Permission_Drop_Decision     *
 * WS10076N NuritY   30/12/19 Move permission routines added by*
 *                            WS10075 to CTSBPHR               *
 * WS10076S SeligT   05/01/20 Manage Permissions as Account    *
 *                            and Group Attributes - Phase 2   *
 * WS10076A AvnerL   19/01/20 add admin_params 2 ACF2_Get_Group*
 * BS10108  NuritY   15/09/20 Move here XREF routines,         *
 * BS10108T ThomaS   30/09/20 1. Xref_Block_Build:             *
 *                               Fix init and cleanup issues.  *
 *                               Replace the code parsing with *
 *                               call to Parse_XREF_Record.    *
 *                            2. Parse_XREF_Record:            *
 *                               If requested, parse SYSID and *
 *                               add to addinfo.               *
 *                            3. XREF_Block_Find:              *
 *                               Use strcmp instead of strstr. *
 *                               Use XREF_NAME_SIZE, not 9.    *
 * WS10079T ThomaS   20/10/20 1. Replace Xref_Block_Build      *
 *                   21/12/20 2. Parse_XREF_Record: JPMC phase2*
 *                            3. create/update/delete of       *
 *                               role/source                   *
 * WS10079K KailasP  30/12/20 Move and add new code to         *
 *                            ACF2_Get_Xref                    *
 *                   13/01/21 Moved again to CTSBAPI (WS10079T)*
 * WS10079N NuritY   05/01/21 Remove Xref_Blokc_Find, change   *
 *                            Get_Xref_Record to static and    *
 *                            add XREF_Block_Print.            *
 * BS10111  NuritY   16/12/20 Support ruob above the bar.      *
 * BS10113  NuritY   16/03/21 Fix xref record length calc.     *
 * IS10184  NuritY   02/09/21 Improve scripts performance      *
 * WS10084  ThomaS   22/08/23 Replace ACFRPTRX                 *
 * BS10134  AvnerL   16/02/24 S0C4 while Source aggregation    *
 * WS10082  AvnerL   03/10/23 Recompile & allow 16K inc/exc lst*
 **************************************************************/

 #include   <globs.h>

 /*
  *   Standard include files
  */

 #include   STDLIB
 #include   STDIO
 #include   STRING
 #include   CTYPE

 /*
  *   ESA include files
  */

 #include ESA_DIAG
 #include ESA_CTSAMSG
 #include ESA_API
 #include ESA_API_CODES

 #include MVS_COMP
 #include MVS_CODES                                      /* WS10079A */
 #include MVS_OS_CLI
 #include MVS_INTERCEPTOR                                 /* WS10067 */

 #include <ctest.h>                                      /* WS10084 */
 #include API_ADDINFO
 #include API_DATES

 #include ACF2_CODES
 #include ACF2

 typedef struct {
  char *Date_Field_Name;
  } Date_Field_typ;

 /* PS0234 */
 typedef struct {
  char *Access_Field_Name;
  } Access_Field_typ;

 typedef struct {                                         /* BS2307 */
  int Lid_Length[ACF2_MAX_LID_PARTS];                     /* BS2307 */
  int Lid_Offset[ACF2_MAX_LID_PARTS];                     /* BS2307 */
  int Original_Lid_Offset[ACF2_MAX_LID_PARTS];            /* PS0234 */
  } LID_Parts_typ;                                        /* BS2307 */

 static char component[] = "CTSBSRV";
 static char   end_marker[]="UID(f)";                     /* WS10067 */
 static int    LID_In_UID, LID_Offset, LID_Length;        /* WS10067 */
 static int    numgrps;                                   /* WS10067 */
 static long   blksize;                                   /* WS10067 */
#define LRECL   133                                       /* WS10067 */
/* WS10067 #define BLKSIZE 1330                                      */

#define MAX_DATE_FIELDS 50 /* same as in CTSBKDA !!!       BS2665 */
#define Date_Fields_Table dateflt /* extern should be LE 8 bs2607 */
 extern Date_Field_typ Date_Fields_Table [20]; /*up to 20 date fields*/

 /* PS0234 - Added UNTIL keyword */
 /* Date_Fields_Table is built dynamically. drop pre-defined. bs2607 *
 static Date_Field_typ  Date_Fields_Table [] = {
     "ACTIVE",
     "EXPIRE",
     "UNTIL",
     ""       };
     end of dropping the pre-defined table                    bs2607 */

 /* PS0234 */
 static Access_Field_typ  Access_Fields_Table [] = {
     "READ",
     "WRITE",
     "EXEC",
     "ALLOC",
     ""       };


/* BS10111 - moved from CTSBACF because it should not be used by
   others                                                       */
typedef struct {
 /* BS10111 Get_RUOBline_handle_rec_typ *h_RUOB;  */
 void             * ctsaruh_handle;     /* -> CTSARUH handle BS10111 */
 ASM_RTN_TYP      * p_ctsaruh;          /* -> CTSARUH        BS10111 */
 } Get_XREF_Rec_Handle;
/*  BS10111 - end of moved code.  */


static ESA_RC Check_UIDMASKS_Correllation(int     u1_count,
                                          UIDMASK uidmask1[1],
                                          int     u2_count,
                                          UIDMASK uidmask2[1],
                                          int     *u1_index,
                                          int     *u2_index);

static int Check_UID_Correllate(UIDMASK uid1,
                                UIDMASK uid2);

static void Upper_UIDMASKS(ADDINFO_rec_ptr addinfo);      /* BS2309 */

static int Build_LID_Array(int *);                        /* PS0234 */

static ESA_RC Check_UIDMASKS_NonLID_Masked(int     Group_UID_Count,
                                           UIDMASK Group_UID[1]);
                                                          /* BS2307 */

static ESA_RC Check_UIDMASKS_Multi_Masked(int     Group_UID_Count,
                                          UIDMASK Group_UID[1],
                                  CTSAMSG_DEST_TABLE_rec_ptr dest,
                                  CTSAMSG_HANDLE_rec_ptr     msgs);
                                                          /* PS0345 */
/* PS0354 */
static int ACF2_Connected_To_New_UIDs (int,
                                       char *,
                                       int,
                                       UIDMASK UG_UIDM[1]);
/* WS10079N - changed to be static   */
static ESA_RC Get_XREF_Record(char        * function,  /* WSS0079N */
          /* BS10111    Get_XREF_Rec_Handle        ** handle,  */
          /* BS10111 */ void                       ** handle,
          /* BS10111    REXX@UTL_output_blk_rec_typ * ruob,     */
          /* BS10111 */ char                        * ruob,
                        char                        * output_buffer,
                        int                           max_output_length,
                        ADMIN_PARAMS_rec_typ        * admin_params);
/* WS10079N - end  */

/*  Start WS10079   */
static ESA_RC XREF_Prep_CB(
        XBhandle_rec_typ         * XBhandle,
        char                       XorG,
        PBhandle_typ            ** PBhandle,
        ESA_DIAG_COMP_typ          diag_comp,
        ADMIN_PARAMS_rec_typ     * admin_params);

static ESA_RC  Free_PBXB(
        PBhandle_typ             * PBhandle,
        ESA_DIAG_COMP_typ          diag_comp,
        ADMIN_PARAMS_rec_typ     * admin_params);

static ESA_RC  XREF_Find_and_Inactivate(
        PBhandle_typ             * PBhandle,
        char                     * name,
        char                     * in_sysid,
        char                     * out_sysid,
        ESA_DIAG_COMP_typ          diag_comp,
        ADMIN_PARAMS_rec_typ     * admin_params);

static ESA_RC Insert_PBXB_Entry(
        XBhandle_rec_typ         * XBhandle,
        PBhandle_typ             * PBhandle,
        char                     * name,
        char                     * sysid_from_parse,
        char                     * acf2_sysid,
        char                       active,
        char                     * output_area,
        ESA_DIAG_COMP_typ          diag_comp,
        ADMIN_PARAMS_rec_typ     * admin_params);

static ESA_RC XREF_Match_SYSID(
        char                     * acf2_sysid,
        char                     * entity_sysid,
        ESA_DIAG_COMP_typ          diag_comp,
        ADMIN_PARAMS_rec_typ     * admin_params);

static void  XREF_Block_Print(                            /* WS10079N */
                  XBhandle_rec_typ         * XBhandle,    /* WS10079N */
                  ESA_DIAG_COMP_typ      diag_comp,       /* WS10079N */
                  ADMIN_PARAMS_rec_typ * admin_params);   /* WS10079N */

#define   COMMA_CHAR     ','

static ESA_RC XREF_Extract_One_Inc_Exc_List(
                  char                          * incexctype,
                  ADDINFO_rec_typ               * addinfo,
                  XREF_Operations_Lists_typ    ** op_lists,
                  ESA_DIAG_COMP_typ               diag_comp,
                  ADMIN_PARAMS_rec_typ          * admin_params);

static ESA_RC XREF_Extract_One_Operation(
                  char                          * operation,
                  char                          * list,
                  char                         ** one_op_list,
                  ESA_DIAG_COMP_typ               diag_comp,
                  ADMIN_PARAMS_rec_typ          * admin_params);

static ESA_RC XREF_One_Command_Create(
                  char                 * type,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
                  char                 * include_list,
                  char                 * exclude_list,
                  char                 * command_op,
                  int                    command_area_len,
                  char                ** command_area,
                  char                 * preamble,
                  char                 * descript,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params);

static ESA_RC XREF_Insert_Inc_Exc(
                  char                 * inc_exc_type,
                  char                 * command_op,
                  char                 * command_area,
                  char                 * list,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params);
/*  End   WS10079   */

/* BS10134 - start */
/* UPDVAL_EOF

   Called when ADDINFO_updval return ESA_EOF (value too long).
   It issues the appropriate message and sets the isIncomplete
   keyword to Y.

    _nm - xref name.
    _pr - pair
    _data - data put in pair.
    _len - data length.
    _fld - field name for message.
    _adi - addinfo
    _em - error message variable.
                                                                     */
#define UPDVAL_EOF(_nm, _pr, _data, _len, _fld,  _adi, _em)            \
  {                                                                    \
    char    _errfunc[10] = "";                                         \
    ESA_RC   uerc = ESA_OK;                                            \
    ONE_FIELD_rec_ptr   uepr = NULL;                                   \
                                                                       \
    CTSAMSG_print(ACF2_MISSING_PERM, msgs, NULL, dest,                 \
      _pr->keyword,      /* addinfo keywrd.                     */     \
      _nm,               /* entity name.                        */     \
      _data+_pr->vallen, /* data                                */     \
      _len-_pr->vallen,  /* data length.                        */     \
      _pr->vallen,       /* current pair data length            */     \
      _fld);                                                           \
                                                                       \
    /* Set IsIncomplete   */                                           \
    uepr = ADDINFO_search("isIncomplete",                              \
             ACF_ADDINFO_KWD_LEN,                                      \
             _adi->pair,                                               \
             _adi->num_pairs);                                         \
    if (uepr NE NULL)                                                  \
    {                                                                  \
     if (uepr->value[0] NE 'Y')                                        \
     {                                                                 \
        uerc = ADDINFO_updval("Y", ACF_ADDINFO_VAL_LEN, uepr);         \
       if (uerc NE ESA_OK)                                             \
          strcpy(_errfunc, "Updating");                                \
     }                                                                 \
    }                                                                  \
    else                                                               \
    {                                                                  \
      uerc = ADDINFO_insert(TYPE_1A,                                   \
                    "isIncomplete",                                    \
                    "Y",                                               \
                    _adi,                                              \
                    ACF_ADDINFO_KWD_LEN,                               \
                    1,                                                 \
                    UNIQUE);                                           \
      if (uerc NE ESA_OK)                                              \
          strcpy(_errfunc, "Inserting");                               \
    }                                                                  \
    if (_errfunc[0] NE NULL_CHAR)                                      \
    {                                                                  \
       sprintf(_em,"%s isIncomplete failed with rc=%d",                \
               _errfunc, uerc);                                        \
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,                  \
                     component,func, _em, 16,__LINE__);                \
    }                                                                  \
  }
/* BS10134 - end   */

 /* **PS0234 START** */
 /**************************************************************
 *                                                             *
 * Title            : ACF2_Convert_Access_Levels               *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 01/02/98                                 *
 *                                                             *
 * Description      : Convert access levels fields             *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
 ESA_RC ACF2_Convert_Access_Levels(ADDINFO_rec_ptr laddinfo,
                                  CTSAMSG_DEST_TABLE_rec_ptr dest,
                                  CTSAMSG_HANDLE_rec_ptr     msgs)
 {
  /*
   *   Static Variables
   */

   static char                 func[]="ACF2_Convert_Access_Levels";

  /*
   *   Variables
   */

   ESA_RC                     rc = ESA_OK;
   ONE_FIELD_rec_ptr          pair;
   Access_Field_typ          *af;
   char                       access_code[2];

   /*-----------------------------------------------------------*/
   /* Start  ...                                                */
   /*-----------------------------------------------------------*/

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);

  access_code[1] = NULL_CHAR;

  for (af=Access_Fields_Table;
       af->Access_Field_Name[0] NE NULL_CHAR;
       af++)
   {
     pair =  ADDINFO_search(af->Access_Field_Name,
                         ACF_ADDINFO_KWD_LEN,
                         laddinfo->pair,
                         laddinfo->num_pairs);

     if (pair NE NULL) /* bs2665 divide to 2 if */
       if (pair->value[0] NE NULL_CHAR)
        {
         if (strcmp (pair->value, "ALLOW") EQ 0)
           access_code[0] = 'A';
         else if (strcmp (pair->value, "LOG") EQ 0)
           access_code[0] = 'L';
         else if (strcmp (pair->value, "PREVENT") EQ 0)
           access_code[0] = 'P';
         else
         {
           rc = ESA_FATAL;
           goto exit;
         };

       ADDINFO_updval(access_code,ACF_ADDINFO_VAL_LEN,pair);
      };
   };

  exit:

   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func, rc);

   return rc;
 }
 /* **PS0234 END** */

 /**************************************************************
 *                                                             *
 * Title            : ACF2_Convert_Dates                       *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 04/06/97                                 *
 *                                                             *
 * Description      : Convert date fields in ACF2 commands to  *
 *                    ACF2 commands                            *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
 ESA_RC ACF2_Convert_Date_Fields (ADDINFO_rec_ptr laddinfo,
                                  CTSAMSG_DEST_TABLE_rec_ptr dest,
                                  CTSAMSG_HANDLE_rec_ptr     msgs)
 {

  /*
   *   Static Variables
   */

   static char                 func[]="ACF2_Convert_Date_Fields";

  /*
   *   Variables
   */

   ESA_RC                     rc = ESA_OK;
   char                       Date_Pattern[9]="";
   char                       ACF2_Date[9]="";
   Date_Field_typ             *df;
   ONE_FIELD_rec_ptr          pair;
   int                        i;                         /* BS2665 */

   /*-----------------------------------------------------------*/
   /* Start  ...                                                */
   /*-----------------------------------------------------------*/

  ESA_DIAG_enter(PLT_COMP_API_ACF2, 11, func);

  Global_ACF2_Date_Format(Date_Pattern);

  ESA_DIAG_printf(PLT_COMP_API_ACF2,11,                      /*bs2607*/
                   "ACF2 Date Pattern: (%s)",Date_Pattern);

  for  (i = 0,df=Date_Fields_Table;
       (i LT MAX_DATE_FIELDS) AND
       (df->Date_Field_Name[0] NE NULL_CHAR) AND
      /*SAS2IBMA (df->Date_Field_Name[0] NE NULL);was NULL_CHAR BS2665*/
       (df->Date_Field_Name[0] NE (char)NULL);/*was NULL_CHAR BS2665*/
       df++,i++)
   {
     ESA_DIAG_printf(PLT_COMP_API_ACF2,11,                   /*bs2607*/
         "search date field: (%s) for counter=(%d)",         /*BS2665*/
         df->Date_Field_Name,i);

     pair =  ADDINFO_search(df->Date_Field_Name,
                         ACF_ADDINFO_KWD_LEN,
                         laddinfo->pair,
                         laddinfo->num_pairs);

   /*if ( (pair NE NULL) AND (pair->value[0] NE NULL_CHAR) ) BS2665 */
     if (pair NE NULL)
     {
      ESA_DIAG_printf(PLT_COMP_API_ACF2,11,                /*BS2665*/
         "pair NE NULL pair->value=(%s)",
         pair->value);
      if (pair->value[0] NE NULL_CHAR)
      {
       CTSCDAT_conv2RSS(PLT_COMP_API_ACF2,                  /*IS10009*/
                        Date_Pattern,pair->value,ACF2_Date,
                        dest,msgs);

       ESA_DIAG_printf(PLT_COMP_API_ACF2,11,                /*IS10009*/
       "ESS date 2 b converted:<%s> ACF2_date_pat:<%s> ACF2_date:<%s>",
       pair->value,Date_Pattern,ACF2_Date);

       /*BS10007 ESA_DIAG_printf(PLT_COMP_API_ACF2,11,     /*BS2665*
          "pair->value[0] NE NULL_CHAR. Calls ADDINFO_updval");     */
        ADDINFO_updval(ACF2_Date,ACF_ADDINFO_VAL_LEN,pair);
      }; /* end of (pair->value[0] NE NULL_CHAR) BS2665 */
     }; /* end of (pair NE NULL)*/
   }; /* end of for loop */

  exit:
   ESA_DIAG_exit(PLT_COMP_API_ACF2, 11, func, rc);
   return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : Reset_Field                              *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Reset Field to initial value and then    *
 *                    optionally copy other field as init.     *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
 void Reset_Field(char *field,
                  int  field_size,
                  char Init_Char,
                  char *in_field)
 {
   memset(field,0X00,field_size);
   memset(field,Init_Char,field_size-1);
   if (in_field NE NULL)
    memcpy(field,in_field,strlen(in_field));
 }

 /**************************************************************
 *                                                             *
 * Title            : Round_Number                             *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Round number to the nearest multiply     *
 *                    of X                                     *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
 int  Round_Number(int Num, int X)
 {
  if ( (Num % X) EQ 0)
   return(Num);
  else
   return(Num + X - (Num % X));
 }

 /**************************************************************
 *                                                             *
 * Title            : Convert_Mutli_to_Vec                     *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Convert Mutli Value Field to Vec         *
 *                                                             *
 * Input            : Multi   : Multi value field              *
 *                    Max_Entry: Larget entry in field         *
 *                                                             *
 * Output           : Count : Number of entries detected       *
 *                    Vec   : Entries vec                      *
 *                    reason_code     : when error occured     *
 *                     8 : Entry size larger than limit        *
 *                    12 : Max num of UIDMASKS exceeded        *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem                      *
 *                    else   : error - see reason_code         *
 *                                                             *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
ESA_RC Convert_Multi_to_Vec(char *Multi,
                            int *Count,
                            char **Vec,
                            int  Max_Entry,
                            int *reason_code)             /* BS2306 */
{
 static char func[] = "Conver_Multi_to_Vec";

 ESA_RC rc = ESA_OK;

 char Temp[1024]="";
 char *End_Of_Entry;
 char *Begin_Of_Entry;
 char sep[2];

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);

 ESA_DIAG_printf(PLT_COMP_API_ACF2,1,
                   "multi-UIDMASKS 1 (%s)",Multi);

 sep[0] = ADDINFO_LIST_ENTRY;
 sep[1] = NULL_CHAR;

 (*Count) = 0;

 if ( Multi[0] EQ NULL_CHAR )
  {
   (*Count) = 0;
   goto exit;
  };

 strcpy(Temp,Multi);
 strcat(Temp,sep);

 ESA_DIAG_printf(PLT_COMP_API_ACF2,1,
                   "multi-UIDMASKS 2 (%s)",Multi);

 Begin_Of_Entry = Temp;

 do
  {
   End_Of_Entry = strpbrk(Begin_Of_Entry,sep);
   (*End_Of_Entry) = NULL_CHAR;

   if ( (End_Of_Entry - Begin_Of_Entry) GE Max_Entry)
    {
     (*reason_code) = 8;                                  /* BS2306 */
     rc = ESA_FATAL;
     goto exit;
    };

   /* **BS2306 START** */

   if ((*Count) GE ACF2_MAX_GRP_UIDMASKS)
    {
     (*reason_code) = 12;
     rc = ESA_FATAL;
     goto exit;
    };

   /* **BS2306 END** */

 ESA_DIAG_printf(PLT_COMP_API_ACF2,1,
                   "multi-UIDMASKS 3 (%s)",Multi);
   ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_ALL,
                   "before Entry (%d) Val(%s)",*Count,Vec[*Count]);

   Reset_Field(Vec[*Count],Max_Entry,0X00,Begin_Of_Entry);

   ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_ALL,
                   "After Entry (%d) Val(%s)",*Count,Vec[*Count]);

   (*Count)++;

   Begin_Of_Entry = End_Of_Entry+1;

  } while( (*Begin_Of_Entry) NE NULL_CHAR);

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func,rc);

 return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : ACF2_Get_Group_UIDMASKS                  *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Get GROUP record UIDMASKS field as count+*
 *                    vector of UIDMASK elements.              *
 *                    2 modes of operation are available:      *
 *                    - if non-empty addinfo is supplied, get  *
 *                      uidmasks from there.                   *
 *                    - else, read group record and extract    *
 *                      uidmasks from record.                  *
 *                                                             *
 * Input            : Group   : Group Name to process          *
 *                    laddinfo: optional Group addinfo/work    *
 *                    ctsamsg stuff                            *
 *                                                             *
 * Output           : Group_UID_Count : number of uidmasks     *
 *                    Group_UID       : uidmasks vector        *
 *                    reason_code     : when error occured     *
 *                     4 : UIDMASKS field not found            *
 *                     8 : Group Not Found                     *
 *                    12 : Internal Error                      *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem in new group         *
 *                    else   : Correlative group found         *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
ESA_RC ACF2_Get_Group_UIDMASKS(char *group,
                               int  *Group_UID_Count,
                               UIDMASK Group_UID[1],
                               ADDINFO_rec_ptr laddinfo,
                               int *reason_code,
 /*WS10076A*/                  ADMIN_PARAMS_rec_typ * admin_params)
 /*WS10076A                    CTSAMSG_DEST_TABLE_rec_typ  * dest,
                               CTSAMSG_HANDLE_rec_typ      * msgs)
                           * BS2306 - added dest+msgs parms         */
{
 static char func[]="ACF2_Get_Group_UIDMASKS";

 ACF2_API_Return_Codes ACF2_rc;
 ESA_RC rc = ESA_OK;
 int i, convert_reason_code;                              /* BS2306 */
 UIDMASK *Group_UID_ptr[ACF2_MAX_GRP_UIDMASKS];           /* BS2306 */
 ONE_FIELD_rec_ptr pair;
 CTSAMSG_HANDLE_rec_typ      * msgs;                    /*WS10076A*/
 CTSAMSG_DEST_TABLE_rec_typ  * dest;                    /*WS10076A*/

 msgs = admin_params->ctsamsg_handle;                   /*WS10076A*/
 dest = admin_params->ctsamsg_dest;                     /*WS10076A*/

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);
 msgs = admin_params->ctsamsg_handle;                     /*WS10076A*/
 dest = admin_params->ctsamsg_dest;                       /*WS10076A*/

 if (laddinfo->num_pairs EQ 0)
   ACF2_rc = ACF2_Get_Group(GDB_Exact_Locate, group, laddinfo,
                            NULL, NULL,                  /* WS10076S */
                            admin_params);               /* WS10076A */
 else
   goto Process_UIDMASKS;

 switch(ACF2_rc)
  {
   case ACF2_OK:
    break;

   case ACF2_Not_Found:
    (*reason_code) = 8;
    rc = ESA_FATAL;
    goto exit;

   default:
    (*reason_code) = 12;
    rc = ESA_FATAL;
    goto exit;
 };

  Process_UIDMASKS:

  pair = ADDINFO_search("UIDMASKS",
                        ACF_ADDINFO_KWD_LEN,
                        laddinfo->pair,
                        laddinfo->num_pairs);
  if (pair EQ NULL)
   {
     rc = ESA_FATAL;
     (*reason_code) = 4;
     goto exit;
   };

  for(i=0;i LT ACF2_MAX_GRP_UIDMASKS;i++)                 /* BS2306 */
   Group_UID_ptr[i] = &(Group_UID[i]);

  rc = Convert_Multi_to_Vec(pair->value,                  /* BS2306 */
                            Group_UID_Count,
                            (char **)Group_UID_ptr,
                            ACF2_UID_SIZE,
                            &convert_reason_code);        /* BS2306 */

  /* **BS2306 START** */

  if (rc NE ESA_OK)
   {
     switch(convert_reason_code)
      {
       case 8:
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                 "Addinfo entry len too big", 16,__LINE__);
        break;

       case 12:
        CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
                 "Max num of UIDMASKS exceeded", 16,__LINE__);
        break;

       default:
        break;
     };

     rc = ESA_FATAL;
     (*reason_code) = 12;
     goto exit;
   };

  /* **BS2306 END** */

  for(i=0;i LT (*Group_UID_Count);i++)
   ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_ALL,
                   "Group %s, UIDMASK[%d] = %s",
                   group,i,Group_UID[i]);
 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func,rc);
 return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : ACF2_Check_User_Force_Disconnect_from_Group *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Check that a change in user's uid string *
 *                    does not disconnect him from any group he*
 *                    is connected to. Return disc'ed group    *
 *                    name.                                    *
 *                                                             *
 *                    This routine reads all the Groups the user*
 *                    is connected to and sees if the modified *
 *                    uid string remains connected.            *
 *                                                             *
 * Input            : old_uid : User's uid before change       *
 *                    new_uid : User's uid after change        *
 *                    laddinfo: work addinfo                   *
 *                    ctsamsg stuff                            *
 *                                                             *
 * Output           : cgroup  : disconnected-group             *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem in UID modification  *
 *                    else   : disconnected group found        *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
ESA_RC Check_User_Force_Disconnect_from_Group( UIDMASK old_uid,
                               UIDMASK new_uid,
                               UG_typ  cgroup,
                               ADDINFO_rec_ptr laddinfo,
 /*WS10076A*/                  ADMIN_PARAMS_rec_typ * admin_params)
 /*WS10076A                    CTSAMSG_DEST_TABLE_rec_typ  * dest,
                               CTSAMSG_HANDLE_rec_typ      * msgs)*/
                          /* BS2306 - added dest+msgs parms         */
{

  static char func[] = "Check_Force_Disconnect";

  ESA_RC rc = ESA_OK;
  ACF2_API_Return_Codes ACF2_rc;
  int i;

  int OGroup_UID_Count;
  UIDMASK OGroup_UID[ACF2_MAX_GRP_UIDMASKS];              /* BS2306 */

  int reason_code = 0;
  UG_typ Current_Group="";
  CTSAMSG_HANDLE_rec_typ      * msgs;                    /*WS10076A*/
  CTSAMSG_DEST_TABLE_rec_typ  * dest;                    /*WS10076A*/

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);
  msgs = admin_params->ctsamsg_handle;                   /*WS10076A*/
  dest = admin_params->ctsamsg_dest;                     /*WS10076A*/

  ADDINFO_empty(laddinfo);

  ACF2_rc = ACF2_Get_Group(GDB_Generic_Locate,
                           Current_Group,
                           laddinfo,
                           NULL, NULL,                   /* WS10076S */
                           admin_params);                /* WS10076A */

  while(ACF2_rc EQ ACF2_OK)
   {
     rc = ACF2_Get_Group_UIDMASKS(Current_Group,
                                  &OGroup_UID_Count,
                                  OGroup_UID,
                                  laddinfo,
                                  &reason_code,
                                  admin_params);          /* WS10076A *
                                  dest,                    * BS2306 *
                                  msgs);                   * BS2306 */


     if (rc NE ESA_OK)
      goto exit;

     for (i=0;i LT OGroup_UID_Count;i++)
      {
       if (ACF2_Match_Id_to_Mask(UID_Object,old_uid,OGroup_UID[i])
          EQ TRUE)
          goto Check_New_UID;
       };
     goto Next_Group;

     Check_New_UID:

     for (i=0;i LT OGroup_UID_Count;i++)
      {
       if (ACF2_Match_Id_to_Mask(UID_Object,new_uid,OGroup_UID[i])
          EQ TRUE)
          goto Next_Group;
       };

   rc = ESA_ERR;
   strcpy(cgroup,Current_Group);
   goto exit;

   Next_Group:

   ADDINFO_empty(laddinfo);
   ACF2_rc = ACF2_Get_Group(GDB_Next_Locate,
                       Current_Group,
                       laddinfo,
                       NULL, NULL,                      /* WS10076S */
                       admin_params);                   /* WS10076A */

   };

  rc = ESA_OK;

  exit:
   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func, rc);
   return rc;
}

 /* PS0354 - New function */
 /**************************************************************
 *                                                             *
 * Title            : ACF2_Check_Mult_Force_Disconnect_from_Group *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 09/12/98                                 *
 *                                                             *
 * Description      : Check that a change in user's uid string *
 *                    does not disconnect him from any group he*
 *                    is connected to. Return disc'ed group    *
 *                    name.                                    *
 *                                                             *
 *                    This routine reads all the Groups the user*
 *                    is connected to and sees if the modified *
 *                    uid string remains connected.            *
 *                                                             *
 * Input            : old_uids: User's UIDs before change      *
 *                    new_uids: User's UIDs after change       *
 *                    laddinfo: work addinfo                   *
 *                    ctsamsg stuff                            *
 *                                                             *
 * Output           : cgroup  : disconnected-group             *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem in UID modification  *
 *                    else   : disconnected group found        *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 **************************************************************/
ESA_RC Check_Mult_Force_Disconnect_from_Group( char *old_uids,
                               char *new_uids,
                               UG_typ  cgroup,
                               ADDINFO_rec_ptr laddinfo,
 /*WS10076A*/                  ADMIN_PARAMS_rec_typ * admin_params)
 /*WS10076A                    CTSAMSG_DEST_TABLE_rec_typ  * dest,
                               CTSAMSG_HANDLE_rec_typ      * msgs)*/
{

  static char func[] = "Check_Multi_Disconnect";

  ESA_RC rc = ESA_OK;
  ACF2_API_Return_Codes ACF2_rc;
  UIDMASK OGroup_UID[ACF2_MAX_GRP_UIDMASKS];
  UIDMASK current_user_old_uid;
  UG_typ Current_Group="";
  int OGroup_UID_Count;
  int reason_code = 0;
  int num_old_uids, num_new_uids;
  int i, j;
  CTSAMSG_HANDLE_rec_typ      * msgs;                    /*WS10076A*/
  CTSAMSG_DEST_TABLE_rec_typ  * dest;                    /*WS10076A*/

  ESA_DIAG_enter(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL, func);
  msgs = admin_params->ctsamsg_handle;                   /*WS10076A*/
  dest = admin_params->ctsamsg_dest;                     /*WS10076A*/

  ADDINFO_empty(laddinfo);

  num_old_uids = 1;
  num_new_uids = 1;

  /******************************************************************/
  /* Count number of old and new UIDs                               */
  /******************************************************************/
  for (i=0; i LT strlen(old_uids); i++)
    if (old_uids[i] EQ ADDINFO_LIST_ENTRY)
      num_old_uids++;

  for (i=0; i LT strlen(new_uids); i++)
    if (new_uids[i] EQ ADDINFO_LIST_ENTRY)
      num_new_uids++;

  ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL,
                  "num old_uids(%d) new_uids(%d)",
                  num_old_uids, num_new_uids);

  ACF2_rc = ACF2_Get_Group(GDB_Generic_Locate,
                           Current_Group,
                           laddinfo,
                           NULL, NULL,                   /* WS10076S */
                           admin_params);                /* WS10076A */

  /******************************************************************/
  /* Scan all groups in GDB.                                        */
  /* For each group, check if it is connected to the old UIDs_List  */
  /* If it is, check if it is STILL connected to the new UIDs_List. */
  /******************************************************************/
  while(ACF2_rc EQ ACF2_OK)
  {
    rc = ACF2_Get_Group_UIDMASKS(Current_Group,
                                 &OGroup_UID_Count,
                                 OGroup_UID,
                                 laddinfo,
                                 &reason_code,
                                 admin_params);       /* WS10076A *
                                 dest,
                                 msgs);                           */


    if (rc NE ESA_OK)
     goto exit;

    /****************************************************************/
    /* Scan all OLD UIDs of user                                    */
    /****************************************************************/
    for (j=0; j LT num_old_uids; j++)
    {
      Reset_Field(current_user_old_uid,
                  sizeof(UIDMASK),
                  0X00,
                  NULL);

      Reset_Field(current_user_old_uid,
                  (sizeof(UIDMASK)-1),
                  ' ',
                  NULL);

      memcpy (current_user_old_uid,
              (old_uids+(j*ACF2_UID_SIZE)),
              (ACF2_UID_SIZE-1));

      /**************************************************************/
      /* Scan all UIDMASKS of current group                         */
      /**************************************************************/
      for (i=0;i LT OGroup_UID_Count;i++)
      {
        ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL,
                        "Compare: Group(%s) UIDMASK(%s) User_UID(%s)",
                        Current_Group,
                        OGroup_UID[i],
                        current_user_old_uid);

        if (ACF2_Match_Id_to_Mask(UID_Object,
                                  current_user_old_uid,
                                  OGroup_UID[i]) EQ TRUE)
        {
          ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL,
                          "Connection found! Check in NEW UIDs");

          /**********************************************************/
          /* Is this group connected to NEW UIDs ?                  */
          /**********************************************************/
          if (NOT ACF2_Connected_To_New_UIDs (num_new_uids,
                                              new_uids,
                                              OGroup_UID_Count,
                                              OGroup_UID))
          {
            ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL,
                            "Connection not found in NEW_UIDS !");
            rc = ESA_ERR;
            strcpy(cgroup,Current_Group);
            goto exit;
          };
        };
      }; /* End of Current Group UIDMASKS loop */
    }; /* End of Current User UID loop */

    ADDINFO_empty(laddinfo);

    ACF2_rc = ACF2_Get_Group(GDB_Next_Locate,
                        Current_Group,
                        laddinfo,
                        NULL, NULL,                      /* WS10076S */
                        admin_params);                   /* WS10076A */

  }; /* End of GDB scan loop */

  rc = ESA_OK;

  exit:;

  ESA_DIAG_exit(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL, func, rc);

  return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : ACF2_Connected_To_New_UIDs               *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 13/12/98                                 *
 *                                                             *
 * Description      : Check that a group is connected to       *
 *                    new User UIDs.                           *
 *                    New User UIDs are the User UIDs after    *
 *                    a 'Update User' command.                 *
 *                                                             *
 * Input            : Num_UIDs : Number of new UIDs            *
 *                    New_UIDs : List of New UIDs              *
 *                    Num_UIDM : Number of Group UIDMASKs      *
 *                    UG_UIDM  : List of Group UIDMASKs        *
 *                                                             *
 * Output           : None                                     *
 *                                                             *
 * Return Codes     : TRUE or FALSE                            *
 *                                                             *
 **************************************************************/
 static int ACF2_Connected_To_New_UIDs (int        Num_UIDs,
                                        char      *New_UIDs,
                                        int        Num_UIDM,
                                        UIDMASK    UG_UIDM[1])
 {
   static char func[] = "ACF2_Connected_To_New_UIDs";

   UIDMASK      current_user_new_uid;
   int          conn_exists;
   int          i,j;

   ESA_DIAG_enter(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL, func);

   conn_exists = FALSE;

   /**********************************************************/
   /* Scan all NEW UIDs of user                              */
   /**********************************************************/
   for (i=0; i LT Num_UIDs; i++)
   {
     Reset_Field(current_user_new_uid,
                 sizeof(UIDMASK),
                 0X00,
                 NULL);

     Reset_Field(current_user_new_uid,
                 (sizeof(UIDMASK)-1),
                 ' ',
                 NULL);

     memcpy (current_user_new_uid,
             (New_UIDs+(i*ACF2_UID_SIZE)),
             (ACF2_UID_SIZE-1));

     /************************************************************/
     /* Scan all Group UIDMASKs                                  */
     /************************************************************/
     for (j=0;j LT Num_UIDM;j++)
     {
       ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL,
                       "Compare UIDMASK(%s) NEW_UID(%s)",
                       UG_UIDM[j],
                       current_user_new_uid);

       if (ACF2_Match_Id_to_Mask(UID_Object,
                                 current_user_new_uid,
                                 UG_UIDM[j]) EQ TRUE)
       {
         ESA_DIAG_printf(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL,
                         "Connection found. End NEW_UIDS check");
         conn_exists = TRUE;
         goto exit;
       };
     };
   };

   exit:;

   ESA_DIAG_exit(ESA_COMP_UPDUSER, DEBUG_SHOW_ALL, func, conn_exists);

   return conn_exists;

 }
 /* End of PS0354 */

 /**************************************************************
 *                                                             *
 * Title            : Check_Group_Correlation                  *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Check that a group is not associated     *
 *                    with other group in such a way that disc *
 *                    from group 1 will affect the user connec-*
 *                    tion to group 2.                         *
 *                                                             *
 *                    Example: if group-1 is "BC" and          *
 *                                group-2 is "B"  then         *
 *                    If User X is connected to group-1 and    *
 *                    group-2, He cant be disconnected from    *
 *                    just one of them.                        *
 *                                                             *
 * Input            : Group   : New Group Name                 *
 *                    addinfo : New Group addinfo              *
 *                    laddinfo: work addinfo                   *
 *                    ctsamsg stuff                            *
 *                                                             *
 * Output           : cgroup  : Correlative Group              *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem in new group         *
 *                    else   : Correlative group found         *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 *   See Also       : main reamark in CTSBIUG                  *
 *                                                             *
 **************************************************************/
ESA_RC Check_Group_Correllation(UG_typ Group,
                                ADDINFO_rec_ptr addinfo,
                                UG_typ  cgroup,
                                ADDINFO_rec_ptr laddinfo,
                                CTSAMSG_DEST_TABLE_rec_typ  * dest,
                                CTSAMSG_HANDLE_rec_typ      * msgs,
 /*IS10088*/                    ADMIN_PARAMS_rec_typ * admin_params)
                          /* BS2306 - added dest+msgs parms         */
{

  static char func[] = "Check_Group_Correllation";

  ESA_RC rc = ESA_OK;
  ACF2_API_Return_Codes ACF2_rc;
  /********  move to Check_Group_UIDMASKS  ********          IS10128 */
  /*IS10128 ACF2_PARAMS_rec_typ * params_ptr = NULL;       * IS10088 */
  /*IS10128 int tuidlen;                                   * IS10088 */

  int Group_UID_Count;
  UIDMASK Group_UID[ACF2_MAX_GRP_UIDMASKS];               /* BS2306 */
  int TGroup_UID_Count;
  UIDMASK TGroup_UID[ACF2_MAX_GRP_UIDMASKS];              /* BS2306 */
  int reason_code, gindex = 0, tindex = 0;
  UG_typ Current_Group="";

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);

  rc = ACF2_Get_Group_UIDMASKS(Group,
                               &Group_UID_Count,
                               Group_UID,
                               addinfo,
                               &reason_code,
                               admin_params);             /*WS10076A*
                               dest,                       * BS2306 *
                               msgs);                      * BS2306 */

  if (rc NE ESA_OK)                                       /* BS2306 */
   goto exit;                                             /* BS2306 */

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                  "Checked group: <%s) and Group_UID: <%s>",
                  Group,Group_UID);                       /*IS10088*/

  /* IS10128 move IS10088 to Check_Group_UIDMASKS            */
  /* IS10088 start - test if uidlen from ESS > ACF2's uidlen *
  tuidlen = strlen((char *) Group_UID);
  if (tuidlen GT 0) {
    params_ptr = admin_params->apiinit_handle;
    ESA_DIAG_printf(PLT_COMP_API_ACF2,1,
      "ACF2 uidlen =<%d> ", params_ptr->uidlen);
    if (tuidlen GT params_ptr->uidlen) {
      ESA_DIAG_printf(PLT_COMP_API_ACF2,1,
        "(%s) length (%d) is longer than ACF2 uidlen (%d)",
        Group_UID,tuidlen,params_ptr->uidlen);
      CTSAMSG_print(UIDMASK_GT_UIDLEN,msgs,NULL,dest,
                    Group_UID,tuidlen,params_ptr->uidlen);
      rc = ESA_SKIP; /* msg issued sign in rc to upper levels *
      goto exit;
    }
  } /* end of uidlen test IS10088 */
  /******* end of drop by IS10128 as moved to Check_Group_UIDMASKS */

  ADDINFO_empty(laddinfo);
  ACF2_rc = ACF2_Get_Group(GDB_Generic_Locate,
                      Current_Group,
                      laddinfo,
                      NULL, NULL,                        /* WS10076S */
                      admin_params);                     /* WS10076A */

  while(ACF2_rc EQ ACF2_OK)
   {

    if (strcmp(Current_Group,Group) EQ 0)
     goto Next_Group;

    rc = ACF2_Get_Group_UIDMASKS(Current_Group,
                                 &TGroup_UID_Count,
                                 TGroup_UID,
                                 laddinfo,
                                 &reason_code,
                                 admin_params);           /*WS10076A*
                                 dest,                     * BS2306 *
                                 msgs);                    * BS2306 */

    if (rc NE ESA_OK)
     goto exit;

    rc = Check_UIDMASKS_Correllation(Group_UID_Count,
                                     Group_UID,
                                     TGroup_UID_Count,
                                     TGroup_UID,
                                     &gindex,
                                     &tindex);

   if (rc NE ESA_OK)
    {
     strcpy(cgroup,Current_Group);
     goto exit;
    };

   Next_Group:

   ADDINFO_empty(laddinfo);
   ACF2_rc = ACF2_Get_Group(GDB_Next_Locate,
                       Current_Group,
                       laddinfo,
                       NULL, NULL,                       /* WS10076S*/
                       admin_params);                    /*WS10076A*/

   };

  exit:
   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func, rc);
   return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : Check_UIDMASKS_Correllation              *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Check that 2 sets of UIDMASKS do not     *
 *                    correllate as described in               *
 *                    Check_Group_Correllation.                *
 * Input            : u1_count: first set, uidmask count       *
 *                  : uidmask1: first set, uidmasks vector     *
 *                  : u2_count: secnd set, uidmask count       *
 *                  : uidmask2: secnd set, uidmasks vector     *
 *                                                             *
 * Output           : u1_index: Index of correlated uidmask in *
 *                              set 1                          *
 *                  : u2_index: Index of correlated uidmask in *
 *                              set 2                          *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem                      *
 *                    else   : Correlative uidmasks found      *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 *   See Also       : main reamark in CTSBIUG                  *
 *                                                             *
 **************************************************************/
static ESA_RC Check_UIDMASKS_Correllation(int     u1_count,
                                          UIDMASK uidmask1[1],
                                          int     u2_count,
                                          UIDMASK uidmask2[1],
                                          int     *u1_index,
                                          int     *u2_index)
{

  static char func[] = "Check_UIDMASKS_Correllation";

  ESA_RC rc = ESA_OK;

  int i,j;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);

  for(i=0;i LT u1_count;i++)
   for(j=0;j LT u2_count;j++)
    {
      if (Check_UID_Correllate(uidmask1[i],uidmask2[j]) NE ESA_OK)
        {
         *u1_index = i;
         *u2_index = j;
         rc = ESA_ERR;
        };
     };

  exit:
   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func, rc);
   return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : Check_UID_Correllation                   *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : service routine for Check_UIDMASKS_Corre.*
 *                    check 2 specific UIDMASKS dont correlate *
 *                                                             *
 * Input            : uidmask1: uidmask 1                      *
 *                  : uidmask2: uidmask 2                      *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem                      *
 *                    else   : Correlative uidmasks found      *
 * Assumptions and                                             *
 *   Considerations :                                          *
 *                                                             *
 *   See Also       : main reamark in CTSBIUG                  *
 *                                                             *
 **************************************************************/
static int Check_UID_Correllate(UIDMASK uid1,
                                UIDMASK uid2)
{
 static char func[] = "Check_UID_Correllate";

  ESA_RC rc = ESA_OK;
  int i, search_length, field_offset;
  char field_name[ACF2_LID_SIZE]="";
  UIDMASK luid1="" , luid2 = "";

  ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL,
                 "UID1 (%s) , UID2(%s)",uid1,uid2);

  search_length = MAX(strlen(uid1),strlen(uid2));

  Reset_Field(luid1,search_length+1,'*',uid1);
  Reset_Field(luid2,search_length+1,'*',uid2);

  for (i=0;i LT search_length;i++)
   {
    if ( (luid1[i] EQ '*') OR (luid2[i] EQ '*') )
     continue;

    if (luid1[i] EQ luid2[i])
     {
     /* IS10088
      rc = ESA_ERR;
      Convert_UID_Offset_to_Field_Name(i,field_name,&field_offset);
      if (strcmp(field_name,"LID") EQ 0)
       rc = ESA_OK;                                                  */
      /* IS10088 - handle Convert_UID_Offset_to_Field_Name rc        */
      rc = Convert_UID_Offset_to_Field_Name(i,field_name,&field_offset);
      if (rc EQ ESA_OK)                                     /* IS10088*/
        if (strcmp(field_name,"LID") NE 0)                  /* IS10088*/
          rc = ESA_ERR;                                     /* IS10088*/
     }
    else
     {
      rc = ESA_OK;
      goto exit;
     };

   };

  exit:;
   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func, rc);
   return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : Convert_Keyword_Chars                    *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : Convert certain chars in addinfo keywords*
 *                    to others (specifically used to convert  *
 *                    underscores to minus).                   *
 *                                                             *
 * Input            : addinfo - addinfo to convert             *
 *                    from_char - char to convert              *
 *                    to_char   - char to convert to           *
 *                                                             *
 * Return Codes     : None                                     *
 **************************************************************/
void Convert_Keyword_Chars(ADDINFO_rec_ptr addinfo,
                           char from_char,
                           char to_char)
{
 static char func[] = "Convert_Keyword_Chars";

 int i;
 ONE_FIELD_rec_ptr pair = NULL;
 char from_str[2]=" ";

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func);

 from_str[0]=from_char;

 for (i=0;i LT addinfo->num_pairs;i++)
  {
   pair = ADDINFO_get_next(addinfo,pair);
   while(strpbrk(pair->keyword,from_str) NE NULL)
     *strpbrk(pair->keyword,from_str) = to_char;
  };

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_ALL, func, ESA_OK);
}
 /**************************************************************
 *                                                             *
 * Title            : ACF2_Match_Id_to_Mask                    *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 07/07/97                                 *
 *                                                             *
 * Description      : check a string (or a mask) agains  a mask.*
 *                    returns if there is a match or not.      *
 *                                                             *
 *                    2 types of comparisons are supported:    *
 *                                                             *
 *                    LID - String lengths are important. an   *
 *                          asterisk represent a single-char   *
 *                          even if located at end of mask.    *
 *                                                             *
 *                    UID - String lengths are not important.  *
 *                          asterisk represent a single-char   *
 *                          if in the middle of UID but represent *
 *                          all_match if located as last char  *
 *                          of UID.                            *
 *                                                             *
 * Input            : object_type - LID/UID                    *
 *                    id        - string/mask                  *
 *                    mask      - target mask to check         *
 *                                                             *
 * Return Codes     : TRUE - id match mask                     *
 *                  : FALSE- id dont match mask                *
 **************************************************************/
int ACF2_Match_Id_to_Mask(ACF2_Object_Type object_type,
                          char             *Object,
                          char             *Mask)
{
 int compare_size, i, rc;

 UIDMASK object, mask;

 /**************************************************************
 * Allign objects according to object type                     *
 **************************************************************/
 switch(object_type)
  {
   /**************************************************************
    * For UIDs, flud objects with asterisks to size of the longer*
    *           object.                                          *
    **************************************************************/
   case UID_Object:
    compare_size = MAX(strlen(Mask),strlen(Object));
  /*Reset_Field(object,compare_size+1,'*',Object); */      /* PS0458 */
    Reset_Field(object,compare_size+1,' ',Object);         /* PS0458 */
    Reset_Field(mask,compare_size+1,'*',Mask);
    break;
   /**************************************************************
    * For LIDs, set compare size to the shorter string           *
    **************************************************************/
   case LID_Object:
    compare_size = MIN(strlen(Mask),strlen(Object));
    strcpy(object,Object);
    strcpy(mask,Mask);
   default:;
  };

 rc = TRUE;

 /* Preliminary check :
    if mask is shorter then obj and last mask char is '*'
    then a match is impossible ('*' wild cards represent single
    char). We define as TRUE a case where LID "prefix" as ID is compared
    with LIDMASK */

 if ( object_type EQ LID_Object )
  if ( strlen(mask) LT strlen(object) )
   if (mask[strlen(mask)-1] EQ '*')
    return FALSE;

 ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,
                 "Match_IdMask:object=%s  objlen=%d mask=%s masklen=%d",
                 object, strlen(object), mask, strlen(mask));

 /* for (i=0; i LT compare_size ; i++) BS10049 */
 for (i=0; (i LT compare_size) AND (rc EQ TRUE); i++) /*BS10049*/
  {
   switch(mask[i])
    {
     case '*':
         break;   /* skip to next char */

     case '-':    /* Treat - as match any only if last char,
                     else, it as as any other char */
         if (i EQ strlen(mask)-1)
           break;
         /* continue with default processing if previous condition
            not met */

     default:
         if (object[i] NE '*')     /* Support masking char in object */
          if (object[i] NE mask[i])
            rc = FALSE;
    };
  };
 ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_REGULAR,
                 "Final RC is %d",rc);
 return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : Check_Group_UIDMASKS                     *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 05/08/97                                 *
 *                                                             *
 * Description      : check group's uidmasks field for:        *
 *                                                             *
 *                    a. There is a UIDMASKS sub-field which   *
 *                       is not null (at least one uidmask).   *
 *                                                             *
 *                    b. there's no uidmask which is equivalent*
 *                       to all asterisk field (in uids, '*' = *
 *                       '****' = '**********' = '-')          *
 *                                                             *
 *                    c. there's no uidmask which is all       *
 *                       asteriks in all non-LID fields        *
 *                       (all asteriks except for LID)         *
 *                                                             *
 *      PS0345        d. there's no uidmask with a partial     *
 *                       mask on a MULTIVALUED field (in UID). *
 *                                                             *
 *      PS0345        e. there's no uidmask with a value       *
 *                       in a MULTIVALUED field which is not   *
 *                       the first one in the UID (the only    *
 *                       REAL MULTIVALUED field in the UID !)  *
 *                                                             *
 *                                                             *
 * Input            : group                                    *
 *                    addinfo   - received at insert or update *
 *                    ctsamsg stuff                            *
 *                                                             *
 * Return Codes     : ESA_OK - group is ok                     *
 *                  : other  - problem, message issued         *
 **************************************************************/
ESA_RC Check_Group_UIDMASKS(UG_typ                      group,
                            ADDINFO_rec_ptr             addinfo,
 /*IS10128*/                ADMIN_PARAMS_rec_typ * admin_params)
 /*drop by IS10128 as admin_params CTSAMSG_DEST_TABLE_rec_typ  * dest,
                                   CTSAMSG_HANDLE_rec_typ      * msgs)*/
{
   ESA_RC rc = ESA_OK;
   int i, reason_code, Group_UID_Count;
   UIDMASK  ALL_ASTERISK;
   UIDMASK  Group_UID[ACF2_MAX_GRP_UIDMASKS];             /* BS2306 */
   ACF2_PARAMS_rec_typ * params_ptr = NULL;               /* IS10128 */
   char                 iiqAcf2Groups = ' ';              /* IS10128 */
   int tuidlen;                                           /* IS10128 */
   CTSAMSG_HANDLE_rec_typ      * msgs;                    /* IS10128 */
   CTSAMSG_DEST_TABLE_rec_typ  * dest;                    /* IS10128 */

   msgs = admin_params->ctsamsg_handle;                   /* IS10128 */
   dest = admin_params->ctsamsg_dest;                     /* IS10128 */
   Reset_Field(ALL_ASTERISK,sizeof(ALL_ASTERISK),'*',NULL);

   /* Match UIDMASKS to uppercase */

   Upper_UIDMASKS(addinfo);                               /* BS2309 */

   rc = ACF2_Get_Group_UIDMASKS(group,
                                &Group_UID_Count,
                                Group_UID,
                                addinfo,
                                &reason_code,
                                admin_params);            /* WS10076A*
                                dest,                      * BS2306 *
                                msgs);                     * BS2306 */

   if (rc NE ESA_OK)
    if (reason_code EQ 4)                                 /* BS2306 */
     {                   /* No UIDMASKS in addinfo, good for update */
      rc = ESA_OK;
      goto exit;
     }
    else
     goto exit;

   if (Group_UID_Count EQ 0)
    {
      CTSAMSG_print(ACF2_NO_UIDMASKS,msgs,NULL,dest,group);
      rc = ESA_FATAL;
      goto exit;
    };

  /* IS10128 move IS10088 code here as this should be done even
   *         when IIQACF2GROUPS = 'Y' .                      */
  /* IS10088 start - test if uidlen from ESS > ACF2's uidlen */
  tuidlen = strlen((char *) Group_UID);
  if (tuidlen GT 0) {
    params_ptr = admin_params->apiinit_handle;
    ESA_DIAG_printf(PLT_COMP_API_ACF2,6,
      "ACF2 uidlen =<%d> ", params_ptr->uidlen);
    if (tuidlen GT params_ptr->uidlen) {
      ESA_DIAG_printf(PLT_COMP_API_ACF2,1,
        "(%s) length (%d) is longer than ACF2 uidlen (%d)",
        Group_UID,tuidlen,params_ptr->uidlen);
      CTSAMSG_print(UIDMASK_GT_UIDLEN,msgs,NULL,dest,
                    Group_UID,tuidlen,params_ptr->uidlen);
      rc = ESA_SKIP; /* msg issued sign in rc to upper levels */
      goto exit;
    }
  } /* end of uidlen test IS10088 */
   /* BS2307 - added second condition to following IF statement */
 /*params_ptr = admin_params->apiinit_handle; done above   *IS10128*/
   iiqAcf2Groups = params_ptr->rssparm_IIQACF2GROUPS[0];  /*IS10128*/
   if (iiqAcf2Groups NE 'Y')                              /*IS10128*/
   {

   for (i=0;i LT Group_UID_Count;i++)
    if ( (memcmp(Group_UID[i],ALL_ASTERISK,strlen(Group_UID[i])) EQ 0)
      OR (strlen(Group_UID[i]) EQ 1 AND *Group_UID[i] EQ '-') )
    {
      CTSAMSG_print(ACF2_ALL_UIDMASKS,msgs,NULL,dest,group);
      rc = ESA_FATAL;
      goto exit;
    };

    /* **BS2307 START** */

    rc = Check_UIDMASKS_NonLID_Masked(Group_UID_Count,
                                      Group_UID);

    if (rc NE ESA_OK)
    {
      CTSAMSG_print(ACF2_ALL_UIDMASKS,msgs,NULL,dest,group);
      rc = ESA_FATAL;
      goto exit;
    };
   }; /* end of (iiqAcf2Groups NE 'Y')                      IS10128*/

    /* **BS2307 END** */

    /* **PS0345 START** */

    rc = Check_UIDMASKS_Multi_Masked(Group_UID_Count,
                                     Group_UID,
                                     dest,
                                     msgs);

    if (rc NE ESA_OK)
    {
      rc = ESA_FATAL;
      goto exit;
    };

    /* **PS0345 END** */

 exit:;
  return rc;
}

 /* **PS0234 START** */
 /**************************************************************
 *                                                             *
 * Title            : Trunc_UIDMASKS                           *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 20/01/98                                 *
 *                                                             *
 * Description      : truncate group uidmasks                  *
 *                                                             *
 * Input / Output   : addinfo                                  *
 *                                                             *
 * Return Codes     : None                                     *
 *                                                             *
 * *** WS10082 ***                                             *
 * This routine can support UISMASKS up to 1024 characters.    *
 * If support for more UIDMASKS is needed, we will have to     *
 * change the way we define and use work_pair and value.       *
 **************************************************************/
void Trunc_UIDMASKS(ADDINFO_rec_ptr addinfo)
{
   char *curr_entry;
   char sep[3];
   char value[ACF_ADDINFO_VAL_LEN+1] = "";
   ONE_FIELD_rec_ptr pair, orig_pair;
   ONE_FIELD_rec_typ work_pair;

   BUILD_STRING_SEPARATOR(sep, ADDINFO_LIST_ENTRY);

   if (addinfo->num_pairs GT 0)
   {
     pair = ADDINFO_search("UIDMASKS",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);
     if (pair NE NULL)
     {
       memcpy ((char *)&work_pair, (char *)pair,
        sizeof (ONE_FIELD_rec_typ));

       orig_pair = pair;
       pair = &work_pair;

       curr_entry = strtok(pair->value, sep);

       while (curr_entry NE NULL)
       {
       /*Trunc_One_UIDMASK (curr_entry); leave UIDMASKS asis BS10049*/
         Trunc_One_UIDMASK (curr_entry);/*drop '*' & leave ' ' BS10050*/

         strcat (value, curr_entry);
         strcat (value, sep);

         curr_entry = strtok(NULL, sep);
       };
       value[strlen(value)-1] = NULL_CHAR;

       pair = orig_pair;

       ADDINFO_updval (value,
                       ACF_ADDINFO_VAL_LEN,
                       pair);
     };
   };
}

 /**************************************************************
 *                                                             *
 * Title            : Trunc_One_UIDMASK                        *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 28/01/98                                 *
 *                                                             *
 * Description      : truncate one uidmask                     *
 *                                                             *
 * Input / Output   : uidmask                                  *
 *                                                             *
 * Return Codes     : None                                     *
 **************************************************************/
void Trunc_One_UIDMASK(char *uidmask)
{
   int i;

   for (i=strlen(uidmask)-1; i GE 0; i--)
     if (uidmask[i] NE '*' AND
         uidmask[i] NE '-')
       break;
     else
       uidmask[i] = NULL_CHAR;

 /*Trunc_Blanks(uidmask);   * trunc right blanks from uidmask BS2593 */
 /*Trunc_Blanks(uidmask);drop trunc right blanks from uidmask BS10050*/
}
 /* **PS0234 END** */

 /********** add Trunc_Blanks routine BS2593 *******************/
 /**************************************************************
 *                                                             *
 * Title            : Trunc_Blanks                             *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Avner Livny                              *
 *                                                             *
 * Creation Date    : 07/04/03                                 *
 *                                                             *
 * Description      : truncate blanks                          *
 *                                                             *
 * Input / Output   : string                                   *
 *                                                             *
 * Return Codes     : None                                     *
 **************************************************************/
void Trunc_Blanks(char *my_string)
{
   int i;

   for (i=strlen(my_string)-1; i GE 0; i--)
     if (my_string[i] NE ' ')
       break;
     else
       my_string[i] = NULL_CHAR;
}
 /********************** BS2593 ends **************************/

 /* **BS2309 START** */

 /**************************************************************
 *                                                             *
 * Title            : Upper_UIDMASKS                           *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 02/11/97                                 *
 *                                                             *
 * Description      : match group uidmasks to uppercase        *
 *                                                             *
 * Input/Output     : addinfo                                  *
 *                                                             *
 * Return Codes     : None                                     *
 **************************************************************/
static void Upper_UIDMASKS(ADDINFO_rec_ptr addinfo)
{
   int i;
   ONE_FIELD_rec_ptr pair;

   if (addinfo->num_pairs GT 0)
   {
     pair = ADDINFO_search("UIDMASKS",
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);
     if (pair NE NULL)
       for (i=0;i LT strlen(pair->value);i++)
         if (isprint(pair->value[i]))
           pair->value[i] = toupper(pair->value[i]);
   };
}

 /* **BS2309 END** */

 /* **PS0234 START** */

 /**************************************************************
 *                                                             *
 * Title            : Build_UIDMASK_User                       *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 11/02/98                                 *
 *                                                             *
 * Description      : Build UIDMASK from user LID              *
 *                                                             *
 * Input            : user name                                *
 *                                                             *
 * Output           : uidmask                                  *
 *                                                             *
 * Return Value     : ESA_RC                                   *
 *                                                             *
 **************************************************************/
ESA_RC Build_UIDMASK_User(char *user_name,
                          char *built_uidmask)
{
  /*
   *   Static Variables
   */

   static char func[] = "Build_UIDMASK_User";

  /*
   *   Variables
   */

   ESA_RC         rc = ESA_FATAL;
   char           work_user_name[ACF2_LID_SIZE]="";
   int            i, LID_Offset;
   int            LID_Length;                             /* IS10178 */

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func);

   Reset_Field(work_user_name,
               sizeof(work_user_name),
               ' ',
               user_name);

   /*--------------------------------------------------------------*/
   /* If LID does not appear in UID, we can skip the entire check  */
   /*--------------------------------------------------------------*/
   /* IS10178 Added a parameter to this routine
   if (NOT ACF2_Is_LID_In_UID(&LID_Offset))                          */
   if (NOT ACF2_Is_LID_In_UID(&LID_Offset,&LID_Length))   /* IS10178 */
    goto exit;

   /*--------------------------------------------------------------*/
   /* Build UIDMASK                                                */
   /*--------------------------------------------------------------*/
   for (i=0;i LT (ACF2_UID_SIZE-1);i++)
   {
    /* IS10178 Use LID_Length instead of hard-coded ACF2_LID_SIZE
    if ((i GE LID_Offset) AND (i LT LID_Offset+(ACF2_LID_SIZE-1)) ) */
    if ((i GE LID_Offset) AND (i LT LID_Offset+(LID_Length)))/*IS10178*/
      built_uidmask[i] = work_user_name[i-LID_Offset];
    else
      built_uidmask[i] = '*';
   };
   rc = ESA_OK;

 exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func, rc);

  return rc;
}

 /**************************************************************
 *                                                             *
 * Title            : Is_LID_In_UID                            *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 16/02/98                                 *
 *                                                             *
 * Description      : Check if full image of LID is in UIDMASK *
 *                                                             *
 * Input            : None                                     *
 *                                                             *
 * Output           : Offset of LID in UIDMASK                 *
 *                                                             *
 * Return Value     : TRUE or FALSE                            *
 *                                                             *
 **************************************************************/
int Is_LID_In_UID(int *LID_Offset)
{
  /*
   *   Static Variables
   */

   static char func[] = "Is_LID_In_UID";

   static char LID_Field[6] = { ADDINFO_LIST_ENTRY,
                                'L', 'I', 'D',
                                ADDINFO_LIST_SUBFIELD,
                                NULL_CHAR };

   static char LID_Field2[5] = { 'L', 'I', 'D',
                                 ADDINFO_LIST_SUBFIELD,
                                 NULL_CHAR };

  /*
   *   Variables
   */

   char     uid_structure[32768]="", *temp, *temp2, *end_of_entry;
   char     subfield_sep[2], entry_sep[2], *end_of_struct;
   int      LID_Is_In_UID;

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func);

   LID_Is_In_UID = FALSE;

   subfield_sep[0] = ADDINFO_LIST_SUBFIELD;
   subfield_sep[1] = NULL_CHAR;

   entry_sep[0] = ADDINFO_LIST_ENTRY;
   entry_sep[1] = NULL_CHAR;

   Get_UID_In_ESS_Format(uid_structure);

   ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                   "uid_structure=(%s)",uid_structure);

   /*--------------------------------------------------------------*/
   /* If LID does not appear in UID, we can skip the entire check  */
   /*--------------------------------------------------------------*/
   if (NOT strstr(uid_structure, "LID"))
    goto exit;

   end_of_struct = uid_structure + strlen(uid_structure);

   if (*end_of_struct NE NULL_CHAR)
    goto exit;

   /*--------------------------------------------------------------*/
   /* The first time, LID can be the first field in the structure, */
   /* so it may appear without entry_list before                   */
   /*--------------------------------------------------------------*/
   if (memcmp(uid_structure, LID_Field2, strlen(LID_Field2)) EQ 0)
    temp = uid_structure;

   else
   {
     /*-------------------------------------------------------------*/
     /* Search for "LID" inbetween list_entry and list_subfield     */
     /* LID can also appear as LID1, MYLID or TLID5 (user defined)  */
     /* Insure we continue only if original LID appears             */
     /*-------------------------------------------------------------*/
     temp = strstr(uid_structure, LID_Field);

     if (temp NE NULL)
      temp++;
   };

   /*--------------------------------------------------------------*/
   /* Build a structure containing all LID-parts appearances       */
   /*--------------------------------------------------------------*/
   while (temp NE NULL)
   {
     end_of_entry = strpbrk(temp, entry_sep);

     if (end_of_entry EQ NULL)
      end_of_entry = end_of_struct;

     /*------------------------------------------------------------*/
     /* Point to original offset field                             */
     /*------------------------------------------------------------*/
     temp = temp + 4;
     if (temp GE end_of_entry)
      goto exit;

     /*------------------------------------------------------------*/
     /* Keep pointer to beginning of original offset in LID        */
     /*------------------------------------------------------------*/
     temp2 = temp;

     temp = strstr(temp, subfield_sep);
     if (temp EQ NULL)
      goto exit;

     *temp = NULL_CHAR;

     /*------------------------------------------------------------*/
     /* If original LID offset is not 0 (meaning it is a substring */
     /* of the LID) or we already found a LID part, return FALSE   */
     /*------------------------------------------------------------*/
     if ( (atoi(temp2) NE 0) OR (LID_Is_In_UID) )
     {
       LID_Is_In_UID = FALSE;
       goto exit;
     };

     LID_Is_In_UID = TRUE;

     /*------------------------------------------------------------*/
     /* Keep pointer to beginning of offset in UID                 */
     /*------------------------------------------------------------*/
     temp++;
     if (temp GE end_of_entry)
      goto exit;

     temp2 = temp;

     temp = strstr(temp, subfield_sep);
     if (temp EQ NULL)
      goto exit;

     *temp = NULL_CHAR;

     *LID_Offset = atoi(temp2);

     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                     "LID offset (%d)",
                     *LID_Offset);

     /*------------------------------------------------------------*/
     /* Keep pointer to beginning of length in UID                 */
     /*------------------------------------------------------------*/
     temp++;
     if (temp GE end_of_entry)
      goto exit;

     temp2 = temp;

     temp = strstr(temp, entry_sep);

     /*------------------------------------------------------------*/
     /* If not end of struct, change entry_sep to NULL_CHAR        */
     /*------------------------------------------------------------*/
     if (temp NE NULL)
       *temp = NULL_CHAR;
     else
       temp = end_of_struct;

     /*------------------------------------------------------------*/
     /* If length is not LID length, return FALSE                  */
     /*------------------------------------------------------------*/
     /* IS10178 Remove this check. LID can be < 8
     if (atoi(temp2) NE (ACF2_LID_SIZE-1))
     {
       LID_Is_In_UID = FALSE;
       goto exit;
     };                                                              */

     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                     "LID length (%d)",
                     atoi(temp2));

     /*------------------------------------------------------------*/
     /* Was it the last entry in the structure ?                   */
     /*------------------------------------------------------------*/
     if (temp GE end_of_struct)
      break;

     /*------------------------------------------------------------*/
     /* Restore entry_sep value                                    */
     /*------------------------------------------------------------*/
     *temp = ADDINFO_LIST_ENTRY;

     /*------------------------------------------------------------*/
     /* search only for a valid LID                                */
     /*------------------------------------------------------------*/
     temp = strstr(temp, LID_Field);

     if (temp NE NULL)
      temp++;
   };

 exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func, ESA_OK);

  return LID_Is_In_UID;
}

 /**************************************************************
 *                                                             *
 * Title            : Build_LID_Array                          *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 11/02/98                                 *
 *                                                             *
 * Description      : Build flags array for UID chars          *
 *                    describing who is a LID part             *
 *                                                             *
 * Output           : flags array                              *
 *                                                             *
 * Return Value     : TRUE  - Existing LID parts in UID        *
 *                    FALSE - No LID parts in UID              *
 *                                                             *
 **************************************************************/
static int Build_LID_Array(int *Is_In_LID)

{
  /*
   *   Static Variables
   */

   static char func[] = "Build_LID_Array";

   static char LID_Field[6] = { ADDINFO_LIST_ENTRY,
                                'L', 'I', 'D',
                                ADDINFO_LIST_SUBFIELD,
                                NULL_CHAR };

   static char LID_Field2[5] = { 'L', 'I', 'D',
                                 ADDINFO_LIST_SUBFIELD,
                                 NULL_CHAR };

  /*
   *   Variables
   */

   LID_Parts_typ  LID_Parts;
   char     uid_structure[32768]="", *temp, *temp2, *end_of_entry;
   char     subfield_sep[2], entry_sep[2], *end_of_struct;
   int      i, j, num_of_parts, Existing_LID_Parts = FALSE;

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func);

   subfield_sep[0] = ADDINFO_LIST_SUBFIELD;
   subfield_sep[1] = NULL_CHAR;

   entry_sep[0] = ADDINFO_LIST_ENTRY;
   entry_sep[1] = NULL_CHAR;

   Get_UID_In_ESS_Format(uid_structure);

   ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                   "uid_structure=(%s)",uid_structure);

   /*--------------------------------------------------------------*/
   /* If LID does not appear in UID, we can skip the entire check  */
   /*--------------------------------------------------------------*/
   if (NOT strstr(uid_structure, "LID"))
    goto exit;

   num_of_parts = 0;

   end_of_struct = uid_structure + strlen(uid_structure);

   if (*end_of_struct NE NULL_CHAR)
    goto exit;

   /*--------------------------------------------------------------*/
   /* The first time, LID can be the first field in the structure, */
   /* so it may appear without entry_list before                   */
   /*--------------------------------------------------------------*/
   if (memcmp(uid_structure, LID_Field2, strlen(LID_Field2)) EQ 0)
    temp = uid_structure;

   else
   {
     /*-------------------------------------------------------------*/
     /* Search for "LID" inbetween list_entry and list_subfield     */
     /* LID can also appear as LID1, MYLID or TLID5 (user defined)  */
     /* Insure we continue only if original LID appears             */
     /*-------------------------------------------------------------*/
     temp = strstr(uid_structure, LID_Field);

     if (temp NE NULL)
      temp++;
   };

   /*--------------------------------------------------------------*/
   /* Build a structure containing all LID-parts appearances       */
   /*--------------------------------------------------------------*/
   while (temp)
   {
     end_of_entry = strpbrk(temp, entry_sep);

     if (end_of_entry EQ NULL)
      end_of_entry = end_of_struct;

     /*------------------------------------------------------------*/
     /* Point to original offset field                             */
     /*------------------------------------------------------------*/
     temp = temp + 4;
     if (temp GE end_of_entry)
      goto exit;

     /*------------------------------------------------------------*/
     /* Skip original field offset                                 */
     /*------------------------------------------------------------*/
     temp = strpbrk(temp, subfield_sep);
     if (temp EQ NULL)
      goto exit;

     /*------------------------------------------------------------*/
     /* Keep pointer to beginning of offset in UID                 */
     /*------------------------------------------------------------*/
     temp++;
     if (temp GE end_of_entry)
      goto exit;

     temp2 = temp;

     temp = strstr(temp, subfield_sep);
     if (temp EQ NULL)
      goto exit;

     *temp = NULL_CHAR;

     LID_Parts.Lid_Offset[num_of_parts] = atoi(temp2);

     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                     "Lid part (%d) offset (%d)",
                     num_of_parts, LID_Parts.Lid_Offset[num_of_parts]);

     /*------------------------------------------------------------*/
     /* Keep pointer to beginning of length in UID                 */
     /*------------------------------------------------------------*/
     temp++;
     if (temp GE end_of_entry)
      goto exit;

     temp2 = temp;

     temp = strstr(temp, entry_sep);

     /*------------------------------------------------------------*/
     /* If not end of struct, change entry_sep to NULL_CHAR        */
     /*------------------------------------------------------------*/
     if (temp NE NULL)
       *temp = NULL_CHAR;
     else
       temp = end_of_struct;

     LID_Parts.Lid_Length[num_of_parts] = atoi(temp2);

     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                     "Lid part (%d) length (%d)",
                     num_of_parts, LID_Parts.Lid_Length[num_of_parts]);

     num_of_parts++;

     /*------------------------------------------------------------*/
     /* Was it the last entry in the structure ?                   */
     /*------------------------------------------------------------*/
     if (temp GE end_of_struct)
      break;

     /*------------------------------------------------------------*/
     /* Restore entry_sep value                                    */
     /*------------------------------------------------------------*/
     *temp = ADDINFO_LIST_ENTRY;

     /*------------------------------------------------------------*/
     /* search only for a valid LID                                */
     /*------------------------------------------------------------*/
     temp = strstr(temp, LID_Field);

     if (temp NE NULL)
      temp++;
   };

   ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                   "Num of LID parts=(%d)",num_of_parts);

   /*--------------------------------------------------------------*/
   /* Build Is_In_LID array (TRUE or FALSE for each char in UID)   */
   /*--------------------------------------------------------------*/
   for (i=0;i LT (ACF2_UID_SIZE-1);i++)
   {
    Is_In_LID[i] = FALSE;
    for (j=0;j LT num_of_parts;j++)
      if ( (i GE LID_Parts.Lid_Offset[j]) AND
           (i LT LID_Parts.Lid_Offset[j]+LID_Parts.Lid_Length[j]) )
        Is_In_LID[i] = TRUE;

     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                     "Is_In_LID(%d)=(%d)",i, Is_In_LID[i]);
   };

   Existing_LID_Parts = TRUE;

 exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func, ESA_OK);

  return Existing_LID_Parts;
}

 /**************************************************************
 *                                                             *
 * Title            : Is_UIDMASK_User                          *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 11/02/98                                 *
 *                                                             *
 * Description      : check if a UIDMASK is of a specific      *
 *                    user (LID)                               *
 *                                                             *
 * Input            : UIDMASK                                  *
 *                                                             *
 * Output           : None                                     *
 *                                                             *
 * Return Value     : TRUE  - UIDMASK is of specific user      *
 *                    FALSE - UIDMASK is not of specific user  *
 *                                                             *
 **************************************************************/
 /* * * * * * * * * * * IS10178 start * * * * * * * * * * * * */
 /*************************************************************/
 /* The old code in this routine assumed that the LID resides
    in the right-most part of the UID. This new code makes no
    assumptions about the LID at all.  The LID can be anywhere
    in the UID and can be any length.  These are the 3
    possibilities:
      1. LIDxxxxx | RightPartOfUID
      2. LeftPartOfUID | LIDxxxxx | RightPartOfUID
      3. LeftPartOfUID | LIDxxxxx

    To support this, there are 3 basic rules that we follow:
    A. If a UID does not contain any part of the LID, i.e., the
       length of the UID is less than or equal to LID_Offset,
       the UID represents a 'group'.
    >> ****** ****** ****** WS10075S Start ****** ****** ****** <<
       We added the following test to the second rule:
    B. If a UID - no matter what its size - ends with an
       asterisk or dash, the UID represents a 'group'.
    >> ****** ****** ****** WS10075S End ****** ****** ****** <<
       If a UID contains a specific LID (a LID which ends with
       a blank OR a LID whose length is equal to LID_Length
       but does not end with a dash or asterisk), the UID does
       not represent a 'group' - it is a specific user.
    C. If a UID contains a generic LID (a LID which ends with
       a dash or asterisk OR a LID whose length is less than
       LID_Length and does not have a trailing blank), the UID
       represents a 'group'.                                  */
 /*************************************************************/
 /* * * * * * * * * * * IS10178  end  * * * * * * * * * * * * */
 /*************************************************************/
 int Is_UIDMASK_User(char *UIDMASK_To_Check)
{
  /*
   *   Static Variables
   */

   static char func[] = "Is_UIDMASK_User";

  /*
   *   Variables
   */

   UIDMASK  current_uidmask;
   int      UIDMASK_Is_User = FALSE, UIDMASK_OK = TRUE, i, LID_Offset;
   int      LID_Length;                                   /* IS10178 */
   char     lid[ACF2_LID_SIZE] = "";                      /* IS10178 */

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func);

   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,/*IS10178 */
       "Is_UIDMASK_user |%s|", UIDMASK_To_Check);         /* IS10178 */

   /*--------------------------------------------------------------*/
   /* Is full LID contained in UID and only once ?  Get its offset */
   /*--------------------------------------------------------------*/
   /* IS10178 Added a parameter to this routine
   if (NOT ACF2_Is_LID_In_UID(&LID_Offset))                          */
   if (NOT ACF2_Is_LID_In_UID(&LID_Offset,&LID_Length))   /* IS10178 */
     goto exit;

 /********************************************************************/
 /* The following 20+ lines of code is commented out and is replaced */
 /* by code marked IS10178 several lines down.                       */
 /********************************************************************/
 /*
   Reset_Field(current_uidmask,
               sizeof(current_uidmask),
               '*',
               UIDMASK_To_Check);

   for (i=0; (i LT ACF2_UID_SIZE-1) AND (UIDMASK_OK); i++)
   {
     if ( (i GE LID_Offset) AND (i LT LID_Offset+(ACF2_LID_SIZE-1)) )
     {
       if (current_uidmask[i] EQ '*')
         UIDMASK_OK = FALSE;
     }
     else
     {
       if (current_uidmask[i] NE '*')
         UIDMASK_OK = FALSE;
     };
   };

   if (UIDMASK_OK)
     UIDMASK_Is_User = TRUE;                                  */

 /********************************************************************/
 /* * * * * * * * * * * * * IS10178 start * * * * * * * * * * * * * **/
 /********************************************************************/

 /* We are now ready to test our first rule (A):                     */
 /* If a UID does not contain any part of the LID, i.e., the length  */
 /* of the UID is less than or equal to LID_Offset, the UID          */
 /* represents a 'group'.                                            */
 if (strlen(UIDMASK_To_Check) LE LID_Offset)        /* no LID at all */
    goto exit;                                   /* UID is a 'group' */

 /* We will now extract the LID and test our second rule (B):        */
 /* ****** ****** ****** WS10075S Start ****** ****** ****** ******  */
 /* We added the following test to this rule:                        */
 /* If a UID - no matter what its size - ends with an asterisk       */
 /* or dash, the UID represents a 'group'.                           */
 /* ****** ****** ****** WS10075S End ****** ****** ****** ******    */
 /* If a UID contains a specific LID (a LID which ends with a blank  */
 /* OR a LID whose length is equal to LID_Length but does not end    */
 /* with a dash or asterisk), the UID does not represent a 'group' - */
 /* it is a specific user.                                           */
 memset (lid, 0X00, sizeof(lid));            /* init local lid field */
 strncpy (lid, UIDMASK_To_Check+LID_Offset, LID_Length); /* copy lid */
 ESA_DIAG_printf(PLT_COMP_API_ACF2, 20, "lid = |%s|", lid);
 /* ****** ****** ****** WS10075S Start ****** ****** ****** ******  */
 for(i=0; (lid[i] NE ' ' AND lid[i] NE NULL_CHAR); i++);
 if ( (lid[i-1] EQ '*') OR (lid[i-1] EQ '-') )
    goto exit;                                   /* UID is a 'group' */
 /* ****** ****** ****** WS10075S End   ****** ****** ****** ******  */
 if (strncmp(lid+strlen(lid)-1, " ", 1) EQ 0)   /* lid ends w/ blank */
    goto specific_user;                    /* uid is a specific user */
 if ((strlen(lid) EQ LID_Length)          /* lid length = LID_Length */
     AND
     (strncmp(lid+strlen(lid)-1, "-", 1) NE 0)      /* no ending "-" */
     AND
     (strncmp(lid+strlen(lid)-1, "*", 1) NE 0))     /* no ending "*" */
     goto specific_user;                   /* uid is a specific user */

 /* We are now ready to test our third rule (C):                     */
 /* If a UID contains a generic LID (a LID which ends with a '-' or  */
 /* '*' OR a LID whose length is less than LID_Length and does not   */
 /* have a trailing blank), the UID represents a 'group'.            */
 if ((strncmp(lid+strlen(lid)-1, "-", 1) EQ 0)    /* lid ends w/ "-" */
     OR
     (strncmp(lid+strlen(lid)-1, "*", 1) EQ 0))   /* lid ends w/ "*" */
     goto exit;                                  /* UID is a 'group' */
 if ((strlen(lid) LT LID_Length)         /* lid length LT LID_Length */
     AND
     (strncmp(lid+strlen(lid)-1, " ", 1) NE 0)) /* no trailing blank */
     goto exit;                                  /* UID is a 'group' */

 ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, /* IS10178 */
                 "fall-thru lid |%s| defaults to user", lid);

 specific_user:
     UIDMASK_Is_User = TRUE;
 /********************************************************************/
 /* * * * * * * * * * * * * IS10178  end  * * * * * * * * * * * * * **/
 /********************************************************************/

  exit:;

  ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT,/* IS10178 */
      "UIDMASK_Is_User=%s",                               /* IS10178 */
      UIDMASK_Is_User ? "TRUE" : "FALSE");                /* IS10178 */

  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func, ESA_OK);

  return UIDMASK_Is_User;
}

 /* **PS0234 END** */

 /**************************************************************
 *                                                             *
 * Title            : Check_UIDMASKS_NonLID_Masked             *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 03/11/97                                 *
 *                                                             *
 * Description      : check that not all non-LID fields in     *
 *                    the Group's UIDMASKS are masked          *
 *                                                             *
 * Input            : Group_UID_Count : number of UIDMASKS     *
 *                    Group_UID       : UIDMASKS vector        *
 *                                                             *
 * Output           : None                                     *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem in UIDMASKS          *
 *                    else   : One or more UIDMASKs not valid  *
 *                                                             *
 **************************************************************/
static ESA_RC Check_UIDMASKS_NonLID_Masked(int     Group_UID_Count,
                                           UIDMASK Group_UID[1])

{
  /*
   *   Static Variables
   */

   static char func[] = "Check_UIDMASKS_NonLID_Masked";

  /*
   *   Variables
   */

   UIDMASK  current_uidmask;
   int      i, j, UIDMASK_Ok;
   int      Is_In_LID[ACF2_UID_SIZE];
   ESA_RC   rc = ESA_OK;

   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func);

   if (NOT Build_LID_Array(Is_In_LID))
     goto exit;

   /*--------------------------------------------------------------*/
   /* Check all UIDMASKS in group.                                 */
   /* First, we flud the current UIDMASK with '*'.                 */
   /* For each UIDMASK, we pass char by char.                      */
   /* If IT IS included in a LID part, we skip to the next char.   */
   /* If it is NOT included in a LID part, and it's not '*',       */
   /* then we know that not all non-LID chars are '*', and we      */
   /* skip to the next UIDMASK.                                    */
   /* Finally, we check the UIDMASK_Ok to see if we found at least */
   /* one non '*' and non-LID-part char.                           */
   /*--------------------------------------------------------------*/

   /*--------------------------------------------------------------*/
   /* Main loop for all UIDMASKs in group                          */
   /*--------------------------------------------------------------*/
   for (i=0;i LT Group_UID_Count;i++)
   {
    UIDMASK_Ok = FALSE;
    Reset_Field(current_uidmask,
                sizeof(current_uidmask),
                '*',
                Group_UID[i]);

    /*-------------------------------------------------------------*/
    /* Second loop for scanning all chars in current UIDMASK       */
    /*-------------------------------------------------------------*/
    for (j=0;(j LT ACF2_UID_SIZE-1) AND (NOT UIDMASK_Ok);j++)
    {
      /*-----------------------------------------------------------*/
      /* If current char is part of LID we skip to next char       */
      /*-----------------------------------------------------------*/
      if (Is_In_LID[j])
       continue;

      /*-----------------------------------------------------------*/
      /* If current char is not '*' then the entire UIDMASK is OK  */
      /*-----------------------------------------------------------*/
      if (current_uidmask[j] NE '*')
      {
        ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                        "UIDMASK (%s) is OK", current_uidmask);
        UIDMASK_Ok = TRUE;
        break;
      };
    };

    if (NOT UIDMASK_Ok)
    {
      ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                      "UIDMASK (%s) is invalid", current_uidmask);
      rc = ESA_FATAL;
      goto exit;
    };
   };

 exit:;
  ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, func, rc);
  return rc;
}

 /* **BS2307 END** */

 /* PS0345 - New function */
 /**************************************************************
 *                                                             *
 * Title            : Check_UIDMASKS_Multi_Masked              *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Guy Shavitt                              *
 *                                                             *
 * Creation Date    : 02/12/98                                 *
 *                                                             *
 * Description      : check that there is no partial mask on   *
 *                    MULTIVALUE fields, and no value on       *
 *                    MULTIVALUE fields which are not the 1st  *
 *                    in the UID (according to UID definition) *
 *                                                             *
 * Input            : Group_UID_Count : number of UIDMASKS     *
 *                    Group_UID       : UIDMASKS vector        *
 *                    dest,msgs                                *
 *                                                             *
 * Output           : None                                     *
 *                                                             *
 * Return Codes     : ESA_RC                                   *
 *                    ESA_OK : No Problem in UIDMASKS          *
 *                    else   : One or more UIDMASKs not valid  *
 *                                                             *
 **************************************************************/
static ESA_RC Check_UIDMASKS_Multi_Masked(int     Group_UID_Count,
                                          UIDMASK Group_UID[1],
                                  CTSAMSG_DEST_TABLE_rec_ptr dest,
                                  CTSAMSG_HANDLE_rec_ptr     msgs)
{
  /*
   *   Static Variables
   */

   static char func[] = "Check_UIDMASKS_Multi_Masked";

  /*
   *   Variables
   */

   ESA_RC                     rc = ESA_OK;
   ACF2_MVF_Scan_Status_Type  scan_status;
   UIDMASK                    current_uidmask;
   char                       multi_field_name[20]="";
   char                       mvf_name[20]="";
   int                        multi_field_offset=0;
   int                        mvf_offs, mvf_len;
   int                        i, j;

   ESA_DIAG_enter(ESA_COMP_ADDUG, DEBUG_SHOW_IMPORTANT, func);

   /*--------------------------------------------------------------*/
   /* If there are no MULTIVALUED fields in UID,we have no problem */
   /*--------------------------------------------------------------*/
   if (NOT UID_Contains_MULTI(multi_field_name,
                              &multi_field_offset) )
     goto exit;

   ESA_DIAG_printf(ESA_COMP_ADDUG,DEBUG_SHOW_IMPORTANT,
                   "UID contains MVF. First field is(%s) at offs(%d)",
                   multi_field_name, multi_field_offset);

   /*--------------------------------------------------------------*/
   /* Scan all UIDMASKs of group                                   */
   /*--------------------------------------------------------------*/
   for (i=0;i LT Group_UID_Count;i++)
   {
     scan_status = ACF2_Scan_Not_Started;

     Reset_Field(current_uidmask,
                 sizeof(current_uidmask),
                 '*',
                 Group_UID[i]);

     /*------------------------------------------------------------*/
     /* Scan current UIDMASK char by char                          */
     /*------------------------------------------------------------*/
     for (j=0;j LT ACF2_UID_SIZE-1;j++)
     {
       /*----------------------------------------------------------*/
       /* If current char is not part of MULTIVALUED field,        */
       /* skip to next char in UIDMASK.                            */
       /* otherwise, get MULTIVALUED field details:                */
       /*                                                          */
       /* - MULTIVALUED field name                                 */
       /* - MULTIVALUED field offset in UID                        */
       /* - MULTIVALUED field length                               */
       /*----------------------------------------------------------*/
       if (NOT ACF2_Is_Part_Of_Multi (j,
                                      mvf_name,
                                      &mvf_offs,
                                      &mvf_len) )
         continue;

       ESA_DIAG_printf(ESA_COMP_ADDUG,DEBUG_SHOW_IMPORTANT,
           "Char at offs(%d) is part of %s o=%d l=%d scan_status=%d",
            j, mvf_name, mvf_offs, mvf_len,scan_status); /*BS2620 */

       /*----------------------------------------------------------*/
       /* Is this part of the FIRST MULTIVALUED field in UID ?     */
       /*----------------------------------------------------------*/
       if (strcmp (mvf_name, multi_field_name) NE 0)
       {
         ESA_DIAG_printf(ESA_COMP_ADDUG,DEBUG_SHOW_IMPORTANT,
            "Char not part of first MVF, crnt_uidmsk=%c",
            current_uidmask[j]);

         /*--------------------------------------------------------*/
         /* For MVF field which is not the first one in UID,       */
         /* we must have a full mask (all chars must be '*')       */
         /*--------------------------------------------------------*/
         if (current_uidmask[j] EQ '*')
           continue;

         CTSAMSG_print(ACF2_NO_FULL_MASK,
                       msgs,
                       NULL,
                       dest,
                       current_uidmask);

         rc = ESA_FATAL;
         goto exit;
       };

       /*----------------------------------------------------------*/
       /* Handle part of first MULTIVALUED field                   */
       /*----------------------------------------------------------*/
       ESA_DIAG_printf(ESA_COMP_ADDUG,DEBUG_SHOW_IMPORTANT,
            "Char IS part of first MVF, crnt_uidmsk=%c, sc_status=%d",
            current_uidmask[j],scan_status); /*BS2620 */

       /*----------------------------------------------------------*/
       /* Partial mask is not allowed. Full mask or value are OK.  */
       /* ' ' like '*' makes it partial mask.       BS2620         */
       /*----------------------------------------------------------*/
       if (current_uidmask[j] EQ '*' OR         /*BS2620 */
           current_uidmask[j] EQ ' ')           /*BS2620*/
       {
         if (scan_status EQ ACF2_Scan_Found_Value)
         {
           CTSAMSG_print(ACF2_MVF_PARTIAL_MASK,
                         msgs,
                         NULL,
                         dest,
                         current_uidmask);

           rc = ESA_FATAL;
           goto exit;
         };

         scan_status = ACF2_Scan_Found_Mask;
         continue;
       }
       else
       {
         ESA_DIAG_printf(ESA_COMP_ADDUG,DEBUG_SHOW_IMPORTANT,
            "Crnt_uidmsk=%c, scan_status=%d",
            current_uidmask[j],scan_status);            /*BS2620 */
         if (scan_status EQ ACF2_Scan_Found_Mask)
         {
           CTSAMSG_print(ACF2_MVF_PARTIAL_MASK,
                         msgs,
                         NULL,
                         dest,
                         current_uidmask);

           rc = ESA_FATAL;
           goto exit;
         };

         scan_status = ACF2_Scan_Found_Value;
         continue;
       };
     };
   };

   exit:;

   ESA_DIAG_exit(ESA_COMP_ADDUG, DEBUG_SHOW_IMPORTANT, func, rc);

   return rc;
}
/* PS0345 - End */

 /**************************************************************
 *                                                             *
 * Title            : Trim String                              *
 *                                                             *
 * File Name        : ctsbsrv.c                                *
 *                                                             *
 * Author           : Yishay Yovel                             *
 *                                                             *
 * Creation Date    : 05/08/97                                 *
 *                                                             *
 * Description      : remove string's trailing blanks          *
 *                                                             *
 * Input/Output     : string                                   *
 *                                                             *
 * Return Codes     : None                                     *
 **************************************************************/
char *Trim(char *string)
{
   int i;

   for (i=strlen(string)-1;i GE 0;i--)
    if ((string[i] EQ ' ') OR (string[i] EQ '\n'))
     string[i]=NULL_CHAR;
    else
     break;

   return string;
}

ACF2_API_Return_Codes ACF2_Clean_GDB(void) /* WS10076K */
{
  static char func[] = "ACF2_Clean_GDB";

  ACF2_API_Return_Codes ACF2_rc = ACF2_OK;
  GDB_Codes GDB_rc = GDB_OK;

  ESA_DIAG_enter(PLT_COMP_API_ACF2, 1, func);

 /*---------------------------------------------------------------*
  * Delete each GDB record one at a time                          *
  *---------------------------------------------------------------*/
 while(GDB_rc EQ GDB_OK) {
    GDB_rc = GDB_GetNext(GDB_RECORD_TYPE_GROUP, NULL);
    if (GDB_rc EQ GDB_OK) {
       GDB_rc = GDB_Delete();
       numgrps++;                                         /* WS10067 */
    }
 };

  ESA_DIAG_printf(PLT_COMP_API_ACF2, 6,
           "ACF2_Clean_GDB: Leaving loop with GDB_rc = %d", GDB_rc);

  if (GDB_rc NE GDB_Not_Found) ACF2_rc = ACF2_Internal_Error;
  if (GDB_rc EQ GDB_EOF)       ACF2_rc = ACF2_OK;

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ACF2, 1, func, ACF2_rc);
  return ACF2_rc;
}

/* BS10108 - code moved here from CTSBPHR
/****************** WS10078A start ********************************
/* WS10079N  - removed - replaced  by the new structure of the
               xref block and the use of ACF2_Get_Xref to look
               for a name in the block.
/@*****************************************************************
 * Procedure Name: XREF_Block_Find
 ******************************************************************
 * Description   : Search the XREFName received as first parameter
 *                 in XREF_Block.
 *                 If found, set the IsGroup output parameter based
 *                 on XREF_Block's type & group (XREFBlk->type,group))
 *                 If not found, we assume it's in the "other" type and
 *                 return the "other" type than the one in XREFBlk->type
 *
 * Input         : XREFName - name of Role/Source to find its type
 *                 XREFBlk  - XREF_Block address
 * Output        : IsGrouop - Y/N (XrefBlk->type is R/S)
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_FATAL - fatal error
 *****************************************************************@/
/@ BS10108 static ESA_RC XREF_Block_Find(                        @/
ESA_RC XREF_Block_Find(                                   /@ BS10108 @/
                 char                     * XREFName,
                 XREF_REC_BLK_rec_typ     * XREFBlk,
                 char                     * IsGroup,
                 ADMIN_PARAMS_rec_typ     * admin_params)
/@ copied from ctsbacf cmac for reference while coding
typedef struct XREF_REC_block {            /@                        *
  char              eyec[4];               /@ xxx_BLOCK_EYEC above   *
  char              type;                  /@ XREF_REC_TYPE_xxx      *
  char              group;                 /@ Y | N                  *
  int               num_names;             /@                        *
  char              names[XREF_NAME_SIZE]; /@                 *
  } XREF_REC_BLK_rec_typ,  *XREF_REC_BLK_rec_ptr; /@          @/
{
  static char func[] = "XREF_Block_Find";

  ESA_RC     rc = ESA_OK;
  int        i_num_names = 0;
  char       * pXREFNames;              /@ cur ptr in XREFBlk->names @/

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);
  ESA_DIAG_printf(PLT_COMP_XREF,6,
    "XREFName=<%s> Blk.type=<%c> Blk.group=<%c> Blk.num_names=<%d>",
    XREFName, XREFBlk->type, XREFBlk->group, XREFBlk->num_names);

  if ((XREFName EQ NULL) OR
      (XREFBlk EQ  NULL) OR
      (IsGroup EQ NULL)) {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                   "NULL parameter is illegal", 16, __LINE__);
     rc = ESA_FATAL;
     goto exit_XREF_Block_Find;
  }

  i_num_names=1;
  pXREFNames = XREFBlk->names;
  while (i_num_names LE XREFBlk->num_names)
  {
   ESA_DIAG_printf(PLT_COMP_XREF,6,
     "pXREFNames=<%s> XREFName=<%s> i_num_names=<%d>",
     pXREFNames, XREFName, i_num_names);
   /@
   if (strstr(pXREFNames,XREFName) NE NULL)                  BS10108T @/
   if (strcmp(pXREFNames,XREFName) EQ 0)                  /@ BS10108T @/
     break;
   i_num_names++;
   /@
   pXREFNames+=9;                                            BS10108T @/
   pXREFNames+=XREF_NAME_SIZE;
  }

  ESA_DIAG_printf(PLT_COMP_XREF,6,
     "i_num_names=<%d> XREFBlk->num_names=<%d>",
     i_num_names, XREFBlk->num_names);

  if(i_num_names GT XREFBlk->num_names) /@ XREFName not found @/
   if(XREFBlk->group EQ 'N')
          *IsGroup = 'Y';
     else *IsGroup = 'N';
  else /@ XREFName is found @/
   if(XREFBlk->group EQ 'Y')     *IsGroup = 'Y';
                            else *IsGroup = 'N';

  ESA_DIAG_printf(PLT_COMP_XREF,6,
               "XREFName=<%s> *IsGroup = %c",XREFName,*IsGroup);
  exit_XREF_Block_Find:
  ESA_DIAG_exit(PLT_COMP_XREF,1, func, rc);
  return rc;
}
/@ end of XR
   end of removed code - WS10079N */

/***********  */
/******************************************************************
 * Procedure Name: Get_XREF_Record
 ******************************************************************
 * Description   : Read the next relevant line via ESA_CLI_get_RUOB_line
 *                 when doing accounts aggregation, collect all lines
 *                 which belong to the same logical record and pass it
 *                 up to the caller (XREF_Block_Build).
 *
 * Input         : function: GETNEXT / TERM
 *                 pointer to handle
 *                 ptr to RUOB containing SET X(ROL)+L LIKE(-) output
 *                 ptr to output area
 *                 output area length
 *                 XREF type (ROL/SGP) - not needed as we collect all
 *                                       lines between "LAST CHANGED"
 *                                       until "TOTAL".
 * Output        : output area is set with the XREF logical record which
 *                   is a full output of a role or source in L LIKE(-)
 *                 output area length
 * Return Value  : ESA_OK    - ended alright and returned next record
 *                 ESA_SKIP  - output area too small
 *                 ESA_WARN  - end-of-user notification
 *                 ESA_FATAL - serious error encountered
 *                 ESA_EOF   - end_of_file reached
 *
 * BackGround:
 * The output of the LIST LIKE(-) command has the following format.
 * Note that after the TOTAL line , there is always a whole spaces line.
 *  TLVB / TSROL1 LAST CHANGED BY TLVTS ON 03/10/20-15:26
 *                       EXCLUDE(TLVTS61 TLVTS62 TLVTS63 TLVTS64
 *                       TLVTS81 TLVTS82 TLVTS83 TLVTS84 TLVTS85
 *                       TLVTS97)
 *                       INCLUDE(TLVTS TLVTS1 TLVTS11 TLVTS12 TLV
 *                       TLVTS31 TLVTS32 TLVTS33 TLVTS34 TLVTS35
 *                       TLVTS6-) ROLE
 * TOTAL RECORD LENGTH= 764 BYTES, 18 PERCENT UTILIZED
 *
 * The keywords appear in alfabeta order:
 * DESCRIPT, EXCLUDE, GROUP, INCLUDE, ROLE
 * The routine calls ESA_CLI_get_RUOB_line which returns one physical
 * line from RUOB , which has the output of the LIST LIKE(-) command.
 * The routine collects all physical lines which belong to one logical
 * record, which is one Role or Source with all its keywords.
 * In the example above there are 7 physical lines belong to one record.
 * Once all lines are collected into one logical record, it is returned
 * to the caller.
 ******************************************************************/
/*static  ESA_RC Get_XREF_Record(char              * function,
                   REXX@UTL_output_blk_rec_typ  ** handle,
                   IDB_GETRUOBLINE_rec_typ       * ruob,
                   char                          * output_area,
                   int                             output_length,
                   ADMIN_PARAMS_rec_typ          * admin_params);  */
/*static ESA_RC Get_XREF_Record(char      * function, WS10078KG */
/* WS10079N ESA_RC Get_XREF_Record(char    * function, /@ WS10078KG@/ */
static ESA_RC Get_XREF_Record(char        * function,  /* WSS0079N */
          /* BS10111    Get_XREF_Rec_Handle        ** handle,  */
          /* BS10111 */ void                       ** handle,
          /* BS10111    REXX@UTL_output_blk_rec_typ * ruob,     */
          /* BS10111 */ char                        * ruob,
                        char                        * output_buffer,
                        int                           max_output_length,
                        ADMIN_PARAMS_rec_typ        * admin_params)
{
  static char func[] = "Get_XREF_Record";

  /*get_RUOBline_handle_rec_typ *h_RUOB in this routine's handle*/
  /* BS10111 IDB_GETRUOBLINE_rec_typ   input_desc_block; */
  /* Get_XREF_Rec_Handle *h = NULL; not needed yet */
  Get_XREF_Rec_Handle *h = NULL;                          /* BS10111 */
  char        * ret_str = NULL;   /* returned pointer from strstr */
  /* BS10111 char getfunc[8]="";               /* WS10078T @/    */
  char getfunc[9]="";                                     /* BS10111 */
  char physical_line[135];
  int  xref_not_done;
  int  cur_data_len = 0; /* current data length in output_buffer */
  int  line_data_len = 0; /* data length in line read        BS10113 */
  /* BS10111 char       errmsg[125];  */
  char       errmsg[170] = "";                            /* BS10111 */
  ESA_RC     rc = ESA_OK;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  int        xref_done = 0;
  int        in_xref_element = 0;
  int        int_rc = 0;                                  /* BS10111 */
  int        dbglvl = 0;                                  /* BS10111 */
  /* IS10184 DUMMY_PARAMS_rec_typ     * params_ptr = NULL; * BS10111 **/
  COMMON_PARAMS_rec_typ    * cmnprms = NULL;              /* BS10111 */
 /********** end of variables defintion *************/

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);

  dbglvl = (int)ESA_DIAG_get_debug_level(PLT_COMP_XREF);  /* BS10111 */
  if ( dbglvl GT 0   AND   dbglvl NE 77)                  /* BS10111 */
    dbglvl = 1;                                           /* BS10111 */

  /* BS10111 input_desc_block.blk = ruob;  */

  if (strncmp(function, "TERM", 4) EQ 0)
  {
   ESA_DIAG_printf(PLT_COMP_XREF, 6, "TERM");            /* WS10078T */

     /***************************************************************/
     /* Free all allocated areas.                                   */
     /***************************************************************/
     if (handle NE NULL  AND  *handle NE NULL)           /* WS10076N */
     {
       /*  BS10111 - the code below is replaced by a call
           to ctsaruh with TERMIO
       rc = ESA_CLI_get_RUOB_line("TERM",
                        (void*)&input_desc_block,
                                 /@ESA_CLI_get_RUOB_line's handle is @/
                        (void*)&((*handle)->h_RUOB), /@ within
                                         Get_XREF_Record's handle    @/
                                 physical_line,
                                 133,
                                 admin_params);
          end of replaced code  - BS10111  */

       h = (Get_XREF_Rec_Handle *) *handle;               /* BS10111 */
       if (h->p_ctsaruh NE NULL)                          /* BS10111 */
       {                                                  /* BS10111 */
         int_rc = (*(h->p_ctsaruh))(CTSARUH_REQ_TERMIO,   /* BS10111 */
                          &(h->ctsaruh_handle),           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          NULL,                           /* BS10111 */
                          &dbglvl,                        /* BS10111 */
                          CTSARUH_DBGTYPE_PRTDBG,         /* BS10111 */
                          errmsg,                         /* BS10111 */
                          sizeof(errmsg),                 /* BS10111 */
                          NULL);                          /* BS10111 */

         ESA_DIAG_printf(PLT_COMP_XREF, 6,                /* BS10111 */
                         "CTSARUH - %s: rc = %d",         /* BS10111 */
                         CTSARUH_REQ_TERMIO, int_rc);     /* BS10111 */

         if (int_rc NE 0)   /* if not OK - issue error msg   BS10111 */
         {                                                /* BS10111 */
            if (errmsg[0] NE NULL_CHAR)                   /* BS10111 */
              CTSAMSG_print(ERR_TL_STRING,                /* BS10111 */
                            msgs, NULL, dest, errmsg);    /* BS10111 */
            sprintf(errmsg,                               /* BS10111 */
                "CTSARUH - %s failed with rc=%d.",        /* BS10111 */
                CTSARUH_REQ_TERMIO, int_rc);              /* BS10111 */

            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,      /* BS10111 */
                          dest, component, func, errmsg,  /* BS10111 */
                          int_rc, __LINE__);              /* BS10111 */
         };                                               /* BS10111 */
       };                                                 /* BS10111 */

       free(*handle);
       *handle = NULL;
     };
     goto exit;
  };
     /* only GETNEXT and TERM are valid function values */
  if (strcmp(function, "GETNEXT") NE 0)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, "invalid input function parameter",16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  /******************************************************************
   * Allocate the handle if first call to routine.                  *
   ******************************************************************/
  if (handle EQ NULL)   /* Make sure we have a handle */
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, func,
                   "hanlde parameter is NULL", 16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
  }
  else
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "handle address on entry = %8x", *handle);
  if (*handle EQ NULL)      /* first time ==> allocate the handle */
  {
   *handle = (void *) calloc (1,sizeof(Get_XREF_Rec_Handle));
    if (*handle EQ NULL)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "Get_XREF_Rec handle",
                     sizeof(Get_XREF_Rec_Handle));        /* BS10108 */
       /* BS10108    sizeof(Get_Rule_Rec_Handle));  */
       rc = ESA_FATAL;
       goto exit;
    };
   ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "just allocated Get_XREF_Rec_Handle at(%8x)",*handle);
    h = (Get_XREF_Rec_Handle *) *handle;                  /* BS10111 */

    /*  Get CTSARUH address.                               * BS10111 */
    /* IS10184
    GET_P_CTSARUH(params_ptr, cmnprms, h->p_ctsaruh)   * BS10111 *   */
    GET_CMNPRMS_PROG(admin_params, cmnprms, p_ctsaruh,    /* IS10184 */
                     h->p_ctsaruh, rc, errmsg)            /* IS10184 */
    if (rc NE ESA_OK)   /* Emvironmental error ? */       /* BS10111 */
    {                                                     /* IS10184 */
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,      /* IS10184 */
                    component, func, errmsg,              /* IS10184 */
                    16, __LINE__);                        /* IS10184 */
      goto exit;                                          /* BS10111 */
    };                                                    /* IS10184 */

   /* BS10111 strcpy(getfunc,"GETFIRST");             /@ WS10078T @/ */
   strcpy(getfunc, CTSARUH_REQ_GETFIRST);                 /* BS10111 */
  }
  else                                                   /* WS10078T */
  {                                                       /* BS10111 */
    h = (Get_XREF_Rec_Handle *) *handle;                  /* BS10111 */
    /* BS10111 strcpy(getfunc,"GETNEXT");             /@ WS10078T @/ */
    strcpy(getfunc, CTSARUH_REQ_GETNEXT);                 /* BS10111 */
  }                                                       /* BS10111 */

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
                  "h before starting loop = %8x", *handle);

  /******************************************************************
   * LOOP:  Collect all lines from "LAST CHANGED" until "TOTAL".    *
   * data is collected into output_buffer and its length is kept in *
   * output_length.                                                 *
   * Logic:                                                         *
   * Call CTSARIH to get one physical line.                         *
   * Loop until EOF while xref_not_done                             *
   *  If "LAST CHANGED" keep it as first line in output_buffer      *
   *  If "TOTAL" return to caller with output_buffer & output_length*
   *  Append physical line to output_buffer & update output_length. *
   *  Call ESA_CLI_get_RUOB_line to get one physical line.          *
   * End of loop                                                    *
   ******************************************************************/
  /* call to read first line from LIST LIKE(-) output */
  /* rc = ESA_CLI_get_RUOB_line("GETFIRST",                 WS10078T */
  /* BS10111 - replced by call to CTSARUH
  rc = ESA_CLI_get_RUOB_line(getfunc,                   /@  WS10078T @/
                      (void*)&input_desc_block,
                             /@ESA_CLI_get_RUOB_line's handle is     @/
                      (void*)&((*handle)->h_RUOB), /@ within
                                     Get_XREF_Record's handle        @/
                             physical_line,
                             133,
                             admin_params);
   end of replaced code  - BS10111 */

   int_rc = (*(h->p_ctsaruh))(getfunc,                    /* BS10111 */
                      &(h->ctsaruh_handle),               /* BS10111 */
                      ruob,                               /* BS10111 */
                      physical_line,                      /* BS10111 */
                      NULL,                               /* BS10111 */
                      sizeof(physical_line),              /* BS10111 */
                      NULL,                               /* BS10111 */
                      &dbglvl,                            /* BS10111 */
                      CTSARUH_DBGTYPE_PRTDBG,             /* BS10111 */
                      errmsg,                             /* BS10111 */
                      sizeof(errmsg),                     /* BS10111 */
                      NULL);                              /* BS10111 */

  xref_done = 0;    /* role/source is not ready yet 2 return 2 caller*/
  in_xref_element = 0;          /*not within role/source output lines*/

  /* BS10111 while((rc NE ESA_EOF) AND (NOT xref_done))  */
  while((int_rc EQ 0) AND (NOT xref_done))                /* BS10111 */
  {
   line_data_len = strlen(physical_line);                 /* BS10113 */
   if (NOT in_xref_element)             /* if outside role/source ... */
   {
    ret_str = strstr(physical_line,"LAST CHANGED"); /*xerf 1st line?*/
    if (ret_str NE NULL)                   /* a new role/source found */
    {
     in_xref_element = 1;                       /* inside role/source */
     /* BS10113 if (cur_data_len + 133 LE max_output_length)  */
     if (cur_data_len + line_data_len                     /* BS10113 */
                                LE max_output_length)     /* BS10113 */
     {
      strcpy(output_buffer,physical_line); /*set 1st line 2 b return */
      /* BS10113
      cur_data_len += 133 ; /@ update logical record length    @/ */
      cur_data_len += line_data_len; /* update logical rec len BS10113*/
      ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "1st line of xref element <%s>", physical_line);
     }
     else
     {
      sprintf(errmsg,"max_output_length is too little = <%d>.",
              max_output_length);
      /* BS10113
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, errmsg,
      */
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,      /* BS10113  */
                    component, func, errmsg,              /* BS10113  */
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
     }
    } /* end of LAST CHANGED */
   } /* end of (NOT in_xref_element) */

   else if (in_xref_element)        /* if inside role/source ... */
   {
    ret_str = strstr(physical_line,"TOTAL RECORD LENGTH=");
    if (ret_str NE NULL)                /* last line of role/source? */
    {
     in_xref_element = 0;
     xref_done = 1; /* xref element is done. return to caller */
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
       "End of xref lines <%s>", physical_line);
     break; /* WS10078KG - Stop reading and send record to caller */
    } /* end of TOTAL RECORD LENGTH= */

    else   /*not TOTAL & not 1st xref line ==> inside xref element *
            *so concatenate physical line to logical record.      */
    {
     /*WS10078AG if (cur_data_len + 133 LE max_output_length)*/
     line_data_len -= 22; /* ignore first 22 blanks */    /* BS10113 */
     /*BS10113if (cur_data_len + 111 LE max_output_length) /*WS10078AG*/
     if (cur_data_len + line_data_len LE max_output_length)/* BS10113 */
     {
      /*WS10078AG strcat(output_buffer,physical_line);*/
      strcat(output_buffer,physical_line+22); /*WS10078AG*/
      /*WS10078AG cur_data_len += 133 ; */
      /* BS10113 cur_data_len += 111 ;                  /@WS10078AG@/ */
      cur_data_len += line_data_len;                      /* BS10113 */
      ESA_DIAG_printf(PLT_COMP_XREF, 6,
        "concatenate <%s>", physical_line);
     }
     else
     {
      sprintf(errmsg,"max_output_length is too little = <%d>.",
              max_output_length);
      /* BS10113
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component, errmsg,
      */
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,      /* BS10113 */
                    component, func, errmsg,              /* BS10113 */
                    16, __LINE__);
      rc = ESA_FATAL;
      goto exit;
     }
    }
   } /* end of in_xref_element */
  /* BS10111 - replced by call to CTSARUH
  rc = ESA_CLI_get_RUOB_line("GETNEXT",
                      (void*)&input_desc_block,
                             /@ESA_CLI_get_RUOB_line's handle is     @/
                      (void*)&((*handle)->h_RUOB), /@ within
                                     Get_XREF_Record's handle        @/
                             physical_line,
                             133,
                             admin_params);
      end of replaced code   - BS10111 */
   strcpy(getfunc, CTSARUH_REQ_GETNEXT);                  /* BS10111 */
   int_rc = (*(h->p_ctsaruh))(getfunc,                    /* BS10111 */
                      &(h->ctsaruh_handle),               /* BS10111 */
                      ruob,                               /* BS10111 */
                      physical_line,                      /* BS10111 */
                      NULL,                               /* BS10111 */
                      sizeof(physical_line),              /* BS10111 */
                      NULL,                               /* BS10111 */
                      &dbglvl,                            /* BS10111 */
                      CTSARUH_DBGTYPE_PRTDBG,             /* BS10111 */
                      errmsg,                             /* BS10111 */
                      sizeof(errmsg),                     /* BS10111 */
                      NULL);                              /* BS10111 */

 } /* end of while((int_rc Eq 0) AND (NOT xref_done)) */

 if (int_rc LE 4)   /* OK or EOF */                       /* BS10111 */
 {                                                        /* BS10111 */
   if (xref_done) rc = ESA_OK;
   else rc = ESA_EOF;                                     /* BS10111 */
 }                                                        /* BS10111 */
 else if (int_rc GT 4)   /* if not OK or EOF - error         BS10111 */
 {
    if (errmsg[0] NE NULL_CHAR)                           /* BS10111 */
      CTSAMSG_print(ERR_TL_STRING,                        /* BS10111 */
                    msgs, NULL, dest, errmsg);
    sprintf(errmsg,                                       /* BS10111 */
        "CTSARUH - %s failed with rc=%d.",                /* BS10111 */
        getfunc, int_rc);                                 /* BS10111 */

    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,        /* BS10111 */
                  component, func, errmsg,                /* BS10111 */
                  int_rc, __LINE__);                      /* BS10111 */
    rc = ESA_FATAL;                                       /* BS10111 */
 }

 exit:
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;
}
/*************** WS10078A end ***************/
/*                 start WS10079T                                */
/******************************************************************
 * Procedure Name: XREF_Block_Build
 ******************************************************************
 * Description   :
 * Input         : function:  BUILD - Build the table(s) according
 *               :            to the request type
 *               :            TERM  - free all
 *               : XBhandle
 *               :  from XBhandle:
 *               :  request_type
 *               :            XREFONLY - create only roles/source
 *               :            block. No groups block
 *               :            XREFNGRP - create both roles/sources and
 *               :            groups blocks
 *               :            ONLYSHRT - like XREFNGRP but leave the
 *               :            shortest
 *               :  xrefname
 *               :            role/source for which to create the
 *               :            block. It may or may not contain a sysid
 *               :  PB_type
 *               :            R(ole) or S(ource)
 *               :  active_request
 *               :            C - Check which is active
 *               :            N - no need to check which is active
 *               :  need_rec_YN
 *               :            Y - role/source attributes are required
 *               :            N - role/source attributes not required
 *               : diag_comp
 *               : admin_params
 * output        :
 *****************************************************************/
EXT     ESA_RC XREF_Block_Build(       /* WS10079T changed to EXT */
                 char                     * function,
                 XBhandle_rec_typ         * XBhandle,
                 ESA_DIAG_COMP_typ          diag_comp,
                 ADMIN_PARAMS_rec_typ     * admin_params)
{
 /* BS10113 #define OUTPUT_AREA_LEN 16384   */
 /* Maximum xref record area length = 35K:                   BS10113 */
 /*   32K max xref length + additional data in list output   BS10113 */
 #define OUTPUT_AREA_LEN 35840                           /* BS10113 */
  static char func[] = "XREF_Block_Build";

  ESA_RC                        rc            = ESA_OK;
  ACF2_API_Return_Codes         acf_rc = ACF2_OK;        /* WS10079N */
  ACF2_PARAMS_rec_typ         * params_ptr    = NULL;
  /* BS10111 REXX@UTL_output_blk_rec_typ * pruob         = NULL;  */
  char                          pruob[8];                 /* BS10111 */
  /* BS10111 Get_XREF_Rec_Handle         * h             = NULL;     */
  void                        * h             = NULL;     /* BS10111 */
  char                        * output_area   = NULL;
  char                  rectype[30]           = "";
  char                  sysid_for_command[16] = "";
  char                  xrefname_for_command[19] = "";
  char                  recparm[100]          = "";
  char                  sysid[9]              = "";
  char                  acf2_sysid[9]         = "";
  char                  out_sysid[9]          = "";
  char                * out_activeYN          = "";
  int                   output_area_len       = OUTPUT_AREA_LEN;
  int                   name_split            = FALSE;
  int                   input_sysid_relevant  = FALSE;
  int                   sysid_from_parse_is_relevant = FALSE;
  char                  name[XREF_NAME_SIZE]  = "";
  char                  active                = NULL_CHAR;
  char                  isitgrp               = NULL_CHAR;
  char                  name_from_parse[9]    = "";
  char                  sysid_from_parse[9]   = "";
  char                  main_block            = NULL_CHAR;
  char                  secondary_block       = NULL_CHAR;
  /* BS10111 char       errmsg[125]           = "";                  */
  char                  errmsg[170]           = "";       /* BS10111 */
  PBhandle_typ        * PBhandle              = NULL;
  int                   int_rc                = 0;        /* BS10111 */
  int                   dbglvl                = 0;        /* BS10111 */
  ASM_RTN_TYP         * p_ctsaruh             = NULL;     /* BS10111 */

  COMMON_PARAMS_rec_typ     * cmnprms = NULL;             /* BS10111 */
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(diag_comp, 1, func);

  /*                                                       * BS10111 *
  *   Verify that common_params exists and keep            * BS10111 *
  *   its address and CTSARUH address.                     * BS10111 *
  */                                                      /* BS10111 */
  /* IS10184
  GET_P_CTSARUH(params_ptr, cmnprms, p_ctsaruh)          * BS10111 * */
  GET_CMNPRMS_PROG(admin_params, cmnprms, p_ctsaruh,      /* IS10184 */
                    p_ctsaruh, rc, errmsg)                /* IS10184 */
  if (rc NE ESA_OK)   /* Emvironmental error ? */         /* BS10111 */
  {                                                       /* IS10184 */
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,        /* IS10184 */
                  component, func, errmsg,                /* IS10184 */
                  16, __LINE__);                          /* IS10184 */
    goto exit_final;                                      /* BS10111 */
  };                                                      /* IS10184

  dbglvl = (int)ESA_DIAG_get_debug_level(diag_comp);      /* BS10111 */
  if ( dbglvl GT 0   AND   dbglvl NE 77)                  /* BS10111 */
    dbglvl = 1;                                           /* BS10111 */

  memcpy(pruob, p_ruob_null, 8);  /* init pruob address      BS10111 */

  /*
   *   Validate the funciton
   */

  ESA_DIAG_printf(diag_comp,2,
    "function = %s",function);

  if (strcmp(function, "TERM") EQ 0)
     goto term;
  else
  if (strcmp(function, "BUILD") NE 0)
  {
    sprintf(errmsg,
       "Invalid function = <%.8s>",function);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
    XBhandle->bld_err = TRUE;
    rc = ESA_FATAL;
    goto exit_final;
  }

  /* WS10084
  ctrace("XREF_Block_Build: BUILD ");                /* WS10084 @/
     WS10084 */
  /*
   *   Validate xrefname
   *   Already validated at higher levels
   */

  /*
   *   Get the current SYSID (for "active" check, etc).
   */

  params_ptr = admin_params->apiinit_handle;
  strncpy(acf2_sysid,params_ptr->ACF2_SYSID,9);
  Trim(acf2_sysid);

  /*
   *   Complete the XBhandle setting:
   *   Set sysidYN, active_check and active_default according to the
   *   XBhandle set by the caller, and XREF_SYSID_SCOPE.
   */

  ESA_DIAG_printf(diag_comp,2,
    "XREF_SYSID_SCOPE = %s xrefname = <%.18s>, request_type = <%.8s>, "
    "PB_type = %c, active_request = %c, need_rec_YN = %c "
    "ACF2_SYSID = <%.8s>",
     params_ptr->XREF_SYSID_SCOPE,XBhandle->xrefname,
     XBhandle->request_type,XBhandle->PB_type,XBhandle->active_request,
     XBhandle->need_rec_YN,acf2_sysid);

  if (params_ptr->XREF_SYSID_SCOPE[0] NE 'a')
  {
     /*
      *   When XREF_SYSID_SCOPE != 'a':
      *   sysidYN = N - No sysid entries
      *   active_check  = N - do not check if active
      *   active_default = Y - all are marked as Active.
      */
     XBhandle->sysidYN        = 'N';
     XBhandle->active_check   = 'N';
     XBhandle->active_default = 'Y';
  }
  else if (params_ptr->XREF_SYSID_SCOPE[0] EQ 'a')
  {
     /*
      *   When XREF_SYSID_SCOPE = 'a':
      *   active_default = U
      *   active_check = active_request
      *   If name(sysid)
      *     if active_request=N (do not check if active)->
      *        sysidYN=N (no need for SYSID entry).
      *     if active_request=C -> sysidYN=Y - we need the SYSID
      *        entries inorder to check which is active.
      *   If name without sysid, or  '-' :
      *      sysidYN=Y (regardless of active_request setting,
      *      because we need to return the sysid)
      */
     XBhandle->active_default = 'U';
     XBhandle->active_check   = XBhandle->active_request;

     if (strchr(XBhandle->xrefname, '(') NE NULL)
     {
        rc = XREF_Split_Name(XBhandle->xrefname,
                             name,sysid,diag_comp,admin_params);
        if (rc  EQ ESA_FATAL)
        {
          XBhandle->bld_err = TRUE;
          rc = ESA_FATAL;
          goto exit_final;
        }

        ESA_DIAG_printf(diag_comp,2,
          "After XREF_Split_Name: name=%s sysid=%s",
           name,sysid);
        name_split = TRUE;

        rc = XREF_Match_SYSID(acf2_sysid,
                              sysid,
                              diag_comp,
                              admin_params);
             if (rc EQ 0)
                input_sysid_relevant = TRUE;
             else
                input_sysid_relevant = FALSE;

        if (XBhandle->active_request EQ 'N')
            XBhandle->sysidYN = 'N';

        if (XBhandle->active_request EQ 'C')
            XBhandle->sysidYN = 'Y';
     }
     else
     {
        name_split = FALSE;
        XBhandle->sysidYN = 'Y';
     }
  }

  /* WS10084
  char  request_type[9];  /* XREFONLY, XREFNGRP
  char  xrefname[19];     /* xref(sysid)
  char  PB_type;          /*  R / S
  char  active_request;   /* C(heck) / N(one)
  char  need_rec_YN;      /* xref data is required Y/N
  /* Process @/
  char  sysidYN;          /* SYSID entries exist Y/N
  char  active_check;     /* C(heck) / N(o)
  char  active_default;   /* U / Y
  char  shortest;         /* X / G
     WS10084 */
  /* WS10084 start */
  ESA_DIAG_printf(diag_comp,2,
    "request_type   = %s "
    "xrefname       = %s "
    "PB_type        = %c "
    "active_request = %c "
    "need_rec_YN    = %c "
    "sysidYN        = %c "
    "active_check   = %c "
    "active_default = %c ",
     XBhandle->request_type,
     XBhandle->xrefname,
     XBhandle->PB_type,
     XBhandle->active_request,
     XBhandle->need_rec_YN,
     XBhandle->sysidYN,
     XBhandle->active_check,
     XBhandle->active_default);
  /* WS10084 end   */

  ESA_DIAG_printf(diag_comp,2,
    "active_default set to = %c "
    "active_check   set to = %c "
    "sysidYN set to = %c ",
     XBhandle->active_default,
     XBhandle->active_check,
     XBhandle->sysidYN);


  /*
   *   Prepare the rectype parameter:
   *    Put X(ROL) or X(SGP) according to the PB_type set in
   *    XBhandle.
   *    Call XREF_Set_command_SYSID to get the SYSID. Append it to
   *    rectype in the format type/sysid.
   */

  if (XBhandle->PB_type EQ 'R')
     strcat(rectype,"X(ROL)");
  else
  if (XBhandle->PB_type EQ 'S')
     strcat(rectype,"X(SGP)");

  if ( (name_split)           AND
       (input_sysid_relevant) AND
       (XBhandle->sysidYN EQ 'Y')  )
     strcpy(xrefname_for_command,name); /* we want all SYSIDs of name */
  else
     strcpy(xrefname_for_command,XBhandle->xrefname);

  rc = XREF_Set_Command_SYSID("LIST",
                              xrefname_for_command,
                              sysid_for_command,
                              diag_comp,
                              admin_params);
  if (rc  NE ESA_OK)
  {
    sprintf(errmsg,
       "XREF_Set_Command_SYSID returned rc = %d",
            rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
    XBhandle->bld_err = TRUE;
    rc = ESA_FATAL;
    goto exit_final;
  }

  ESA_DIAG_printf(diag_comp,2,
   "XREF_Set_Command_SYSID has set command sysid to = <%s>",
     sysid_for_command);

  if (strlen(sysid_for_command) GT 0)
  {
     strcat(rectype,"/");
     strcat(rectype,sysid_for_command);
  }

  /*
   *   Prepare the recparm parameter:
   *    If role(sysid) was requested call XREF_Split_Name to split the
   *    xrefname to name and sysid (already split above).
   *    Set recparm with the name to be retrieved.
   */

  if (name_split)
     strcat(recparm,name);
  else
     strcat(recparm,XBhandle->xrefname);

  /*
   *   Call ACF2_Cmd2mem to issue the command and get the output
   */
  ESA_DIAG_printf(diag_comp,2,
          "Before ACF2_Cmd2Mem: rectype=%s recparm=%s",
           rectype,recparm);

  /* WS10079N rc = ACF2_Cmd2Mem(rectype,  */
  acf_rc = ACF2_Cmd2Mem(rectype,                          /* WS10079N */
                    recparm,
                    NULL,
       /* BS10111   &pruob,   */
                    pruob,                                /* BS10111 */
                    diag_comp,
                    admin_params);

  /* BS10111
  ESA_DIAG_printf(diag_comp,2,
          "ACF2_Cmd2Mem for %s returned rc = %d  ruob = %p",
           rectype,rc, pruob);   */
  ESA_DIAG_printf(diag_comp, 2,                           /* BS10111 */
          "ACF2_Cmd2Mem for %s returned rc = %d ...",     /* BS10111 */
           rectype,acf_rc);                               /* WS10079N */
           /* WS10079N rectype,rc);                    /@ BS10111 @/ */
  ESA_DIAG_printf(diag_comp, 2,                           /* BS10111 */
    "   ...and ruob = %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",  /* BS10111 */
          pruob[0],pruob[1],pruob[2],pruob[3],            /* BS10111 */
          pruob[4],pruob[5],pruob[6],pruob[7]);           /* BS10111 */

  /* WS10079N if (rc  NE ESA_OK)  */
  if (acf_rc  GT ACF2_Not_Found)                        /* WS10079N */
  {
    XBhandle->bld_err = TRUE;
    sprintf(errmsg,
            "ACF2_Cmd2Mem returned rc = %d",
            rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
    rc = ESA_FATAL;
    goto exit_final;
  }
  else                                                  /* WS10079N */
    if  (acf_rc  EQ ACF2_Not_Found)   /* Not found */   /* WS10079N */
    {                                                   /* WS10079N */
      XBhandle->bld_nf = TRUE;                          /* WS10079N */
      rc = ESA_KEY_NOT_FOUND;                           /* WS10079N */
      goto exit_final;                                  /* WS10079N */
    };                                                  /* WS10079N */

  /*
   *   If nothing was returned - error.
   */

  /* BS10111 if (pruob EQ NULL)  */
  if (memcmp(pruob, p_ruob_null, 8) EQ 0)                 /* BS10111 */
  {
    XBhandle->bld_err = TRUE;
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                  "No output was returned by ACF2_Cmd2Mem",
                  16, __LINE__);
    rc = ESA_FATAL;
    goto exit_final;
  }

  /*
   *   Prepare the main control blocks:
   *    For XREFONLY, Allocate and initialize the blocks for the
   *   XREF block.
   *    For XREFNGRP / ONLYSHRT, allocate the initialize the blocks
   *   for the XREF and groups blocks.
   *
   */

  rc = XREF_Prep_CB(
            XBhandle,
            'X',
            &(XBhandle->XREF_PB_handle),
            diag_comp,
            admin_params);

  if (rc  NE ESA_OK)
  {
    XBhandle->bld_err = TRUE;
    sprintf(errmsg,
            "XREF_Prep_CB of XREF_PB_handle returned rc = %d",
            rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
    rc = ESA_FATAL;
    goto exit_error;
  }

  if (   (strcmp(XBhandle->request_type,"XREFNGRP") EQ 0)  OR
         (strcmp(XBhandle->request_type,"ONLYSHRT") EQ 0)     )
  {
    rc = XREF_Prep_CB(
              XBhandle,
              'G',
              &(XBhandle->Groups_PB_handle),
              diag_comp,
              admin_params);

    if (rc  NE ESA_OK)
    {
      XBhandle->bld_err = TRUE;
      sprintf(errmsg,
         "XREF_Prep_CB of Groups_PB_handle returned rc = %d",
              rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit_error;
    }
  }


  output_area = calloc(1, output_area_len);

  if (output_area EQ NULL)
  {
    XBhandle->bld_err = TRUE;
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Output area for Get_XREF_Record", output_area_len);
    rc = ESA_FATAL;
    goto exit_error;
  };

  /*
   *   Loop:
   *   1 Call Get_XREF_Record to get an xref record
   *   2 Call Parse_XREF_Record with the SYSID and isitgroup parameters
   *     (but no addinfo) in order to get role name, type (role/group)
   *     and SYSID.
   */

  while (TRUE)
  {
    /*
     *   Call Get_XREF_Record to get an xref record
     */
    rc = Get_XREF_Record(
               "GETNEXT",
               &h,
               pruob,
               output_area,
               output_area_len,
               admin_params);

    if (rc  EQ ESA_EOF)
        break;

    if (rc  NE ESA_OK)
    {
      XBhandle->bld_err = TRUE;
      sprintf(errmsg,
         "Get_XREF_Record rc = %d",
              rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit_error;
    }

    /*
     *   Call Parse_XREF_Record with the SYSID and isitgroup parameters
     *   (but no addinfo) in order to get role name, type (role/group)
     *   and SYSID.
     */

    rc = Parse_XREF_Record(
               name_from_parse,   /* of role/source/group  */
               sysid_from_parse,  /* of role/source/group  */
               NULL,
               output_area,
               'Y',
               &isitgrp,
               admin_params);

    if (rc  NE ESA_OK)
    {
      XBhandle->bld_err = TRUE;
      sprintf(errmsg,
         "Parse_XREF_Record = %d",
              rc);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
      rc = ESA_FATAL;
      goto exit_error;
    }

    ESA_DIAG_printf(diag_comp,2,
          "After Parse_XREF_Record: name=%s sysid=%s isitgrp=%c",
           name_from_parse,sysid_from_parse,isitgrp);
    /*
     *   When active_check=C
     *   Keep active and not-active xref/group, and mark each entry
     *   as active/inactive.
     *   - When name(sysid) - keep only this SYSID, with an indication
     *     of active/inactive. So, if we find it as not relevant,
     *     or we find a more-relevant xref/group, we mark as not-active
     *     and leave the loop.
     *   - When name/'-', we keep all, each with its active indication.
     *     The user may have XREFs and groups with the same name and
     *     different SYSIDs. We handle each in a different table,
     *     so when a record is found as active, we need to check if
     *     there is already active entry in the "other" table, and
     *     if there is, update the entry and set as inactive.
     */

    if (XBhandle->active_check EQ 'C')
    {
       rc = XREF_Match_SYSID(acf2_sysid,         /* relevant? */
                             sysid_from_parse,
                             diag_comp,
                             admin_params);
       if (rc EQ ESA_OK)
          sysid_from_parse_is_relevant = TRUE;   /* yes       */
       else
          sysid_from_parse_is_relevant = FALSE;  /* no        */

       /*
        *  If Xref  record - Set:
        *     Main block = XREF
        *     Secondary block = group
        */

       if (isitgrp EQ 'X')                           /* XREF? */
       {
          main_block      = 'X';
          secondary_block = 'G';

       }

       if (isitgrp EQ 'G')                           /* group?       */
       {
          if (strcmp(XBhandle->request_type,
                     "XREFONLY") EQ 0)               /* XREFONLY?    */
          {
                 if (strcmp(sysid,sysid_from_parse) EQ 0)
                     /* we want it as XREF, but it is a group: leave */
                     break;
             /*
              *      If relevant, look if this group name appears as
              *      active in xref block.
              *      Prepare the parameters block for
              *      XREF_Block_getSYSID (set in_active=Y and ask to
              *      get the SYSID entry address, and call
              *      Peremssions_Block_Get UID with UIDTHIS to look for
              *      the name in the XREF block.
              *      If found as active in XREF block, inactivate it.
              */

             if (NOT sysid_from_parse_is_relevant) /* if not relevant */
                continue;                          /* skip it         */

             PBhandle = XBhandle->XREF_PB_handle;

             rc = XREF_Find_and_Inactivate(
                             PBhandle,
                             name_from_parse,
                             NULL,
                             NULL,
                             diag_comp,
                             admin_params);
             continue;
          }  /* XREFONLY     */

          /*
           *      If XREFNFRP / ONLYSHRT
           *         Set:
           *         Main block=group
           *         Secondary block=XREF
           */

          if ( (strcmp(XBhandle->request_type,"XREFNGRP") EQ 0)  OR
               (strcmp(XBhandle->request_type,"ONLYSHRT") EQ 0)     )
          {
             main_block      = 'G';
             secondary_block = 'X';
          }  /* XREFNGRP / ONLYSHRT */

       }    /* Group   */
     /*
      *    If name(sysid) was requested (the list was done with
      *    the name only so we get all SYSIDS)
      */
     if (name_split)
     {
        /*
         *      If the SYSID of the record matches the input, add to
         *      the main block as active/inactive:  (when name(sysid)
         *      we add only if it is us so no need to check if any
         *      other exists)
         */
        if (strcmp(sysid,sysid_from_parse) EQ 0)
        {
           /*
            *    Call Permissions_Block_Insert to add role to the
            *    main table with its SYSID entry. If relevant,
            *    mark as active.
            *    (see Inserting an entry below).
            */

            /*
             *   Inserting an entry
             *   If sysidYN=Y, prepare parameters for
             *      SYSID extension routines.
             *   Else, if need_rec_YN=Y, prepare parameters
             *          for REC extension routines
             *   Else, no extension routines.
             *   When active_check=C and entry is active:
             *    Set activeYN=Y
             *    Set updActYN=Y to ask the insert routine to
             *       remove the active indication from the
             *       current active entry.
             *   When need_rec_YN=Y:
             *    Allocate an area with the length of the
             *    record and copy the record. Pass this record
             *    to the extension routines.
             *   Call Permissions_Block_Insert to insert the
             *      record to the appropriate block
             *   If the entry was added, call
             *      Permissions_Block_UpdateIndex
             *      (as done in Permissions_Block_Build)
             */

            if (main_block EQ 'X')
               PBhandle = XBhandle->XREF_PB_handle;
            else
               PBhandle = XBhandle->Groups_PB_handle;

            if (sysid_from_parse_is_relevant)
               active = 'Y';
            else
               active = 'N';
            /* WS10084
            ESA_DIAG_printf(diag_comp, 0,                   /* WS10084 @/
             "1 calling Insert_PBXB_Entry");                /* WS10084 @/
               WS10084 */
            rc = Insert_PBXB_Entry(
                 XBhandle,
                 PBhandle,
                 name_from_parse,
                 sysid_from_parse,
                 acf2_sysid,
                 active,
                 output_area,
                 diag_comp,
                 admin_params);

            if (rc  NE ESA_OK)
            {
              sprintf(errmsg,
                 "Insert_PBXB_Entry returned rc = %d",rc);
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                             dest, component,
                             func, errmsg, 16, __LINE__);
              XBhandle->bld_err = TRUE;
              rc = ESA_FATAL;
              goto exit_error;
            }

            /*
             *  If active, continue the loop  get next record
             *  (we may  need to remove the active indication if
             *  another role with the same  name if later found
             *  to be active).
             *  otherwise, leave the loop.
             *  (note: relevant is active so we check relevance)
             */


             if (sysid_from_parse_is_relevant)    /* relevant?     */
                continue;                         /* yes: continue */
             else
                break;                            /* no : leave    */

        } /* If the SYSID of the record matches the input   */
        else    /* the SYSID of the record does not match the input */
        {

           /*
            *      If the SYSID of the record does not match the input
            *           we need to check if the requested SYSID was
            *           already found, and if its status has to be
            *           changed:
            */

           /*
            *        If the new record is not relevant ignore this
            *           record and continue the loop (get next record).
            */

            if (NOT sysid_from_parse_is_relevant) /* if not relevant */
                continue;                         /* ignore          */

           /*
            *        Prepare the parameters block for
            *           XREF_Block_GetSYSID and call
            *           Permissions_Block_GET
            *           with UIDTHIS, in_active=Y and in_SYSID=sysid
            *           from the requested name(sysid) in order to check
            *           if the requested name(sysid) is active.
            *        If found, call XREF_Block_UpdateSYSID to change
            *           it to not-active and leave the loop
            *           (we have nothing more to do).
            */

            if (main_block EQ 'X')
               PBhandle = XBhandle->XREF_PB_handle;
            else
               PBhandle = XBhandle->Groups_PB_handle;

            rc = XREF_Find_and_Inactivate(
                             PBhandle,
                             name_from_parse,
                             sysid,
                             NULL,
                             diag_comp,
                             admin_params);

            if (rc EQ ESA_OK)
               break;
           /*
            *        If not found, and a secondary block exists, repeat
            *           the above 2 steps for the secondary block
            *          (in case it is set as active there).
            */

            if (rc EQ ESA_KEY_NOT_FOUND)          /* not found  */
            {
              if (secondary_block EQ 'X')
                  PBhandle = XBhandle->XREF_PB_handle;
              else
                  PBhandle = XBhandle->Groups_PB_handle;

              if (PBhandle NE NULL)
              {
                rc = XREF_Find_and_Inactivate(
                            PBhandle,
                            name_from_parse,
                            sysid,
                            NULL,
                            diag_comp,
                            admin_params);

                if (rc EQ ESA_OK)
                    break;
                if (rc EQ ESA_KEY_NOT_FOUND)     /* not found  */
                    continue;

                /* some other bad rc  */
                XBhandle->bld_err = TRUE;
                sprintf(errmsg,
                   "XREF_Find_and_Inactivate rc = %d",
                        rc);
                CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                             dest, component,
                             func, errmsg, 16, __LINE__);
                rc = ESA_FATAL;
                goto exit_error;
              }
            }
            else    /* some other bad rc  */
            {
              XBhandle->bld_err = TRUE;
              sprintf(errmsg,
                 "XREF_Find_and_Inactivate rc = %d",
                      rc);
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                           dest, component,
                           func, errmsg, 16, __LINE__);
              rc = ESA_FATAL;
              goto exit_error;
            }
            continue;
        } /* end: sysid of the record doesn't matches the input */
     } /* end: if name(sysid) was requested */

     /*
      *    In all other cases (name or - was requested):
      *      Call Permissions_Block_Insert to add the record
      *        to the main block with its SYSID entry. If active
      *        set activeYN, and ask to update the previous active
      *        entry. (see Inserting an entry below)
      */


     if (main_block EQ 'X')
        PBhandle = XBhandle->XREF_PB_handle;
     else
        PBhandle = XBhandle->Groups_PB_handle;


     if (sysid_from_parse_is_relevant)
        active = 'Y';
     else
        active = 'N';
     /* WS10084
     ESA_DIAG_printf(diag_comp, 0,                          /* WS10084 @/
             "2 calling Insert_PBXB_Entry");                /* WS10084 @/
        WS10084 */
     rc = Insert_PBXB_Entry(
          XBhandle,
          PBhandle,
          name_from_parse,
          sysid_from_parse,
          acf2_sysid,
          active,
          output_area,
          diag_comp,
          admin_params);

     if (rc  NE ESA_OK)
     {
       sprintf(errmsg,
          "Insert_PBXB_Entry returned rc = %d",rc);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                      dest, component,
                      func, errmsg, 16, __LINE__);
       XBhandle->bld_err = TRUE;
       rc = ESA_FATAL;
       goto exit_error;
     }

     /*
      *      If a secondary block exists (XREFNGRP/ONLYSHRT),
      *        call Permissions_Block_Get with UIDTHIS,  provide
      *        the name (without SYSID) and set in_active=Y to get
      *        the active entity.
      *      If an active entry was found, call
      *        XRef_Block_updaeSYSID to set this entry as inactive.
      */

      if (secondary_block EQ 'X')
         PBhandle = XBhandle->XREF_PB_handle;
      else
         PBhandle = XBhandle->Groups_PB_handle;

      if (PBhandle NE NULL)
      {
             rc = XREF_Find_and_Inactivate(
                             PBhandle,
                             name_from_parse,
                             NULL,
                             NULL,
                             diag_comp,
                             admin_params);


        if ( (rc EQ ESA_OK) OR (rc EQ ESA_KEY_NOT_FOUND) )
        {
           continue;
        }
        else    /* some other bad rc  */
        {
          XBhandle->bld_err = TRUE;
          sprintf(errmsg,
             "XREF_Find_and_Inactivate rc = %d",
                  rc);
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                       dest, component,
                       func, errmsg, 16, __LINE__);
          rc = ESA_FATAL;
          goto exit_error;
        }
     }
    } /* end of active_check EQ 'C' */

    /*
     *   4. When active_check=N
     *      Put all records in xref/group blocks according to their
     *      type. If sysidYN=Y, set active indication as active_default.
     *    4.1. If Xref  record  Set Main block =XREF
     *    4.2. If Group  record:
     *      4.2.1. If XREFONLY, ignore the record.
     *      4.2.2. Else, Set main block =group
     *    4.3. Call Permissions_Block_Insert to add
     *         it to the main table. If sysidYN=Y, set
     *         actve=active_default
     */
    if (XBhandle->active_check EQ 'N')
    {
     if (isitgrp EQ 'X')                           /* XREF? */
        PBhandle = XBhandle->XREF_PB_handle;
     else
     {
        if (strcmp(XBhandle->request_type,"XREFONLY") EQ 0)
            continue;

        PBhandle = XBhandle->Groups_PB_handle;
     }
     /* WS10084
     ESA_DIAG_printf(diag_comp, 0,                          /* WS10084 @/
             "3 calling Insert_PBXB_Entry");                /* WS10084 @/
        WS10084 */
     rc = Insert_PBXB_Entry(
          XBhandle,
          PBhandle,
          name_from_parse,
          sysid_from_parse,
          acf2_sysid,
          NULL_CHAR,
          output_area,
          diag_comp,
          admin_params);

     if (rc  NE ESA_OK)
     {
       sprintf(errmsg,
          "Insert_PBXB_Entry returned rc = %d",rc);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                      dest, component,
                      func, errmsg, 16, __LINE__);
       XBhandle->bld_err = TRUE;
       rc = ESA_FATAL;
       goto exit_error;
     }
    } /* end of active_check EQ 'N'  */
  }  /* while */
  /*
   *     Epilogue
   *    When no more roles in LIST output:
   */

  /*
   *    Call Permissions_Block_UpdateIndex with LastCall
   *         indication.
   */
  if (XBhandle->XREF_PB_handle NE NULL)
  {
     PBhandle = XBhandle->XREF_PB_handle;
     rc = Permissions_Block_updateIndex(&(PBhandle->PBptr),
                                     TRUE,
                                     diag_comp,
                                     admin_params);
     if (rc NE ESA_OK)
     {
       sprintf(errmsg,
         "Permissions_Block_UpdateIndex for last in XREF_PB_handle "
         "returned rc = %d",rc);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                     dest, component,
                     func, errmsg, 16, __LINE__);
       rc = ESA_FATAL;
       XBhandle->bld_err = TRUE;
       goto exit_error;
     };
  }

  if (XBhandle->Groups_PB_handle NE NULL)
  {
     PBhandle = XBhandle->Groups_PB_handle;
     rc = Permissions_Block_updateIndex(&(PBhandle->PBptr),
                                     TRUE,
                                     diag_comp,
                                     admin_params);
     if (rc NE ESA_OK)
     {
       sprintf(errmsg,
         "Permissions_Block_UpdateIndex for last in Groups_PB_handle "
         "returned rc = %d",rc);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                     dest, component,
                     func, errmsg, 16, __LINE__);
       rc = ESA_FATAL;
       XBhandle->bld_err = TRUE;
       goto exit_error;
     };
  }

  /*
   *    Check each PBHeader to see which is the shortest and set in
   *         XBheader
   */
  if (strcmp(XBhandle->request_type,"XREFONLY") NE 0)
  {
     if (XBhandle->XREF_PB_handle->PBptr->num_uids   GT
         XBhandle->Groups_PB_handle->PBptr->num_uids)
         XBhandle->shortest = 'G';
     else
         XBhandle->shortest = 'X';
  }

  /*
   *    If ONLYSHRT, free the longer block with its headers, etc.
   *         and clear its address in the XBhandle.
   */
  if (strcmp(XBhandle->request_type,"ONLYSHRT") EQ 0)
  {

     if (XBhandle->shortest EQ 'G')
     {
         PBhandle = XBhandle->XREF_PB_handle;
         XBhandle->XREF_PB_handle = NULL;
     }
     if (XBhandle->shortest EQ 'X')
     {
         PBhandle = XBhandle->Groups_PB_handle;
         XBhandle->Groups_PB_handle = NULL;
     }

     rc = Free_PBXB(PBhandle,
                    diag_comp,
                    admin_params);

     if (rc NE ESA_OK)
     {
       sprintf(errmsg,
          "Free_PBXB returned rc = %d",rc);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                      dest, component,
                      func, errmsg, 16, __LINE__);
       XBhandle->bld_err = TRUE;
       rc = ESA_FATAL;
       goto exit_error;
     }
  }

  /*
   *    Put each/the address of the PBHeader in each/the PBHandle..
   *    Put each/the address of the PBHandle in the XBHandle.
   *        note: already done by XREF_Prep_CB
   */

  /*    WS10079N - start */
  /*    Print the xref and/or groups blocks */
  if (ESA_DIAG_get_debug_level(diag_comp) GE 1)
  {
      ESA_DIAG_printf(diag_comp, 0,
                      "Printing the XREF blocks");
      ESA_DIAG_printf(diag_comp, 0,
                      "=========================");
      XREF_Block_Print(XBhandle, diag_comp, admin_params);
  };
  /*    WS10079N - end   */

  /*   BS10111 = the code below is replaced by a call to ctsaruh
  /@
   *    Call ESA_CLI_Del_RUOB to free the RUOB
   @/
  rc = ESA_CLI_del_RUOB(pruob,admin_params);
  if (rc NE ESA_OK)
  {
    sprintf(errmsg,
            "ESA_CLI_del_RUOB returned rc = %d  for ruob = %p",
            rc, pruob);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg, 12, __LINE__);
  };
      end of replaced code - BS10111 */

  /*                                                       * BS10111 *
   *    Call CTSARUH to free the RUOB                      * BS10111 *
   */                                                     /* BS10111 */
  int_rc = (*(p_ctsaruh))(CTSARUH_REQ_FREERUOB,           /* BS10111 */
                    NULL, pruob,                          /* BS10111 */
                    NULL, NULL, NULL, NULL,               /* BS10111 */
                    &dbglvl, CTSARUH_DBGTYPE_PRTDBG,      /* BS10111 */
                    errmsg, sizeof(errmsg), NULL);        /* BS10111 */
  ESA_DIAG_printf(diag_comp, 6,                           /* BS10111 */
                  "CTSARUH - %s: rc = %d",                /* BS10111 */
                   CTSARUH_REQ_FREERUOB, int_rc);         /* BS10111 */

  if (int_rc NE 0)   /* if not OK - issue error msg          BS10111 */
  {                                                       /* BS10111 */
     if (errmsg[0] NE NULL_CHAR)                          /* BS10111 */
       CTSAMSG_print(ERR_TL_STRING,                       /* BS10111 */
                     msgs, NULL, dest, errmsg);           /* BS10111 */
     sprintf(errmsg,                                      /* BS10111 */
         "CTSARUH - %s failed with rc=%d.",               /* BS10111 */
         CTSARUH_REQ_FREERUOB, int_rc);                   /* BS10111 */

     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,             /* BS10111 */
                   dest, component, func, errmsg,         /* BS10111 */
                   int_rc, __LINE__);                     /* BS10111 */
  };                                                      /* BS10111 */

  /* WS10079T start */
  Get_XREF_Record("TERM",
                  &h,
                  NULL,
                  NULL,
                  0,
                  admin_params);
  /* WS10079T end   */

  /*
   *    Need to check what other cleanup actions should be done.
   */
  if (output_area NE NULL)
     free(output_area);
  goto exit_final;

  exit_error:
  /*
   *   When any error in the process:
   *    Free all blocks already allocated, including the ruob.
   *    Set bld_err=TRUE in XBhandle
   */
    XBhandle->bld_err = TRUE;

    /*    WS10079N - start */
    /*    Print the xref and/or groups blocks */
      ESA_DIAG_printf(diag_comp, 0,
                      "Printing the XREF blocks after build error");
      ESA_DIAG_printf(diag_comp, 0,
                      "==========================================");
      XREF_Block_Print(XBhandle, diag_comp, admin_params);
    /*    WS10079N - end   */

  /*   BS10111 = the code below is replaced by a call to ctsaruh
  if (pruob NE NULL)
  {
     rc = ESA_CLI_del_RUOB(pruob,admin_params);
     if (rc NE ESA_OK)
     {
       sprintf(errmsg,
               "ESA_CLI_del_RUOB returned rc = %d  for ruob = %p",
               rc, pruob);
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, errmsg, 12, __LINE__);
     };
  };
    end of replaced code   - BS10111 */
  if ( memcmp(pruob, p_ruob_null, 8) NE 0)                /* BS10111 */
  {                                                       /* BS10111 */
    int_rc = (*(p_ctsaruh))(CTSARUH_REQ_FREERUOB,         /* BS10111 */
                      NULL, pruob,                        /* BS10111 */
                      NULL, NULL, NULL, NULL,             /* BS10111 */
                      &dbglvl, CTSARUH_DBGTYPE_PRTDBG,    /* BS10111 */
                      errmsg, sizeof(errmsg), NULL);      /* BS10111 */
    ESA_DIAG_printf(diag_comp, 6,                         /* BS10111 */
                    "CTSARUH - %s: rc = %d",              /* BS10111 */
                     CTSARUH_REQ_FREERUOB, int_rc);       /* BS10111 */

    if (int_rc NE 0)   /* if not OK - issue error msg        BS10111 */
    {                                                     /* BS10111 */
       if (errmsg[0] NE NULL_CHAR)                        /* BS10111 */
         CTSAMSG_print(ERR_TL_STRING,                     /* BS10111 */
                       msgs, NULL, dest, errmsg);         /* BS10111 */
       sprintf(errmsg,                                    /* BS10111 */
           "CTSARUH - %s failed with rc=%d.",             /* BS10111 */
           CTSARUH_REQ_FREERUOB, int_rc);                 /* BS10111 */

       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,           /* BS10111 */
                     dest, component, func, errmsg,       /* BS10111 */
                     int_rc, __LINE__);                   /* BS10111 */
    };                                                    /* BS10111 */
  };                                                      /* BS10111 */
  if (output_area NE NULL)
     free(output_area);

  /* WS10079T start */
  Get_XREF_Record("TERM",
                  &h,
                  NULL,
                  NULL,
                  0,
                  admin_params);
  /* WS10079T end   */

  exit_free:
  /*
   *   When any error in the process, or when called with TERM
   *   Free the PBhandles pointed by the XBhandle.
   */
  /* WS10084
  ctrace("exit_free: before freeing XREF_PB_handle and Groups_PB_handle");
     WS10084    */
  ESA_DIAG_printf(diag_comp, 6,                           /* WS10084 */
      "Before Free_PBXB XBhandle->XREF_PB_handle = %p",   /* WS10084 */
       XBhandle->XREF_PB_handle);                         /* WS10084 */
  if(XBhandle->XREF_PB_handle NE NULL)
  {
     Free_PBXB(XBhandle->XREF_PB_handle,
               diag_comp,
               admin_params);
     XBhandle->XREF_PB_handle = NULL;
      ESA_DIAG_printf(diag_comp, 6,
      "Freed XREF_PB_handle \n");
  }

  if(XBhandle->Groups_PB_handle NE NULL)
  {
     Free_PBXB(XBhandle->Groups_PB_handle,
               diag_comp,
               admin_params);
     XBhandle->Groups_PB_handle = NULL;
      ESA_DIAG_printf(diag_comp, 6,
      "Freed Groups_PB_handle \n");
  }

  goto exit_final;

  term:
  /* WS10084
  ctrace("XREF_Block_Build: TERM ");              /* WS10084 @/
     WS10084 */
  if (XBhandle->bld_err)
      goto exit_final;
  goto exit_free;

  exit_final:
  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;

}
/*****************************************************************
 * Procedure Name: XREF_Prep_CB
 *
 * Description:
 *   Allocate and initialize the Blocks of one type (XREF or Group)
 *    Allocate and initialize PBhandle.
 *     If sysidYN=Y, Allocate and initialize XB_SYSID_PBhandle.
 *    Allocate and initialize PBHeader and the XB_PBHeader_ext .
 *     If sysidYN=Y:
 *        Set ext_type=S in PBhandle.
 *        Allocate an area for PB_rtnblk_ext and for the SYSID
 *        routines parameters block (XB_PB_SYSID_rtnparms_rec_typ),
 *        and initialize.
 *     Else, if need_rec_YN=Y,
 *        Set ext_type=R in PBhandle.
 *        Allocate an area for PB_rtnblk_ext and for the
 *        "only record" routines and parameters block
 *        (XB_PB_onlyrec_rtnparms_rec_typ), and initialize..
 *     Else, set ext_type=N in PBhandle.
 *     =============================================
 * input         XBhandle
 *               XorG
 *               PBhandle
 *                from XBhandle:
 *                 PB_type
 *                 need_rec_YN
 *               diag_comp
 *               admin_params
 *
 ******************************************************************/

static ESA_RC XREF_Prep_CB(
             XBhandle_rec_typ         * XBhandle,
             char                       XorG,
             PBhandle_typ            ** PBhandle,
             ESA_DIAG_COMP_typ          diag_comp,
             ADMIN_PARAMS_rec_typ     * admin_params)

{
 static char func[] = "XREF_Prep_CB";

 ESA_RC                           rc                    = ESA_OK;
 int                              pbh_len               = 0 ;
 PB_rtnblk_ext_rec_typ          * PtrExRtn              = NULL;
 void                           * PtrExRtPrms           = NULL;
 XB_PB_SYSID_rtnparms_rec_typ   * PtrExRtSysPrms        = NULL;
 XB_PB_onlyrec_rtnparms_rec_typ * PtrExRtRecPrms        = NULL;
 XB_InsertSYSID_parms_typ       * PtrExRtPrmsInsSysPrms = NULL;
 XB_GetSYSID_parms_typ          * PtrExRtPrmsGetSysPrms = NULL;
 XB_InsertRec_parms_typ         * PtrExRtPrmsInsRecPrms = NULL;
 XB_GetRec_parms_typ            * PtrExRtPrmsGetRecPrms = NULL;
 XB_SYSID_PBhandle_rec_typ      * SYSID_PBhandle        = NULL;
 XB_PBheader_ext_rec_typ        * PtrExtRec             = NULL;

 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);
 /*
  *     Allocate PBhandle
  */

 *PBhandle  = calloc (1, sizeof(PBhandle_typ));
 if (NOT *PBhandle)
 {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
            "PBhandle", sizeof(PBhandle_typ));
    rc = ESA_FATAL;
    goto exit;
 }


 /*
  *     Init PBhandle
  */

 strcat((*PBhandle)->blockid,"[XB]");
 (*PBhandle)->PB_type       = XBhandle->PB_type;
 (*PBhandle)->XREF_or_Group = XorG;
 (*PBhandle)->curUIDinPB    = NULL;
 (*PBhandle)->curPERMinPB   = NULL;
 (*PBhandle)->PBbldErr      = FALSE;
 (*PBhandle)->PBErr         = FALSE;
 (*PBhandle)->PBnf          = FALSE;                      /* WS10079N */


 /*
  *     Allocate PBheader
  */

 pbh_len = sizeof(PERM_BLK_HDR_rec_typ) +
              (sizeof(PB_INDEX_rec_typ) * PBH_INITAL_IX_NUM);
 (*PBhandle)->PBptr = (PERM_BLK_HDR_rec_typ *)calloc(1, pbh_len);

 if ((*PBhandle)->PBptr EQ NULL)
 {
   CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,"PBheader",pbh_len);
   rc = ESA_FATAL;
   goto exit;
 };


 /*
  *     init     PBheader
  */

 strncpy((*PBhandle)->PBptr->eyecatcher, PBH_EYECATCHER,
                      sizeof(PBH_EYECATCHER) );
 (*PBhandle)->PBptr->num_ix_ent = PBH_INITAL_IX_NUM + 1;
 (*PBhandle)->PBptr->table_type = XBhandle->PB_type;


 /*
  *     Allocate XB_PBheader_ext
  */

 (*PBhandle)->PBptr->ext_block_header =
       (void *)calloc(1, sizeof(XB_PBheader_ext_rec_typ));

 if ((*PBhandle)->PBptr->ext_block_header  EQ NULL)
 {
   CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
        "XB_PBheader_ext",sizeof(XB_PBheader_ext_rec_typ));
   rc = ESA_FATAL;
   goto exit;
 };

 /*
  *     init     XB_PBheader_ext
  */
 PtrExtRec = (XB_PBheader_ext_rec_typ *)
             (*PBhandle)->PBptr->ext_block_header;
 strcpy(PtrExtRec->eyec,"XBHE");
 PtrExtRec->xbtype = XBhandle->PB_type;


 if (XBhandle->sysidYN EQ 'Y')
 {
    (*PBhandle)->ext_type = 'S';

    /*
     *     Allocate XB_SYSID_PBhandle
     */

    (*PBhandle)->handle_extension =
               calloc (1, sizeof(XB_SYSID_PBhandle_rec_typ));
    if (NOT (*PBhandle)->handle_extension)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "XB_SYSID_PBhandle_rec_typ",sizeof(XB_SYSID_PBhandle_rec_typ));
       rc = ESA_FATAL;
       goto exit;
    }

    /*
     *     Init     XB_SYSID_PBhandle
     */

    SYSID_PBhandle =
        (XB_SYSID_PBhandle_rec_typ *)(*PBhandle)->handle_extension;
    strcpy(SYSID_PBhandle->eyec,"XBSE");
    SYSID_PBhandle->currXREF      = NULL;
    SYSID_PBhandle->curSYSIDinBlk = NULL;
    SYSID_PBhandle->sysidEOF      = FALSE;
 }


 if (  (XBhandle->sysidYN EQ 'Y') OR
       (XBhandle->need_rec_YN EQ 'Y')  )
 {

    /*
     *     Allocate PB_rtnblk_ext
     */
    (*PBhandle)->PBptr->ext_block_routines  =
                calloc (1, sizeof(PB_rtnblk_ext_rec_typ));
    PtrExRtn = (*PBhandle)->PBptr->ext_block_routines;
    if (NOT  PtrExRtn)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "PB_rtnblk_ext_rec_typ",sizeof(PB_rtnblk_ext_rec_typ));
       rc = ESA_FATAL;
       goto exit;
    }

    /*
     *     Init (partialy) PB_rtnblk_ext
     *          Additional specific init below
     */

    strcpy(PtrExRtn->eyec,"PBRE");
 }

 if  (XBhandle->sysidYN EQ 'Y')
 {
    (*PBhandle)->ext_type = 'S';

    /*
     *    Allocate XB_PB_SYSID_rtnparms
     */

    PtrExRtn->p_rtnparms =
        (void *)calloc (1, sizeof(XB_PB_SYSID_rtnparms_rec_typ));
    PtrExRtPrms = PtrExRtn->p_rtnparms;
    if (NOT  PtrExRtPrms)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
       "XB_PB_SYSID_rtnparms",sizeof(XB_PB_SYSID_rtnparms_rec_typ));
       rc = ESA_FATAL;
       goto exit;
    }

    /*
     *    Init     XB_PB_SYSID_rtnparms
     */

    PtrExRtSysPrms = (XB_PB_SYSID_rtnparms_rec_typ *)PtrExRtPrms;
    strcpy(PtrExRtSysPrms->eyec,"XBSP");
    PtrExRtSysPrms->p_XBhandle = XBhandle;
    /*
     *    Init     XB_PB_SYSID_rtnparms->insert_params
     */
    /* WS10079N
    PtrExRtPrmsInsSysPrms = PtrExRtSysPrms->insert_parms;
    */
    PtrExRtPrmsInsSysPrms = &PtrExRtSysPrms->insert_parms;
    PtrExRtPrmsInsSysPrms->SYSID    = NULL;
    PtrExRtPrmsInsSysPrms->ActiveYN = NULL_CHAR;
    PtrExRtPrmsInsSysPrms->xref_rec = NULL;
    PtrExRtPrmsInsSysPrms->updActYN = NULL_CHAR;
    /*
     *    Init     XB_PB_SYSID_rtnparms->get_params
     */
    /* WS10079N
    PtrExRtPrmsGetSysPrms = PtrExRtSysPrms->get_parms;
    */
    PtrExRtPrmsGetSysPrms = &PtrExRtSysPrms->get_parms;
    PtrExRtPrmsGetSysPrms->Function[0]       = NULL_CHAR;
    PtrExRtPrmsGetSysPrms->in_SYSID          = NULL;
    PtrExRtPrmsGetSysPrms->in_Active         = NULL_CHAR;
    PtrExRtPrmsGetSysPrms->out_SYSID         = NULL;
    PtrExRtPrmsGetSysPrms->out_ActiveYN      = NULL;
    PtrExRtPrmsGetSysPrms->out_num_of_SYSIDs = NULL;
    PtrExRtPrmsGetSysPrms->out_xref_rec      = NULL;
    PtrExRtPrmsGetSysPrms->out_SYSID_ent     = NULL;
    /*
     *     Init the SYSID routines in PB_rtnblk_ext
     */
    PtrExRtn->insert = XREF_Block_InsertSYSID;
    PtrExRtn->get    = XREF_Block_GetSYSID;
    PtrExRtn->print  = XREF_Block_PrintSYSID;
    PtrExRtn->free   = XREF_Block_FreeSYSID;
 }
 else if (XBhandle->need_rec_YN EQ 'Y')
 {
   (*PBhandle)->ext_type = 'R';

    /*
     *    Allocate XB_PB_onlyrec_rtnparms
     */

    PtrExRtn->p_rtnparms =
        (void *)calloc (1, sizeof(XB_PB_onlyrec_rtnparms_rec_typ));
    PtrExRtPrms = PtrExRtn->p_rtnparms;
    if (NOT  PtrExRtPrms)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
         "XB_PB_onlyrec_rtnparms",
         sizeof(XB_PB_onlyrec_rtnparms_rec_typ));
       rc = ESA_FATAL;
       goto exit;
    }

    /*
     *    Init   XB_PB_onlyrec_rtnparms
     */

    PtrExRtRecPrms = (XB_PB_onlyrec_rtnparms_rec_typ *)PtrExRtPrms;
    strcpy(PtrExRtRecPrms->eyec,"XBRP");
    PtrExRtRecPrms->p_XBhandle = XBhandle;
    /*
     *    Init     XB_PB_onlyrec_rtnparms->insert_params
     */
    /* WS10079N
    PtrExRtPrmsInsRecPrms = PtrExRtRecPrms->insert_parms;
    */
    PtrExRtPrmsInsRecPrms = &PtrExRtRecPrms->insert_parms;
    PtrExRtPrmsInsRecPrms->xref_rec = NULL;
    /*
     *    Init     XB_PB_onlyrec_rtnparms->get_params
     */
    /* WS10079N
    PtrExRtPrmsGetRecPrms = PtrExRtRecPrms->get_parms;
    */
    PtrExRtPrmsGetRecPrms = &PtrExRtRecPrms->get_parms;
    PtrExRtPrmsGetRecPrms->out_xref_rec    = NULL;
    PtrExRtPrmsGetRecPrms->Function[0]     = NULL_CHAR;
    /*
     *    Init the onlyrec routines in PB_rtnblk_ext
     */
     PtrExRtn->insert = XREF_Block_InsertRec;
     PtrExRtn->get    = XREF_Block_GetRec;
     PtrExRtn->print  = XREF_Block_PrintRec;
     PtrExRtn->free   = XREF_Block_FreeRec;
 }
 else
 {
    (*PBhandle)->ext_type = 'N';
 }
 exit:
 exit_final:
 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;

}
/**************************************************************
*                                                             *
* PROCEDURE NAME : Free_PBXB                                  *
*                                                             *
* DESCRIPTION    : Free PB block and all related extension    *
*                  areas                                      *
*                                                             *
*                                                             *
* INPUT          : PBhandle                                   *
*                  diag_comp                                  *
*                  admin_params                               *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                    ESA_OK                                   *
*                    ESA_FATAL                                *
**************************************************************/
static ESA_RC  Free_PBXB(
                  PBhandle_typ             * PBhandle,
                  ESA_DIAG_COMP_typ          diag_comp,
                  ADMIN_PARAMS_rec_typ     * admin_params)
{
 static char func[] = "Free_PBXB";

 ESA_RC                           rc                    = ESA_OK;
 PB_rtnblk_ext_rec_typ          * PtrExRtn              = NULL;
 char                           * rec                   = NULL;
 char                             errmsg[125]           = "";
 CTSAMSG_HANDLE_rec_ptr           msgs;
 CTSAMSG_DEST_TABLE_rec_ptr       dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);

 /* WS10084 start */
 /*
 ESA_DIAG_printf(diag_comp,0,
   "Befoe calling Permissions_block_Free. PBhandle->PBptr = %p",
   PBhandle->PBptr);
 ESA_DIAG_printf(diag_comp,0,
   "UID = %s, PBhandle->ext_type = %c",
    PBhandle->uid, PBhandle->ext_type);
 */
 /* WS10084 end   */

 /* WS10084 start moved from below */
 rc = Permissions_block_Free(PBhandle->PBptr,
                             diag_comp,
                             admin_params);
 if (rc NE ESA_OK)
 {
   sprintf(errmsg,
           "Permissions_block_Free returned rc = %d", rc);
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                 func, errmsg, 12, __LINE__);
 };
 /* WS10084 end   */

 if (PBhandle->handle_extension NE NULL)
    free(PBhandle->handle_extension);

 PtrExRtn = PBhandle->PBptr->ext_block_routines;

 if (PtrExRtn NE NULL)
 {
    if (PtrExRtn->p_rtnparms NE NULL)
       free(PtrExRtn->p_rtnparms);
    free(PtrExRtn);
 }

 if (PBhandle->PBptr->ext_block_header NE NULL)
    free(PBhandle->PBptr->ext_block_header);

 /* WS10084 moved above
 rc = Permissions_block_Free(PBhandle->PBptr,
                             diag_comp,
                             admin_params);
 if (rc NE ESA_OK)
 {
   sprintf(errmsg,
           "Permissions_block_Free returned rc = %d", rc);
   CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                 func, errmsg, 12, __LINE__);
 };  WS10084 */

 free(PBhandle);

 exit:
 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;
}
/**************************************************************
*                                                             *
* PROCEDURE NAME : XREF_Find_and_Inactivate                   *
*                                                             *
* DESCRIPTION    : Find active entry with given name and      *
*                  mark as inactive                           *
*                                                             *
*                                                             *
* INPUT          : PBhandle                                   *
*                  name                                       *
*                  in_sysid                                   *
*                  out_sysid                                  *
*                  diag_comp                                  *
*                  admin_params                               *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                    ESA_OK                                   *
*                    ESA_FATAL                                *
**************************************************************/
static ESA_RC  XREF_Find_and_Inactivate(
                  PBhandle_typ             * PBhandle,
                  char                     * name,
                  char                     * in_sysid,
                  char                     * out_sysid,
                  ESA_DIAG_COMP_typ          diag_comp,
                  ADMIN_PARAMS_rec_typ     * admin_params)
{
 static char func[] = "XREF_Find_and_Inactivate";

 ESA_RC                           rc                    = ESA_OK;
 char                           * rec                   = NULL;
 char                             errmsg[125]           = "";
 char                             active                = NULL_CHAR;
 char                             my_out_sysid[9]       = "";
 void                           * PtrExRtPrms           = NULL;
 PB_rtnblk_ext_rec_typ          * PtrExRtn              = NULL;
 XB_PB_SYSID_rtnparms_rec_typ   * PtrExRtSysPrms        = NULL;
 XB_GetSYSID_parms_typ          * PtrExRtPrmsGetSysPrms = NULL;
 XB_InsertSYSID_parms_typ       * PtrExRtPrmsInsSysPrms = NULL;
 XB_PB_onlyrec_rtnparms_rec_typ * PtrExRtRecPrms        = NULL;
 XB_InsertRec_parms_typ         * PtrExRtPrmsInsRecPrms = NULL;
 XB_SYSID_entry_rec_typ         * out_sysid_ent         = NULL;
 CTSAMSG_HANDLE_rec_ptr           msgs;
 CTSAMSG_DEST_TABLE_rec_ptr       dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);

 ESA_DIAG_printf(diag_comp,2,
  "Looking for name=%s with sysid=(%s) in block=%c",
    name,in_sysid,PBhandle->XREF_or_Group);

 PtrExRtn = PBhandle->PBptr->ext_block_routines;
 PtrExRtPrms = PtrExRtn->p_rtnparms;
 PtrExRtSysPrms =
   (XB_PB_SYSID_rtnparms_rec_typ *)PtrExRtPrms;
 /* WS10079N
 PtrExRtPrmsGetSysPrms = PtrExRtSysPrms->get_parms;
 */
 PtrExRtPrmsGetSysPrms = &PtrExRtSysPrms->get_parms;

 strcpy(PtrExRtPrmsGetSysPrms->Function,"UIDTHIS");
 PtrExRtPrmsGetSysPrms->in_Active         = 'Y' ;
 PtrExRtPrmsGetSysPrms->in_SYSID          = in_sysid;
 PtrExRtPrmsGetSysPrms->out_SYSID         = my_out_sysid;
 PtrExRtPrmsGetSysPrms->out_SYSID_ent     = &out_sysid_ent;
 PtrExRtPrmsGetSysPrms->out_ActiveYN      = NULL;
 PtrExRtPrmsGetSysPrms->out_num_of_SYSIDs = NULL;
 PtrExRtPrmsGetSysPrms->out_xref_rec      = NULL;

 rc = Permissions_block_Get("UIDTHIS",
                             PBhandle,
                             name,
                             NULL,
                             0,
                             diag_comp,
                             admin_params);
 /*
  *  If exists, call  XREF_Block_updateSYSID to mark
  *  the entry in block as inactive.
  */

 if (rc EQ ESA_KEY_NOT_FOUND)
 {
  ESA_DIAG_printf(diag_comp,2,
  "Not found name=%s with sysid=(%s) in block=%c",
    name,in_sysid,PBhandle->XREF_or_Group);
  goto exit;
 }

 if (rc EQ ESA_OK)
 {
   ESA_DIAG_printf(diag_comp,2,
   "Active name=%s with sysid=(%s) found in block=%c, "
   "and will be inactivated",
    name,my_out_sysid,PBhandle->XREF_or_Group);

    if (out_sysid NE NULL)
       strcpy(out_sysid,my_out_sysid);

    rc = XREF_Block_UpdateSYSID(
              PBhandle->curUIDinPB,
              out_sysid_ent,
              'N',
              diag_comp,
              admin_params);

    if (rc NE ESA_OK)
    {
       sprintf(errmsg,
       "XREF_Block_UpdateSYSID for entity=%s type=%c "
       "sysid=%s got rc=%d",
       name,PBhandle->PB_type,my_out_sysid,rc);

       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
       goto exit;
    };
 }
 exit:
 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;
}
/**************************************************************
*                                                             *
* PROCEDURE NAME : Insert_PBXB_entry                          *
*                                                             *
* DESCRIPTION    : Prepare parameter for extension routine    *
*                  insert and call Permissions_Block_Insert   *
*                                                             *
*                                                             *
*                                                             *
* INPUT          : XBhandle                                   *
*                  PBhandle                                   *
*                  name                                       *
*                  sysid_from_parse                           *
*                  acf2_sysid                                 *
*                  active                                     *
*                  output_area                                *
*                  diag_comp                                  *
*                  admin_params                               *
*                                                             *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                    ESA_OK                                   *
*                    ESA_FATAL                                *
**************************************************************/
/*
 *   Inserting an entry
 *   If sysidYN=Y, prepare parameters for
 *      SYSID extension routines.
 *   Else, if need_rec_YN=Y, prepare parameters
 *          for REC extension routines
 *   Else, no extension routines.
 *   When active_check=C and entry is active:
 *    Set activeYN=Y
 *    Set updActYN=Y to ask the insert routine to
 *       remove the active indication from the
 *       current active entry.
 *   When need_rec_YN=Y:
 *    Allocate an area with the length of the
 *    record and copy the record. Pass this record
 *    to the extension routines.
 *   Call Permissions_Block_Insert to insert the
 *      record to the appropriate block
 *   If the entry was added, call
 *      Permissions_Block_UpdateIndex
 *      (as done in Permissions_Block_Build)
 */

static ESA_RC Insert_PBXB_Entry(
                 XBhandle_rec_typ         * XBhandle,
                 PBhandle_typ             * PBhandle,
                 char                     * name,
                 char                     * sysid_from_parse,
                 char                     * acf2_sysid,
                 char                       active,
                 char                     * output_area,
                 ESA_DIAG_COMP_typ          diag_comp,
                 ADMIN_PARAMS_rec_typ     * admin_params)
{
 static char func[] = "Insert_PBXB_entry";

 ESA_RC                           rc                    = ESA_OK;
 int                              rec_len               = 0;
 char                           * rec                   = NULL;
 char                             errmsg[125]           = "";
 PB_rtnblk_ext_rec_typ          * PtrExRtn              = NULL;
 void                           * PtrExRtPrms           = NULL;
 XB_PB_SYSID_rtnparms_rec_typ   * PtrExRtSysPrms        = NULL;
 XB_GetSYSID_parms_typ          * PtrExRtPrmsGetSysPrms = NULL;
 XB_InsertSYSID_parms_typ       * PtrExRtPrmsInsSysPrms = NULL;
 XB_PB_onlyrec_rtnparms_rec_typ * PtrExRtRecPrms        = NULL;
 XB_InsertRec_parms_typ         * PtrExRtPrmsInsRecPrms = NULL;
 XB_GetRec_parms_typ            * PtrExRtPrmsGetRecPrms = NULL;
 CTSAMSG_HANDLE_rec_ptr           msgs;
 CTSAMSG_DEST_TABLE_rec_ptr       dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);


 ESA_DIAG_printf(diag_comp, 6,
  "Parms at entry: name = %s  sysid = %s   active = %c   PBhandle = %p",
  name,sysid_from_parse, active, PBhandle);

 if (XBhandle->need_rec_YN EQ 'Y')
 {
    rec_len =(strlen(output_area) + 1);
    rec  = calloc (1, rec_len);
    if (rec EQ NULL)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "XREF_Rec",
                     rec_len);
       rc = ESA_FATAL;
       goto exit;
    };
    strcpy(rec,output_area);
 }

 PtrExRtn = PBhandle->PBptr->ext_block_routines;
 PtrExRtPrms = PtrExRtn->p_rtnparms;

 if (XBhandle->sysidYN EQ 'Y')
 {
  PtrExRtSysPrms =
    (XB_PB_SYSID_rtnparms_rec_typ *)PtrExRtPrms;
  /* WS10079N
  PtrExRtPrmsInsSysPrms = PtrExRtSysPrms->insert_parms;
  */
  PtrExRtPrmsInsSysPrms = &PtrExRtSysPrms->insert_parms;
  PtrExRtPrmsInsSysPrms->SYSID    = sysid_from_parse;

  if(XBhandle->active_check EQ 'C')
  {
    PtrExRtPrmsInsSysPrms->ActiveYN = active;
    PtrExRtPrmsInsSysPrms->updActYN = active;
  }

  if(XBhandle->active_check EQ 'N')
  {
    PtrExRtPrmsInsSysPrms->ActiveYN = XBhandle->active_default;
    PtrExRtPrmsInsSysPrms->updActYN = 'N';
  }

  PtrExRtPrmsInsSysPrms->xref_rec = rec;
 }
 else if(PBhandle->ext_type EQ 'R')
 {
  PtrExRtRecPrms =
    (XB_PB_onlyrec_rtnparms_rec_typ *)PtrExRtPrms;
  /* WS10079N
    PtrExRtPrmsInsRecPrms = PtrExRtRecPrms->insert_parms;
  */
    PtrExRtPrmsInsRecPrms = &PtrExRtRecPrms->insert_parms;
    PtrExRtPrmsInsRecPrms->xref_rec = rec;
 }

 rc = Permissions_block_Insert(PBhandle->PBptr,
                               name,
                               NULL,
                               diag_comp,
                               admin_params);
 if (rc EQ ESA_OK)
 {
   /* Update the permissions block index, if needed */
   rc = Permissions_Block_updateIndex(&(PBhandle->PBptr),
                                      FALSE,
                                      diag_comp,
                                      admin_params);
   if (rc NE ESA_OK)
   {
     sprintf(errmsg,
       "Permissions_Block_UpdateIndex returned rc = %d",
            rc);
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
     rc = ESA_FATAL;
     goto exit;
   };
 }
 exit:
 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;

}
/**************************************************************
*                                                             *
* PROCEDURE NAME : XREF_Match_SYSID                           *
*                                                             *
* DESCRIPTION    : Check if given sysid of an entity matches  *
*                  ACF2 SYSID                                 *
*                                                             *
* NOTE           : The existing routine ACF2_Match_Id_to_Mask *
*                  doesn't suite us because we can have:      *
*                  record sysid = TL*                         *
*                  ACF2_SYSID   = TLVB                        *
*                  For us it is a match but it will not be a  *
*                  match for ACF2_Match_Id_to_Mask            *
*                                                             *
*                                                             *
* INPUT          : acf2_sysid                                 *
*                  entity_sysid                               *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                  0 - match                                  *
*                  4 - no match                               *
**************************************************************/
static ESA_RC XREF_Match_SYSID(
                    char                 * acf2_sysid,
                    char                 * entity_sysid,
                    ESA_DIAG_COMP_typ      diag_comp,
                    ADMIN_PARAMS_rec_typ * admin_params)
{
 ESA_RC rc  = ESA_OK;
 int    i   = 0;
 int    len = 0;
 int    len1= 0;
 int    len2= 0;
 int    diff= 0;
 char   * p1= NULL;
 char   * p2= NULL;
 static char func[] = "XREF_Match_SYSID";

 ESA_DIAG_enter(diag_comp, 1, func);
 len1 = strlen(entity_sysid);
 len2 = strlen(acf2_sysid);


 /*
  *  we first compare up to the shorter sysid, whose length will be in
  *  len
  */

 if (len1 LE len2)
    len = len1;
 else
    len = len2;

 p1 = entity_sysid;
 p2 = acf2_sysid;
 rc = 0;

 for (i=0; i LT len; i++)
 {
     if (*(p1+i) EQ '*')      /* if there is an * in this position in
                                 entity sysid, it matches anything    */
        continue;

     if (*(p1+i) EQ *(p2+i))  /* if the chars in both strings in this
                                 position are the same its a match so
                                 far                                 */
        continue;
     rc = 4;                  /* no match, return rc = 4             */
     goto exit;
 }

 /*
  *  If we get here then the strings up to the shorter sysid match
  *  rc is 0 now.
  */

 if (len1 EQ len2)
    goto exit;                /* we have a full match            */


 /*
  *  If the entity sysid is shorter, then if it ends with * we have
  *  a match
  */

 if (len1 LT len2)
 {
    if (*(p1+len1-1) EQ '*')  /* check last char of entity sysid */
       goto exit;             /* we have a match                 */

    rc = 4;                   /* last char of entity sysid is not
                                 *, no match                     */
    goto exit;
 }


 /*
  *  Entity sysid is longer.
  *  All chars in entity sysid beyond the length of acf2 sysid
  *  must be * to have a match
  */

 diff = len1-len2;
 for (i=0; i LT diff; i++)
 {
     if (*(p1+len2+i) EQ '*') /* check chars beyond acf2 sysid len */
        continue;
     rc = 4;                  /* a char beyond is not *, no match  */
     goto exit;
 }

 exit:
 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;

}

/* WS10079N - start */
/***************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Block_Print                           *
 *                                                             *
 * DESCRIPTION    : Print the XREF blocks.                     *
 *                                                             *
 * INPUT            XBhandle                                   *
 *                  diag_comp                                  *
 *                  admain_params                              *
 *                                                             *
 * OUTPUT         :                                            *
 *                                                             *
 * RETURN VALUE   :                                            *
 *                                                             *
 **************************************************************/

static void  XREF_Block_Print(
                  XBhandle_rec_typ         * XBhandle,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

   static char    func[]="XREF_Block_Print";

   ESA_DIAG_enter(diag_comp, 1, func);

   ESA_DIAG_printf(diag_comp, 0,
         "XBhandle: request_type=%s  xrefname=%s  PB_type=%c...",
         XBhandle->request_type, XBhandle->xrefname,
         XBhandle->PB_type);
   ESA_DIAG_printf(diag_comp, 0,
         "...active_request=%c     need_rec_YN=%c   sysidYN=%c... ",
         XBhandle->active_request,
         XBhandle->need_rec_YN, XBhandle->sysidYN);
   ESA_DIAG_printf(diag_comp, 0,
         "...  active_check=%c   active_default=%c",
         XBhandle->active_check, XBhandle->active_default);

 if ( XBhandle->XREF_PB_handle        NE NULL  AND
      XBhandle->XREF_PB_handle->PBptr NE NULL  )
 {
   ESA_DIAG_printf(diag_comp, 0,
                   "%s block",
                    XBhandle->PB_type EQ 'R'? "Roles" : "Sources");
   ESA_DIAG_printf(diag_comp, 0,
                    "========================================");
     Permissions_block_Print(XBhandle->XREF_PB_handle->PBptr,
                           diag_comp, admin_params);
 };

 if ( XBhandle->Groups_PB_handle        NE NULL   AND
      XBhandle->Groups_PB_handle->PBptr NE NULL )
 {
   ESA_DIAG_printf(diag_comp, 0,
                   "%s Groups block",
                    XBhandle->PB_type EQ 'R'? "Role" : "Source");
   ESA_DIAG_printf(diag_comp, 0,
                   "=========================================");
   Permissions_block_Print(XBhandle->Groups_PB_handle->PBptr,
                           diag_comp, admin_params);
 };

 ESA_DIAG_exit(diag_comp, 1, func, 0);
}
/*  WS10079N - end */

/***************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Extract_Inc_Exc_Lists                 *
 *                                                             *
 * DESCRIPTION    : Extract include and exclude lists from     *
 *                  addinfo to XREF_Operations_Lists           *
 *                  Caller must free the areas pointed by      *
 *                  the XREF_Operations_Lists and then the     *
 *                  XREF_Operations_Lists themselves.          *
 *                                                             *
 * INPUT            addinfo   - full addinfo with include      *
 *                              and/or exclude lists           *
 *                  include_op_lists  - pointer. We return     *
 *                                      the op lists  here     *
 *                  exclude_op_lists  - pointer. We return     *
 *                                      the op lists  here     *
 *                  diag_comp                                  *
 *                  admain_params                              *
 *                                                             *
 * OUTPUT         : XREF_Operations_Lists                      *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

ESA_RC XREF_Extract_Inc_Exc_Lists(
                  ADDINFO_rec_typ      * addinfo,
                  XREF_Operations_Lists_typ ** include_op_lists,
                  XREF_Operations_Lists_typ ** exclude_op_lists,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

   static char    func[]="XREF_Extract_Inc_Exc_Lists";

  /*
   *     Variables
   */

   ESA_RC                  rc = ESA_OK;
   CTSAMSG_HANDLE_rec_ptr      msgs;
   CTSAMSG_DEST_TABLE_rec_ptr  dest;

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_enter(diag_comp, 1, func);



  /*
   *     Make sure include_op_lists & exclude_op_lists are null
   */

   if (*include_op_lists NE NULL   OR    *exclude_op_lists NE NULL)
   {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
       func, "include_op_lists  and  exclude_op_lists  must be NULL",
         16, __LINE__);
     rc = ESA_FATAL;
     goto exit_final;
   };


  /*
   *     Handle the include list
   */

   rc = XREF_Extract_One_Inc_Exc_List(
                  "IncludeList",
                  addinfo,
                  include_op_lists,
                  diag_comp,
                  admin_params);

  /*
   *     Handle the exclude list
   */

   rc = XREF_Extract_One_Inc_Exc_List(
                  "ExcludeList",
                  addinfo,
                  exclude_op_lists,
                  diag_comp,
                  admin_params);

  exit:

  if (rc NE ESA_OK )
   {
     if (*include_op_lists NE NULL)
      {
        if ( (*include_op_lists)->add_list NE NULL)
           free ( (*include_op_lists)->add_list) ;

        if ( (*include_op_lists)->del_list NE NULL)
           free ( (*include_op_lists)->del_list) ;

        if ( (*include_op_lists)->rep_list NE NULL)
           free ( (*include_op_lists)->rep_list) ;

        free (*include_op_lists);
        *include_op_lists = NULL;
      }

     if (*exclude_op_lists NE NULL)
      {
        if ( (*exclude_op_lists)->add_list NE NULL)
           free ( (*exclude_op_lists)->add_list) ;

        if ( (*exclude_op_lists)->del_list NE NULL)
           free ( (*exclude_op_lists)->del_list) ;

        if ( (*exclude_op_lists)->rep_list NE NULL)
           free ( (*exclude_op_lists)->rep_list) ;

        free (*exclude_op_lists);
        *exclude_op_lists = NULL;
      }

   }

  exit_final:
  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;

}
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Extract_One_Inc_Exc_List              *
 *                                                             *
 * DESCRIPTION    : Extract include or exclude list from       *
 *                  addinfo to XREF_Operations_Lists.          *
 *                                                             *
 * INPUT            incexctype  IncludeList/ExcludeList        *
 *                  addinfo   - full addinfo with include      *
 *                              and/or exclude lists           *
 *                  op_lists  - pointer. We return             *
 *                              the op lists  here             *
 *                  diag_comp                                  *
 *                  admain_params                              *
 *                                                             *
 * OUTPUT         : XREF_Operations_Lists                      *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

static ESA_RC XREF_Extract_One_Inc_Exc_List(
                  char                          * incexctype,
                  ADDINFO_rec_typ               * addinfo,
                  XREF_Operations_Lists_typ    ** op_lists,
                  ESA_DIAG_COMP_typ               diag_comp,
                  ADMIN_PARAMS_rec_typ          * admin_params)
{

   static char    func[]="XREF_Extract_One_Inc_Exc_List";

  /*
   *     Variables
   */

   ESA_RC                  rc = ESA_OK;
   ONE_FIELD_rec_ptr       pair = NULL;
   char                    OP[4] =  NULL_STRING;
   /*WS10082 char  list[MAX_RSS_ADDINFO_VAL_LEN] = NULL_STRING;     */
   char list[32768+1]=NULL_STRING;/*support 32k role&source  WS10082*/
   char                  * last_ptr = NULL;
   int                     i = 0;
   int                     len = 0;
   CTSAMSG_HANDLE_rec_ptr      msgs;
   CTSAMSG_DEST_TABLE_rec_ptr  dest;

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_enter(diag_comp, 1, func);

  /*
   *     Get the List
   */

   pair  = ADDINFO_search(incexctype,
                          ACF_ADDINFO_KWD_LEN,
                          addinfo->pair,
                          addinfo->num_pairs);

   if (pair NE NULL)
   {

     ESA_DIAG_printf(diag_comp,6,
     "%s List found",incexctype);

     *op_lists = calloc(1, sizeof(XREF_Operations_Lists_typ));
     if (*op_lists EQ NULL)
       {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
         "XREF_Operations_Lists",
         sizeof(XREF_Operations_Lists_typ));
         rc = ESA_FATAL;
         goto exit;
       }

     (*op_lists)->add_list = NULL;
     (*op_lists)->del_list = NULL;
     (*op_lists)->rep_list = NULL;
     last_ptr = NULL;


     /*
      *     The for loop below iterates 3 times.
      *     There can be 1 or 2 operations of ADD/DEL/REP.
      *     We can have one of the above, or both ADD & DEL.
      *     If there is REP it must be just REP.
      *     So when i EQ 1 then it is the first iteration and we
      *     expect to find some list.
      *     When i EQ 3 then if we find a 3rd list it is an error.
      */

     for (i=1; i LE 3; i++)
      {
        list[0]=NULL_CHAR;
        rc = ADDINFO_list_getnextvalue(
                             pair,ADDINFO_LIST_SUBFIELD,
                             list, &last_ptr);

        ESA_DIAG_printf(diag_comp, 6,
         "list getnextvalue i=%d rc=%d last=%p list=<%s>",
          i,rc, last_ptr,list);

        if ( ( rc NE ESA_OK ) OR ( list[0] EQ NULL_CHAR ) )
          {
            if (i EQ 1) /* 1st time should have found a list */
             {
              CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                     dest, component, func,
                     "List exists but is empty",
                     16, __LINE__);
              rc = ESA_FATAL;
              goto exit;
             }

            rc = ESA_OK;
            break;   /* get out */
          }

        if (i EQ 3)
          {

           /*
            *     We should only have maximum 2 lists
            */

            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                 dest, component, func,
                 "List has more than 2 lists",
                 16, __LINE__);
            rc = ESA_FATAL;
            goto exit;
          }

        ESA_DIAG_printf(diag_comp, 6,
         "delimiter after operation = %x",
          *(list+3));


        if (*(list+3) NE ADDINFO_LIST_ENTRY)
           {

            /*
             *     After the operation (ADD/DEL/REP) there must be
             *     list entry seperator, so we have an error
             */

             CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                     dest, component, func,
              "ADDINFO_LIST_ENTRY seperator not found in List",
                     16, __LINE__);
             rc = ESA_FATAL;
             goto exit;
           }

        memcpy(OP,list,3);

        if (memcmp(OP,"ADD",3) EQ 0)
           {
             rc = XREF_Extract_One_Operation(
                  "ADD",
                  list,
                  &((*op_lists)->add_list),
                  diag_comp,
                  admin_params);


             if ( rc NE ESA_OK)
                goto exit;

             continue;  /* the for loop */
           }

        if (memcmp(OP,"DEL",3) EQ 0)
           {
             rc = XREF_Extract_One_Operation(
                  "DEL",
                  list,
                  &((*op_lists)->del_list),
                  diag_comp,
                  admin_params);


             if ( rc NE ESA_OK)
                goto exit;

             continue;  /* the for loop */
           }

        if (memcmp(OP,"REP",3) EQ 0)
           {
             rc = XREF_Extract_One_Operation(
                  "REP",
                  list,
                  &((*op_lists)->rep_list),
                  diag_comp,
                  admin_params);


             if ( rc NE ESA_OK)
                goto exit;

             continue;  /* the for loop */
           }

        /*
         *     The operation is not one of ADD/DEL/REP
         */

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                      dest, component, func,
                      "Invalid operation in List",
                      16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }   /* end of for loop */
   }

  exit:
  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;

}
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Extract_One_Operation                 *
 *                                                             *
 * DESCRIPTION    : Extract one of ADD/DE/REP operations       *
 *                  to the given one of XREF_Operations_Lists  *
 *                                                             *
 * INPUT            operation - ADD/DEL/REP                    *
 *                  list      - output of                      *
 *                              ADDINFO_list_getnextvalue      *
 *                  one_op_list pointer. We return             *
 *                              the op list  here              *
 *                  diag_comp                                  *
 *                  admain_params                              *
 *                                                             *
 * OUTPUT         : One list of XREF_Operations_Lists          *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

static ESA_RC XREF_Extract_One_Operation(
                  char                          * operation,
                  char                          * list,
                  char                         ** one_op_list,
                  ESA_DIAG_COMP_typ               diag_comp,
                  ADMIN_PARAMS_rec_typ          * admin_params)
{

   static char    func[]="XREF_Extract_One_Operation";

  /*
   *     Variables
   */

   ESA_RC                      rc = ESA_OK;
   int                         len = 0;
   CTSAMSG_HANDLE_rec_ptr      msgs;
   CTSAMSG_DEST_TABLE_rec_ptr  dest;

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_enter(diag_comp, 1, func);

   ESA_DIAG_printf(diag_comp, 6,
      "list operator is <%s>",operation);

    if ( *one_op_list NE NULL)
      {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                dest, component, func,
                "Operation already found in List",
                16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }

    len = strlen(list) - 4;

    ESA_DIAG_printf(diag_comp, 6,
      "list string length=%d, len without operation=%d",
       strlen(list),len);

    /*
     *     Allocate the one_op_list area
     *     without the operation, with null term
     *     and copy the names to there
     */

    *one_op_list = calloc(1, len+1);
    if (*one_op_list EQ NULL)
      {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "one_op_list", len);
        rc = ESA_FATAL;
        goto exit;
      }

    strcpy(*one_op_list,list+4);

    ESA_DIAG_printf(diag_comp, 6,
      "one_op_list = <%s>",
       (*one_op_list));

  exit:
  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;

}
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Commands_Create                       *
 *                                                             *
 * DESCRIPTION    : Create the ACF2 commands needed to add     *
 *                  or update an XREF record according to      *
 *                  the addinfo fields and the command name    *
 *                  received from the caller.                  *
 *                  The areas of the commands returned in      *
 *                  pointers in xref_command_struct must be    *
 *                  freed by the caller                        *
 *                                                             *
 * INPUT            type      - ROL/SGP                   (I)  *
 *                  addinfo   - full addinfo with include      *
 *                              and/or exclude lists      (I)  *
 *                  xref_name - role/source name          (I)  *
 *                              may include sysid         (I)  *
 *                  command_name - INS/CHA/DEL            (I)  *
 *                  include_op_lists - pointer to existing     *
 *                                      op lists          (I)  *
 *                  exclude_op_lists - pointer to existing     *
 *                                      op lists          (I)  *
 *                  xref_command_struct - pointer to struct    *
 *                                      allocated by the       *
 *                                      caller            (O)  *
 *                  diag_comp                             (I)  *
 *                  admain_params                         (I)  *
 *                                                             *
 * OUTPUT         : xref_command_struct                        *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

ESA_RC XREF_Commands_Create(
                  char                 * type,
                  ADDINFO_rec_typ      * addinfo,
                  char                 * xref_name,
                  char                 * command_name,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
                  XREF_Cmd_Struct_typ  * xref_command_struct,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

   static char    func[]="XREF_Commands_Create";

  /*
   *     Variables
   */

   ESA_RC                   rc = ESA_OK;
   char                     errmsg[125] = NULL_STRING;
   XREF_Operations_Lists_typ * myinclude_op_lists = NULL;
   XREF_Operations_Lists_typ * myexclude_op_lists = NULL;
   int                      free_op_lists_needed = FALSE;
   /* WS10082N - remove the following unused definitions
   ONE_FIELD_rec_ptr        i_pair = NULL;  /@ IncludeList @/
   ONE_FIELD_rec_ptr        e_pair = NULL;  /@ ExcludeList @/  */
   ONE_FIELD_rec_ptr        d_pair = NULL;  /* Description */
   ONE_FIELD_rec_ptr        r_pair = NULL;  /* REFRESH     */
   int                      len = 0;
   int                      add_len = 0;
   int                      del_len = 0;
   int                      rep_len = 0;
   int                      desc_len = 0;
   int                      ref_len =  0;
   int                      preamble_len = 0;
   int                      list_len = 0;
   int                      i = 0;
   char                     sysid_for_command[16]            = "";
   char                     xname_for_command[XREF_NAME_SIZE] = "";
   char                     sysid_after_split[9]             = "";
   char                   * preamble = NULL;
   char                   * descript = NULL;
   int                      only_description = FALSE;
   int                      add_desc_to_rep  = FALSE;
   int                      add_desc_to_add  = FALSE;
   int                      add_desc_to_del  = FALSE;
   CTSAMSG_HANDLE_rec_ptr      msgs;
   CTSAMSG_DEST_TABLE_rec_ptr  dest;

   msgs = admin_params->ctsamsg_handle;
   dest = admin_params->ctsamsg_dest;

   ESA_DIAG_enter(diag_comp, 1, func);
   ESA_DIAG_printf(diag_comp, 6,
     "type = <%.8s> xref_name = <%.8s> command_name = <%.8s>",
      type, xref_name, command_name);


  /*
   *     Check that type and command_name were provided.
   *     addinfo is null when called from Xref_Command_Restore
   */


 if (  (type EQ NULL) OR (command_name EQ NULL)  )
    {
       CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
               dest, component, func,
               "type or command_name not provided",
               16, __LINE__);
       rc = ESA_FATAL;
       goto exit;
    }

  /*
   *     If not any  op list provided call XREF_Extract_Inc_Exc_Lists
   */

 if (  (include_op_lists EQ NULL)   AND
       (exclude_op_lists EQ NULL)   AND
       (strcmp(command_name,"DEL") NE 0) )
    {
    if (addinfo EQ NULL)
       {
          CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                  dest, component, func,
                  "addinfo not provided",
                  16, __LINE__);
          rc = ESA_FATAL;
          goto exit;
       }
       ESA_DIAG_printf(diag_comp, 6,
        "Both op lists are null. Calling XREF_Extract_Inc_Exc_Lists");

       rc = XREF_Extract_Inc_Exc_Lists (
                  addinfo,
                  &myinclude_op_lists,
                  &myexclude_op_lists,
                  diag_comp,
                  admin_params);

       ESA_DIAG_printf(diag_comp, 6,
        "XREF_Extract_Inc_Exc_Lists rc=%d",rc);

       if ( rc NE ESA_OK)
          {
            sprintf(errmsg,"XREF_Extract_Inc_Exc_Lists rc =%d",rc);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                    dest, component, func,
                    errmsg,
                    16, __LINE__);
            rc = ESA_FATAL;
            goto exit;
          }
       /*
        *     XREF_Extract_Inc_Exc_Lists  allocated the op lists
        *     so we will have to free them
        */
       free_op_lists_needed = TRUE;

       /*
        *     myinclude_op_lists and/or myexclude_op_lists should
        *     now have pointer(s) returned by XREF_Extract_Inc_Exc_Lists
        */

       if (myinclude_op_lists NE NULL)
        {
         ESA_DIAG_printf(diag_comp, 6,
          "myinclude_op_lists add_list(%p):<%.250s>",
          myinclude_op_lists->add_list,myinclude_op_lists->add_list);

         ESA_DIAG_printf(diag_comp, 6,
          "myinclude_op_lists del_list(%p):<%.250s>",
          myinclude_op_lists->del_list,myinclude_op_lists->del_list);

         ESA_DIAG_printf(diag_comp, 6,
          "myinclude_op_lists rep_list(%p):<%.250s>",
          myinclude_op_lists->rep_list,myinclude_op_lists->rep_list);
        }

       if (myexclude_op_lists NE NULL)
        {
         ESA_DIAG_printf(diag_comp, 6,
          "myexclude_op_lists add_list(%p):<%.250s>",
          myexclude_op_lists->add_list,myexclude_op_lists->add_list);

         ESA_DIAG_printf(diag_comp, 6,
          "myexclude_op_lists del_list(%p):<%.250s>",
          myexclude_op_lists->del_list,myexclude_op_lists->del_list);

         ESA_DIAG_printf(diag_comp, 6,
          "myexclude_op_lists rep_list(%p):<%.250s>",
          myexclude_op_lists->rep_list,myexclude_op_lists->rep_list);
        }

    }
 else        /* now handle op lists are provided by the caller */
    {

       /*
        *     include_op_lists and/or exclude_op_lists should have
        *     pointer(s) received in the routine call.
        *     Pointers of the provided op lists are copied to
        *     myxxclude_op_lists so we have them in there regardless
        *     of the way we got them
        */

       if (include_op_lists NE NULL)
        {

         myinclude_op_lists = include_op_lists;

         ESA_DIAG_printf(diag_comp, 6,
          "include_op_lists add_list(%p):<%.250s>",
          include_op_lists->add_list,include_op_lists->add_list);

         ESA_DIAG_printf(diag_comp, 6,
          "include_op_lists del_list(%p):<%.250s>",
          include_op_lists->del_list,include_op_lists->del_list);

         ESA_DIAG_printf(diag_comp, 6,
          "include_op_lists rep_list(%p):<%.250s>",
          include_op_lists->rep_list,include_op_lists->rep_list);

        }

       if (exclude_op_lists NE NULL)
        {
         myexclude_op_lists = exclude_op_lists;

         ESA_DIAG_printf(diag_comp, 6,
          "exclude_op_lists add_list(%p):<%.250s>",
          exclude_op_lists->add_list,exclude_op_lists->add_list);

         ESA_DIAG_printf(diag_comp, 6,
          "exclude_op_lists del_list(%p):<%.250s>",
          exclude_op_lists->del_list,exclude_op_lists->del_list);

         ESA_DIAG_printf(diag_comp, 6,
          "exclude_op_lists rep_list(%p):<%.250s>",
          exclude_op_lists->rep_list,exclude_op_lists->rep_list);

        }
    }


 /*
  *     Now myxxclude_op_lists have either the received struct
  *     in the parameters of the call or the output of
  *     XREF_Extract_Inc_Exc_Lists
  */


 /*
  *     Validate that REP is not with ADD or DEL
  *     in includelist
  */

 if (myinclude_op_lists NE NULL)
  {
    if (
        (
         (myinclude_op_lists->add_list   NE NULL)
          OR
         (myinclude_op_lists->del_list   NE NULL)
        )
          AND
         (myinclude_op_lists->rep_list   NE NULL)
       )
     {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                dest, component, func,
                "IncludeList error: REP not allowed with ADD or DEL",
                16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
  }

 /*
  *     Validate that REP is not with ADD or DEL
  *     in excludelist
  */

 if (myexclude_op_lists NE NULL)
  {
    if (
        (
         (myexclude_op_lists->add_list   NE NULL)
          OR
         (myexclude_op_lists->del_list   NE NULL)
        )
          AND
         (myexclude_op_lists->rep_list   NE NULL)
       )
     {
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                dest, component, func,
                "ExcludeList error: REP not allowed with ADD or DEL",
                16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }
  }
  rc = XREF_Split_Name(xref_name,
                       xname_for_command,
                       sysid_after_split,
                       diag_comp,
                       admin_params);
  if (rc  EQ ESA_FATAL)
  {
    sprintf(errmsg,
       "XREF_Split_Name returned rc = %d",rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

 /*
  * prepare xrefname and sysid for the commnad
  */

  rc = XREF_Set_Command_SYSID(command_name,
                              xref_name,
                              sysid_for_command,
                              diag_comp,
                              admin_params);
  if (rc  NE ESA_OK)
  {
    sprintf(errmsg,
       "XREF_Set_Command_SYSID returned rc = %d",rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                   dest, component,
                   func, errmsg, 16, __LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

 /*
  *     calculate length of the command areas
  *     ACF2 ROL/SGP INS/CHA/DEL <role/source name> SYSID(sysid)
  *     ROLE/SOURCE
  *     INCLUDE(<xxx_list>) EXCLUDE(<xxx_list>) ADD/DEL/REP
  *     DESCRIPT(<description>)
  */

 /*
  *     first calculate the common length of common elements.
  *     The command for all operations (ADD/DEL/REP)
  *     starts with the same text saved in preamble
  */

 len = strlen("ACF2") + 1;
 len = len + strlen(type) + 1;                 /* ROL/SGP             */
 len = len + strlen(command_name) + 1;         /* INS/CHA/DEL         */
 len = len + strlen(xname_for_command) + 1;    /* role/source name    */
 if (sysid_for_command NE NULL)
   len = len + strlen(sysid_for_command) + 1;  /* sysid part          */
 if (strcmp(command_name,"DEL") NE 0)
 {
   len = len + 6 + 1;                          /* max len ROLE/SOURSE */
   len = len + 3 + 1;                          /* for ADD/DEL/REP     */
 }
 len = len + 1;                                /* for null terminator */
 preamble_len = len;
 preamble = calloc(1, preamble_len);
 if (preamble EQ NULL)
  {
     CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                  "preamble command area", preamble_len);
     rc = ESA_FATAL;
     goto exit;
  }

 ESA_DIAG_printf(diag_comp, 6,
        "Common len = %d",len);

 /*
  *     Build the preamble:
  *     ACF2 ROL/SGP INS/CHA <xref name> SYSID(sysid) ROLE/SOURCE
  */
 strcat(preamble,"ACF2 ");
 strcat(preamble,type);
 strcat(preamble," ");
 strcat(preamble,command_name);
 strcat(preamble," ");
 strcat(preamble,xname_for_command);
 strcat(preamble," ");
 if (sysid_for_command NE NULL)
  {
    strcat(preamble,sysid_for_command);
    strcat(preamble," ");
  }

 if (strcmp(command_name,"DEL") NE 0)
  if (strcmp(type,"ROL") EQ 0)
     strcat(preamble,"ROLE ");
  else if (strcmp(type,"SGP") EQ 0)
     strcat(preamble,"SOURCE ");

 /*
  *     Calculate lenth of each operation:
  *     add_len will have total length needed for ADD command
  *     del_len will have total length needed for DEL command
  *     rep_len will have total length needed for REP command
  */

 if (myinclude_op_lists NE NULL)
  {
    /*
     *     calculate adding INCLUDE(<data>)
     */

    len = len + strlen("INCLUDE()") + 1;
    if (myinclude_op_lists->add_list   NE NULL)
       add_len = len + strlen(myinclude_op_lists->add_list);
    if (myinclude_op_lists->del_list   NE NULL)
       del_len = len + strlen(myinclude_op_lists->del_list);
    if (myinclude_op_lists->rep_list   NE NULL)
       rep_len = len + strlen(myinclude_op_lists->rep_list);

    ESA_DIAG_printf(diag_comp, 6,
      "Lengths with include list: add_len=%d, del_len=%d, rep_len=%d",
      add_len,del_len,rep_len);

  }

 if (myexclude_op_lists NE NULL)
  {
    /*
     *     calculate adding EXCLUDE(<data>)
     */

    len = len + strlen("EXCLUDE()") + 1;
    if (myexclude_op_lists->add_list   NE NULL)
       add_len = add_len + len + strlen(myexclude_op_lists->add_list);
    if (myexclude_op_lists->del_list   NE NULL)
       del_len = del_len + len + strlen(myexclude_op_lists->del_list);
    if (myexclude_op_lists->rep_list   NE NULL)
       rep_len = rep_len + len + strlen(myexclude_op_lists->rep_list);

    ESA_DIAG_printf(diag_comp, 6,
      "Lengths with exclude list: add_len=%d, del_len=%d, rep_len=%d",
      add_len,del_len,rep_len);

  }

 if (addinfo NE NULL)
 {

 /*
  *    Has description been provided in addinfor?
  */

 d_pair = ADDINFO_search("Description",
                            ACF_ADDINFO_KWD_LEN,
                            addinfo->pair,
                            addinfo->num_pairs);
 if (d_pair NE NULL)
  {

       /*
        *     calculate length of DESCRIPT(<description>)
        */

       desc_len = strlen(" DESCRIPT()") + 1;
       desc_len = desc_len + strlen(d_pair->value);
       /*  does the value include apostophes ? */

       ESA_DIAG_printf(diag_comp, 6,
          "desc_len=%d",desc_len);



   /*
    *    Decide where to add the description to
    */

   if  (rep_len GT 0)
    {
       /*
        *   When REP exists add the description to it
        */

       rep_len = rep_len + desc_len;
       add_desc_to_rep = TRUE;
       ESA_DIAG_printf(diag_comp, 6,
          "Description will be added to REP. rep_len=%d",rep_len);
    }
   else if  (del_len GT 0)
    {
       /*
        *   When DEL exists, add the description to it
        */

       del_len = del_len + desc_len;
       add_desc_to_del = TRUE;

       ESA_DIAG_printf(diag_comp, 6,
          "Description will be added to DEL. del_len=%d",del_len);
    }
   else if  (add_len GT 0)
    {
       /*
        *   When only ADD exists, add the description to it
        */

       add_len = add_len + desc_len;
       add_desc_to_add = TRUE;

       ESA_DIAG_printf(diag_comp, 6,
          "Description will be added to ADD. add_len=%d",add_len);
    }
   else /* only description: generate as REP */
    {
       rep_len = len + desc_len;
       only_description = TRUE;
       ESA_DIAG_printf(diag_comp, 6,
          "Only description. REP used. rep_len=%d",rep_len);
    }
  }
 }


 xref_command_struct->add_command = NULL;
 xref_command_struct->del_command = NULL;
 xref_command_struct->rep_command = NULL;
 xref_command_struct->ref_command = NULL;

 /*
  *    Allocate and build del command
  */

 if (strcmp(command_name,"DEL") EQ 0)
   {
   /*
    *    Alloc main DEL area and copy the preamble which has the
    *    main DEL command
    */

   xref_command_struct->del_command = calloc(1, preamble_len);
   if (xref_command_struct->del_command EQ NULL)
    {
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                    "Main DEL command area", preamble_len);
       rc = ESA_FATAL;
       goto exit;
    }
    strcpy(xref_command_struct->del_command,preamble);
   }
 else
 if (del_len GT 0)
  {
     rc = XREF_One_Command_Create(
                           type,
                           myinclude_op_lists,
                           myexclude_op_lists,
      myinclude_op_lists ? myinclude_op_lists->del_list : NULL,
      myexclude_op_lists ? myexclude_op_lists->del_list : NULL,
                           "DEL",
                           del_len,
                           &(xref_command_struct->del_command),
                           preamble,
      add_desc_to_del    ? d_pair->value  : NULL,
                           diag_comp,
                           admin_params);
  }


 /*
  *    Allocate and build add command
  */

 if (add_len GT 0)
  {
     rc = XREF_One_Command_Create(
                           type,
                           myinclude_op_lists,
                           myexclude_op_lists,
      myinclude_op_lists ? myinclude_op_lists->add_list : NULL,
      myexclude_op_lists ? myexclude_op_lists->add_list : NULL,
                           "ADD",
                           add_len,
                           &(xref_command_struct->add_command),
                           preamble,
      add_desc_to_add    ? d_pair->value  : NULL,
                           diag_comp,
                           admin_params);

  }

 /*
  *    Allocate and build rep command
  */

 if (rep_len GT 0)
  {
     if (only_description)
       rc = XREF_One_Command_Create(
                                type,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                "REP",
                                rep_len,
                                &(xref_command_struct->rep_command),
                                preamble,
                                d_pair->value,
                                diag_comp,
                                admin_params);
     else
       rc = XREF_One_Command_Create(
                                type,
                                myinclude_op_lists,
                                myexclude_op_lists,
           myinclude_op_lists ? myinclude_op_lists->rep_list : NULL,
           myexclude_op_lists ? myexclude_op_lists->rep_list : NULL,
                                "REP",
                                rep_len,
                                &(xref_command_struct->rep_command),
                                preamble,
           add_desc_to_rep    ? d_pair->value  : NULL,
                                diag_comp,
                                admin_params);
  }

 /*
  *    Has REFRESH been requested by the user?
  */
 if (addinfo NE NULL)
  if (NOT only_description)
   {
    r_pair = ADDINFO_search("REFRESH",
                       ACF_ADDINFO_KWD_LEN,
                       addinfo->pair,
                       addinfo->num_pairs);

    if ((r_pair NE NULL) AND (r_pair->value[0] EQ 'Y'))
     {
      /*
       *    Allocate and build ref command
       */

      ref_len = strlen("ACF2 ROL F ACF2,NEWXREF,TYPE(ROL)") + 1;

      ESA_DIAG_printf(diag_comp, 6,
           "REFRESH requested. ref_len=%d",ref_len);

      xref_command_struct->ref_command = calloc(1, ref_len);
      if (xref_command_struct->ref_command EQ NULL)
       {
          CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                       "REF command area", ref_len);
          rc = ESA_FATAL;
          goto exit;
       }
      sprintf(xref_command_struct->ref_command,
              "ACF2 %s F ACF2,NEWXREF,TYPE(%s)",
              type,type);
     }
   }


 exit:

 /* WS10079N - start */
 if (rc EQ ESA_OK )
 {
   if (xref_command_struct NE NULL)
   {
     if (xref_command_struct->add_command  NE NULL)
        ESA_DIAG_printf(diag_comp, 2,
                        "ADD command: %s",
                         xref_command_struct->add_command);
     if (xref_command_struct->del_command  NE NULL)
        ESA_DIAG_printf(diag_comp, 2,
                        "DEL command: %s",
                         xref_command_struct->del_command);
     if (xref_command_struct->rep_command  NE NULL)
        ESA_DIAG_printf(diag_comp, 2,
                        "REP command: %s",
                         xref_command_struct->rep_command);
     if (xref_command_struct->ref_command  NE NULL)
        ESA_DIAG_printf(diag_comp, 2,
                        "REFRESH command: %s",
                         xref_command_struct->ref_command);
   }
 }
 /* WS10079N - end   */

 if (preamble NE NULL)
    free(preamble);

 if (rc NE ESA_OK )
   {
     if (xref_command_struct NE NULL)
      {
       if (xref_command_struct->add_command  NE NULL)
          free(xref_command_struct->add_command);
       if (xref_command_struct->del_command  NE NULL)
          free(xref_command_struct->del_command);
       if (xref_command_struct->rep_command  NE NULL)
          free(xref_command_struct->rep_command);
       if (xref_command_struct->ref_command  NE NULL)
          free(xref_command_struct->ref_command);
      }
   }

 if (free_op_lists_needed)
   {
    if (myinclude_op_lists NE NULL)
     {
       if (myinclude_op_lists->add_list   NE NULL)
          free(myinclude_op_lists->add_list);
       if (myinclude_op_lists->del_list   NE NULL)
          free(myinclude_op_lists->del_list);
       if (myinclude_op_lists->rep_list   NE NULL)
          free(myinclude_op_lists->rep_list);

       free(myinclude_op_lists);
     }

    if (myexclude_op_lists NE NULL)
     {
       if (myexclude_op_lists->add_list   NE NULL)
          free(myexclude_op_lists->add_list);
       if (myexclude_op_lists->del_list   NE NULL)
          free(myexclude_op_lists->del_list);
       if (myexclude_op_lists->rep_list   NE NULL)
          free(myexclude_op_lists->rep_list);

       free(myexclude_op_lists);
     }
   }

   ESA_DIAG_exit(diag_comp, 1, func, rc);
   return rc;

}
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_One_Command_Create                    *
 *                                                             *
 * DESCRIPTION    : create one command of ADD/DEL/REP          *
 *                  in the command_area                        *
 *                                                             *
 * INPUT            type                ROL/SGP           (I)  *
 *                  include_op_lists                      (I)  *
 *                  exclude_op_lists                      (I)  *
 *                  include_list                          (I)  *
 *                  exclude_list                          (I)  *
 *                  command_op          ADD/DEL/REP       (I)  *
 *                  command_area_len                      (I)  *
 *                  command_area                          (I,O)*
 *                  preamble            common start of        *
 *                                      command to be          *
 *                                      copied to              *
 *                                      command_area      (I)  *
 *                  descript            description/NULL  (I)  *
 *                  diag_comp                             (I)  *
 *                  admain_params                         (I)  *
 *                                                             *
 * OUTPUT         : command_area with xref command             *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

static ESA_RC XREF_One_Command_Create(
                  char                 * type,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
                  char                 * include_list,
                  char                 * exclude_list,
                  char                 * command_op,
                  int                    command_area_len,
                  char                ** command_area,
                  char                 * preamble,
                  char                 * descript,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

 static char    func[]="XREF_One_Command_Create";

/*
 *     Variables
 */

 ESA_RC                   rc = ESA_OK;
 char                     errmsg[125] = NULL_STRING;
 char                   * data = NULL;
 int                      cmd_len = 0;
 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);

 if (include_list NE NULL)
   ESA_DIAG_printf(diag_comp, 6,
   "type = <%.8s> command_op = <%.8s> include_list = <%.500s>",
    type, command_op, include_list);

 if (exclude_list NE NULL)
   ESA_DIAG_printf(diag_comp, 6,
   "type = <%.8s> command_op = <%.8s> exclude_list = <%.500s>",
    type, command_op, exclude_list);

     *command_area = calloc(1, command_area_len);
     if (*command_area EQ NULL)
      {
         CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                      "Command area", command_area_len);
         rc = ESA_FATAL;
         goto exit;
      }

     strcpy(*command_area,preamble);

     if (include_op_lists NE NULL)
      {
       rc = XREF_Insert_Inc_Exc(
                  "INCLUDE",
                  command_op,
                  *command_area,
                  include_list,
                  diag_comp,
                  admin_params);
       if (rc NE ESA_OK)
           goto exit;

      }

     if (exclude_op_lists NE NULL)
      {
       rc = XREF_Insert_Inc_Exc(
                  "EXCLUDE",
                  command_op,
                  *command_area,
                  exclude_list,
                  diag_comp,
                  admin_params);
       if (rc NE ESA_OK)
           goto exit;

      }

     strcat(*command_area,command_op);

     if (descript NE NULL)
      {
        strcat(*command_area," DESCRIPT(");
        strcat(*command_area,descript);
        strcat(*command_area,")");
      }

     ESA_DIAG_printf(diag_comp, 6,
           "command:<%.500s>",
           *command_area);

 exit:

 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;

}
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Insert_Inc_Exc                        *
 *                                                             *
 * DESCRIPTION    : Insert the INCLUDE or EXCLUDE part from    *
 *                  the list to the XREF command area          *
 *                                                             *
 * INPUT            inc_exc_type        INCLUDE/EXCLUDE   (I)  *
 *                  command_op          ADD/DEL/REP       (I)  *
 *                  command_area                          (I)  *
 *                  list                ptr to in/exclude      *
 *                                      list in mv struct (I)  *
 *                  diag_comp                             (I)  *
 *                  admain_params                         (I)  *
 *                                                             *
 * OUTPUT         : command_area with include/exclude part     *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/

static ESA_RC XREF_Insert_Inc_Exc(
                  char                 * inc_exc_type,
                  char                 * command_op,
                  char                 * command_area,
                  char                 * list,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

 static char    func[]="XREF_Insert_Inc_Exc";

/*
 *     Variables
 */

 ESA_RC                   rc = ESA_OK;
 char                     errmsg[125] = NULL_STRING;
 char                   * data = NULL;
 int                      cmd_len = 0;
 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);

 ESA_DIAG_printf(diag_comp, 6,
   "inc_exc_type = <%.8s> command_op = <%.8s> list = <%.500s>",
    inc_exc_type, command_op, list);

 if (list NE NULL)
  {
     strcat(command_area,inc_exc_type);
     strcat(command_area,"(");
     cmd_len = strlen(command_area);   /* length so far             */
     data = command_area + cmd_len;    /* ptr where data begins,    */
                                       /* needed for input below to */
                                       /* ADDINFO_convert_list_sep  */
     strcat(command_area,list);

     /*
      *    Replace list seperator with comma.
      *    subfield seperator replacement is specified
      *    in the parameters because the routine expects
      *    them,  but no subfield seperators will be found.
      */

     rc = ADDINFO_convert_list_sep(data,ADDINFO_LIST_ENTRY,
                                   ADDINFO_LIST_SUBFIELD,
                                   COMMA_CHAR,COMMA_CHAR);
     if (rc NE ESA_OK)
       {
         sprintf(errmsg,"ADDINFO_convert_list_sep rc =%d",rc);
         CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                 dest, component, func,
                 errmsg,
                 16, __LINE__);
         rc = ESA_FATAL;
         goto exit;
       }

     strcat(command_area,") ");

     ESA_DIAG_printf(diag_comp, 6,
       "after command_area = <%.500s>",
        command_area);

  }

  exit:

  ESA_DIAG_exit(diag_comp, 1, func, rc);
  return rc;

}

 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : XREF_Commands_Restore                      *
 *                                                             *
 * DESCRIPTION    : Restore commands that failed               *
 *                                                             *
 * INPUT            type                ROL/SGP           (I)  *
 *                  xref_name                             (I)  *
 *                  command_ops_to_restore                (I)  *
 *                                   - list of 3 char ops      *
 *                                     (ADD and/or DEL)   (I)  *
 *                                     to be restored     (I)  *
 *                  include_op_lists - pointer to existing     *
 *                                      op lists          (I)  *
 *                  exclude_op_lists - pointer to existing     *
 *                                      op lists          (I)  *
 *                  xref_command_struct - pointer to commands  *
 *                                      structure for the      *
 *                                      created commands  (O)  *
 *                  diag_comp                             (I)  *
 *                  admain_params                         (I)  *
 *                                                             *
 * OUTPUT         :                                            *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 * WS10079N:                                                   *
 * =========                                                   *
 * The code that executes the commands was moved to the        *
 * callers in order to save the need to add CTSBCMD (for       *
 * Acf2Cmd) to the LONKCARDs of CTSCONI nd CTSCOFI. Both       *
 * programs have CTSBSRV in their LINKCARD so adding a code    *
 * that calls ACf2Cmd requires changing their LINKCARDs. To    *
 * save this need, XREF_COmmands_Restore was changed to        *
 * prepare the commands and its callers will issue them.       *
 *                                                             *
 *                                                             *
 **************************************************************/

ESA_RC XREF_Commands_Restore(
                  char                 * type,
                  char                 * xref_name,
                  char                 * command_ops_to_restore,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
   /* WS10079N */ XREF_Cmd_Struct_typ       * xref_command_struct,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params)
{

 static char    func[]="XREF_Commands_Restore";

/*
 *     Variables
 */

 ESA_RC                      rc                  = ESA_OK;
 int                         ops_len             = 0;
 int                         ops_num             = 0;
 int                         i                   = 0;
 int                         add_was             = FALSE;
 int                         del_was             = FALSE;
 char                        op[4]               = "";
 char                        rst[4]              = "";
 char                        errmsg[125]         = "";
 char                      * pos                 = NULL;
 XREF_Operations_Lists_typ * myinclude_op_lists  = NULL;
 XREF_Operations_Lists_typ * myexclude_op_lists  = NULL;
 CTSAMSG_HANDLE_rec_ptr      msgs;
 CTSAMSG_DEST_TABLE_rec_ptr  dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(diag_comp, 1, func);

 xref_command_struct->add_command = NULL;
 xref_command_struct->del_command = NULL;
 xref_command_struct->rep_command = NULL;
 xref_command_struct->ref_command = NULL;

 ESA_DIAG_printf(diag_comp, 6,
   "type = <%.8s> xref_name = <%.8s> ops_to_restore = <%s>",
    type, xref_name, command_ops_to_restore);

 ops_len = strlen(command_ops_to_restore);

/*
 *     The provided list of command operations must a multiple of 3,
 *     so the remainder of dividing by 3 must be 0.
 */

 if ((ops_len % 3) NE 0)
  {
    sprintf(errmsg,
            "command_ops_to_restore is not valid  = <%s>",
            command_ops_to_restore);
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,func,
            errmsg, 16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

/*
 *     Validate that the list of command operations to restore
 *     contains only ADD and/or DEL.
 */

 ops_num = ops_len/3;
 for (i = ops_num; i GE 1; i--)
   {
     pos = command_ops_to_restore + (i-1)*3;
     if (strncmp(pos,"ADD",3) EQ 0)
        if(add_was) continue;
        else add_was = TRUE;
     else
     if (strncmp(pos,"DEL",3) EQ 0)
        if(del_was) continue;
        else del_was = TRUE;
     else
      {
        sprintf(errmsg,
        "command op %.3s is invalid or appears multiple times",
         pos);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                dest, component, func,
                errmsg,
                16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
      }
   }

/*
 *     Allocate include op lists
 */

 myinclude_op_lists  = calloc(1, sizeof(XREF_Operations_Lists_typ));

 if (myinclude_op_lists EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
    "Include XREF_Operations_Lists",
    sizeof(XREF_Operations_Lists_typ));
    rc = ESA_FATAL;
    goto exit;
  }

/*
 *     We want to reverse the include list we deleted, so we
 *     we put it in the add_list so the XREF_Commands_Create
 *     will generate an ADD for the list
 */

 myinclude_op_lists->add_list = include_op_lists->del_list;

/*
 *     We want to reverse the include list we added, so we
 *     we put it in the del_list so the XREF_Commands_Create
 *     will generate an DEL for the list
 */

 myinclude_op_lists->del_list = include_op_lists->add_list;
 myinclude_op_lists->rep_list = NULL;

 myexclude_op_lists  = calloc(1, sizeof(XREF_Operations_Lists_typ));
 if (myexclude_op_lists EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
    "Exclude XREF_Operations_Lists",
    sizeof(XREF_Operations_Lists_typ));
    rc = ESA_FATAL;
    goto exit;
  }

/*
 *     We want to reverse the exclude list we deleted, so we
 *     we put it in the add_list so the XREF_Commands_Create
 *     will generate an ADD for the list
 */

 myexclude_op_lists->add_list = exclude_op_lists->del_list;

/*
 *     We want to reverse the exclude list we added, so we
 *     we put it in the del_list so the XREF_Commands_Create
 *     will generate an DEL for the list
 */

 myexclude_op_lists->del_list = exclude_op_lists->add_list;
 myexclude_op_lists->rep_list = NULL;


 XREF_Commands_Create(type,
                      NULL,
                      xref_name,
                      "CHA",
                      myinclude_op_lists,
                      myexclude_op_lists,
                      xref_command_struct,
                      diag_comp,
                      admin_params);

 if (rc NE ESA_OK)
  {
    sprintf(errmsg,"XREF_Commands_Create rc =%d",rc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
            dest, component, func,
            errmsg,
            16, __LINE__);
    rc = ESA_FATAL;
    goto exit;
  }

 exit:

 if (myinclude_op_lists NE NULL)
    free(myinclude_op_lists);

 if (myexclude_op_lists NE NULL)
    free(myexclude_op_lists);

 ESA_DIAG_exit(diag_comp, 1, func, rc);
 return rc;

}
 /*      End   WS10079     */
/*****************************************************************/
/*                 start WS10078T                                */
/******************************************************************
 * Procedure Name: Old_XREF_Block_Build
 ******************************************************************
 * Description   : Build 2 XREF blocks of roles & role groups  or
 *                 sources & source groups.
 *                 Return either the shorter (BLDSHORT) or both
 *                 (BLD2). BLD2 is for future use.
 *                 This routine is called for account aggregation
 *                 and for SYNC user processing at the start of
 *                 the transaction and the output XREF block is
 *                 used to find out for each role or source
 *                 defined for a user whether it is a basic element
 *                 or a group element.
 * The output of the LIST LIKE(-) command has the following format.
 * Note that after the TOTAL line , there is always a whole spaces line.
 *  TLVB / TSROL1 LAST CHANGED BY TLVTS ON 03/10/20-15:26
 *                       EXCLUDE(TLVTS61 TLVTS62 TLVTS63 TLVTS64
 *                       TLVTS81 TLVTS82 TLVTS83 TLVTS84 TLVTS85
 *                       TLVTS97)
 *                       INCLUDE(TLVTS TLVTS1 TLVTS11 TLVTS12 TLV
 *                       TLVTS31 TLVTS32 TLVTS33 TLVTS34 TLVTS35
 *                       TLVTS6-) ROLE
 * TOTAL RECORD LENGTH= 764 BYTES, 18 PERCENT UTILIZED
 *
 * If the output is a GROUP then the word GROUP will apear after the
 * EXCLUDE(...)
 * Input         : function:  BLDSHORT - return the shorter list
 *                            BLD2     - return both blocks
 *                            TERM     - free the block(s)
 *                 XREFType : R-Roles reqested | S-Sources requested
 * Output        : Pointer to XREFBlk in pXREFBlk1
 *               : Pointer to XREFBlk in pXREFBlk2  (BLD2)
 * Return Value  : ESA_OK    - ended ok
 *                 ESA_WARN  - nothing to return
 *                 ESA_FATAL - fatal error
 ******************************************************************/
/* Start WS10079     XREF_Block_Build is replaced with a new version
ESA_RC Old_XREF_Block_Build(
                 char                     * function,
                 XREF_REC_BLK_rec_ptr     * pXREFBlk1,
                 XREF_REC_BLK_rec_ptr     * pXREFBlk2,
                 char                       XREFType,
                 ADMIN_PARAMS_rec_typ     * admin_params)         */
/* #define OUTPUT_AREA_LEN 16384                       */
/*               XREFType is XREF_REC_TYPE_xxx                       */
/*
{
  static char func[] = "Old_XREF_Block_Build";

  ESA_RC     rc = ESA_OK;
  ESA_RC     rcc = ESA_OK;
  char       errmsg[125];
  char       group = NULL_CHAR;
  char       name[XREF_NAME_SIZE] = "";
  char       rectype[7] = "";
  char       * output_area = NULL;
  char       * p1      = NULL;
  char       * p2      = NULL;
  char       * j       = NULL;
  int        term_needed = FALSE;                      /@ BS10108T @/
  int        name_size = 0;
  int        ruob_len  = 0;
  int        xref_size = 0;
  int        num_names_group = 0;
  int        num_names_non_group = 0;
  char       * pnext_group = NULL;
  char       * pnext_non_group = NULL;
  int        output_area_len = OUTPUT_AREA_LEN;
  char       isitgrp = NULL_CHAR;                      /@ BS10108T @/
  REXX@UTL_output_blk_rec_typ * pruob = NULL;
  Get_XREF_Rec_Handle * h = NULL;
  XREF_REC_BLK_rec_typ    * pXREFBlk_group = NULL;
  XREF_REC_BLK_rec_typ    * pXREFBlk_non_group = NULL;

  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);

  if (pXREFBlk1 EQ NULL)
  {
     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
             func, "XREFBlk1 pointer NULL",
             16, __LINE__);
     rc = ESA_FATAL;
        /@
        goto xref_bld_exit;                               BS10108T @/
        goto exit_final;                              /@  BS10108T @/
  }

  if (strcmp(function, "TERM") EQ 0)
  {
     ESA_DIAG_printf(PLT_COMP_XREF, 6,
                     "Processing TERM request");
     if (
           (strncmp((*pXREFBlk1)->eyec,ROLE_BLOCK_EYEC,4) NE 0)
           AND
           (strncmp((*pXREFBlk1)->eyec,SGP_BLOCK_EYEC,4) NE 0)
        )
     {
        sprintf(errmsg,
            "Invalid XREFBlk eye catcher = %4s",
            (*pXREFBlk1)->eyec);

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component,func,
                      errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        /@
        goto xref_bld_exit;                               BS10108T @/
        goto exit_final;                               /@ BS10108T @/
     }

     if (*pXREFBlk1 NE NULL)
        free(*pXREFBlk1);
     if (pXREFBlk2 NE NULL)
        if (*pXREFBlk2 NE NULL)
           free(*pXREFBlk2);
     /@
     goto xref_bld_exit;                                  BS10108T @/
     goto exit_final;                                  /@ BS10108T @/

  }
  else if (strcmp(function, "BLDSHORT") NE 0)
  {
     sprintf(errmsg,
         "Invalid function parameter = %8s", function);

     CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                   errmsg, 16, __LINE__);
     rc = ESA_FATAL;
     /@
     goto xref_bld_exit;                                  BS10108T @/
     goto exit_final;                                  /@ BS10108T @/
  }

  ESA_DIAG_printf(PLT_COMP_XREF, 6,
                 "Processing BLDSHORT request. XREFType=%c",
                  XREFType);

  /@   BS10108T  -  start @/

  if (pXREFBlk1 NE NULL)
      *pXREFBlk1 = NULL;

  if (pXREFBlk2 NE NULL)
      *pXREFBlk2 = NULL;

  /@   BS10108T  -  end   @/
  if (XREFType EQ XREF_REC_TYPE_ROLE)
     strcpy(rectype,"X(ROL)");
  else if (XREFType EQ XREF_REC_TYPE_SGP)
     strcpy(rectype,"X(SGP)");
  else
     {
        sprintf(errmsg,
            "Invalid XREFType = %c",
             XREFType);

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,
                      component,func,
                      errmsg, 16, __LINE__);
        rc = ESA_FATAL;
        /@
        goto xref_bld_exit;                               BS10108T @/
        goto exit_final;                               /@ BS10108T @/
     };

  rc = ACF2_Cmd2Mem(rectype,
                    "-",
                    NULL,
                    &pruob,
                    PLT_COMP_XREF,
                    admin_params);

  ESA_DIAG_printf(PLT_COMP_XREF,2,
          "ACF2_Cmd2Mem for %s returned rc = %d  ruob = %p",
           rectype,rc, pruob);

  if (rc  NE ESA_OK)
  {
    rc = ESA_FATAL;   /* Error message was already issued? @/
    /@
    goto xref_bld_exit;                                   BS10108T @/
    goto exit_final;                                   /@ BS10108T @/
  }

  /@   If nothing was returned - error.    @/
  if (pruob EQ NULL)
  {
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,func,
                  "No output was returned by the ACF2 commands",
                  16, __LINE__);
    rc = ESA_FATAL;
    /@
    goto xref_bld_exit;                                   BS10108T @/
    goto exit_final;                                   /@ BS10108T @/
  }

  /@ allocate 2 XREF blocks          @/

  ruob_len = pruob->ruohdlen;
  xref_size =  sizeof(XREF_REC_BLK_rec_typ) + ruob_len/2;

  pXREFBlk_group = calloc(1, xref_size);

  if (pXREFBlk_group EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Area for XREF block1", xref_size);
    rc = ESA_FATAL;
    goto xref_bld_exit;
  };

  ESA_DIAG_printf(PLT_COMP_XREF,1,
          "Allocated pXREFBlk_group of size = %d at = %p",
           xref_size,pXREFBlk_group);
  pnext_group =   pXREFBlk_group->names;

  pXREFBlk_non_group = calloc(1, xref_size);

  if (pXREFBlk_non_group EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Area for XREF block2", xref_size);
    free(pXREFBlk_group);                             /@ BS10108T @/
    rc = ESA_FATAL;
    goto xref_bld_exit;
  };

  pnext_non_group =   pXREFBlk_non_group->names;
  ESA_DIAG_printf(PLT_COMP_XREF,1,
          "Allocated pXREFBlk_non_group of size = %d at = %p",
           xref_size,pXREFBlk_non_group);


  /@ initialize the 2 XREF blocks          @/
     pXREFBlk_non_group->group = XREF_REC_group_No;
     pXREFBlk_group->group = XREF_REC_group_Yes;
     pXREFBlk_non_group->num_names = 0;
     pXREFBlk_group->num_names = 0;

  if (XREFType EQ XREF_REC_TYPE_ROLE)
  {
     strncpy(pXREFBlk_group->eyec,ROLE_BLOCK_EYEC,4);
     strncpy(pXREFBlk_non_group->eyec,ROLE_BLOCK_EYEC,4);
     pXREFBlk_group->type = XREF_REC_TYPE_ROLE;
     pXREFBlk_non_group->type = XREF_REC_TYPE_ROLE;
  }
  else
  {
     strncpy(pXREFBlk_group->eyec,SGP_BLOCK_EYEC,4);
     strncpy(pXREFBlk_non_group->eyec,SGP_BLOCK_EYEC,4);
     pXREFBlk_group->type = XREF_REC_TYPE_SGP;
     pXREFBlk_non_group->type = XREF_REC_TYPE_SGP;
  }

  ESA_DIAG_printf(PLT_COMP_XREF, 2,
     "pXREFBlk_non_group -> %5s",pXREFBlk_non_group);


  ESA_DIAG_printf(PLT_COMP_XREF, 2,
     "pXREFBlk_group -> %5s",pXREFBlk_group);

  output_area = calloc(1, output_area_len);

  if (output_area EQ NULL)
  {
    CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "Output area for Get_XREF_Record", output_area_len);
    rc = ESA_FATAL;
    goto xref_bld_exit;
  };

  do
   {

     ESA_DIAG_printf(PLT_COMP_XREF, 2,
     "Calling Get_XREF_Record");

     rc = Get_XREF_Record(
                "GETNEXT",
                &h,
                pruob,
                output_area,
                output_area_len,
                admin_params);


     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Get_XREF_Record rc = %d",
           rc);

     if (rc  NE ESA_OK)
     {
       break;
     }


     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Get_XREF_Record output area = %s",
           output_area);

     /@   BS10108T  -  start @/
     /@   extract the role|source name and if group or not          @/

     term_needed = TRUE;

     ESA_DIAG_printf(PLT_COMP_XREF, 2,
      "Calling Parse_XREF_Record");


     rc = Parse_XREF_Record(
                            name,
                            NULL,
                            output_area,
                            'Y',
                            &isitgrp,
                            admin_params);

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Parse_XREF_Record rc = %d",
           rc);

     if (rc  NE ESA_OK)
     {
        sprintf(errmsg,
            "Parse_XREF_Record returned rc = %d",
            rc);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg, 12, __LINE__);

        rc = ESA_FATAL;
        goto xref_bld_exit;
       break;
     }

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "name = <%s> isitgrp = %c",
           name,isitgrp);

     /@ if (isitgrp EQ 'N')                             BS10108T @/
     if (isitgrp EQ 'X')                             /@ BS10108T @/
     {
        strcpy(pnext_non_group,name);
        pXREFBlk_non_group->num_names+= 1;
        pnext_non_group+=XREF_NAME_SIZE;
     }
     else
     {
        strcpy(pnext_group,name);
        pXREFBlk_group->num_names+= 1;
        pnext_group+=XREF_NAME_SIZE;
     }

   } while (rc EQ ESA_OK);


   /@   BS10108T  -  end   @/


     /@
      * BS10108T - following parsing replaced with Parse_XREF_Record
      *            above
     p1 = strstr(output_area, " LAST CHANGED");
     if (p1  EQ NULL)
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "LAST CHANGED not found in Get_XREF_Record output area");

        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     p2 = p1 - XREF_NAME_SIZE;
     for (j=p1-1; j GE p2; j--)
          {
            if (*j EQ ' ') break;  /@ break only from this for @/
          };

     if ((*j NE ' ') OR (j EQ (p1-1)) )
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
        "Could not locate a valid name p1=%p p2=%p(%9s) j=%p(%c)",
        p1,p2,p2,j,*j);

        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     name_size = p1 - j -1;

     if (name_size GT (XREF_NAME_SIZE - 1))
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
        "Could not locate a valid name p1=%p p2=%p j=%p name_size=%d",
        p1,p2,j,name_size);

        rc = ESA_FATAL;
        goto xref_bld_exit;
     }

     memset (name, 0X00, sizeof(name));
     strncpy(name,++j,name_size);

     ESA_DIAG_printf(PLT_COMP_XREF,6,
          "name = %s",
           name);

     p1 = strstr(output_area, " GROUP ");
     if (p1  EQ NULL)
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "GROUP not found, assuming non group");

        strcpy(pnext_non_group,name);
        pnext_non_group+=9 ;
        pXREFBlk_non_group->num_names+= 1;
     }
     else
     {

        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "GROUP found");

        strcpy(pnext_group,name);
        pXREFBlk_group->num_names+= 1;
        pnext_group+=9 ;
     }

   } while (rc EQ ESA_OK);
     @/

  ESA_DIAG_printf(PLT_COMP_XREF,2,
          "After while rc = %d",
           rc);

  ESA_DIAG_printf(PLT_COMP_XREF,6,
          "Calling Get_XREF_Record TERM");

  rcc = Get_XREF_Record(
             "TERM",
             &h,
             pruob,
             output_area,
             output_area_len,
             admin_params);

  term_needed = FALSE;                            /@ BS10108T @/
  if (rcc NE ESA_OK)
  {
    sprintf(errmsg,
            "Get_XREF_Record TERM returned rc = %d",
            rcc);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg, 12, __LINE__);
  };

  /@ * * WS10078S start * * @/

  rcc = ESA_CLI_del_RUOB(pruob,
                         admin_params);
  if (rcc NE ESA_OK)
  {
    sprintf(errmsg,
            "ESA_CLI_del_RUOB returned rc = %d  for ruob = %p",
            rcc, pruob);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                  func, errmsg, 12, __LINE__);
  };

  pruob = NULL;


  /@ * * WS10078S end * * @/

  /@ if (output_area NE NULL) free(output_area);            BS10108T @/
  if (rc EQ ESA_FATAL) goto xref_bld_exit;
  /@ if (pXREFBlk_group EQ NULL) goto xref_bld_exit;       BS10108T @/
  rc = ESA_OK;

  if (pXREFBlk_non_group->num_names LT pXREFBlk_group->num_names)
  {
   ESA_DIAG_printf(PLT_COMP_XREF,2,
   "Shorter list is non group with pXREFBlk_non_group->num_names=%d",
    pXREFBlk_non_group->num_names);
   *pXREFBlk1 =  pXREFBlk_non_group;
   free(pXREFBlk_group);
  }
  else
  {
   ESA_DIAG_printf(PLT_COMP_XREF,2,
   "Shorter list is group with pXREFBlk_group->num_names=%d names",
    pXREFBlk_group->num_names);

   *pXREFBlk1 =  pXREFBlk_group;
   free(pXREFBlk_non_group);
  }
  goto exit_final;                                       /@ BS10108T @/

  xref_bld_exit:

  /@   BS10108T  -  start @/
  if (rc  EQ ESA_FATAL)
   {
     if (term_needed)
        rcc = Get_XREF_Record(
             "TERM",
             &h,
             pruob,
             output_area,
             output_area_len,
             admin_params);

     if (pruob NE NULL)
        rcc = ESA_CLI_del_RUOB(pruob, admin_params);

     if (pXREFBlk1 NE NULL)
        if (*pXREFBlk1      NE NULL) free(*pXREFBlk1);

     if (output_area        NE NULL) free(output_area);

     if (pXREFBlk_group     NE NULL) free(pXREFBlk_group);

     if (pXREFBlk_non_group NE NULL) free(pXREFBlk_non_group);
   }
  exit_final:
  /@   BS10108T  -  end   @/

  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;

}
/@ BS10108 - end of moved code.                          @/
end of WS10079   */
/* BS10108 - The code below was moved here from CTSBGUG  */
/*********************************************************************
        Start WS10078TG

        Parse_XREF_Record

        The routine parses a ROLE/SOURCE record from SET X(ROL)/X(SGP)
        LIST LIKE(-) output, and updates ug_params & addinfo.

        A sample ROLE record will look as follows:
 TLVB / ROLR341 LAST CHANGED BY TLVKP ON 04/13/20-05:44
                      DESCRIPT('THIS IS DESCRIPTION')
                      EXCLUDE(ROLR11A ROLR31A ROLR31B ROLR32B ...
                      ROLR34N ROLR34O ROLR34P ROLR34Q ROLR34R ...
                      ROLR35Y ROLR35Z ROLR36H ROLR36V ROLR37A ...
                      ROLR39Z)
                      INCLUDE(ROLR321 ROLR322 ROLR323 ROLR324 ...
                      ROLR345 ROLR346 ROLR347 ROLR348 ROLR349 ...
                      ROLR357 ROLR358 ROLR359 ROLR360 ROLR361 ...
                      ROLR391 ROLR392 ROLR393) ROLE
TOTAL RECORD LENGTH= 986 BYTES, 24 PERCENT UTILIZED

Note: the leading blanks on all lines which are not the first and the
      last are dropped by Get_XREF_Record (some extra blanks may remain
      on the right side of continued lines).


   BS10108 - 2 new input parameters:
             groupYN - whether to process group records or not (I):
                       Y - progess group records.
                       N - process only role/source records.
             isitgrp - is it group (Y/N) (O)

   BS10108 - New return code
             ESA_SKIP - a group record indentified, and groupYN = N



**********************************************************************/
/* BS10108 static   ESA_RC Parse_XREF_Record(   */
ESA_RC Parse_XREF_Record(                                /* BS10108 */
    /* BS10108              UG_PARAMS_rec_ptr       ug_params,   */
    /* WS10079              UG_typ                  group_name,  */
                            char              * out_xname, /*WS10079*/
                            char              * out_sysid, /*WS10079*/
                            ADDINFO_rec_ptr         addinfo,
                            char                  * xref_record,
    /* BS10108 */           char                    groupYN,
    /* BS10108 */           char                  * isitgrp,
                            ADMIN_PARAMS_rec_typ  * admin_params)
{
  static char func[] = "Parse_XREF_Record";

  ESA_RC              rc   = ESA_OK;
  ESA_RC              max_rc = ESA_OK;                  /* BS10134 */
  /* BS10108 ESA_RC   rcc  = ESA_OK;  */
  ONE_FIELD_rec_ptr   pair = NULL;
  char              * p1   = NULL;
  char              * g1   = NULL;                       /* BS10108 */
  char              * p2   = NULL;
  char              * j    = NULL;
  /* BS10108 char   * val  = NULL;  */
  char              * from = NULL;
  char              * to   = NULL;
  char                schar = NULL_CHAR;                  /* BS10108 */
  UG_typ              name;
  int                 name_size = 0;
  char              * sysid = NULL;                       /* BS10108T */
  char                sysid_name[ACF2_SYSID_SIZE]="";     /* BS10108T */
  int                 sysid_len = 0;                      /* BS10108T */
  char              * description = NULL;                 /* BS10108 */
  int                 desc_len = 0;                       /* BS10108 */
  char              * exclude = NULL;                     /* BS10108 */
  int                 exclude_len = 0;                    /* BS10108 */
  char              * include = NULL;                     /* BS10108 */
  int                 include_len = 0;                    /* BS10108 */
  char                errmsg[125] = "";
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  ESA_DIAG_enter(PLT_COMP_XREF, 1, func);

  /*  BS10108 - start */
  /*  Validate the groupYN parameter                                */
  if (groupYN NE 'Y'   AND  groupYN NE 'N')
  {
      sprintf(errmsg,
       "groupYN = %c is invalid.  Should be Y/N", groupYN);

      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                             func, errmsg, 16,__LINE__);

      rc = ESA_FATAL;
      goto exit;
  };
  /*  BS10108 - end   */

  /*  BS10108T - start   */

  /*  Locate the sysid                                              */

  sysid = xref_record +1;
  p1 = strstr(xref_record, " /");

  if (p1  EQ NULL)
   {
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component, func,
                   "/ not found in XREF record area",
                    16,__LINE__);
      rc = ESA_FATAL;
      goto exit;
   };

  sysid_len = p1 - sysid ;

  if (sysid_len GT (ACF2_SYSID_SIZE - 1))
   {

      ESA_DIAG_printf(PLT_COMP_XREF,6,
      "Could not locate a valid SYSID sysid=%p p1=%p sysid_len=%d",
      sysid,p1,sysid_len);


      sprintf(errmsg,
       "SYSID name size too large = %d",sysid_len);

      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                             func, errmsg, 16,__LINE__);

      rc = ESA_FATAL;
      goto exit;
   };

  strncpy(sysid_name,sysid,sysid_len);
  sysid_name[sysid_len] = NULL_CHAR;

  ESA_DIAG_printf(PLT_COMP_XREF,6,"sysid = <%s>", sysid_name);

  p1 = NULL;

  /*  BS10108T - end     */

  /*  locate the xref name and return                               */

  ESA_DIAG_printf(PLT_COMP_XREF,6,
        "input xref record area = <%s>",xref_record);

  /*  Locate the role|source name                                   */

  p1 = strstr(xref_record, " LAST CHANGED");
  if (p1  EQ NULL)
   {
      /* BS10108 - start */
      /*
      sprintf(errmsg,
        "LAST CHANGED not found in XREF record area");

      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                             func, errmsg, 16,__LINE__);
      */
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component, func,
                   "LAST CHANGED not found in XREF record area",
                    16,__LINE__);
      /* BS10108 - end   */
      rc = ESA_FATAL;
      goto exit;
   };

  p2 = p1 - XREF_NAME_SIZE;
  for (j=p1-1; j GE p2; j--)
        {
          if (*j EQ ' ') break;  /* break only from this for */
        };

  if ((*j NE ' ') OR (j EQ (p1-1)) )
   {

      ESA_DIAG_printf(PLT_COMP_XREF,6,
      "Could not locate a valid name p1=%p p2=%p<%s> j=%p(%c)",
      p1,p2,p2,j,*j);

      /* BS10108 - start */
      /*
      sprintf(errmsg,
        "Could not locate the precedng blank of XREF name");

      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                             func, errmsg, 16,__LINE__);
      */
      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest,
                    component, func,
                   "Could not locate the preceding blank of XREF name",
                    16,__LINE__);
      /* BS10108 - end   */

      rc = ESA_FATAL;
      goto exit;
   };

  name_size = p1 - j -1;

  if (name_size GT (XREF_NAME_SIZE - 1))
   {

      ESA_DIAG_printf(PLT_COMP_XREF,6,
      "Could not locate a valid name p1=%p p2=%p j=%p name_size=%d",
      p1,p2,j,name_size);


      sprintf(errmsg,
       "XREF name size too large = %d",name_size);

      CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                             func, errmsg, 16,__LINE__);

      rc = ESA_FATAL;
      goto exit;
   };


  strncpy(name,++j,name_size);
  name[name_size] = NULL_CHAR;

  /*  return the xref name, if requested                        */
  /* WS10079
  if (group_name NE NULL)     */                          /* BS10108 */
  /* BS10108 strcpy(ug_params->group,name);    */
  /* WS10079
    strcpy(group_name, name); */  /* return the group name   BS10108 */
  if (out_xname NE NULL)                                  /* WS10079 */
    strcpy(out_xname,name);                               /* WS10079 */

  if (out_sysid NE NULL)                                  /* WS10079 */
    strcpy(out_sysid,sysid_name);                         /* WS10079 */
  else if (out_xname NE NULL)                             /* WS10079N*/
  {                                                       /* WS10079 */
    strcat(out_xname,"(");                                /* WS10079 */
    strcat(out_xname,sysid_name);                         /* WS10079 */
    strcat(out_xname,")");                                /* WS10079 */
  }

  ESA_DIAG_printf(PLT_COMP_XREF,6,"name = <%s>", name);

  /*  locate the description                                    */

  from = p1 + sizeof(" LAST CHANGED") -1;
  p1 = strstr(from, "DESCRIPT(");

  if (p1  EQ NULL)
     ESA_DIAG_printf(PLT_COMP_XREF,6,"DESCRIPT( not found");
  else
   {
     ESA_DIAG_printf(PLT_COMP_XREF,6,"DESCRIPT( found");

     from = p1 + sizeof("DESCRIPT(") -1;
     to = strstr(from, ")");

     if (to  EQ NULL)
     {
        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "DESCRIPT closing parenthesis not found");

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, "DESCRIPT closing parenthesis not found",
                     16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }

     /* BS10108 *to = NULL_CHAR;  */
     /* BS10108 val = from;  */
     description = from;           /* start of description   BS10108 */
     desc_len = to - from;         /* description length     BS10108 */
     from = to + 1;   /* for next search   */

     /* BS10108 ESA_DIAG_printf(PLT_COMP_XREF,6,"DESCRIPT=<%s>",val); */
     ESA_DIAG_printf(PLT_COMP_XREF,6,                     /* BS10108 */
                     "DESCRIPT=<%.*s>",                   /* BS10108 */
                     desc_len, description);              /* BS10108 */

     /* BS10108 - this code will be executed later...
     pair = ADDINFO_search("Description",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
      {
         rc = ADDINFO_updval(val, ACF_ADDINFO_VAL_LEN, pair);

         if (rc NE ESA_OK)
         {
           sprintf(errmsg,
                "Updating xref=<%s> Description=<%s> failed with rc=%d",
                 name,val,rc);

           CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                                func, errmsg, 16,__LINE__);
           rc = ESA_FATAL;
           goto exit;
         };
      };

         BS10108 - end of moved code */
   }

  /*  locate the exclude list and update addinfo with the value of the
      ExcludeList attribute                                         */

   p1 = strstr(from, "EXCLUDE(");

   if (p1  EQ NULL)
      ESA_DIAG_printf(PLT_COMP_XREF,6,"EXCLUDE( not found");
   else
   {
     ESA_DIAG_printf(PLT_COMP_XREF,6, "EXCLUDE( found");

     from = p1 + sizeof("EXCLUDE(") -1;
     to = strstr(from, ")");

     if (to  EQ NULL)
     {
        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "EXCLUDE closing parenthesis not found");

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, "EXCLUDE closing parenthesis not found",
                     16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }

     /* BS10108 *to = NULL_CHAR;  */
     /* BS10108 val = from;  */
     exclude = from;               /* start of exclude       BS10108 */
     exclude_len = to - from;      /* exclude length         BS10108 */
     from = to + 1;   /* for next search   */

     /* BS10108
     ESA_DIAG_printf(PLT_COMP_XREF,6,"EXCLUDE list=<%s>",val);  */
     ESA_DIAG_printf(PLT_COMP_XREF,6,                     /* BS10108 */
                    "EXCLUDE list=<%.*s>",                /* BS10108 */
                    exclude_len, exclude);                /* BS10108 */

     /* BS10108 - this code will be executed later...
     pair = ADDINFO_search("ExcludeList",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
      {
        rc = ADDINFO_updval(val, ACF_ADDINFO_VAL_LEN, pair);

        if (rc NE ESA_OK)
        {

          sprintf(errmsg,
              "Updating xref=<%s> ExcludeList=<%s> failed with rc=%d",
               name,val,rc);

          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                               func, errmsg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
        };
      };
         BS10108 - end of moved code */
   }

  /*  Locate the group and include list                              */

   p1 = strstr(from, "INCLUDE(");
   g1 = strstr(from, " GROUP ");  /* look for GROUP          BS10108 */


   /*  Check if it is a group        */                   /* BS10108 */

   if (g1 NE NULL  AND g1 LT p1) /* group before include     BS10108 */
   {                                                      /* BS10108 */
     if (groupYN EQ 'N')    /* ignore group ? */          /* BS10108 */
     {                                                    /* BS10108 */
       rc = ESA_SKIP;       /* group ignored */           /* BS10108 */
       goto exit;                                         /* BS10108 */
     }                                                    /* BS10108 */
     else                   /* return isitgrp = Y */      /* BS10108 */
       if (isitgrp NE NULL)                               /* BS10108 */
         *isitgrp = 'G';                                  /* BS10108 */
   }                                                      /* BS10108 */
   else                     /* it is not a group */       /* BS10108 */
     if (isitgrp NE NULL)                                 /* BS10108 */
       *isitgrp = 'X';      /* return isitgrp = N */      /* BS10108 */

   if (isitgrp NE NULL)                                  /* BS10108T */
     ESA_DIAG_printf(PLT_COMP_XREF,6,                    /* BS10108T */
                    "isitgrp=%c",*isitgrp);              /* BS10108T */

   /*  Locate the include list data.                                 */
   if (p1  EQ NULL)
      ESA_DIAG_printf(PLT_COMP_XREF,6,"INCLUDE( not found");
   else
   {
     ESA_DIAG_printf(PLT_COMP_XREF,6, "INCLUDE( found");

     from = p1 + sizeof("INCLUDE(") -1;
     to = strstr(from, ")");

     if (to  EQ NULL)
     {
        ESA_DIAG_printf(PLT_COMP_XREF,6,
          "INCLUDE closing parenthesis not found");

        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
                     func, "INCLUDE closing parenthesis not found",
                     16, __LINE__);
        rc = ESA_FATAL;
        goto exit;
     }

     /* BS10108 *to = NULL_CHAR;   */
     /* BS10108 val = from;        */
     include = from;               /* start of include       BS10108 */
     include_len = to - from;      /* include length         BS10108 */
     from = to + 1;   /* for next search   */

     /* BS10108
     ESA_DIAG_printf(PLT_COMP_XREF,6,"INCLUDE list=<%s>",val);       */
     ESA_DIAG_printf(PLT_COMP_XREF,6,                     /* BS10108 */
                    "INCLUDE list=<%.*s>",                /* BS10108 */
                    include_len, include);                /* BS10108 */


     /* BS10108 - this code will be executed later...
     pair = ADDINFO_search("IncludeList",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
      {
        rc = ADDINFO_updval(val, ACF_ADDINFO_VAL_LEN, pair);

        if (rc NE ESA_OK)
        {

          sprintf(errmsg,
              "Updating xref=<%s> IncludeList=<%s> failed with rc=%d",
               name,val,rc);

          CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                               func, errmsg, 16,__LINE__);
        rc = ESA_FATAL;
        goto exit;
        };
      };
         BS10108 - end of moved code */
   }

   /* BS10108 - start */
   /*
    *  Return xref data in addinfo, if requested.
    *
    *  Why is this code moved to the end of the routine:
    *  When groupYN=N, we do not need to return the record data.
    *  But, we know the record type only after we already processed
    *  some of the attributes. So, we keep the location of each
    *  attribute and set them in addinfo only if they are required.
    *
    */

   if (addinfo NE NULL)
   {
     /* BS10108T - start */
     pair = ADDINFO_search("SYSID",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
     {
       rc = ADDINFO_updval(sysid_name, ACF_ADDINFO_VAL_LEN, pair);

       if (rc NE ESA_OK)
       {
         sprintf(errmsg,
            "Updating xref=<%s> SYSID=<%.*s> failed with rc=%d",
               name, sysid_len, sysid_name, rc);

         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                              func, errmsg, 16,__LINE__);
         rc = ESA_FATAL;
         goto exit;
       };
     };

     if (description NE NULL)
     {
     /* BS10108T - end   */
     pair = ADDINFO_search("Description",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
     {
       schar = *(description+desc_len);      /* save original char */
       *(description+desc_len) = NULL_CHAR;  /* set string terminator */

       rc = ADDINFO_updval(description, ACF_ADDINFO_VAL_LEN, pair);

       *(description+desc_len) = schar;      /* restore the data.     */

       /* BS10134 - start */
       if (rc EQ ESA_EOF)
       {
         max_rc = rc;
         UPDVAL_EOF(name, pair, description, desc_len,
                    "description", addinfo, errmsg);
       }
       /* BS10134 - end */
       /* BS10134 if (rc NE ESA_OK)   */
       else if (rc NE ESA_OK)                             /* BS10134 */
       {
        /*BS10134 sprintf(errmsg,
            "Updating xref=<%s> Description=<%.*s> failed with rc=%d",
               name, desc_len, description, rc);                ***/
        snprintf(errmsg,  sizeof(errmsg)-1,              /*BS10134*/
         "Updating xref=<%s> failed with rc=%d - Description=%d<%.*s> ",
           name, rc, desc_len, desc_len, description);

         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                              func, errmsg, 16,__LINE__);
         rc = ESA_FATAL;
         goto exit;
       };
     };
     };                                              /* BS10108T */

     if (exclude NE NULL)                            /* BS10108T */
     {
     pair = ADDINFO_search("ExcludeList",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
     {
       schar = *(exclude+exclude_len);      /* save original char */
       *(exclude+exclude_len) = NULL_CHAR;  /* set string terminator */

       rc = ADDINFO_updval(exclude, ACF_ADDINFO_VAL_LEN, pair);

       *(exclude+exclude_len) = schar;      /* restore the data.     */

       /************ BS10134 start ************/
       if (rc EQ ESA_EOF)
       {
         max_rc = rc;
         UPDVAL_EOF(name, pair, exclude, exclude_len,
                    "Exclude-List items", addinfo, errmsg);
       }
       /************ BS10134 end   ************/
       /*BS10134 if (rc NE ESA_OK)             */
       else if (rc NE ESA_OK)                               /*BS10134*/
       {

        /*BS10134 sprintf(errmsg,
            "Updating xref=<%s> ExcludeList=<%.*s> failed with rc=%d",
             name, exclude_len, exclude, rc);                    ***/
        snprintf(errmsg,  sizeof(errmsg)-1,           /*BS10134*/
         "Updating xref=<%s> failed with rc=%d ExcludeList=%d<%.*s> ",
           name, rc, exclude_len , exclude_len , exclude);

         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                              func, errmsg, 16,__LINE__);
       rc = ESA_FATAL;
       goto exit;
       };
     /* BS10134  };  */
     /* WS10079 start */
     /* if multivalue attribute convert blanks to list seperators   */
     if (pair->add_typ EQ TYPE_1B)
       {
        pair = get_pair(pair); /*get real pair after updval WS10082N*/
        rc = ADDINFO_convert_list_sep(pair->value,
                                      ' ',
                                      ' ',
                                      ADDINFO_LIST_ENTRY,
                                      ADDINFO_LIST_ENTRY);
        if (rc NE ESA_OK)
          {
            sprintf(errmsg,"ADDINFO_convert_list_sep rc =%d",rc);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                    dest, component, func,
                    errmsg,
                    16, __LINE__);
            rc = ESA_FATAL;
            goto exit;
          }
       }
     /* WS10079 end  */
      };                                             /* BS10134  */
     };                                              /* BS10108T */

     pair = ADDINFO_search("IncludeList",
                                ACF_ADDINFO_KWD_LEN,
                                addinfo->pair,
                                addinfo->num_pairs);

     if (pair NE NULL)
     {
       schar = *(include+include_len);      /* save original char */
       *(include+include_len) = NULL_CHAR;  /* set string terminator */

       rc = ADDINFO_updval(include, ACF_ADDINFO_VAL_LEN, pair);

       *(include+include_len) = schar;      /* restore the data.     */

       /************ BS10134 start ************/
       if (rc EQ ESA_EOF)
       {
         max_rc = rc;
         UPDVAL_EOF(name, pair, include, include_len,
                    "Include-List items", addinfo, errmsg);
       }
       /************ BS10134 end ***************/
       /*BS10134 if (rc NE ESA_OK) ***/
       else if (rc NE ESA_OK)                             /*BS10134*/
       {
         /*BS10134 sprintf(errmsg,
             "Updating xref=<%s> IncludeList=<%.*s> failed with rc=%d",
              name, include_len, include, rc);                ***/
         snprintf(errmsg,  sizeof(errmsg)-1,              /*BS10134*/
          "Updating xref=<%s> failed with rc=%d IncludeList=%d<%.*s> ",
            name, rc, include_len , include_len , include);

         CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, component,
                              func, errmsg, 16,__LINE__);
       rc = ESA_FATAL;
       goto exit;
       };
     /* BS10134  };  */
     /* WS10079 start */
     /* if multivalue attribute convert blanks to list seperators   */
     if (pair->add_typ EQ TYPE_1B)
       {
        pair = get_pair(pair);  /* get real pair after updval WS10082N*/
        rc = ADDINFO_convert_list_sep(pair->value,
                                      ' ',
                                      ' ',
                                      ADDINFO_LIST_ENTRY,
                                      ADDINFO_LIST_ENTRY);
        if (rc NE ESA_OK)
          {
            sprintf(errmsg,"ADDINFO_convert_list_sep rc =%d",rc);
            CTSAMSG_print(ERR_INTERNAL2, msgs, NULL,
                    dest, component, func,
                    errmsg,
                    16, __LINE__);
            rc = ESA_FATAL;
            goto exit;
          }
       }
     };                                                  /* BS10134  */
     /* WS10079 end  */
   };

   /* BS10134 rc = ESA_OK;  */
   rc = max_rc;                                           /* BS10134 */
   /* BS10108 - end   */

  exit:
  ESA_DIAG_exit(PLT_COMP_XREF, 1, func, rc);
  return rc;

}
/* BS10108 - end of moved code.   */
/********************** WS10079A start ******************************/
/*********************************************************************
 * Procedure Name: XREF_Validate_name
 *********************************************************************
 * Description   : Validate XREF name
 * Input         : Role/Source name with/without SYSID
 * Output        :
 * Return Value  : ESA_OK    - Name is valid
 *                 ESA_FATAL - Name is invalid or missing parameter
 ********************************************************************/
ESA_RC XREF_Validate_name(
              char                     * pXREFname,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Validate_name";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[256];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  ACF2_PARAMS_rec_typ       * params_ptr = NULL;
  char                      * isSYSID;
  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if(pXREFname EQ NULL) {
    rc = ESA_FATAL;
    strcpy(errmsg, "XREFname is missing");
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  ESA_DIAG_printf(comp,6,"XREFname passed<%s>",pXREFname);
  isSYSID  = strchr(pXREFname,'(');
  params_ptr = admin_params->apiinit_handle;
  if(isSYSID EQ NULL) /* XREFname has no SYSID */
    if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a') {
      /* WS10079T
      sprintf(errmsg,
      "SYSID_SCOPE=ALL_SYSTEMS but no SYSID in XREF name <%s>.",
      pXREFname);
      strcat(errmsg,
        "Verify that Account or Group aggregation has been performed");
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);                      WS10079T */
      CTSAMSG_print(ACF2_SYSID_IN_XREF,                 /* WS10079T */
                    msgs, NULL, dest,                   /* WS10079T */
                    pXREFname,"expected","is");         /* WS10079T */
      rc = ESA_FATAL;
      goto exit;
    }
    else {
      rc = ESA_OK;
      ESA_DIAG_printf(comp,6,
        "SYSID_SCOPE NE 'a' and no SYSID in XREF name <%s>",pXREFname);
      goto exit;
    }
  else { /* XREFname has SYSID xref(sysid) */
    isSYSID = strchr(isSYSID,')');
    if(isSYSID EQ NULL) { /*no right parentheses*/
      /* WS10079T
      sprintf(errmsg,
      "Bad format of XREF name <%s>.Missing right parantheses",
      pXREFname);
      ESA_DIAG_printf(comp,6,"%s",errmsg);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);                      WS10079T */
      rc = ESA_FATAL;
      goto exit;
    }
    else if(params_ptr->XREF_SYSID_SCOPE[0] NE 'a') {
      /* WS10079T
      sprintf(errmsg,
        "SYSID_SCOPE is not ALL_SYSTEMS but SYSID unexpectedly is in "
        "XREF name <%s>. If SYSID_SCOPE has been ALL_SYSTEMS but "
        "changed, Account or Group Aggregation may solve the problem.",
        pXREFname);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);                      WS10079T */
      CTSAMSG_print(ACF2_SYSID_IN_XREF,                 /* WS10079T */
                    msgs, NULL, dest,                   /* WS10079T */
                    pXREFname,"not expected","is not"); /* WS10079T */
      rc = ESA_FATAL;
      goto exit;
    }
    else {
      rc = ESA_OK;
      ESA_DIAG_printf(comp,6,
        "SYSID_SCOPE EQ 'a' and SYSID is in XREF name <%s>",pXREFname);
      goto exit;
    }
  } /* end of: XREFname has SYSID xref(sysid) */
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}

/*** end of XREF_Validate_name  **********************************/
/*********************************************************************
 * Procedure Name: XREF_Split_Name
 *********************************************************************
 * Description   : Split XREF name to XREF and SYSID
 * Input         : Role/Source name with/without SYSID
 * Output        :
 * Return Value  : ESA_OK    - SYSID is added
 *                 ESA_FATAL - Missing parameter
 ********************************************************************/
ESA_RC XREF_Split_Name(
              char                     * pFullName,
              char                     * pXREFname,
              char                     * pSYSID,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Split_Name";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[256];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  char                      * isSYSID;
  char                        left_par[2]  = "(" ;
  char                        right_par[2] = ")" ;
  char                        tmpFullName[20];

  ESA_DIAG_enter(comp, 2, func);
  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if((pFullName EQ NULL) OR (pXREFname EQ NULL) OR (pSYSID EQ NULL)) {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s %s %s is a missing parameter",
          (pFullName NE NULL ? "" : "Full name-1st parm"),
          (pXREFname NE NULL ? "" : "XREF name-2nd parm"),
          (pSYSID    NE NULL ? "" : "SYSID-3rd parm"));
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  ESA_DIAG_printf(comp,6,"Full XREFname passed<%s>",pFullName);
  isSYSID  = strchr(pFullName,'(');
  if(isSYSID EQ NULL) { /* XREFname has no SYSID */
    strcpy(pXREFname,pFullName);
    ESA_DIAG_printf(comp,6,"No paranthesis in XREF name");
    /* rc = ESA_WARN;    indicate no SYSID. ESA_WARN = 2 WS10079T */
  }
  else { /* xref(sysid) format */
    isSYSID = strchr(isSYSID,')');
    if(isSYSID EQ NULL) { /*no right parentheses*/
      sprintf(errmsg,
      "Bad format of XREF name <%s>.Missing right parantheses",
      pFullName);
      ESA_DIAG_printf(comp,6,"%s",errmsg);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }
    else { /*xref(sysid) valid format */
      strcpy(tmpFullName,pFullName);/*copy as strtok modifies 1st parm*/
      strcpy(pXREFname,strtok(tmpFullName,left_par));
      strcpy(pSYSID,strtok(NULL,right_par));
      ESA_DIAG_printf(comp,6,"XREFname is <%s> SYSID is <%s>",
                      pXREFname,pSYSID);
    }
  }
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Split_Name **********************************/
/*********************************************************************
 * Procedure Name: XREF_Set_Command_SYSID
 *********************************************************************
 * Description   : Return relevant SYSID
 * Input         : pCommand  - LIST
 *               : pXREFname - full XREF name
 * Output        : pSYSID    - SYSID parameter for the ACF2 command
 * Return Value  : ESA_OK    -
 *                 ESA_FATAL - Missing parameter
 ********************************************************************/
ESA_RC XREF_Set_Command_SYSID(
              char                     * pCommand,
              char                     * pXREFname,
              char                     * pSYSID,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Set_Command_SYSID";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[256];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  ACF2_PARAMS_rec_typ       * params_ptr = NULL;
  int                         isSYSID = FALSE;           /* WS10079 */
  char                        lXREFname[9] = NULL_STRING;
  char                        lSYSID[9] = NULL_STRING;
  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if((pCommand EQ NULL) OR (pXREFname EQ NULL) OR (pSYSID EQ NULL)) {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s %s %s is a missing parameter",
          (pCommand NE NULL ?  "" : "Command-1st parm"),
          (pXREFname NE NULL ? "" : "XREF name-2nd parm"),
          (pSYSID    NE NULL ? "" : "SYSID-3rd parm"));
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  /* split XREFname to lXREFname & lSYSID */
  params_ptr = admin_params->apiinit_handle;
  rc = XREF_Split_Name(pXREFname, /*full XREF name*/
                       lXREFname, /*2 b set be routine*/
                       lSYSID,    /*2 b set be routine*/
                       comp,
                       admin_params);
  ESA_DIAG_printf(comp,6,"Full XREFname<%s> split XREF<%s> SYSID<%s>",
    pXREFname,lXREFname,lSYSID);
  if (strlen(lSYSID) GT 0) isSYSID = TRUE;               /* WS10079T */
  if((rc EQ ESA_OK) AND (isSYSID) AND                    /* WS10079T */
     (params_ptr->XREF_SYSID_SCOPE[0] NE 'a')) {
      sprintf(errmsg,
        "SYSID_SCOPE is not ALL_SYSTEMS but SYSID unexpectedly is in "
        "XREF name <%s>. If SYSID_SCOPE has been ALL_SYSTEMS but "
        "changed, Account or Group Aggregation may solve the problem.",
        pXREFname);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
      rc = ESA_FATAL;
      goto exit;
  }
  if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'a') {/*ALL_SYSTEMS*/
    if(isSYSID)   /*SYSID in XREFname*/
      sprintf(pSYSID,"%s(%s)","SYSID",lSYSID);
    else if(strcmp(pCommand,"LIST") EQ 0)
      strcpy(pSYSID,"MSYSID(-)");
    else {
      sprintf(errmsg,
      "Bad combination of parameters: cmd<%s> XREF<%s> sysid_scope<%s>",
      pCommand,pXREFname,params_ptr->XREF_SYSID_SCOPE[0]);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
      rc = ESA_FATAL;
      goto exit;
    }
    rc = ESA_OK;                                      /* WS10079N */
  } /* end of ALL_SYSTEMS */
  else  /* scope is either c or sysid */                  /* WS10079N */
  {                                                       /* WS10079N */
    rc = ESA_OK;                                      /* WS10079T */
    if(params_ptr->XREF_SYSID_SCOPE[0] EQ 'c')  /*CURRENT_SYSTEM*/
      pSYSID[0] = NULL_CHAR;
    else   /* A specific SYSID value is set in XREF_SYSID_SCOPE */
      sprintf(pSYSID,"SYSID(%s)",params_ptr->XREF_SYSID_SCOPE);
  }                                                       /* WS10079N */

  ESA_DIAG_printf(comp,6,"SYSID set for command is:<%s>",pSYSID);
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Set_Command_SYSID *******************************/
/********************** WS10079A end   ******************************/

/********************** WS10079A start ******************************
 *
 *                    XREF block extension routines.
 *
 ********************************************************************/

/*********************************************************************
 * Procedure Name: XREF_Block_InsertSYSID
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Insert to
 *                 insert SYSID to the PB for the UID/XREF entry which
 *                 is passed as first parameter.
 * Input         : SYSID - SYSID to set in the block. Mandatory
 *                 ActiveYN - active ind. to set in block. Mandatory
 *                 xref_rec - address of record - optional
 *                 updActYN - whether to deactivate current active entry
 * Output        :
 *
 * Return Value  : ESA_OK    - SYSID is added
 *                 ESA_SKIP  - SYSID exists already
 *                 ESA_FATAL - Missing parameter
 *
 ********************************************************************/
ESA_RC XREF_Block_InsertSYSID(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address, /*PBheader*/
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_InsertSYSID";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[80];
  XB_SYSID_entry_rec_typ    * curSYSID;
  PERM_BLK_HDR_rec_typ      * PBheader  = NULL;
  XB_PB_SYSID_rtnparms_rec_typ * rtnparms;
  XB_InsertSYSID_parms_typ     * rtnSysInsParms = NULL;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  PBheader = (PERM_BLK_HDR_rec_typ *) blk_address;
  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  if((PBheader->ext_block_routines EQ NULL) OR
     (PBheader->ext_block_routines->p_rtnparms EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader->ext_block_routines EQ NULL) ?
        "ext_block_routines":"p_rtnparms") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  rtnparms=(XB_PB_SYSID_rtnparms_rec_typ *)
           PBheader->ext_block_routines->p_rtnparms;
  /* WS10079
  rtnSysInsParms = rtnparms->insert_parms;
  if(rtnSysInsParms->SYSID EQ NULL) {
  */
  rtnSysInsParms = &rtnparms->insert_parms;
  if(rtnSysInsParms->SYSID EQ NULL) {
    rc = ESA_FATAL;
    sprintf(errmsg, "SYSID can not be NULL");
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  if(UID->P_SYSID EQ NULL) { /*no SYSID yet in UID/XREF entry*/
    UID->P_SYSID=(XB_SYSID_entry_rec_typ *)
                 calloc(1,sizeof(XB_SYSID_entry_rec_typ));
     if (UID->P_SYSID EQ NULL)
     {
        CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
          "UID->P_SYSID", sizeof(XB_SYSID_entry_rec_typ));
        rc = ESA_FATAL;
        goto exit;
     };
    strcpy(UID->P_SYSID->SYSID,rtnSysInsParms->SYSID);
    UID->P_SYSID->ActiveYN = rtnSysInsParms->ActiveYN;
    UID->P_SYSID->next_sysid = NULL;
    UID->P_SYSID->eyec = 'Y';
    /*UID->P_SYSID->ActiveYN = 'N';
    if(rtnSysInsParms->ActiveYN EQ 'Y') UID->P_SYSID->ActiveYN = 'Y';*/
    UID->num_of_sysids++;
    UID->P_SYSID->xref_rec = rtnSysInsParms->xref_rec;
    ESA_DIAG_printf(comp, 6,
                  "SYSID (%s) added to XREF (%s), active = %c",
                  UID->P_SYSID->SYSID,UID->XREFname,
                  UID->P_SYSID->ActiveYN);
  } else /*UID->P_SYSID NE NULL*/
  {
    curSYSID = UID->P_SYSID; /* -> XB_SYSID_entrec_typ */
    while(curSYSID NE NULL) {
    if(strcmp(rtnSysInsParms->SYSID,curSYSID->SYSID) EQ 0) {
      ESA_DIAG_printf(comp, 6,
                  "SYSID(%s) already exists in XREF(%s)",
                  rtnSysInsParms->SYSID,UID->XREFname);
      sprintf(errmsg, "SYSID(%s) already exists in XREF(%s)",
              rtnSysInsParms->SYSID,UID->XREFname);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
      rc = ESA_SKIP;
      goto exit;
    } else { /*SYSID is not found*/
    if((rtnSysInsParms->ActiveYN EQ 'Y') AND
       (rtnSysInsParms->updActYN EQ 'Y') AND
       (curSYSID->ActiveYN EQ 'Y')) {
      curSYSID->ActiveYN = 'N';
      ESA_DIAG_printf(comp, 6,
                  "Drop active indication from SYSID(%s) ",
                  curSYSID->SYSID);
      }
      if(curSYSID->next_sysid EQ NULL) {
        ESA_DIAG_printf(comp, 6, "Last SYSID is found");
        curSYSID->next_sysid = (XB_SYSID_entry_rec_typ *)
                  calloc(1,sizeof(XB_SYSID_entry_rec_typ));
        if (curSYSID->next_sysid EQ NULL)
        {
           CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
             "curSYSID->next_sysid",sizeof(XB_SYSID_entry_rec_typ));
           rc = ESA_FATAL;
           goto exit;
        };
        strcpy(curSYSID->next_sysid->SYSID,rtnSysInsParms->SYSID);
        curSYSID->next_sysid->ActiveYN = rtnSysInsParms->ActiveYN;
        curSYSID->next_sysid->next_sysid = NULL;
        curSYSID->next_sysid->eyec = 'Y';
      /*curSYSID->next_sysid->ActiveYN = 'N';
        if(rtnSysInsParms->ActiveYN EQ 'Y')
           curSYSID->next_sysid->ActiveYN = 'Y';*/
        UID->num_of_sysids++;
        curSYSID->next_sysid->xref_rec = rtnSysInsParms->xref_rec;
        ESA_DIAG_printf(comp, 6,"SYSID (%s) added to XREF (%s)",
                        UID->P_SYSID->SYSID,UID->XREFname);
        rc = ESA_OK;
        goto exit;
      }
      curSYSID = curSYSID->next_sysid;
    } /* else */
  } /* while(curSYSID NE NULL) */
  } /* end of else ... UID->P_SYSID NE NULL*/

  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}

/*** end of XREF_Block_InsertSYSID **********************************/
/*********************************************************************
 * Procedure Name: XREF_Block_UpdateSYSID
 *********************************************************************
 * Description   : Update SYSID with active ind. passed as 3rd parm
 * Input         : UID
 *                 SYSID    -
 *                 active   - active indication 2 update SYSID
 * Output        :
 * Return Value  : ESA_OK    - SYSID is added
 *                 ESA_FATAL - Missing parameter
 ********************************************************************/
ESA_RC XREF_Block_UpdateSYSID(
              PERM_BLK_UID_rec_typ     * pUID,
              XB_SYSID_entry_rec_typ   * pSYSID,
              char                       pACTIVE,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_UpdateSYSID";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[80] = NULL_STRING;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  if((pSYSID EQ NULL) OR (pSYSID->eyec NE 'Y'))
  {
    rc = ESA_FATAL;
    if(pUID NE NULL) sprintf(errmsg,"For XREF(%s)",pUID->XREFname);
    strcat(errmsg, "SYSID is NULL or not a real SYSID");
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  pSYSID->ActiveYN = pACTIVE;
  ESA_DIAG_printf(comp, 6,"SYSID (%s) is updated with active=(%c)",
    "For XREF<%s> SYSID<%s> is updated with active=<%c>",
    pUID->XREFname,pSYSID->SYSID,pSYSID->ActiveYN);
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}

/*** end of XREF_Block_UpdateSYSID **********************************/
/*********************************************************************
/*********************************************************************
 * Procedure Name: XREF_Block_InsertRec
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Insert to
 *                 insert XREFRec to the PB for the UID/XREF entry which
 *                 is passed as first parameter.
 * Input         : xref_rec - address of record - optional
 * Output        :
 *
 * Return Value  : ESA_OK    - SYSID is added
 *                 ESA_SKIP  - SYSID exists already
 *                 ESA_FATAL - Missing parameter
 ********************************************************************/
ESA_RC XREF_Block_InsertRec(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address, /*PBheader*/
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_InsertRec";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[80];
  PERM_BLK_HDR_rec_typ     * PBheader  = NULL;
  XB_PB_onlyrec_rtnparms_rec_typ * rtnparms;
  XB_InsertRec_parms_typ     * rtnRecInsParms = NULL;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  PBheader = (PERM_BLK_HDR_rec_typ *) blk_address;
  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  if((PBheader->ext_block_routines EQ NULL) OR
     (PBheader->ext_block_routines->p_rtnparms EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader->ext_block_routines EQ NULL) ?
        "ext_block_routines":"p_rtnparms") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  rtnparms=(XB_PB_onlyrec_rtnparms_rec_typ *)
           PBheader->ext_block_routines->p_rtnparms;
  /* WS10079
  rtnRecInsParms = rtnparms->insert_parms;
  if(rtnRecInsParms->xref_rec EQ NULL) {
  */
  rtnRecInsParms = &rtnparms->insert_parms;
  if(rtnRecInsParms->xref_rec EQ NULL) {
    rc = ESA_FATAL;
    strcpy(errmsg, "xref_rec can not be NULL");
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  /****************************************************************
   * The following pointer assignment is all this routine does... *
   ****************************************************************/
  UID->p_rec = rtnRecInsParms->xref_rec;
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_InsertRec ******************/
/********************** WS10079A start ******************************/
/*********************************************************************
 * Procedure Name: XREF_Block_GetSYSID
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Get to
 *                 get SYSID of UID/XREF entry which is passed as
 *                 first parameter.
 * Input         : function -
 * Output        :
 *
 * Return Value  : ESA_OK    - SYSID is added
 *                 ESA_SKIP  - SYSID exists already
 *                 ESA_FATAL - Missing parameter
 *
 ********************************************************************/
ESA_RC XREF_Block_GetSYSID(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address, /*PBheader*/
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
#define  $RETURN_SYSID /*SYSID found==>return all requested out vars*/ \
       if(rtnSysGetParms->out_SYSID NE NULL)                           \
         strcpy(rtnSysGetParms->out_SYSID,curSYSID->SYSID);            \
       if(rtnSysGetParms->out_SYSID_ent NE NULL)                       \
         *rtnSysGetParms->out_SYSID_ent = curSYSID;                    \
       if(rtnSysGetParms->out_ActiveYN NE NULL)                        \
         *rtnSysGetParms->out_ActiveYN = curSYSID->ActiveYN;           \
       if(rtnSysGetParms->out_num_of_SYSIDs NE NULL)                   \
         *rtnSysGetParms->out_num_of_SYSIDs=UID->num_of_sysids;        \
       if(rtnSysGetParms->out_xref_rec NE NULL)                        \
         *rtnSysGetParms->out_xref_rec = curSYSID->xref_rec;           \
       SYSID_PBhandle->curSYSIDinBlk = curSYSID;                       \
       if(curSYSID->next_sysid EQ NULL) {                              \
         SYSID_PBhandle->sysidEOF = TRUE;                              \
         ESA_DIAG_printf(comp,6,"Last SYSID in chain of XREF(%s)",     \
                         UID->XREFname);                               \
       }                                                               \
       rc = ESA_OK;
  static char                 func[] = "XREF_Block_GetSYSID";
  ESA_RC                      rc = ESA_OK;
  char                        errmsg[80];
  XB_SYSID_entry_rec_typ    * curSYSID;
  PBhandle_typ             * PBhandle  = NULL;
  XB_PB_SYSID_rtnparms_rec_typ * rtnparms;
  XB_GetSYSID_parms_typ     * rtnSysGetParms = NULL;
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  char                        nullVar[80] = "";
  XB_SYSID_PBhandle_rec_typ * SYSID_PBhandle;
  int                         pbhandle_ok = FALSE;      /*WS10079T*/
  int                         xbhandle_ok = FALSE;      /*WS10079T*/
  XBhandle_rec_typ         *  xbhandle    = NULL;       /*WS10079T*/

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;
  PBhandle = (PBhandle_typ *) blk_address;

  /***************************************
   * Veirfy no mandatory pointer is NULL *
   ***************************************/
  /*  WS10079T start */
  if(PBhandle EQ NULL) strcpy(nullVar,"PBhandle");
  else
  {
    pbhandle_ok = TRUE;
    if(PBhandle->PBptr EQ NULL) strcpy(nullVar,"PBhandle->PBptr");
    else if(PBhandle->PBptr->ext_block_routines EQ NULL)
          strcpy(nullVar,"PBhandle->PBptr->ext_block_routines");
    else if(PBhandle->PBptr->ext_block_routines->p_rtnparms EQ NULL)
      strcpy(nullVar,"PBhandle->PBptr->ext_block_routines->p_rtnparms");
    else
    {
      rtnparms = (XB_PB_SYSID_rtnparms_rec_typ *)
              PBhandle->PBptr->ext_block_routines->p_rtnparms;
      if(rtnparms->p_XBhandle EQ NULL) strcpy(nullVar,"XBhandle");
      else
      {
       xbhandle = rtnparms->p_XBhandle;
       xbhandle_ok = TRUE;
       if(UID EQ NULL) strcpy(nullVar,"UID");
       else if(UID->P_SYSID EQ NULL) strcpy(nullVar,"UID->P_SYSID");
      }
    }
  }

  if(nullVar[0] NE NULL_CHAR)
  {
    rc = ESA_FATAL;
    if(xbhandle_ok) xbhandle->XB_err = TRUE;
    else if(pbhandle_ok) PBhandle->PBErr = TRUE;
    sprintf(errmsg, "%s can not be NULL", nullVar);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  SYSID_PBhandle = (XB_SYSID_PBhandle_rec_typ *)
                    PBhandle->handle_extension;
  /*  WS10079T end  */

  /*  WS10079T start
  if(PBhandle EQ NULL) strcpy(nullVar,"PBhandle");
  else if(UID EQ NULL) strcpy(nullVar,"UID");
  else if(UID->P_SYSID EQ NULL) strcpy(nullVar,"UID->P_SYSID");
  else if(PBhandle->PBptr EQ NULL) strcpy(nullVar,"PBhandle->PBptr");
  else if(PBhandle->PBptr->ext_block_routines EQ NULL)
          strcpy(nullVar,"PBhandle->PBptr->ext_block_routines");
  else if(PBhandle->PBptr->ext_block_routines->p_rtnparms EQ NULL)
      strcpy(nullVar,"PBhandle->PBptr->ext_block_routines->p_rtnparms");
  if(strcmp(nullVar,NULL_STRING) NE 0) {
    rc = ESA_FATAL;
    PBhandle->PBErr = TRUE;
    sprintf(errmsg, "%s can not be NULL", nullVar);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }

  SYSID_PBhandle = (XB_SYSID_PBhandle_rec_typ *)
                    PBhandle->handle_extension;
  rtnparms = (XB_PB_SYSID_rtnparms_rec_typ *)
              PBhandle->PBptr->ext_block_routines->p_rtnparms;
     WS10079T end  */

  /* WS10079N
  rtnSysGetParms = rtnparms->get_parms;
  */
  rtnSysGetParms = &rtnparms->get_parms;

  /******************************* n
   * Verify valid Function value *
   *******************************/
  if((strcmp(rtnSysGetParms->Function,"UIDTHIS") NE 0) AND
     (strcmp(rtnSysGetParms->Function,"UIDNEXT") NE 0) AND
     (strcmp(rtnSysGetParms->Function,"SYSIDNXT") NE 0)) {
    rc = ESA_FATAL;
    PBhandle->PBErr = TRUE;
    sprintf(errmsg, "Function must be:UIDTHIS or UIDNEXT or SYSIDNXT");
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  /*************************************
   * Mutual code for UIDTHIS & UIDNEXT *
   *************************************/
  if((strcmp(rtnSysGetParms->Function,"UIDTHIS") EQ 0) OR
     (strcmp(rtnSysGetParms->Function,"UIDNEXT") EQ 0)) {
    SYSID_PBhandle->curSYSIDinBlk = NULL;
    SYSID_PBhandle->sysidEOF = FALSE;
    SYSID_PBhandle->currXREF = UID;
  /***********
   * UIDTHIS *
   ***********/
    if(strcmp(rtnSysGetParms->Function,"UIDTHIS") EQ 0) {
    /*****************************************************************
     * if in_SYSID passed, search this SYSID and return its details. *
     *****************************************************************/
      if(rtnSysGetParms->in_SYSID NE NULL) {
        ESA_DIAG_printf(comp, 6, "UIDTHIS search SYSID(%s) of XREF(%s)",
          rtnSysGetParms->in_SYSID,UID->XREFname);
        curSYSID = UID->P_SYSID;
        /***********************************
         * Search in_SYSID in UID's SYSIDs *
         ***********************************/
        while(curSYSID NE NULL) {
          if(strcmp(rtnSysGetParms->in_SYSID,curSYSID->SYSID) EQ 0) {
            ESA_DIAG_printf(comp, 6, "SYSID found");
            if((rtnSysGetParms->in_Active EQ 'Y') AND
              (curSYSID->ActiveYN NE 'Y')) {
              rc = ESA_KEY_NOT_FOUND;
              ESA_DIAG_printf(comp,6,
                "SYSID found is not active, set ESA_KEY_NOT_FOUND");
              break;
            }
            else { /* SYSID found so return all requested out vars */
              $RETURN_SYSID
              break;
          }
        }
        curSYSID = curSYSID->next_sysid;
      } /* end of while(curSYSID NE NULL) */
      if(curSYSID EQ NULL) { /* After the while-SYSID not found */
        rc = ESA_KEY_NOT_FOUND;
        ESA_DIAG_printf(comp, 6, "SYSID not found");
      }
    } else { /* rtnSysGetParms->in_SYSID EQ NULL */
       /***********************************************************
        * in_SYSID not passed, so if in_active='Y' search for the *
        * active SYSID in UID.                                    *
        ***********************************************************/
        ESA_DIAG_printf(comp, 6, "UIDTHIS but no SYSID is specified.");
        if(rtnSysGetParms->in_Active EQ 'Y') {
          curSYSID = UID->P_SYSID;
          /* in a loop */
          while(curSYSID NE NULL) {
            if(curSYSID->ActiveYN EQ 'Y') { /*SYSID found*/
               ESA_DIAG_printf(comp,6,"Active SYSID(%s) found",
                              curSYSID->SYSID);
              $RETURN_SYSID
              break;
            }
            curSYSID = curSYSID->next_sysid;
          } /*end of while */
          if(curSYSID EQ NULL) { /*no SYSID with active is found*/
            rc = ESA_KEY_NOT_FOUND;
            ESA_DIAG_printf(comp, 6,
              "No in_SYSID and no active SYSID. No SYSID to return.");
          }
        } else {/* end if(rtnSysGetParms->in_Active EQ 'Y') */
            rc = ESA_KEY_NOT_FOUND;
            ESA_DIAG_printf(comp, 6,
              "No in_SYSID and in_active='N'. No SYSID to return.");
          }
      } /* end else rtnSysGetParms->in_SYSID EQ NULL) */
    } else {         /* UIDNEXT is passed in Function */
     /***********
      * UIDNEXT *
      ***********/
      curSYSID = UID->P_SYSID;
      ESA_DIAG_printf(comp, 6, "UIDNEXT rtrn first SYSID of XREF(%s)",
        UID->XREFname);
      $RETURN_SYSID
      goto exit;
    } /*end else which is end of UIDNEXT */
  } /*end if(UIDTHIS or UIDNEXT */
  else  {
     /************
      * SYSIDNXT *
      ************/
    if(SYSID_PBhandle->currXREF NE UID) {
      rc = ESA_FATAL;
      PBhandle->PBErr = TRUE;
      sprintf(errmsg,"SYSIDNXT:UID(%p) should be like currXREF(%p)",
              UID,SYSID_PBhandle->currXREF);
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
          func, errmsg , rc, __LINE__);
      goto exit;
    } else { /* SYSID_PBhandle->currXREF EQ UID */
      curSYSID = SYSID_PBhandle->curSYSIDinBlk;
      if(curSYSID EQ NULL) {
        sprintf(errmsg, "curSYSIDinBlk should not be NULL. XREF(%s)",
                UID->XREFname);
        CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
            func, errmsg , rc, __LINE__);
        rc = ESA_FATAL;
        PBhandle->PBErr = TRUE;
        goto exit;
      }
      else {
        if(curSYSID->next_sysid EQ NULL) {
          ESA_DIAG_printf(comp,6,"no more SYSIDs in chain. Set rc=EOF");
          rc = ESA_EOF;
          goto exit;
        }
        else { /*curSYSID->next_sysid NE NULL)*/
          ESA_DIAG_printf(comp,6,"SYSIDNXT return SYSID of XREF(%s)",
            UID->XREFname);
          curSYSID = curSYSID->next_sysid;
          $RETURN_SYSID
          goto exit;
          }
        }
      } /* end else SYSID_PBhandle->currXREF EQ UID */
    } /* end if(SYSIDNXT) */
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_GetSYSID ******************/

/*********************************************************************
 * Procedure Name: XREF_Block_GetRec
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Get to
 *                 get xref_rec of XREF entry which is passed as
 *                 first parameter (UID).
 * Input         : function - UIDTHIS / UIDNEXT
 * Output        : UID->p_rec set in
 *
 * Return Value  : ESA_OK    - no error in input parameters
 *                 ESA_FATAL - missing parameter
 *
 ********************************************************************/
ESA_RC XREF_Block_GetRec(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address, /*PBhandle*/
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                      func[] = "XREF_Block_GetRec";
  ESA_RC                           rc = ESA_OK;
  char                             errmsg[80];
  PBhandle_typ                   * PBhandle  = NULL;
  XB_PB_onlyrec_rtnparms_rec_typ * rtnparms;
  XB_GetRec_parms_typ            * rtnRecGetParms = NULL;
  CTSAMSG_HANDLE_rec_ptr           msgs;
  CTSAMSG_DEST_TABLE_rec_ptr       dest;
  char                             nullVar[80] = "";
  int                              pbhandle_ok = FALSE; /*WS10079T*/
  int                              xbhandle_ok = FALSE; /*WS10079T*/
  XBhandle_rec_typ               * xbhandle    = NULL;  /*WS10079T*/

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;
  PBhandle = (PBhandle_typ *) blk_address;

  /***************************************
   * Veirfy no mandatory pointer is NULL *
   ***************************************/
  /*  WS10079T start  */
  if(PBhandle EQ NULL) strcpy(nullVar,"PBhandle");
  else
  {
    pbhandle_ok = TRUE;
    if(PBhandle->PBptr EQ NULL) strcpy(nullVar,"PBhandle->PBptr");
    else if(PBhandle->PBptr->ext_block_routines EQ NULL)
          strcpy(nullVar,"PBhandle->PBptr->ext_block_routines");
    else if(PBhandle->PBptr->ext_block_routines->p_rtnparms EQ NULL)
      strcpy(nullVar,"PBhandle->PBptr->ext_block_routines->p_rtnparms");
    else
    {
      rtnparms=(XB_PB_onlyrec_rtnparms_rec_typ *)
           PBhandle->PBptr->ext_block_routines->p_rtnparms;
      if(rtnparms->p_XBhandle EQ NULL) strcpy(nullVar,"XBhandle");
      else
      {
       xbhandle = rtnparms->p_XBhandle;
       xbhandle_ok = TRUE;
       if(UID EQ NULL) strcpy(nullVar,"UID");
       else if(UID->p_rec EQ NULL) strcpy(nullVar,"UID->p_rec");
      }
    }
  }

  if(nullVar[0] NE NULL_CHAR)
  {
    rc = ESA_FATAL;
    if(xbhandle_ok) xbhandle->XB_err = TRUE;
    else if(pbhandle_ok) PBhandle->PBErr = TRUE;
    sprintf(errmsg, "%s can not be NULL", nullVar);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  /*  WS10079T end  */

  /*  WS10079T start
  if(PBhandle EQ NULL) strcpy(nullVar,"PBhandle");
  else if(UID EQ NULL) strcpy(nullVar,"UID");
  else if(UID->p_rec EQ NULL) strcpy(nullVar,"UID->p_rec");
  else if(PBhandle->PBptr EQ NULL) strcpy(nullVar,"PBhandle->PBptr");
  else if(PBhandle->PBptr->ext_block_routines EQ NULL)
          strcpy(nullVar,"PBhandle->PBptr->ext_block_routines");
  else if(PBhandle->PBptr->ext_block_routines->p_rtnparms EQ NULL)
      strcpy(nullVar,"PBhandle->PBptr->ext_block_routines->p_rtnparms");
  if(strcmp(nullVar,NULL_STRING) NE 0) {
    rc = ESA_FATAL;
    PBhandle->PBErr = TRUE;
    sprintf(errmsg, "%s can not be NULL", nullVar);
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  rtnparms=(XB_PB_onlyrec_rtnparms_rec_typ *)
           PBhandle->PBptr->ext_block_routines->p_rtnparms;
     WS10079T  end  */

  /* WS10079N
  rtnRecGetParms = rtnparms->get_parms;
  */
  rtnRecGetParms = &rtnparms->get_parms;
  /*******************************
   * Verify valid Function value *
   *******************************/
  if((strcmp(rtnRecGetParms->Function,"UIDTHIS") NE 0) AND
     (strcmp(rtnRecGetParms->Function,"UIDNEXT") NE 0)) {
    rc = ESA_FATAL;
    PBhandle->PBErr = TRUE;
    sprintf(errmsg, "Function must be:UIDTHIS or UIDNEXT ");
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  /*************************************************************
   * Following conditional assignment is all this routine does *
   *************************************************************/
  if(rtnRecGetParms->out_xref_rec NE NULL)
     *rtnRecGetParms->out_xref_rec = UID->p_rec;
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_GetRec ******************/

/*********************************************************************
 * Procedure Name: XREF_Block_FreeSYSID
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Free to
 *                 free all SYSIDs of XREF entry which is passed as
 *                 first parameter.
 * Input         :
 * Output        :
 * Return Value  : ESA_OK    - SYSIDs of UID/XREF entry are freed
 *                 ESA_FATAL - Missing parameters/pointers
 ********************************************************************/
ESA_RC XREF_Block_FreeSYSID(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address,
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_FreeSYSID";
  ESA_RC                      rc = ESA_OK;
  XB_SYSID_entry_rec_typ    * curSYSID;
  PERM_BLK_HDR_rec_typ      * PBheader  = NULL;
  char                        errmsg[80];
  XB_SYSID_entry_rec_typ    * nextSYSID;
  /*XB_SYSID_entry_rec_typ    * sysidToFree[50]; /* max 50 */
  /*char                      * xrefRecToFree[50]; */
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;
  int                         i,j = 0;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  PBheader = (PERM_BLK_HDR_rec_typ *) blk_address;
  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  curSYSID = UID->P_SYSID; /* -> XB_SYSID_entry_rec_typ */
  if(curSYSID EQ NULL) {
    sprintf(errmsg,"XREF(%s) has no SYSIDs",UID->XREFname);
    CTSAMSG_print(WARN_INT1, msgs, NULL, dest, component,func,
                  errmsg,4,__LINE__);
    /*ESA_DIAG_printf(comp, 6,
    "XREF(%s) has no SYSIDs",UID->XREFname); */
  }
  else {
    ESA_DIAG_printf(comp, 6,
    "Free all SYSIDs of XREF(%s)",UID->XREFname);
    nextSYSID = curSYSID->next_sysid;
    while(curSYSID NE NULL) {
      if(curSYSID->xref_rec NE NULL) {
        ESA_DIAG_printf(comp, 6,
          "Free XREF record at (%x)",curSYSID->xref_rec);
        free(curSYSID->xref_rec);
      }
      ESA_DIAG_printf(comp, 6, "Free SYSID at (%x)",curSYSID);
      free(curSYSID);
      curSYSID = nextSYSID;
      nextSYSID = curSYSID->next_sysid;
    } /*end while */
  /*for (i = 0;curSYSID NE NULL,i<50;i++) {
      sysidToFree[i] = curSYSID;
      xrefRecToFree[i] = curSYSID->xref_rec;
      curSYSID = curSYSID->next_sysid;
    }  * while(curSYSID NE NULL) *
    curSYSID = UID->P_SYSID;  * -> XB_SYSID_entry_rec_typ *
    for (j=i;j>0;j--) {
      if(xrefRecToFree[j] NE NULL) {
        ESA_DIAG_printf(comp, 6,
          "Free XREF record at (%x)",xrefRecToFree[j]);
        free(xrefRecToFree[j]);
      }
      if(sysidToFree[j] NE NULL) {
        free(sysidToFree[j]);
        ESA_DIAG_printf(comp, 6,
          "Free XREF record at (%x)",xrefRecToFree[j]);
        free(xrefRecToFree[j]);
      }
    }  *for ends*/
  } /*else ends*/
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_FreeSYSID ***   WS10079A end **************/

/*********************************************************************
 * Procedure Name: XREF_Block_FreeRec
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Free to
 *                 free xref_rec of XREF entry which is passed as
 *                 first parameter.
 * Input         :
 * Output        :
 * Return Value  : ESA_OK    - SYSIDs of UID/XREF entry are freed
 *                 ESA_FATAL - Missing parameters/pointers
 ********************************************************************/
ESA_RC XREF_Block_FreeRec(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address,
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_FreeRec";
  ESA_RC                      rc = ESA_OK;
  PERM_BLK_HDR_rec_typ      * PBheader  = NULL;
  char                        errmsg[80];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  PBheader = (PERM_BLK_HDR_rec_typ *) blk_address;
  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  if(UID->p_rec EQ NULL)
    ESA_DIAG_printf(comp, 6,
    "XREF(%s) has no xref_rec",UID->XREFname);
  else {
    ESA_DIAG_printf(comp, 6, "Free XREF record of XREF(%s) at (%p)",
                    UID->XREFname,UID->p_rec);
    free(UID->p_rec);
  }
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_FreeRec ****************/

/*********************************************************************
 * Procedure Name: XREF_Block_PrintSYSID
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Print to
 *                 print all SYSIDs of XREF entry which is passed as
 *                 first parameter.
 * Input         :
 * Output        :
 * Return Value  : ESA_OK    - SYSIDs of UID/XREF entry are printed
 *                 ESA_FATAL - Missing parameters/pointers
 ********************************************************************/
ESA_RC XREF_Block_PrintSYSID(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address,
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_PrintSYSID";
  ESA_RC                      rc = ESA_OK;
  XB_SYSID_entry_rec_typ    * curSYSID;
  PERM_BLK_HDR_rec_typ      * PBheader  = NULL;
  char                        errmsg[80];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  PBheader = (PERM_BLK_HDR_rec_typ *) blk_address;
  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
    curSYSID = UID->P_SYSID; /* -> XB_SYSID_entry_rec_typ */
    if(curSYSID EQ NULL)
      ESA_DIAG_printf(comp, 0,
      "XREF(%s) has no SYSIDs",UID->XREFname);
    while(curSYSID NE NULL) {
        ESA_DIAG_printf(comp, 0,
          "For XREF(%s) current SYSID is (%s) and ActiveYN is (%c)",
          UID->XREFname,curSYSID->SYSID, curSYSID->ActiveYN);
        if(curSYSID->xref_rec NE NULL)
          ESA_DIAG_printf(comp,0,"For XREF(%s) xref_rec is (%.200s)",
                          UID->XREFname,curSYSID->xref_rec);
        curSYSID = curSYSID->next_sysid;
    } /* while(curSYSID NE NULL) */

  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_PrintSYSID *****************/

/*********************************************************************
 * Procedure Name: XREF_Block_PrintRec
 *********************************************************************
 * Description   : Extension routine of Permissions_block_Print to
 *                 print xref_rec of XREF entry which is passed as
 *                 first parameter.
 * Input         :
 * Output        :
 * Return Value  : ESA_OK    - SYSIDs of UID/XREF entry are printed
 *                 ESA_FATAL - Missing parameters/pointers
 ********************************************************************/
ESA_RC XREF_Block_PrintRec(
            PERM_BLK_UID_rec_typ     * UID,
            void                     * blk_address,
            ESA_DIAG_COMP_typ          comp,
            ADMIN_PARAMS_rec_typ     * admin_params)
{
  static char                 func[] = "XREF_Block_PrintRec";
  ESA_RC                      rc = ESA_OK;
  PERM_BLK_HDR_rec_typ      * PBheader  = NULL;
  char                        errmsg[80];
  CTSAMSG_HANDLE_rec_ptr      msgs;
  CTSAMSG_DEST_TABLE_rec_ptr  dest;

  ESA_DIAG_enter(comp, 2, func);

  msgs = admin_params->ctsamsg_handle;
  dest = admin_params->ctsamsg_dest;

  PBheader = (PERM_BLK_HDR_rec_typ *) blk_address;
  if((PBheader EQ NULL) OR (UID EQ NULL))
  {
    rc = ESA_FATAL;
    sprintf(errmsg, "%s can not be NULL",
        ((PBheader EQ NULL) ? "PBheader" : "UID") );
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest, component,
        func, errmsg , rc, __LINE__);
    goto exit;
  }
  if(UID->p_rec EQ NULL)
    ESA_DIAG_printf(comp, 0,
    "XREF(%s) has no xref_rec");
  else
    ESA_DIAG_printf(comp,0,"For XREF(%s) xref_rec is (%.200s)",
           UID->XREFname,UID->p_rec);
  exit:
  ESA_DIAG_exit(comp , 2, func, rc);
  return rc;
}
/*** end of XREF_Block_PrintRec *****************/

/*   end of xref block extension routines       */

/********************** WS10079A end       **************************/
