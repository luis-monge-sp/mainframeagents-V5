/**************************************************************
*                                                             *
* Title            : ACF2                                     *
*                                                             *
* File Name        : ctsbacf.h                                *
*                                                             *
* Author           : Yishay Yovel                             *
*                                                             *
* Creation Date    : 22/06/1997                               *
*                                                             *
* Description      :                                          *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who    When       Description                      *
* -------- ------ ---------- -------------------------------- *
* BS2306   Guy    27/10/1997 Added ACF2_MAX_GRP_UIDMASKS      *
*                            and updated some function        *
*                            prototypes                       *
* BS2307   Guy    03/11/1997 Added ACF2_MAX_LID_PARTS         *
* PS0234   Guy    13/01/1998 Added definitions for resources  *
* PS0278   Guy    15/06/1998 Added Rule_Backup                *
* WS2333   Guy    28/07/1998 Changes required for improved    *
*                            ruleset filtering routine        *
*                            + NEXTKEYs processing            *
*                            + deleted Get_Dsn_Resource       *
* WS2337   Guy    07/10/1998 Added Multi Valued Fields support*
* PS0320   Guy    22/10/1998 Deleted ACF2_CMDOUT_typ and      *
*                            ACF2_CMD_RC_typ                  *
* PS0321   Guy    25/10/1998 Changed structure of ACFFDR field*
*                            and added UIDX field             *
* PS0325   Guy    01/11/1998 Support new GSO fields+records   *
* BS2367   Guy    05/11/1998 Exits Names not nullified        *
* WS2338   Guy    10/11/1998 Support multivalued fields in    *
*                            groups processing                *
* PS0338   Guy    25/11/1998 Fix URID length                  *
* PS0339   Guy    26/11/1998 Return connections of all user   *
*                            UIDs if MULTI VALUED             *
* PS0345   Guy    02/12/1998 Add MULTIVALUE limits            *
* PS0347   Guy    03/12/1998 Determine MAXRULE usage with parm*
* PS0354   Guy    09/12/1998 Check Disconnect from Multivalued*
*                            field in Update User             *
* PS0364   Guy    24/12/1998 Remove EMULATE stuff             *
* WS2358   Guy    12/10/1999 Support for the virtual resource *
* PS0398   Guy    02/12/1999 ARI fails for qualified resrules *
* WS2370   RamiK  01/01/2002 add support for specific user    *
*                            profiles                         *
* BS2509   RamiK  03/03/2002 correct problem in online intrcptr*
* BS2513   RamiK  17/03/2002 add check of user existance      *
*                            before user profile update       *
* BS2537   AvnerL 17/07/2002 change switches to Y/N (ws2370)  *
* BS2556   AvnerL 14/10/02 send acf2 original error msg       *
* BS2593   AvnerL 07/04/03 trunc blanks from res-name         *
* BS2607   AvnerL 31/05/03 support user defined date fields   *
* IS0272   Michael 10/06/04  Update C31B libs with old fixes  *
* WS2565   Eli MY  15/10/06 ACF2 V3202: Update new password   *
*                           keywords.                         *
* IS10002  AvnerL 31/01/07 keep VERIFY_PASSWORD_BY_LOGIN value*
* IS10005  AvnerL 08/05/07 Support RU_LOCKED & RU_SUSPENDED.  *
* WS10005  AvnerL 29/05/07 Add OMVS kwds & more user profiles.*
* ws10006  AvnerL 01/08/07 Add PASSWORD user profile.         *
* WS10007  AvnerL 22/08/07 Insert calls CTSUpdPassword.       *
* BS10028  Nurity 23/02/12 Create Account fails after ugrade  *
*                          to 3.2.02.                         *
* BS10029  Nurity 12/03/12 Copy from 3.2.02 in order to       *
*                          apply BS10028.                     *
* IS10088  NuritY 03/06/13 S0C4 when UID len < 24.  (BS10030) *
* IS10119  AvnerL 17/03/14 Support ACCREL# as release source. *
* IS10122  NuritY 16/06/14 Ignore ROLESET rules.              *
* BS10126  AvnerL 28/09/14 Allow correlated UIDs for IIQ.     *
* WS10054  SeligT 26/07/16 Add ENQ/DEQ SYSTEMS RNL Parameter  *
* IS10139  SeligT 28/08/16 Update OS Functions for Agents     *
* sasc     NuritY 25/08/16 Adapt to CC changes.               *
* SAS2IBMT SeligT 17/07/16 SAS/C to IBM C Conversion Project  *
* SAS2IBMA AvnerL 17/07/16 SAS/C to IBM C Conversion Project  *
* IS10147A SeligT 18/06/17 Add support for password phrase    *
* IS10147B AvnerL 18/06/17 Set common_prm_ptr first.          *
* BS10070  SeligT 23/10/17 ABEND S0C4 during aggregation when *
*                          user not authorized                *
* BS10072  SeligT 24/10/17 Improve previous fix - allow for   *
*                          smaller message area in call to    *
*                          macro                              *
* BS10076  SeligT 11/12/17 Organize Connector Locking         *
*                          Functions and Structures           *
* WS10067  SeligT 21/01/18 Update GDB dynamically when access *
*                          or resource rules are added or     *
*                          modified                           *
* IS10174  NuritY 17/01/18 Move VERIFY_BY_LOGIN to common     *
* BS10093  SeligT 12/08/18 Add and Delete Group Functions     *
*                          Not Working After CCID BS10091     *
* BS10097  SeligT 19/11/18 ACF2 Group Aggregation Endless     *
*                          Loop                               *
* IS10178  SeligT 18/12/18 Supporting LID Anywhere in UID     *
* IS10178B SeligT 20/01/19 Permission Which Ends With a       *
*                          LID Which Ends With a Blank Will   *
*                          Be Replaced With This Character:   *
*                          rssparm_REPL_END_BLNK              *
* WS10075  SeligT 25/08/19 Manage Permissions as Account and  *
*                          Group Attributes                   *
* WS10075  KailasP 25/11/19 Add short name for methods        *
* WS10076S SeligT 22/12/19 Manage Permissions as Account and  *
*                          Group Attributes - Phase 1 part 2  *
* WS10076N NuritY 30/12/19 Manage Permissions as Account and  *
*                          Group Attributes - Phase 1 part 2  *
* WS10076A AvnerL 19/01/20 add admin_params 2 ACF2_Get_Group  *
* WS10078T ThomaS 11/03/20 Support roles                      *
* WS10078S SeligT 02/04/20 Support Roles                      *
* WS10078KG KailasP 23/04/20 Add prototype of ACF2_Cmd2Mem    *
*                          and Get_XREF_Record                *
* BS10108  NuritY 09/09/20 Remove routines that were changed  *
*                          to static and add ones changed to  *
*                          external.                          *
* BS10108T ThomaS 04/10/20 Add define INACT_BLOCK 0xFFFFFFFF  *
*                          Add perms_exist parameter to       *
*                          Get_user_permissions               *
* BS10110  NuritY 15/11/20 1. Add  ACFRPTRX_NOUIDALL_SUP      *
*                          2. role/source error.              *
* WS10079T ThomaS 12/11/20 JPMC phase 2                       *
* WS10079A AvnerL 16/12/20 JPMC phase 2                       *
* WS10079K KailaS 21/12/20 JPMC phase 2                       *
* BS10111  NuritY 16/12/20 Support ruob above the bar.        *
* WS10079N NuritY 11/01/21 JPMC phase 2                       *
* IS10184  NuritY 02/09/21 Improve scripts performance        *
* WS10084  ThomaS 13/07/23 Replace ACFRPTRX                   *
* WS10082  Kailas 02/04/24 ADDINFO                            *
* WS10090  AvnerL 29/08/24 Allow UID collision                *
**************************************************************/

#ifndef ACF2_H_included
#define ACF2_H_included

 /* sasc - not needed anymore because it is defined in GLOBS
#ifdef EXT
#undef EXT
#endif
#ifndef ACF2_owner
#define EXT extern
#else
#define EXT
#endif
*/

#include MVS_SRV                                          /* IS10139 */
#include MVS_OS_CLI                                       /* WS10076S*/

#define ACF2_get_list_count                    acf2010
#define ACF2_alloc_output_lines                acf2011
#define Global_Get_Virtual_Res                 acf2012    /* WS2358 */
#define ACF2_Get_Resource                      acf2013    /* PS0234 */
#define Trunc_UIDMASKS                         acf2014    /* PS0234 */
#define ACF2_output_to_addinfo                 acf2015
#define ACF2_get_field                         acf2016
#define Build_Ruleset                          acf2017    /* PS0234 */
#define Compile_Ruleset                        acf2018    /* PS0234 */
#define Delete_Ruleset                         acf2019    /* PS0234 */
#define ACF2_revoke_date                       acf2020
#define Build_Rule_Entry                       acf2021    /* PS0234 */
/* IS10174 #define ACF2_version_get                       acf2022   */
#define ACF2_version_check                     acf2023
#define Trunc_One_UIDMASK                      acf2024    /* PS0234 */
#define ACF2_Filter_ADDINFO                    acf2025    /* PS0234 */
#define ACF2_Convert_Access_Levels             acf2026    /* PS0234 */
#define convert_tod_to_YYYYMMDDHHMMSS          acf2027    /* PS0234 */
#define Init_ACE_Handle                        acf2028    /* PS0234 */
#define Fill_ACE_Keywords                      acf2029    /* PS0234 */
#define Prepare_ACF2IN_File                    acf2030    /* PS0234 */
#define ACES_Match                             acf2031    /* PS0234 */
#define Fill_Res_Keywords                      acf2032    /* PS0234 */
#define Is_UIDMASK_User                        acf2033    /* PS0234 */
#define Build_UIDMASK_User                     acf2034    /* PS0234 */
#define Check_ACE_UNTIL                        acf2035    /* PS0234 */
#define Is_LID_In_UID                          acf2036    /* PS0234 */
#define ACF2_Set_LID_In_UID                    acf2037    /* PS0234 */
#define ACF2_Is_LID_In_UID                     acf2038    /* PS0234 */
#define ACF2_Update_KDT                        acf2039
#define ACF2_build_KDT_from_ACFFDR             acf2040
#define ACF2_Get_User                          acf2041
#define ACF2_Set_Global_Data                   acf2042
#define Global_ACF2_Date_Format                acf2043
#define ACF2_Convert_Date_Fields               acf2044
#define ACF2_Get_GSO                           acf2045
#define ACF2_Match_Id_to_Mask                  acf2046
#define ACF2_Get_Group                         acf2047
#define Rule_Backup                            acf2048    /* PS0278 */
#define ACF2_Match_User_Group                  acf2049
#define ACF2_Get_User_UID                      acf2050
#define ACF2_Get_Next_User                     acf2051
#define ACF2_Get_UID_Info                      acf2052
#define Initialize_UID_Definitions             acf2053
#define Generate_UID_Update                    acf2054
#define GDB_Set_Mode                           acf2055
#define GDB_Insert                             acf2056
#define GDB_Delete                             acf2057
#define GDB_Update                             acf2058
#define GDB_Locate                             acf2059
#define GDB_GetNext                            acf2060
#define UID_Contains_MULTI                     acf2061    /* PS0321 */
#define Reset_Field                            acf2062
#define Convert_Multi_to_Vec                   acf2063
#define GDB_Convert_to_Record                  acf2064
#define GDB_Convert_from_Record                acf2065
#define Round_Number                           acf2066
#define ACF2_Is_Virtual_Resource               acf2067    /* WS2358 */
/* BS10076 #define Global_Total_Wait_Lock_Time acf2068              */
/* BS10076 #define Global_Retry_Wait_Lock_Time acf2069              */
/* WS10054  #define Global_Get_QNAME           acf2070              */
#define Calc_User_UID_String                   acf2071
#define Global_UDB_Active                      acf2072
#define Build_Multi_UIDs                       acf2073    /* PS0321 */
#define ACF2_Is_Part_Of_Multi                  acf2074    /* PS0345 */
#define ACF2_Automate                          acf2075    /* WS2358 */
#define Get_First_Qualifier                    acf2076    /* WS2358 */
#define Strip_First_Qualifier                  acf2077    /* WS2358 */
#define Most_Specific_Match                    acf2078    /* WS2358 */
#define Prepare_KEYs_List                      acf2079    /* WS2358 */
#define ACF2_Set_Keyword_Value                 acf2080    /* WS2358 */
#define ACF2_Get_Field_Information             acf2085
#define ACF2_Get_Group_UIDMASKS                acf2086
#define Convert_UID_Offset_to_Field_Name       acf2090
#define Check_Group_Correllation               acf2091
#define Check_User_Force_Disconnect_from_Group acf2092
#define Convert_Keyword_Chars                  acf2093
#define Get_ACFFDR_In_ESS_Format               acf2094
#define Get_UID_In_ESS_Format                  acf2095
#define Check_Group_UIDMASKS                   acf2096
#define ACF2_Refresh_User_UID                  acf2097
#define Check_Mult_Force_Disconnect_from_Group acf2098
#define UDB_Set_Mode                           acf2100
#define UDB_Insert                             acf2101
#define UDB_Delete                             acf2102
#define UDB_Update                             acf2103
#define UDB_Locate                             acf2104
#define UDB_GetNext                            acf2105
#define UDB_Get_Next_User                      acf2106    /* WS2338 */
#define Trim                                   acf2110
#define ACF2_Get_User_Groups                   acf2120    /*ws2431  */
#define ACF2_Get_specific_user_profile         acf2121    /*ws2370  */
#define ACF2_Get_all_specific_user_profiles    acf2122    /*ws2370  */
#define ACF2_UP_switch_is_activated            acf2123    /*ws2370  */
#define ACF2_UP_exists                         acf2124    /*ws2370  */
#define ACF2_Free_ACFFDR                       acf2125    /*BS2509  */
#define ACF2_User_Exists                       acf2126    /*bs2513  */
#define Trunc_Blanks                           acf2127    /*bs2593  */
/* WS10076N #define ACF2_Refresh_GDB           acf2128     *WS10067 * */
#define ACF2_Clean_GDB                         acf2129    /*WS10067K*/
#define find_groups                            acf2130    /*WS10067 */
#define GDB_Get_Mode                           acf2131    /*BS10093 */
#define GCM2str                                acf2132    /*BS10093 */
/*WS10076N #define get_line                    acf2133     *WS10075 * */
/*WS10076N #define ACF2_get_LID_rules          acf2134    /*WS10075 * */
/*WS10076N #define Get_rule_line_from_memory   acf2135     *WS10075 * */
#define Permissions_block_Build                acf2133    /* WS10076N*/
#define Permissions_block_Get                  acf2134    /* WS10076K*/
#define Get_user_permissions                   acf2136    /* WS10075 */
/* WS10076N #define Get_Rule_Record            acf2137     *WS10075 * */
#define Get_Rule_Record                        acf2137    /* WS10078T */
#define GLR_del_mods                           acf2138    /* WS10075 */
#define Permission_dsnrsrc_key_prefix_handler  acf2139    /* WS10075 */
/* BS10108 #define Get_User_XROL               acf2140     * WS10078T */
/* WS10084 #define ACF2_Get_ACFRPTRX_Report    acf2141     * WS10078T */
/* BS10108 #define Get_User_XSGP               acf2143     * WS10078T */
#define ACF2_Cmd2Mem                           acf2144    /* WS10078KG*/
/* WS10079N #define Get_XREF_Record            acf2145    /* WS10078KG*/
/* WS10079T #define XREF_Block_Find            acf2146    /* BS10108  */
#define Parse_XREF_Record                      acf2147    /* BS10108  */
#define XREF_Block_GetSYSID                    acf2148    /*WS10079A*/
#define XREF_Block_InsertSYSID                 acf2149    /*WS10079A*/
#define XREF_Block_PrintSYSID                  acf2150    /*WS10079A*/
#define XREF_Block_FreeSYSID                   acf2151    /*WS10079A*/
#define XREF_Block_GetRec                      acf2152    /*WS10079A*/
#define XREF_Block_InsertRec                   acf2153    /*WS10079A*/
#define XREF_Block_PrintRec                    acf2154    /*WS10079A*/
#define XREF_Block_FreeRec                     acf2155    /*WS10079A*/
#define XREF_Split_Name                        acf2156    /*WS10079A*/
#define XREF_Validate_name                     acf2157    /*WS10079A*/
#define XREF_Block_UpdateSYSID                 acf2158    /*WS10079A*/
#define XREF_Set_Command_SYSID                 acf2159    /*WS10079A*/
#define Permissions_Block_updateIndex          acf2160    /*WS10079A*/
#define Permissions_block_Free                 acf2161    /*WS10079A*/
#define Permissions_block_Insert               acf2162    /*WS10079T*/
#define XREF_Extract_Inc_Exc_Lists             acf2163    /*WS10079T*/
#define XREF_Commands_Create                   acf2164    /*WS10079T*/
#define XREF_Commands_Restore                  acf2165    /*WS10079T*/
#define ACF2_Get_Xref                          acf2166    /*WS10079N*/
#define XREF_Block_Build                       acf2167    /*WS10079T*/
#define Permissions_block_Print                acf2168    /*WS10079N*/
#define Drop_Perms_Match                       acf2169    /*WS10079T*/

/* WS10082K #define MAX_API_ST 4096                moved to ESAAPI  */
#define ACF2_OUTPUT_SIZE            16384  /* for user/group   */
                            /* r0003 increased to 16k from 4k  */
#define ACF2_CNN_OUTPUT_SIZE          512  /* for connection   */
                            /* r0003 increased to 512 from 500 */
#define ACF2_END_OF_KDT        '\xff'

#define ACF2_EOF            "ACF02010"
#define ACF2_NOT_FOUND      "ACF0A005"
#define ACF2_ARULE_EXISTS   "ACF03017"
#define ACF2_RRULE_EXISTS   "ACF04012"
#define ACF2_ARULE_NOT_FND  "ACF03006"
#define ACF2_RESRULE_EOF    "ACF04005"
#define ACF2_RULE_NOT_FOUND "ACF03005"

#define ACF2_RETRIEVE_OP    "RET"
#define ACF2_RET_KEY_OP     "KEY"          /* WS2358 */

#define ACF2_UID_SIZE          25
#define ACF2_LID_SIZE          9
#define ACF2_UDB_LID_SIZE      8           /* PS0338           */
#define ACF2_URID_SIZE         5           /* PS0339           */
#define ACF2_ACCRULE_KEY_SIZE  9           /* PS0234           */
#define ACF2_RESRULE_KEY_SIZE  41          /* PS0234           */
#define ACF2_MAX_LID_PARTS     24          /* BS2307           */
#define ACF2_MAX_GRP_UIDMASKS  25          /* BS2306           */
#define ACF2_FIELDNAME_SIZE    9
#define ACF2_QUALIFIER_SIZE    9           /* WS2358           */
#define ACF2_MAX_QUALIFIERS    22          /* WS2358           */
#define ACF2_VOLSER_SIZE       7           /* WS2358           */
#define ACF2_MAX_NUM_OF_RULES  5000        /* WS2358           */
#define ACF2_MAX_PERMISSN_SIZE 666         /* WS10075          */
/*                                            (133*5)+1 = 666  */
#define MAX_PERM_KEY_LEN       64      /* max current size: 40 */
                                           /* WS10076S         */
#define MAX_PERM_RESTYPE_LEN    4          /* WS10076S         */
#define MAX_PERM_PREFIX_LEN    64      /* max current size: 40 */
#define XREF_NAME_SIZE          9      /* for roles and SGP WS10078T */
                                           /* WS10076S         */


#define ACF2_SYSID_SIZE        9
#define ACF2_RECID_SIZE       41

#define ACF2_ADDINFO               512
#define ACF2_RULE_BUFFER_LENGTH  32768     /* PS0234           */
#define ACF2_RULE_SOURCE_LENGTH  128*1024  /* PS0234           */
#define ACF2_RULE_SOURCE_INC     512*1024  /* PS0234           */
#define ACF2_NEXTKEY_LIST_EXTENT 4096      /* WS2333           */
#define ACF2_ARE_BUFFER_LENGTH   32760

#define ACF2_DATE_FORMAT             "OPTS.DATE"
#define ACF2_BYPASS_DISCONNECT_CHECK "@#!BYPASS!#@"
#define ACF2_ROLESET_IGNORED_MSG  "ROLESET rule ignored"  /* IS10122 */

#define UP_SWITCH_CONST   "_SWITCH"  /* ws2370 */
#define UP_SWITCH_ON      "Y"        /* ws2370 , bs2537 */
#define UP_SWITCH_OFF     "N"        /* ws2370 , bs2537 */
#define UP_SWITCH_CONST_LEN 7        /* ws2370 */
/* * * * * * * * * * * * * * WS10067 Start * * * * * * * * * * * * * */
#define MAX_GRP_SLOTS 500

typedef char NEWGRPTABLE_typ [ACF2_UID_SIZE];

typedef struct {
  int               used_slots;                       /* used slots  */
  int               total_slots;                      /* total slots */
  NEWGRPTABLE_typ   table[1];                         /* first slot  */
  } NEW_GRP_TABLE_rec_typ, *NEW_GRP_TABLE_rec_ptr;

#define NGTBL_size(num)          \
        sizeof(NEW_GRP_TABLE_rec_typ)+((num-1)*sizeof(NEWGRPTABLE_typ))
/* * * * * * * * * * * * * * WS10067  End  * * * * * * * * * * * * * */

typedef enum {
 CHECK_COLLISION,
 CHECK_CORRELLATION
} CORRELLATION_CHECK_MODE;

typedef enum {
 FLAG_KEYWORD,
 REG_KEYWORD,
 MULTI_KEYWORD,
 LIST_KEYWORD
} ACF2_Keyword_Type;

typedef enum {
 BEFORE_KEYWORD,
 IN_KEYWORD,
 IN_VALUE
} ACF2_Automat_States_Type;

typedef enum {
   ACF2_Return_Multi_UIDs,
   ACF2_No_Multi_UIDs
} ACF2_Multi_UIDs_Mode_Type;                              /* PS0321 */

typedef enum {
   ACF2_Scan_Not_Started,
   ACF2_Scan_Found_Mask,
   ACF2_Scan_Found_Value
} ACF2_MVF_Scan_Status_Type;                              /* PS0345 */

typedef enum {
   ACF2_Return_Ruleset,
   ACF2_Return_Rule_Entries
} ACF2_Resource_Data_Type;

typedef enum {
   ACF2_Replace_Rule,
   ACF2_Dont_Replace_Rule
} ACF2_Replace_Rule_Type;

typedef enum {
   ACF2_Object_is_Masked,
   ACF2_Object_is_Not_Masked
} ACF2_Object_Mask;

typedef enum {
   ACF2_NO, ACF2_YES
} ACF2_FLAG_typ;

/* PS0320 - Deleted
typedef enum {
   CMDOUT_YES, CMDOUT_NO, CMDOUT_ERR
} ACF2_CMDOUT_typ;

typedef enum {
   MAX_OK_RC_0 = 0, MAX_OK_RC_4 = 4
} ACF2_CMD_RC_typ;
*/

typedef char ONE_KEYWORD_typ[MAX_RSS_ADDINFO_KWD_LEN+1];

typedef struct S_KEYWORDS {
  ONE_KEYWORD_typ   keyword;
  ADDINFO_typ       type;
} KEYWORDS_LIST_typ;

/* WS2358 - moved from Get_Rule_Entry_Info (CTSBRES) */
static KEYWORDS_LIST_typ access_keywords[] = {
                                              "READ",    TYPE_1A,
                                              "WRITE",   TYPE_1A,
                                              "EXEC",    TYPE_1A,
                                              "ALLOC",   TYPE_1A,
                                              "",        TYPE_1A };

/* WS2358 - list of unsupported keywords for ARI feature */
static KEYWORDS_LIST_typ unsupp_keywords[] = {
                                              "VOL",     TYPE_1A,
                                              "SOURCE",  TYPE_1A,
                                              "SHIFT",   TYPE_1A,
                                              "LIB",     TYPE_1A,
                                              "PGM",     TYPE_1A,
                                              "DDN",     TYPE_1A,
                                              "UNTIL",   TYPE_1A,
                                              "ACTIVE",  TYPE_1A,
                                              "",        TYPE_1A };

typedef struct {
  int   max_len;                            /* max  length   */
  int   used_len;                           /* used length   */
  char  buffer[ACF2_OUTPUT_SIZE];           /* output buffer */
  } ACF2_OUTPUT_LINE_rec_typ, *ACF2_OUTPUT_LINE_rec_ptr;

 /*
  *   Handle structure for Get Resource ACL processing
  *
  *   WS2333:
  *   Records_Buffer is the address of the first record which
  *   interests us inside Rule_Buffer. It is created by the
  *   Filter_Rule_Records function. Current_ACE_Offset is an
  *   offset WITHIN Records_Buffer and NOT Rule_Buffer !!!
  *   (Records_Buffer is considered as a "buffer within a buffer")
  */

 typedef struct {
   char                        *Rule_Buffer;        /* Orig. buffer  */
   int                          Rule_Buffer_Len;    /* Buffer length */
   int                          Current_ACE_Pos;    /* ACE ID(0,1,..)*/
   int                          First_Call;         /* 1st call? Y/N */
   char                        *Current_ACE_Offset; /* In filt buff! */
   char                        *Records_Buffer;     /* WS2333        */
   int                          Records_Buffer_Len; /* WS2333        */
   } ACF2_Get_ResACL_Handle;

 /*
  *   Handle structure for Get Resource processing
  */

 typedef struct {
   RESOURCE_typ                 Current_Key;
   int                          First_Call;
   char                        *Nextkeys_Chain;       /* WS2333 */
   char                        *Nextkeys_List_Ptr;    /* WS2333 */
   int                          Load_Nextkeys;        /* WS2333 */
   int                          Nextkeys_Depth;       /* WS2333 */
   int                          Num_Loaded_Nextkeys;  /* WS2333 */
   } ACF2_Get_Res_Handle;

 /* WS2358 */
 /*
  *   Structure representing one $KEY
  *   (used by Most_Specific_Match for ARI processing)
  */
 typedef struct
 {
   char   Key_Cell_Val[ACF2_RESRULE_KEY_SIZE];     /* $KEY value    */
   int    Key_Cell_Match;                          /* is matching ? */
   int    Key_Cell_Rank;                           /* match rank    */
 } ACF2_Key_Cell_Typ, *ACF2_Key_Cell_Ptr;

/* ------------------------ IS10002 ---------------------------- *
 * ACF2 USA-API Parameters                                       *
 * ------------------------------------------------------------- *
 * The following structure is initialized during CTSAPIInit call *
 * and contains static data of the USA-API such are loaded       *
 * RSSPARM information.                                          *
 *                                                               *
 * apiinit_handle is pointing to this structure.                 *
 *                                                               *
 * Note that changes in this type might require rebuilt of ALL   *
 * the USA-API  modules.                                         *
 * When adding fields, try to keep the total length 1,000 bytes. *
 * Which means if you add a 2 bytes fields, subtract 2 from ffu. *
 * ------------------------------------------------------------- *
 *    !!! Minimize changes and usage of this record !!!          *
 * ------------------------------------------------------------- */

#define  PARAMS_TYPE_ACF2   'A'   /* set in PARAMS_type in    IS10184 */
                                  /* common_params            IS10184 */
typedef  struct _ACF2_PARAMS{
  /* move "* common_params" to start of "ACF2 PARAMS".       IS10147B*/
  COMMON_PARAMS_rec_typ * common_params; /* ptr to common    WS10054 */
                          /* usaapi parameters area (look at WS10054 */
                          /* CTS.CMAC(CTSCSRV) for details)  WS10054 */
  /* IS10174 - VERIFY_PASS_LOGIN is moved to common params
  char rssparm_ffu1[4];               * should be like RACF struct ! *
  char rssparm_VERIFY_PASS_LOGIN[2];  * VERIFY_PASSWORD_BY_LOGIN val *
  */
  /* BS10110 char rssparm_ffu1[6];                            IS10174 */
   char rssparm_ffu1[4];                                   /* BS10110 */
   char rssparm_ACFRPTRX_NOUIDALL_SUPP[2];                 /* BS10110 */
                           /* ACFRPTRX_NOUIDALL_SUPP parm     BS10110 */
   char rssparm_SUSPEND_IS_LOCKED[2];/* SUSPEND_IS_LOCKED parm IS10005*/
   char rssparm_DISR_RU_SUSPENDED[2];/* DISREGARD_RU_SUSPENDED IS10005*/
   /* BS10028 - no insert calls to CTSUpdPassword
   char Insert_Calls_CTSUpdPassword[2];  * Insert calls        WS10007*
                                                                     */
  short uidlen;                                             /*IS10088*/
  char rssparm_IIQACF2GROUPS[2];    /* IIQACF2GROUPS          IS10128*/
  int  rssparm_ACF2_LOCK;           /* copy of RSSPARM        BS10076
                                       ACF2_LOCK parameter    BS10076
                                       or the default value   BS10076*/
  int  rssparm_ACF2_LOCK_INTERVAL;  /* copy of RSSPARM        BS10076
                                       ACF2_LOCK_INTERVAL     BS10076
                                       parameter or the       BS10076
                                       default value          BS10076*/
  char rssparm_REPL_END_BLNK[2];    /* ACF2_REPL_END_BLNK     BS10097*/
  /* WS10084 ASM_RTN_TYP   * p_cts2rxs; /* -> CTS2RXS routine WS10075*/
  void  * FFU;               /* place holder                 WS10084 */
  char XREF_SYSID_SCOPE[9];  /*a(all)/c(current)/SYSID-NAME  WS10079A*/
  char ACF2_SYSID[ACF2_SYSID_SIZE]; /* ACF2_SYSID_SIZE=9    *WS10079A*/
  char rssparm_MSG_CONNGRP_ERR[2]; /* MSG_CONNGRP_ERR value  WS10079N */
  char DROP_ACCT_IND_PERMS[53]; /*                           WS10079T*/
  char DROP_GROUP_PERMS[56];    /*                           WS10079T*/
  char ALLOW_UID_COLLISION[2];  /*ALLOW_UID_COLLISION value  WS10090 */
  char ffu[833];  /* for future use, please update in change WS10090 */
  /*WS10090 char ffu[835];/* for future use, please update   WS10079T*/
  /*WS10079T   char ffu[944];*for future use, please update in change*/
  /*WS10079A   char ffu[964];*for future use, please update in change*/
} ACF2_PARAMS_rec_typ, *ACF2_PARAMS_rec_ptr;
/* ------------------- end of IS10002 -------------------------- */

/* WS10078KG - Start */

/* BS10111 - moved to CTSBSRV
typedef struct {
 Get_RUOBline_handle_rec_typ *h_RUOB;
 } Get_XREF_Rec_Handle;
   end of moved code - BS10111 */

/* WS10078KG - End */

/**************************************************************
*                                                             *
* PROCEDURE NAME : ACF2cmd                                    *
*                                                             *
* DESCRIPTION    : check, build and issue a ACF2 command      *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
EXT ESA_RC ACF2cmd (char                       * func,
                    char                       * ddn,
                    USER_typ                     admin_uname,
                    char                       * cmd,
     /* ps0320 */   CMD_RC_typ                   max_ok_rc,
                    short                        numaddi,
                    ADDINFO_rec_ptr            * addinfo,
                    ADDINFO_MKTE_rec_typ       * mkt,
                    ADDINFO_KDTE_rec_typ       * kdt,
     /* IS10174 */  ADMIN_PARAMS_rec_typ       * admin_params,
     /* ps0320 */   CMDOUT_typ                   gout_flag,
                    ACF2_FLAG_typ                ignore_no_addinfo);
     /* IS10174     CTSAMSG_DEST_TABLE_rec_typ * dest,           */
     /* IS10174     CTSAMSG_HANDLE_rec_typ     * msgs,           */

/* IS10174 - remove this function
 **************************************************************
*                                                             *
* PROCEDURE NAME : ACF2_version_get                           *
*                                                             *
* DESCRIPTION    : Retrieve ACF2 version                      *
*                                                             *
* INPUT          : none                                       *
*                                                             *
* OUTPUT         : version                                    *
*                                                             *
* RETURN VALUE   : ESA_OK,  ESA_FATAL                         *
*                                                             *
**************************************************************

EXT ESA_RC ACF2_version_get( char   * version,
          *IS10119*          ADMIN_PARAMS_rec_typ *admin_params);
*/

/**************************************************************
*                                                             *
* PROCEDURE NAME : ACF2_version_check                         *
*                                                             *
* DESCRIPTION    : Check ACF2 version                         *
*                                                             *
* INPUT          : rss_type                                   *
*                  dest                                       *
*                  msgs                                       *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_OK,  ESA_FATAL                         *
*                                                             *
**************************************************************/

EXT ESA_RC ACF2_version_check(RSS_typ                      rss_type,
                              CTSAMSG_DEST_TABLE_rec_typ * dest,
                              CTSAMSG_HANDLE_rec_typ     * msgs);

 /**************************************************************
 * Global COnstants                                            *
 **************************************************************/
#define DEBUG_SHOW_IGNORE           0
#define DEBUG_SHOW_IMPORTANT        1
#define DEBUG_SHOW_REGULAR          10
#define DEBUG_SHOW_ALL              20

#define UDB_ACTIVE                  "Y"
/* BS10076 #define GLOBAL_TOTAL_WAIT_LOCK_TIME "WAIT_LOCK"           */
/* BS10076 #define DEFAULT_TOTAL_WAIT_LOCK_TIME 600                  */
/* BS10076 #define GLOBAL_RETRY_WAIT_LOCK_TIME "WAIT_QUEUE"          */
/* BS10076 #define DEFAULT_RETRY_WAIT_LOCK_TIME 30                   */
#define GLOBAL_UDB_ACTIVE           "UDB_ACTIVE"
#define DEFAULT_UDB_ACTIVE          "Y"

/* WS2358 */
#define GLOBAL_VIRTUAL_RES_NAME     "VIRTUAL_RES_NAME"
#define DEFAULT_VIRTUAL_RES_NAME    "$$ADDACE$$"

#define GDB_KEY_LENGTH 64

#define GDB_RECORD_TYPE_GROUP  'G'
#define GDB_RECORD_TYPE_USER   'U'
#define GDB_RECORD_TYPE_IGNORE '*'

/* The following values are the default values for ACF2      BS10076
   file-related (GDB and UDB) locking. The ACF2_LOCK_TOTAL   BS10076
   field is in seconds and represents the total amount of    BS10076
   time we will wait for a lock to be released before we     BS10076
   give up. The ACF2_LOCK_INTERVAL_DFLT field is in          BS10076
   milliseconds and represents how often we attempt to       BS10076
   acquire the lock (if it was held on a previous attempt).  BS10076 */
#define ACF2_LOCK_INTERVAL_DFLT 1000         /* milliseconds BS10076 */
#define ACF2_LOCK_TOTAL          600         /* seconds      BS10076 */

 /**************************************************************
 * UID Update modes                                            *
 **************************************************************/
typedef enum {
  Disconnect_Update,
  Connect_Update
} UID_Update_type;

 /**************************************************************
 * UIDMASK, UID , LID , URID                                   *
 **************************************************************/
typedef char UIDMASK[ACF2_UID_SIZE];
typedef char UID[ACF2_UID_SIZE];
typedef char LID[ACF2_LID_SIZE];
typedef char URID[ACF2_URID_SIZE];                        /* WS2338 */
typedef char UDBLID[ACF2_UDB_LID_SIZE];                   /* PS0338 */
typedef char UDBURID[ACF2_URID_SIZE-1];                   /* PS0339 */

typedef char QUALIFIER[ACF2_QUALIFIER_SIZE];              /* WS2358 */
typedef char VOLSER[ACF2_VOLSER_SIZE];                    /* WS2358 */

 /**************************************************************
 * Group Database Locate  types                                *
 **************************************************************/
typedef enum {
 GDB_Exact_Locate,
 GDB_Generic_Locate,
 GDB_Next_Locate
} GDB_Locate_Mode;

 /**************************************************************
 * User  Database Locate  types                                *
 **************************************************************/
typedef enum {
 UDB_Exact_Locate,
 UDB_Generic_Locate,
 UDB_Next_Locate
} UDB_Locate_Mode;

 /**************************************************************
 * Group Database Codes                                        *
 **************************************************************/
typedef enum {
 GDB_OK,

 GDB_Wrong_Mode,

 GDB_Open_Failed,
 GDB_Close_Failed,
 GDB_Insert_Failed,
 GDB_Update_Failed,
 GDB_Delete_Failed,
 GDB_Locate_Failed,
 GDB_GetNext_Failed,

 GDB_Obtain_Lock_Failed,
 GDB_Release_Lock_Failed,
 GDB_Read_Lock_Failed,
 GDB_Update_Lock_Failed,

 GDB_EOF,
 GDB_Duplicate_Key,
 GDB_Not_Found,
 GDB_Database_Full,
 GDB_IO_Error
 } GDB_Codes;

 /**************************************************************
 * Group Database Open modes                                   *
 **************************************************************/
typedef enum {
 GDB_Closed  ,
 GDB_ReadOnly,
 GDB_ReadWrite
 } GDB_Modes;

 /**************************************************************
 * Group Database Lock types                                   *
 **************************************************************/
typedef enum {
 GDB_No_Lock,
 GDB_ReadOnly_Lock,
 GDB_ReadWrite_Lock,
 GDB_ALL_Locks
 } GDB_Locks;

 /**************************************************************
 * User  Database Codes                                        *
 **************************************************************/
typedef enum {
 UDB_OK,
 UDB_Wrong_Mode,
 UDB_Open_Failed,
 UDB_Close_Failed,
 UDB_Insert_Failed,
 UDB_Update_Failed,
 UDB_Delete_Failed,
 UDB_Locate_Failed,
 UDB_GetNext_Failed,
 UDB_Obtain_Lock_Failed,
 UDB_Release_Lock_Failed,
 UDB_Read_Lock_Failed,
 UDB_Update_Lock_Failed,
 UDB_EOF,
 UDB_Duplicate_Key,
 UDB_Not_Found,
 UDB_Database_Full,
 UDB_IO_Error
 } UDB_Codes;

 /**************************************************************
 * User  Database Open modes                                   *
 **************************************************************/
typedef enum {
 UDB_Closed  ,
 UDB_ReadOnly,
 UDB_ReadWrite
 } UDB_Modes;

 /**************************************************************
 * User  Database Lock types                                   *
 **************************************************************/
typedef enum {
 UDB_No_Lock,
 UDB_ReadOnly_Lock,
 UDB_ReadWrite_Lock,
 UDB_ALL_Locks
 } UDB_Locks;

 /**************************************************************
 * UID description entry                                       *
 **************************************************************/
typedef struct{
 char  UID_Part_Field_Name[16];
 short UID_Part_Offset;
 short UID_Field_Offset;
 short UID_Part_Length;
 char  UID_Part_Multi;                                    /* PS0321 */
 } UID_Structure;

 typedef enum {
   ACF2_TRUE,
   ACF2_FALSE,
   ACF2_ERROR
   } ACF2_Flags;

 /**************************************************************
 * Match_Id_to_Mask object types                               *
 **************************************************************/
 typedef enum {
   LID_Object,
   UID_Object,
   Undefined_Object
  } ACF2_Object_Type;

 /**************************************************************
 * Get User with/without fields                                *
 **************************************************************/
 typedef enum
  {
    ACF2_GetUser_Get_Fields,
    ACF2_GetUser_No_Fields   } ACF2_GetUser_Fields;

 /**************************************************************
 * ACF2 API return codes                                       *
 **************************************************************/
 typedef enum
  {
    ACF2_OK ,
    ACF2_Not_Found,
    ACF2_ACF2_Not_Active,
    ACF2_Internal_Error } ACF2_API_Return_Codes;

 /**************************************************************
 * KDT and ACFFDR merge option                                 *
 **************************************************************/
 typedef enum
  { ACF2_KDT_Merge,
    ACF2_KDT_Replace } ACF2_KDT_Processing_Option;

 /**************************************************************
 * KDT from ACFFDR processing                                  *
 **************************************************************/
 typedef enum
  { ACF2_Get_ReadWrite_Fields,
    ACF2_Get_ReadWrite_Fields_and_NoFlag,
    ACF2_Get_ReadOnly_Fields,
    ACF2_Get_ReadOnly_Fields_and_NoFlag,
    ACF2_Get_All_Fields     ,
    ACF2_Get_All_Fields_and_NoFlag } ACF2_Get_Fields_Filter;

 /**************************************************************
 * ARE structure                                               *
 **************************************************************/
  typedef struct {
   short          ARE_Length;
   char           ARE_Last_Entry;
 #define ARE_LAST_ENTRY 0X80
   char           ARE_Field_Type;
 #define ARE_BINARY  0X80
 #define ARE_CHAR    0X40
 #define ARE_PACKED  0X20
 #define ARE_TIME    0X10
 #define ARE_BIT     0X08
 #define ARE_TOD     0X04
 #define ARE_HEX     0X02
 #define ARE_ENCR    0X01
   char           ARE_Field_Name[8];
   char           ARE_Type;
 #define          ARE_IS_XARE    0X10
 #define          ARE_IS_MULTI   0X01
 #define          ARE_IS_2BMULTI 0X05   /* RRK */
   char           ARE_Auth;
   short          ARE_Value_Length;
   char           ARE_Value;
   } ARE_typ;

 /**************************************************************
 * XARE header                                                 *
 **************************************************************/
typedef struct {
 short          XARE_Fixed_Length;
 short          XARE_Value_Offset;
 } XARE_Header_typ;

 /**************************************************************
 * XARE value extension                                        *
 **************************************************************/
typedef struct {
 short          XARE_Value_Length;
 char           XARE_Value;
 } XARE_Value_typ;

 /**************************************************************
 * Infostorage Record retrieval strcuture                      *
 **************************************************************/
typedef struct {
 char  INF_sysid_masked;
 char  INF_recid_masked;
 short INF_sysid_length;
 short INF_recid_length;
 char  INF_class;
 char  INF_type[3];
 char  INF_key[41];
 } ACF2_INF_record;

 /**************************************************************
 * Infostorage GSO records matching mode                       *
 **************************************************************/
typedef enum {
 ACF2_INF_Get_Best_Match,
 ACF2_INF_Get_Match
 } ACF2_INF_Match;

 /**************************************************************
 * Snap Area in C                                              *
 **************************************************************/

static int i_snap;
static int j_snap;
static char m_snap;
#define    SNAP_AREA( title, ptr, len )                       \
  printf("\n>>> %s addr=%x len=%d <<<\n", title, ptr, len );  \
  for( i_snap=0; i_snap LT len; i_snap++)   {                 \
     if ( ( i_snap % 16 ) EQ 0 )                              \
       printf("%4.4X ",i_snap);                               \
     printf("%2.2X", *((char *)ptr+i_snap) );                 \
     if ( ( ( i_snap + 1 ) % 4 ) EQ 0 )                       \
           printf(" ");                                       \
     if ( ( ( i_snap + 1 ) % 16) EQ 0 )                       \
      {                                                       \
      for (j_snap=0;j_snap LT 16;j_snap++)                    \
       {                                                      \
       m_snap = (char) *((char *)ptr +i_snap-15+j_snap);      \
       if (isprint(m_snap) EQ 0)                              \
        printf(".");                                          \
       else                                                   \
        printf("%c",m_snap);                                  \
        };                                                    \
      printf("\n");                                           \
      };                                                      \
  };                                                          \
  printf("\n");                                               \
  printf("\n");

 /*****************************************************************
 * Macro for trimming blanks - This macro was written for BS10070 *
 *                             but then improved for BS10072. The *
 *                             original BS10070 macro was deleted.*
 *****************************************************************/

#define TRIM_BLANKS(msg, temp, len, ndx)                             \
  /* BS10072 start */                                                \
  /* WS10079T START */                                               \
  /*                                                                 \
  temp[0] = NULL_CHAR;                                               \
  for (ndx=len-1; (isspace(msg[ndx]) NE 0) AND (ndx GT 0); ndx--);   \
  */                                                                 \
  temp[0] = NULL_CHAR;                                               \
  for (ndx=len-1; (ndx GT 0) AND (isspace(msg[ndx]) NE 0); ndx--);   \
  /* WS10079T end   */                                               \
  if (ndx GT 0) {                                                    \
      memcpy (temp, msg, ndx+1);                                     \
      temp[ndx+1] = NULL_CHAR;                                       \
      }                                                              \
  /* BS10072 end */
  /* BS10070 start
  temp[len] = NULL_CHAR;                                             \
  memcpy (temp, msg, len);                                           \
  for (ndx=len-1; (isspace(temp[ndx]) NE 0) AND (ndx GT 0); ndx--);  \
  temp[ndx+1] = NULL_CHAR;                                           \
  strcpy (msg, temp);                                                \
     BS10070 end */

 /*****************************************************************
 * * * * * * * * * * * * * BS10097 start  * * * * * * * * * * * * *
 *                                                                *
 * Macros for replacing / restoring an ending blank in an ACF2    *
 * group.                                                         *
 *                                                                *
 * REPLACE_ENDING_BLANK - If the last character is a blank and    *
 *                        it is not part of the LID (i.e., it     *
 *                        is part of the group), replace the      *
 *                        blank with rssparm_REPL_END_BLNK.       *
 *                                                                *
 * RESTORE_ENDING_BLANK - If the last character is                *
 *                        rssparm_REPL_END_BLNK and it is not     *
 *                        part of the LID (i.e., it is part of    *
 *                        the group), restore the ending blank.   *
 *                                                                *
 * With IS10178, we had to change the way we determined whether   *
 * the ending blank is part of the LID or not. We now check       *
 * whether the ending blank is before the LID begins (LID_Offset) *
 * or whether the ending blank is after the LID ends (LID_Offset  *
 * + LID_Length - 1).  If this check fails, the ending blank is   *
 * in the LID itself.                                             *
 *                                                                *
 *****************************************************************/

#define REPLACE_ENDING_BLANK(group, diag)                             \
  LID_In_UID = ACF2_Is_LID_In_UID(&LID_Offset, &LID_Length);          \
  params_ptr = admin_params->apiinit_handle;                          \
  if ( (strncmp(group+strlen(group)-1, " ", 1) EQ 0) AND              \
       (LID_In_UID)                                  AND              \
       /* IS10178 change the next line with the next 2 lines          \
       (strlen(group) LE LID_Offset)                 )*/              \
       ( (strlen(group)-1 LT LID_Offset)             OR    /*IS10178*/\
         (strlen(group)-1 GT (LID_Offset+LID_Length-1)) ) )/*IS10178*/\
     {                                                                \
       ESA_DIAG_printf(diag, 6,                                       \
                "Group with ending blank = |%s|", group);             \
       strncpy(group+strlen(group)-1,                                 \
               params_ptr->rssparm_REPL_END_BLNK, 1);                 \
       ESA_DIAG_printf(diag, 6,                                       \
                "Group ending blank replaced = |%s|", group);         \
     }

#define RESTORE_ENDING_BLANK(group, diag)                             \
  LID_In_UID = ACF2_Is_LID_In_UID(&LID_Offset, &LID_Length);          \
  params_ptr = admin_params->apiinit_handle;                          \
  if ( (strncmp(group+strlen(group)-1,                                \
         params_ptr->rssparm_REPL_END_BLNK, 1) EQ 0) AND              \
       /* IS10178 change the next line with the next 2 lines          \
       (strlen(group) LE LID_Offset)                 )*/              \
       ( (strlen(group)-1 LT LID_Offset)             OR    /*IS10178*/\
         (strlen(group)-1 GT (LID_Offset+LID_Length-1)) ) )/*IS10178*/\
     {                                                                \
       ESA_DIAG_printf(diag, 6,                                       \
                "Group with replacement = |%s|", group);              \
       strncpy(group+strlen(group)-1, " ", 1);                        \
       ESA_DIAG_printf(diag, 6,                                       \
                "Group ending blank restored = |%s|", group);         \
     }

 /* * * * * * * * * * BS10097 end * * * * * * * * * */

 /*****************************************************************
 * * * * * * * * * * * * * IS10178B start * * * * * * * * * * * * *
 *                                                                *
 * Macros for replacing / restoring an ending blank in an ACF2    *
 * permission UID which ends with a LID.                          *
 *                                                                *
 * A permission which ends with a LID which ends with a blank     *
 * will be replaced with this character: rssparm_REPL_END_BLNK    *
 * These 2 macros replace the ending blank and restore the        *
 * ending blank.                                                  *
 *                                                                *
 * REPLACE_PRMSN_LID_EB - If the last character of the ACF2       *
 *                        permission UID is a blank and it is     *
 *                        part of the LID, replace the blank      *
 *                        with rssparm_REPL_END_BLNK.             *
 *                                                                *
 * RESTORE_PRMSN_LID_EB - If the last character of the ACF2       *
 *                        permission UID is rssparm_REPL_END_BLNK *
 *                        and it is part of the LID, restore the  *
 *                        ending blank.                           *
 *                                                                *
 *****************************************************************/

#define REPLACE_PRMSN_LID_EB(uid, diag)                               \
  LID_In_UID = ACF2_Is_LID_In_UID(&LID_Offset, &LID_Length);          \
  params_ptr = admin_params->apiinit_handle;                          \
  if ( (strncmp(uid+strlen(uid)-1, " ", 1) EQ 0) AND                  \
       (LID_In_UID)                              AND                  \
       (strlen(uid) GT LID_Offset)               AND                  \
       (strlen(uid) LE (LID_Offset+LID_Length)) )                     \
     {                                                                \
       ESA_DIAG_printf(diag, 6,                                       \
           "UID LID with ending blank = |%s|", uid);                  \
       strncpy(uid+strlen(uid)-1,                                     \
               params_ptr->rssparm_REPL_END_BLNK, 1);                 \
       ESA_DIAG_printf(diag, 6,                                       \
           "UID LID ending blank replaced = |%s|", uid);              \
     }

#define RESTORE_PRMSN_LID_EB(uid, diag)                               \
  LID_In_UID = ACF2_Is_LID_In_UID(&LID_Offset, &LID_Length);          \
  params_ptr = admin_params->apiinit_handle;                          \
  if ( (strncmp(uid+strlen(uid)-1,                                    \
         params_ptr->rssparm_REPL_END_BLNK, 1) EQ 0) AND              \
       (strlen(uid) GT LID_Offset)                   AND              \
       (strlen(uid) LE (LID_Offset+LID_Length)) )                     \
     {                                                                \
       ESA_DIAG_printf(diag, 6,                                       \
           "UID LID with replacement = |%s|", uid);                   \
       strncpy(uid+strlen(uid)-1, " ", 1);                            \
       ESA_DIAG_printf(diag, 6,                                       \
           "UID LID ending blank restored = |%s|", uid);              \
     }

 /* * * * * * * * * * IS10178B end  * * * * * * * * */


 /* * * * * * * * * * * * * WS10075 start * * * * * * * * * * * * */

 /**************************************************************
 * RULE_KWD_VALUE_RTRVR macro                                  *
 *                                                             *
 * Input to this macro:                                        *
 *    ptri - pointer to input parameter, e.g., UID(            *
 *    leno - return area length                                *
 *    reto - return area                                       *
 *    rcm  - ESA_OK or ESA_FATAL                               *
 *    frw  - from - work area                                  *
 *    tow  - to - work area                                    *
 *    lnw  - len - work area                                   *
 *                                                             *
 * Note 1: It is the caller's responsibility to make sure that *
 *         the return area is large enough to hold the keyword *
 *         and a NULL terminator.                              *
 * Note 2: The return area will always end with a terminator.  *
 *                                                             *
 **************************************************************/
#define RULE_KWD_VALUE_RTRVR(ptri, leno, reto, rcm, frw, tow, lnw) \
frw  = strchr (ptri, '(');  /* point to keyword value - 1      */  \
tow  = strchr (frw, ')');   /* point to end of value + 1       */  \
lnw  = tow - frw - 1;       /* get length of keyword value     */  \
reto[0] = NULL_CHAR;        /* set terminator         WS10076S */  \
if (lnw LT leno)            /* allow for terminator   WS10076S */  \
   {                                                               \
     strncpy (reto, frw+1, lnw);  /* copy value to return area */  \
     reto[lnw] = NULL_CHAR;       /* set terminator   WS10076S */  \
     ESA_DIAG_printf(PLT_COMP_PERMISSION, 17,                      \
                     "keyword value = |%s|", reto);                \
     rcm = ESA_OK;                /* set good return code      */  \
   }                                                               \
else rcm = ESA_FATAL;             /* set bad return code       */



 /* * * WS10078S start * * */

 /*  WS10078T change ptr[0] -1 to *(ptr-1)                     */
 /*  and      change ptr[0]+strlen(lid) to *(ptr+strlen(lid))  */
 /**************************************************************
 * IS_LID_IN_LIST macro                                        *
 *                                                             *
 * Input to this macro:                                        *
 *    lid  - the lid to look for in the list                   *
 *    list - the pair->value to search for the lid in          *
 *    srch - work area - used as a roving pointer to the list  *
 *    ptr  - pointer to the lid in the list or NULL (retcode)  *
 *                                                             *
 **************************************************************/
/* WS10079 start: IS_LID_IN_LIST is replaced by ADDINFO_list_search
#define IS_LID_IN_LIST(lid, list, srch, ptr)                       \
srch = list;                /@ point to start of list          @/  \
while (TRUE)                                                       \
{                                                                  \
   ptr = strstr(srch, lid); /@ look for lid in list            @/  \
   if (ptr EQ NULL) break;  /@ not there, return to caller now @/  \
   if (ptr NE list)         /@ if we're not on first list item @/  \
      if (@(ptr-1) NE ' ')  /@ if there's no ' ' before match  @/  \
         {                                                         \
            srch = ptr + strlen(lid); /@ update pointer and... @/  \
            continue;       /@ go up to do another strstr      @/  \
         }                                                         \
   if ( (@(ptr+strlen(lid)) EQ NULL_CHAR) OR                       \
        (@(ptr+strlen(lid)) EQ ' '   ) )                           \
      break;                /@ ptr points to the lid in list   @/  \
   else                     /@ ptr not pointing to lid         @/  \
      {                                                            \
         srch = ptr + strlen(lid); /@ update pointer and...    @/  \
         continue;          /@ go up to do another strstr      @/  \
      }                                                            \
}                                                                  \
if (ptr EQ NULL)                                                   \
   ESA_DIAG_printf(PLT_COMP_XREF, 6,                               \
       "LID %s was not found in the LIST", lid);                   \
else                                                               \
   ESA_DIAG_printf(PLT_COMP_XREF, 6,                               \
       "LID %s was found here in the LIST %s", lid, list);

WS10079  end */
 /**************************************************************
 * Diagnostic message when storage is allocated                *
 **************************************************************/
#define ALLOC_STORAGE_DIAG(ptr, size, func)                        \
 ESA_DIAG_printf(PLT_COMP_ACF2_MEMORY, 6,                          \
     "Allocate: addr=%p len=%d rtn=%s",                            \
     ptr, size, func);


 /**************************************************************
 * Diagnostic message when storage is freed                    *
 **************************************************************/
#define FREE_STORAGE_DIAG(ptr, func)                               \
 ESA_DIAG_printf(PLT_COMP_ACF2_MEMORY, 6,                          \
     "Free: addr=%p rtn=%s",                                       \
     ptr, func);


 /* * * WS10078S end * * */


/*  IS10184 - this macro is replaced by GET_CMNPRMS_PROG which
              is common to all SPI programs.
/@***************************************************   * BS10111 *
 *   Verify that common_params exist and keep       *   * BS10111 *
 *   its address and CTSARUH address.               *   * BS10111 *
 ***************************************************@/ /@ BS10111 @/
#define GET_P_CTSARUH(pptr, cmn, p)                    /@ BS10111 @/  \
  rc = ESA_OK;                                         /@ BS10111 @/  \
  if ((pptr) EQ NULL)                                  /@ BS10111 @/  \
    (pptr) = admin_params->apiinit_handle;             /@ BS10111 @/  \
                                                       /@ BS10111 @/  \
  if ((pptr) NE NULL       AND                         /@ BS10111 @/  \
      (pptr)->common_params NE NULL)                   /@ BS10111 @/  \
  {                                                    /@ BS10111 @/  \
    (cmn) = (pptr)->common_params;                     /@ BS10111 @/  \
    if ((cmn)->p_ctsaruh NE NULL)                      /@ BS10111 @/  \
      (p) = (cmn)->p_ctsaruh;                          /@ BS10111 @/  \
    else                                               /@ BS10111 @/  \
    {                                                  /@ BS10111 @/  \
      CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,   /@ BS10111 @/  \
               component, func,                        /@ BS10111 @/  \
               "common_params was not initialized",    /@ BS10111 @/  \
                   16, __LINE__);                      /@ BS10111 @/  \
      rc = ESA_FATAL ;                                 /@ BS10111 @/  \
    }                                                  /@ BS10111 @/  \
  }                                                    /@ BS10111 @/  \
  else                                                 /@ BS10111 @/  \
  {                                                    /@ BS10111 @/  \
    CTSAMSG_print(ERR_INTERNAL2, msgs, NULL, dest,     /@ BS10111 @/  \
                 component, func,                      /@ BS10111 @/  \
                 "common_params does not exist",       /@ BS10111 @/  \
                 16, __LINE__);                        /@ BS10111 @/  \
    rc = ESA_FATAL ;                                   /@ BS10111 @/  \
  }                                                    /@ BS10111 @/
    end of replaced code - IS10184   */


 /**************************************************************
 * Permission_record_type - type of line requested / returned  *
 **************************************************************/
 typedef enum {
  ANY_LINE = 1,
  KPP_LINE,
  LID_LINE,
  $KEY_LINE,
  $PREFIX_LINE,
  PERMISSION_LINE,
  ROLES_BLOCK,                                          /* WS10078S */
  ROLE_LINE                                             /* WS10078S */
 } Permission_Record_Type;



 /* BS10111 - removed because they are not used
 /@*************************************************************
 * Input Descriptor Block for the Get_stem_line routine        *
 *************************************************************@/
 typedef struct {
  char  name[16];        /@ stem name - for group aggregation @/
 } IDB_GETSTEMLINE_rec_typ, *IDB_GETSTEMLINE_rec_ptr;

/@*********************************************************************
 *  typedef for the Get_stem_line routine                             *
 ********************************************************************@/

typedef struct {
 FILE     * stream;
 } Get_Line_Handle;


/@**************************************************************
 *  WANTED_PERM_REC - Wanted Permission Record Entry structure *
 *************************************************************@/

typedef struct {
   char                   wanted_rec[10];
   int                    length;
   Permission_Record_Type type;
 } WANTED_PERM_REC_rec_typ, *WANTED_PERM_REC_rec_ptr;

     end of rmeoved code - BS10111  */


/**********************************************************************
 *  PB - Permissions Block structures                                 *
 *  These are the structures used by all routines handling the        *
 *  Permissions Block.                                                *
 *********************************************************************/

typedef struct S_XB_PBheader_ext {                         /* WS10079 */
   char        eyec[5];          /* XBHE                      WS10079 */
   char        xbtype;           /* X / G                     WS10079 */
} XB_PBheader_ext_rec_typ, * XB_PBheader_ext_rec_ptr;      /* WS10079 */

#define  ACF2_PERM_PBENT_EYEC  'P'

typedef struct S_PERM_BLK_PERM {
   struct S_PERM_BLK_PERM * next_perm; /* ptr to next perm (horiz)    */
   char                    eyec;       /* 'P'                         */
   char                    perm[1];  /* permission placeholder.       */
                                     /* permission element length is  */
                                     /* determined according to the   */
                                     /* permission string length.     */
} PERM_BLK_PERM_rec_typ, * PERM_BLK_PERM_rec_ptr;

/* WS10079 - start */
typedef struct S_XB_SYSID  {
   struct   S_XB_SYSID * next_sysid;
   char     eyec;                 /* 'Y'  */
   char     SYSID[9];
   char     ActiveYN;
   char   * xref_rec;
}  XB_SYSID_entry_rec_typ,  * XB_SYSID_entry_rec_ptr;

/* WS10079 - end   */

/**********************************************************************
 **** UID ENTRY    **** -  pointed by PBhandle and others    WS10079A *
 **** Role ENTRY   **** -  pointed by PBhandle and others    WS10079A *
 **** Source ENTRY **** -  pointed by PBhandle and others    WS10079A *
 **** Acounts is the Users PB (U is already taken for Uid)   WS10084  *
 **********************************************************************/
#define  ACF2_UID_PBENT_EYEC    'U'
#define  ACF2_ROLE_PBENT_EYEC   'R'
#define  ACF2_SOURCE_PBENT_EYEC 'S'
#define  ACF2_ACNT_PBENT_EYEC   'A'      /*:A Accounts=Users  WS10084 */
typedef struct S_PERM_BLK_UID {
   struct S_PERM_BLK_UID * next_uid;   /* ptr to next uid entry (vert)*/
   char                    eyec;       /* 'U' / 'R' / 'S'             */
                                       /* 'A'                 WS10084 */
                                       /* same as PBentry table_type  */
   union {                             /*                    WS10079A */
   char         uid[ACF2_UID_SIZE];    /* uid                         */
   struct xref {
   char           XREFname[9];
   unsigned char   num_of_sysids;
   union  {
       XB_SYSID_entry_rec_typ  * P_SYSID;
   char                      *  p_rec;
             };
             };
   };
   PERM_BLK_PERM_rec_typ * first_perm; /*ptr to 1st perm entry (horiz)*/
} PERM_BLK_UID_rec_typ,  * PERM_BLK_UID_rec_ptr;

/* WS10079 - start */
typedef   ESA_RC  PB_ext_rtn_typ (
   PERM_BLK_UID_rec_typ  * uid_ent,
   void                  * blk_address,
   ESA_DIAG_COMP_typ       comp,
   ADMIN_PARAMS_rec_typ  * admin_params);            /*WS10079A*/
/* WS10079 - end   */

typedef PB_ext_rtn_typ   * PB_ext_rtn_ptr;
typedef struct S_PB_INDEX_rec_typ {
   int                     entry_number;       /* entry number        */
   char                    uid[ACF2_UID_SIZE]; /* uid                 */
   PERM_BLK_UID_rec_typ  * UIDentry;           /* pointer to uid entry*/
} PB_INDEX_rec_typ, * PB_INDEX_rec_ptr;

/*WS10079 #define PBH_EYECATCHER     "PBH "                           */
#define PBH_EYECATCHER     "PBH"                           /* WS10079 */
#define PBH_INITAL_IX_NUM  100  /* Initial number w/o last */

/* WS10079 - start */

typedef struct S_PB_rtnblk_ext {
   char              eyec[5];    /* PBRE */
   PB_ext_rtn_typ  * insert;     /* -> Insert routine */
   PB_ext_rtn_typ  * get;        /* -> Get    routine */
   PB_ext_rtn_typ  * print;      /* -> Print  routine */
   PB_ext_rtn_typ  * free;       /* -> Free   routine */
   void            * p_rtnparms; /* routines parameters block */
} PB_rtnblk_ext_rec_typ, * PB_rtnblk_ext_rec_ptr;
/* WS10079 - end   */


/***********************************************************************
 *  The following typedef from WS10075 was changed in WS10076S as      *
 *  follows:                                                           *
 *     - every reference to PBB was changed to GRO                     *
 *     - the reference to CTSBPBB was changed to CTSCGRO               *
 *     - changes to individual variables as documented below           *
 *     - move the entire typedef to CTSCCLI / CTSOCLI                  *
 *                                                                     *
 *  typedef for the CTSCGRO routine                                    *
 *  This is a structure for passing parameters from a 'C' program to   *
 *  another 'C' program via a REXX program, CTSBRLST, and an Assembler *
 *  program, CTSAVAR.                                                  *
 ***********************************************************************

#define GRO_EYECATCHER                    "GRO "

typedef struct s_os_gro {
     char                       eyecatcher[4]; // eyecatcher 'GRO' //
     void                    ** RUOBptr;       // ptr to 1st RUOB  //
                                               // added in WS10076S//
     REXX@UTL_output_ignlist_rec_typ * ignore_list; // ignore list //
                                               // added in WS10076S//
 /*  PBhandle_typ             * PBhandle;      // ptr to PB handle //
                                             // removed in WS10076S//
     char                     * rss_name;      // ptr to rss_name  //
     char                     * rss_type;      // ptr to rss_type  //
     int                        debug_level;   // debug level      //
     ADMIN_PARAMS_rec_typ     * admin_params;  // admin params     //
     CTSAMSG_HANDLE_rec_ptr     msgs;
     CTSAMSG_DEST_TABLE_rec_ptr dest;
} OS_GRO_typ, *OS_GRO_ptr ;                                        */



/*   WS10076S (start) Change the variable names and move this to CTSCCLI
//
 *   LID_RULE_AREA block header structure.  This header is
 *   immediatetly followed by rule lines as returned by ACFRPTRX.
 *
 *   Each line of data is preceded by 1 byte of length. This
 *   byte contains the length of the data (not including itself).
 *   The LID_RULE_AREA blocks are chained.  The last block
 *   The s created by CTS2RXO
 *   contains 0 in the hnext field.
 *
 *   The type of hnext is LID_RULE_AREA_blk_rec_typ   *.
 *   The type of all other fields is int.
 *
 *   ***  ATTENTION ***
 *   Any change in this structure should be first done in the
 *   CTS2PMB member in the MAC library, and EDCDSECT should be
 *   run to get the matching structure definition to be put here.
 *
 //
#pragma pack(packed)

typedef struct lra {
  void          *lrahnext; // -> NEXT BLOCK. //
  int            lrahlen;  // BLOCK LENGTH.  //
  int            lrahdlen; // DATA LENGTH.   //
  unsigned char  lradata;  // START OF DATA. //
  } LID_RULE_AREA_blk_rec_typ,  * LID_RULE_AREA_blk_rec_ptr;

// Values for field "lrahdlen" //
#define _lrahlen 0x0C /* HEADRER LENGTH //

typedef struct lral {
  unsigned char  lrallen;  // LINE DATA LENGTH.     //
  unsigned char  lraldata; // VARIABLE LENGTH DATA, //
  } LID_RULE_AREA_line_rec_typ,  * LID_RULE_AREA_line_rec_ptr;

// Values for field "lraldata" //
#define _lrasp 131  // SUBPOOL=131 - OWNER=JSTCB //

#pragma pack(reset)
// WS10076S (end) Change the variable names and move this to CTSCCLI*/

/**********************************************************************
 *  LID_RULE_AREA_vector - LID rule area vector                       *
 *  This is a vector which holds information and pointers to the LID  *
 *  rule area, get_rule_record handle, and several indicators.        *
 *********************************************************************/
typedef struct LID_RULE_AREA_vector {
     char                        rules_type[5];
     /* BS10111
     REXX@UTL_output_blk_rec_typ * lidra; /@ typedef name changed in @/
                                          /@ WS10076S                */
     char                        lidra[8]; /* ruob addr.      BS10111 */
     void                      * get_rule_record_handle;
     int                         EOF_indicator;
     int                         IOError_indicator;
} LID_RULE_AREA_vec_rec_typ,  *LID_RULE_AREA_vec_rec_ptr;

static  char   p_ruob_null[8] = {0X00, 0X00, 0X00, 0X00,   /* BS10111 */
                                 0X00, 0X00, 0X00, 0X00};  /* BS10111 */
/*  WS10078T - start */

/***********************************************************************
 *  XREF_REC_block list of all the XREF records of the given type.     *
 *  Usage:                                                             *
 *  1. Given a name, search the list to determine whether it is group  *
 *     or basic                                                        *
 *  2. ......                                                          *
 **********************************************************************/
/* WS10084
#define  ROLE_BLOCK_EYEC      "ROLB"
#define  SGP_BLOCK_EYEC       "SGPB"
   WS10084 */
/*  XREF record types                                            */
#define  XREF_REC_TYPE_ROLE   'R'
#define  XREF_REC_TYPE_SGP    'S'
#define  XREF_REC_TYPE_ALL    'A'
/*  XREF record group                                            */
#define  XREF_REC_group_Yes   'Y'
#define  XREF_REC_group_No    'N'
/* WS10084
typedef struct XREF_REC_block {            /*                        @/
  char              eyec[4];               /* xxx_BLOCK_EYEC above   @/
  char              type;                  /* XREF_REC_TYPE_xxx      @/
  char              group;                 /* Y | N                  @/
  int               num_names;             /*                        @/
  char              names[XREF_NAME_SIZE]; /*                 @/
  } XREF_REC_BLK_rec_typ,  *XREF_REC_BLK_rec_ptr; /*          @/
   WS10084 */

/*  WS10078T - end  */
/* LID_PERM_handle was moved from here to urther below       WS10084 */

 /* WS10076 Moved the following typedef to CTSCCLI
 /*******************************************************************
 * Input Descriptor Block for the Get_line_from_memory routine      *
 ********************************************************************
 typedef struct get_from_mem_parm {
    REXX@UTL_output_blk_rec_typ  * LID_rule_area; // ACFRPTRX output //
                                          // typedef name changed in //
                                          // WS10076S                //
 } IDB_GETMEMLINE_rec_typ  , *IDB_GETMEMLINE_rec_ptr;                */

/*
 *   ACFRPTXRX output interception - error block
 *   This block contians the fields in which ACFRPTRX output
 *   interceptiopn routine return error information.
 *
 *   rxeerror - error indication (0/1)
 *   rxepgm - contains the name of the progrma in which the error
 *            occured.
 *   rxemsg - contains the message to be written to stdmsg
 *   rxedlin_ and rxedline - the scfrptrx output line on which
 *                           the error occurs.
 *
 *  The program calling CTS2RXS should pass the address of this
 *   area. When CTS2RXS returns, or after attaching ACFRPTRX using
 *   CTSAATC, if an error rc was returnef or if rxeerror is set,
 *   it should issue the message received in rxemsg. If rxedline
 *   contains data, it should issue a message with this data line
 *   as well.
 *
 *
 *   ***  ATTENTION ***
 *   Any change in this structure should be first done in the
 *   CTS2RXE member in the MAC library, and EDCDSECT should be
 *   run to get the matching structure definition to be put here.
 *
 *
 */
/* WS10084
#pragma pack(packed)

typedef  struct rxe {
  int            rxeerror;      /* ERROR INDICATION (0/1) @/
  unsigned char  rxepgm[9];     /* PROGRAM NAME.          @/
  unsigned char  rxefunc[9];    /* FUNCTION NAME.         @/
  unsigned char  rxemsg[201];   /* ERROR MESSAGE.         @/
  unsigned char  rxedline[133]; /* DATA LINE.             @/
  int            rxeline_;      /* LINE #.                @/
  } CTS2RX_error_block_rec_typ, *  CTS2RX_error_block_rec_ptr;
   WS10084 */

/*   The following moved here from CTSBPHR              WS10078T */
/* structure needed for Get_user_permissions routine */
#pragma pack(packed)             /* WS10084 */
typedef struct RULE_TYPE_PERM_handle {
 char       rules_type[5];
 char       last_lid_processed[ACF2_LID_SIZE];
 char       last_lid_read[ACF2_LID_SIZE]; /* LID record was read
                                             but not processed   */
 int        permError_indicator;
 } RULE_TYPE_PERM_rec_typ,  *RULE_TYPE_PERM_rec_ptr;
/* Values for field "rxeline_" */
/* WS10084 #define _rxelen 0x168    BLOCK LENGTH. */

#pragma pack(reset)


 /* * * * * * * * * * * * * WS10075 end * * * * * * * * * * * * * */
 /* * * * * * * * * * * * * WS10079A START  * * * * * * * * * * * */
/**********************************************************************
 **** Permissions Block Header - PBheader                    WS10079A *
 *******************m**************************************************/
typedef struct S_PERM_BLK_HDR {
   /* WS10079 char       eyecatcher[4]; eyecatcher 'PBH' - PB header  */
   char        eyecatcher[3]; /* eyecatcher 'PBH'-PB header   WS10079 */
   char        table_type;    /* U / R / S                    WS10079 */
                              /* / A                          WS10084 */
   int         num_uids;        /* total number of uids in PB         */
   int         num_ix_ent;      /* Number of index entries.           */
   int         num_used_ix_ent;  /* Number of used index entries.     */
   void      * ext_block_header; /* -> XB_PBheader_ext        WS10079 */
   PB_rtnblk_ext_rec_typ * ext_block_routines;             /* WS10079 */
   char        skip_extYN;    /* Y/N - skip ext routines      WS10084 */
   PB_INDEX_rec_typ index[1]; /* an index - the number of index       */
                              /* entries is allocated according to    */
                              /* num_ix_ent above.                    */
} PERM_BLK_HDR_rec_typ, * PERM_BLK_HDR_rec_ptr;

#define PERM_BLK_HDR_size(num)          \
        sizeof(PERM_BLK_HDR_rec_typ)+((num-1)*sizeof(PB_INDEX_rec_typ))


/***********************************************************************
 *  PBhandle - Permissions Block handle                                *
 *  This is the structure used by all routines handling the            *
 *  Permissions Block.                                                 *
 **********************************************************************/

typedef struct PBhandle {
     union                                               /* WS10079 */
     {                                                   /* WS10079 */
     char                uid[ACF2_UID_SIZE];
     struct  table_type_and_ext                          /* WS10079 */
      {                                                  /* WS10079 */
      char  blockid[5];           /* [XB]                   WS10079 */
      /* WS10084 moved below   char  PB_type;  /* R / S     WS10079 */
      char  XREF_or_Group;        /* X / G                  WS10079 */
      char  ext_type;             /* S(ysid)/R(ec)/N(one)   WS10079 */
      void  * handle_extension;   /* i.e. -> XB_SYSID_PBhandle      */
      };
     };
     /* PB_type values are the same as table_type in PBheader
        and eyec in PERM_BLK_UID_rec_typ
        R(oles)  S(ources)  U(ids)=Groups A(ccounts)=Users  WS10084 */
     char                PB_type;                        /* WS10084 */
     char                resource_name [MAX_RSS_RESOURCE_NAME_LEN + 1];
     char                resource_type [MAX_RSS_RESTYPE_NAME_LEN + 1];
     char                WithPermissions;
     PERM_BLK_HDR_rec_typ  * PBptr;         /* PBheader     */
     int                     PBbldErr;      /* TRUE / FALSE */
     int                     PBErr;         /* TRUE / FALSE */
     int                     PBnf;          /* TRUE / FALSE WS10079N */
     PERM_BLK_UID_rec_typ  * curUIDinPB;
     PERM_BLK_PERM_rec_typ * curPERMinPB;
} PBhandle_typ,  *PBhandle_ptr;

/* Start WS10079T  */


/*      XB routines for handling SYSID entries               */
PB_ext_rtn_typ   extern XREF_Block_InsertSYSID;
PB_ext_rtn_typ   extern XREF_Block_GetSYSID;
PB_ext_rtn_typ   extern XREF_Block_PrintSYSID;
PB_ext_rtn_typ   extern XREF_Block_FreeSYSID;
/*      XB routines for handling "record only" (no SYSID)    */
PB_ext_rtn_typ   extern XREF_Block_insertRec;
PB_ext_rtn_typ   extern XREF_Block_GetRec;
PB_ext_rtn_typ   extern XREF_Block_PrintRec;
PB_ext_rtn_typ   extern XREF_Block_FreeRec;

/*  SYSID routines parameters                                        */

/*  Insert routines parameters */
typedef  struct  S_XB_InsertSYSID_parms {
   char         * SYSID;         /* address of SYSID                 */
   char           ActiveYN;      /* Y(es) / N(o) / U(nknown)         */
   char         * xref_rec;      /* address of role/source record    */
   char           updActYN;      /* update old active when new added */
}  XB_InsertSYSID_parms_typ, *  XB_InsertSYSID_parms_ptr;

/*  Get routines parameters                                          */
typedef  struct  S_XB_GetSYSID_parms {
   char      Function[9];        /* UIDTHIS/UIDNEXT/SYSIDTHS/SYSIDNXT*/
   char      *  in_SYSID;        /* SYSID for UIDTHIS/SYSIDTHS       */
   char         in_Active;       /* Y - Get only if active           */
   char      *  out_SYSID;       /* area for active sysid            */
   char      *  out_ActiveYN;    /* area for active indication       */
   char      *  out_num_of_SYSIDs; /* area for # of sysids           */
   char      ** out_xref_rec;    /* area for sysid entry address     */
   XB_SYSID_entry_rec_typ
             **out_SYSID_ent;    /* area for sysid entry addr        */
}  XB_GetSYSID_parms_typ, *  XB_GetSYSID_parms_ptr;

typedef struct XBhandle
{
   /* ACF_Get_XREF callers - xref block request.             */
   char  request_type[9];  /* XREFONLY, XREFNGRP             */
   char  xrefname[19];     /* xref(sysid)                    */
   char  PB_type;          /*  R / S                         */
   char  active_request;   /* C(heck) / N(one) */
   char  need_rec_YN;      /* xref data is required Y/N      */
   /* Process */
   char  sysidYN;          /* SYSID entries exist Y/N        */
   char  active_check;     /* C(heck) / N(o)                 */
   char  active_default;   /* U / Y                          */
   char  shortest;         /* X / G                          */
   PBhandle_typ * XREF_PB_handle;
   PBhandle_typ * Groups_PB_handle;
   int   bld_nf;     /* Not found. no blocks. TRUE / FALSE  WS10079N */
   int   bld_err;    /* Build error. No blocks. TRUE / FALSE */
   int   XB_err;     /* Error in blocks. TRUE / FALSE        */
}  XBhandle_rec_typ,    * XBhandle_rec_ptr;

/*
 *  SYSID routines parameters block
 *  Pointed by the common routines block,
 *  when SYSID entries are handled
 */

typedef struct S_XB_PB_SYSID_rtnparms {
   char                       eyec[5];           /*   XBSP */
   XBhandle_rec_typ         * p_XBhandle;
   /* WS10079
   XB_InsertSYSID_parms_typ * insert_parms;
   XB_GetSYSID_parms_typ    * get_parms;
   */
   XB_InsertSYSID_parms_typ   insert_parms;
   XB_GetSYSID_parms_typ      get_parms;
}  XB_PB_SYSID_rtnparms_rec_typ, * XB_PB_SYSID_rtnparms_rec_ptr;

/*
 *  "record only" routines parameters
 */

/*   Insert routines parameters                                      */
typedef  struct  S_XB_InsertRec_parms {
   char         * xref_rec;
}  XB_InsertRec_parms_typ, *  XB_InsertRec_parms_ptr;

/*   Get routines parameters                                         */
typedef  struct  S_XB_GetRec_parms {
   char             Function[9];            /* UIDTHIS/UIDNEXT*/
   char          ** out_xref_rec;
}  XB_GetRec_parms_typ, *  XB_GetRec_parms_ptr;

/*  "only record"  routines parameters block                         */
typedef struct S_XB_PB_onlyrec_rtnparms {
   char                      eyec[5];        /*   XBRP */
   XBhandle_rec_typ        * p_XBhandle;
   /* WS10079N
   XB_InsertRec_parms_typ  * insert_parms;
   XB_GetRec_parms_typ     * get_parms;
   */
   XB_InsertRec_parms_typ    insert_parms;
   XB_GetRec_parms_typ       get_parms;
}  XB_PB_onlyrec_rtnparms_rec_typ, * XB_PB_onlyrec_rtnparms_rec_ptr;

typedef struct XB_SYSID_PBhandle
{
   char                     eyec[5];           /*   XBSE       */
   PERM_BLK_UID_rec_typ   * currXREF;
   XB_SYSID_entry_rec_typ * curSYSIDinBlk;
   int                      sysidEOF;          /* TRUE / FALSE */
} XB_SYSID_PBhandle_rec_typ,    * XB_SYSID_PBhandle_rec_ptr;

/* End   WS10079T  */
 /* * * * * * * * * * * * * WS10079A END  * * * * * * * * * * * * */
/* WS10084 start */
typedef struct PB_Build_Request {
  PBhandle_typ      * Groups_PBhandle_ptr;      /* Groups PBhandle */
  PBhandle_typ      * Users_PBhandle_ptr;       /* Users  PBhandle */
  XBhandle_rec_typ  * Roles_XBhandle_ptr;       /* Roles  XBhandle */
  char                lid[ACF2_LID_SIZE]; /* of single user  */
  char                resource_name [MAX_RSS_RESOURCE_NAME_LEN + 1];
  char                resource_type [MAX_RSS_RESTYPE_NAME_LEN + 1];
  char                WithPermissions;
  /* the following flags are set to true only when the
     corresponding PB block is also provided.
     Shorthand notations blow:
     AGGR:X for which transaction these permissions may be requested.
      X is one of the following:
      G: Group /get group
      A: Account /get user
      R: Roles /get role
     PB: X In which PB these permissions will be chained.
      G: Groups
      U: Users
      R: Roles */
  int                 GroupDirect;         /* TRUE/FALSE AGGR:G PB:G */
  int                 AccountDirect;       /* TRUE/FALSE AGGR:A PB:U */
  int                 AccountIndirect;     /* TRUE/FALSE AGGR:A PB:G */
  int                 AccountRoleDirect;   /* TRUE/FALSE AGGR:A PB:U */
  int                 AccountRoleIndirect; /* TRUE/FALSE AGGR:A PB:R */
  int                 RoleDirect;          /* TRUE/FALSE AGGR:R PB:R */

  int                 SingleUser;          /* TRUE/FALSE             */
  int                 PB_rules_nf;         /* TRUE/FALSE             */
  int                 PB_xref_nf;          /* TRUE/FALSE             */
  int                 PBbldErr;            /* TRUE/FALSE             */
  int                 PBErr;               /* TRUE/FALSE             */
  char                RequiredRoles;       /* NULL_CHAR: no          */
} PB_Build_Request_typ,  * PB_Build_Request_ptr;

/* WS10084 end   */
/* WS10084 LID_PERM_handle  moved here from above        WS10084 */
/***********************************************************************
 *  LID_PERM_handle - LID Permissions handle                           *
 *  This is the main control block used to handle permission for       *
 *  users. This handle is used by several routines which handle account*
 *  aggregation or the SYNC user process.                              *
 **********************************************************************/

/*  Values for  RequiredPermissions                      WS10078T */
#define  PERM_TYPE_LID        'L'                     /* WS10078S */
#define  PERM_TYPE_ROLE       'R'                     /* WS10078T */
/* WS10084
#define  INACT_BLOCK   (XREF_REC_BLK_rec_typ*) 0xFFFFFFFF /* BS10108T @/
   WS10084 */
typedef struct LID_PERM_handle {
     char                         lid[ACF2_LID_SIZE];
     PB_Build_Request_typ       * PB_Req;                 /* WS10084 */
     /*LID_RULE_AREA_vec_rec_typ  * lidra_vec;               WS10084 */
     int                          lidra_vec_num;
     void                       * rule_type_perm_vec;
     int                          error;
     char        RequiredPermissions; /* L-LID/R-Role        WS10078T */
     char        RequiredRoles;       /* R-Roles/A-All       WS10078T */
     char        RequiredSources;     /* S-Sources/A-ALL     WS10078T */
     /* WS10079N XREF_REC_BLK_rec_typ  * RolesBlk; /@   WS10078T @/   */
     /* WS10079N XREF_REC_BLK_rec_typ  * SourcesBlk; /@  WS10078T @/  */
     int         Source_error;                           /* BS10110   */
     int         Role_error;                             /* BS10110   */
     int         Source_nf;                              /* WS10079N  */
     int         Role_nf;                                /* WS10079N  */
     void                       * get_user_xrol_handle;     /*WS10079A*/
     void                       * get_user_xsgp_handle;     /*WS10079A*/
} LID_PERM_handle_rec_typ,  *LID_PERM_rec_handle_ptr;

 /**************************************************************
 * DATA AREAS for GLOBAL PARAMETERS Processing                 *
 **************************************************************/

#ifdef ACF2_GLOBAL_PARAMETERS_DEFINITIONS

static ADDINFO_RKTE_rec_typ rkt[] = {
   "PSWD.MINPSWD",         /* from RSS_PARAMS structure */
   ""              /* a null string indicate end-of-rkt */
 };

/*
 *     MKT for GSO
 *         (Mandatory Keywords Table)
 */

static ADDINFO_MKTE_rec_typ mkt[] = {
       ""         /* a null string indicate end-of-mkt */
 };

/*
 *     KDT for GSO
 *         (Keyword Decscription Table)
 */

static ADDINFO_KDTE_rec_typ OPTS_kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"BLPLOG"             ,KDT_FLG ,"NOBLPLOG"           ,""  , "" },
  {"CACHE"              ,KDT_FLG ,"NOCACHE"            ,""  , "" },
  {"CMDREC"             ,KDT_FLG ,"NOCMDREC"           ,""  , "" },
  {"CONSOLE"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"CPF"                ,KDT_FLG ,"NOCPF"              ,""  , "" },
  {"CPUTIME"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"DATE"               ,KDT_KEY ,""                   ,"(" , ")"},
  {"DDB"                ,KDT_FLG ,"NODDB"              ,""  , "" },
  {"DFTLID"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"DFTSTC"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"DDB"                ,KDT_FLG ,"NODDB"              ,""  , "" },
  {"INFOLIST"           ,KDT_KEY ,""                   ,"(" , ")"},
  {"JOBCK"              ,KDT_FLG ,"NOJOBCK"            ,""  , "" },
  {"MODE"               ,KDT_KEY ,""                   ,"(" , ")"},
  {"MAXVIO"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"NOTIFY"             ,KDT_FLG ,"NONOTIFY"           ,""  , "" },
  {"PRIMARY"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"SECONDARY"          ,KDT_KEY ,""                   ,"(" , ")"},
  {"RPTSCOPE"           ,KDT_FLG ,"NORPTSCOPE"         ,""  , "" },
  {"SHRDASD"            ,KDT_FLG ,"NOSHRDASD"          ,""  , "" },
  {"STAMPSMF"           ,KDT_FLG ,"NOSTAMPSMF"         ,""  , "" },
  {"STC"                ,KDT_FLG ,"NOSTC"              ,""  , "" },
  {"SYSPLEX"            ,KDT_FLG ,"NOSYSPLEX"          ,""  , "" },
  {"TAPEDSN"            ,KDT_FLG ,"NOTAPEDSN"          ,""  , "" },
  {"TEMPDSN"            ,KDT_FLG ,"NOTEMPDSN"          ,""  , "" },
  {"TNGMON"             ,KDT_FLG ,"NOTNGMON"           ,""  , "" },
  {"UADS"               ,KDT_FLG ,"NOUADS"             ,""  , "" },
  {"XBM"                ,KDT_FLG ,"NOXBM"              ,""  , "" },
  {"VTAMOPEN"           ,KDT_FLG ,"NOVTAMOPEN"         ,""  , "" },
  {""                   ,KDT_FLG ,""          ,""  ,""           }
  }; /* PS0325-Added CPF,SYSPLEX,TEMPDSN,TNGMON */

static ADDINFO_KDTE_rec_typ PSWD_kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"MAXTRY"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"MINPSWD"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"PASSLMT"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDALT"            ,KDT_FLG ,"NOPSWDALT"          ,""  , "" },
  {"PSWDFRC"            ,KDT_FLG ,"NOPSWDFRC"          ,""  , "" },
  {"PSWDHST"            ,KDT_FLG ,"NOPSWDHST"          ,""  , "" },
  {"PSWDJES"            ,KDT_FLG ,"NOPSWDJES"          ,""  , "" },
  {"PSWDLID"            ,KDT_FLG ,"NOPSWDLID"          ,""  , "" },
  {"PSWDNCH"            ,KDT_FLG ,"NOPSWDNCH"          ,""  , "" },
  {"PSWDNUM"            ,KDT_FLG ,"NOPSWDNUM"          ,""  , "" },
  {"PSWDREQ"            ,KDT_FLG ,"NOPSWDREQ"          ,""  , "" },
  {"PSWDRSV"            ,KDT_FLG ,"NOPSWDRSV"          ,""  , "" },
  {"PSWDXTR"            ,KDT_FLG ,"NOPSWDXTR"          ,""  , "" },
  {"WRNDAYS"            ,KDT_KEY ,""                   ,"(" , ")"},
  /* WS2565 : start here */
  {"PSWDALPH"           ,KDT_FLG ,"NOPSWDALPH"         ,"" , ""},
  {"PSWDMAX"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDMAXL"           ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDMIN"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDMIXD"           ,KDT_FLG ,"NOPSWDMIXD"         ,"" , ""},
  {"PSWDNMIC"           ,KDT_FLG ,"NOPSWDNMIC"         ,"" , ""},
  {"PSWDPAIR"           ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDPLST"           ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDSIM"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"PSWDSPLT"           ,KDT_FLG ,"NOPSWDSPLT"         ,"" , ""},
  {"PSWDVFY"            ,KDT_FLG ,"NOPSWDVFY"          ,"" , ""},
  {"PSWDVOWL"           ,KDT_FLG ,"NOPSWDVOWL"         ,"" , ""},
  {"PSWNAGE"            ,KDT_FLG ,"NOPSWNAGE"          ,"" , ""},
  {"PSWXHIST"           ,KDT_FLG ,"NOPSWXHIST"         ,"" , ""},
  {"PSWXHST@"           ,KDT_KEY ,"" /*ws10006*/       ,"(" , ")"},
  /* PSWXHST@ <==> PSWXHST# (# isn't supported in ESS) ws10006 */
  /* PSWXHSTN is known as PSWXHST# (# isn't supported in ESS)  */
  /* WS2565 : end here */
  {""                   ,KDT_FLG ,""                   ,""  ,""   }
  }; /* PS0325-Added PSWDHST,PSWDLID,PSWDNCH,PSWDNUM,PSWDREQ,PSWDRSV */

/*** password phrase KDT *** IS10147A start ***/
static ADDINFO_KDTE_rec_typ PWPHRASEG_kdt[] =  {
 /* keyword             type   negative val   value delimiters */
 /* =================== ====== ============== ================ */
  {"MINLEN"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"HISTORY"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"REPCHAR"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"SPECLIST"           ,KDT_KEY ,""                   ,"(" , ")"},
  {""                   ,KDT_FLG ,""                   ,""  ,""   }
  };
/*** password phrase KDT *** IS10147A end   ***/

static ADDINFO_KDTE_rec_typ RULEOPTS_kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"ACCRULE"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"CENTRAL"            ,KDT_FLG ,"NOCENTRAL"          ,""  , "" },
  {"CHANGE"             ,KDT_FLG ,"NOCHANGE"           ,""  , "" },
  {"DECOMP"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"$NOSORT"            ,KDT_FLG ,"NO$NOSORT"          ,""  , "" },
  {"PATHTRAN"           ,KDT_FLG ,"NOPATHTRAN"         ,""  , "" },
  {"RSCDIR"             ,KDT_KEY ,""                   ,"(" , ")"},
  {"RSCRULE"            ,KDT_KEY ,""                   ,"(" , ")"},
  {"RULELONG"           ,KDT_FLG ,"NORULELONG"         ,""  , "" },
  {"VOLRULE"            ,KDT_FLG ,"NOVOLRULE"          ,""  , "" },
  {""                   ,KDT_FLG ,""                   ,""  ,""  },
  }; /* PS0325-Added RULELONG */

static ADDINFO_KDTE_rec_typ EXITS_kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"DSNGEN"             ,KDT_KEY ,"DSNGEN()"           ,"(" , ")"},
  {"DSNPOST"            ,KDT_KEY ,"DSNPOST()"          ,"(" , ")"},
  {"EXPPXIT"            ,KDT_KEY ,"EXPPXIT()"          ,"(" , ")"},
  {"INFOPRE"            ,KDT_KEY ,"INFOPRE()"          ,"(" , ")"},
  {"INFOPST"            ,KDT_KEY ,"INFOPST()"          ,"(" , ")"},
  {"LGNIXIT"            ,KDT_KEY ,"LGNIXIT()"          ,"(" , ")"},
  {"LGNPARM"            ,KDT_KEY ,"LGNPARM()"          ,"(" , ")"},
  {"LGNPXIT"            ,KDT_KEY ,"LGNPXIT()"          ,"(" , ")"},
  {"LGNTERM"            ,KDT_KEY ,"LGNTERM()"          ,"(" , ")"},
  {"LIDLOC"             ,KDT_KEY ,"LIDLOC()"           ,"(" , ")"},
  {"LIDMOD"             ,KDT_KEY ,"LIDMOD()"           ,"(" , ")"},
  {"LIDPOST"            ,KDT_KEY ,"LIDPOST()"          ,"(" , ")"},
  {"LIDPRE"             ,KDT_KEY ,"LIDPRE()"           ,"(" , ")"},
  {"NEWPXIT"            ,KDT_KEY ,"NEWPXIT()"          ,"(" , ")"},
  {"PGMOVRD"            ,KDT_KEY ,"PGMOVRD()"          ,"(" , ")"},
  {"RSCXIT1"            ,KDT_KEY ,"RSCXIT1()"          ,"(" , ")"},
  {"RSCXIT2"            ,KDT_KEY ,"RSCXIT2()"          ,"(" , ")"},
  {"RULEPRE"            ,KDT_KEY ,"RULEPRE()"          ,"(" , ")"},
  {"RULEPST"            ,KDT_KEY ,"RULEPST()"          ,"(" , ")"},
  {"SEVPOST"            ,KDT_KEY ,"SEVPOST()"          ,"(" , ")"},
  {"SEVPRE"             ,KDT_KEY ,"SEVPRE()"           ,"(" , ")"},
  {"SRCXIT"             ,KDT_KEY ,"SRCXIT()"           ,"(" , ")"},
  {"STCXIT"             ,KDT_KEY ,"STCXIT()"           ,"(" , ")"},
  {"SVCIXIT"            ,KDT_KEY ,"SVCIXIT()"          ,"(" , ")"},
  {"VIOEXIT"            ,KDT_KEY ,"VIOEXIT()"          ,"(" , ")"},
  {"VLDEXIT"            ,KDT_KEY ,"VLDEXIT()"          ,"(" , ")"},
  {""                   ,KDT_FLG ,""                   ,""  ,""  },
  }; /* BS2367 - Added negative values to all keywords */

/* PS0325 - Added RESWORD record support */
static ADDINFO_KDTE_rec_typ RESWORD_kdt[] =      {

 /*                                                            */
 /* keyword             type   negative       value delimiters */
 /*                             value                          */
 /* =================== ====== ============== ================ */

  {"PREFIXES"           ,KDT_KEY ,""                   ,"(" , ")"},
  {""                   ,KDT_FLG ,""                   ,""  ,""  },
  };

  typedef struct {
    char                  *gso_name;
    ADDINFO_KDTE_rec_typ  *gso_kdt ;
    } GSO_KDT;

  static GSO_KDT gso_kdts[] =      {

   /*                                                            */
   /* RECORD NAME         KDT                                    */
   /*                                                            */
   /* =================== ======                                 */

    {"OPTS"    ,(void *)   &OPTS_kdt                 /*1lalal*/     },
    {"PSWD"    ,(void *)   &PSWD_kdt                 /*SAS2IBMA*/   },
    {"PWPHRASE",(void *)   &PWPHRASEG_kdt            /*IS10147A*/   },
    {"RULEOPTS",(void *)   &RULEOPTS_kdt             /*SAS2IBMA*/   },
    {"EXITS"   ,(void *)   &EXITS_kdt                /*SAS2IBMA*/   },
    {"RESWORD" ,(void *)   &RESWORD_kdt              /*SAS2IBMA*/   },
    {""                   ,NULL                                     }
    } ; /* PS0325 - Added RESWORD record */
 #endif

 /**************************************************************
 * WS2370 added KDT definitions for ACF2 User Profiles         *
 **************************************************************/
 /* CERTDATA is not supported - dropped by WS10005 */
 static ADDINFO_KDTE_rec_typ CERTDATA_kdt[] =        {
    {"ACTIVE"          , KDT_KEY , "ACTIVE()"   ,"("    ,")"    },
    {"CERTID"          , KDT_KEY , "CERTID()" ,"(" ,")" },/*WS10005*/
    {"DSA"             , KDT_FLG , "NODSA"    ,"" ,"" },/*WS10005*/
    {"DSN"             , KDT_KEY , "DSN()"      ,"("    ,")"    },
    {"EXPIRE"          , KDT_KEY , "EXPIRE()"   ,"("    ,")"    },
    {"ICSF"            , KDT_FLG , "NOICSF"     ,"" ,"" },/*WS10005*/
    {"LABEL"           , KDT_KEY , "LABEL()"    ,"("    ,")"    },
    {"NEWLABEL"        , KDT_KEY , "NEWLABEL()" ,"("    ,")"    },
  /*{"ISSUERDN"        , KDT_KEY , "ISSUERDN()" ,"(",")"},/*WS10005*/
    {"PCICC"           , KDT_FLG , "NOPCICC"    ,"" ,"" },/*WS10005*/
    {"SUBJDN"          , KDT_KEY , "SUBJDN()"   ,"(",")"},/*WS10005*/
    {"TRUST"           , KDT_FLG , "NOTRUST"    ,""     ,""     },
    {"HITRUST"         , KDT_FLG , "NOTRUST"    ,"" ,"" },/*WS10005*/
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ CICS_kdt[] =        {
    {"FORCE"           , KDT_FLG , "NOFORCE"    ,""    ,""      },
    {"OPCLASS"         , KDT_KEY , "OPCLASS()"  ,"("    ,")"    },
    {"OPIDENT"         , KDT_KEY , "OPIDENT()"  ,"("    ,")"    },
    {"OPPRTY"          , KDT_KEY , "OPPRTY()"   ,"("    ,")"    },
    {"TIMEOUT"         , KDT_KEY , "TIMEOUT()"  ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ DCE_kdt[] =        {
    {"UUID"            , KDT_KEY , "UUID()"     ,"("    ,")"    },
    {"DCENAME"         , KDT_KEY , "DCENAME()"  ,"("    ,")"    },
    {"HOMEUUID"        , KDT_KEY , "HOMEUUID()" ,"("    ,")"    },
    {"HOMECELL"        , KDT_KEY , "HOMECELL()" ,"("    ,")"    },
    {"AUTOLOG"         , KDT_FLG , "NOAUTOLOG"  ,""    ,""      },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };
 /* KEYRING is not supported - dropped by WS10005 */
 static ADDINFO_KDTE_rec_typ KEYRING_kdt[] =        {
    {"DEFAULT"         , KDT_KEY , "DEFAULT()"  ,"("    ,")"    },
    {"RINGNAME"        , KDT_KEY , "RINGNAME()" ,"("    ,")"    },
    /* no support for changing keyring from ESS       WS10005
    {"NEWNAME"         , KDT_KEY , "NEWNAME()"  ,"("    ,")"    },*/
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ KERB_kdt[] =        {
    {"KERBNAME"        , KDT_KEY , "KERBNAME()" ,"("    ,")"    },
    {"DES"             , KDT_FLG , "NODES"    ,"" ,"" },/*WS10005*/
    {"DES3"            , KDT_FLG , "NODES3"   ,"" ,"" },/*WS10005*/
    {"DESD"            , KDT_FLG , "NODESD"   ,"" ,"" },/*WS10005*/
    {"KERB-VIO"        , KDT_KEY , "KERB-VIO()" ,"("    ,")"    },
    {"MAXTKTLF"        , KDT_KEY , "MAXTKTLF()" ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ KERBLINK_kdt[] =  {        /*WS10005*/
    {"KBLKNAME"        , KDT_KEY , "KBLKNAME()" ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ LANGUAGE_kdt[] =        {
    {"PRIMARY"         , KDT_KEY , "PRIMARY()"  ,"("    ,")"    },
    {"SECONDRY"        , KDT_KEY , "SECONDRY()" ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ LINUX_kdt[] =         { /*WS10005*/
    {"LINUXGRP"        , KDT_KEY , "LINUXGRP()" ,"("    ,")"    },
    {"LINUXHOM"        , KDT_KEY , "LINUXHOM()" ,"("    ,")"    },
    {"LINUXNAM"        , KDT_KEY , "LINUXNAM()" ,"("    ,")"    },
    {"LINUXPGM"        , KDT_KEY , "LINUXPGM()" ,"("    ,")"    },
    {"LINUXUID"        , KDT_KEY , "LINUXUID()" ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ LNOTES_kdt[] =        {
    {"SNAME"           , KDT_KEY , "SNAME()"    ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ NDS_kdt[] =        {
    {"UNAME"           , KDT_KEY , "UNAME()"    ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ NETVIEW_kdt[] =        {
    {"IC"              , KDT_KEY , "IC()"       ,"("    ,")"    },
    {"CONSNAME"        , KDT_KEY , "CONSNAME()" ,"("    ,")"    },
    {"SECCTL"          , KDT_KEY , "SECCTL()"   ,"("    ,")"    },
    {"MSGRECVR"        , KDT_FLG , "NOMSGRECVR" ,"("    ,")"    },
    {"NGMFADMN"        , KDT_FLG , "NONGMFADMN" ,"("    ,")"    },
    {"NTVCLASS"        , KDT_KEY , "NTVCLASS()" ,"("    ,")"    },
    {"DOMAINS"         , KDT_KEY , "DOMAINS()"  ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ OMVS_kdt[] =        {
    {"UID"             , KDT_KEY , "UID()"      ,"("    ,")"    },
    {"HOME"            , KDT_KEY , "HOME()"     ,"("    ,")"    },
    {"OMVSPGM"         , KDT_KEY , "OMVSPGM()"  ,"("    ,")"    },
    {"CPUTIME"         , KDT_KEY , "CPUTIME()"  ,"("    ,")"    },
    {"ASSIZE"          , KDT_KEY , "ASSIZE()"   ,"("    ,")"    },
    {"FILEPROC"        , KDT_KEY , "FILEPROC()" ,"("    ,")"    },
    {"PROCUSER"        , KDT_KEY , "PROCUSER()" ,"("    ,")"    },
    {"THREADS"         , KDT_KEY , "THREADS()"  ,"("    ,")"    },
    {"MMAPAREA"        , KDT_KEY , "MMAPAREA()" ,"("    ,")"    },
 /* WS10005 fix - start */
    {"MEMLIMIT"        , KDT_KEY , "MEMLIMIT()" ,"("    ,")"    },
    {"SHMEMMAX"        , KDT_KEY , "SHMEMMAX()" ,"("    ,")"    },
 /* WS10005 fix - end   */
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ OPERPARM_kdt[] =        {
    {"STORAGE"         , KDT_KEY , "STORAGE()"  ,"("    ,")"    },
    {"AUTH"            , KDT_KEY , "AUTH()"     ,"("    ,")"    },
    {"AUTO"            , KDT_KEY , "AUTO()"     ,"("    ,")"    },
    {"MFORM"           , KDT_KEY , "MFORM()"    ,"("    ,")"    },
    {"MSGLEVEL"        , KDT_KEY , "MSGLEVEL()" ,"("    ,")"    },
    {"MONITOR"         , KDT_KEY , "MONITOR()"  ,"("    ,")"    },
    {"ROUTCODE"        , KDT_KEY , "ROUTCODE()" ,"("    ,")"    },
    {"LOGCMD"          , KDT_KEY , "LOGCMD()"   ,"("    ,")"    },
    {"MIGID"           , KDT_KEY , "MIGID()"    ,"("    ,")"    },
    {"DOM"             , KDT_KEY , "DOM()"      ,"("    ,")"    },
    {"UD"              , KDT_KEY , "UD()"       ,"("    ,")"    },
    {"KEY"             , KDT_KEY , "KEY()"      ,"("    ,")"    },
    {"CMDSYS"          , KDT_KEY , "CMDSYS()"   ,"("    ,")"    },
    {"ALTGROUP"        , KDT_KEY , "ALTGROUP()" ,"("    ,")"    },
    {"OPERMSCP"        , KDT_KEY , "OPERMSCP()" ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ PASSWORD_kdt[] = { /*ws10006*/
    {"#PSWDCNT"        , KDT_KEY , "#PSWDCNT()" ,"("    ,")"    },
    {"#PWD-TOD"        , KDT_KEY , "#PWD-TOD"   ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ PWPHRASEU_kdt[] = { /* IS10147A */
    {"PWP-EXP"         , KDT_KEY , "NOPWP-EXP"  ,"("    ,")"    },
    {"PWP-HST"         , KDT_KEY , "PWP-HST()"  ,"("    ,")"    },
    {"PWP-TOD"         , KDT_KEY , "PWP-TOD()"  ,"("    ,")"    },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

 static ADDINFO_KDTE_rec_typ WORKATTR_kdt[] =        {
    {"WANAME"          , KDT_KEY , "WANAME()"   ,"("    ,")"    },
    {"WABLDG"          , KDT_KEY , "WABLDG()"   ,"("    ,")"    },
    {"WADEPT"          , KDT_KEY , "WADEPT()"   ,"("    ,")"    },
    {"WAROOM"          , KDT_KEY , "WAROOM()"   ,"("    ,")"    },
    {"WAADDR1"         , KDT_KEY , "WAADDR1()"  ,"("    ,")"    },
    {"WAADDR2"         , KDT_KEY , "WAADDR2()"  ,"("    ,")"    },
    {"WAADDR3"         , KDT_KEY , "WAADDR3()"  ,"("    ,")"    },
    {"WAADDR4"         , KDT_KEY , "WAADDR4()"  ,"("    ,")"    },
    {"WAACCNT"         , KDT_KEY , "WAACCNT()"  ,"("    ,")"    },
    {"REP"             , KDT_FLG , ""           ,""     ,""     },
    {""                , KDT_FLG , ""           ,""     ,""     }
    };

  typedef struct {
    char                  *UP_name;
    ADDINFO_KDTE_rec_typ  *UP_kdt ;
    } UP_KDT;

  static UP_KDT UP_kdts[] =      {

   /*                                                            */
   /* User Profile Sysid  KDT                                    */
   /*                                                            */
   /* =================== ======                                 */

    {"OMVS"               ,(void *) &OMVS_kdt      }, /* SAS2IBMT */
    {"CICS"               ,(void *) &CICS_kdt      }, /* SAS2IBMT */
    {"DCE"                ,(void *) &DCE_kdt       }, /* SAS2IBMT */
    {"KERB"               ,(void *) &KERB_kdt      }, /* SAS2IBMT */
    {"KERBLINK"           ,(void *) &KERBLINK_kdt  }, /* SAS2IBMT */
    {"CERTDATA"           ,(void *) &CERTDATA_kdt  }, /* SAS2IBMT */
    {"KEYRING"            ,(void *) &KEYRING_kdt   }, /* SAS2IBMT */
    {"LANGUAGE"           ,(void *) &LANGUAGE_kdt  }, /* SAS2IBMT */
    {"LINUX"              ,(void *) &LINUX_kdt     }, /* SAS2IBMT */
    {"LNOTES"             ,(void *) &LNOTES_kdt    }, /* SAS2IBMT */
    {"NDS"                ,(void *) &NDS_kdt       }, /* SAS2IBMT */
    {"NETVIEW"            ,(void *) &NETVIEW_kdt   }, /* SAS2IBMT */
    {"OPERPARM"           ,(void *) &OPERPARM_kdt  }, /* SAS2IBMT */
    {"PASSWORD"           ,(void *) &PASSWORD_kdt  }, /* SAS2IBMT */
    {"PWPHRASE"           ,(void *) &PWPHRASEU_kdt }, /* IS10147A */
    {"WORKATTR"           ,(void *) &WORKATTR_kdt  }, /* SAS2IBMT */
    {""                   ,NULL                              }
    } ;

 /**************************************************************
 * end ws2370                                                  *
 **************************************************************/

 /**************************************************************
 * KDT management functions                                    *
 **************************************************************/
 ADDINFO_KDTE_rec_ptr ACF2_Update_KDT (ADDINFO_KDTE_rec_ptr      ,
                                       ACF2_Get_Fields_Filter    ,
                                       ACF2_KDT_Processing_Option,
                                       ADMIN_PARAMS_rec_typ *    );


 ADDINFO_KDTE_rec_ptr  ACF2_build_KDT_from_ACFFDR(
                            ACF2_Get_Fields_Filter    ,
                            int                      *,
                            ADMIN_PARAMS_rec_typ *);    /* bs2607 */

 /**************************************************************
 * ACF2 Low-Level API                                          *
 **************************************************************/
 ACF2_API_Return_Codes ACF2_Get_User(char *lidmask,
                                     ACF2_Object_Mask lid_masked,
                                     char  *uidmask,
                                     char  *current_lid,
                                     ACF2_GetUser_Fields Get_Fields,
                                     char  *Get_Field_Vec,
                                     ADDINFO_rec_ptr,
      /* PS0321 */                   ACF2_Multi_UIDs_Mode_Type,
                                     char  *errmsg,
      /* bs2556 */                   ADMIN_PARAMS_rec_typ *);

 ACF2_API_Return_Codes ACF2_User_Exists (char     *lid,  /* bs2513 */
      /* bs2556 */                       ADMIN_PARAMS_rec_typ *);


 /* PS0234 */
 ESA_RC Init_ACE_Handle (ACF2_Get_ResACL_Handle **,
                         CTSAMSG_HANDLE_rec_typ *,
                         CTSAMSG_DEST_TABLE_rec_typ *);

 /* PS0234 */
 ESA_RC Check_ACE_UNTIL (ADDINFO_rec_ptr);

 /* PS0234 */
 void Fill_ACE_Keywords (ADDINFO_rec_ptr);

 /* PS0234 */
 void Fill_Res_Keywords (ADDINFO_rec_ptr);

 /* WS2358 */
 void ACF2_Set_Keyword_Value (char *,
                              char *,
                              ADDINFO_rec_ptr,
                              CTSAMSG_HANDLE_rec_typ *,
                              CTSAMSG_DEST_TABLE_rec_typ *);

 /* PS0234 */
 int ACES_Match (ACE_rec_typ *,
                 ADDINFO_rec_typ *,
                 ACE_rec_typ *,
                 ADDINFO_rec_typ *);

 /* PS0278 */
 ESA_RC Rule_Backup (char *,
                     char *,
                     char *,
                     ADMIN_PARAMS_rec_typ  *);

 /* PS0234 */
 ESA_RC Prepare_ACF2IN_File (FILE **,
                             CTSAMSG_HANDLE_rec_typ *,
                             CTSAMSG_DEST_TABLE_rec_typ *);

 /* PS0234 */
 ESA_RC Build_Ruleset (char *,                            /* WS2358 */
                       char *,                            /* WS2358 */
                       ADDINFO_rec_ptr,
                       FILE *,
                       CTSAMSG_HANDLE_rec_typ *,
                       CTSAMSG_DEST_TABLE_rec_typ *);

 /* PS0234 */
 ESA_RC Build_Rule_Entry (ACE_rec_typ *,
                          ADDINFO_rec_ptr,
                          RESTYPE_typ,
                          FILE *,
                          CTSAMSG_HANDLE_rec_typ *,
                          CTSAMSG_DEST_TABLE_rec_typ *);

 /* PS0234 */
 void ACF2_Filter_ADDINFO (char *,
                           ADDINFO_rec_ptr);
 /* PS0234 */
 ESA_RC Compile_Ruleset (char *,
                         char *,
                         ACF2_Replace_Rule_Type,
                         int,
                         char *,
                         char *,
                         ADMIN_PARAMS_rec_typ *);         /* PS0347 */

 /* PS0234 */
 ESA_RC Delete_Ruleset (char *,
                        char *,
                        char *,
                        CTSAMSG_HANDLE_rec_typ *,
                        CTSAMSG_DEST_TABLE_rec_typ *);

 /* PS0234 */
 ACF2_API_Return_Codes ACF2_Get_Resource(char *,
                                         ACF2_Object_Mask,
                                         char *,
                                         ACF2_Resource_Data_Type,
                                         ACF2_Get_ResACL_Handle *,
                                         ACF2_Get_Res_Handle *,
                                         char *,
                                         ACE_rec_typ *,
                                         ADDINFO_rec_ptr,
                                         char *,
                                         ADMIN_PARAMS_rec_typ *);

 /* WS2358 */
 ESA_RC ACF2_Automate (char *,
                       char *,
                       ACE_rec_typ *,
                       ADDINFO_rec_ptr,
                       ACF2_Get_ResACL_Handle *,
                       ADDINFO_rec_ptr,
                       ADDINFO_rec_ptr,
                       FILE *,
                       int *,
                       char *,
                       ACF2_Key_Cell_Typ *,
                       int,
                       char *,
                       char *,
                       ADMIN_PARAMS_rec_typ *);

 /* WS2358 */
 void Get_First_Qualifier (char *,
                           char *,
                           int);                          /* PS0398 */

 /* WS2358 */
 void Strip_First_Qualifier (char *,
                             char *);

 /* WS2358 */
 ESA_RC Prepare_KEYs_List (char *,
                           ACF2_Key_Cell_Typ *,
                           int *,
                           ADMIN_PARAMS_rec_typ *);

 /* WS2358 */
 int Most_Specific_Match (char *,
                          char *,
                          ACF2_Key_Cell_Typ *,
                          int,
                          ADMIN_PARAMS_rec_typ *);

 ACF2_API_Return_Codes ACF2_Get_GSO(char                 *recname,
                                    ADDINFO_rec_ptr      laddinfo,
                                    char                 *errmsg);

 ACF2_API_Return_Codes ACF2_Get_all_specific_user_profiles
                                 (char                       *recname,
                                  char                       *func,
                                  ADDINFO_rec_ptr            laddinfo,
                                  char                       *errmsg,
                                  ESA_DIAG_COMP_typ          comp,
                                  CTSAMSG_HANDLE_rec_typ     * msgs,
                                  CTSAMSG_DEST_TABLE_rec_typ * dest);

 ESA_RC ACF2_UP_switch_is_activated(char   *sysid,
                                    ADDINFO_rec_ptr       addinfo);

 ACF2_API_Return_Codes ACF2_UP_exists
                                 (char                       *recname,
                                  char                       *sysname,
                                  ESA_DIAG_COMP_typ          comp,
                                  CTSAMSG_HANDLE_rec_typ     * msgs,
                                  CTSAMSG_DEST_TABLE_rec_typ * dest);

 /**************************************************************
 * Global Data Area functions                                  *
 **************************************************************/
 ESA_RC ACF2_Set_Global_Data( ADMIN_PARAMS_rec_typ * admin_params,
                              ERR_STRUCT_rec_typ   * err);

 /* PS0234 */
 /* IS10178 We are adding admin_parms to the routine's parameter list
 void ACF2_Set_LID_In_UID(void);                                     */
 void ACF2_Set_LID_In_UID(ADMIN_PARAMS_rec_typ * admin_params);

 /* PS0234 */
 /* IS10178 We are adding another parm to the routine's parameter list
 int ACF2_Is_LID_In_UID(int *);                                      */
 int ACF2_Is_LID_In_UID(int *, int *);

 /* WS2358 */
 int ACF2_Is_Virtual_Resource(char *);

 void Global_ACF2_Date_Format(char *Date_Format);

 /* BS10076 int Global_Total_Wait_Lock_Time(void);                   */

 /* BS10076 int Global_Retry_Wait_Lock_Time(void);                   */

 int Global_UDB_Active(void);

/* WS10054  char *Global_Get_QNAME(void);  */

 /* WS2358 */
 void Global_Get_Virtual_Res(char *ResName);

 /**************************************************************
 * User Functions                                              *
 **************************************************************/
ACF2_API_Return_Codes  ACF2_Get_User_UID(char *lid,
                                         char *uid,
                                         char *current_lid,
                                         char *uidmask,
                                         char *uids_list, /* PS0339 */
                                         ADDINFO_rec_ptr laddinfo,
      /*bs2556*/                 ADMIN_PARAMS_rec_typ * admin_params);

ACF2_API_Return_Codes  ACF2_Refresh_User_UID(char *lid,
                                             OBJ_EXISTS_typ lid_exist,
                                             ADDINFO_rec_ptr laddinfo);

 /**************************************************************
 * GDB Processing                                              *
 **************************************************************/
GDB_Codes GDB_Set_Mode(GDB_Modes,
                       ADMIN_PARAMS_rec_typ * admin_params,
                       ERR_STRUCT_rec_typ   * err);

GDB_Codes GDB_Locate(char Record_Type,char *key, GDB_Locate_Mode mode);

GDB_Codes GDB_GetNext(char Record_Type,char *key);

GDB_Codes GDB_Insert(void);

GDB_Codes GDB_Update(void);

GDB_Codes GDB_Delete(void);

ESA_RC GDB_Convert_to_Record(char Record_Type,
                             char *Key,
                             ADDINFO_rec_ptr   addinfo);

ESA_RC GDB_Convert_from_Record(char *Record_Type,
                               char *Key,
                               ADDINFO_rec_ptr   addinfo);

GDB_Modes GDB_Get_Mode(void);                             /* BS10093 */

const char * GCM2str (GDB_Modes mode);                    /* BS10093 */

 /**************************************************************
 * UDB Processing                                              *
 **************************************************************/
 UDB_Codes UDB_Set_Mode(UDB_Modes,
                       ADMIN_PARAMS_rec_typ * admin_params,
                       ERR_STRUCT_rec_typ   * err);

 UDB_Codes UDB_Locate(URID urid, LID lid, UDB_Locate_Mode mode);
                                                          /* WS2338 */

 UDB_Codes UDB_GetNext(URID urid, LID lid, UID uid);      /* WS2338 */

 UDB_Codes UDB_Get_Next_User(URID urid, LID lid, UID uid); /* WS2338 */

 UDB_Codes UDB_Insert(URID urid, LID lid,  UID uid);      /* WS2338 */

 UDB_Codes UDB_Update(URID urid, LID lid,  UID uid);      /* WS2338 */

 UDB_Codes UDB_Delete(void);

ESA_RC ACF2_Get_Field_Information(char *field_name,
                                  char *field_type,
                                  char *field_rw    ,
                                  int  *field_length,
                                  int  *field_offset,
                                  char *field_multi,      /* WS2337 */
                                  int  *field_mvmax);     /* WS2337 */

void Get_ACFFDR_In_ESS_Format(char *,     /*bs2607*/      /* PS0321 */
                              ADMIN_PARAMS_rec_typ  *);   /* bs2607 */

 /**************************************************************
 * ACFFDR                                                      *
 **************************************************************/
void ACF2_Free_ACFFDR(void);               /* BS2509 */

 /**************************************************************
 * Group Processing functions                                  *
 **************************************************************/
 void Trunc_UIDMASKS(ADDINFO_rec_ptr);              /* PS0234 */

 void Trunc_Blanks(char *);                         /* bs2593 */

 void Trunc_One_UIDMASK(char *);                    /* PS0234 */

 ACF2_API_Return_Codes ACF2_Get_Group(GDB_Locate_Mode mode,
                                  UG_typ Group,
                                  ADDINFO_rec_ptr laddinfo,
                    /*WS10076S*/  ADDINFO_rec_ptr addinfo,
      /* WS10084    /*WS10076S@/  PBhandle_typ * PBh, */
                    /*WS10084 */  PB_Build_Request_typ * PB_Req,
                    /*WS10076S*/  ADMIN_PARAMS_rec_typ * admin_params);

ESA_RC ACF2_Get_Group_UIDMASKS(char *group,
                               int  *Group_UID_Count,
                               UIDMASK Group_UID[1],
                               ADDINFO_rec_ptr laddinfo,
                               int  *reason_code,
                 /*WS10076A*/  ADMIN_PARAMS_rec_typ * admin_params);
                 /*WS10076A    CTSAMSG_DEST_TABLE_rec_typ  * dest,
                               CTSAMSG_HANDLE_rec_typ      * msgs); */
                          /* BS2306 - added dest+msgs parms         */

ESA_RC Check_Group_Correllation(UG_typ Group,
                                ADDINFO_rec_ptr addinfo,
                                UG_typ  cgroup,
                                ADDINFO_rec_ptr laddinfo,
                                CTSAMSG_DEST_TABLE_rec_typ  * dest,
                                CTSAMSG_HANDLE_rec_typ      * msgs,
                    /*IS10088*/ ADMIN_PARAMS_rec_typ * admin_params);
                          /* BS2306 - added dest+msgs parms         */

int ACF2_Match_User_Group(USER_typ User,
                            UG_typ   Group);

ESA_RC Check_Group_UIDMASKS(UG_typ                      group,
                            ADDINFO_rec_ptr             addinfo,
                            ADMIN_PARAMS_rec_typ *); /*IS10128*/
 /* drop by admin_params    CTSAMSG_DEST_TABLE_rec_typ  * dest,
    IS10128                 CTSAMSG_HANDLE_rec_typ      * msgs); */
 /**************************************************************
 * UID   Processing functions                                  *
 **************************************************************/
ESA_RC Generate_UID_Update(UID_Update_type Update_Type,
                           char *UID_User,
                           char *UID_Masks,
                           ADDINFO_rec_ptr uaddinfo,
                           ADDINFO_rec_ptr laddinfo,     /* WS10090 */
                           char  allow_collision);       /* WS10090 */
      /* WS10090           ADDINFO_rec_ptr laddinfo);   */

 /* PS0234 */
 int Is_UIDMASK_User (char *);

 /* PS0234 */
 ESA_RC Build_UIDMASK_User (char *,
                            char *);

 /* PS0234 */
 int Is_LID_In_UID (int *);

ESA_RC Calc_User_UID_String(USER_typ        user,         /* PS0354 */
                            ADDINFO_rec_ptr addinfo,
                            UIDMASK UID,
                            char   *UIDs_List,            /* PS0354 */
                            char    Init_UID_Char,
                            ADMIN_PARAMS_rec_typ *    );  /*bs2556*/

ESA_RC Convert_UID_Offset_to_Field_Name  (int   uid_offset,
                                          char  *field_name,
                                          int   *field_offset);

ESA_RC Check_User_Force_Disconnect_from_Group( UIDMASK old_uid,
                               UIDMASK new_uid,
                               UG_typ  cgroup,
                               ADDINFO_rec_ptr laddinfo,
  /*WS10076A*/                 ADMIN_PARAMS_rec_typ * admin_params);
  /*WS10076A                   CTSAMSG_DEST_TABLE_rec_typ  * dest,
                               CTSAMSG_HANDLE_rec_typ      * msgs);
                           * BS2306 - added dest+msgs parms         */

/* PS0354 */
ESA_RC Check_Mult_Force_Disconnect_from_Group( char *old_uids,
                               char *new_uids,
                               UG_typ  cgroup,
                               ADDINFO_rec_ptr laddinfo,
  /*WS10076A*/                 ADMIN_PARAMS_rec_typ * admin_params);
  /*WS10076A                   CTSAMSG_DEST_TABLE_rec_typ  * dest,
                               CTSAMSG_HANDLE_rec_typ      * msgs);

 int ACF2_Is_Part_Of_Multi (int,
                            char *,
                            int *,
                            int *);                       /* PS0345 */

 void ACF2_Get_UID_Info( char *                              ,
                         int *                               ,
                         UID_Structure *                     ,
                         char *,                          /* PS0321 */
                         ADMIN_PARAMS_rec_typ *);         /* bs2607 */

 int UID_Contains_MULTI (char *,
                         int *);                          /* PS0321 */

 ESA_RC Build_Multi_UIDs (char *,
                          char *,
                          int,
                          ADDINFO_rec_ptr,                /* PS0354 */
                          int *,                          /* PS0354 */
                          char *,                         /* bs2556 */
                          ADMIN_PARAMS_rec_typ *    );

 void Initialize_UID_Definitions(ADMIN_PARAMS_rec_typ  *); /*bs2607*/

 void Get_UID_In_ESS_Format(char *field);
 /**************************************************************
 * Service functions                                           *
 **************************************************************/
 ESA_RC Convert_Multi_to_Vec(char *, int *, char **, int, int *);
                          /*   BS2306 - added reason_code parm      */

 void Convert_Keyword_Chars(ADDINFO_rec_ptr addinfo,
                           char from_char,
                           char to_char);
 int Round_Number(int, int);

 char *Trim(char *string);

 void Reset_Field(char *,int,char,char *);

 int ACF2_Match_Id_to_Mask(ACF2_Object_Type object_type,
                           char *object,
                           char *mask);

 ESA_RC ACF2_Convert_Date_Fields(ADDINFO_rec_ptr          addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr   dest,
                           CTSAMSG_HANDLE_rec_ptr       msgs);

 ESA_RC ACF2_Convert_Access_Levels(ADDINFO_rec_ptr          addinfo,
                           CTSAMSG_DEST_TABLE_rec_ptr   dest,
                           CTSAMSG_HANDLE_rec_ptr       msgs);

 void convert_tod_to_YYYYMMDDHHMMSS(char *,char *);

 /*ws2431 moved from CTSBGCN */
 ACF2_API_Return_Codes ACF2_Get_User_Groups
              (GDB_Locate_Mode mode,
               char   *UID,
               UG_typ Group,
               ADDINFO_rec_ptr laddinfo,
               ADMIN_PARAMS_rec_typ * admin_params);   /*WS10076A*
               CTSAMSG_DEST_TABLE_rec_typ  * dest,
               CTSAMSG_HANDLE_rec_typ      * msgs);              */

 /**************************************************************
 * * * * * * * * * * * *  WS10067 Start  * * * * * * * * * * * *
 * These 3 prototypes were moved from CTSBGUG and CTSBSRV.     *
 *                                                             *
 * These 3 routines originally resided in CTSBGUG but were     *
 * moved to CTSBSRV so they can be used as a common routine    *
 * for CTSBGUG (during full group aggregation) and CTSBINT     *
 * (during single group interception).                         *
 **************************************************************/
/*  WS10076 - ACF2_Refresh_GDB is no longer used - remove
       ESA_RC ACF2_Refresh_GDB(
                           char                   * caller,
                           char                   * restype,
                           char                   * resname,
                           NEW_GRP_TABLE_rec_typ ** new_grp_table,
                           ADMIN_PARAMS_rec_typ   * admin_params,
                           ERR_STRUCT_rec_typ     * err);
    end of removed code      WS10076N */

       ACF2_API_Return_Codes ACF2_Clean_GDB(void);

       ESA_RC find_groups(
                           char                   * buffer,
                           ADDINFO_rec_ptr          caddinfo,
                           NEW_GRP_TABLE_rec_typ ** ngt_struct,
                           ADMIN_PARAMS_rec_typ   * admin_params);
 /* * * * * * * * * * * * * * WS10067  End * * * * * * * * * * * * * */

/* * * * * * * * * * * * * WS10075 start * * * * * * * * * * * * */


/* WS10076N - The definitions below were moved to CTSCCLI
/@
 @   Internal subroutines
 @/
typedef ESA_RC GET_LINE_TYP(char                * function,
                       void                     * inp_desc_blk,
                       void                    ** handle,
                       char                     * get_line_buffer,
                       int                       get_line_buffer_size,
                       ADMIN_PARAMS_rec_typ     * admin_params);


extern  GET_LINE_TYP   get_line;       /@ actual function @/

typedef GET_LINE_TYP * GET_LINE_PTR;   /@ pointer to func @/

extern  GET_LINE_TYP   Get_line_from_memory;
     End of moved code           */

/* WS10076N - remove because used as static
  *********************************************************************
 *  prototype for the Get_Rule_Record routine                         *
 *********************************************************************
ESA_RC Get_Rule_Record(char                   * function,
                       void                  ** handle,
                       GET_LINE_PTR             get_line_ptr,
                       void                   * inp_desc_blk,
                       WANTED_PERM_REC_rec_ptr  wanted_list,
                       Permission_Record_Type   req_rec_type,
                       int                      rule_record_len,
                       char                   * caller_code,
                       Permission_Record_Type * ret_rec_type,
                       char                   * rule_record,
                       char                   * resource_type,
                       ADMIN_PARAMS_rec_typ   * admin_params);

 **********************************************************************
 *  prototype for the ACF2_get_LID_rules routine                      *
 *********************************************************************
ESA_RC  ACF2_get_LID_rules (char                    * req_type,
                            LID_PERM_handle_rec_typ * lid_perm_handle,
                            ADMIN_PARAMS_rec_typ    * admin_params);
*/

/**********************************************************************
 *  prototype for the Get_user_permissions routine                    *
 *********************************************************************/
ESA_RC Get_user_permissions(char                     * LID,
    /* WS10084             LID_PERM_handle_rec_typ * lid_perm_handle,*/
    /* WS10084 */            PB_Build_Request_typ    * PB_Req,
                             ADDINFO_rec_ptr           addinfo,
                             char                    * call_type,
    /* WS10078T @//* WS10084 int                       index,        */
    /* BS10108T */           int                     * perms_exist,
                             ADMIN_PARAMS_rec_typ    * admin_params);

/*            start WS10078T                                         */
/* BS1008 - Remove definitions because the routines were changed to
            static
/@*********************************************************************
 *  prototype for the Get_User_XROL routine
 ********************************************************************@/
ESA_RC Get_User_XROL(
          char                       * inputLID,
          LID_PERM_handle_rec_typ    * lid_perm_handle,
          XREF_REC_BLK_rec_typ       * XREFBlk,
          ADDINFO_rec_ptr              addinfo,
          ADMIN_PARAMS_rec_typ       * admin_params);
/@*********************************************************************
 *  prototype for the Get_User_XSGP routine
 ********************************************************************@/
ESA_RC Get_User_XSGP(
                 char                     * inputLID,
                 XREF_REC_BLK_rec_typ     * XREFBlk,
                 ADDINFO_rec_ptr            addinfo,
                 ADMIN_PARAMS_rec_typ     * admin_params);
  end of remove  - BS10108  */

/**********************************************************************
 *  prototype for the XREF_Block_Build routine
 *********************************************************************/
/*  WS10079
ESA_RC XREF_Block_Build(
                 char                     * function,
                 XREF_REC_BLK_rec_ptr     * pXREFBlk1,
                 XREF_REC_BLK_rec_ptr     * pXREFBlk2,
                 char                       XREFType,
                 ADMIN_PARAMS_rec_typ     * admin_params);
    WS10079 */
/*               XREFType is XREF_REC_TYPE_xxx                       */

/* BS10108 - The following routines were changed to be external */
/**************** WS10078A ********************************************
 *  prototype for the XREF_Block_Find routine
 *********************************************************************/
/* WS10079T start (routine no longer used)
ESA_RC XREF_Block_Find(
                 char                     * XREFname,
                 XREF_REC_BLK_rec_typ     * XREFBlk,
                 char                     * IsGroup,
                 ADMIN_PARAMS_rec_typ     * admin_params);
   WS10079T */
/**************** WS10078A ********************************************
 *  prototype for the Parse_XREF_Record routine
 *********************************************************************/
EXT ESA_RC Parse_XREF_Record(                            /* BS10108 */
    /* BS10108              UG_PARAMS_rec_ptr       ug_params,   */
    /* WS10079              UG_typ                  group_name,  */
                            char                  * xname, /*WS10079*/
                            char                  * sysid, /*WS10079*/
                            ADDINFO_rec_ptr         addinfo,
                            char                  * xref_record,
    /* BS10108 */           char                    groupYN,
    /* BS10108 */           char                  * isitgrp,
                            ADMIN_PARAMS_rec_typ  * admin_params);

/* BS10108 - end */
/* WS10078KG - Start */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  prototype for Get_XREF_Record                        *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* WS10079N  routine changed to be static
EXT ESA_RC Get_XREF_Record(char          * function,
           Get_XREF_Rec_Handle          ** handle,
           REXX@UTL_output_blk_rec_typ   * ruob,
           char                          * output_area,
           int                             output_length,
           ADMIN_PARAMS_rec_typ          * admin_params);
   WS10079N */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  prototype for ACF2_Cmd2Mem                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* WS10079N EXT ESA_RC ACF2_Cmd2Mem(  */
ACF2_API_Return_Codes ACF2_Cmd2Mem(                  /* WS10079N */
                       char                            * rectype,
                       char                            * recparm,
                       REXX@UTL_output_ignlist_rec_typ * ignlist,
         /* BS10111    REXX@UTL_output_blk_rec_typ    ** p_ruob,  */
         /* BS10111 */ char                            * p_ruob,
                       ESA_DIAG_COMP_typ                 comp,
                       ADMIN_PARAMS_rec_typ            * admin_params);
/* WS10078KG - End */

/**************** WS10078A ********************************************
 *  prototype for the ACF2_Get_ACFRPTRX_Report
 *********************************************************************/
EXT ESA_RC  ACF2_Get_ACFRPTRX_Report(
                             char                    * req_type,
                             LID_PERM_handle_rec_typ * lid_perm_handle,
                             ADMIN_PARAMS_rec_typ    * admin_params);
 /* WS10079T start */
 /*********************************************************************
 *  prototype for the XREF_Block_Build                                *
 *********************************************************************/
 EXT    ESA_RC XREF_Block_Build(
         char                     * function,
         XBhandle_rec_typ         * XBhandle,
         ESA_DIAG_COMP_typ          diag_comp,
         ADMIN_PARAMS_rec_typ     * admin_params);
 /* WS10079T end   */
 /*********************************************************************
 *  prototype for the Get_Rule_Record routine                         *
 *********************************************************************/
ESA_RC         Get_Rule_Record(char             * function,
                         void                  ** handle,
/* BS10111               GET_LINE_PTR             get_line_ptr,     */
/* BS10111               void                   * inp_desc_blk, */
                         char                   * p_ruob, /* BS10111 */
/* WS10078S Phased out   WANTED_PERM_REC_rec_ptr  wanted_list,      */
                         Permission_Record_Type   req_rec_type,
/* WS10078S Change name  int                      rule_record_len,  */
/* WS10078S to . . . */  int                      return_buffer_len,
                         char                   * caller_code,
                         Permission_Record_Type * ret_rec_type,
/* WS10078S Change name  char                   * rule_record,      */
/* WS10078S to . . . */  char                   * return_buffer,
                         char                   * resource_type,
                         ADMIN_PARAMS_rec_typ   * admin_params);
/*           end    WS10078T                                         */
/* WS10076N - remove because used as static
 **********************************************************************
 *  prototype for the Is_This_A_Perm_Line routine                     *
 *********************************************************************
int Is_This_A_Perm_Line(char                 * get_line_buffer,
                        char                 * rule_type,
                        char                 * caller_code,
                        ADMIN_PARAMS_rec_typ * admin_params);

 **********************************************************************
 *  prototype for the Perm_Continuation_Handler routine               *
 *********************************************************************
int Perm_Continuation_Handler(char            * caller_code,
                              GET_LINE_PTR      get_line_ptr,
                              char            * function,
                              void            * inp_desc_blk,
                              void            * get_line_handle,
                              char            * input_buffer,
                              char            * prev_line_read,
                              char            * rule_type,
                              char            * complete_perm_area,
                              int               complete_perm_area_size,
                         ADMIN_PARAMS_rec_typ * admin_params);
*/

void  GLR_del_mods(ADMIN_PARAMS_rec_typ    * admin_params);

/**********************************************************************
 *  prototype for the Permission_dsnrsrc_key_prefix_handler routine   *
 *********************************************************************/
EXT ESA_RC Permission_dsnrsrc_key_prefix_handler(
                                 char             * request,
                                 char             * input,
                                 char             * resource_type_attr,
                                 char             * key_attr,
                                 int                key_len,
                                 char             * prefix_attr,
                                 int                prefix_len,
                                 char             * resource_attr,
                                 int                resource_attr_len,
                                 char             * keyprefix_attr,
                                 int                keyprefix_attr_len,
               /* WS10084 */     char               is_direct_perm,
               /* WS10084 */     char               group_or_user,
               /* WS10084 */     int                roleset_permission,
                                 ESA_DIAG_COMP_typ  comp,
                                 ADMIN_PARAMS_rec_typ * admin_params);

/* * * * * * * * * * * * * WS10075 end * * * * * * * * * * * * * */

/*   WS10076N - start */

/*********************************************************************
 * Procedure Name: Permissions_block_Build
 *********************************************************************/
EXT ESA_RC Permissions_block_Build(char                 * function,
                  /* WS10084    PBhandle_typ            * PBhandle, */
                  /* WS10084 */ PB_Build_Request_typ    * PB_Req,
                                ESA_DIAG_COMP_typ         comp,
                                ADMIN_PARAMS_rec_typ    * admin_params);

/*   WS10076N - end */
/*  WS10076K - start */
/*********************************************************************
 * Procedure Name: Permissions_block_Get
 *********************************************************************/
EXT ESA_RC Permissions_block_Get(char                  * function,
                              PBhandle_typ             * PBhandle,
                              char                     * UID,
                              char                     * perm_data,
                              int                        perm_buff_len,
                              ESA_DIAG_COMP_typ          comp,
                              ADMIN_PARAMS_rec_typ     * admin_params);
/* WS10076K - end */
/* WS10079N  - Moved from CTSBPHR and chnaged to EXT  */
/**********************************************************************
 *  prototype for the Permissions_block_Print routine
 *********************************************************************/
EXT ESA_RC Permissions_block_Print(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params);
/* WS10079N - end */

/* WS10079T  - Start */
/*********************************************************************
 * Procedure Name: Permissions_block_Insert
 *********************************************************************/
/* moved from CTSBPHR and changed to EXT                             */
EXT ESA_RC Permissions_block_Insert(
                                 PERM_BLK_HDR_rec_typ * PBheader,
                                 char                 * UID,
                                 char                 * perm_data,
                                 ESA_DIAG_COMP_typ      comp,
                                 ADMIN_PARAMS_rec_typ * admin_params);
/**********************************************************************
 *  prototype for the XREF_Validate_Name routine
 *********************************************************************/
EXT ESA_RC XREF_Validate_Name(
                    char                 * xrefname,
                    ESA_DIAG_COMP_typ      comp,
                    ADMIN_PARAMS_rec_typ * admin_params);
/**********************************************************************
 *  prototype for the XREF_Set_Command_SYSID routine
 *********************************************************************/
ESA_RC XREF_Set_Command_SYSID(
              char                     * pCommand,
              char                     * pXREFname,
              char                     * pSYSID,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params);
/**********************************************************************
 *  prototype for the XREF_Split_Name routine
 *********************************************************************/
EXT ESA_RC XREF_Split_Name(
              char                     * pFullName,
              char                     * pXREFname,
              char                     * pSYSID,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params);
/**********************************************************************
 *  Structures for parameters of XREF_Extract_Inc_Exc_Lists and
 *  XREF_Commands_Create routines
 *********************************************************************/
 typedef struct {
 char     * add_list;
 char     * del_list;
 char     * rep_list;
 } XREF_Operations_Lists_typ, * XREF_Operations_Lists_ptr;

 typedef struct {
 char     * add_command;
 char     * del_command;
 char     * rep_command;
 char     * ref_command;
 } XREF_Cmd_Struct_typ, * XREF_Cmd_Struct_ptr;

/**********************************************************************
 *  prototype for the XREF_Extract_Inc_Exc_Lists routine
 *********************************************************************/
EXT ESA_RC XREF_Extract_Inc_Exc_Lists(
                  ADDINFO_rec_typ      * addinfo,
                  XREF_Operations_Lists_typ ** include_op_lists,
                  XREF_Operations_Lists_typ ** exclude_op_lists,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params);

/**********************************************************************
 *  prototype for the XREF_Commands_Create routine
 *********************************************************************/
EXT ESA_RC XREF_Commands_Create(
                  char                 * type,
                  ADDINFO_rec_typ      * addinfo,
                  char                 * xref_name,
                  char                 * command_name,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
                  XREF_Cmd_Struct_typ  * xref_command_struct,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params);
/**********************************************************************
 *  prototype for the XREF_Commands_Restore routine
 *********************************************************************/
EXT ESA_RC XREF_Commands_Restore(
                  char                 * type,
                  char                 * xref_name,
                  char                 * command_ops_to_restore,
                  XREF_Operations_Lists_typ * include_op_lists,
                  XREF_Operations_Lists_typ * exclude_op_lists,
  /* WS10079N */  XREF_Cmd_Struct_typ       * xref_command_struct,
                  ESA_DIAG_COMP_typ      diag_comp,
                  ADMIN_PARAMS_rec_typ * admin_params);
/**********************************************************************
 *  prototype for the Drop_Perms_Match routine
 *********************************************************************/
EXT ESA_RC Drop_Perms_Match(
                  char                       * parm,
                  char                       * filter,
                  char                       * entity,
                  char                         etype,
                  char                       * ftype,
                  ESA_DIAG_COMP_typ            diag_comp,
                  ADMIN_PARAMS_rec_typ       * admin_params);
/* WS10079T  - End   */
/* WS10079A  - Start */
/*********************************************************************
 * Procedure Name: Permissions_Block_updateIndex prototype
 *********************************************************************/
EXT ESA_RC Permissions_Block_updateIndex(
                      PERM_BLK_HDR_rec_typ    ** PBheader,
                      int                        last_call,
                      ESA_DIAG_COMP_typ          comp,
                      ADMIN_PARAMS_rec_typ     * admin_params);
/**********************************************************************
 *  prototype for the Permissions_block_Free routine
 *********************************************************************/
EXT ESA_RC Permissions_block_Free(
                 PERM_BLK_HDR_rec_typ     * PBheader,
                 ESA_DIAG_COMP_typ          comp,
                 ADMIN_PARAMS_rec_typ     * admin_params);

/* WS10079N - moved here all the definitions of the XREF Block
 *            extensions routines and defined them using the  .
 *            general PB_ext_rtn_typ typedef which is common to
 *            all the routines.
/**********************************************************************
 *  prototype for the XREF_Block_xxxSYSID routines
 *********************************************************************/
EXT  PB_ext_rtn_typ  XREF_Block_GetSYSID;
EXT  PB_ext_rtn_typ  XREF_Block_InsertSYSID;
EXT  PB_ext_rtn_typ  XREF_Block_PrintSYSID;
EXT  PB_ext_rtn_typ  XREF_Block_FreeSYSID;

/**********************************************************************
 *  prototype for the XREF_Block_xxxRec routines
 *********************************************************************/
EXT  PB_ext_rtn_typ  XREF_Block_GetRec;
EXT  PB_ext_rtn_typ  XREF_Block_InsertRec;
EXT  PB_ext_rtn_typ  XREF_Block_PrintRec;
EXT  PB_ext_rtn_typ  XREF_Block_FreeRec;

/**********************************************************************
 *  prototype for the XREF_Block_UpdateSYSID routine
 *********************************************************************/
EXT ESA_RC XREF_Block_UpdateSYSID(
              PERM_BLK_UID_rec_typ     * UID,
              XB_SYSID_entry_rec_typ   * SYSID,
              char                       activeYNU,
              ESA_DIAG_COMP_typ          comp,
              ADMIN_PARAMS_rec_typ     * admin_params);
/***************** WS10079A end ***************************************

/* WS10079K  - Start */
/**********************************************************************
 *  Prototype for the ACF2_Get_Xref routine
 *********************************************************************/
EXT ACF2_API_Return_Codes ACF2_Get_Xref(
                       char                   * function,
                       XBhandle_rec_typ       * XBhandle,
                       void                  ** xref_handle,
                       char                     block_to_read,
                       char                   * block_read,
                       UG_typ                   xrefname_in,
                       UG_typ                   xrefname_out,
                       ADDINFO_rec_ptr          addinfo,
                       ESA_DIAG_COMP_typ        diag_comp,
                       ADMIN_PARAMS_rec_typ   * admin_params);
/* WS10079K  - End   */
#endif  /* ACF2_H_included */
