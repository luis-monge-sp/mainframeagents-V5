/**************************************************************
*                                                             *
* Title            : Additional Info Manipulation Routines    *
*                                                             *
* File Name        : ctsradi.c                                *
*                                                             *
* Author           : Doron Cohen                              *
*                                                             *
* Creation Date    : 21/03/94                                 *
*                                                             *
* Description      :                                          *
*                                                             *
* Assumptions and                                             *
*   Considerations :                                          *
*                                                             *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------  -------------------------------- *
* AS0903   A.Shv    09/03/95 Added new function :             *
*                            ADDINFO_clear_value              *
*                                                             *
* spr125   Alex     07/09/95 Change duplicate quates logic    *
*                                                             *
* AS0207   Alex     02/07/96 ADDINFO_insert. addinfo overflow *
*                            rc = ESA_FATAL instead ESA_ERR   *
* ps0009   Alex     10/10/96 New list's fields separator      *
*                            See ADDINFO_addval, _list_search *
*                            _list_diff and ALL calls to this *
*                            functions                        *
* ps0106   Alex     18/06/97 Add new functions :              *
*                            ADDINFO_masupd                   *
*                            ADDINFO_copy_by_prefix           *
* ps0145   Yishay   09/07/97 Add new functions :              *
*                            ADDINFO_expand_from_buffer       *
*                            ADDINFO_pack_to_buffer           *
* ps0161   Alex     27/07/97 Fix bug in function :            *
*                            ADDINFO_convert_list_sep         *
* ps0288   Alex     09/07/98 Add parameter to :               *
*                            ADDINFO_dup_check                *
*                            ADDINFO_prefix_search            *
* ps0292   AS       24/07/98 Digital certificate support      *
* PS0349   Guy      06/12/98 Add quotes for each multivalued  *
*                            field value                      *
* PS0352   Guy      08/12/98 Handle NULL values correctly     *
* PS0537   ShmuelK  06/10/02 Change name of pointer variable  *
* IS0208   AmirH    30/12/03 Add ADDINFO_value_addval function*
* IS0212   AmirH    06/01/04 Do not add separator to emtpy    *
*                            value string                     *
* IS10094  NuritY   11/06/13 BS10032 changes:                 *
*                            1. Incorrect length check whe    *
*                               update value.                 *
*                            2. Entries have incorrect type   *
*                               after deleting an entry,      *
*                               because the type field is not *
*                               copied when compressing the   *
*                               list.                         *
* IS10100  NuritY   29/07/13 Support CTSA internal custom     *
*                            fields (CTSACFs).                *
* IS10100A NuritY   14/10/13 Add ADDINFO_Split_by_Prefix      *
*                            to support RACF command          *
*                            limitations.                     *
* SAS2IBMT SeligT   11/05/17 SAS*C to IBM C Conversion Project*
* WS10070  KailasP  13/03/17 Add ADDINFO_list_getnextvalue    *
* IS10181  SeligT   03/06/19 Display Message When ADDINFO     *
*                            Value Is Too Large               *
* WS10078S SeligT   30/04/20 Support roles, X(ROL), & X(SGP)  *
* WS10079  ThomaS   22/09/20 ADDINFO_list_match               *
* IS10183  ThomaS   04/05/21 Don't print PASSWORD and PWPHRASE*
*                            in clear. Print '*****' instead  *
* WS10081  ThomaS   04/05/21 Don't print PASSWORD and PWPHRASE*
* ws10082  mauric   29/09/22 remove ADDINFO_ routines         *
**************************************************************/
#include   <globs.h>

/*
 *   Standard include files
 */

#include   STDIO
#include   STDLIB
#include   STRING
#include   CTYPE

/*
 *   ESA include files
 */

#include   ESA_DIAG
/* WS10082 - APICODE has now few defs moved from CTS.CMAC which
             are needed by ESAAPI and ESAADI, so move it here */
#include   ESA_API_CODES
#include   ESA_API
#include   ESA_CTSAMSG

/*
 *   MVS include files
 */

#include   MVS_COMP

/*
 *   RACF include files
 */

#include   RACF_CODES
#include   API_ADDINFO

static char component[] = "CTSCADI";

/*
 *
 */

#define    ADDINFO_MAX_PKB     50    /* maximum PKB's    */
#define    ADDINFO_MAX_PKB_LEN 2049  /* size of each PKB */

/* WS10082 start
static ESA_RC ADDINFO_concat_one(char                 *p_func,
                            char                      *p_cmd,
                            ADDINFO_PKB_rec_ptr        pkb_vec,
                            ADDINFO_rec_ptr            p_addinfo,
                            ADDINFO_KDTE_rec_ptr       p_kdt,
                            CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                            CTSAMSG_HANDLE_rec_ptr     p_msgs);

   WS10082 end */

/* WS10082 start */

/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_spi_init                           *
*                                                             *
* DESCRIPTION    : Store Admin parameters pointer.            *
*                                                             *
* INPUT          : admin_params     -  Admin params ptr       *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
**************************************************************/
EXT ESA_RC ADDINFO_spi_init(ADMIN_PARAMS_rec_typ  *admin_params)
{

 ESA_RC rc=ESA_OK;
 static char func[]="ADDINFO_spi_init";

 ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

 admin_params_copy = admin_params;

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, rc);

 return rc;

}
/* WS10082 end */



/* ws10082 start replace code with macro call to cc version
***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_search                             *
*                                                             *
* DESCRIPTION    : Search a keyword in additional info        *
*                                                             *
* INPUT          : kwd              -  keyword                *
*                  pair             -  entry to start search  *
*                  limit            -  max entries to search  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if not found)   *
*                                                             *
***************************************************************
ONE_FIELD_rec_ptr ADDINFO_search (char              *kwd,
                                  int               max_kwdlen,
                                  ONE_FIELD_rec_ptr p_pair,
                                  short             p_limit)
{

 ONE_FIELD_rec_ptr xptr = NULL;
 int kwdlen = 0;
 static char func[]="ADDINFO_search";

 if (kwd EQ NULL)
   goto exit ;
 kwdlen = strlen(kwd) ;
 if ( (kwdlen GT max_kwdlen ) OR (kwdlen EQ 0) )
   goto exit ;


 xptr =
  admin_params_copy->cs_func.ADDINFO_func_ptr->ADDINFO_search_ptr
                           (kwd,
                           max_kwdlen,
                           p_pair,
                           p_limit);
   exit:;

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                   "Exiting with result=%p", xptr);
   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, ESA_OK);

   return xptr;

}    ADDINFO_search

   short i = 0;
   int kwdlen = 0;
   ONE_FIELD_rec_ptr cpair;
   ONE_FIELD_rec_ptr rc = NULL;
   ONE_FIELD_rec_ptr xptr = NULL;
   static char func[]="ADDINFO_search";


   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   if (kwd EQ NULL)
      goto exit ;
   kwdlen = strlen(kwd) ;
   if ( (kwdlen GT max_kwdlen ) OR (kwdlen EQ 0) )
      goto exit ;

   cpair = p_pair;

   for (i=0; i LT p_limit; i++) {
      if (strcmp(cpair->keyword,kwd) EQ 0) {
       xptr = cpair;
         break;
      }
      cpair++;
   }
   exit:;

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                   "Exiting with result=%p", xptr);
   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, ESA_OK);

   return rc;
   return xptr;
**


 ***************************************************************
 *                                                             *
 * Procedure Name : ADDINFO_dup_check                          *
 *                                                             *
 * Description    : Check duplicate keywords in ADDINFO        *
 *                                                             *
 * Input          : addinfo                                    *
 *                  keyword                                    *
 *                                                             *
 * Output         : ptr to found record                        *
 *                                                             *
 * Input*Output   :                                            *
 *                                                             *
 * Return Value   : ESA_RC, ESA_FATAL - Duplicate keywords     *
 *                                                             *
 * Side Effects   :                                            *
 *                                                             *
 * Comments       :                                            *
 *                                                             *
 ***************************************************************

 ESA_RC ADDINFO_dup_check(ADDINFO_rec_typ           * addinfo,
                          char                      * kwd,
                          int                         max_kwdlen,
    PS0288 **             int                         exists_when_empty,
                          ONE_FIELD_rec_ptr         * pair,
                          CTSAMSG_DEST_TABLE_rec_ptr  dest,
                          CTSAMSG_HANDLE_rec_ptr      msgs)
  {

   *
   *  Variables
   *

   ESA_RC                     rc=ESA_OK ;
   short                      pairs_left ;
   ONE_FIELD_rec_ptr          pair1 = NULL;
   ONE_FIELD_rec_ptr          pair2 = NULL;
   static  char               func[]="ADDINFO_dup_check";

   *
   *  initialize
   *

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);
   *pair = NULL ;

   *
   *  Search keyword
   *

   pair1 = ADDINFO_prefix_search(kwd, max_kwdlen,
                                 exists_when_empty,   * PS0288 *
                                 addinfo->pair, addinfo->num_pairs);
   if ( pair1 NE NULL) {
      *pair = pair1;
      pairs_left = addinfo->num_pairs - (pair1 - addinfo->pair) - 1;
      if (pairs_left GT 0) {

     *
     *  Search keyword next times
     *

         pair2 = ADDINFO_prefix_search(kwd, max_kwdlen,
                                       exists_when_empty,   * PS0288 *
                                       pair1+1, pairs_left);
         if (pair2 NE NULL) {
            CTSAMSG_print(ERR_PARAM_MUTUALLY_EXC, msgs, NULL, dest,
                          pair1->keyword, pair1->value ,
                          pair2->keyword, pair2->value );
            rc = ESA_FATAL;
            goto exit;
         }     * duplicate keywords *

      }  * not last pair *

   }  * keyword was found *

  exit :;

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                   "Exiting with ptr=%X", *pair);
   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, rc);

   return rc;

} ** ADDINFO_dup_check **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_prefix_search                      *
*                                                             *
* DESCRIPTION    : Search a keyword in additional info        *
*                                                             *
* INPUT          : kwd              -  keyword prefix         *
*                  pair             -  entry to start search  *
*                  limit            -  max entries to search  *
*                                                             *
* OUTPUT         : None                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if not found)   *
*                                                             *
***************************************************************
ONE_FIELD_rec_ptr ADDINFO_prefix_search (char              *kwd,
                                         int          max_kwdlen,
  * PS0288 *                             int          exists_when_empty,
                                         ONE_FIELD_rec_ptr p_pair,
                                         short             p_limit)
{

   *
   *  Variables
   *

   short i ;
   int pfxlen = 0;
   ONE_FIELD_rec_ptr cpair;
   ONE_FIELD_rec_ptr rc = NULL;
   static char func[]="ADDINFO_prefix_search";

   *
   *  initialize
   *

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   if (kwd EQ NULL)
      goto exit ;
   pfxlen = strlen(kwd) ;
   if ( (pfxlen GT max_kwdlen) OR (pfxlen EQ 0) )
      goto exit ;

   cpair = p_pair;

   *
   *  Loop on Pairs
   *

   for (i=0; i LT p_limit; i++) {
      if ( strncmp(cpair->keyword, kwd, pfxlen) EQ 0 ) {
        if ( (cpair->vallen GT 0)   OR                  * ps0288 *
             ( (cpair->vallen EQ 0) AND exists_when_empty) ) {
          rc = cpair;
          break;
        }
      }
      cpair++;
   }  * while *

   *
   *    Finish
   *

   exit:;


   ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                   "Exiting with rc=%X", rc);
   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, ESA_OK);

   return rc;

}  * ADDINFO_prefix_search *

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_get_next                           *
*                                                             *
* DESCRIPTION    : Get next item from ADDINFO                 *
*                                                             *
* INPUT          : pair             -  entry to start loop    *
*                                                             *
* OUTPUT         : None                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if finished)    *
*                                                             *
***************************************************************
ONE_FIELD_rec_ptr ADDINFO_get_next(ADDINFO_rec_typ   * addinfo,
                                   ONE_FIELD_rec_ptr   p_pair)
{

  **
   *  Variables
   **

   int p_limit;
   ONE_FIELD_rec_ptr rc = NULL;
   static char func[]="ADDINFO_get_next";

  **
   *  initialize
   **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   if ( p_pair EQ NULL ) {
     p_limit = addinfo->num_pairs;
     p_pair  = addinfo->pair;
     p_pair--;
   }
   else
     p_limit = addinfo->num_pairs - (p_pair - addinfo->pair) - 1;

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                   "p_limit=%d", p_limit);

   if (p_limit EQ 0)
       goto exit;

  **
   *  Get next pair
   **

   rc = p_pair + 1;

  **
   *    Finish
   **

   exit:;

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                   "Exiting with rc=%X", rc);

   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, ESA_OK);

   return rc;

}  * ADDINFO_get_next *

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert                             *
*                                                             *
* DESCRIPTION    : Insert a keyword in additional info        *
*                                                             *
* INPUT          : type             -  addinfo type           *
*                  kwd              -  keyword                *
*                  value            -  value                  *
*                  addinfo          -  additional info        *
*                  dupflag          -  allow duplicate flag   *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************

ESA_RC ADDINFO_insert  (ADDINFO_typ        type,
                        char               *kwd,
                        char               *val,
                        ADDINFO_rec_ptr    addinfo,
                        int                max_kwdlen,
                        int                max_vallen,
                        ADDINFO_DUPLICATE  dupflag)
 {}

    *
    *  Variables

    static char func[] = "ADDINFO_insert";
    int i=0;
    int kwdlen, vallen;
    ONE_FIELD_rec_ptr cpair;
    ESA_RC rc = ESA_OK ;

    *
    *  initialize

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 2, func);

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "num_pairs = %d, max_pairs = %d",
                    addinfo->num_pairs,addinfo->max_pairs);

    if (addinfo->num_pairs GE addinfo->max_pairs) {
          rc = ESA_ERR; - deleted  AS0207
       rc = ESA_FATAL;  * added    AS0207
       goto exit;
    }

    *
    *  Validity checks

    kwdlen =strlen(kwd);
    if ((kwdlen EQ 0) OR (kwdlen GT max_kwdlen)) {
       rc = ESA_FATAL;
       goto exit;
    }

    vallen = strlen(val);
     * IS10181 skip the next few instructions - we will
               deal with this in ADDINFO_updval below
    if (vallen GT max_vallen) {
       rc = ESA_FATAL;
       goto exit;
    }                                                               *

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "Keyword=(%3d)'%s' Value=(%3d)'%s'",
                    kwdlen,kwd,vallen,val);

    *
    *  Verify that keyword is not yet used

    cpair = addinfo->pair;
    while (i LT addinfo->num_pairs) {

       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Entry %d,%X: kwd=%s(%3d),val=%s(%3d)",
                       i,cpair,
                       cpair->keyword,cpair->keylen,
                       cpair->value,cpair->vallen);

       if (dupflag EQ UNIQUE)
          if (strcmp(cpair->keyword,kwd) EQ 0) {
             rc = ESA_ERR;
             goto exit;
          }

       else if ( *(cpair->keyword) EQ NULL_CHAR)
             break;

       cpair++;
       i++;

    }  * while *

    *
    *    Add the Keyword

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "Updating entry at %d,%X", i,cpair);

    cpair->add_typ = type;
    cpair->keylen = kwdlen;
    strcpy(cpair->keyword,kwd);
    addinfo->num_pairs++;

    *
    *    Update the value
    *

     * IS10181 Add a return code so the ADDINFO_insert caller
               knows that the input value was too large and was
               truncated.
    ADDINFO_updval(val,max_vallen,cpair);
    rc = ADDINFO_updval(val,max_vallen,cpair);            * IS10181

    *
    *    Finish
    exit: ;

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 2, func, rc);

    return rc;

  }  * ADDINFO_insert *

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_updval                             *
*                                                             *
* DESCRIPTION    : Update a value of an exiting entry         *
*                                                             *
* INPUT          : value     - Value to be updated            *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_updval (char               *addval,
                       int                max_vallen,
                       ONE_FIELD_rec_ptr  pair)
{

 **
  *  Variables
  **

  char * ptr;                                            ** IS10181 **
  int set_done = 0;                                      ** IS10181 **
  ESA_RC rc = ESA_OK;
  static char func[] = "ADDINFO_updval";

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

 **
  *  Enough place for value ?
  *  If the incoming value parameter is larger than         IS10181
  *  the max_vallen input parameter, take the input value   IS10181
  *  parameter, point to the 16384th character, back up     IS10181
  *  until we find a ADDINFO_LIST_ENTRY (x'01') delimiter,  IS10181
  *  and place a null character on this delimiter.  If      IS10181
  *  there is no delimiter, just place a null character     IS10181
  *  on the 16384th character.                              IS10181
  **
  ** IS10094 if ( strlen(addval) GE max_vallen) {              **
  if ( strlen(addval) GT max_vallen) {              ** IS10094 **
     ** * * * * * IS10181 Start * * * * * **
     for (ptr = addval+max_vallen-1; ptr GT addval; ptr--)
     {
        if (ptr[0] EQ ADDINFO_LIST_ENTRY)
        {
** WS10078S Do not change the caller's input data
           ptr[0] = NULL_CHAR;                                       **
           rc     = ESA_EOF;
           set_done = 1;
           break;
        }
     }
     if (set_done EQ 0)
     {
        ptr    = addval+max_vallen-1;
** WS10078S Do not change the caller's input data
        ptr[0] = NULL_CHAR;                                          **
        rc     = ESA_EOF;
     }
     ** skip the next 2 instructions
     rc = ESA_FATAL;
     goto exit;                                                     **
     ** * * * * * IS10181 End * * * * * **
** Just copy the portion of the caller's input data we want WS10078S **
     strncpy(pair->value, addval, ptr-addval);           ** WS10078S **
     pair->value[ptr-addval] = NULL_CHAR;                ** WS10078S **
  }

 **
  *  update value
  **
** This is a regular case when the caller's input data      WS10078S
   fits into the ADDINFO pair->value output area.           WS10078S **
  else                                                   ** WS10078S **
     strcpy(pair->value,addval);
  pair->vallen = strlen(pair->value);

 **
  *  finish
  **

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_addval                             *
*                                                             *
* DESCRIPTION    : Conactenate a value to an exiting one      *
*                                                             *
* INPUT          : addval    - Value to be added              *
*                  addsep    - Seperator between value list   *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_addval (char                      *addval,
                       int                        max_vallen,
                       char                       addsep_c,
                       ONE_FIELD_rec_ptr          pair,
                       CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                       CTSAMSG_HANDLE_rec_ptr     p_msgs)
{

 **
  *  Variables
  **

  ESA_RC rc = ESA_OK;
  static char func[] = "ADDINFO_addval";
  char   msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];
  char   addsep[2];

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

  BUILD_STRING_SEPARATOR( addsep, addsep_c)

 **
  *  Enough place for value ?
  **
  if ( (strlen(addval)+(pair->vallen)) GE max_vallen) {
     ** IS10181 With this error, set the rc to the same
                rc as ADDINFO_insert and ADDINFO_updval
     rc = ESA_FATAL;                                                **
     rc = ESA_EOF;                                       ** IS10181 **
     goto exit;
  }

 **
  *  Add seperator
  **
  if ( *pair->value NE NULL_CHAR ) {
    if ( (pair->add_typ EQ TYPE_1B)  OR
         (pair->add_typ EQ TYPE_2B)   )
     strcat(pair->value, addsep);
    else {
      sprintf(msgbuf, "Invalid type=%d for list keyword=%s (value=%s %s)",
              pair->add_typ,  pair->keyword, pair->value, addval);
                 ** added pair->value and addval to message SAS2IBMT **
      CTSAMSG_print(ERR_INTERNAL2, p_msgs, NULL, p_dest,
                    component, func, msgbuf, 0, __LINE__);
      strcat(pair->value, addsep);
    }
  }

 **
  *  Add value
  **
  strcat(pair->value,addval);
  pair->vallen = strlen(pair->value);

 **
  *  finish
  **

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_delete                             *
*                                                             *
* DESCRIPTION    : Delete an entry from addinfo buffer        *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                  keyword          -  keyword                *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_delete(ADDINFO_rec_ptr addinfo,
                      char            *keyword)

{

  static char func[] = "ADDINFO_delete";

 **
  *   Variables
  **

  ESA_RC rc = ESA_OK ;
  int  found, i;

 **
  *   Initialize
  **

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

 **
  *   Search keyword that must be deleted
  **

  found =0;
  for ( i=0; NOT(found) AND (i LT addinfo->num_pairs); i++ )
      if (strcmp(addinfo->pair[i].keyword,keyword) EQ 0)
         found = i+1;

  if ( NOT(found) ) {
     rc = ESA_ERR ;
     goto exit;
  }

 **
  *   Compress information
  **

  for ( i = found-1; i LT (addinfo->num_pairs-1); i++) {

     strcpy(addinfo->pair[i].keyword, addinfo->pair[i+1].keyword);
     strcpy(addinfo->pair[i].value  , addinfo->pair[i+1].value  );
     addinfo->pair[i].keylen  = addinfo->pair[i+1].keylen;
     addinfo->pair[i].vallen  = addinfo->pair[i+1].vallen;
     addinfo->pair[i].add_typ = addinfo->pair[i+1].add_typ; ** IS10094**

  }

 **
  *   Update number of entries
  **

  addinfo->num_pairs--;

 **
  *   Finish
  **

  exit :;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_dump                               *
*                                                             *
* DESCRIPTION    : Dump Addtional info area                   *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                  print_empty      -  1 print in any case    *
*                                   -  0 print only if value  *
*                                        length > 0           *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_dump (ADDINFO_rec_ptr addinfo,
                     int             print_empty)
{

    static char func[] = "ADDINFO_dump";
    int i;
    ESA_RC rc = ESA_OK;
    ONE_FIELD_rec_ptr f_ptr;

    ** initialize        **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 0, func);

    if (addinfo NE NULL) {

       ** addinfo num pairs **

       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                       "num_pairs = %d, max_pairs = %d",
                       addinfo->num_pairs,addinfo->max_pairs);

       ** addinfo pairs **

       i = 0;
       f_ptr = addinfo->pair;
       while ( i LT addinfo->num_pairs) {
        if ( (print_empty NE 0 ) OR
             (f_ptr->vallen GT 0 ) )
          if (strcmp(f_ptr->keyword,                 **ps0292 **
                   "DCERT.CERTDATA") EQ 0)           **ps0292 **
           ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,   **ps0292 **
               "pair no. %3d: %d kwd=%s(%3d) crypted data val=%s(%3d)",
                i+1, f_ptr->add_typ,                 **ps0292 **
                f_ptr->keyword,f_ptr->keylen,        **ps0292 **
                "...",f_ptr->vallen) ;               **ps0292 **
          else                                       **ps0292 **
           ** IS10100 - start  **
        ** ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                          "pair no. %3d: %d kwd=%s(%3d) val=%s(%3d)",
                          i+1, f_ptr->add_typ,
                          f_ptr->keyword,f_ptr->keylen,
                          f_ptr->value,f_ptr->vallen) ;    **
          ** IS10183 - start  **
          if (  (strcmp(f_ptr->keyword,"PASSWORD") EQ 0)  OR
                (strcmp(f_ptr->keyword,"PHRASE") EQ 0)    OR
                (strcmp(f_ptr->keyword,"PWPHRASE") EQ 0)  )
           ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                          "pair no. %3d: %d kwd=%s(%3d) val=%s",
                          i+1, f_ptr->add_typ,
                          f_ptr->keyword,f_ptr->keylen,
                          "********");
           else
          ** IS10183 - end    **
           ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                          "pair no. %3d: %d kwd=%s(%3d) val=%.*s(%3d)",
                          i+1, f_ptr->add_typ,
                          f_ptr->keyword,f_ptr->keylen,
                          f_ptr->vallen, f_ptr->value,f_ptr->vallen) ;
           ** IS10100 - end    **
          f_ptr++;
          i++;
       }

    } ** addinfo pointer not empty **

    ** finish            **

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 0, func, rc );

    return rc;

  } ** ADDINFO_dump **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_alloc                              *
*                                                             *
* DESCRIPTION    : Allocate additional info area              *
*                                                             *
* INPUT          : max_pairs        -  max_pairs              *
*                : addinfo_ptr      -  additional info pointer*
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_alloc (char                       *func,
                      short                      max_pairs,
                      ADDINFO_rec_ptr           *addinfo_ptr,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
{

    static char fn[] = "ADDINFO_alloc";
    int size;
    ESA_RC rc = ESA_OK;

    ** Initialize        **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, fn);
    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                    "addinfo pointer at %X, max =%d",
                    addinfo_ptr,max_pairs);

    ** Obtain area       **

    size = sizeof (ADDINFO_rec_typ) +
           max_pairs * sizeof(ONE_FIELD_rec_typ);
    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                    "area size = %d",size);

    (*addinfo_ptr) = (ADDINFO_rec_typ *)malloc (size);
    if ((*addinfo_ptr) EQ NULL) {
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                       "malloc for addinfo buffer failed");
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "ADDINFO BUFFER", size);
       rc = ESA_ERR;
    }
    else {
       (*addinfo_ptr)->num_pairs = 0;
       (*addinfo_ptr)->max_pairs = max_pairs;
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                       "area at %X",(*addinfo_ptr));
       ESA_DIAG_printf(PLT_COMP_ACF2_MEMORY, 6,          ** WS10078S **
           "Allocate: addr=%X len=%d rtn=%s",            ** WS10078S **
           *addinfo_ptr, size, fn);                      ** WS10078S **
    }

    ** Finish            **

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, fn, rc );

    return rc;

  } ** ADDINFO_alloc **


***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_free                               *
*                                                             *
* DESCRIPTION    : Free additional info buffer                *
*                                                             *
* INPUT          : addinfo_ptr      -  additional info pointer*
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_free (ADDINFO_rec_ptr *addinfo_ptr)

{

    static char func[] = "ADDINFO_free";

    ** Initialize        **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1,func);

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                    "area at %X",(*addinfo_ptr));

    ** Free area       **

    if ((*addinfo_ptr) NE NULL) {
       free (*addinfo_ptr);
       ESA_DIAG_printf(PLT_COMP_ACF2_MEMORY, 6,          ** WS10078S **
           "Free: addr=%X rtn=%s",                       ** WS10078S **
           *addinfo_ptr, func);                          ** WS10078S **
       (*addinfo_ptr) = NULL;
    }

    ** Finish            **

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, ESA_OK );

    return ESA_OK;

  } ** ADDINFO_free    **


***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_copy                               *
*                                                             *
* DESCRIPTION    : Copy additional info area                  *
*                                                             *
* INPUT          : to               -  additional info        *
*                  from             -  additional info        *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
***************************************************************
ESA_RC ADDINFO_copy  (ADDINFO_rec_ptr to,
                      ADDINFO_rec_ptr from)

{

    static char func[] = "ADDINFO_copy";

    ESA_RC rc = ESA_OK;
    short save_max_pairs;

    ** Initialize        **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);
    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                    "FROM: at %X, used %d max %d",
                    from,from->num_pairs,from->max_pairs);
    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                    "TO at %X, used %d max %d",
                    to,to->num_pairs,to->max_pairs);

    ** Copy area       **

    if (to->max_pairs LT from->num_pairs) {
       rc = ESA_ERR;
       goto exit;
    }

    save_max_pairs = to->max_pairs;
    memcpy( (void *)to,
            (void *)from,
            ADDINFO_size(from->num_pairs) );

    to->num_pairs = from->num_pairs;
    to->max_pairs = save_max_pairs;

     ** Finish            **

    exit: ;

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

    return rc;

  } ** ADDINFO_copy    **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_copy_by_prefix                     *
*                                                             *
* DESCRIPTION    : Copy ADDINFO pairs by prefix               *
*                                                             *
* INPUT          : addinfo_in                                 *
*                  prefix
*                                                             *
* OUTPUT         : addinfo_out                                *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if finished)    *
*                                                             *
***************************************************************
ESA_RC ADDINFO_copy_by_prefix(char              *prefix,
                              int                max_kwdlen,
                              int                max_vallen,
                              int                drop_prefix,
                              ADDINFO_rec_typ   *addinfo_in,
                              ADDINFO_rec_typ   *addinfo_out)
{

  **
   *  Variables
   **

   ESA_RC   rc = ESA_OK;
   int      len;
   int      skip_prefix;
   ONE_FIELD_rec_ptr cpair   = NULL;
   ONE_FIELD_rec_ptr cpair_o = NULL;
   static char func[]="ADDINFO_copy_by_prefix";

  **
   *  initialize
   **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   len = strlen(prefix);
   if ( len EQ 0 )
       goto exit;

   while ( cpair = ADDINFO_get_next(addinfo_in, cpair ) ) {
     if ( memcmp(cpair->keyword, prefix, len ) EQ 0 ) {
        if (drop_prefix EQ TRUE)
         skip_prefix = len;
        else
         skip_prefix = 0;
        rc = ADDINFO_insert(cpair->add_typ,
                            &(cpair->keyword[skip_prefix]),
                            cpair->value, addinfo_out,
                            max_kwdlen, max_vallen,
                            UNIQUE);
        if ( rc EQ ESA_FATAL )  ** Overflow **
           goto exit;
        else {
             cpair_o = ADDINFO_search(cpair->keyword, max_kwdlen,
                                      addinfo_out->pair,
                                      addinfo_out->num_pairs);
             if ( (cpair_o NE NULL)            AND
                  (strlen(cpair_o->value) EQ 0 )  )
              ADDINFO_updval(cpair->value, max_vallen, cpair_o);
        }
     }
   }

   ** Finish **

   exit: ;

   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

   return rc;

  } ** ADDINFO_copy_by_prefix    **


***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_rkt_check                          *
*                                                             *
* DESCRIPTION    : Verify that no reserved keywords are used  *
*                                                             *
* INPUT          : func          - function name              *
*                  numaddi       - addinfo buffer             *
*                  addinfo       - addinfo vector pointer     *
*                  rkte          - RKTE to start with         *
*                  p_dest        - Vector of error msg dests  *
*                  p_msgs        - Error messages buffer      *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_rkt_check   (char                      *p_func,
                            short                      p_numaddi,
                            ADDINFO_rec_ptr           *p_addinfo,
                            ADDINFO_RKTE_rec_ptr       p_rkte,
                            CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                            CTSAMSG_HANDLE_rec_ptr     p_msgs)
{

  static char func[] = "ADDINFO_rkt_check";

 **
  *  Variables
  **

  ESA_RC               rc = ESA_OK;
  short                i;
  ONE_FIELD_rec_ptr    cpair;
  ADDINFO_RKTE_rec_ptr pw_rkte;

 **
  *  Initialize
  **

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

 **
  *   Check that KWD was not specified in addinfo
  **

  for (i=0; i LT p_numaddi; i++) {
      if (p_addinfo[i] NE NULL) {
         for (pw_rkte = p_rkte; *pw_rkte->kwd NE NULL_CHAR; pw_rkte++)
         {
             cpair = ADDINFO_search(pw_rkte->kwd,
                                    sizeof(pw_rkte->kwd),
                                    p_addinfo[i]->pair,
                                    p_addinfo[i]->num_pairs);
             ESA_DIAG_printf(PLT_COMP_API_ADDINFO,4,
                             "keyword=%s at %X", pw_rkte->kwd,cpair);
             if (cpair NE NULL) {
                CTSAMSG_print(RACF_KEYWORD_RESVD,   p_msgs, NULL,
                              p_dest, pw_rkte->kwd);
                rc = ESA_ERR;
                goto exit;
             } ** reserved keyword found **
          }     ** keywords loop **
      } ** addinfo buffer exists **
  }

 **
  *  finish
  **

  exit:  ;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc );
  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_kdt_search                         *
*                                                             *
* DESCRIPTION    : Locate a keyword in KDT (Keyword           *
*                  Description Table )                        *
*                                                             *
* INPUT          : p_kwd            - keyword to be searched  *
*                  p_kdte           - KDTE to start search    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ADDINFO_KDTE_rec_ptr                       *
*                                                             *
***************************************************************
ADDINFO_KDTE_rec_ptr ADDINFO_kdt_search(char                 *kwd,
                                        ADDINFO_KDTE_rec_ptr  p_kdte)

{

   static char func[] = "ADDINFO_kdt_search";

   **
    *     Variables
    **

   ADDINFO_KDTE_rec_ptr c_desc;
   ADDINFO_KDTE_rec_ptr rc = NULL;
   int                  length;       ** ps0292 **
   int                  wildcard;     ** ps0292 **

   **
    *     Initialize
    **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   **
    *     Locate description for keyword
    **
   for (c_desc=p_kdte; *(c_desc->kwd) NE NULL_CHAR; c_desc++ ) {
      ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                      "Checking kwd %s",c_desc->kwd);

      ** ps0292
       * Check if KDT keyword includes wildcard symbol '*'
       **

      length = strlen(c_desc->kwd) - 1;            ** ps0292 **
      if ( (length) GE 0) {                        ** ps0292 **
         if (c_desc->kwd[length] EQ '*')           ** ps0292 **
            wildcard = TRUE;                       ** ps0292 **
         else                                      ** ps0292 **
            wildcard = FALSE;                      ** ps0292 **
      }                                            ** ps0292 **
                                                   ** ps0292 **
      if ( NOT wildcard ) {                        ** ps0292 **
        if (strcmp(c_desc->kwd,kwd) EQ 0) {
           rc = c_desc;
           break;
        } ** if **
      } ** if **                                   ** ps0292 **
      ** Checking according wildcard **            ** ps0292 **
      else {                                       ** ps0292 **
        if (memcmp(c_desc->kwd, kwd,               ** ps0292 **
                   length ) EQ 0) {                ** ps0292 **
           rc = c_desc;                            ** ps0292 **
           break;                                  ** ps0292 **
        } ** if **                                 ** ps0292 **
      }                                            ** ps0292 **
   } ** for **

   **
    *     finish
    **

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 3,
                   "exiting with rc= %X", rc );

   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, ESA_OK);

   return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_kdt_modify                         *
*                                                             *
* DESCRIPTION    : Modify the textl, tetxr for specified      *
*                  entry in KDT table                         *
*                                                             *
* INPUT          : kwd              - keyword                 *
*                  p_kdte           - KDTE table              *
*                  char             - text left               *
*                  char             - text right              *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_OK, ESA_ERR - specified keyword        *
*                                    not found                *
*                                                             *
***************************************************************
ESA_RC ADDINFO_kdt_modify(char                 *kwd,
                          ADDINFO_KDTE_rec_ptr  p_kdte,
                          char                 *txtl,
                          char                 *txtr)

{

   static char func[] = "ADDINFO_kdt_modify";

   **
    *     Variables
    **

   ESA_RC                rc = ESA_OK;
   ADDINFO_KDTE_rec_ptr  fnd = NULL;

   **
    *     Initialize
    **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   **
    *     Locate specified keyword
    **

   fnd = ADDINFO_kdt_search(kwd, p_kdte);
   if ( fnd EQ NULL ) {
      rc = ESA_ERR ;
      goto exit;
   }

   fnd->txtl = txtl;   ** Update ptr to new text left  **
   fnd->txtr = txtr;   ** Update ptr to new text right **

   **
    *     finish
    **

  exit :;

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 3,
                   "exiting with rc= %d", rc );

   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, rc);

   return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_mkt_check                          *
*                                                             *
* DESCRIPTION    : Check that all mandatory keywords were     *
*                  specified                                  *
*                                                             *
* INPUT          : p_func        - function name              *
*                  p_numaddi     - number of addinfo buffers  *
*                  p_addinfo     - pointer to addinfo         *
*                  p_mkte        - MKTE to start with         *
*                  p_dest        - Vector of error msg dests  *
*                  p_msgs        - Error messages buffer      *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_mkt_check( char                      *p_func,
                          short                      p_numaddi,
                          ADDINFO_rec_ptr           *p_addinfo,
                          ADDINFO_MKTE_rec_ptr       p_mkte,
                          ADDINFO_KDTE_rec_ptr       p_kdt,
                          CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                          CTSAMSG_HANDLE_rec_ptr     p_msgs)
{

    static char func[] = "ADDINFO_mkt_check";

   **
    *   Variables
    **

    ESA_RC               rc = ESA_OK;
    ONE_FIELD_rec_ptr    cpair;
    ADDINFO_KDTE_rec_ptr cdesc;
    short                i;

   **
    *   Initialize
    **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 2, func);

    if ( ( p_addinfo EQ NULL ) OR
         ( p_numaddi EQ 0    )  )
       goto exit;

   **
    *    Check for mandatory parameters
    **

    while ( *(p_mkte->kwd) NE NULL_CHAR ) {

        ** mandatory keyword not supplied **

        cpair = NULL;
        for (i=0; i LT p_numaddi; i++)
            if (p_addinfo[i] NE NULL) {
               cpair = ADDINFO_search(p_mkte->kwd,
                                      sizeof(p_mkte->kwd),
                                      p_addinfo[i]->pair,
                                      p_addinfo[i]->num_pairs);
               if (cpair NE NULL)
                  break;
            } ** addinfo buffer exists **

        ** mandatory keyword not supplied **

        if ( cpair EQ NULL ) {
           CTSAMSG_print(RACF_MANDATORY_MISS,   p_msgs, NULL, p_dest,
                         p_mkte->kwd );
           rc = ESA_ERR;
        }

        ** mandatory keyword has no value **

        else {
           cdesc = ADDINFO_kdt_search(p_mkte->kwd,p_kdt);
           if (cdesc NE NULL ) {
              if ( (*(cpair->value)   EQ NULL_CHAR)  AND
                   (cdesc->type       EQ KDT_KEY  )  AND
                   (*(cdesc->neg_kwd) EQ NULL_CHAR)      ) {
                   CTSAMSG_print(RACF_MANDATORY_EMPTY,   p_msgs, NULL,
                                 p_dest, p_mkte->kwd );
                 rc = ESA_ERR;

              } ** parameter empty **
           } ** kdte located **
        } ** mandatory keyword specified **

        p_mkte++;
    }

   **
    *    finish
    **

    exit:;

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 2, func, rc);

    return rc;
}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_concat                             *
*                                                             *
* DESCRIPTION    : Concatenate Additional Info buffers to     *
*                  command buffer                             *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_concat( char                      *p_func,
                       char                      *p_cmd,
                       short                      p_numaddi,
                       ADDINFO_rec_ptr           *p_addinfo,
                       ADDINFO_KDTE_rec_ptr       p_kdt,
                       CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                       CTSAMSG_HANDLE_rec_ptr     p_msgs)
{

  static char func[] = "ADDINFO_concat";
  ADDINFO_PKB_rec_typ  pkb_vec[ADDINFO_MAX_PKB];
  int                  i;
  ESA_RC               rc = ESA_OK;

  ****************************************************************
  *    Initialize
  ****************************************************************

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 2, func);

  **
   *   Initialize PKBs (Primary Keyword Buffers)
   **

  for (i=0; i LT ADDINFO_MAX_PKB; i++) {
       pkb_vec[i].no_pkb = 0;
       strcpy(pkb_vec[i].name, NULL_STRING);
       pkb_vec[i].buff = NULL;
       pkb_vec[i].size = ADDINFO_MAX_PKB_LEN;
  }

  if ( ( p_addinfo EQ NULL ) OR
       ( p_numaddi EQ 0    )  )
    goto exit;

  ****************************************************************
  *    Scan Additional Info Table                                *
  ****************************************************************

  for (i=0; i LT p_numaddi; i++)
      if (p_addinfo[i] NE NULL) {
         rc = ADDINFO_concat_one( p_func, p_cmd, pkb_vec, p_addinfo[i],
                                  p_kdt, p_dest, p_msgs);
         if (rc NE ESA_OK)
            goto exit;
      }

  *****************************************************************
  *    Concatenate PKBs to command                                *
  *****************************************************************

  for (i=0; i LT ADDINFO_MAX_PKB; i++) {
      if (pkb_vec[i].buff NE NULL) {

         ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,  "%d f=%d b=%s",
                         i, pkb_vec[i].no_pkb , pkb_vec[i].buff);

         if (pkb_vec[i].no_pkb EQ 0) {
            if (strlen(pkb_vec[i].buff) GT 0) {
               strcat(p_cmd,pkb_vec[i].name);
               strcat(p_cmd,"(");
               strcat(p_cmd,pkb_vec[i].buff);
               strcat(p_cmd,") ");
               ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                               "Loop:p_cmd=%s", p_cmd );
            }
            else break;
         }
      }
      else break;
  }

 *****************************************************************
 *    Free PKBs
 *****************************************************************

  exit: ;

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,  "p_cmd=%s", p_cmd );

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                  "Termination cleanup started");
  for (i=0; i LT ADDINFO_MAX_PKB; i++) {
      if (pkb_vec[i].buff NE NULL) {
         ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                         "Buffer %d, at %X size=%d buf=%s",
                         i,pkb_vec[i].buff,pkb_vec[i].size,
                         pkb_vec[i].buff NE NULL);
         free(pkb_vec[i].buff);
      }
      else
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO,8,
                        "Buffer %d, nothing to free",i);
  }

  *****************************************************************
  *    finish
  *****************************************************************

  ADDINFO_convert_list_sep( p_cmd,
                            ADDINFO_LIST_ENTRY, ADDINFO_LIST_SUBFIELD,
                            ',', ',' );

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 2, func, rc );
  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_concat_one                         *
*                                                             *
* DESCRIPTION    : Concatenate an Additional Info buffer to   *
*                  command buffer                             *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
static ESA_RC ADDINFO_concat_one(char                *p_func,
                           char                      *p_cmd,
                           ADDINFO_PKB_rec_ptr        pkb_vec,
                           ADDINFO_rec_ptr            p_addinfo,
                           ADDINFO_KDTE_rec_ptr       p_kdt,
                           CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                           CTSAMSG_HANDLE_rec_ptr     p_msgs)
{

 static char              func[] = "ADDINFO_concat_one";
 ONE_FIELD_rec_ptr        cpair;
 int                      cnum;
 ADDINFO_KDTE_rec_ptr     cdesc;
 char                     pri_kwd[MAX_RSS_ADDINFO_KWD_LEN+1];
 char                     sec_kwd[MAX_RSS_ADDINFO_KWD_LEN+1];
 char                     pkb_desc[MAX_RSS_ADDINFO_KWD_LEN+1+80];

 int                      i, j, k;
 char                     *cpri;

 char                     temp_kwd[MAX_RSS_ADDINFO_KWD_LEN+1];
 char                     temp_val[2*MAX_RSS_ADDINFO_VAL_LEN+1];
 ADDINFO_KWD_typ          temp_type;
 ADDINFO_KWD_typ          orig_type;    ** ps0071 **
 ESA_RC                   rc = ESA_OK;

 ****************************************************************
 *    Initialize
 ****************************************************************

 ESA_DIAG_enter(PLT_COMP_API_ADDINFO,1,"ADDINFO_concat_one");

 ****************************************************************
 *    loop on addinfo table
 *****************************************************************

 cpair = p_addinfo->pair;
 cnum  = 0;

 while (cnum LT p_addinfo->num_pairs) {


    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "Keyword=%s Value='%s'",
                    cpair->keyword,cpair->value);

   **
    *    Locate parameter description in KDT
    **

    cdesc = ADDINFO_kdt_search(cpair->keyword, p_kdt);

    if (memcmp(cpair->keyword,"MFA.",4) EQ 0)            ** WS10081 **
       goto next_pair;                                   ** WS10081 **

    if (cdesc EQ NULL) {
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,2,
                       "Keyword=%s not supporetd",
                       cpair->keyword);
       if ( cpair->add_typ EQ TYPE_1A  OR
            cpair->add_typ EQ TYPE_1B   )
          CTSAMSG_print(RACF_KEYWORD_NOSUPP,   p_msgs, NULL, p_dest,
                        cpair->keyword);
       goto next_pair;
    }

    strcpy(temp_kwd,cpair->keyword); ** Keyword      **
    temp_type=cdesc->type;           ** keyword type **
    orig_type=cdesc->type;           ** ps0071 **

    if ( temp_type EQ KDT_KEYG )  {        ** spr125 **
       strcpy( temp_val, cpair->value );   ** spr125 **
       temp_type = KDT_KEY;                ** spr125 **
       cdesc->type = KDT_KEY;              ** spr125 **
    }                                      ** spr125 **
    else if ( temp_type EQ KDT_KEYM ) {                   ** PS0349 **
     **
      *    Add quotes for each value in multivalued field
      **
      temp_type = KDT_KEY;                                ** PS0349 **
      cdesc->type = KDT_KEY;                              ** PS0349 **
                                                          ** PS0349 **
      k = strlen(cpair->value);                           ** PS0349 **
                                                          ** PS0349 **
      if (k NE 0) {                                       ** PS0352 **
        j = 1;                                            ** PS0349 **
                                                          ** PS0349 **
        temp_val[0] = QUOTE_CHAR;                         ** PS0349 **
                                                          ** PS0349 **
        for (i=0; i LT k; i++) {                          ** PS0349 **
             temp_val[j] = (cpair->value)[i];             ** PS0349 **
             if (temp_val[j] EQ ADDINFO_LIST_ENTRY) { ** PS0349 **
                temp_val[j] = QUATE_CHAR;                 ** PS0349 **
                temp_val[j+1] = ADDINFO_LIST_ENTRY;       ** PS0349 **
                temp_val[j+2] = QUATE_CHAR;               ** PS0349 **
                j=j+2;                                    ** PS0349 **
             }                                            ** PS0349 **
             j++;                                         ** PS0349 **
        }                                                 ** PS0349 **
        temp_val[j] = QUATE_CHAR;                         ** PS0349 **
        temp_val[j+1] = NULL_CHAR;                        ** PS0349 **
      }                                                   ** PS0352 **
      else                                                ** PS0352 **
        strcpy (temp_val,"");                             ** PS0352 **
    }                                                     ** PS0349 **
    else {                                 ** spr125 **
     **
      *    Duplicate quates in value
      **

      j = 0;
      k = strlen(cpair->value);
      for (i=0; i LT k; i++) {
           temp_val[j] = (cpair->value)[i];
           if (temp_val[j] EQ QUATE_CHAR) {
              temp_val[j+1] = QUATE_CHAR;
              j++;
           }
           j++;
      }
      temp_val[j] = NULL_CHAR;
    }

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "Original value=%s New value=%s",
                    cpair->value, temp_val);

    if (cdesc->type EQ KDT_IGN)
       goto next_pair;

   **
    *    Handle a KEYED parameter
    **

    if (( cdesc->type EQ KDT_KEY    ) AND
        ( temp_val[0] EQ NULL_CHAR  )) {

        strcpy(temp_kwd,cdesc->neg_kwd);
        temp_type = KDT_FLG ;

        ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Keyed parameter '%s' was changed to flag '%s'",
                        cpair->keyword,cdesc->neg_kwd);

    } ** handle a keyed **

    **
     *    Handle a KDT_FLG parameter
     **

    if (cdesc->type EQ KDT_FLG) {
       temp_type = KDT_FLG ;

       if      (strcmp(temp_val, KWD_FLAG_ON) EQ 0)
               strcpy(temp_kwd,cdesc->kwd);

       else if (strcmp(temp_val, KWD_FLAG_OFF) EQ 0 )
               strcpy(temp_kwd,cdesc->neg_kwd);

       else {
            ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                            "Flag %s value mismatch",
                            cpair->keyword, temp_val);
            CTSAMSG_print(RACF_UNDEF_OPTION, p_msgs, NULL, p_dest,
                           temp_kwd, temp_val );
            rc = ESA_ERR;
            goto exit;
       }
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Flag parameter '%s' was set to '%s'",
                       cpair->keyword,temp_kwd);

    } ** handle a flag) **

    **
     *     If no negative word was found, ignore the keyword
     **

    if (*temp_kwd EQ NULL_CHAR) {
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Keyword=%s was ignored, no neg",
                       cpair->keyword);
       goto next_pair;
    }

    **
     *  Primary keyword - concatenate to command buffer
     **

    cpri = strchr(temp_kwd,'.');
    if (cpri EQ NULL) {
       if ( temp_type EQ KDT_KEY ) {
          if ( temp_val[0] NE NULL_CHAR) {
            strcat(p_cmd,temp_kwd);
            strcat(p_cmd,cdesc->txtl);
            strcat(p_cmd,temp_val);
            strcat(p_cmd,cdesc->txtr);
          }
          else
            CTSAMSG_print(RACF_KEYWORD_NOVALUE, p_msgs, NULL, p_dest,
                          temp_kwd );
       }
       else if (temp_type EQ KDT_FLG)
           strcat(p_cmd,temp_kwd);

       strcat(p_cmd," ");

    } ** of primary parameter **

    **
     *  Secondary keyword - concatenate to appropriate PKB
     **

    else {

       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Keyword=%s at %X, sperator at %X",
                       temp_kwd,temp_kwd,cpri);

       ** Seperate the Primary and Secondary keywords **

       strncpy(pri_kwd,temp_kwd,cpri-temp_kwd); ** primary **
       pri_kwd[cpri-temp_kwd] = NULL_CHAR;      ** primary **
       strcpy(sec_kwd,cpri+1);                  ** secondary **

       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Primary=%s Secondary=%s",
                       pri_kwd,sec_kwd);

       ** locate the PKB of the primary keyword **

       for (i=0; i LT ADDINFO_MAX_PKB; i++) {

           ESA_DIAG_printf(PLT_COMP_API_ADDINFO,4,
                           "%3d,Name=%s Buff at %X",
                           i,pkb_vec[i].name,pkb_vec[i].buff);

           if (  ( *(pkb_vec[i].name) EQ NULL_CHAR    ) OR
                 ( strcmp(pri_kwd,pkb_vec[i].name) EQ 0 ) )
              break;
       }
       if (i GE ADDINFO_MAX_PKB-1) {
          CTSAMSG_print(RACF_PKB_EXC,
                        p_msgs, NULL, p_dest,
                        p_func, ADDINFO_MAX_PKB, cpair->keyword);
          rc = ESA_ERR;
          goto exit;
       }

       ** If no PKB matched, allocate a new PKB **

       if ( *(pkb_vec[i].name) EQ NULL_CHAR ) {
          strcpy(pkb_vec[i].name,pri_kwd);
          pkb_vec[i].buff = malloc(pkb_vec[i].size);
          if (pkb_vec[i].buff EQ NULL) {
              sprintf(pkb_desc,"PKB (%d) FOR %s",i, cpair->keyword );
              CTSAMSG_print(ERR_MALLOC, p_msgs, NULL, p_dest,
                            pkb_desc, pkb_vec[i].size);
              rc = ESA_ERR;
              goto exit;
          } ** if **
          strcpy(pkb_vec[i].buff, NULL_STRING);
       } ** if **

       ** Add secondary keyword to PKB  **

       if ( temp_type EQ KDT_KEY ) {
          if ( temp_val[0] NE NULL_CHAR ) {
            strcat(pkb_vec[i].buff,sec_kwd);
            strcat(pkb_vec[i].buff,cdesc->txtl);
            strcat(pkb_vec[i].buff,temp_val);
            strcat(pkb_vec[i].buff,cdesc->txtr);
          }
          else {
            CTSAMSG_print(RACF_KEYWORD_NOVALUE, p_msgs, NULL, p_dest,
                          temp_kwd );
          }
       }
       else if (temp_type EQ KDT_FLG) {
          strcat(pkb_vec[i].buff,sec_kwd);
          if (strcmp(sec_kwd, "NO_PKB") EQ 0 )
             pkb_vec[i].no_pkb = 1;
       }

       strcat(pkb_vec[i].buff," ");
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,  "%d f=%d b=%s",
                      i, pkb_vec[i].no_pkb , pkb_vec[i].buff);
    } ** of secondary parameter **

   **
    *     Next ADDINDO pair
    **

    next_pair:;

    if (cdesc NE NULL)              ** ps0071 **
        cdesc->type = orig_type;    ** ps0071 **
    cnum++;
    cpair++;
  }

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

  return rc;

 }

***************************************************************
*                                                             *
* PROCEDURE NAME : ERROR_add                                  *
*                                                             *
* DESCRIPTION    : Add error message to error buffer          *
*                                                             *
* INPUT          : p_line   - line to add to buffer           *
*                  p_err    - error buffer                    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ERROR_add     (char                 *p_line,
                      ERR_STRUCT_rec_ptr   p_err   )
{

  **
   *
   **

   static char func[] = "ERROR_add";
   ESA_RC rc = ESA_OK;
   short  line_len,line_off;

   **
    *     Initialize
    **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 3, func);

   line_len = strlen(p_line)+1;
   line_off = p_err->length;

   **
    *     Copy line into buffer
    **

   if  ( (line_len+line_off) LT sizeof(p_err->err_msg_text)) {
        strcpy(&(p_err->err_msg_text[line_off]),p_line);
        p_err->length = p_err->length + line_len;
   }

   **
    *     No place in buffer
    **

   else rc = ESA_ERR;

  **
   *  finish
   **

   ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 3, func, rc);
   return rc ;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ERROR_dump                                 *
*                                                             *
* DESCRIPTION    : Dump error message buffer                  *
*                                                             *
* INPUT          : p_err    - error buffer                    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ERROR_dump (ERR_STRUCT_rec_ptr p_err) {

  static char func[] = "ERROR_dump";
  int  coff,cleft,clen;

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 0, func );

  ** Error lines **

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                 "Error buffer size=%d used=%d",
           sizeof(p_err->err_msg_text),p_err->length);

  coff  = 0;
  cleft = p_err->length ;
  while (cleft GT 0) {
        clen = strlen(&(p_err->err_msg_text[coff]))+1;
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,"%3d,%s",
                        coff,&(p_err->err_msg_text[coff]));
        cleft = cleft - clen;
        coff  = coff  + clen;
  } ** while **

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 0, func, ESA_OK );

  return ESA_OK;

} ** ERROR_dump **

***************************************************************
*                                                             *
* PROCEDURE NAME : ERROR_print                                *
*                                                             *
* DESCRIPTION    : print error message buffer to stdout       *
*                                                             *
* INPUT          : p_err    - error buffer                    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************

ESA_RC ERROR_print(ERR_STRUCT_rec_ptr p_err) {

  static char func[] = "ERROR_print";
  int  coff,cleft,clen;

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

  ** Error lines **

  coff  = 0;
  cleft = p_err->length ;
  while (cleft GT 0) {
        clen = strlen(&(p_err->err_msg_text[coff]))+1;
        printf("- %s",&(p_err->err_msg_text[coff]) );
        cleft = cleft - clen;
        coff  = coff  + clen;
  } ** while **

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, ESA_OK );

  return ESA_OK;

} ** ERROR_print **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_list_search                        *
*                                                             *
* DESCRIPTION    : Locate an item in addinfo list value       *
*                                                             *
* INPUT          : list     - list string (items spearted by  *
*                             commas)                         *
*                  item     - searched item                   *
*                  sep      - string of list seperators       *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : Pointer to list item or NULL               *
*                                                             *
***************************************************************
char * ADDINFO_list_search (char *list, char *item, char  sep_c)
{

  static char func[] = "ADDINFO_list_search";
  char *loc, *before_loc;
  char sep[2];
  int  len;

 **
  *    Initialize
  **

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

  BUILD_STRING_SEPARATOR( sep, sep_c)
  ** ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);         WS10081 **

  len = strlen(item);
  loc = strstr(list,item);

 **
  *    Locate matching substrings
  **

  while ( loc NE NULL ) {

     ** substring found **

     before_loc = loc - 1 ;
     if ((loc[len] EQ NULL_CHAR) OR (strchr(sep,loc[len]) NE NULL))

          ** substring is a seperate item **

          if (loc EQ list)
             break;
          else if (strchr(sep,*before_loc) NE NULL)
                  break;

     ** try again **
     loc = strstr(loc+len,item);

  } ** while **

 **
  *   Finish
  **

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                  "Exiting with rc = %X",loc);
  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, ESA_OK );

  return loc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_list_diff                          *
*                                                             *
* DESCRIPTION    : Build a list of items found in first       *
*                  string, but not in second string .         *
*                                                             *
* INPUT          : inlist1  - first list                      *
*                  inlist2  - second list                     *
*                  outlist  - list of added items             *
*                  insep    - string of list sperators        *
*                  outsep   - sepearator in output list       *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_OK                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_list_diff (char *inlist1, char *inlist2,
                          char *outlist, char insep_c, char outsep_c)
{

  static char func[] = "ADDINFO_list_diff";
  char   item[ADDINFO_LIST_MAX_ITEM+1];
  ESA_RC rc = ESA_OK;
  int    off;
  int    len;
  int    max_off ;
  char   insep[2], outsep[2];

 **
  *    Initialize
  **

  BUILD_STRING_SEPARATOR( insep,  insep_c)
  BUILD_STRING_SEPARATOR( outsep, outsep_c)

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);
  ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                  "inlist1=%s inlist2=%s",inlist1,inlist2);

  max_off = strlen(inlist1);
  *outlist = NULL_CHAR;

  off = strspn(inlist1,insep);

 **
  *    Loop on first input list keywords
  **

  while ( off LT max_off ) {

    len = strcspn(inlist1+off,insep);
    if (len GT 0) {

        ** if item not in second list, add it to output list **

       if (len GT sizeof(item)-1) {
         rc = ESA_ERR;
         goto exit;
       }
       strncpy(item,inlist1+off,len);
       item[len] = NULL_CHAR;
       if (ADDINFO_list_search(inlist2,item,insep_c) EQ NULL) {
          if ( *outlist NE NULL_CHAR )
             strcat(outlist,outsep);
          strcat(outlist,item);
       }
       off += len;
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,2,
                       "item=%s, outlist=%s",item,outlist);
    }
    off += strspn(inlist1+off,insep);

  } ** while **

 **
  *   Finish
  **

  exit: ;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

  return rc;

}
**   start WS10079                                           **
***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_list_match                         *
*                                                             *
* DESCRIPTION    : Build a list of items in the first string, *
*                  which also appear in the 2nd string        *
*                                                             *
* INPUT          : inlist1  - first list                      *
*                  inlist2  - second list                     *
*                  outlist  - pointer to area at least as     *
*                             large as inlist1                *
*                  insep_c  - char of input list seperator    *
*                  outsep-c - char of output list seperator   *
*                                                             *
* OUTPUT         : outlist  - list of common items            *
*                                                             *
* RETURN VALUE   : ESA_OK                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_list_match (char *inlist1, char *inlist2,
                          char *outlist, char insep_c, char outsep_c)
{

  static char func[] = "ADDINFO_list_match";
  char   item[ADDINFO_LIST_MAX_ITEM+1] = NULL_STRING;
  ESA_RC rc = ESA_OK;
  int    off = 0;
  int    len = 0;
  int    max_off = 0 ;
  char   insep[2] = NULL_STRING;
  char   outsep[2] = NULL_STRING;

 **
  *    Initialize
  **

  BUILD_STRING_SEPARATOR( insep,  insep_c)
  BUILD_STRING_SEPARATOR( outsep, outsep_c)

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);
  ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                  "inlist1=%s inlist2=%s",inlist1,inlist2);

  max_off = strlen(inlist1);
  *outlist = NULL_CHAR;

  off = strspn(inlist1,insep);

 **
  *    Loop on first input list keywords
  **

  while ( off LT max_off ) {

    len = strcspn(inlist1+off,insep);
    if (len GT 0) {

        ** if item is in second list, add it to output list **

       if (len GT sizeof(item)-1) {
         rc = ESA_ERR;
         goto exit;
       }
       strncpy(item,inlist1+off,len);
       item[len] = NULL_CHAR;
       if (ADDINFO_list_search(inlist2,item,insep_c) NE NULL) {
          if ( *outlist NE NULL_CHAR )
             strcat(outlist,outsep);
          strcat(outlist,item);
       }
       off += len;
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,2,
                       "item=%s, outlist=%s",item,outlist);
    }
    off += strspn(inlist1+off,insep);

  } ** while **

 **
  *   Finish
  **

  exit: ;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

  return rc;

}

**   end   WS10079                                           **
***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_clear_value                        *
*                                                             *
* DESCRIPTION    : Clear value of entering pair               *
*                                                             *
* INPUT          : pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_clear_value(ONE_FIELD_rec_ptr  pair)
{

 **
  *  Variables
  **

  ESA_RC rc = ESA_OK;
  static char func[] = "ADDINFO_clear_value";

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

 **
  *  Clear value
  **

  pair->value[0] = NULL_CHAR;
  pair->vallen   = 0;

 **
  *  finish
  **

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_clear                              *
*                                                             *
* DESCRIPTION    : Clear Addtional info area                  *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_clear(ADDINFO_rec_ptr addinfo)
{

    static char func[] = "ADDINFO_clear";
    int i;
    ESA_RC rc = ESA_OK;
    ONE_FIELD_rec_ptr f_ptr;

    ** initialize        **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

    if (addinfo NE NULL) {

       ** addinfo num pairs **

       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                       "num_pairs = %d, max_pairs = %d",
                       addinfo->num_pairs,addinfo->max_pairs);

       ** addinfo pairs **

       i = 0;
       f_ptr = addinfo->pair;
       while ( i LT addinfo->num_pairs) {
          ESA_DIAG_printf(PLT_COMP_API_ADDINFO,1,
                          "pair no. %3d: kwd=%s(%3d) val=%s(%3d)",
                          i+1, f_ptr->keyword,f_ptr->keylen,
                          f_ptr->value,f_ptr->vallen) ;
          ADDINFO_clear_value(f_ptr);
          f_ptr++;
          i++;
       }

    } ** addinfo pointer not empty **

    ** finish            **

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc );

    return rc;
  } ** ADDINFO_dump **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert_cond                        *
*                                                             *
* DESCRIPTION    : Search kwd1 with val1 in addinfo1          *
*                  and if it matches, add kwd2 with val2      *
*                  to addinfo2 .                              *
*                                                             *
* INPUT          : kwd1                                       *
*                  val1                                       *
*                  addinfo1                                   *
*                  kwd2                                       *
*                  val2                                       *
*                                                             *
* OUTPUT         : addinfo2                                   *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
***************************************************************

void ADDINFO_insert_cond( char              * kwd1,
                          char              * val1,
                          ADDINFO_rec_typ   * addinfo1,
                          char              * kwd2,
                          char              * val2,
                          int                 max_kwdlen,
                          int                 max_vallen,
                          ADDINFO_rec_typ   * addinfo2 )
{

   ONE_FIELD_rec_ptr   cpair;

   cpair = ADDINFO_search( kwd1, max_kwdlen,
                           addinfo1->pair, addinfo1->num_pairs);
   if (cpair NE NULL)
      if (strcmp(cpair->value, val1) EQ 0 )
         ADDINFO_insert(cpair->add_typ, kwd2, val2, addinfo2,
                        max_kwdlen, max_vallen, UNIQUE);

}

 ***************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_get_value                          *
 *                                                             *
 * DESCRIPTION    : Get parameter from ADDINFO                 *
 *                                                             *
 * INPUT          : addinfo                                    *
 *                  parameter_name                             *
 *                                                             *
 * OUTPUT         : parameter_value                            *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 ***************************************************************
 ESA_RC ADDINFO_get_value(ADDINFO_rec_typ    * addinfo,
                          char               * parameter_name,
                          char               * parameter_val,
                          int                  max_kwdlen,
                          int                  max_vallen)
 {

   static char       func[]="ADDINFO_get_value";
   ONE_FIELD_rec_ptr cpair;
   ESA_RC            rc = ESA_OK;

  **
   *    Initialize
   **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO ,4,func);

  **
   *    Get Parameter
   **

   cpair=ADDINFO_search(parameter_name, max_kwdlen,
                        addinfo->pair, addinfo->num_pairs);
   if (cpair NE NULL) {
     if ( strlen(cpair->value) LT max_vallen ) {
       strcpy(parameter_val, cpair->value);
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                       "parameter=%s value=%d*%s",
                        parameter_name,
                        strlen(parameter_val), parameter_val);
     }
     else {
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                        "parameter=%s value=%d*%s grate then max=%d",
                         parameter_name,
                         strlen(parameter_val),
                         parameter_val, max_vallen);
        *parameter_val = NULL_CHAR;
     }
   }
   else {
     ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                     "parameter=%s not found",
                      parameter_name);
     *parameter_val = NULL_CHAR;
     rc = ESA_ERR;
   }

  **
   *    Finish
   **

   ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,4, func, rc );

   return rc;

 }

 ***************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_strip_prefix                       *
 *                                                             *
 * DESCRIPTION    : Copy prefix keyword from source addinfo    *
 *                  to target addinfo with removing prefix from*
 *                  from keyword                               *
 *                                                             *
 * INPUT          : addinfo                                    *
 *                  keyword                                    *
 *                                                             *
 * OUTPUT         : laddinfo                                   *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 ***************************************************************
 ESA_RC ADDINFO_strip_prefix(char               * keyword,
                             int                  max_kwdlen,
                             int                  max_vallen,
                             ADDINFO_rec_typ    * addinfo,
                             ADDINFO_rec_typ    * laddinfo)
 {

   static   char     func[] = "ADDINFO_strip_prefix";
   ESA_RC            rc = ESA_OK;
   ONE_FIELD_rec_ptr cpair;
   char              *work;

  **
   *    Initialize
   **

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO ,4,func);

  **
   *    Get Parameter
   **

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                   "keyword=%s", keyword);

   cpair = ADDINFO_search(keyword, max_kwdlen,
                          addinfo->pair, addinfo->num_pairs);
   if (cpair EQ NULL) {
      rc = ESA_ERR;
      goto exit;
   }

   ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                   "keyword=%s value=%s",
                   cpair->keyword, cpair->value );

   work = strchr( keyword, '.' );
   if ( work EQ NULL )   ** prefix separator not found **
      work = keyword;
   else
      work++;            ** branch over the separator **

   rc = ADDINFO_insert(cpair->add_typ,
                       work, cpair->value, laddinfo,
                       max_kwdlen, max_vallen, UNIQUE);

  **
   *    Finish
   **

   exit :;

   ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,4, func, rc );

   return rc;

 }

 ***************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_convert_list_sep                   *
 *                                                             *
 * DESCRIPTION    : Convert string containing old seperators   *
 *                  to new seperators                          *
 *                                                             *
 * INPUT          : src_entry_sep - source entry sep           *
 *                  src_subf_sep  - source subfield  sep       *
 *                  trg_entry_sep - target entry sep           *
 *                  trg_subf_sep  - target subfield  sep       *
 *                                                             *
 * input*output   : buff    - string buffer                    *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 ***************************************************************

 EXT ESA_RC ADDINFO_convert_list_sep(char    * buff,
                                     char      src_entry_sep,
                                     char      src_subf_sep,
                                     char      trg_entry_sep,
                                     char      trg_subf_sep)
 {

   static   char     func[] = "ADDINFO_convert_list_sep";
   ESA_RC            rc = ESA_OK;
   int               i, len;

   ESA_DIAG_enter(PLT_COMP_API_ADDINFO ,4,func);

   len = strlen(buff);
   for(i=0; i LT len; i++) {
     if (buff[i] EQ src_entry_sep)      ** Entry separator    **
        buff[i] = trg_entry_sep;
     else if (buff[i] EQ src_subf_sep)  ** Subfield separator **
        buff[i] = trg_subf_sep;
   **
    *  Removed by ps0161
    *  The function isprint('!') returns  - is unprintable
    *
    * else if ( isprint(buff[i]) EQ 0 )  *. Unprintable char   .*
    *    buff[i] = trg_entry_sep;
    **
   }


   ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,4, func, rc );

   return rc;

 }

 ***************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_masupd                             *
 *                                                             *
 * DESCRIPTION    : Massive updates of field in addinfo_to by  *
 *                  values of same_name fields in addinfo_from *
 *                                                             *
 * RETURN VALUE   : NONE                                       *
 *                                                             *
 ***************************************************************

void ADDINFO_masupd(ADDINFO_rec_ptr              addinfo_to,
                    ADDINFO_rec_ptr              addinfo_from,
                    ADDINFO_masupd_mode          mode,
                    CTSAMSG_DEST_TABLE_rec_typ * dest,
                    CTSAMSG_HANDLE_rec_typ     * msgs)
{
  ONE_FIELD_rec_ptr pair_from, pair_to;
  static  char    func[]="ADDINFO_masupd";

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO ,1,func);

  if ( (addinfo_to->num_pairs EQ 0)  OR
       (addinfo_from->num_pairs EQ 0) )
    goto exit;

  pair_from = addinfo_from->pair;

  while (pair_from NE NULL)
   {
    pair_to = ADDINFO_search(pair_from->keyword,
                        MAX_RSS_ADDINFO_KWD_LEN,
                        addinfo_to->pair,
                        addinfo_to->num_pairs );
    if (pair_to NE NULL)
     ADDINFO_updval(pair_from->value, MAX_RSS_ADDINFO_VAL_LEN, pair_to);
    else
    if (mode EQ ADDINFO_masupd_Merge)
     ADDINFO_insert(pair_from->add_typ,
                    pair_from->keyword,
                    pair_from->value,
                    addinfo_to,
                    MAX_RSS_ADDINFO_KWD_LEN,
                    MAX_RSS_ADDINFO_VAL_LEN,
                    UNIQUE);

    pair_from=ADDINFO_get_next(addinfo_from,pair_from);
   }

  exit:;

  ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,1, func, ESA_OK);
}

 ***************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_expand_from_buffer                 *
 *                                                             *
 * DESCRIPTION    : build addinfo object from a buffer of      *
 *                  null-terminated pairs (kwd,type,value).    *
 *                                                             *
 * RETURN VALUE   : NONE                                       *
 *                                                             *
 ***************************************************************

ESA_RC ADDINFO_expand_from_buffer (char *buffer,
                                  int  buffer_length,
                                  ADDINFO_rec_ptr addinfo)
{
  static  char    func[]="ADDINFO_expand_from_buffer";

  char *Kwd_Begin, *Value_Begin, *Type_Begin;
  int  Kwd_Length, Value_Length, Type_Length, buffer_loc = 0;
  ADDINFO_typ Type;
  ESA_RC rc = ESA_OK;

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO ,1,func);

  if ( (buffer_length LE 0) OR ((*buffer) EQ NULL_CHAR) )
   {
    rc = ESA_ERR;
    goto exit;
   };

  while (buffer_loc LT buffer_length)
   {
    Kwd_Begin = buffer + buffer_loc;
    Kwd_Length = strlen(Kwd_Begin);
    Type_Begin = Kwd_Begin + Kwd_Length + 1;
    Type_Length = strlen(Type_Begin);
    Value_Begin = Type_Begin + Type_Length + 1;
    Value_Length = strlen(Value_Begin);

    if (strcmp(Type_Begin,"1A") EQ 0)
     Type = TYPE_1A;
    else
    if (strcmp(Type_Begin,"1B") EQ 0)
     Type = TYPE_1B;
    else
    if (strcmp(Type_Begin,"2A") EQ 0)
     Type = TYPE_2A;
    else
    if (strcmp(Type_Begin,"2B") EQ 0)
     Type = TYPE_2B;
    else
     {
      rc = ESA_ERR;
      goto exit;
     };

    ADDINFO_insert(Type,
                  Kwd_Begin,
                  Value_Begin,
                  addinfo,
                  MAX_RSS_ADDINFO_KWD_LEN,
                  MAX_RSS_ADDINFO_VAL_LEN,
                  MULTIPLE);

    buffer_loc += Kwd_Length + Type_Length + Value_Length + 3;
   };

  exit:;

  ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,1, func, rc);

  return rc;
}

 ***************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_pack_to_buffer                     *
 *                                                             *
 * DESCRIPTION    : build a buffer of null-terminated strings  *
 *                  from addinfo object.                       *
 *                                                             *
 * RETURN VALUE   : NONE                                       *
 *                                                             *
 ***************************************************************

ESA_RC ADDINFO_pack_to_buffer (char *buffer,
                              int  buffer_length,
                              ADDINFO_rec_ptr addinfo,
                              int  *actual_buffer_length)
{
  static  char    func[]="ADDINFO_pack_to_buffer";

  ONE_FIELD_rec_ptr pair = NULL;
  int i, buffer_loc = 0;
  char Type[2];
  ESA_RC rc = ESA_OK;

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO,1,func);

  for(i=0;i LT addinfo->num_pairs;i++)
   {
    pair = ADDINFO_get_next(addinfo,pair);

    if ((buffer_loc + strlen(pair->keyword) + strlen(pair->value) + 32)
                     GT buffer_length)
      {
       rc = ESA_ERR;
       goto exit;
      };

    memcpy(buffer + buffer_loc,pair->keyword,
                               strlen(pair->keyword)+1);
    buffer_loc += strlen(pair->keyword) +1;

    switch(pair->add_typ)
     {
      case TYPE_1A: strcpy(Type,"1A");
                    break;
      case TYPE_1B: strcpy(Type,"1B");
                    break;
      case TYPE_2A: strcpy(Type,"2A");
                    break;
      case TYPE_2B: strcpy(Type,"2B");
                    break;
      default:
         ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                         "Bad ADDINFO type %d for field %s",
                         pair->add_typ,pair->keyword);
         rc = ESA_ERR;
                    goto exit;
     };

    memcpy(buffer + buffer_loc,Type,strlen(Type)+1);
    buffer_loc += strlen(Type) +1;

    memcpy(buffer + buffer_loc,pair->value,strlen(pair->value)+1);
    buffer_loc += strlen(pair->value) +1;
   };

  (*actual_buffer_length) = buffer_loc;

  exit:;

  ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,1, func, rc);
  return rc;
}

** ps0292 Digital certificate functions **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert_dgt                         *
*                                                             *
* DESCRIPTION    : Insert a keyword in additional info        *
*                                                             *
* INPUT          : type             -  addinfo type           *
*                  kwd              -  keyword                *
*                  value            -  value                  *
*                  addinfo          -  additional info        *
*                  dupflag          -  allow duplicate flag   *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************

ESA_RC ADDINFO_insert_dgt  (ADDINFO_typ        type,
                            char               *kwd,
                            char               *val,
                            int                 vallen,
                            ADDINFO_rec_ptr    addinfo,
                            int                max_kwdlen,
                            int                max_vallen,
                            ADDINFO_DUPLICATE  dupflag)
 {

   **
    *  Variables
    **

    static char func[] = "ADDINFO_insert_dgt";
    int i=0;
    int kwdlen;
    ONE_FIELD_rec_ptr cpair;
    ESA_RC rc = ESA_OK ;

   **
    *  initialize
    **

    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 2, func);

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "num_pairs = %d, max_pairs = %d",
                    addinfo->num_pairs,addinfo->max_pairs);

    if (addinfo->num_pairs GE addinfo->max_pairs) {
       ** rc = ESA_ERR; - deleted  AS0207 **
       rc = ESA_FATAL; ** added    AS0207 **
       goto exit;
    }

   **
    *  Validity checks
    **

    kwdlen =strlen(kwd);
    if ((kwdlen EQ 0) OR (kwdlen GT max_kwdlen)) {
       rc = ESA_FATAL;
       goto exit;
    }

    if (vallen GT max_vallen) {
       rc = ESA_FATAL;
       goto exit;
    }

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "Keyword=(%3d)'%s' Value=(%3d)'%s'",
                    kwdlen,kwd,vallen,val);

   **
    *  Verify that keyword is not yet used
    **

    cpair = addinfo->pair;
    while (i LT addinfo->num_pairs) {

       ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                       "Entry %d,%X: kwd=%s(%3d),val=%s(%3d)",
                       i,cpair,
                       cpair->keyword,cpair->keylen,
                       cpair->value,cpair->vallen);

       if (dupflag EQ UNIQUE)
          if (strcmp(cpair->keyword,kwd) EQ 0) {
             rc = ESA_ERR;
             goto exit;
          }

       else if ( *(cpair->keyword) EQ NULL_CHAR)
             break;

       cpair++;
       i++;

    } ** while **

   **
    *    Add the Keyword
    **

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO,3,
                    "Updating entry at %d,%X", i,cpair);

    cpair->add_typ = type;
    cpair->keylen = kwdlen;
    strcpy(cpair->keyword,kwd);
    addinfo->num_pairs++;

   **
    *    Update the value
    **

    ADDINFO_updval_dgt(val,vallen, max_vallen,cpair);

   **
    *    Finish
    **
    exit: ;

    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 2, func, rc);

    return rc;

  } ** ADDINFO_insert **

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_updval_dgt                         *
*                                                             *
* DESCRIPTION    : Update a value of an exiting entry         *
*                                                             *
* INPUT          : value     - Value to be updated            *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_updval_dgt (char               *addval,
                           int                vallen,
                           int                max_vallen,
                           ONE_FIELD_rec_ptr  pair)
{

 **
  *  Variables
  **

  ESA_RC rc = ESA_OK;
  static char func[] = "ADDINFO_updval";

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

 **
  *  Enough place for value ?
  **
  if ( vallen GE max_vallen) {
     rc = ESA_FATAL;
     goto exit;
  }

 **
  *  update value
  **

  memcpy(pair->value, addval, vallen);
  pair->vallen = vallen;

 **
  *  finish
  **

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;

}

***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_addval_dgt                         *
*                                                             *
* DESCRIPTION    : Conactenate a value to an exiting one      *
*                                                             *
* INPUT          : addval    - Value to be added              *
*                  addsep    - Seperator between value list   *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_addval_dgt (char                      *addval,
                           int                        vallen,
                           int                        max_vallen,
                           char                       addsep_c,
                           ONE_FIELD_rec_ptr          pair,
                           CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                           CTSAMSG_HANDLE_rec_ptr     p_msgs)
{

 **
  *  Variables
  **

  ESA_RC rc = ESA_OK;
  char   *wptr;
  static char func[] = "ADDINFO_addval";
  char   msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];
  char   addsep[2];

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

  BUILD_STRING_SEPARATOR( addsep, addsep_c)

 **
  *  Enough place for value ?
  **
  if ( (vallen + pair->vallen) GE max_vallen) {
     rc = ESA_FATAL;
     goto exit;
  }

 **
  *  Add seperator
  **
  if ( *pair->value NE NULL_CHAR ) {
    if ( (pair->add_typ EQ TYPE_1B)  OR
         (pair->add_typ EQ TYPE_2B)   )
     strcat(pair->value, addsep);
    else {
      sprintf(msgbuf, "Invalid type=%d for list keyword=%s",
              pair->add_typ,  pair->keyword);
      CTSAMSG_print(ERR_INTERNAL2, p_msgs, NULL, p_dest,
                    component, func, msgbuf, 0, __LINE__);
      strcat(pair->value, addsep);
    }
  }

 **
  *  Add value
  **
  wptr = pair->value + pair->vallen;
  memcpy(wptr,addval,vallen);
  pair->vallen += vallen;

 **
  *  finish
  **

  exit:;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;

}

***************************************************************
*                                                      IS0208 *
* PROCEDURE NAME : ADDINFO_value_addval                       *
*                                                             *
* DESCRIPTION    : Conactenate a value to an value string     *
*                  and update string length                   *
*                                                             *
* INPUT          : addval    - Subfield * Entry to be added   *
*                  addval_len - Added string length           *
*                  current_val - Addinfo value string         *
*                  current_val_len - Addinfo value string len *
*                  ( passed by address for update )           *
*                  max_vallen - Max value string length       *
*                  addsep_c  - Sufield * List entry seperator *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
ESA_RC ADDINFO_value_addval (char                      *addval,
                             int                        addval_len,
                             char                      *current_val,
                             int                       *current_val_len,
                             int                        max_vallen,
                             char                       addsep_c,
                             ADMIN_PARAMS_rec_typ      *admin_params)
{

 **
  *  Variables
  **

  ESA_RC rc = ESA_OK;
  char   *wptr;
  static char func[] = "ADDINFO_value_addval";

  admin_params->cs_func.DIAG_enter_ptr(
     PLT_COMP_API_ADDINFO, 1, func);

 **
  *  Enough place for value ?
  **
  if ( (*current_val_len + addval_len) GE max_vallen) {
     rc = ESA_FATAL;
     goto exit;
  }

 **
  *  Add seperator if value is not empty
  **
  if ( *current_val_len GT 0 ) {                            ** IS0212 **
     current_val[ (*current_val_len) ] = addsep_c;
     (*current_val_len)++;
  }

 **
  *  Add value
  **
  wptr = current_val + (*current_val_len);
  strncpy(wptr, addval, addval_len + 1);
  *current_val_len += addval_len;

 **
  *  finish
  **

  exit:;

  admin_params->cs_func.DIAG_exit_ptr(
     PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;

}

**  IS10100A - start   **
***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_split_by_prefix                    *
*                                                             *
* DESCRIPTION    : split the addinfo to 2 or more addinfos:   *
*                  - entries matching the prefix are copied   *
*                    to to_prefix.                            *
*                  - all other entries are copied to          *
*                    to_general.                              *
*                                                             *
* INPUT          : from - input addinfo.                      *
*                  to_prefix_num - number of addinfos in      *
*                                  to_prefix vector.          *
*                  prefix - prefix for split.                 *
*                                                             *
* OUTPUT         : to_general - addinfo for non-prefix        *
*                               entries.                      *
*                  to_prefix - vector of pointers to addinfos *
*                              for prefix entries.            *
*                                                             *
* RETURN VALUE   : ESA_OK - when all OK.                      *
*                  ESA_ERR - when output overflow.            *
*                                                             *
*                                                             *
* *** ATTEMTION  : This function does not support splitting   *
*                  addinfo contsining non-string digital      *
*                  certificate attributes.                    *
*                                                             *
*                                                             *
***************************************************************
ESA_RC  ADDINFO_split_by_prefix(ADDINFO_rec_ptr  from,
                                ADDINFO_rec_ptr  to_general,
                                ADDINFO_rec_ptr *to_prefix,
                                int              to_prefix_num,
                                char            *prefix)
{

  static char func[] = "ADDINFO_split_by_prefix";

  ESA_RC rc = ESA_OK;
  ONE_FIELD_rec_ptr pair = NULL;
  int    i;
  int    j;
  ADDINFO_rec_ptr out;

  **
   *  Initialization
   **

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "FROM at %X, used %d  max %d",
                  from,from->num_pairs,from->max_pairs);
  ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "TO-general at %X,  max %d",
                  to_general,to_general->max_pairs);
  ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "TO-prefix vec at %X, num %d  max %d",
                  to_prefix, to_prefix_num, to_prefix[0]->max_pairs);

  **
   *  verify output large enough
   **

  if ( ( (to_prefix[0]->max_pairs * (to_prefix_num - 1)) +
       to_prefix[to_prefix_num - 1]->max_pairs  +
       to_general->max_pairs)    LT
       from->num_pairs )
  {
    rc = ESA_ERR;
    goto exit;
  }

  **
   *  Split the addinfo by prefix.
   **
  j = 0;

  for (i = 0 ; i < from->num_pairs  AND  j LT to_prefix_num; i++)
  {
    pair = ADDINFO_get_next(from, pair);
    if (pair NE NULL)
    {
      if ( memcmp(pair->keyword, prefix, strlen(prefix)) EQ 0 )
      {
        if (to_prefix[j]->num_pairs GE to_prefix[j]->max_pairs)
          if (++j GE to_prefix_num)
          {
            rc = ESA_ERR;
            break;
          }

        out = to_prefix[j];
      }
      else
        out = to_general;

      ** Insert_dgt is used in order to support non-string values. **
      ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "copy keyword %s to addinfo at %8X",
                  pair->keyword, out);
      rc = ADDINFO_insert(pair->add_typ, pair->keyword,
                          pair->value, out,
                          RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                          UNIQUE);
      ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "keyword %s was copied to addinfo at %8X",
                  pair->keyword, out);
      if (rc NE ESA_OK)
      {
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 0,
          "Insert of keyword %s(%s)to addinfo at %8X failed with rc %d",
          pair->keyword, pair->value, out, rc);
        rc = ESA_FATAL;
      }
    }
  }

  **
   *  return
   **

 exit: ;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);

  return rc;

}  **  ADDINFO_split_by_prefix  **

**  IS10100A - end     **

**  IS10100 - start    **
***************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_count_by_prefix                    *
*                                                             *
* DESCRIPTION    : Count the number of entries with a         *
*                  specific prefix.                           *
*                                                             *
* INPUT          : addinfo - ut addinfo.                      *
*                  prefix - prefix for count.                 *
*                  prefix_with_data - count only pairs with   *
*                                     data (TRUE) or all      *
*                                     (FALSE).                *
*                  other_with_data - count only pairs with    *
*                                    data (TRUE) or all       *
*                                    (FALSE).                 *
*                                                             *
* OUTPUT         : prefix_num - number of entries with        *
*                               prefix.                       *
*                  other_num - number of other entries.       *
*                                                             *
* RETURN VALUE   :                                            *
*                                                             *
***************************************************************
void  ADDINFO_count_by_prefix(ADDINFO_rec_ptr  addinfo,
                              char            *prefix,
                              int             *prefix_num,
                              int             *other_num,
                              int              prefix_with_data,
                              int              other_with_data)
{

  static char func[] = "ADDINFO_count_by_prefix";

  ONE_FIELD_rec_ptr pair = NULL;
  int    i;
  int    p_num, o_num;
  int    prefix_len = strlen(prefix);

  **
   *  Initialization
   **

  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "addinfo at %X, used %d  max %d",
                  addinfo,addinfo->num_pairs,addinfo->max_pairs);
  ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                  "Prefix = %s", prefix);

  p_num = 0;
  o_num = 0;

  for (i = 0; i LT addinfo->num_pairs; i++)
  {
    pair = &addinfo->pair[i];

    if ( (pair->keylen GT prefix_len)   AND
         (memcmp(pair->keyword, prefix, prefix_len) EQ 0) )
      if ( NOT prefix_with_data   OR
          ( prefix_with_data  AND  pair->vallen GT 0) )
        p_num++;
    else
      if ( NOT other_with_data   OR
          ( other_with_data  AND  pair->vallen GT 0) )
        o_num++;
  }

  ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
              "There are %d prefix entries and %d general entries",
              p_num, o_num);

  *prefix_num = p_num;
  *other_num = o_num;

  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, ESA_OK);

}

**  IS10100 - end      **

** WS10070 - start **
*********************************************************************
* Procedure Name: ADDINFO_list_getnextvalue                         *
*                                                                   *
* Description : Get one value from list field.                      *
*               The routine can be used to get list values one      *
*               by one.                                             *
*               Note:                                               *
*               This routine does not handle sub-fields.            *
*                                                                   *
* Input :  pair - add_info pair to be parsed                        *
*          field_separator - delimiter to get field from list       *
*          lasts - lasts position to continue getting values        *
*                  lasts must be NULL when called for first time    *
* Output:                                                           *
*          token - A copy of the next value from the list-type      *
*                  value, NULL_CHAR when end of values.             *
*                  token should be defined by the caller as a       *
*                  string variable with length enough to get the    *
*                  longest expected value.                          *
*                                                                   *
* Return value: ESA_OK                                              *
*               ESA_EOF - If we reach to end of string              *
*                                                                   *
*********************************************************************

ESA_RC ADDINFO_list_getnextvalue(ONE_FIELD_rec_ptr pair,
                                char field_separator,
                                char *token,
                                char **lasts)
{
    static char func[] = "ADDINFO_list_getnextvalue";
    char *start_ptr, temp_char, *iterator;
    ESA_RC rc = ESA_OK;
    ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);


    if ( *lasts NE NULL )
    {
        iterator = *lasts;
    }
    else
    {
        **calling for first time **
        iterator = pair->value;
        *lasts = iterator;
    }

    if(iterator EQ NULL OR *iterator EQ NULL_CHAR )
    {
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 10,
                    "iterator is NULL");
        *token = NULL_CHAR;
        rc = ESA_EOF;
        goto exit;
    }

    ** Check if first character is separator and not the end of   *
     * string. Move pointer to next character to read next token  **


    if ( (*iterator EQ field_separator) AND
         (*(iterator+1) NE NULL_CHAR)       )
    {
        iterator++;
    }

    start_ptr = iterator;

    while ( (*iterator NE NULL_CHAR)    AND
            (*iterator NE field_separator) )
    {
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 99,
          "iterator_len - %d, iterator - %c", strlen(iterator)
           , *iterator);

        iterator++;
    }

    if( start_ptr NE iterator )
    {
        temp_char = *iterator;
        *iterator = NULL_CHAR;
        strcpy (token, start_ptr);
        *iterator = temp_char;
        *lasts = iterator;
    }
    else
        *token = NULL_CHAR;

    exit :

    ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 5,
                        "Token: %s", token);
    ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, ESA_OK);

    return rc;
}
** WS10070 - end **
 * WS10082 - end */
