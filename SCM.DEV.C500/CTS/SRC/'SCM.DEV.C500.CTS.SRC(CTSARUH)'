         TITLE 'CTSARUH - RUOB HANDLING '
*                                                                       00000901
****************************************************************        00000201
****                                                        ****        00000301
****     MF CONNECTOR RELEASE 4.0.00                        ****        00000401
****                                                        ****        00000501
****     (C) COPYRIGHT 2019 SAILPOINT TECHNOLOGIES, INC.,   ****        00000601
****     ALL RIGHTS RESERVED.                               ****        00000701
****                                                        ****        00000801
****************************************************************        00000901
*                                                                       00000901
****************************************************************        00001001
*                                                              *        00001101
* TITLE            : CTSARUH                                   *        00001201
*                                                              *        00001501
* AUTHOR           : NURIT YAHALOM                             *        00001601
*                                                              *        00001701
* CREATION DATE    : 23 NOVEMBER 2020                          *        00001801
*                                                              *        00001901
* DESCRIPTION      : HANDLE THE RUOB:                          *        00002001
*                    PUT - PUT A RECORD TO THE RUOB. WHEN     .*        00002101
*                          NEEDED, ALLOCATE A NEW RUOB AND     *        00002101
*                          CHAIN TO THE CURRENT (IF NOT FIRST) *        00002101
*                    GETNEXT - GET THE NEXT LINE FROM RUOB.    *        00002101
*                    GETFIRST - GET THE FIRST LINE FROM THE    *        00002101
*                               RUOB.                          *        00002101
*                    TERMIO - FREE THA HANDLE.                 *        00002101
*                    FREE - FREE THE RUOB CHAIN.               *        00002101
*                                                              *        00002101
* PARAMETERS       : 1. FUNCTION:                              *        00002101
*                       - STARTIO  - INITIALIZE THE HANDLE     *        00002101
*                                    THAT WAS ALLOCAETD BY THE *        00002101
*                                    CALLER...  SEE BELOW.     *        00002101
*                       - GETFIRST - GET FIRST LINE.           *        00002101
*                       - GETNEXT - GET NEXT LINE.             *        00002101
*                       - PUT - PUT THE LINE TO THE RUOB.      *        00002101
*                       - TERMIO - FREE THE HANDLE.            *        00002101
*                       - FREERUOB FREE THE RUOB CHAIN,        *        00002101
*                       - TERMNFRE - FREERUOB + TERMIO.        *        00002101
*                    2. HANDLE                                 *        00002101
*                    3. BLOCK ADDRESS (I/O)  (8)               *        00002101
*                       - GET - FIRST RUOB ADDRESS. (I)        *        00002101
*                       - PUT - FIRST RUOB ADDRESS (I/O)       *        00002101
*                       - FREE - FIRST RUOB ADDRESS. (I)       *        00002101
*                    4. LINE                                   *        00002101
*                       - GET - AREA FOR LINE.                 *        00002101
*                               THE AREA SHOULD BE LONG        *        00002101
*                               ENOUGH FOR THE LINE WITH       *        00002101
*                               X'00' AT THE END.              *        00002101
*                       - PUT - LINE TO PUT.                   *        00002101
*                    5. LINE LENGTH. (4)                       *        00002101
*                       FOR GET:                               *        00002101
*                       - THIS PARAMETER IS OPTIONAL.          *        00002101
*                       - THE LENGTH RETURNED DOES NOT INCLUDE *        00002101
*                         THE X'00' AT THE OF OF THE LINE.     *        00002101
*                    6. LENGTH: (4)                            *        00002101
*                       - PUT - BLOCK LENGTH IN MB TO BE USED  *        00002101
*                               WHEN THE FIRST BLOCK IS        *        00002101
*                               ALLOCTED.                      *        00002101
*                       - GET - LINE BUFFER LENGTH             *        00002101
*                    7. USERTOKEN (I/O)  (4)                   *        00002101
*                       - PUT - A FIELD CONTAINING A NUMBER    *        00002101
*                               WHICH, AFTER INCREASED BY 1    *        00002101
*                               WILL BE USED AS USER TOKEN FOR *        00002101
*                               IARV64 GETSTOR.                *        00002101
*                       - GET - N/A.                           *        00002101
*                    8. DEBUG LEVEL (4)                        *        00002101
*                    9. DEBUG TYPE  (8) - WTO / PRTDBG         *        00002101
*                   10. AREA FOR ERROR MESSAGE (170)           *        00002101
*                       X'00' IS APPENDED TO THE ERORR MESSAGE *        00002101
*                       TEXT.                                  *        00002101
*                   11. ERROR MESSAGE AREA LENGTH (4) (I)      *        00002101
*                       SHOULD NOT BE LESS THAN 170.           *        00002101
*                   12. ERROR MESSAGE LENGTH (4) (O)           *        00002101
*                       THIS PARAMETER IS OPTIONAL.            *        00002101
*                       WHEN SPECIFIED, THE LENGTH OF THE      *        00002101
*                       ERROR MESSAGE, WITHOUT THE X'00' AT    *        00002101
*                       THE END, IS RETURNED.                  *        00002101
*                                                              *        00002101
* RETURN CODES     :  0 - OPERATION WAS PROCESSED SUCCESSFULY. *        00002101
*                     4 - GET - EOF.                           *        00002101
*                         PUT - BLOCK ALLOCATION FAILED.       *        00002101
*                         TERMIO - CALLER IS THE OWNER.        *        00002101
*                     8   LINE TOO LONG.                       *        00002101
*                    12 - HANDLE ALLOCATION FAILED.            *        00002101
*                    16 - PARMAETERS ERROR.                    *        00002101
*                    20 - INTERNAL ERROR.                      *        00002101
*                                                              *        00002101
*                                                              *        00002101
* MESSAGES         : 1. THIS ROUTINE IS CALLED FROM DIFFERENT  *        00002101
*                       ENVIRONMENTS (ACFRPTRX, REXX, CS/CD).  *        00002101
*                       THEREFORE, IT WILL NOT ISSUE ITS ERROR *        00002101
*                       MESSAGES, BUT WILL CREATE THEM AND     *        00002101
*                       RETURN TO THE CALLER. THE RETURNED     *        00002101
*                       MESSAGES HAVE THE NULL TERMINATOR SO   *        00002101
*                       THAT THEY CAN BE HANDLED WITH C        *        00002101
*                       STRING FUNCTIONS.                      *        00002101
*                                                              *        00002101
*                    2. NO MESSAGE WILL BE RETURNED FOR ERRORS *        00002101
*                       OCCURING BEFORE OR WHILE ALLOCATING OR *        00002101
*                       VERIFYING THE HANDLE, OR ERRORS IN     *        00002101
*                       THE MESSAGES PARAMETERS.               *        00002101
*                                                              *        00002101
*                                                              *        00002101
* ASSUMPTIONS AND                                              *        00002201
*   CONSIDERATIONS : 1. THIS ROUTINE IS REENTRANT AND          *        00002301
*                       REUSABLE.                              *        00002401
*                    2. THIS ROUTINE IS CALLED BY ASSEMBLER    *        00002101
*                       AND C SO EVERY STRING IT RETURNS       *        00002101
*                       SHOULD HAVE X'00' AT THE END TO        *        00002101
*                       MAKE IT A VALID C STRING.              *        00002101
*                    3. THIS ROUTINE SWITCHES TO AMODE 64      *        00002401
*                    4. THIS ROUTINE IS WRITTEN WITH RELATIVE  *        00002401
*                       B (J) AND ADDRESS LOAD (LARL).         *        00002401
*                       MACRO IEABRCX IS USED TO TRANSLATE B   *        00002401
*                       TO J IN MACROS.                        *        00002401
*                       WE STILL NEED 2 BASE REGISTERS BECAUSE *        00002401
*                       OF LA COMMANDS USED BY MACROS.         *        00002401
*                    5. STARTIO CALL:                          *        00002401
*                       WHEN THE CALLER IS NOT WORKING IN A    *        00002401
*                       STANDARD ENVIRONMENT (LIKE CTS2RXO)    *        00002401
*                       IT IS SOMETIMES NEEDED TO ALLOCATE     *        00002401
*                       THE WORK AREA IN A SPECIFIC SUBPOOL    *        00002401
*                       AND KEY.                               *
*                       IN SUCH CASE, THE CALLER NEEDS FIRST   *        00002401
*                       TO CALL THIS ROUTINE WITH R1=0 (NO     *        00002401
*                       PARAMETERS) IN ORDER TO GET BACK THE   *        00002401
*                       WORK AREA LENGTH IN R15. THEN          *        00002401
*                       THE CALLER NEEDS TO ALLOCATE THE       *        00002401
*                       WORK AREA AND CALL THIS ROUTINE        *        00002401
*                       AGAIN WITH STARTIO. AFTER THIS CALL,   *        00002401
*                       THE CALLER CAN USE THE GET/PUT         *        00002401
*                       FUNCTIONS AS NEEDED. THE CALLER SHOULD *        00002401
*                       NOT CALL WITH TERMIO - IT IS HIS       *        00002401
*                       RESPONSIBILITY TO FREE THE WORK AREA.  *        00002401
*                       AFTER ALL I/O IS DONE.                 *        00002401
*                                                              *        00002401
****************************************************************        00002501
*--------------------- CTS V 4.0.00 ---------------------------*
* BS10111  23.11.20 NY NEW                                     *
* WS10079  08.02.21 NY CORRECT MESSAGE CTS271E                 *
* BS10117  19.09.21 NY ABEND SDC2-0049 -  RUOB UTOKEN          *
*                      COLLIDED WITH ATB CELLPOOL.             *
* IS10188  06.10.24 AL MOVE OUR MODULES ABOVE 16M LINE         *
****************************************************************        00002501
*-----------------------------------------------------------------*
*                     MACROS                                      *
*-----------------------------------------------------------------*
         MACRO
.*
.**   PRINT THE RUOB WHEN IN AMODE 64
.**
.**
.**   THE MACRO COPIES THE RUOB HEADER TO A BLOCK BELOW THE BAR,
.**   RESTORES THE AMODE TO THE ROUTINE CALLER AMODE, PRINTS THE
.**   DATA FROM THE BELOW-THE-BAR COPY AND CHANGES BACK TO THE MACRO
.**   CALLER AMODE.
.**   THE COPY OF THE RUOB HEADER IS DONE ONLY IF DEBUG IS NEEDED,
.**   ACCORDNG TO THE DEBUG LEVEL SPECIFIED.
.**
.**   PARAMETERS:
.**   MSG    - MESSGAE TEXT (FOR CTSADBG)
.**   PARMS  - REPLACEMENT VARIABLES FOR CTSADBG. FIELDS OF THE RUOB
.**            SHOULD BE SPECIFIED WITH THEIR NAME ONLY.
.**   BLKNM  - NAME OF "USING" FOR THE ABOVE THE BAR RUOB.
.**   DBGLVL - DEBUG LEVEL. IF MORE THAN ONE, SHOUDLD BE SPECIFIED
.**            BETWEEN BRACKETS.
.**   R      - WORK REGISTER.
.*
         DBG64 &MSG,&PARMS,&BLKNM=,&DBGLVL=,&R=R14
         LCLA  &I,&N
         LCLC  &D
.*
.**  CHECK AND PREPARE THE DBGLEVEL
.*
&N       SETA  N'&DBGLVL
&I       SETA  0
&D       SETC  '(DBGLEVEL'        CTSADBG LEVEL PARAMETER.
         AIF   (&N EQ 0).OUT
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &N).ELOOP
&D       SETC  '&D'.','.'&DBGLVL(&I)'
         CLI   DBGLEVEL,&DBGLVL(&I)
         JE    DBG&SYSNDX
         AGO   .LOOP
.ELOOP   ANOP
         J     NODBG&SYSNDX
DBG&SYSNDX DS  0H
&D       SETC  '&D'.')'
         MVC   WARUOCPY(#RUOHLEN),&BLKNM..RUO COPY BELOW (FOR DIAG)
         LHI   R0,0
         IC    R0,WAHDBGT         SET DEBUG TYPE.
         CTSAAMD SAVE,AMODSAV=WADB64AM,R=&R  SAVE CURRENT AMODE.
         CTSAAMD RESTORE,AMODSAV=WAAMODE,CMDTAB=AMDCMDTB,R=&R
*                                 SWITCH TO ROUTINE CALLER AMODE.
         LA    &R,WARUOCPY        SET ADDRESSABILITY TO THE BLOCK COPY.
         PUSH  USING
         USING RUO,&R
         CTSADBG TYPE=(R0),LEVEL=&D,                                   >
               &MSG,                                                   >
               &PARMS,                                                 >
               RAREA=RAREA,DBGAREA=DBGAREA
         POP   USING
         CTSAAMD RESTORE,AMODSAV=WADB64AM,CMDTAB=AMDCMDTB,R=&R
.*                                SWITCH TO MACRO CALLER AMODE.
NODBG&SYSNDX   DS  0H
.OUT    ANOP
         MEXIT
         MEND
*
*
*-----------------------------------------------------------------*
*                     START WORKING                               *
*-----------------------------------------------------------------*
CTSARUH  CSECT
CTSARUH  AMODE 31
*IS10188 CTSARUH  RMODE 24
CTSARUH  RMODE ANY                                             IS10188
*
         CHI   R1,0                    PARMAETERS BLOCK PROVIDED ?
         JNE   PROCREQ                 ..YES - PROCESS REQUEST.
         LHI   R15,#WALEN              R15 = WWORK AREA LENGTH.
         BR    R14                     RETURN IT TO CALLER.
*
PROCREQ  DS    0H
*                                                                       00020001
         USING CTSARUH,R15
         IEABRCX DEFINE                PREPARE FOR B -> J
*
         BAKR  R14,0                   SAVE LONG REGISTERS.
         CTSLEVEL
         IEABRCX PUSH
         IEABRCX DISABLE               DISABLE B->J CONVERSION.
*
         LR    R12,R15                 SET BASE REGISTER
         LA    R11,4095(,R12)          SET SECOND BASE
         LA    R11,1(,R11)
         DROP  R15
         USING (CTSARUH,CTSARUHE),R12,R11 ESTABLISH ADDRESSABILITY
*
         CTSARHC R0,R15                CLEAR THE HIGH-HALF + AMODE BIT  ERS
*                                      OF ALL REGISTERS TO BE READY FOR
*                                      AMODE 64.
*
         LARL  R10,CONST               R10 -> CONTATANS AREA
         USING CONST,R10
*
         LLGTR R9,R1                   R9 -> PARAMETER LIST
         USING PRM,R9
*
         CTSAAMD SAVE,AMODSAV=(R3)     R3 = AMODE AT ENTRY.
         LHI   R13,0                   R13 = 0 - NO WORK AREA.
*
**   GO PROCESS FUNCTION.
*
         LLGT  R1,PRMFUNC              R1 -> FUNCTION.
         LA    R1,0(,R1)               PURIFY HIGH-ORDER BIT/BYTE.
         CHI   R1,0
         JE    RETPRMER
*
         LHI   R5,#FTABNUM             LOOK FOR FUNCTION...
         LA    R4,FUNCTAB              ...IN FUNCTIONS TABLE.
         USING FENTRY,R4
FUNCLOOP DS    0H
         CLC   FENAME,0(R1)            OUR FUNCTION ?
         JE    DOFUNC                  ..YES - PROCESS.
         LA    R4,#FELEN(,R4)          R4 -> NEXT ENTRY IN FUNCTAB.
         BCT   R5,FUNCLOOP             CHECK NEXT ENTRY.
         J     RETPRMER                FUNCTION UNKNOWN.
DOFUNC   DS    0H
         CTSAAMD 31
         L     R15,FERTN1              R15 -> FUNCTION ROUTINE.
         BR    R15                     GO PROCESS FUNCTION.
*
**  ISSUE ERROR MESSAGES (COMMON TO ALL) AND SET RETURN CODE.
*
RETOK    DS    0H                      OK
         LHI   R15,#RCOK
         B     RETURN
*
RETPRMER DS    0H                      PARAMETERS ERROR (NO WA).
         LHI   R15,#RCPRM
         J     RETURN
*
         USING WA,R13
RETPRMSG DS    0H                      ERROR IN PARAMETER.
         MVI   WAHBLUNU,#WAHUNUY       SET 'UNUSABLE'
         LHI   R1,MSG270-MSGRTN        ISSUE CTS250E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LHI   R15,#RCPRM
         J     RETPRMER
*
RETHALER DS    0H                      PARAMETERS ERROR (NO WA).
         LHI   R15,#RCHNDAL
         J     RETURN
*
RETL2LER DS    0H                      LINE TOO LONG
         LHI   R1,MSG272-MSGRTN        ISSUE CTS272E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LHI   R15,#RCL2L              SET RC.
         J     RETURN
*
RETUNUER DS  0H                        BLOCK ARE UNUSABLE.
         CLI   WAHUNUMS,#WAHUNMY       MESSGAE ISSUED ?
         JE    RETINTRC                ..YES - NO NEED AGAIN.
         MVI   WAHUNUMS,#WAHUNMY       SET 'MESSAGE ISSUED'
         LHI   R1,MSG275-MSGRTN        ISSUE CTS275E
         LARL  R15,MSGRTN
         BASR  R14,R15
         JE    RETINTRC                ..YES - NO NEED AGAIN.
*
RETINTER DS    0H                      INTERNAL ERROR MESSAGE
         LHI   R1,MSG274-MSGRTN        ISSUE CTS274E
         LARL  R15,MSGRTN
         BASR  R14,R15
RETINTRC DS    0H
         LHI   R15,#RCINT              SET RC.
         J     RETURN
*
**  RETURN
*
RETURN   DS    0H
         CHI   R13,0                   DO WE HAVE A SAVE WORK AREA ?
         BE    OUT                     ..NO - SKIP DIAG
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: RETURN WITH RC = #',(WAFUNC,8,?R15),                >00037400
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         IEABRCX POP
         XC    SA+4(4),SA+4            ZERO SA TYPE.
OUT      DS    0H
         PR    ,
         DROP  R13
*-----------------------------------------------------------------*
*                                                                 *
*                          STARTIO                                *
*                                                                 *
*  STARTIO IS CALLED ONLY WHEN THE CALLER ALLOCATES THE HANDLE    *
*  AFTER CALLING US WITH A 0-HANDLE ADDRESS TO GET THE LENGTH.    *
*  IN THIS ROUTINE WE JUST INITIALIZE THE HANDLE SO IT CAN BE     *
*  USED BY THE SUBSEQUENT CALLS.                                  *
*  THE HANDLE IS MARKED AS OWNER=CALLER. IF WE WILL BE LATER      *
*  CALLED FOR TERMIO WITH THIS HANDLE, WE WILL NOT FREE IT        *
*  BECAUSE IT IS OWNED BY THE CALLER (AND PROBABELY WAS           *
*  ALLOCATED WITH A SPECIFIC SUBPOOL, KEY, ETC. OR ALONG WITH     *
*  OTHER WORK AREAS, OR BOTH).                                    *
*                                                                 *
*  THIS CALL, WHICH FOLLOWS THE 0-HANDLE ADDRESS CALL (TO GET     *
*  THE HANDLE LENGTH) IS USED BY CTS2RXO IN ORDER TO ALLOCATE     *
*  THE HANDLE IN SUBPOOL 230, SO THAT WE ARE SURE IT WILL BE      *
*  FREED WHEN THE TASK ENDS, REGARDLESS OF THE ATTATCH            *
*  PARAMETERS. THIS IS REQUIRED BECAUSE CTS2RXO WILL NOT CALL US  *
*  WITH TERMIO. CTS2RXO DOES NOT GET CONTROL AFTER THE LAST       *
*  LINE IS WRITTEN, AND THEREFORE CANNOT CALL WITH TERMIO.        *
*                                                                 *
*                                                                 *
*  REGISTERS AT ENTRY:                                            *
*  R3  =  CALLER AMODE.                                           *
*  R4  -> ENTRY IN FUNCTIONS TABLE (FUNCTAB).                     *
*  R9  -> PARAMETERS BLOCK.                                       *
*  R10 -> CONSTANTS AREA.                                         *
*  R12+R11 - BASE.                                                *
*                                                                 *
*-----------------------------------------------------------------*
STARTIO  DS    0H
*
**   INITIALIZE THE ENVIRONMENT.
*
         LHI   R0,#IRINIT              REQUEST TO INITIALIZE THE
*                                      HANDLE.
         LARL  R15,INITRTN
         BASR  R14,R15
         CHI   R15,#RCOK               OK ?
         JE    STSETONR                ..YES - SET OWNER.
         LR    R14,R15                 ..NO - GET RETURN ADDRESS AND...
         J     STRET                          ...OUT (RC ALREADY SET)
*
**   SET OWNER = CALLER.
*
STSETONR DS    0H
         USING WA,R13
         MVI   WAHOWNER,#WAHOWNC       OWNER = CALLER.
         LARL  R14,RETOK
STRET    DS    0H
         BR    R14
         DROP  R13
*
*-----------------------------------------------------------------*
*                                                                 *
*                            PUT                                  *
*                                                                 *
*  REGISTERS AT ENTRY:                                            *
*  R3  =  CALLER AMODE.                                           *
*  R4  -> ENTRY IN FUNCTIONS TABLE (FUNCTAB).                     *
*  R9  -> PARAMETERS BLOCK.                                       *
*  R10 -> CONSTANTS AREA.                                         *
*  R12+R11 - BASE.                                                *
*                                                                 *
*-----------------------------------------------------------------*
PUT      DS    0H
*
**   INITIALIZE THE ENVIRONMENT.
*
         LHI   R0,#IRVNA               REQUEST TO GET/ALLOC HANDLE.
         LARL  R15,INITRTN
         BASR  R14,R15                 GET/ALLOCATE HANDLE.
         CHI   R15,#RCOK               OK ?
         JE    PTGTPRMS                ..YES - PROCESS THE PUT REQUEST.
         LR    R14,R15                 ..NO - GET RETURN ADDRESS AND...
         J     PTRET                          ...OUT (RC ALREADY SET)
*
PTGTPRMS DS    0H
         LARL  R15,PARMSGET
         BASR  R14,R15                 GET COMMON PARAMETERS.
         CHI   R15,#RCOK               OK ?
         JE    PTPROC                  ..YES - PROCESS THE PUT REQUEST.
         LR    R14,R15                 ..NO - GET RETURN ADDRESS AND...
         J     PTRET                          ...OUT (RC ALREADY SET)
*
PTPROC   DS    0H
         USING WA,R13                  R13 - HANDLE (WA / SA ).
*
**   CHECK IF BLOCKS ARE MARKED AS UNUSABLE.
*
         CLI   WAHBLUNU,#WAHUNUY       BLOCKS ARE UNUSABLE ?
         JE    PTERRUNU                ..YES - OUT
*
**   PROCESS THE REQUEST
*
         LLGT  R4,@LINELEN             R4 -> LINE LENGTH
         L     R4,0(,R4)               R4 = LINE LENGTH
*
         LLGT  R3,$LINEA               R3 -> LINE TO PUT.
*
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: CURRBLK=$   RECLEN = #/~',                          >
               (WAFUNC,8,WAHBLCUR,8,?R4,?R4),                          >
               RAREA=RAREA,DBGAREA=DBGAREA
         IEABRCX POP
*
         CHI   R4,0                    LINE LENGTH = 0 ?
         JE    PTOK                    ..YES - NOTHING TO DO.
         CHI   R4,#MAXPUTL             LINE LENGTH > 255 ?
         JH    PTERRL2L                ..YES - LINE TOO LONG.
@PTCBLK  USING RUO,R8                  PREPARE ADDRESSABILITY.
*
**   FIST BLOCK ?
*
         LG    R8,WAHBLCUR             R8 -> CURRENT BLOCK.
         CGHI  R8,0                    DO WE HAVE SUCH ?
         JNE   PTCHKBLK                ..YES - TRY TO PUT THE LINE.
*
**   FIRST BLOCK - PREPARE TOKENS AND LENGTH FOR FIRST BLOCK.
*
         MVC   WAPARMNM,=CL8'BLOCKLEN'
         LLGT  R1,$LOBLEN              R1 -> REQUESTED BLOCK LENGTH.
         CHI   R1,0
         JE    PTERRPRM              ..NOTHING PASSED - ERROR.
         LLGT  R5,0(,R1)               R5 = BUFFER LENGTH (IN MB)
         CHI   R5,0
         JE    PTERRPRM              ..NOTHING PASSED - ERROR.
         STG   R5,WABLKSG#             SAVE # OF SEGMETS (MB).
*
         MVC   WAPARMNM,=CL8'USRTOKEN'
         XC    WAUTKN,WAUTKN           ZERO UTOKEN FIELD.
         LLGT  R1,$UTKNA               R1 -> USRTOKEN.
         CHI   R1,0
         JE    PTERRPRM               ..NOTHING PASSED - ERROR.
**                                                             BS10117
**  UTOKEN = CTS || X'NN' (C3E3E200)                           BS10117
**  WE TAKE IT INTO R15 AND ADD 1 TO X'NN' TO GET THE NEW      BS10117
**  TOKEN VALUE.                                               BS10117
**                                                             BS10117
**  ASSUMING THE TOKEN NUMBER (NN) IS 7:                       BS10117
**  (1) - LR    R15,R0 -> R15 = X'00000000C3E3E207'            BS10117
**  (2) - SLLG  R15,24 -> R15 = X'00C3E3E207000000'            BS10117
**  (3) - SRL   R15,24 -> R15 = X'00C3E3E200000007'            BS10117
**  (4) - SRL   R15,24 -> R15 = X'00C3E3E200000008'            BS10117
**                        WHEN WE GET TO 256 WE SWITCH TO 1.   BS10117
**  (5) - SLL   R15,24 -> R15 = X'00C3E3E208000000'            BS10117
**  (6) - SRLG  R15,24 -> R15 = X'00000000C3E3E208'            BS10117
**                                                             BS10117
         L     R0,0(,R1)               R0  = USRTOKEN VALUE.
PTCALCTK DS    0H
         LR    R15,R0         (1)      R15 = USRTOKEN VALUE.
         SLLG  R15,R15,24     (2)      SHIFT CTS TO HIGH       BS10117
         SRL   R15,24         (3)      SHIFT NUMBER BACK       BS10117
         AHI   R15,1          (4)      INCREASE USRTOKEN BY 1.
*BS10117 JP    PTSAVUTK                IF POSITIVE - USE IT.
         CHI   R15,255                 BYTE OVERFLOW ?         BS10117
         BNH   PTSETTKN                ..NO- USE IT.           BS10117
         LHI   R15,1                   ..ELSE, SET TO 1.
PTSETTKN DS    0H                                              BS10117
         SLL   R15,24          (5)     ATTACH NUMBER TO "CTS"  BS10117.
         SRLG  R15,R15,24      (6)     MOVE ALL TO PLACE.      BS10117
*BS10117 PTSAVUTK DS    0H
         CS    R0,R15,0(R1)            RETURN THE USRTOKEN.
         BNZ   PTCALCTK                ..FAILED- RETRY.
*BS10117 ST    R15,WAUTKN+4            PREPARE USRTOKEN FOR IARV64
         STG   R15,WAUTKN              PREPARE USRTOKEN FOR    BS10117
*                                      IARV64 GETSTOR          BS10117
*
         IEABRCX PUSH
         IEABRCX ENABLE
         TCBTOKEN TYPE=JOBSTEP,TTOKEN=WATTKN,MF=(E,WATCBTKL)
*                                      GET JOBSTEP TCB TOKEN.
         IEABRCX POP
         J     PTGETBLK
*
**   NOT FIRST BLOCK:
**   CHECK IF ENOUGH PLACE FOR THE RECORD IN CURRENT BLOCK.
*
PTCHKBLK DS    0H
         CTSAAMD 64
*
         LG    R2,@PTCBLK.RUOHDLEN     R2 - BUF DATA LEN
         STG   R2,WADATAL              SAVE FOR DIAG
         CTSAAMD 31
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         IEABRCX PUSH
         IEABRCX ENABLE
*BS10117 CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: MAX DATA LENGTH = $    USED LENGTH = $',            >
               (WAFUNC,8,WAHMAXDL,8,WADATAL,8),                        >
               RAREA=RAREA,DBGAREA=DBGAREA
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                BS10117 >
               '_: LENGTH - MAX = $    USED = $',              BS10117 >
               (WAFUNC,8,WAHMAXDL,8,WADATAL,8),                BS10117 >
               RAREA=RAREA,DBGAREA=DBGAREA                     BS10117
         IEABRCX POP
         CTSAAMD 64
*
         LA    R1,1(,R4)               R1 = LENGTH REQ'D FOR RECORD.
         LG    R5,WAHMAXDL             R5 = MAX DATA LENGTH,
         SG    R5,@PTCBLK.RUOHDLEN     R5 = FREE AREA LENGTH.
         CGR   R1,R5                   ENOUGH SPACE FOR RECORD ?
         JNH   PTMOVREC                ..YES - PUT IT.
*
**   NO PLACE IN CURRENT BLOCK, PREPARE TO GET NEW.
*
         LGF   R5,@PTCBLK.RUOHLEN      R5 = BUFFER LENGTH (IN MB)
         STG   R5,WABLKSG#             SAVE # OF SEGMETS (MB).
         MVC   WAUTKN,@PTCBLK.RUOHUTKN SET USERTKN
         MVC   WATTKN,@PTCBLK.RUOHTTKN SET TTOKEN.
         CTSAAMD 31
*
**   GET A NEW BLOCK
*
PTGETBLK DS    0H
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,1,77),                      >
               '_: GETBLOCK - LEN=$XMB  UTOKEN=$  TTOKEN=$',           >
               (WAFUNC,8,WABLKSG#,8,WAUTKN,8,WATTKN,16),               >
               RAREA=RAREA,DBGAREA=DBGAREA
*
         IARV64 REQUEST=GETSTOR,                                       >
               SEGMENTS=WABLKSG#,                                      >
               USERTKN=WAUTKN,                                         >
               TTOKEN=WATTKN,                                          >
               COND=YES,                                               >
               ORIGIN=WABLKNEW,                                        >
               RETCODE=WAV64RC,                                        >
               RSNCODE=WAV64RS,                                        >
               MF=(E,WAV64L)
*
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,1,77),                      >
               '_: NEW BLOCK - ADDR = $   RC = #   RS = ~',            >00037400
               (WAFUNC,8,WABLKNEW,8,?R15,WAV64RS),                     >
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         IEABRCX POP
*
         CHI   R15,0                   IARV64 ENDED OK ?
         JE    PTINITBF                ..YES - GO INIT THE BLOCK.
*                                      ..NO - CALCULATE NEW LENGTH.
         LG    R1,WABLKSG#
         CGHI  R1,#MINSG#              LENGTH REQ. > MINIMUM (1MB) ?
         JNH   PTERRBLA                ...NO - ERROR.
         SRLG  R1,R1,1                 TAKE HALF LENGTH.
         STG   R1,WABLKSG#             SET NEW LENGTH.
         J     PTGETBLK                RETRY ALLOCATION.
*
**   INITIALIZE THE HEADER OF THE NEW BUFFER.
*
PTINITBF DS    0H
         CTSAAMD 64
         LG    R7,WABLKNEW             R7 -> NEW BLOCK.
@PTNBLK  USING RUO,R7
         MVC   @PTNBLK.RUOHEYEC,RUOBEYE     SET EYE CATCHER
         LGHI  R0,0
         STG   R0,@PTNBLK.RUOHNEXT
         STG   R0,@PTNBLK.RUOHDLEN     DATA LENGTH = 0.
         MVC   @PTNBLK.RUOHLEN,WABLKSG#+4 SAVE BUFFER LENGTH (IN MB)
         MVC   @PTNBLK.RUOHTTKN,WATTKN SAVE TTOKEN.
         MVC   @PTNBLK.RUOHUTKN,WAUTKN SAVE USERTKN.
*
         IEABRCX PUSH
         IEABRCX ENABLE
*BS10117 DBG64 '_: NEW BLOCK HEADER - $ -> $, #MB, $',                 >00037400
               (WAFUNC,8,WABLKNEW,8,RUOHNEXT,8,RUOHLEN,RUOHDLEN,8),    >
               BLKNM=@PTNBLK,DBGLVL=(1,77)
*BS10117 DBG64 '_: NEW BLOCK HEADER - $, $',                           >00037400
               (WAFUNC,8,RUOHTTKN,16,RUOHUTKN,8),                      >
               BLKNM=@PTNBLK,DBGLVL=(1,77)
         DBG64 '_: NEW BLOCK HEADER - $ -> $ ...',             BS10117 >00037400
               (WAFUNC,8,WABLKNEW,8,RUOHNEXT,8),               BS10117 >
               BLKNM=@PTNBLK,DBGLVL=(1,77)                     BS10117
         DBG64 '_: (CONT.) - ... #MB, $, $',                   BS10117 >00037400
               (WAFUNC,8,RUOHLEN,RUOHDLEN,8,RUOHUTKN,8),       BS10117 >
               BLKNM=@PTNBLK,DBGLVL=(1,77)                     BS10117
         DBG64 '_: (CONT.) - ... $',                           BS10117 >00037400
               (WAFUNC,8,RUOHTTKN,16),                         BS10117 >
               BLKNM=@PTNBLK,DBGLVL=(1,77)                     BS10117
         IEABRCX POP
*
**   SET MAX DATA LENGTH IN HANDLE.
*
         LG    R0,WABLKSG#             R0 = BLOCK LENGTH (IN MB)
         SLLG  R0,R0,20                R0 = MULTIPLY BY 1024*1024 TO
*                                           GET THE LENGTH IN BYTES
         AGHI  R0,-#RUOHLEN            R0 = LENGTH OF DATA AREA.
         STG   R0,WAHMAXDL             SAVE IT IN HANDLE.
*
**   IF FIRST RECORD - RETURN ADDRESS TO CALLER
*
         CGHI  R8,0                    FIRST RECORD ?
         JNE   PTCHAIN
         LLGT  R1,$BLKA                R1 -> FIRST BLOCK ADDRESS        EA
*                                            RETURN AREA.
         STG   R7,0(,R1)               RETURN 1ST BLOCK ADDRESS.
         J     PTSETCB                 SET CURRENT BUFFER.
*
**   NOT FIRST BUFFER - CHAIN BUFFERS.
*
PTCHAIN  DS    0H
         STG   R7,@PTCBLK.RUOHNEXT     CHAIN BUFFERS.
*
         IEABRCX PUSH
         IEABRCX ENABLE
*BS10117 DBG64 '_: PREV BLOCK AFTER CHAIN - $ -> $, #, $',            > 00037400
         DBG64 '_: CURR BLOCK - $ -> $, #, $',                 BS10117 >   >7400
               (WAFUNC,8,WAHBLCUR,8,RUOHNEXT,8,RUOHLEN,RUOHDLEN,8),    >X
               BLKNM=@PTCBLK,DBGLVL=(1,77)
         IEABRCX POP
*
**   SET NEW AS CURRENT
*
PTSETCB  DS    0H
         STG   R7,WAHBLCUR             SET NEW AS CURRENT BUFFER.
         LGR   R8,R7                   NEW IS NOW CORRENT.
         DROP  @PTNBLK
*
**   MOVE RECORD TO BLOCK.
*
PTMOVREC DS    0H
         IEABRCX PUSH
         IEABRCX ENABLE
*BS10117 DBG64 '_: BLOCK BEFORE MOVE - ADDR = $   MAXDL = $  DL = $',  >00037400
               (WAFUNC,8,WAHBLCUR,8,WAHMAXDL,8,RUOHDLEN,8),            >
               BLKNM=@PTCBLK,DBGLVL=77
         DBG64 '_: BEFORE MOVE - $ -> $ ($)',                  BS10117 >00037400
               (WAFUNC,8,WAHBLCUR,8,RUOHDLEN,8,WAHMAXDL,8),    BS10117 >
               BLKNM=@PTCBLK,DBGLVL=77                         BS10117
         IEABRCX POP
*
         LA    R15,@PTCBLK.RUODATA
         AG    R15,@PTCBLK.RUOHDLEN
PTREC    USING RUOL,R15
         STC   R4,PTREC.RUOLLEN
         AHI   R4,-1
         EX    R4,PTMVCREC
         J     *+L'*+L'PTMVCREC
PTMVCREC MVC   PTREC.RUOLDATA,0(R3)
         DROP  PTREC
         AHI   R4,1+1                  RESTORE (-1 ABOVE) + 1 FOR
*                                      LENGTH BYTE.
         AG    R4,@PTCBLK.RUOHDLEN
         STG   R4,@PTCBLK.RUOHDLEN     UPDATE DATA LENGTH.
         IEABRCX PUSH
         IEABRCX ENABLE
*BS10117 DBG64 '_: BLOCK AFTER MOVE - ADDR = $   MAXDL = $  DL = $',   >00037400
               (WAFUNC,8,WAHBLCUR,8,WAHMAXDL,8,RUOHDLEN,8),  ,         >
               BLKNM=@PTCBLK,DBGLVL=77
         DBG64 '_: AFTER MOVE -  $ -> $ ($)',                  BS10117 >00037400
               (WAFUNC,8,WAHBLCUR,8,RUOHDLEN,8,WAHMAXDL,8),    BS10117 >
               BLKNM=@PTCBLK,DBGLVL=77                         BS10117
         IEABRCX POP
         DROP  @PTCBLK
         J     PTOK
*
**   ISSUE ERROR MESSGAES, SET RETURN CODES AND RETURN
*
PTOK     DS    0H                      OK
         LARL  R14,RETOK               SET RC.
         J     PTEND
*
PTERRPRM DS    0H                      ERROR IN PARAMETER.
         LARL  R14,RETPRMSG
         J     PTEND
*
PTERRUNU DS  0H                        BLOCK ARE UNUSABLE.
         LARL  R15,RETUNUER
         J     PTEND
*
PTERRBLA DS    0H                      BLOCK ALLOCAITON FAILED.
         MVI   WAHBLUNU,#WAHUNUY       SET 'UNUSABLE'
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,255),                       >
               '_: GETSTOR - RC = #  RS = ~   LEN=$XMB',               >
               (WAFUNC,8,WAV64RC,WAV64RS,WABLKSG#,8),                  >
               RAREA=RAREA,DBGAREA=DBGAREA
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,255),                       >
               '_: GETSTOR - UTOKEN = $    TTOKEN=$',                  >
               (WAFUNC,8,WAUTKN,8,WATTKN,16),                          >
               RAREA=RAREA,DBGAREA=DBGAREA
*
         MVC   M271CBNM,=CL8'RUOB'
         MVC   MSGACT,=CL7'OBTAIN'
         L     R15,WAV64RC             R15 = RETURN CODE.
         CTSAN2C CHARRC                TRANSLATE RC.
         MVC   WAM271TX,M271AO         PREPARE TEXT.
         L     R15,WAV64RS
         CTSAN2C WAM271TX+(M271AORS-M271AO),MODE=HEX,LEN=8 REASON CODE.
         L     R15,WABLKSG#
*WS10079 CTSAN2C WAM271TX+(M271AOL-M271AO),LEN=3   # OF SEGMENTS.
         CTSAN2C WAM271TX+(M271AOL-M271AO),LEN=4 # OF SEGMENTS. WS10079
         LHI   R1,MSG271-MSGRTN        ISSUE CTS271E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LHI   R15,#RCBLKAL            SET RC.
         LARL  R14,RETURN
         J     PTEND
*
PTERRL2L DS    0H                      LINE LENGTH > 255
         ST    R4,WAL2L1               LINE LENGTH FOR MESSAGE.
         MVC   WAL2L2,=F'255'
         MVI   WAHBLUNU,#WAHUNUY       SET 'UNUSABLE'
         LARL  R14,RETL2LER
         J     PTEND
*
**   RESTORE AMODE AND RETURN
*
PTEND    DS    0H
         CTSAAMD 31
*
**   RETURN WHEN NO SAVE AREA
*
PTRET    DS    0H
         BR    R14                     RETURN
         DROP  R13
*-----------------------------------------------------------------*
*                                                                 *
*                       GETFIRST / GETNEXT                        *
*                                                                 *
*  REGISTERS AT ENTRY:                                            *
*  R3  =  CALLER AMODE.                                           *
*  R4  -> ENTRY IN FUNCTIONS TABLE (FUNCTAB).                     *
*  R9  -> PARAMETERS BLOCK.                                       *
*  R10 -> CONSTANTS AREA.                                         *
*  R11 -  SECOND BASE.                                            *
*  R12 -  BASE RGISTER.                                           *
*                                                                 *
*-----------------------------------------------------------------*
GET      DS    0H
*
**   INITIALIZE THE ENVIRONMENT.
*
         LHI   R0,#IRVNA               REQUEST TO GET/ALLOC HANDLE.
         LARL  R15,INITRTN
         BASR  R14,R15                 GET/ALLOCATE HANDLE.
         CHI   R15,#RCOK               OK ?
         JE    GTGTPRMS                ..YES - GET COMMON PARAMETERS. .
         LR    R14,R15                 ..NO - GET RETURN ADDRESS AND...
         J     GTRET                          ...OUT (C ALREADY SET)
*
*
GTGTPRMS DS    0H
         LARL  R15,PARMSGET
         BASR  R14,R15                 GET COMMON PARAMETERS.
         CHI   R15,#RCOK               OK ?
         JE    GTPROC                  ..YES - PROCESS THE PUT REQUEST.
         LR    R14,R15                 ..NO - GET RETURN ADDRESS AND...
         J     GTRET                          ...OUT (RC ALREADY SET)
*
GTPROC   DS    0H
*
         USING WA,R13                  R13 - HANDLE (WA / SA ).
*
         LLGT  R5,@LINELEN             R5 -> AREA FOR LINE LENGTH.
         CHI   R5,0                    PROVIDED ?
         BE    GTINITLN                ..NO - INIT LINE BUFFER.
         XC    0(4,R5),0(R5)           INIT LINE LENGTH.
GTINITLN DS    0H
         LLGT  R5,$LINEA               R5 -> AREA FOR LINE.
         MVI   0(R5),X'00'             INIT RETURNED DATA - SET 'C'
*
*
         CLI   WAHBLUNU,#WAHUNUY       BLOCKS ARE UNUSABLE (PREV ERR)?
         BE    GTERRUNU                ..YES - OUT.
*
**   BRACH ACCORDING TO SPECIFIC REQUEST (GETFIRST / GETNEXT)
*
         L     R4,WAFUNCA
         L     R15,FERTN2-FENTRY(,R4)  R15 -> SECONDARY ROUTINE
         BR    R15
*-----------------------------------------------------------------*
**                   GETNEXT
*-----------------------------------------------------------------*
GETN     DS    0H
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: BLOCK = $   EOF = $',                               >00037400
               (WAFUNC,8,WAHBLCUR,8,WAHEOF,1),                         >
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         IEABRCX POP
         LG    R1,WAHBLCUR             R1 -> BLOCK TO READ.
         CGHI  R1,0                    FIRST CALL ?
         JE    GETF                    ..YES - HANDLE AS GET FIRST.
         CLI   WAHEOF,#WAHEOFY         EOF ?
         JE    GTEOF                   ..YES - OUT.
         J     GTLOC
*-----------------------------------------------------------------*
**                   GETFIRST
*-----------------------------------------------------------------*
GETF     DS    0H
         MVI   WAHEOF,#WAHEOFN         REMOVE THE EOF INDICAITON.
         LLGT  R1,$BLKA                R1 -> FIRST BLOCK ADDRESS.
         LG    R1,0(,R1)               R1 -> FIRST  BLOCK.
         MVC   WAPARMNM,=CL8'1STBLK'
         CGHI  R1,0                    FIRST BLOCK PROVIDED ?
         JE    GTERRPRM                ..NO - ERROR.
         STG   R1,WAHBLCUR             SET CURRNT = FIRST.
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,1,77),                      >
               '_: FIRST BLOCK = $',(WAFUNC,8,WAHBLCUR,8),             >00037400
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         IEABRCX POP
         XC    WAHRDLEN,WAHRDLEN       ZERO POSITION IN BLOCK.
         J     GTLOC
*-----------------------------------------------------------------*
**                          G E T
*-----------------------------------------------------------------*
*
**  LOCATE THE LINE TO GET
*
GTLOC    DS    0H
         MVC   WAPARMNM,=CL8'OUTBUFLN'
         LLGT  R1,$LOBLEN
         CHI   R1,0                    LINE LENGTH PARM PROVIDED ?
         JE    GTERRPRM                ..NO - ERROR.
*
         LG    R8,WAHBLCUR             R8 -> BLOCK TO READ.
         LG    R7,WAHRDLEN             R7 = LENGTH ALREADY READ.
@GTBLK   USING RUO,R8
*
         CTSAAMD 64
         IEABRCX PUSH
         IEABRCX ENABLE
         DBG64 '_: BLOCK = $  DATA LENGTH = $   READ LEN = $',         >00037400
               (WAFUNC,8,WAHBLCUR,8,RUOHDLEN,8,WAHRDLEN,8),            >
               BLKNM=@GTBLK,DBGLVL=77
         IEABRCX POP
*
         CG    R7,@GTBLK.RUOHDLEN      MORE DATA TO READ ?
         JL    GTGET                   ..YES - GET IT.
         LG    R8,@GTBLK.RUOHNEXT      ..NO - R8 -> NEXT BLOCK.
         CGHI  R8,0                    DO WE HAVE MORE BLOCKS ?
         JE    GTEOF                   ..NO - EOF.
*
         STG   R8,WABLKAD
         IEABRCX PUSH
         IEABRCX POP
         DBG64 '_: NEXT BLOCK - $ -> _, $, #, $',                      >00037400
               (WAFUNC,8,WABLKAD,8,RUOHEYEC,8,RUOHNEXT,8,              >
               RUOHLEN,RUOHDLEN,8),                                    >
               BLKNM=@GTBLK,DBGLVL=(1,77)
         IEABRCX ENABLE
*
         CLC   @GTBLK.RUOHEYEC,RUOBEYE   VALID RUOB ?
         JNE   GTERREYC
         LG    R0,@GTBLK.RUOHDLEN      DATA LENGTH IN BLOCK.
         CGHI  R0,0                    ANYTHING IN BLOCK ?
         JE    GTERRBLN                ..NO - INVALID BLOCK.
         STG   R8,WAHBLCUR             SET NEW CURRENT.
         LGHI  R7,0                    ..YES - USE IT
*
**   GET THE LINE
*
GTGET    DS    0H
         LA    R6,@GTBLK.RUODATA(R7)   R6 -> LINE TO GET.
@GTLNE   USING RUOL,R6
         LGHI  R4,0
         IC    R4,@GTLNE.RUOLLEN       R1 = LINE LENGTH.
*
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSAAMD 31
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: LINE - $ -> #',(WAFUNC,8,WALINEAD,8,?R4),           >00037400
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         CTSAAMD 64
         IEABRCX POP
*
         CHI   R4,0                    LINE LENGTH = 0 ?
         JE    GTERLNE0                ..YES - ERROR (PUT SHOULD NOT    CH)
*                                              PUT SUCH LINES.).
         LLGT  R1,$LOBLEN              R1 -> OUTPUT BUFFER LENGTH.
         L     R1,0(,R1)               R1 = OUTPUT BUFFER LENGTH.
         AHI   R1,-1                   LEAVE PLACE FOR NULL-CHAR.
         CR    R4,R1                   ENOUGH SPACE FOR LINE ?
         JNH   GTGETLNE                ..YES - GET THE LINE.
         ST    R4,WAL2L1               LINE LENGTH FOR MESSAGE.
         ST    R1,WAL2L2               LINE AREA LENGTH FOR MESSAGE.
         LARL  R14,GTERRL2L            R14 -> ERROR LABEL.
         ST    R14,WARET
         J     GTAFTMV                 SKIP THE RECORD SO WE WILL
*                                      BE ABLE TO PROCESS THE NEXT      Y.
*                                      ENTITY.
GTGETLNE DS    0H
         L     R5,@LINELEN             R5 -> AREA FOR LINE LENGTH.
         CHI   R5,0                    PROVIDED ?
         BE    GTRETLNE                ..NO - SKIP INITALIZATION.
         ST    R4,0(,R5)               RETURN LINE LENGTH.
GTRETLNE DS    0H
         LLGT  R5,$LINEA               R5 -> AREA FOR LINE.
         AHI   R4,-1                   FOR EX
         EX    R4,GTMVLINE
         J     *+L'*+L'GTMVLINE
GTMVLINE MVC   0(0,R5),@GTLNE.RUOLDATA
         AHI   R4,1                    R4 = DATA LENGTH.
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSAAMD 31
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: LINE READ = #, _',                                  >00037400
               (WAFUNC,8,?R4,0(R5),?R4),                               >
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         CTSAAMD 64
         IEABRCX POP
         LA    R5,0(R4,R5)             R5 -> PLACE FOR NULL-CHAR.
         MVI   0(R5),X'00'             SET 'C' TERMINATOR.
*
GTAFTMV  DS    0H
         LA    R7,1(R4,R7)             R7 = LENGTH READ FROM BLOCK.
         STG   R7,WAHRDLEN             R7 - GET LENGTH ALREADY READ.
         DROP  @GTBLK,@GTLNE
         CTSAAMD 31
*
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,77),                        >
               '_: NEW LENGTH READ = $',                               >00037400
               (WAFUNC,8,WAHRDLEN,8),                                  >
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         IEABRCX POP
*
         L     14,WARET                R14 = RETURN ADDRESS.
         CHI   R14,0                   ALREADY SET ?
         BNER  R14                     ..YES - USE IT.
         J     GTOK                    ..NO - ALL IS OK.
*
**   ISSUE ERROR MESSGAES, SET RETURN CODES AND RETURN
*
GTOK     DS    0H                      OK
         LARL  R14,RETOK
         J     GTEND
*
GTEOF    DS    0H
         MVI   WAHEOF,#WAHEOFY         EOF.
         LHI   R15,#RCEOF              END OF FILE.
         LARL  R14,RETURN
         J     GTEND
*
GTERRPRM DS    0H                      RUOB EYE-CATCHER INVALID.
         LARL  R14,RETPRMSG
         J     GTEND
*
GTERRUNU DS  0H                        BLOCK ARE UNUSABLE.
         LARL  R15,RETUNUER
         J     GTEND
*
GTERREYC DS    0H                      RUOB EYE-CATCHER INVALID.
         LA    R0,M274EYE
         J     GTERRINT                ISSUE 'INTERNAL ERROR'
GTERRBLN DS    0H                      BLOCK LENGTH = 0
         LA    R0,M274LEN0
         J     GTERRINT                ISSUE 'INTERNAL ERROR'
GTERRINT DS    0H                      INTERNAL ERROR MESSAGE
         MVI   WAHBLUNU,#WAHUNUY       SET ERROR INDICATION.
         LARL  R14,RETINTER            HANDLE INTERNAL ERROR.
         J     GTEND
*
GTERLNE0 DS    0H                      LINE LENGTH IN BLOCK = 0.
         MVI   WAHBLUNU,#WAHUNUY       SET ERROR INDICATION.
         LHI   R1,MSG273-MSGRTN        ISSUE CTS273E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LHI   R15,#RCINT              SET RC.
         LARL  R14,RETURN
         J     GTEND
*
GTERRL2L DS    0H                      LINE TOO LONG.
         LARL  R14,RETL2LER            ISSUE CTS272E
         J     GTEND
*
**  RESTORE AMODE AND RETURN
*
GTEND    DS    0H
         CTSAAMD 31
*
**   RETURN WHEN NO SAVE AREA
*
GTRET    DS    0H
         BR    14                      RETURN.
         DROP  R13
*-----------------------------------------------------------------*
*                                                                 *
*                     TERM AND FREE,                              *
*                                                                 *
*  WE GET HERE FOR 3 REQUESTS:                                    *
*  TERMNFREE - FREE THE RUOB AND THE HANDLE.                      *
*  TERMIO    - FREE THE HANDLE.                                   *
*  FREERUOB - FREE THE RUOB.                                      *
*                                                                 *
*  REGISTERS AT ENTRY:                                            *
*  R3  =  CALLER AMODE.                                           *
*  R4  -> ENTRY IN FUNCTIONS TABLE (FUNCTAB).                     *
*  R9  -> PARAMETERS BLOCK.                                       *
*  R10 -> CONSTANTS AREA.                                         *
*  R11 -  SECOND BASE.                                            *
*  R12 -  BASE RGISTER.                                           *
*                                                                 *
*                                                                 *
*  WHEN BLOCK ADDRESS IS NOT SUPPLIED FOR FREE, OR HANDLE         *
*  ADDRESS IS NOT SUPPLIDED FOR TERMIO, THE ROUTINE RETURNS A     *
*  RETURN CODE OF 0 (OK).                                         *
*                                                                 *
*-----------------------------------------------------------------*
TERMNFRE DS    0H
*
**   INITIALIZE THE ENVIRONMENT.
*
         CLC   0(4,R4),FTTRMNFR        TERMIO / TERMNFREE ?
         JNE   TFCHKFRE                ..NO  - ALLOC HANDLE.
*
**  FOR TERM/TERMNFREE, VERIFY THE HANDLE BEFORE WE FREE IT.
*
         CTSAAMD RESTORE,AMODSAV=(R3),CMDTAB=AMDCMDTB
         LLGT  R1,PRMHNDLE             R1 -> HANDLE ADDRESS.
         LA    R1,0(,R1)               PURIFY LEFTMOST BIT/BYTE
         CTSAAMD 31
         CHI   R1,0                    HANDLE WAS PROVIDED ?
         JE    TFISITTF                ..NO - CHEK IF TERMNFREE.
         L     R1,0(,R1)               R1 -> HANDLE.
         CHI   R1,0                    HANDLE WAS PROVIDED ?
         JNE   TFVERHND                ..YES - VERIFY IT.
TFISITTF DS    0H
         CLC   0(8,R4),FTTRMNFR        IS IT TERMNFRE ?
         JE    TFCHKFRE                ..YES - PROCESS FREE.
         LHI   R15,#RCOK               ..NO - NOTHING TO DO.
         LARL  R14,RETURN
         J     TFRET
TFVERHND DS    0H
         LHI   R0,#IRVER               REQUEST TO VERIFY THE HANDLE.
         LARL  R15,INITRTN
         BASR  R14,R15                 GET HANDLE.
         LR    R5,R13                  R5 -> OLD HANDLE (WILL BE FREED)
         CHI   R15,#RCOK               OK ?
         JE    TFCHKOWN                ..YES - CHECK OWNER TO DECIDE
*                                              WHO IS THE HANDLE OWNER.
         LR    R14,R15                 ..NO - ERROR.
         J     TFRET
TFCHKOWN DS    0H
         CLI   WAHOWNER-WA(R5),#WAHOWNW  ARE WE THE HANDLE OWNER ?
         JE    TFALCHND                ..YES - CONTINUE BECAUSE WE
*                                              NEED TO FREE.
         LHI   R15,#RCNOTUS            ..NO - SET RETURN CODE.
         LARL  R14,RETURN
         J     TFRET
*
**  FOR TERMNFRE WITH NO HANDLE, OR FOR FREE, VERIFY WE HAVE
**  A BLOCK ADDRESS SO THAT WE WON'T ALLOCATE A WORK AREA WHEN
**  THERE'S NOTHING TO DO.
*
TFCHKFRE DS    0H
         LA    R4,FTFREE               FORCE "FREE" CALL.
         LHI   R15,#RCOK               FORCE RC = OK.
         LARL  R14,RETURN
         CTSAAMD RESTORE,AMODSAV=(R3),CMDTAB=AMDCMDTB,R=R1
         LLGT  R1,PRMBLKA              R1 -> BLOCK ADDRESS.
         LA    R1,0(,R1)               PURIFY LEFTMOST BIT/BYTE
         CTSAAMD 31
         CHI   R1,0                    PROVIDED ?
         JE    TFRET                   ..NO - NOTHING TO DO.
         LG    R1,0(,R1)               R1 -> BLOCK.
         CGHI  R1,0                    PROVIDED ?
         JE    TFRET                   ..NO - NOTHING TO DO.
*
**  ALLOCATE A NEW WORK AREA FOR THE OPERATION
*
TFALCHND DS    0H                      ALLOCATE A HANDLE FOR WA.
         LHI   R0,#IRALC               REQUEST TO ALLOCATE A HANDLE.
         LARL  R15,INITRTN
         BASR  R14,R15                 GET HANDLE.
         CHI   R15,#RCOK               OK ?
         BE    TFPROC                  ..YES - PROCESS FCUNTION.
         LR    R14,R15                 ..NO - ERROR.
         J     TFRET
*
         USING WA,R13
*
**   PROCESS THE FUNCITON.
*
TFPROC   DS    0H
         LARL  R15,RETOK
         ST    R15,WARET               INITIALIZE THE RETURN ADDRESS.
         L     R15,FERTN2-FENTRY(,R4)  PROCESS FUNCTION.
         BR    R15
*
**   TERMINATE THE TERM AND/OR FREE REQUESTS
*
TFEND    DS    0H
         LR    R5,R14                  SAVE RETURN ADDRESS.
*
         LR    R1,R13                  R1 -> AREA TO FREE.
         LHI   R13,0
         IEABRCX PUSH
         IEABRCX ENABLE
         STORAGE RELEASE,LENGTH=#WALEN,ADDR=(R1),COND=YES,             >
               SP=0,LINKAGE=SYSTEM FREE THE HANDLE.
         IEABRCX POP
*
         CHI   R15,0                   STORAGE RELEASE SUCCESSFUL ?
         JE    TFRESR14                ..YES - RETURN.
         IEABRCX PUSH
         IEABRCX ENABLE
         WTO   'CTSXXXX: CTS2RUH - WORKAREA RELEASE FAILED'             00037400
         IEABRCX POP
*
TFRESR14 DS    0H
         LR    R14,R5                  RESTORE RETURN ADDR
         J     TFRET
*
TFRET    DS    0H
         BR    R14                     RETURN
*-----------------------------------------------------------------*
**             TERMIO - FREE THE HANDLE.
*-----------------------------------------------------------------*
TERMIO   DS    0H
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         IEABRCX PUSH
         IEABRCX ENABLE
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,1,77),                      >
               '_: HANDLE TO FREE = ~',                                >00037400
               (WAFUNC,8,?R5),                                         >
               RAREA=RAREA,DBGAREA=DBGAREA                              00037500
         IEABRCX POP
*
         ST    R5,WATIHA               SAVE ADDRESS OF HANDLE TO FREE.
         LR    R1,R5                   R1 -> HANDLE TO FREE.
         LHI   R3,0                    INDICATE 'NO WORK AREA'
         LLGT  R6,$HANDLE
         ST    R3,0(,R6)               RETURN HANDLE = 0.
*
**   FREE THE HANDLE (NOT THE ONE WE ARE USING NOW AS WORK AREA)
*
         IEABRCX PUSH
         IEABRCX ENABLE
         STORAGE RELEASE,LENGTH=#WALEN,ADDR=(R1),COND=YES,             >
               SP=0,RTCD=WASTORRC,LINKAGE=SYSTEM FREE THE HANDLE.
*
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,1,77),                      >
               '_: RELEASE HANDLE - RC = #   A = ~   LEN = #',         >
               (WAFUNC,8,?R15,WATIHA,=A(#WALEN)),                      >
               RAREA=RAREA,DBGAREA=DBGAREA
         IEABRCX POP
*
         CHI   R15,0                   STORAGE RELEASE SUCCESSFUL ?
         JE    TIOK                    ..YES - CONTINUE.
*
**    STORAGE RELEASE FAILED.
*
         MVC   MSGACT,=CL7'RELEASE'
         MVC   M271CBNM,=CL8'HANDLE'
         L     R15,WASTORRC            R15 = RETURN CODE.
         CTSAN2C CHARRC                TRANSLATE RC.
         MVC   WAM271TX,M271BR         PREPARE TEXT.
         L     R15,WATIHA              R15 = ADDRESS
         CTSAN2C WAM271TX+(M271BRA-M271BR)   SET ADDRESS
         L     R15,=A(#WALEN)          R15 = ADDRESS
         CTSAN2C WAM271TX+(M271BRL-M271BR)   SET LENGTH
         MVC   WAM271TX+(M271BRSP-M271BR),=CL3'000'
         LHI   R1,MSG271-MSGRTN        ISSUE CTS271E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LARL  R14,RETINTRC            INDICATE INTERNAL ERROR.
         J     TIEND
*
**  RETURN
*
TIOK     DS    0H                      OKK
         LARL  R14,RETOK
*
TIEND    DS    0H
         ST    R14,WARET               SAVE TERMIO RETURN ADDRESS.
         CLC   WAFUNC,FTTRMNFR         TERMNFRE ?
         JE    FREE                    ..YES - DO FREE
         J     TFEND                   ..NO - OUT
*-----------------------------------------------------------------*
**                        FREERUOB
*-----------------------------------------------------------------*
FREE     DS    0H
         LLGT  R1,$BLKA                R1 -> BLOCK ADDRESS.
         CHI   R1,0
         JE    FROK                    ..NOTHING TO DO .
         LG    R8,0(,R1)               R8 -> BLOCK.
         CGHI  R8,0
         JE    FROK                    ..NOTHING TO DO
*
         CTSAAMD 64
*
@FR1BLK  USING RUO,R8
         STG   R8,WABLKAD              FOR DIAG.
         IEABRCX PUSH
         IEABRCX ENABLE
         DBG64 '_: 1ST BLOCK HEADER - $ -> $, #MB, $',                 >
               (WAFUNC,8,WABLKAD,8,RUOHNEXT,8,RUOHLEN,                 >
               RUOHDLEN,8),                                            >
               BLKNM=@FR1BLK,DBGLVL=(1,77)
         DBG64 '_: 1ST BLOCK - $, $',                                  >
               (WAFUNC,8,RUOHTTKN,16,RUOHUTKN,8),                      >
               BLKNM=@FR1BLK,DBGLVL=(1,77)
         IEABRCX POP
*
         CLC   @FR1BLK.RUOHEYEC,RUOBEYE VALID RUOB ?
         JNE   FRERREYC
*
         LLGT  R1,$BLKA                R1 -> BLOCK ADDRESS.
         LGHI  R0,0
         STG   R0,0(,R1)               RETURN BLOCK ADDRESS = 0.
*
**   FREE ALL THE BLOCKS USING THE USER TOKEN
*
         IARV64 REQUEST=DETACH,                                        >
               USERTKN=@FR1BLK.RUOHUTKN,                               >
               TTOKEN=@FR1BLK.RUOHTTKN,                                >
               COND=YES,                                               >
               MATCH=USERTOKEN,                                        >
               RETCODE=WAV64RC,                                        >
               RSNCODE=WAV64RS,                                        >
               MF=(E,WAV64L)
         DROP  @FR1BLK
*
         CTSAAMD 31
*
**   CHECK RC
*
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,1,77),                      >
               '_: DETACH RC = # / ~',                                 >
               (WAFUNC,8,WAV64RC,WAV64RS),                             >
               RAREA=RAREA,DBGAREA=DBGAREA
         IEABRCX POP
         CHI   R15,0                   IARV64 ENDED OK ?
         JNE   FRERRDET                ..NO - ISSUE ERROR MESSAGE.
         J     FROK                    ..YES - RETURN.
*
**   ISSUE EROR MESSAGES AND RETURN
*
FRERRDET DS    0H                      DETACH FAILED.
@FR1BLK  USING RUO,R8
         CTSAAMD 64
         MVC   WAUTKN,@FR1BLK.RUOHTTKN FOR MESSAGE / DIAG.
         MVC   WATTKN,@FR1BLK.RUOHTTKN FOR MESSAGE / DIAG.
         CTSAAMD 31
         DROP  @FR1BLK
*
         LHI   R0,0
         IC    R0,WAHDBGT              GET DEBUG TYPE.
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,255),                       >
               '_: DETACH - RC = #    RS = ~   BLK = $',               >
               (WAFUNC,8,WAV64RS,WAV64RS,WABLKAD,8),                   >
               RAREA=RAREA,DBGAREA=DBGAREA
*
         CTSADBG TYPE=(R0),LEVEL=(DBGLEVEL,255),                       >
               '_: DETACH - UTOKEN = $  TTOKEN = $',                   >
               (WAFUNC,8,WAUTKN,8,WATTKN,16),                          >
               RAREA=RAREA,DBGAREA=DBGAREA
*
         MVC   MSGACT,=CL7'DETACH'
         MVC   M271CBNM,=CL8'RUOB'
         L     R15,WAV64RC             R15 = RETURN CODE.
         CTSAN2C CHARRC                TRANSLATE RC.
         MVC   WAM271TX,M271AR         PREPARE TEXT.
         L     R15,WAV64RS
         CTSAN2C WAM271TX+(M271ARRS-M271AR),MODE=HEX,LEN=8 REASON CODE
         L     R15,WAUTKN+4
*BS10117 CTSAN2C WAM271TX+(M271ARUT-M271AO),LEN=8   UTOKEN
         CTSAN2C WAM271TX+(M271ARUT-M271AO),LEN=8,MODE=HEX     BS10117
         LHI   R1,MSG271-MSGRTN        ISSUE CTS271E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LARL  R14,RETINTRC            INDICATE INTERNAL ERROR.
         J     FRRET
*
FRERREYC DS    0H                      RUOB EYE-CATCHER INVALID.
         LA    R0,M274EYE
         LHI   R1,MSG274-MSGRTN        ISSUE CTS274E
         LARL  R15,MSGRTN
         BASR  R14,R15
         LARL  R14,RETINTRC            INDICATE INTERNAL ERROR.
         J     FRRET
*
FROK     DS    0H                      OK
         L     R14,WARET               TAKE THE RETURN ADDRESS SET
*                                      IN WASET. THIS FIELD WAS
*                                      INITIALIZED AS OK. IF TERMIO WAS
*                                      CALLED, IT SET ITS RETURN CODE
*                                      THERE SO THAT WE RETURN WITH
*                                      THE MOST SEVERE RETURN CODE.
*
FRRET    DS    0H
         J     TFEND
*
         DROP  R13
*
*-----------------------------------------------------------------*
*                                                                 *
*                         GET HANDLE                              *
*                                                                 *
*  THIS ROUTINE PREPARES THE HANDLE:                              *
*  1. IF NOT PROVIDED, THE HANDLE IS ALLOCATED AND INITALIZED.    *
*  2. IF PROVIDED, THE HANDLE IS VERIFIED.                        *
*  3. INITIALIZES THE WORK AREA PART AND FILL WITH DATA FROM      *
*     PARAMETERS.                                                 *
*                                                                 *
*  REGISTERS AT ENTRY:                                            *
*  R0  =  MODE:                                                   *
*         #IRVNA - LOOK FOR HANDLE. IF DOES NOT EXIST, ALLLOCTE   *
*                  AND RETURN ITS ADDRESS. IF EXISTS, VERIFY.     *
*         #IRALC - ALLOC A NEW HANDLE AND INIT. DO NOT CHECK IF   *
*                  ONE WAS PROVIDED AND DO NOT RETURN ITS ADDR.   *
*         #IRVER - VERIFY ONLY. DO NOT ALLOCATE.                  *
*         #IRINIT- INITIALIZE ONLY (WAS PRE-ALLOCAETD BY CALLER). *
*  R0  =  MODE: X'00' - ALLOC ONLY.  X'01' - ALLOC IF NOT FOUND.  *
*  R3  =  AMODE AT ENTRY.                                         *
*  R4  -> ENTRY IN FUNCTIONS TABLE (FUNCTAB).                     *
*  R9  -> PARAMETERS BLOCK.                                       *
*  R10 -> CONSTANTS AREA.                                         *
*  R11 -> SECOND BASE.                                            *
*  R12 -> BASE REGISTER.                                          *
*  R14 =  RETURN ADDRESS.                                         *
*  R15 =  ROUTINE ENTRY ADDRESS.                                  *
*                                                                 *
*  REGISTERS USED BY THE ROUTINE:                                 *
*  R0 - R2  - WORK REGISTERS.                                     *
*  R3 - R12 - UNCHANGED.                                          *
*  R13      - HANDLE ADDRESS.                                     *
*  R14      - WORK REGISTER.  OUTPUT: RETURN ADDRESS.             *
*  R15      - WORK REGISTER.  OUTPUT: RETURN CODE.                *
*                                                                 *
*  *****  ATTENTION  *****                                        *
*  1. THIS ROUTINE DOES NOT HAVE A BASE REGISTER.                 *
*  2. THIS ROUTINE DOES NOT SAVE AND RESTORE REGISTERS            *
*                                                                 *
*-----------------------------------------------------------------*
INITRTN  DS    0H
*
         CTSARHC R2,R2                 CLEAR THE HIGH-HALF + AMODE BIT  ERS
         LR    R2,R14                  SAVE RETURN ADDRESS + AMODE.
         SLLG  R0,R0,32                SHIFT THE MODE TO THE HIGH HALF.
         OGR   R2,R0                   AND PUT IT IN R2
*
         TMHL  R2,#IRALC               ALLOCATE ONLY ?
         JO    IRALLOC                 ..YES - SKIP VERIFICATION.
*
         CTSAAMD RESTORE,AMODSAV=(R3),CMDTAB=AMDCMDTB
         LLGT  R1,PRMHNDLE             R1 -> HANDLE ADDRESS.
         LA    R1,0(,R1)               PURIFY LEFTMOST BIT/BYTE
         CTSAAMD 31
         CHI   R1,0
         JE    IRERRPRM                NO POINTER TO HANDLE ADDRESS.
         LLGT  R13,0(,R1)              R13 -> HANDLE.
         CHI   R13,0                   HANDLE EXISTS ?
         JNE   IRIORV                  ..YES - INIT / VERIFY.
         TMHL  R2,#IRVER+#IRINIT       INIT / VERIFY ?
         JNZ   IRERRPRM                ..YES - ERROR - NO HANDLE.
         J     IRALLOC                 ..NO - ALLOC.
IRIORV   DS    0H                      HANDLE EXISTS - INIT / VERIFY ?
         TMHL  R2,#IRINIT              INIT ONLY ?
         JO    IRINIT                  ..YES - GO INIT.
         J     IRVER
*
**   ALLOCATE A NEW HANDLE (WA) AND GET ITS ADDRESS IN R13.
*
IRALLOC  DS    0H
         IEABRCX PUSH
         IEABRCX ENABLE
         STORAGE OBTAIN,LENGTH=#WALEN,ADDR=(R13),COND=YES,             >
               SP=0,LINKAGE=SYSTEM,LOC=RES     ALLOCATE HANDLE.IS10188
*IS10188       SP=0,LINKAGE=SYSTEM,LOC=BELOW   ALLOCATE HANDLE.
         IEABRCX POP
         CHI   R15,0                   STORAGE SUCCESSFUL ?
         JNE   IRERRALH                ..NO - ERROR.
         USING WA,R13
*
IRINIT   DS    0H
         XC    WAHNDLS(#WAHNDLL),WAHNDLS CLEAR THE HANDLE.
         MVC   WAHEYEC,HNDLICAT        SET EYE-CATCHER.
         MVI   WAHOWNER,#WAHOWNW       WE ARE THE OWNER.
*
         CTSAAMD RESTORE,AMODSAV=(R3),CMDTAB=AMDCMDTB
         LLGT  R1,PRMDBGT              R1 -> DEBUG TYPE.
         LA    R1,0(,R1)               PURIFY LEFTMOST BIT/BYTE
         CTSAAMD 31
         CHI   R1,0                    DEBUG TYPE PROVIDED ?
         JE    IRAFTDBT                ..NO - SKIP.
         CLC   0(8,R1),DBGTWTO         WTO ?
         JE    IRDBGTWT               ..YES - SET TYPE.
         MVI   WAHDBGT,CTMDBPRT        ..NO - ASSUME PRTDBG
         J     IRAFTDBT
IRDBGTWT DS    0H
         MVI   WAHDBGT,CTMDBWTO        DEBUG TYPE=WTO
IRAFTDBT DS    0H
         TMHL  R2,#IRALC+#IRINIT       ALLOCATE / INIT ONLY ?
         JNZ   IRINITWA                ..YES - DO NOT RETURN ADDRESS.
         CTSAAMD RESTORE,AMODSAV=(R3),CMDTAB=AMDCMDTB
         LLGT  R1,PRMHNDLE             R1 -> HANDLE ADDRESS.
         LA    R1,0(,R1)               PURIFY LEFTMOST BIT/BYTE
         CTSAAMD 31
         ST    R13,0(,R1)              RETURN HANDLE ADDRESS.
         J     IRINITWA                ...AND GO INIT.
*
**   VALIDATE THE HANDLE.
*
IRVER    DS    0H
         CLC   WAHEYEC,HNDLICAT        HANDLE VALID ?
         JNE   IRERRHND                ..NO - ERROR.
         TMHL  R2,#IRVER               VERIFYONLY ?
         JO    IROK                    ..YES - OUT.
*
*
**   INIT THE WA AND SA.  NO NEED TO CHAIN SAVE AREAS.
*
IRINITWA DS    0H
*
         XC    SA(#SAL),SA             CLEAR THE SAVE AREA.
         MVC   SA+4(4),F1SA            'STACK USED' INDICATION.
*
         LA    R14,WAWA                R14 -> WORK AREA PART.
         LHI   R15,#WAWALEN            R15 = WORK AREA LENGTH
         LHI   R1,0                    ZERO SOURCE LEN
         MVCL  R14,R0                  CLEAR WORK AREA
*                                      R0 IS NOT CHANGED BY THIS
*                                      COMMAND.
*
         ST    R3,WAAMODE              SAVE ENTRY AMODE.
         ST    R4,WAFUNCA              SAVE FUNCTAB ENTRY ADDRESS.
         MVC   WAFUNC,FENAME-FENTRY(R4) SAVE FUNCITON NAME.

*
**   GET ALL PARAMETERS ADDRESSES (PURIFIED) WHILE IN CALLER AMODE.
*
         CTSAAMD RESTORE,AMODSAV=WAAMODE,CMDTAB=AMDCMDTB
         LLGT  R1,PRMHNDLE
         LA    R1,0(,R1)
         ST    R1,$HANDLE
         LLGT  R1,PRMBLKA
         LA    R1,0(,R1)
         ST    R1,$BLKA
         LLGT  R1,PRMLINEA
         LA    R1,0(,R1)
         ST    R1,$LINEA
         LLGT  R1,PRMLNELN
         LA    R1,0(,R1)
         ST    R1,@LINELEN
         LLGT  R1,PRMGOUBL
         LA    R1,0(,R1)
         ST    R1,$LOBLEN
         LLGT  R1,PRMUTKNA
         LA    R1,0(,R1)
         ST    R1,$UTKNA
         LLGT  R1,PRMDBGL
         LA    R1,0(,R1)
         ST    R1,$DBGL
         LLGT  R1,PRMEMSGA
         LA    R1,0(,R1)
         ST    R1,$ERRMSGA
         LLGT  R1,PRMEMSAL
         LA    R1,0(,R1)
         ST    R1,$ERRMSAL
         LLGT  R1,PRMEMSGL
         LA    R1,0(,R1)
         ST    R1,$ERRMSGL
         CTSAAMD 31
*
         MVI   DBGLEVEL,0              ZERO DEBUG LEVEL
         LLGT  R1,$DBGL                R1-> DEBUG LEVEL.
         CHI   R1,0                    DEBUG LEVEL PROVIDED ?
         JE    IRAFTDBG                ..NO - SKIP.
         L     R1,0(,R1)               R1 = DEBUG LEVEL.
         CHI   R1,0                    DEBUG LEVEL PROVIDED ?
         JNH   IRAFTDBG                ..NO - SKIP.
         STC   R1,DBGLEVEL             SAVE DEBUG LEVEL
*
IRAFTDBG DS    0H
         LHI   R0,0
         IC    R0,WAHDBGT
*
**   CHECK MESSAGE RELATED PARAMETERS
*
         LLGT  R1,$ERRMSGA             R1-> MESSAGE AREA.
         CHI   R1,0                    PROVIDED ?
         JE    IRERRPRM                ..NO - ERROR.
         MVI   0(R1),X'00'             NULLIFY (FOR C).
*
         LLGT  R1,$ERRMSAL            R1-> MESSAGE AREA LENGTH.
         CHI   R1,0                    PROVIDED ?
         JE    IRERRPRM                ..NO - ERROR.
         L     R1,0(,R1)               R1 = MESSGE AREA LENGTH.
         CHI   R1,#MAXMSGL             LONG ENOUGH ?
         JL    IRERRPRM                ..NO- ERROR.
*
         LLGT  R1,$ERRMSGL             R1-> MESSAGE LENGTH AREA.
         CHI   R1,0                    PROVIDED ?
         JE    IROK                    ..NO - OK.
         LHI   R15,0
         ST    R15,0(,R1)              ZERO MESSAGE LENGTH.
*
**   SET RC AND RETURN.
*
IROK     DS    0H                      OK
         LHI   R15,#RCOK
         J     IRRET
*
IRERRALH DS    0H                      FAILED TO ALLOCATE HANDLE.
         IEABRCX PUSH
         IEABRCX ENABLE
         WTO   'CTSXXXX: CTS2RUH - HANDLE ALLOCAITON FAILED'            00037400
         IEABRCX POP
         LARL  R15,RETHALER
         J     IRRET
*
IRERRHND DS    0H                      INVALID HANDLE.
         IEABRCX PUSH
         IEABRCX ENABLE
         WTO   'CTSXXXX: CTS2RUH - HANDLE IS INVALID'                   00037400
         IEABRCX POP
         J     IRERRPRM
*
IRERRPRM DS  0H                        PARAMETERS ERROR - NO MSG.
         LARL  R15,RETPRMER
         J     IRRET
*
IRRET    DS    0H
         LR    R14,R2                  RESTORE RETURN ADDRESS.
         CTSARHC R2,R2                 CLEAR THE HIGH-HALF + AMODE BIT  ERS
         BR    R14                     RETURN
         DROP  R13
*-----------------------------------------------------------------*
*                                                                 *
*                         GET COMMON PARMS                        *
*                                                                 *
*  THIS ROUTINE VALIDATES ALL THE COMMON PARAMETERS TO GET AND    *
*  PUT.                                                           *
*                                                                 *
*  REGISTERS AT ENTRY:                                            *
*  R9  -> PARAMETERS BLOCK.                                       *
*  R10 -> CONSTANTS AREA.                                         *
*  R11 -> SECOND BASE.                                            *
*  R12 -> BASE REGISTER.                                          *
*  R13 -> HANDLE.                                                 *
*  R14 =  RETURN ADDRESS.                                         *
*  R15 =  ROUTINE ENTRY ADDRESS.                                  *
*                                                                 *
*  REGISTERS USED BY THE ROUTINE:                                 *
*  R0       - UNCHANGED.                                          *
*  R2       - WORK REGISTERS.                                     *
*  R2 - R14 - UNCHANGED.                                          *
*  R15      - 0 - OK.   ELSE - BRANCH ADDRESS FOR ERROR LABEL.    *
*                                                                 *
*  *****  ATTENTION  *****                                        *
*  1. THIS ROUTINE DOES NOT HAVE A BASE REGISTER.                 *
*  2. THIS ROUTINE DOES NOT SAVE AND RESTORE REGISTERS            *
*                                                                 *
*-----------------------------------------------------------------*
PARMSGET DS    0H
         USING WA,R13
*
**   CHECK BLOCK AND LINE PARAMETERS
*
         MVC   WAPARMNM,=CL8'BLK1STAD'
         LLGT  R1,$BLKA                R1-> FIRST BLOCK ADDRESS.
         CHI   R1,0                    PROVIDED ?
         JE    PGERMPRM                ..NO - ERROR.
*
         MVC   WAPARMNM,=CL8'LINEADDR'
         LLGT  R1,$LINEA               R1-> LINE.
         CHI   R1,0                    PROVIDED ?
         JE    PGERMPRM                ..NO - ERROR.
*
         MVC   WAPARMNM,=CL8'LINELEN'
         L     R1,@LINELEN             R1-> LINE LENGTH.
         CHI   R1,0                    PROVIDED ?
         JNE   PGOK                    ..YES - OK.
         CLC   0(8,R4),FTPUT           PUT ?
         JE    PGERMPRM                ..YES - LINELEN IS MANDATORY.
*                                      ..NO - OK.
*
*
PGOK     DS    0H                      OK
         LHI   R15,#RCOK
         J     PGRET
*
PGERMPRM DS    0H                      PARAMETERS ERROR - NEED MSG.
         LARL  R15,RETPRMSG
         J     PGRET
*
PGRET    DS    0H
         BR    R14                     RETURN
CTSARUHE EQU   *                       FOR USING SCOPE
         DROP  ,
*--------------------------------------------------------------------
**
**   ISSUE ERROR MESSAGES
**
**   ISSUE THE REQUESTED ERROR MESSAGE.
**
**   THIS ROROUTINE CAN BE CALSLED FROM AMODE 31 OR 64, BUT ITS
**   PARAMETERS SHOULD NOT BE ABOVE THE BAR.
**
**
**   INPUT:
**   R0 - INPUT FOR MESSAGE.
**   R1 - OFFSET OF REQUIRED MESSAGE "BLOCK" IN THIS THIS ROUTINE.
**
**
*--------------------------------------------------------------------
MSGRTN   DS    0H
         USING CONST,R10
         USING PRM,R9
         USING WA,R13
*                                      SAFE SIDE...
         MVC   WASAMSG(4),MGSA         MESSGAE SAVE AREA.
         STM   R14,R12,WASAMSG+4       SAVE REGISTERS
         LR    R8,R15
         USING (MSGRTN,MSGRTNE),R8
         B     MSGRTN(R1)
*
MSG270   DS    0H
         CTSMSG1 CODE=CTS270E,ROUT=NO,RAREA=RAREA,                     >
               PLANT=(8,=CL8'CTSARUH',8,WAFUNC,8,WAPARMNM)
         B     MRRET
*
MSG271   DS    0H
*WS10079 CTSMSG1 CODE=CTS271E,ROUT=NO,RAREA=RAREA,                     >
               PLANT=(8,=CL8'CTSARUH',8,MSGACT,2,CHARRC,30,WAM271TX)
         CTSMSG1 CODE=CTS271E,ROUT=NO,RAREA=RAREA,             WS10079 >
               PLANT=(7,MSGACT,8,M271CBNM,2,CHARRC,30,WAM271TX) WS10079
         B     MRRET
*
MSG272   DS    0H
         L     R15,WAL2L1              R15 = LENGTH 1
         CTSAN2C NUMCHAR,LEN=4         TRANSLATE TO CHAR.
         L     R15,WAL2L2              R15 = LENGTH 2
         CTSAN2C NUMCHAR2,LEN=4        TRANSLATE TO CHAR
         CTSMSG1 CODE=CTS272E,ROUT=NO,RAREA=RAREA,                     >
               PLANT=(8,=CL8'CTSARUH',8,WAFUNC,4,NUMCHAR,4,NUMCHAR2)
         B     MRRET
*
MSG273   DS    0H
         CTSMSG1 CODE=CTS273E,ROUT=NO,RAREA=RAREA,                     >
               PLANT=(8,=CL8'CTSARUH')
         B     MRRET
*
MSG274   DS    0H
         LR    R15,R0                  R15 -> PLANT.
         CTSMSG1 CODE=CTS274E,ROUT=NO,RAREA=RAREA,                     >
               PLANT=(8,=CL8'CTSARUH',30,0(R15))
         B     MRRET
*
MSG275   DS    0H
         CTSMSG1 CODE=CTS275E,ROUT=NO,RAREA=RAREA,                     >
               PLANT=(8,=CL8'CTSARUH')
         B     MRRET
*
**   RETURN THE MESSGAE TO THE CALLER IN THE ERROR BLOCK.
**
**   THE MESSAGE WAS CREATED BY CTSMSG1 IN RAREA:
**   MESSAGE FORMAT:
**   - 2 BYTES = MESSAGE LENGTH
**   - MESSAGE TEXT
*
MRRET    DS    0H
         LLGT  R1,$ERRMSAL             R1 -> MESSAGE AREA LENGTH.
         L     R1,0(,R1)               R1 = MESSGAE AREA LENGTH.
         AHI   R1,-1                   LEAVE 1 BYTE FOR X'00'
         LH    R15,RAREA               R15 = MESSAGE LENGTH.
         CR    R15,R1                  ENOUGH SPACE FOR MESSAGE ?
         BNH   MRRETMSG                ..YES - MOVE.
         LR    R15,R1                  ..NO - TRUNCATE
MRRETMSG DS    0H
         AHI   R15,-1                  FOR EX.
         LLGT  R1,$ERRMSGA             R1 -> MESSAGE LENGTH.
         EX    R15,MRMVMSG
         B     *+L'*+L'MRMVMSG
MRMVMSG  MVC   0(0,R1),RAREA+2
         LA    R1,1(R15,R1)            R1 -> CHAR AFTER MSG TEXT.
         MVI   0(R1),X'00'             PUT C-TYPE TERMINATOR.
         LLGT  R1,$ERRMSGL             R1 -> MESSAGE LENGTH.
         CHI   R1,0                    PROVIDED ?
         BE    MREND                   ..NO - NO NEED TO RETURN.
*                                      ..YES - RETURN LESSAGE LENGTH.
         AHI   R15,1                   1 FOR EX (X'00' IS NOT COUNTED)
         ST    R15,0(,R1)              RETURN LENGTH.
*
**  RETURN
*
MREND    DS    0H
         LM    R14,R12,WASAMSG+4       RESTORE REGISTERS.
         XC    WASAMSG(4),WASAMSG      REMOVE EYE-CATCHER.
         BR    R14                     RETURN.
         DROP  ,
MSGRTNE  DS    0H
*
*--------------------------------------------------------------------
**                      CONSTANTS
*--------------------------------------------------------------------
CONST    DS    0F
         LTORG ,
*
#RCOK    EQU   0                       OK
#RCEOF   EQU   4                       GET: EOF.
#RCBLKAL EQU   4                       PUT: BLOCK ALLOCATION FAILED.
#RCNOTUS EQU   4                       TERMIO: WE ARE NOT THE OWNER.
#RCL2L   EQU   8                       LINE TOO LONG.
#RCHNDAL EQU   12                      HANDLE ALLOCATION FAILED.
#RCPRM   EQU   16                      ERROR IN PARAMETERS.
#RCINT   EQU   20                      INTERNAL ERROR.
*
#MINSG#  EQU   1                       MINIMUM RUOB LENGTH, IN MB.
*
#MAXMSGL EQU   170                     MINIMUM LENGTH FOR MESSAGE AREA.
#MAXPUTL EQU   255                     MAX LINE LENGTH FOR PUT.
*
#M271TL  EQU   30                      CTS271 PLANT TEXT LENGTH
#M274TL  EQU   30                      CTS274 REASON TEXT LENGTH.
*
*  INITRTN REQUEST CODES:
#IRVNA   EQU   X'0000'                 VERIFY AND/OR ALLOCATE.
#IRVER   EQU   X'0001'                 VERIFY ONLY.
#IRALC   EQU   X'0002'                 ALLOCATE AND INIT.
#IRINIT  EQU   X'0004'                 INIT ONLY.
*
#UTOKIDX EQU   X'00E7'                 X'00'+ C'X'
*
HNDLICAT DC    C'RUHH'                 HANDLE EYE-CATCHER.
DBGTWTO  DC    CL8'WTO'
RUOBEYE  DC    CL4'RUOB'               RUOB EYE-CATCHER.
F1SA     DC    C'F1SA'                 'STACK USED' SA INDICATION.
MGSA     DC    C'MGSA'                 MSGRTN SAVE AREA EYEC.
*
         CTSAAMD DEFCMDT,CMDTAB=AMDCMDTB
*
**   FUNCTIONS BRANCH TABLE
**
**   *** ATTENTION ***
**
**   WHEN ADDING/DELETING FUNCITONS OR WHEN CHANGING THE FUNCTION
**   NAMES, THE #DEFINE STATEMENTS FOR THESE NAMES IN CTSCCLI/CTSOCLI
**   SHOULD BE CHANGED ACCORDINGLY.
**
**   - FUNCTION NAME.
**   - FUNCTION MAIN PROCESS ROUTINE.
**   - FUNCTION SECONDARY PROCESS ROUTINE.
*
FUNCTAB  DS    0X
FSTARTIO DC    CL8'STARTIO',AL4(STARTIO),AL4(0)
FTGETF   DC    CL8'GETFIRST',AL4(GET),AL4(GETF)
FTGETN   DC    CL8'GETNEXT',AL4(GET),AL4(GETN)
FTPUT    DC    CL8'PUT',AL4(PUT),AL4(0)
FTTERMIO DC    CL8'TERMIO',AL4(TERMNFRE),AL4(TERMIO)
FTTRMNFR DC    CL8'TERMNFRE',AL4(TERMNFRE),AL4(TERMIO)
FTFREE   DC    CL8'FREERUOB',AL4(TERMNFRE),AL4(FREE)
FTABE    EQU   *
#FTABNUM EQU   (FTABE-FUNCTAB)/#FELEN
*
         CTSAN2C WORK=YES,RENT=CONST
*
*        DC    CL30'(A=12345678 L=12345678 SP=123)'
M271BR   DC    CL(#M271TL)' '          CTS271 DATA FOR BELOW THE BAR.
         ORG   M271BR
         DC    C'(A='       3
M271BRA  DC    CL8' '    +  8          AREA ADDRESS.
         DC    C' L='    +  3
M271BRL  DC    CL8' '    +  8
         DC    C' SP='   +  4
M271BRSP DC    CL3' '    +  3
         DC    C')'      +  1
         ORG   ,         = 30
*
*        DC    CL30'(RS=12345678  L=123MB)'
M271AO   DC    CL(#M271TL)' '          CTS271 DATA FOR ABOVE THE BAR.
         ORG   M271AO
         DC    C'(RS='           4
M271AORS DC    CL8' '         +  8
         DC    C' L='         +  3
*WS100779 M271AOL  DC    CL3' '         +  3
M271AOL  DC    CL4' '         +  4                             WS10079
         DC    C'MB)'         +  3
         ORG   ,              = 22
*
*        DC    CL30'(RS=12345678 UTOKEN=12345678)'
M271AR   DC    CL(#M271TL)' '          CTS271 DATA FOR ABOVE THE BAR.
         ORG   M271AR
         DC    C'(RS='           4
M271ARRS DC    CL8' '         +  8
         DC    C' UTOKEN='    +  8
M271ARUT DC    CL8' '         +  8
         DC    C')'           +  1
         ORG   ,              = 29
*
M274EYE  DC    CL(#M274TL)'NO VALID EYECATCHER.'
M274LEN0 DC    CL(#M274TL)'DATA LENGTH IS 0'
*
*--------------------------------------------------------------------
**                    WORK AREA (HANDLE)
*--------------------------------------------------------------------
WA       DSECT
SA       DS    18F                     SAVE AREA
#SAL     EQU   *-SA                    SAVE AREA LENGTH.
*
**   HANDLE PART - TO BE KEPT BETWENE CALLS.
*
WAHNDLS  DS    0F                      START OF HANDLE.
WAHEYEC  DS    CL4                     EYE-CATCHER.
WAHBLCUR DS    AD                      -> CURRENT BLOCK
WAHMAXDL DS    FD                      LENGTH OF DATA AREA IN BLOCK.
WAHRDLEN DS    FD                      LENGTH OF DATA ALREADY READ.
*
WAHOWNER DS    C                       WORK ARE OWNER:
#WAHOWNC EQU   C'C'                    ..CALLER.
#WAHOWNW EQU   C'W'                    ..WE.
*
WAHDBGT  DS    X                       DEBUG TYPE (ACCORDING TO CTSADBG
*                                      MACRO):
*                                      1 - PRTDBG.
*                                      3 - WTO.
*
WAHEOF   DS    X                       EOF INDICATIN.
#WAHEOFN EQU   X'00'                   - NO EOF.
#WAHEOFY EQU   X'FF'                   - EOF.
*
WAHBLUNU DS    X                       BLOCK ARE UNUSABLE:
#WAHUNUN EQU   X'00'                   - USABLE.
#WAHUNUY EQU   X'FF'                   - UNUSABLE.
*
WAHUNUMS DS    X                       UNUSABLE MESSAGE ISSUED:
#WAHUNMN EQU   X'00'                   - NOT ISSUED.
#WAHUNMY EQU   X'FF'                   - ISSUED.
*
WAHNDLE  DS    0X                      END OF HANDLE.
#WAHNDLL EQU   *-WAHNDLS               HANDLE LENGTH.
*
**   WORK AREA PART - TO BE CLERED FOR EACH CALL.
*
WAWA     DS    0X                      START OF WORK AREA.
WASAMSG  DS    16F                     MSG ROUTINE SAVE AREA.
*                                      1 WORD FOR EYE-CATCHER FOLLOWED
**   PURIFIED PARAMETERS ADDRESSES
$HANDLE  DS    A                       -> HANDLE ADDRESS.
$BLKA    DS    A                       -> FIRST  BLOCK ADDRESS.
$LINEA   DS    A                       -> DATA LINE.
@LINELEN DS    A                       -> LINE LENGTH.
$LOBLEN  DS    A                       -> LINE BUF / BLOCK LENGTH.
$UTKNA   DS    A                       -> USERTOKEN.
$DBGL    DS    A                       -> DBG LEVEL.
$ERRMSGA DS    A                       -> AREA FOR ERROR MESSAGE.
$ERRMSAL DS    A                       -> ERR MESSAGE AREA LENGTH.
$ERRMSGL DS    A                       -> ERROR MESSAGE LENGTH.
*
WAAMODE  DS    A                       ENTRY AMODE.
WADB64AM DS    A                       AMODE SAVE FOR DBG64
DBGLEVEL DS    X                       DEBUG LEVEL FOR THIS ROUTINE
*
WADATAL  DS    FD                      BUF DATA LENGTH.
WATTKN   DS    XL16                    JSTCB TTOKEN.
WAUTKN   DS    FD                      USER TOKEN FOR THE RUOB.
WABLKSG# DS    FD                      # OF SEGMENTS FOR BLOCK.
WABLKNEW DS    AD                      -> NEW BLOCK.
WABLKAD  DS    AD                      FOR DIAG.
WALINEAD DS    AD                      FOR DIAG.
*
WAV64RC  DS    F                       IARV64 RETURN CODE.
WAV64RS  DS    F                       IARV64 REASON CODE.
WASTORRC DS    F                       STIRAGE MACRO RC.
WARET    DS    A                       INTERNAL ROUTINE RETURN ADDRESS.
WATIHA   DS    A                       HANDLE ADDRESS FOR TERMIO.
WARUOCPY DS    XL(#RUOHLEN)            RUOH COPY (FOR DIAG).
WAPARMNM DS    CL8                     PARM NAME (FOR MESSAGE)
WAFUNC   DS    CL8                     FUNC NAME (FOR MESSAGE).
WAFUNCA  DS    A                       -> FUNC ENTRY.
MSGACT   DS    CL7                     'RELEASE' FOR CTS271E
M271CBNM DS    CL8                     CONTROL BLOCK NAME
M271ADDR DS    CL8                     ADDRESS FOR CTS271E
NUMCHAR  DS    CL8                     CTSAN2C OUTPUT IN CHAR.
NUMCHAR2 DS    CL8                     CTSAN2C OUTPUT IN CHAR.
HEXCHAR  DS    CL8                     CTSAN2C OUTPUT IN HEX
CHARRC   DS    CL2                     RC IN CHAR
WAM271TX DS    CL(#M271TL)             CTS271 TEXT PLANT.
WAL2L1   DS    F                       LENGTH 1 FOR CTS272
WAL2L2   DS    F                       LENGTH 2 FOR CTS272
         CTSAN2C WORK=YES,RENT=VAR
*
         IARV64 MF=(L,WAV64L)
*
WATCBTKL TCBTOKEN MF=L
*
         DS    0D
RAREA    DS    XL512                   USED BY CTSADBG
DBGAREA  DS    XL2048                  USED BY CTSADBG
*
#WAWALEN EQU   *-WAWA                  LENGTH OF WORK AREA PART.
#WALEN   EQU   *-WA                    LENGTH OF AREA
*
*--------------------------------------------------------------------
**                   FUNCTAB ENTRY.
*--------------------------------------------------------------------
FENTRY   DSECT
FENAME   DS    CL8                     FUNCITON NAME.
FERTN1   DS    AL4                     -> MAIN ROUTINE.
FERTN2   DS    AL4                     -> 2ND ROUTINE.
#FELEN   EQU   *-FENTRY
*--------------------------------------------------------------------
**                   PARAMTEERS BLOCK.
*--------------------------------------------------------------------
PRM      DSECT                         INPUT PARAMETERS
PRMFUNC  DS    A           (I)   (8)   -> FUNCTION.
PRMHNDLE DS    A         (I/O)   (4)   -> HANDLE ADDRESS.
PRMBLKA  DS    A         (I/O)   (8)   -> FIRST RUOB ADDRESS.
PRMLINEA DS    A                 (4)   -> LINE:
*                          (O)           - GET - AREA FOR LINE.
*                          (I)           - PUT - LINE TO PUT.
PRMLNELN DS    A                 (4)   -> LINE LENGTH:
*                          (O)           - GET - LENGTH OF LINE READ.
*                          (I)           - PUT - LENGTH OF LINE TO PUT.
PRMGOUBL DS    A           (I)   (4)   -> GET: LINE BUFFER LENGTH.
         ORG   PRMGOUBL
PRMPBLKL DS    A           (I)         -> PUT - BLOCK LENGTH FOR THE
*                                               FIRST RUOB, IN MB.
         ORG   ,
PRMUTKNA DS    A           (I)   (4)   -> USRTOKEN FOR IARV64. (PUT)
PRMDBGL  DS    A           (I)   (4)   -> DEBUG LEVEL.
PRMDBGT  DS    A           (I)   (8)   -> DEBUG TYPE (PRTDBG / WTO).
PRMEMSGA DS    A           (O) (170)   -> AREA FOR ERROR MESSAGE.
PRMEMSAL DS    A           (I)   (4)   -> ERROR MESSAGE AREA LENGTH.
PRMEMSGL DS    A           (O)   (4)   -> ERROR MESSAGE LENGTH.
*
*--------------------------------------------------------------------
**                         DSECTS
*--------------------------------------------------------------------
         CTSEQUR
*
         COPY CTSARUOB
*
         END
