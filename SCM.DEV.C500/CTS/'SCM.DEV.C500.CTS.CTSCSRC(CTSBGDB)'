/**************************************************************
*                                                             *
* Title            : Manage Global DataBase (ACF2)            *
*                                                             *
* File Name        : ctsbgdb.c                                *
*                                                             *
* Author           : Yishay Yovel                             *
*                                                             *
* Creation Date    : 20/07/97                                 *
*                                                             *
* Description      : Manage access for API specific Database  *
*                    implemented on VSAM KSDS dataset         *
* Assumptions and                                             *
*   Considerations : Current implementation support ACF2      *
*                    "group" object which is supported by the *
*                    API implementation and not by ACF2.      *
**************************************************************/

/**************************************************************
* Mod.Id   Who      When     Description                      *
* -------- -------- -------  -------------------------------- *
* WS10054  SeligT   04/08/16 Add ENQ/DEQ SYSTEMS RNL Parameter*
* SAS2IBMT SeligT   15/08/16 SAS/C to IBM C Conversion Project*
* IS10139  SeligT   28/08/16 Update OS Functions for Agents   *
* IS10156  SeligT   13/09/17 Allocate ADDINFO Size Correctly: *
*                            just changing print_amrc diag    *
*                            levels from 0 to 1 in 5 places   *
* BS10067  SeligT   25/09/17 Aggregat'n Errors With Empty GDB:*
*                            EOF on VSAM_POINT request should *
*                            return GDB_NOT_FOUND from the    *
*                            print_amrc routine.              *
* BS10076  SeligT   11/12/17 Organize Connector Locking       *
*                            Functions and Structures         *
* BS10093  SeligT   12/08/18 Add and Delete Group Functions   *
*                            Not Working After CCID BS10091   *
* IS10176  SeligT   16/10/18 Potential Locking Problem With   *
*                            ACF2 Files, UDB and GDB          *
* WS10082  MauriC   07/11/22 Recompile for new ADDINFO macros *
**************************************************************/

/*
 * Support OS-level functions and VSAM access
 */

#include <globs.h>
 /* SAS2IBMT #include <lcio.h>                                       */
#include <errno.h>
 /* SAS2IBMT #include <lclib.h>                                      */
 /* SAS2IBMT #include <ostask.h>                                     */
 /* SAS2IBMT #undef OR                                               */

/*
 * Standard Include files
 */

#include STDLIB
#include STDIO
#include STRING
#include CTYPE

#include ESA_DIAG
#include ESA_API
#include ESA_API_CODES
#include ESA_CS_OS                                       /* WS10054 */

#include MVS_OS_MVS                                      /* WS10054 */
#include MVS_COMP

#include API_ADDINFO
#include API_AUTH

/* IS10139 #include <CTSCSRV.h>                              WS10054 */
#include ACF2

/*
 * Local pre-processor defintions
 */

#define CTSAGDB "dd:CTSAGDB"       /* used to be ddn:CTSAGDB SAS2IBMT */
#define GDB_READONLY  "rb,type=record"  /* used to be "rk"   SAS2IBMT */
#define GDB_READWRITE "r+b,type=record" /* used to be "r+k"  SAS2IBMT */
/* BS10076
#define LOCK_INTERVAL 600 // Seconds = 10 minutes            WS10054 */

#define MAX_GDB_RECORD_SIZE 4000

/*----------------------------------------------------------------
   GDB Record Definition:
       Record Type : 'G' - Groups,
                     'U' - Users  (in emulation mode)
                     '*' - Ignore
       Record Key  : Group Name / User Id
       Record EOS  : End-OF-String for key
       Addinfo     : a long string made of addinfo pairs, each name
                     or value is null-terminated
 -------------------------------------------------------------------*/

typedef struct {
 char   GDB_Record_Type;
 char   GDB_Record_Key[GDB_KEY_LENGTH];
 char   GDB_EOS;
 char   GDB_ADDINFO[MAX_GDB_RECORD_SIZE+1];
} GDB_record;

/*
 * Static Read Only fields
 */

/* WS10054 static char GDB_Rname[44] = "GDBLOCK";                    */

/*
 * Static Read Write fields (global to the entire GDB implementation)
 */

static FILE *GDB = NULL;                        /* GDB File Handle    */
static GDB_Modes GDB_Current_Mode = GDB_Closed; /* GDB access Mode
                                                   Closed,
                                                   Read  ,
                                                   ReadWrite          */
static int       GDB_Open_Count = 0;            /* Number of Opens
                                                   Requested (allow
                                                   recursive open)    */
static GDB_record record;                       /* Curr. Record       */
static GDB_Record_Size = 0;                     /* Curr. Rec Size     */
static GDB_ADDINFO_Size = 0;                    /* Curr. ADDINFO size */
static void * lock_handle = NULL ;              /* lock handle WS10054*/
static GDB_Codes global_rc = GDB_OK;            /*            SAS2IBMT */

/*
 * Internal Functions
 */

static GDB_Codes GDB_Release_Lock(ADMIN_PARAMS_rec_typ * admin_params);
                                                          /* WS10054 */
static GDB_Codes GDB_Obtain_Lock(GDB_Locks,
                 ADMIN_PARAMS_rec_typ * admin_params);    /* WS10054 */
static int       GDB_Calc_Record_Size(void);
static int       GDB_Calc_ADDINFO_Size(void);
static void      print_amrc(void);                        /* SAS2IBMT */

/******************************************************************
 * Procedure Name: GDB_Set_Mode
 ******************************************************************
 * Description   : Close/Open GDB for access
 *                 Open: If closed, Obtain Locks and Open GDB.
 *                       If opened for current mode, increase open count
 *                       If opened for Readonly and ReadWrite is
 *                          required, Re-Open GDB and increase Count
 *                 Close: If Count is 1, Physically close.
 *                        If Count is >1, Decrease Count
 *                        If Count is <1, skip
 *
 * Input         : Mode         - Closed, ReadOnly, ReadWrite
 *
 * Output        : GDB_Open_Count   - GDB number of pending opens
 *               : GDB_Current_Mode - GDB mode after call
 *
 * Return Value  : GDB_Codes    - GDB_OK, GDB_Open_Error
 ******************************************************************/
GDB_Codes GDB_Set_Mode(GDB_Modes mode,
                       ADMIN_PARAMS_rec_typ * admin_params,
                       ERR_STRUCT_rec_typ   * err)
{
 static char func[] = "GDB_Set_Mode";
 int rc1 = 0;
 int logout_done = FALSE;
 GDB_Codes rc = GDB_OK;
 CTSAMSG_HANDLE_rec_ptr     msgs;
 CTSAMSG_DEST_TABLE_rec_ptr dest;

 msgs = admin_params->ctsamsg_handle;
 dest = admin_params->ctsamsg_dest;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 if (CTSCRSS_set_authority( &logout_done,
                        SET_TO_STARTED_TASK_AUTH,
                        admin_params,
                        err) NE ESA_OK)
   {
    CTSAMSG_print(ERR_INTERNAL2,msgs, NULL, dest, "GDBOPEN",func,
          "Authority switch to STC failed", 16,__LINE__);
    rc = ESA_FATAL;
    goto exit;
   };

 switch(mode)
  {
   /*----------------------------------------------*/
   /* GDB Close                                    */
   /*----------------------------------------------*/
   case GDB_Closed :

    ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB Close entered, Open Count is %d",
                    GDB_Open_Count);

    switch(GDB_Open_Count)
     {
      case 0:
       /* File Not open, skip */
       goto exit;
      case 1:
       /* Physical Close: File open once, Close it */
       GDB_Open_Count--;
       break;
      default:
       /* Logical Close: decrease count and exit */
       GDB_Open_Count--;
       goto exit;
     };

    /* SAS2IBMT rc1 = fclose(GDB);                                   */
    if (fclose(GDB)) print_amrc();                        /* SAS2IBMT */
    GDB = NULL;

    GDB_Current_Mode = GDB_Closed;

    GDB_Release_Lock(admin_params);                       /* WS10054 */
    break;

   /*----------------------------------------------*/
   /* GDB Open for ReadOnly                        */
   /*----------------------------------------------*/
   case GDB_ReadOnly:

    ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB Open ReadOnly entered, Open Count is %d",
                    GDB_Open_Count);

    GDB_Open_Count++;

   /*--------------------------------------------------------------*/
   /* If GDB is Opened , Continue (ReadWrite mode support ReadOnly */
   /*--------------------------------------------------------------*/
    if (GDB_Current_Mode NE GDB_Closed)
     goto exit;

   /*--------------------------------------------------------------*/
   /* Get ReadOnly Lock                                            */
   /*--------------------------------------------------------------*/
    rc = GDB_Obtain_Lock(GDB_ReadOnly_Lock, admin_params);  /*WS10054*/
    if (rc NE GDB_OK)
     {
      GDB_Open_Count--;                 /* decrement counter IS10176 */
      ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB_Open_Count decremented to %d",   /* IS10176 */
                    GDB_Open_Count);                      /* IS10176 */
      rc = GDB_Read_Lock_Failed;
      goto exit;
     };

   /*--------------------------------------------------------------*/
   /* Open GDB for Readonly                                        */
   /*--------------------------------------------------------------*/
    GDB = fopen(CTSAGDB,GDB_READONLY);

    if (GDB EQ NULL)
     {
      print_amrc();                                       /* SAS2IBMT */
      GDB_Open_Count--;                 /* decrement counter IS10176 */
      ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB_Open_Count decremented to %d",   /* IS10176 */
                    GDB_Open_Count);                      /* IS10176 */
      GDB_Release_Lock(admin_params);   /* release the lock  IS10176 */
      rc = GDB_Open_Failed;
      GDB_Current_Mode = GDB_Closed;
      goto exit;
     };

   /*--------------------------------------------------------------*/
   /* Set GDB Current Mode to Readonly                             */
   /*--------------------------------------------------------------*/
    GDB_Current_Mode = GDB_ReadOnly;

    break;

   /*----------------------------------------------*/
   /* GDB Open for ReadWrite (Update)              */
   /*----------------------------------------------*/
   case GDB_ReadWrite:

    ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB Open ReadWrite entered, Open Count is %d",
                    GDB_Open_Count);

    GDB_Open_Count++;

   /*--------------------------------------------------------------*/
   /* If GDB Current Mode is ReadOnly, Re-Open GDB                 */
   /*--------------------------------------------------------------*/
    switch(GDB_Current_Mode)
     {
      /*--------------------------------------------------------------*/
      /* If GDB Current Mode is ReadOnly, Release Locks and Close GDB */
      /*--------------------------------------------------------------*/
      case GDB_ReadOnly:
        /* SAS2IBMT fclose(GDB);                                     */
        if (fclose(GDB)) print_amrc();                    /* SAS2IBMT */
        GDB_Release_Lock(admin_params);                   /* WS10054 */
        break;
      /*--------------------------------------------------------------*/
      /* If GDB Current Mode is ReadWrite, skip it                    */
      /*--------------------------------------------------------------*/
      case GDB_ReadWrite:
        goto exit;
      default:;
     };

   /*--------------------------------------------------------------*/
   /* Get ReadWrite Lock                                           */
   /*--------------------------------------------------------------*/
    rc = GDB_Obtain_Lock(GDB_ReadWrite_Lock, admin_params); /*WS10054*/
    if (rc NE GDB_OK)
     {
      GDB_Open_Count--;                 /* decrement counter IS10176 */
      ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB_Open_Count decremented to %d",   /* IS10176 */
                    GDB_Open_Count);                      /* IS10176 */
      rc = GDB_Update_Lock_Failed;
      goto exit;
     };

   /*--------------------------------------------------------------*/
   /* Open GDB for ReadWrite Processing                            */
   /*--------------------------------------------------------------*/
    GDB = fopen(CTSAGDB,GDB_READWRITE);
    if (GDB EQ NULL)
     {
      print_amrc();                                       /* SAS2IBMT */
      GDB_Open_Count--;                 /* decrement counter IS10176 */
      ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_IMPORTANT,
                    "GDB_Open_Count decremented to %d",   /* IS10176 */
                    GDB_Open_Count);                      /* IS10176 */
      GDB_Release_Lock(admin_params);   /* release the lock  IS10176 */
      rc = GDB_Open_Failed;
      GDB_Current_Mode = GDB_Closed;
      goto exit;
     };

   /*--------------------------------------------------------------*/
   /* Set Current Mode to ReadWrite                                */
   /*--------------------------------------------------------------*/
    GDB_Current_Mode = GDB_ReadWrite;
    break;

   /*--------------------------------------------------------------*/
   /* Unknown Mode Requested                                       */
   /*--------------------------------------------------------------*/
   default:;
    rc = GDB_Wrong_Mode;
  };

 exit:;

 if (logout_done EQ TRUE)
    CTSCRSS_set_authority(&logout_done,
                          RETURN_FROM_STARTED_TASK_AUTH,
                          admin_params,
                          err);

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}
/******************************************************************
 * Procedure Name: GDB_Obtain_Lock
 ******************************************************************
 * Description   : Get GDB Access Lock
 *                 ReadOnly: Obtain GDB Qname/Rname in "SHARE" mode
 *                 ReadWrite: Obtain GDB Qname/Rname in "EXCLUSIVE" mode
 * Input         : Lock         - ReadOnly, ReadWrite
 *
 * Return Value  : GDB_Codes    - GDB_OK, GDB_Obtain_Lock_Failed
 *
 * Special Considerations:
 * - Uses SAS/C ENQ Macro interface and NOT the USA-API OSLOCK package
 *   because it does not support ENQ with SHR option.
 * - With modification WS10054, the above statement is no longer true.
 *   We now use the USA-API OSLOCK package which now DOES support ENQ
 *   with the SHR option.
 * - With modification BS10076, all waiting and looping is now done
 *   in the lock routine and all required fields, e.g., total wait
 *   time and interval wait time, are saved in the lock header/handle
 *   to be used by the lock routine.
 *   These 2 values came from the following RSSPARM parameters or
 *   (if not present in RSSPARM) from the following #define default
 *   macro definitions:
 *     ACF2_LOCK and ACF2_LOCK_INTERVAL - CTSBACF CMAC
 ******************************************************************/
static GDB_Codes GDB_Obtain_Lock(GDB_Locks lock,
                     ADMIN_PARAMS_rec_typ * admin_params) /* WS10054 */
{
 static char func[] = "GDB_Obtain_Lock";
 int       rc1, i, retries, interval;
 GDB_Codes rc = GDB_OK;
 /* WS10054 char      QNAME[9]="";                                   */
 char      file_name[45];                                 /* WS10054 */
 CTSAMSG_PARAMS_rec_typ msg_params;                       /* WS10054 */
 char      exc_shr[] = "E";                               /* WS10054 */
 ACF2_PARAMS_rec_typ * params_ptr = NULL;                 /* BS10076 */
 int       acf2_lock_value;                               /* BS10076 */
 int       acf2_lock_interval_value;                      /* BS10076 */

 msg_params.ctsamsg_handle = admin_params->ctsamsg_handle;/* WS10054 */
 msg_params.ctsamsg_dest   = admin_params->ctsamsg_dest;  /* WS10054 */

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /* * * * * * * BS10076 start * * * * * * */
 params_ptr = admin_params->apiinit_handle;
 acf2_lock_value          = params_ptr->rssparm_ACF2_LOCK;
 acf2_lock_interval_value = params_ptr->rssparm_ACF2_LOCK_INTERVAL;

 ESA_DIAG_printf (PLT_COMP_API_ACF2, 6,
                  "ACF2_LOCK=<%d>  ACF2_LOCK_INTERVAL=<%d>",
                  acf2_lock_value,
                  acf2_lock_interval_value);
 /* * * * * * * BS10076 end * * * * * * */

 /* * * * * * * * * * Start of WS10054 * * * * * * * * * */

 strcpy(file_name, "CTSAGDB");

 /* BS10076
 rc = OS_CS_lock_init(file_name, 0 ,&lock_handle, NULL,              */
 rc = OS_CS_lock_init(file_name, &lock_handle,            /* BS10076 */
                      acf2_lock_value,                    /* BS10076 */
                      acf2_lock_interval_value,           /* BS10076 */
                      SCOPE_REMOTE, &msg_params);
 if ( rc NE ESA_OK )
    goto exit;

 if (lock EQ GDB_ReadOnly_Lock)
    strcpy(exc_shr, "S");
 else
    strcpy(exc_shr, "E");

 /* * * * * * * * * *  End of WS10054  * * * * * * * * * */

 /* WS10054 strcpy(QNAME,Global_Get_QNAME());  */

 /* BS10076 delete this code - all waiting and looping is
            being done in the lock routine and all required
            fields are now in the lock header/handle
 interval = Global_Retry_Wait_Lock_Time();
 if (interval EQ 0)
  interval = 30;

 retries = Global_Total_Wait_Lock_Time() / interval;
 if (retries EQ 0)
  retries = 20;

 for(i=0;i LT retries;i++)
  {                                                                  */
   /* WS10054
   if (lock EQ GDB_ReadOnly_Lock)
    rc1 = ENQ(QNAME,GDB_Rname,S,sizeof(GDB_Rname)-1,SYSTEMS,HAVE);
   else
    rc1 = ENQ(QNAME,GDB_Rname,E,sizeof(GDB_Rname)-1,SYSTEMS,HAVE);   */
   /* BS10076
   rc1 = OS_CS_DO_LOCK (lock_handle,LOCK_INTERVAL,        // WS10054 */
   rc1 = OS_CS_DO_LOCK (lock_handle,                      /* BS10076 */
                        &msg_params, exc_shr);            /* WS10054 */
   if ( rc1 NE ESA_OK )                                   /* WS10054 */
   {                                                      /* WS10054 */
    rc = GDB_Obtain_Lock_Failed;                          /* WS10054 */
    goto exit;                                            /* WS10054 */
   }                                                      /* WS10054 */

   /* WS10054
   if (rc1 NE 0)
    sleep(interval);
   else
    break;            */
  /* BS10076 remove the 'for' loop's end bracket
  };                                                                 */

 /* WS10054
 if (rc1 NE 0)
 {
   rc = GDB_Obtain_Lock_Failed;
   goto exit;
  };                  */

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Release_Lock
 ******************************************************************
 * Description   : Relase all obtained locks
 *
 * Return Value  : GDB_Codes    - GDB_OK, GDB_Release_Lock_Failed
 *
 * Special Considerations:
 * - Uses SAS/C DEQ Macro interface and NOT the USA-API OSLOCK package
 * - With modification WS10054, the above statement is no longer true.
 ******************************************************************/
static GDB_Codes GDB_Release_Lock(ADMIN_PARAMS_rec_typ * admin_params)
                                                          /* WS10054 */
{
 static char func[] = "GDB_Release_Lock";
 int       rc1;
 GDB_Codes rc = GDB_OK;
 /* WS10054 char      QNAME[9]="";                                   */
 CTSAMSG_PARAMS_rec_typ msg_params;                       /* WS10054 */

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 msg_params.ctsamsg_handle = admin_params->ctsamsg_handle;/* WS10054 */
 msg_params.ctsamsg_dest   = admin_params->ctsamsg_dest;  /* WS10054 */

 /* WS10054 strcpy(QNAME,Global_Get_QNAME());

 rc1 = DEQ(QNAME,GDB_Rname,sizeof(GDB_Rname)-1,SYSTEMS,HAVE);

 if (rc1 NE 0)
 {
   rc = GDB_Release_Lock_Failed;
   goto exit;
  };                            */

 /* * * * * * * * * * Start of WS10054 * * * * * * * * * */

 if ( lock_handle NE NULL ) {
   rc1 = OS_CS_unlock (lock_handle, &msg_params);

   if (rc1 NE 0)
   {
     rc = GDB_Release_Lock_Failed;
     goto exit;
   };

   rc1 = OS_CS_lock_term (&lock_handle, &msg_params);
 }

 /* * * * * * * * * *  End of WS10054  * * * * * * * * * */

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Insert
 ******************************************************************
 * Description   : Insert Current GDB Record into the Database
 *
 * Return Value  : GDB_Codes    - GDB_OK
 *                                GDB_Duplicate_Key
 *                                GDB_Insert_Failed
 *
 * Special Considerations:
 * - Uses SAS/C VSAM interface function (kinsert)
 * - In modification SAS2IBMT we removed all SAS/C functions and
 *   replaced them with their IBM C counterparts.
 * - The GDB package assumes record for insert is established in the
 *   static record strcuture.
 *
 * See Also: GDB_Convert_to_Record, GDB_Convert_from_Record
 ******************************************************************/
GDB_Codes GDB_Insert(void)
{
 static char func[] = "GDB_Insert";
 int       rc1;
 GDB_Codes rc = GDB_OK;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*--------------------------------------------------------------*/
 /* Check Correct GDB Mode                                       */
 /*--------------------------------------------------------------*/
 if (GDB_Current_Mode NE GDB_ReadWrite)
  {
   rc = GDB_Wrong_Mode;
   goto exit;
  };

 /*--------------------------------------------------------------*/
 /* Insert Record                                                */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT The following SAS/C function was removed and was replaced
    by its IBM C counterpart.  In case of an fwrite error, the feedback
    code (in the print_amrc routine) will 'tell us' whether the error
    was caused by an attempt to write a record with a duplicate key.
 rc1 = kinsert(&record, GDB_Calc_Record_Size(), 0 , GDB);

 if (rc1 NE 0)
  {
   if (errno EQ EDUPKEY)
    rc = GDB_Duplicate_Key;
   else
    rc = GDB_Insert_Failed;
  };                                                                 */

/* * * * * * * * * * Start of SAS2IBMT * * * * * * * * * */

 rc1 = fwrite(&record, 1, GDB_Calc_Record_Size(),GDB);

 if (rc1 != GDB_Calc_Record_Size())
  {
   print_amrc();
   if (global_rc == GDB_Duplicate_Key) rc = GDB_Duplicate_Key;
   else                                rc = GDB_Insert_Failed;
   goto exit;
  };
/* * * * * * * * * *  End  of SAS2IBMT * * * * * * * * * */

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Update
 ******************************************************************
 * Description   : Update Current GDB Record in the Database
 *
 * Return Value  : GDB_Codes    - GDB_OK
 *                                GDB_Update_Failed
 *
 * Special Considerations:
 * - Uses SAS/C VSAM interface function (kreplace)
 * - In modification SAS2IBMT we removed all SAS/C functions and
 *   replaced them with their IBM C counterparts.
 * - The GDB package assumes record for update is established in the
 *   static record strcuture and that VSAM is poisitioned to the record
 *   to update.
 *
 * See Also: GDB_Convert_to_Record, GDB_Convert_from_Record
 ******************************************************************/
GDB_Codes GDB_Update(void)
{
 static char func[] = "GDB_Update";
 int       rc1;
 GDB_Codes rc = GDB_OK;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*--------------------------------------------------------------*/
 /* Check Correct GDB Mode                                       */
 /*--------------------------------------------------------------*/
 if (GDB_Current_Mode NE GDB_ReadWrite)
  {
   rc = GDB_Wrong_Mode;
   goto exit;
  };

 /*--------------------------------------------------------------*/
 /* Update Record                                                */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT The following SAS/C function was removed and was replaced
    by its IBM C counterpart.  The fupdate function requires that
    an flocate + fread is done before the fupdate is attempted.  I
    found that the caller to this routine (in CTSBUUG) calls the
    ACF2_Get_Group routine (in CTSBAPI) before calling this routine.
    The ACF2_Get_Group routine calls the GDB_Locate and GDB_GetNext
    routines.  This means that we should have no problem now doing
    an fupdate.
 rc1 = kreplace(&record, GDB_Calc_Record_Size(), GDB);

 if (rc1 NE 0)
  {
    rc = GDB_Update_Failed;
  };                                                                 */

/* * * * * * * * * * Start of SAS2IBMT * * * * * * * * * */
 rc1 = fupdate(&record, GDB_Calc_Record_Size(), GDB);

 if (rc1 == 0)
  {
   print_amrc();
   rc = GDB_Update_Failed;
   goto exit;
  };
/* * * * * * * * * *  End  of SAS2IBMT * * * * * * * * * */

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Delete
 ******************************************************************
 * Description   : Delete Current GDB Record in the Database
 *
 * Return Value  : GDB_Codes    - GDB_OK
 *                                GDB_Delete_Failed
 *
 * Special Considerations:
 * - Uses SAS/C VSAM interface function (kdelete)
 * - In modification SAS2IBMT we removed all SAS/C functions and
 *   replaced them with their IBM C counterparts.
 * - The GDB package assumes the VSAM dataset is poisitioned for the
 *   record to delete.
 ******************************************************************/
GDB_Codes GDB_Delete(void)
{
 static char func[] = "GDB_Delete";
 int       rc1;
 GDB_Codes rc = GDB_OK;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 if (GDB_Current_Mode NE GDB_ReadWrite)
  {
   rc = GDB_Wrong_Mode;
   goto exit;
  };

 /* SAS2IBMT The following SAS/C function was removed and was replaced
    by its IBM C counterpart.  The fdelrec function requires that
    an flocate + fread is done before the fdelrec is attempted.  I
    found that the caller to this routine (in CTSBDUG) calls the
    GDB_Locate and GDB_GetNext routines before calling this routine.
    This means that we should have no problem now doing an fdelrec.
 rc1 = kdelete(NULL, GDB);                                           */
 rc1 = fdelrec(GDB);                                      /* SAS2IBMT */

 if (rc1 NE 0)
  {
    print_amrc();                                         /* SAS2IBMT */
    rc = GDB_Delete_Failed;
  };

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Locate
 ******************************************************************
 * Description   : Position GDB to a specific Record or the next GE
 *                 Record.
 *
 * Input         : Locate Mode: Exact   - Speicifc record
 *                              Generic - Great or Equal key
 *
 * Return Value  : GDB_Codes    - GDB_OK
 *                                GDB_Not_Found
 *                                GDB_Locate_Failed
 *
 * Special Considerations:
 * - Uses SAS/C VSAM interface function (ksearch)
 * - In modification SAS2IBMT we removed all SAS/C functions and
 *   replaced them with their IBM C counterparts.
 * - Access is done with Update/NoUpdate attribute based on GDB current
 *   mode.
 * - The GDB package assumes record for update is established in the
 *   static record strcuture and that VSAM is poisitioned to the record
 *   to update.
 *
 * See Also: GDB_Convert_to_Record, GDB_Convert_from_Record
 ******************************************************************/
GDB_Codes GDB_Locate(char Record_Type, char *key, GDB_Locate_Mode mode)
{
 static char func[] = "GDB_Locate";
 int flags = 0;
 int       rc1;
 GDB_Codes rc = GDB_OK;
 struct {
  char DRecord_Type;
  char DRecord_Key[GDB_KEY_LENGTH];
 } DKey;


 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*--------------------------------------------------------------*/
 /* Establish Read Access Mode (Exact / Generic)                 */
 /*--------------------------------------------------------------*/
 switch(mode)
  {
   /* SAS2IBMT case GDB_Exact_Locate:  flags = flags | K_exact;      */
   case GDB_Exact_Locate:   flags = __KEY_EQ;             /* SAS2IBMT */
                            break;
   case GDB_Generic_Locate: flags = __KEY_GE;             /* SAS2IBMT */
                            break;
   default:;
                            break;
  };

 /*--------------------------------------------------------------*/
 /* Establish Read with HOLD access (for ReadWrite GDB mode)     */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT
 if (GDB_Current_Mode EQ GDB_ReadOnly)
  flags = flags | K_noupdate;                                        */

 /*--------------------------------------------------------------*/
 /* Establish Access Key                                         */
 /*--------------------------------------------------------------*/
 DKey.DRecord_Type = Record_Type;
 Reset_Field(DKey.DRecord_Key,GDB_KEY_LENGTH,0X00,key);

 ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_ALL,
                 "Search Parms: rectype(%c), key(%s), len=(%d)",
                 Record_Type,DKey.DRecord_Key,
                 strlen(DKey.DRecord_Key));

 /*--------------------------------------------------------------*/
 /* Locate...                                                    */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT The following SAS/C function was removed and was replaced
    by its IBM C counterpart.
 rc1 = ksearch(&DKey, sizeof(DKey), flags, GDB);                     */
 rc1 = flocate(GDB, &DKey, sizeof(DKey), flags);          /* SAS2IBMT */

 /* flocate returns 0 if successful; EOF if not successful so...     */
 if (rc1 NE 0)                                            /* SAS2IBMT */
   {
     print_amrc();                                        /* SAS2IBMT */
     if (global_rc == GDB_Not_Found) rc = GDB_Not_Found;  /* SAS2IBMT */
     else                            rc = GDB_Locate_Failed;/*SAS2IBMT*/
     goto exit;                                           /* SAS2IBMT */
   };
 /*--------------------------------------------------------------*/
 /* rc1 <=0 :  Error Condition: 0: Not Found, <0: Error          */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT flocate returns a different return code so...
 if (rc1 LE 0)
  {
   if (rc1 EQ 0)
     rc = GDB_Not_Found;
   else
     rc = GDB_Locate_Failed;
   goto exit;
  };                                                                 */

 /*--------------------------------------------------------------*/
 /* If Record Retrieved, Check that Record Type matches          */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT flocate does not retrieve a record so...
 if (Record_Type NE DKey.DRecord_Type)
  {
   rc = GDB_Not_Found;
   goto exit;
  };                                                                 */

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_GetNext
 ******************************************************************
 * Description   : Retrieve Next GDB Record from current position
 *                 (after locate, retrieves current record)
 * Output        : Record Type  : 'G' - Groups, 'U' - Users
 *                 Key          : Entity Key
 *
 * Return Value  : GDB_Codes    - GDB_OK
 *                                GDB_EOF
 *                                GDB_GetNext_Failed
 *
 * Special Considerations:
 * - Uses SAS/C VSAM interface function (kretrv)
 * - In modification SAS2IBMT we removed all SAS/C functions and
 *   replaced them with their IBM C counterparts.
 * - The GDB package retrieves record into "record" variable. It can
 *   be retrieved from there by the Convert_from_Record function.
 *
 * See Also: GDB_Convert_to_Record, GDB_Convert_from_Record
 ******************************************************************/
GDB_Codes GDB_GetNext(char Record_Type, char *key)
{
 static char   func[] = "GDB_GetNext";

 int flags = 0;
 int       rc1;
 GDB_Codes rc = GDB_OK;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 /*--------------------------------------------------------------*/
 /* Set Access Mode according to GDB Current Mode                */
 /*--------------------------------------------------------------*/
 /* SAS2IBMT
 if (GDB_Current_Mode EQ GDB_ReadOnly)
  flags = K_noupdate;                                                */

 do {
   memset(&record,0X00,sizeof(record));
   /*--------------------------------------------------------------*/
   /* Retrieve Record                                              */
   /*--------------------------------------------------------------*/
   /* SAS2IBMT The following SAS/C function was removed and was replaced
      by its IBM C counterpart.
   rc1 = kretrv(&record, NULL, flags, GDB);                          */
   rc1 = fread(&record, 1, sizeof(record), GDB);          /* SAS2IBMT */

   /* fread returns >0 if successful so...                           */
   if (rc1 LE 0)                                          /* SAS2IBMT */
    {
     if (feof(GDB)) rc = GDB_EOF;                         /* SAS2IBMT */
     else if (ferror(GDB)) {                              /* SAS2IBMT */
             print_amrc();                                /* SAS2IBMT */
             if (global_rc == GDB_EOF) rc = GDB_EOF;      /* SAS2IBMT */
             else rc = GDB_GetNext_Failed;                /* SAS2IBMT */
          }                                               /* SAS2IBMT */
     goto exit;                                           /* SAS2IBMT */
    }
   /*--------------------------------------------------------------*/
   /* Check Error Condition: 0: EOF, <0: General Error             */
   /*--------------------------------------------------------------*/
   /* SAS2IBMT fread returns a different return code so...
   if (rc1 LE 0)
    {
     if (rc1 EQ 0)
       rc = GDB_EOF;
     else
       rc = GDB_GetNext_Failed;
     goto exit;
    }                                                                */
   else
    {
     /*--------------------------------------------------------------*/
     /* If retrieve OK, Build "record"  and ADDINFO information      */
     /*--------------------------------------------------------------*/
     if (key NE NULL)
       strcpy(key,record.GDB_Record_Key);
     GDB_Record_Size = rc1;
     ESA_DIAG_printf(PLT_COMP_API_ACF2,DEBUG_SHOW_ALL,
                     "Record (%s) retrieved, len=(%d)",
                     record.GDB_Record_Key,GDB_Record_Size);
     GDB_ADDINFO_Size = GDB_Calc_ADDINFO_Size();
    };

    /*--------------------------------------------------------------*/
    /* Continue Processing until EOF or Correct Record Type rtrvd.  */
    /* (this is reelvant only in emulation mode)                    */
    /*--------------------------------------------------------------*/
  } while(record.GDB_Record_Type NE Record_Type);

 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);

 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Convert_to_Record
 ******************************************************************
 * Description   : Convert Record_Type, Entity_Name and ADDINFO struc.
 *                 into "record" ready for VSAM processing
 *
 * Input         : Record Type  : 'G' - Groups, 'U' - Users
 *                 Key          : Entity Id
 *                 ADDINFO      : ADDINFO pairs stored in record
 *
 * Output        : "record"
 *
 * Return Value  : ESA_RC
 *
 * See Also: ADDINFO_pack_to_buffer
 ******************************************************************/
ESA_RC GDB_Convert_to_Record(char  Record_Type,
                             char  *key,
                             ADDINFO_rec_ptr addinfo)
{
 static char func[] = "GDB_Convert_to_Record";

 ESA_RC rc = ESA_OK;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);
 memset(&record,0X00,sizeof(record));

 record.GDB_Record_Type = Record_Type;
 Reset_Field(record.GDB_Record_Key,GDB_KEY_LENGTH,0X00,key);
 record.GDB_EOS = NULL_CHAR;

 rc = ADDINFO_pack_to_buffer(record.GDB_ADDINFO,
                             sizeof(record.GDB_ADDINFO),
                             addinfo,
                             &GDB_ADDINFO_Size);

 if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE DEBUG_SHOW_ALL)
  {
    SNAP_AREA("GDB Record after pack", &record,
              Round_Number(GDB_Record_Size,16) );
  };
 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);
 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Convert_from_Record
 ******************************************************************
 * Description   : Convert VSAM_retrieved record into Record_Type,
 *                 Record_Key and ADDINFO strcuture
 *
 * Input         : "record" after GDB_GetNext operation
 *
 * Output        : Record Type  : 'G' - Groups, 'U' - Users
 *                 Key          : Entity Id
 *                 ADDINFO      : ADDINFO pairs stored in record
 *
 * Return Value  : ESA_RC
 *
 * See Also: ADDINFO_expand_from_buffer
 ******************************************************************/
ESA_RC GDB_Convert_from_Record(char             *Record_Type,
                               char             *key,
                               ADDINFO_rec_ptr   addinfo)
{

  static char func[] = "GDB_Convert_from_Record";

  ESA_RC rc = ESA_OK;

 ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);

 if (ESA_DIAG_get_debug_level(PLT_COMP_API_ACF2) GE DEBUG_SHOW_ALL)
  {
    SNAP_AREA("GDB Record before expand", &record,
              Round_Number(GDB_Record_Size,16) );
  };

  (*Record_Type) = record.GDB_Record_Type;
  strcpy(key,record.GDB_Record_Key);

  rc = ADDINFO_expand_from_buffer(record.GDB_ADDINFO,
                                  GDB_ADDINFO_Size,
                                  addinfo);
 exit:;

 ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, rc);
 return rc;
}

/******************************************************************
 * Procedure Name: GDB_Calc_Record_Size
 ******************************************************************
 * Description   : Calculate entire "record" size
 *
 * Input         : "record"     : static parm
 *
 * Output        : "record" size in bytes
 *
 ******************************************************************/
static int GDB_Calc_Record_Size(void)
{
  GDB_Record_Size = sizeof(record.GDB_Record_Type) +
                    sizeof(record.GDB_Record_Key)  +
                    sizeof(record.GDB_EOS)         +
                    GDB_ADDINFO_Size;

  return(GDB_Record_Size);
}

/******************************************************************
 * Procedure Name: GDB_Calc_ADDINFO_Size
 ******************************************************************
 * Description   : Calculate ADDINFO part from entire "record"
 *
 * Input         : "record"     : static parm
 *
 * Output        : "record" size in bytes
 *
 ******************************************************************/
static int GDB_Calc_ADDINFO_Size(void)
{
  GDB_ADDINFO_Size = GDB_Record_Size               -
                     sizeof(record.GDB_Record_Type)-
                     sizeof(record.GDB_Record_Key) -
                     sizeof(record.GDB_EOS)        ;

  return(GDB_ADDINFO_Size);
}

/* * * * * * * * Start BS10093 * * * * * * * */
/******************************************************************
 * Procedure Name: GDB_Get_Mode
 ******************************************************************
 * Description   : Return GDB_Current_Mode
 *
 * Input         : none
 *
 * Output        : GDB_Current_Mode (one of these):
 *                     GDB_Closed
 *                     GDB_ReadOnly
 *                     GDB_ReadWrite
 *
 ******************************************************************/
GDB_Modes GDB_Get_Mode(void)
{
 ESA_DIAG_printf(PLT_COMP_API_ACF2, 6,
          "GDB_Current_Mode = %s", GCM2str(GDB_Current_Mode));

 return(GDB_Current_Mode);
}


/******************************************************************
 * Procedure Name: GCM2str
 ******************************************************************
 * Description   : Translate GDB_Current_Mode to String
 *
 * Input         : GDB_Current_Mode
 *
 * Output        : one of these:
 *                   GDB_Closed
 *                   GDB_ReadOnly
 *                   GDB_ReadWrite
 *
 ******************************************************************/
const char * GCM2str (GDB_Modes mode)
{
 switch(mode)
  {
   case GDB_Closed:     return("GDB_Closed");
   case GDB_ReadOnly:   return("GDB_ReadOnly");
   case GDB_ReadWrite:  return("GDB_ReadWrite");
   default:             return("* undefined *");
  }
}
/* * * * * * * * End BS10093 * * * * * * * */

/* * * * * * * * * * Start of SAS2IBMT * * * * * * * * * */
static void print_amrc() {
   __amrc_type currErr = *__amrc; /* copy contents of __amrc     */
                                  /* structure so that values do */
                                  /* not get clobbered by printf */
   char desc[25];
   global_rc = GDB_OK;            /* clear global rc field       */
   static char func[] = "print_amrc";
   ESA_DIAG_enter(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func);
   if ((currErr.__last_op == 114)              &
       (currErr.__code.__feedback.__rc == 8)   &
       (currErr.__code.__feedback.__fdbk == 4))
       {
         global_rc = GDB_EOF;
         ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR,
                       func, global_rc);
         return;
       }
   if ((currErr.__last_op == 116)              &
       (currErr.__code.__feedback.__rc == 8)   &
       (currErr.__code.__feedback.__fdbk == 16))
       {
         global_rc = GDB_Not_Found;
         ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR,
                       func, global_rc);
         return;
       }
   if ((currErr.__last_op == 116)              &          /* BS10067 */
       (currErr.__code.__feedback.__rc == 8)   &          /* BS10067 */
       (currErr.__code.__feedback.__fdbk == 4))           /* BS10067 */
       {
         global_rc = GDB_Not_Found;                       /* BS10067 */
         ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR,
                       func, global_rc);                  /* BS10067 */
         return;                                          /* BS10067 */
       }
   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, /*IS10156*/
                   "* * * VSAM Error Information * * * ");
   /* The following #defines are defined in CEE.SCEEH.H(STDIO) */
   switch(currErr.__last_op)
    {
     case __VSAM_OPEN_FAIL:
          strcpy(desc,"VSAM_OPEN_FAIL");
          break;
     case __VSAM_OPEN_KSDS:
          strcpy(desc,"VSAM_OPEN_KSDS");
          break;
     case __VSAM_OPEN_KSDS_PATH:
          strcpy(desc,"VSAM_OPEN_KSDS_PATH");
          break;
     case __VSAM_MODCB:
          strcpy(desc,"VSAM_MODCB");
          break;
     case __VSAM_TESTCB:
          strcpy(desc,"VSAM_TESTCB");
          break;
     case __VSAM_SHOWCB:
          strcpy(desc,"VSAM_SHOWCB");
          break;
     case __VSAM_GENCB:
          strcpy(desc,"VSAM_GENCB");
          break;
     case __VSAM_GET:
          strcpy(desc,"VSAM_GET");
          break;
     case __VSAM_PUT:
          strcpy(desc,"VSAM_PUT");
          break;
     case __VSAM_POINT:
          strcpy(desc,"VSAM_POINT");
          break;
     case __VSAM_ERASE:
          strcpy(desc,"VSAM_ERASE");
          break;
     case __VSAM_ENDREQ:
          strcpy(desc,"VSAM_ENDREQ");
          break;
     case __VSAM_CLOSE:
          strcpy(desc,"VSAM_CLOSE");
          break;
     default:
          strcpy(desc,"not defined");
          break;
    }
   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, /*IS10156*/
       "Last VSAM function attempted = %d = %s",
       currErr.__last_op, desc);
   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, /*IS10156*/
       "R15 value = %d   Reason code = %d",
       currErr.__code.__feedback.__rc,
       currErr.__code.__feedback.__fdbk);
   ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, /*IS10156*/
       "RPL feedback code = %02X%02X%02X%02X",
       currErr.__rplfdbwd[0],currErr.__rplfdbwd[1],
       currErr.__rplfdbwd[2],currErr.__rplfdbwd[3]);
   /* rplfdbwd is defined as 'unsigned char __rplfdbwd[4];' in     */
   /* STDIO.  It is important that it is printed as a 4-byte hex   */
   /* value in order to see all its 4 bytes: RPLSTAT, RPLRTNCD,    */
   /* RPLCMPON, and RPLERRCD.                                      */
   /* printf("RBA = %d\n", currErr.__RBA);                         */
   if ((currErr.__last_op == 115)              &
       (currErr.__code.__feedback.__rc == 8)   &
       (currErr.__code.__feedback.__fdbk == 8))
       {
         ESA_DIAG_printf(PLT_COMP_API_ACF2, DEBUG_SHOW_IMPORTANT, /*IS10156*/
             "* * Writing duplicate record not allowed * * ");
         global_rc = GDB_Duplicate_Key;
       }
   ESA_DIAG_exit(PLT_COMP_API_ACF2, DEBUG_SHOW_REGULAR, func, global_rc);
   return;
}
/* * * * * * * * * *  End  of SAS2IBMT * * * * * * * * * */
