/*
 * Version Information:
 * ====================
 * File name       : %name: acsgpf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: leonid_s %
 * Created on      : %date_created: Sun Jul 25 15:51:41 2004 %
 * Current Version : %version: 8 %
 * Last Modified by: %derived_by: leonid_s %
 * Last Modified on: %date_modified: Mon Mar 01 13:43:55 2004 %
 */
 
/***********************************************
 * Mod.ID  Who      When         Description
 * =============================================
 *         Leonid   4/4/01       Compile error in OS2
 * 1805    Leonid   12/04/01     Move SCCSID (for Unix)
 * 2511	   NMore    25/11/05	 To fix the problem of CD picking up wrong admin password.
 * 502839  AvnerL   25-Jun-2009  MF updates for 3.3.00
 * IS10072 AvnerL	09-FEB-2012  Implement AV001 made by Ajay in 3.1.11.P004 (3.3.01 RACF)
 *								 Temporary changes to avoid ABEND in CD (while RSSOFLI updation)on Mainframe (ISS03537689)
 * AV002   Ajay V   12-NOV-2013  Support any value for INTERCEPT_SEND_MAX for MF
 * IS10129 AvnerL   27-APR-2015  Handle COMM_END & INTERCEPT_SEND_MAX is used - CAR00050858
 * SAS2IBMT SeligT  30/06/2016   SAS/C to IBM C Conversion Project
 * SAS2IBMN NuritY  01/01/2017   SAS/C to IBM C Conversion:
 *                               Remove signal processing because it
 *                               depends on the HANDLE_ABENDS RSSPARM
 *                               ALL_RSS parameter which is always N.
 *                               If/when recovery is needed, the
 *                               appropriate recovery services will have
 *                               to be used.
 * AC001   ArunC    12/04/2017   CIQ#6-MF acct aggr with conns
 * BS10057 NuritY   02/07/2017   CIQ#6-MF reset envir_ptr->iiq_version
 *                               when IIQ that does not pass its version
 * BS10076 SeligT   11/12/2017   Organize Connector Locking Functions
 *                               and Structures
 * WS10070 KailasP  16/04/18     Compile only due to change in SA_AGENT_VERSION.
 * BS10100 KailasP  09/04/19     Read Application Administrator
 *                               information received in RS
 * BS10102 KailasP  29/07/19     Get tran credentials from admin_params
 *WS10078KG KailasP 23/04/20     Add type for ROLE and XSGP
 *WS10078KM KailasP 15/06/20     Display error for message overflow
 * WS10079K KailasP 31/12/20     Compile only due to change in
 *                               SA_AGENT_VERSION.
 * WS10080  KailasP 31/05/21     Support MSGSIZE Greater than 32K
 * IS10184  NuritY  20/08/21     Improve Scripts Performance
 *                               (compile only to fix long/short names.)
 * BS10127  KailasP 05/12/2023   Memory overlay in aggregation while
 *                               ading more than 4095 entities.
 * WS10082A AvnerL  20/12/22     Addinfo new approach
 **********************************************/
 
#include "globs.h"
 
#include ERRNO
#include ESA_MSG
#include ESA_CHKSUM
#include ESA_CAREUSR
#include ESA_CS_DBPKG
#include ESA_CS_SINFO
#include ESA_CS_OS
#include ESA_OS_MBX
#include ESA_OS_EVENT
#include ESA_RSS
#include ESA_RSSF
#include ESA_PROC
#include ENC_API
#include ESA_OS_PROC
#include ESA_ADMIN
#include CTYPE
#include ESA_ESAADI
 
 
/* This is a Special string in ERROR message 'EE' to miss to ESS
   that RSS for the last service is DOWN */
#define ESA_RSS_INACTIVE_MSG "!!!RSS IS INACTIVE!!!"
#define INTERCEPT_SEND_DELAY "INTERCEPT_SEND_DELAY"
#define INTERCEPT_SEND_MAX   "INTERCEPT_SEND_MAX"
static long NumIntrcptMsgInEss;
static int  InterceptMax;
static int  InterceptDelay;
static long BK_msg_seq;
static short send_mh_message_last_tmp = FALSE; /*WS10080*/
 
static ESA_RC CS_shutdown_event (void);
static ESA_RC CS_os_event (void);
 
static ESA_RC CS_brdcst_msg (void          * msg_ptr,
                             int             message_size,
                             ESA_EVENT_typ   in_event );
 
static void CS_ess_rss_name_type (RSS_typ rss,
                                  RSS_typ rss_typ,
                                  RSS_typ ess_rss,
                                  RSS_typ ess_rss_typ);
 
static ESA_RC GetAgentPwdChksum (char    * agent_pwd_chksum);
 
static void CD_interception_control (ESA_RC Read_RC);
 
/****************************************************
 * Procedure Name: CS_message_loop
 * Description   : program main loop
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *  Detailed Description:
 *  =====================
 *
 *  This function is CS/CD main loop over received messages
 *  from mailbox (i.e from the CO) and from queue (CD only).
 *  The current function does not read ALL messages - it merely
 *  reads "START OF SERVICE" messages - and ALL the rest of messages
 *  that belongs to that specific service will be read in the
 *  function that takes care of that service.
 *  The function returns to the main program (in order to terminate
 *  the process) on the following events:
 *  - A process termination request arrived from CO.
 *  - A FATAL error returned from CTSA (NOT API!!!) internal function.
 *
 *  The function endless (well, almost endless) loop is:
 *    - Read next message (mailbox or queue).
 *    - For message that is not START OF SERVICE (tested according
 *      it's sequence number equal to "000001" - ignore it!
 *    - For START SERVICE MESSAGES:
 *      - Analyse the start service message and save the service
 *        details in the envir_ptr->
 *      - Activate the "start_service" function taht wil handle the
 *        WHOLE service.
 *      - Send "server is ready" message to CO.
 *
 *    - Continue loop.
 *
 *********************************************************************/
 
ESA_RC CS_message_loop (void)
{
  char fn[]="CS_message_loop";
  ESA_RC                 rc= ESA_OK;
  MSG_typ              * read_msg_ptr;
  MSG_typ              * msg_ptr;
  MSG_typ              * srv_ptr = NULL;   /* AJK001 */
  RSS_MSG_HDR_rec_typ    msg_hdr;
  ADMIN_PARAMS_rec_typ   admin_params;
  HOT_PATH_typ           hot_path= HOT_PATH_ON;
  TRAN_rec_typ           tran;
  NUM_MSGS_typ           num_msgs;
  NUM_MSGS_typ           msg_len;
  char                 * msg = NULL;      /* AJK002 */
  int                    admin_params_set = 0;
  char                   str[STRUCT_LEN+ 1];
/* for MVS */
  char                  buffer [20];
 /* MVS */
  time_t                CurrentTime= 0, StartTime= 0;
  TIME_typ              OfliWaitInterval;
  long int              OfliWaitTime;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  HotPathStr[15];
  #define MAX_AGENT_PASSWORD_LEN MAX_RSS_PASSWD_LEN
                                           /* used to be 64 SAS2IBMT */
  int                   correct_pwd = TRUE;
  char                * pwd_ptr;
  char                  platform_pwd[MAX_AGENT_PASSWORD_LEN+1];
  CHECKSUM_typ          platform_pwd_chksum;
  char                  agent_pwd_chksum[CHECKSUM_LEN+1];
  unsigned long int     max_nmb ;
  void                * handle_for_evnt= NULL;
  char                * pe2_ver;     /* AC001 - CIQ#6 */
  char                  iiq_ver[2];  /* AC001 - CIQ#6 */
  int                   orig_max_msg_size=0; /*WS10080*/
  /* BS10100 - Starts */
  EXTENDED_PARAMS_rec_typ   extended_params;
  MSG_typ                 * extended_msg_ptr;
  char                      allow_prot=NULL_CHAR;
  /* BS10100 - Ends */
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
 
  StartTime= time(NULL);
  rc= rssprm_get_opt ((char *)ALL_RSS,
		              OFLI_WAIT_INTERVAL,
         			  TIME_LEN, OfliWaitInterval,
		    		  OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
     strcpy (OfliWaitInterval, DEF_OFLI_WAIT_INTERVAL);
  rc= ESA_OK;
  TrnsfIntervalToNumber ((char *)OfliWaitInterval, &OfliWaitTime);
 
/*
   SAVE all handles that were initiated in the ADMIN params structure
   of the envir - in the temporary admin params !!
*/
 
  envir_ptr->msg_admin_param.cs_func.LOG_event_ptr= &LOG_event;
  memcpy ((char *)&admin_params,
          (char *)&envir_ptr->msg_admin_param,
          sizeof (ADMIN_PARAMS_rec_typ));
 
  CLEAR_STRUCT (msg_hdr);
 
  /* The CS_init function set the envir_ptr->msg_size,
     in order to allocate
     a message memory segment according to the following formula:
     envir_ptr->msg_size=
          max (max( max_msg_size, msg_size_i), max_msg_size_o);
  max_msg_size from CTSPARM file.
  msg_size_i from ESA_MBX_act_msg_size (envir_ptr->channel_i,
                                        &msg_size_i);
  msg_size_o from ESA_MBX_act_msg_size (envir_ptr->channel_o,
                                        &msg_size_o);
   */
 
  /*
     ALLOCATE buffer to receive all mailbox/queue
     messages according to
     the platform's maximum mailbox message size.
  */
 
  /*WS10080 Start: Use max_msg_size while allocating memory*/
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 9,
              "orig_max_msg_size and max_msg_size initialized to %d",
              (int)envir_ptr->max_msg_size);
 
  /*rc= CSA_alloc ((char **)&msg, 0, (unsigned)envir_ptr->msg_size,*/
  rc= CSA_alloc ((char **)&msg, 0, (unsigned)envir_ptr->max_msg_size,
                   1, fn, "Msg. space");
  orig_max_msg_size = (int)envir_ptr->max_msg_size;
  /*WS10080 End*/
 
  envir_ptr->msg_size= 0;
  if (rc NE ESA_OK)
    goto cleanup;
 
  read_msg_ptr= (MSG_typ *)msg;
 
/* for MVS */
  /* send CS_is_ready message to the MF CO */
  strcpy(buffer, CD_SRVR_IS_READY);
  rc = CS_send_msg(buffer,strlen(buffer));
  if (rc NE ESA_OK) {
    CTSAMSG_print (ERR_CS_MBX_WRITE ,
                   envir_ptr->msg_admin_param.ctsamsg_handle,
                   NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest ,
                   fn , ESA_rc2str(rc));
 
    /* There is nothing to do if the control message can't be sent */
 
    goto cleanup;
  }
 /* MVS */
 
/*
  ACTIVATE read loop for "START SERVICE" messages. Exit only in case
  of CTSA FATAL error in message handling or when PROCESS TERMINATION
  request is read from mailbox.
*/
 while ( (rc NE ESA_FATAL)
        AND
         (rc NE ESA_TERM_CTSA)
        AND
         (rc NE ESA_FATAL_IO) ) {
   /*
     INITIALIZE service reply "sequence number".
   */
    BK_msg_seq= 1;
 
    /*
      ACTIVATE scheduler for time-dependent activities (such as
      offline interceptor activation).
    */
 
    CurrentTime= time(NULL);
	if (CurrentTime LE StartTime+ OfliWaitTime)
       rc = CS_scheduler (FALSE);
	else
       rc = CS_scheduler (TRUE);
    if (rc EQ ESA_TERM_CTSA)
		continue;
    /*
      CLEAR read buffer and error buffer.
    */
 
    memset((char *)read_msg_ptr, '\0', envir_ptr->max_msg_size);
    ERROR_CLEAR (&envir_ptr->msg_err);
 
    /*
      ENABLE next read request (on CD) to read from queue. This
      equation states that if the CD HAS terminate it's initialization
      - it may read from queue
    */
 
    envir_ptr->read_alternatives = PROC_MAY_READ_QUE;
    /*
      READ next message from mailbox or queue return the adders to
      the GENERAL MESSAGE HEADER.
    */
    rc = CS_get_next_msg (read_msg_ptr , & msg_hdr);
    /*
      PROCESS when termination is required:
    */
    if (
        (rc EQ ESA_FATAL) OR
        (rc EQ ESA_FATAL_IO) OR
        (rc EQ ESA_TERM_CTSA)
       )
      continue ; /* Continue - and exit while loop !!! */
    /*
      PROCESS when "cancel current service" (equal to linkdown in
      MVS):
    */
 
    if (rc EQ ESA_CANCEL_SERVICE) {
      /*
        MARK need for HANDSHAKE (CD only).
      */
      envir_ptr->initial_service = BLANK;
      /*
        SEND "ready to next service" control message to CO.
      */
      CS_send_end_of_srv_instance();
    }
    /*
      PROCESS the message when the read succeeded AND the message
      has sequence number "1" (thus assumed to be "START SERVICE"
      message) :
    */
 
    if (
        (rc EQ ESA_OK)
       AND
        (memcmp((char *)(&msg_hdr.mhseq) ,MH_FIRST_MSG,
                sizeof(MH_seq)) EQ 0))
    {
 
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,"*****>...");
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,"************************************>");
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,"*****>...   Starting NEW transaction");
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,"************************************>");
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,"*****>...");
 
       /* BS10100 - Initialise correct_pwd for every transaction */
       correct_pwd = TRUE;                            /* BS10100 */
       ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
         "BK_msg_seq %d envir_ptr->msg_size %d."
           ,(int)BK_msg_seq, (int)envir_ptr->msg_size);
      /*
        SET message pointer right after the message's GENERAL HEADER.
      */
      msg_ptr = CS_get_aplic_msg(read_msg_ptr);
      /*
        ANALYZE the RSS HEADER (number of messages) and set
        message pointer beyond it.
      */
      ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
          "Before CS_get_rss_msg BK_msg_seq %d."
          ,(int)BK_msg_seq);
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr NE NULL)
      {
         ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
             "Before CS_get_single_msg BK_msg_seq %d."
             ,(int)BK_msg_seq);
 
         /*
           ANALYZE the RSS MESSAGE HEADER and set the message pointer
           beyond it.
         */
         msg_ptr= CS_get_singl_msg(&msg_len, &tran, msg_ptr);
      }
      if (msg_ptr NE NULL)
      {
         ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
             "Before CS_get_admin_patrams BK_msg_seq %d."
             ,(int)BK_msg_seq);
 
        /*
          ANALYZE the "START SERVICE" message and save the service
          details in the envir_ptr->
        */
        srv_ptr= CS_get_admin_params (&admin_params, &hot_path, msg_ptr);
	    if ((int)hot_path EQ HOT_PATH_ON)
		   strcpy (HotPathStr, "HOT_PATH_ON");
	    else if ((int)hot_path EQ HOT_PATH_OFF)
		   strcpy (HotPathStr, "HOT_PATH_OFF");
	    else if ((int)hot_path EQ HOT_PATH_FULL)
		   strcpy (HotPathStr, "HOT_PATH_FULL");
	    else
		   strcpy (HotPathStr, "HOT_PATH_UNDEFINED");
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
           "*****>... Transaction is for RSS=%s TYPE=%s ADMIN: User=%s DEF ADMIN=%s Group=%s %s=%d.",
           admin_params.rss_name, admin_params.rss_type, admin_params.admin_uname,admin_params.def_admin,
		   admin_params.admin_gname, HotPathStr, (int)hot_path);
 
        if (NOT(admin_params_set))
        {
           envir_ptr->hot_path = hot_path;
           memcpy ((char *)&envir_ptr->msg_admin_param,
                   (char *)&admin_params,
                   sizeof (ADMIN_PARAMS_rec_typ));
           admin_params_set = 1;
        }
      }
 
      ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
         "read_ptr=%p srv_ptr=%p msg_ptr=%p mhsid=%c add_val_len=%d.",
          read_msg_ptr, srv_ptr, msg_ptr, msg_hdr.mhsid,
          envir_ptr->addinfo_val_len);
      if (
              (srv_ptr NE NULL)
             AND
              (msg_ptr NE NULL)
             AND
			  (
			     (envir_ptr->p_main_name EQ ESA_ACS_PROC)
                OR
                 (envir_ptr->addinfo_val_len EQ 0)
              )
         )
      {
         ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                  "comp_size=%d msg_size=%d.",
                   srv_ptr- read_msg_ptr+ 2, envir_ptr->msg_size);
         if (envir_ptr->msg_size GT srv_ptr- read_msg_ptr+ 2)
         {
            memset (str, NULL_CHAR, sizeof(str));
            memcpy (str, (char *)srv_ptr, STRUCT_LEN);
            ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
	              "msg_ptr=%p str=%s max_numb=%d kwd=%s.",
	               msg_ptr,   str,   4096, "ADINF_VAL_LEN");
            rc= CS_check_nmb (str, srv_ptr, 4096, "ADINF_VAL_LEN");
            if (rc NE ESA_OK)
               msg_ptr= NULL;
            else
            {
               sscanf (str, "%x", &envir_ptr->addinfo_val_len);
               msg_ptr += STRUCT_LEN;
               ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                  "str=%s add_val_len=%d.",
                   str, envir_ptr->addinfo_val_len);
            }
         }
         else
            envir_ptr->addinfo_val_len= ADINF_VAL_LEN_S;
      }
      ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
         "add_val_len=%d.", envir_ptr->addinfo_val_len);
 
      if (msg_hdr.mhsid EQ ESS_INITIAL_SERVICE) {   /* handshake */
       correct_pwd = TRUE;
       max_nmb = MAX_AGENT_PASSWORD_LEN;
       pwd_ptr = srv_ptr + STRUCT_LEN;
       pwd_ptr = CS_get_fld(platform_pwd, pwd_ptr,
                            max_nmb, "Agent password");
 
	   if ((strlen(envir_ptr->file_agentpwd) NE 0) OR
			(strlen(platform_pwd) NE 0)){
         correct_pwd = FALSE;
         ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
		  "*****>... Agent Password file=%s IIQ/IDN Password len=%d.",
		  envir_ptr->file_agentpwd, strlen(platform_pwd));
 
         ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
         "start handshake. received password:<%s>(%d)\n",
         platform_pwd, strlen(platform_pwd));
 
         if (pwd_ptr NE NULL AND strlen(platform_pwd) NE 0
			 AND strlen(envir_ptr->file_agentpwd) NE 0) {
            ChkSum(platform_pwd,
                   strlen(platform_pwd),
                   platform_pwd_chksum);
 
            ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
            "Platform password checksum:%.*s.\n",
            CHECKSUM_LEN,&platform_pwd_chksum);
 
            rc = GetAgentPwdChksum(agent_pwd_chksum);
 
            ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
            "Agent password checksum:%s.\n",
            agent_pwd_chksum);
 
            if ( (rc EQ ESA_OK)  AND
                 (strncmp((char *)agent_pwd_chksum,
                          (char *)platform_pwd_chksum,
                          CHECKSUM_LEN) EQ 0) )
               correct_pwd = TRUE;
 
            ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
            "after comparison of checksums. correct_pwd:%d\n",
            correct_pwd);
 
         }
       }
      }
      /* AC001 - CIQ#6 - Start */
      envir_ptr->iiq_version = 0;   /* initialize version   BS10057 */
      if (srv_ptr NE NULL) {
        pe2_ver = strstr(srv_ptr, PE2_VERSION);
        if (pe2_ver NE NULL) {
          memset(iiq_ver, '\0', sizeof(iiq_ver));
          memcpy (iiq_ver, pe2_ver + sizeof(PE2_VERSION)-1, 2);
          envir_ptr->iiq_version = atoi(iiq_ver);
        }
      }
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
            "IdentityIQ Version =%d.", envir_ptr->iiq_version);
      /* AC001 - CIQ#6 - End */
 
      /* BS10100 - Start: Do not check extended message if there  *
       *                  are errors before. srv_ptr is null if   *
       *                  there are errors in CS_get_admin_params */
      if( ( msg_ptr NE NULL )
                AND
          ( srv_ptr NE NULL )
                AND
          ( rc EQ ESA_OK) )
      {
         extended_msg_ptr = strstr (msg_ptr, START_EXTENDED_MSG);
         if(extended_msg_ptr NE NULL )
         {
            if( *(extended_msg_ptr + strlen(START_EXTENDED_MSG) )
                       NE NULL_CHAR                               )
            {
               extended_msg_ptr+=strlen(START_EXTENDED_MSG);
 
               rc = CS_get_extended_params(&extended_params,
                                           &admin_params,
                                           extended_msg_ptr,
                                           &msg_hdr);
            }
            else
            {
               ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC + 13 ,
                   "CS_get_extended_params is not called. Error while parsing data");
 
               rc = ESA_FATAL;
            }
 
            if (rc NE ESA_OK)
            {
               /* Print the internal error only if the failure is *
                * other than login else do not print the error    */
               if (rc EQ ESA_UNKNWNERR)
               {
                  CTSAMSG_print(ERR_INTERNAL2,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest, NULL,
                       fn, "error reading extended params", rc,
                       __LINE__);
               }
               ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC + 13,
                      "Setting correct password is false");
 
               correct_pwd = FALSE;
            }
         }
         else
         {
            /* We do not want to allow old version of PE2 if the  *
             * parameter ALLOW_ADMIN_WITHOUT_PSWD is N            */
            rc = Init_Allowed_Admins(&allow_prot,
                                     NULL,
                                     NULL,
                                     ESA_COMP_ACSGPF,
                                     &admin_params);
 
            ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_BASIC,
 /*BS10102*/ "Init_Allowed_Admins returned %s : %c rc = %s ",
 /*BS10102*/ "ALLOW_ADMIN_WITHOUT_PSWD",allow_prot,ESA_rc2str(rc));
 /*BS10102                   "Init_Allowed_Admins returned %s : rc = %s   %c ",
                              "ALLOW_ADMIN_WITHOUT_PSWD",
                              ESA_rc2str(rc), allow_prot); ****/
 
            /* Dont throw error if RS is from interceptor */
            if ( ( (rc EQ ESA_KEY_NOT_FOUND)  OR
                   (rc EQ ESA_OK  AND  allow_prot EQ 'N') )
                                AND
                 (msg_hdr.mhsid NE UPDATE_ESS_SERVICE )        )
            {
               correct_pwd = FALSE;
               rc = ESA_ERR;
               CTSAMSG_print (ERR_PE2_VERSION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest);
            }
         }
      }
      /* BS10100 - Ends */
 
      if (srv_ptr NE NULL AND msg_ptr NE NULL AND
          correct_pwd EQ TRUE) {
        /* WS10080 Start */
        /* The interception messages received does not contain PE2   *
         * version and hence the PE2 version for interceptors is     *
         * set to 0. The PE2 version is received when there is start *
         * interception handshake. The same version is saved in      *
         * envir_ptr->iiq_ver_interceptor during start interceptor   *
         * handshake. This variable is set to iiq_version if the     *
         * transaction is received for CD process (ESA_ACD_PROC)     */
 
        if((envir_ptr->p_main_name  EQ ESA_ACD_PROC) AND
           ((int)envir_ptr->iiq_ver_interceptor NE 0) AND
           ((int)envir_ptr->iiq_version EQ 0)              )
           {
               envir_ptr->iiq_version =
                                 (int)envir_ptr->iiq_ver_interceptor;
           }
 
        ESA_DIAG_printf (ESA_COMP_ACSGPF, 6,
                  "max_msg_size<%d>,one_msg_size<%d>,iiq_version<%d>",
                         (int)envir_ptr->max_msg_size,
                         (int)envir_ptr->one_msg_size,
                         (int)envir_ptr->iiq_version);
 
          /*   We are good to start processing transaction.   *
           *   PE2 sets add info value length by checking     *
           *   the Agent version. It is required to perform   *
           *   test connection tranasction after upgrading    *
           *   agent. This will ensure that PE2 is updated    *
           *   with Agent version.                            *
           *   The value of MAX_MSG_SIZE and ONE_MSG_SIZE     *
           *   are set as per below conditions:               *
           *   1. Irrespective of PE2 version if MAX_MSG_SIZE *
           *      is set in CTSPSRV and is less than 32,723;  *
           *      then it is not required to divide a message *
           *      into sub message. We continue with the      *
           *      transaction without modifying parameters.   *
           *   2. If MAX_MSG_SIZE is more than 32,723 and     *
           *      iiq_version is 04 or above then we do not   *
           *      change MAX_MSG_SIZE. Check if ONE_MSG_SIZE  *
           *      is defined, if not set the value to 32723.  *
           *   3. If MAX_MSG_SIZE is more than 32,723 and     *
           *      iiq_version is less than 04 (old iiq) then  *
           *      set MAX_MSG_SIZE to 32,723. There is no     *
           *      need to divide a message into sub-messages. */
 
        /* IIQ_VER_MSGSIZE_SUPPORT = 04 */
        if((int)envir_ptr->iiq_version LT IIQ_VER_MSGSIZE_SUPPORT)
        {
          /*Since PE2 is old ensure MAX_MSG_SIZE is less than 32,723.*/
          if((int)envir_ptr->max_msg_size GT 32723)
          {
             envir_ptr->max_msg_size = 32723;
             /*Reallocate msg*/
             rc = CSA_realloc((char **)&msg, 0,
                              (unsigned)envir_ptr->max_msg_size,1);
             if(rc NE ESA_OK)
                goto cleanup;
 
             read_msg_ptr= (MSG_typ *)msg;
             envir_ptr->one_msg_size = 0;
             ESA_DIAG_printf (ESA_COMP_ACSGPF,6,
                       "Old PE2 msg buffer reallocated with size <%d>",
                       (int)envir_ptr->max_msg_size);
          }
          /*No change if max_msg_size is less than 32723 for old PE2*/
        }
        else
        {
           /* Its new PE2. Let's check if the max_message_size was   *
            * changed while processing prev transaction from old IIQ.*/
           if(orig_max_msg_size GT (int)envir_ptr->max_msg_size )
           {
             envir_ptr->max_msg_size = orig_max_msg_size;
             /*Reallocate msg*/
             rc = CSA_realloc((char **)&msg, 0,
                              (unsigned)envir_ptr->max_msg_size,1);
             if(rc NE ESA_OK)
                goto cleanup;
 
             read_msg_ptr= (MSG_typ *)msg;
 
             ESA_DIAG_printf (ESA_COMP_ACSGPF ,6,
                       "New PE2 msg buffer reallocated with size <%d>",
                       (int)envir_ptr->max_msg_size);
           }
 
           /* ONE_MSG_SIZE can not be greater than  *
            * 32723 or less than 4K - 4096          */
           if( ((int)envir_ptr->one_msg_size GT 32723) OR
               ((int)envir_ptr->one_msg_size LT 4096)    )
           {
              envir_ptr->one_msg_size = 32723;
           }
           /* one_msg_size can not be greater than max_msg_size */
           if((int)envir_ptr->one_msg_size GT
                    (int)envir_ptr->max_msg_size)
           {
              envir_ptr->one_msg_size =
                     (int)envir_ptr->max_msg_size;
           }
        }
        ESA_DIAG_printf (ESA_COMP_ACSGPF, 6,
              "orig_max_msg_size %d, max_msg_size %d, one_msg_size %d",
               orig_max_msg_size, (int)envir_ptr->max_msg_size,
               (int)envir_ptr->one_msg_size);
 
        /* WS10080 End */
        /*
          HANDLE the service.
        */
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
          "Before CS_start_service BK_msg_seq %d addinfo_val_len=%d.",
          (int)BK_msg_seq, (int)envir_ptr->addinfo_val_len);
 
        rc = CS_start_service (&admin_params,
                               hot_path,
                               read_msg_ptr,
                               &msg_hdr);
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,"*****>...");
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,"******************************>");
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,"*****>...   End of Transaction ");
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,"******************************>");
        ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,"*****>...");
        /*
         TERMINATE loop if process termination was requested (returned
          from service in read/write mailbox messages).
        */
        if ( (rc EQ ESA_TERM_CTSA) OR (rc EQ ESA_FATAL_IO) )
          continue;
 
        if (rc EQ ESA_CANCEL_SERVICE)
          /*
            MARK need for HANDSHAKE in case of linkdown
          */
          envir_ptr->initial_service = BLANK;
 
        if (rc NE ESA_OK)
          /*
            In this case the CS_drop_all was already activated
            on start_service so we want to avoid reactivating it.
            */
          rc = ESA_OK;
 
        if (msg_hdr.mhsid NE UPDATE_ESS_SERVICE)
          /*
            TERMINATE SERVICE by sending "end of service" (FC) message
            to CO.
          */
          CS_send_end_of_srv_instance();
 
      } /* END - srv_ptr is not null & msg_ptr is not null */
     else
      /*
        DROP all current service messages from mailbox - in case
        the message analysis went wrong and the required service was
        not "UPDATE" (i.e not a queue message).
      */
      if (msg_hdr.mhsid NE UPDATE_ESS_SERVICE) {
        if ((strlen(envir_ptr->file_agentpwd) NE 0 OR
			strlen(platform_pwd) NE 0) AND correct_pwd EQ FALSE)
			{
			CTSAMSG_print (ERR_PASS_AUTH_FAILED,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
			CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       ERR_PASS_AUTH_FAILED);
			}
		  rc = CS_drop_all (read_msg_ptr, ESA_OK);
        CS_send_end_of_srv_instance();
      }
 
    } /* END - Read msg OK and FIRST message */
    else
 
      /*
        DROP ALL current service messages -  if unexpected failure
        returned from read.
      */
      if (
          (rc NE ESA_OK) AND
          (rc NE ESA_EOF) AND
          (rc NE ESA_CANCEL_SERVICE)) {
        rc = CS_drop_all (read_msg_ptr, ESA_OK);
        if (msg_hdr.mhsid NE UPDATE_ESS_SERVICE)
          CS_send_end_of_srv_instance();
      } /* END - read fail with unexpected ret code */
      else
        if (rc EQ ESA_OK)
          /*
            PRINT error if Message is out of sequence.
          */
          CTSAMSG_print (ERR_CS_NOT_START_SRVC ,
                   envir_ptr->msg_admin_param.ctsamsg_handle,
                   NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest ,
                   fn , read_msg_ptr);
 
 } /* WHILE not FATAL/FATAL_IO or TERM_CTSA */
 
cleanup:
 
  /*
    FREE message buffer.
  */
  CSA_free ((char **)&msg);
 
  ESA_DIAG_exitEx (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, rc, 0, __LINE__, __FILE__);
  return (rc);
 
} /* END of CS_message_loop function */
 
/****************************************************
 * Procedure Name: CS_start_service
 * Description   : start service
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * The START SERVICE function is activated right after reading
 * a start service message from mailbox or from queue. It first
 * loads a new diag level file - it it was updated since last service
 * and than checks if the new service's RSS is not the same RSS as the
 * previouse service (from GENERAL HEADER). If the RSS was changed the
 * following activities are performed:
 * - The aAPITERM functionj is activated to terminate the usage of
 *   previous RSS API.
 * - The new RSS API is attached.
 * - The new RSS API is initialized.
 * - The new RSS validity (existance in interesting keywords file) is
 *   checked.
 * - The new RSS online semaphor & sync semaphor parameters are loaded.
 *
 * For both same and new RSS - the rss status is checked to be active
 * and the service is activated.
 * PLEASE NOTE THAT service activation uses the "acsrvc" function. This
 * function, is developed in acsrvcs.c for CS & acsrvcd.c for CD , that
 * are linked with the CS/CD porocess !!!
 *********************************************************************/
 
ESA_RC CS_start_service (ADMIN_PARAMS_rec_typ * admin_params,
                         HOT_PATH_typ           hot_path,
                         MSG_typ              * msg_ptr_read,
                         RSS_MSG_HDR_rec_typ  * msg_hdr)
{
  char                       fn[]="CS_start_service";
  RSS_MSG_HDR_rec_typ        msg_hdr_cd;
  ESA_RC                     rc;
  int                        ii=0;
  ENVIRONMENT_rec_typ      * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  /*--- Memory diagnostics treatment (start service = ESA_OK) ---*/
  ESA_DIAG_memory_status (envir_ptr->diag_handle, fn, ESA_OK);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  CSA_print_alloc_tbl (ESA_COMP_ACSGPF, fn, TRUE);
  CSA_print_lock_tbl ();
  ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
      "BK_msg_seq %d." ,(int)BK_msg_seq);
  memcpy ((char *)(&msg_hdr_cd),(char *)msg_hdr,
          sizeof(RSS_MSG_HDR_rec_typ));
  /*
    SET not last message in reply - just to make sure.
  */
  CS_set_not_last_msg ((MSG_typ *)&msg_hdr_cd);
 
  /*
    CHECK whether DIAG levels file , Keywords file OR interesting
    users, group, coonections files were modified since last call
  */
  rc= CS_os_event ();
  if (rc NE ESA_OK)
     goto cleanup;
    /*
      VERIFY that the new RSS is valid (exists in envir array of known
      RSSs)
    */
  /*
    PROCESS when rss changed:
  */
 
 ESA_DIAG_printf (ESA_COMP_ACSGPFM, 6,
      "Before- admin_params RSS name:%s admin_params admin name-uname:%s,admin_gname:%s,def_admin:%s, envir_ptr->interest[envir_ptr->rss_num].rss:%s",
                      admin_params->rss_name,
                      admin_params->admin_uname,
                      admin_params->admin_gname,
                      admin_params->def_admin,
                      envir_ptr->interest[envir_ptr->rss_num].rss);
 
 
 
  if (
        (My_stricmp (envir_ptr->interest[envir_ptr->rss_num].rss,
                admin_params->rss_name) NE 0)
       AND
        (msg_hdr->mhsid NE ESS_INITIAL_SERVICE)
       AND
        (msg_hdr->mhsid NE KEYWORDS_SERVICE)
     )
  {
 
     for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
     {
        if (My_stricmp (envir_ptr->interest[ii].rss,
                    admin_params->rss_name) EQ 0)
           break;
 
     } /* END - FOR loop */
 
    /*
      PROCESS when new RSS is invalid:
    */
 
     if (ii GE envir_ptr->max_rss_num)
     {
      /*
        SET FATAL return code - so the PROCESS will exit! - and exit
        function.
      */
        CTSAMSG_print (ERR_CS_RSS_INVALID_NAME,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn,
                     admin_params->rss_name,
                     envir_ptr->file_rssparm);
        rc= ESA_FATAL;
        goto cleanup;
     }
 
     ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
      "RSS name has changed from RSS name:%s to RSS name:%s",
                     envir_ptr->interest[envir_ptr->rss_num].rss,
                     admin_params->rss_name);
 
    /*
        PROCESS when RSS type was altered (in addition to RSS name):
    */
 
    if (My_stricmp(envir_ptr->interest[envir_ptr->rss_num].rss_type ,
               admin_params->rss_type) NE 0)
    {
 
    /*
      TERMINATE usage of previous RSS type
    */
 
      rc= CS_attach_rss (admin_params,
                         hot_path,
                         admin_params->rss_name,
                         admin_params->rss_type);
 
 
      if (rc NE ESA_OK)
         goto cleanup;
 
    } /* END - RSS TYPE was changed */
 
    envir_ptr->rss_num= ii;
 
    if (My_stricmp (envir_ptr->msg_admin_param.rss_name,
                admin_params->rss_name) NE 0)
    {
       strcpy (envir_ptr->msg_admin_param.rss_name,
                       admin_params->rss_name);
       strcpy (envir_ptr->msg_admin_param.admin_uname,
                       admin_params->admin_uname);
       strcpy (envir_ptr->msg_admin_param.admin_gname,
                       admin_params->admin_gname);
       /*WS10082A RSSADM file is not used in MF
       rc= ADM_fill_admin_changes (OPT_TRUE,
                                   OPT_TRUE);
       if (rc NE ESA_OK)
          goto cleanup;
    end of WS10082A **********/
    }
  } /* END - RSS was changed */
 
  strcpy (envir_ptr->msg_admin_param.admin_gname,
          admin_params->admin_gname);
 
/* Nitin Fix for Oracle agent case where Admin and PWD are sent wrongly
   [14/11/2005]
   Not only check user name but password as well*/
/*  if (
       (
            strcmp(envir_ptr->msg_admin_param.admin_passwd,
                      admin_params->admin_passwd) NE 0
       )
       OR
       (
            strcmp (envir_ptr->msg_admin_param.admin_uname,
                   admin_params->admin_uname) NE 0
       )
 
     )*/
/*original   if (strcmp (envir_ptr->msg_admin_param.admin_uname,
                      admin_params->admin_uname) NE 0)
  {*/
 
/*
*/
     ESA_DIAG_printf (ESA_COMP_ACSGPFM, 6,
      "RSS name:%s default admin name-uname:%s",
                      admin_params->rss_name,
                      admin_params->admin_uname);
 
 
     strcpy (envir_ptr->msg_admin_param.admin_uname,
                     admin_params->admin_uname);
 
     strcpy (envir_ptr->msg_admin_param.admin_passwd,    /* BS10100 */
                     admin_params->admin_passwd);        /* BS10100 */
 
/*WS10082A RSSADM file is not used in MF
if (admin_params->rss_name)
{
   if( strlen(admin_params->rss_name) > 0 )
    {
     rc= ADM_fill_admin_changes (OPT_TRUE,
                                 OPT_TRUE);
 
     if (rc NE ESA_OK)
        goto cleanup;
    }
 }
end of WS10082A *****/
/*  }
 
      OK - We repeat the copy if the CS_attach_rss was called - but
     we sure have to do that for all other cases where it was not !
  */
 
  envir_ptr->hot_path = hot_path;
 
  /*
    ACTIVATE the service
  */
 
  CS_DIAG_ADMINPRM (ESA_COMP_ACSGPFM, DIAG_DETAILES, TRUE);
  rc= acsrvc (msg_hdr, msg_ptr_read, &msg_hdr_cd);
  cleanup:
 
  /*
    PROCESS when an error occured while activating the service
    (excludes errors that cause process termination):
  */
  if (
        (msg_hdr->mhsid NE UPDATE_ESS_SERVICE)
       AND
        (
           (
              (rc NE ESA_OK)
             AND
              (rc NE ESA_TERM_CTSA)
             AND
              (rc NE ESA_CANCEL_SERVICE)
             AND
              (rc NE ESA_FATAL_IO)
           )
          OR
              (envir_ptr->interest[envir_ptr->rss_num].rss_status
                        EQ RSS_DOWN)
        )
       )
    /*
      READ and drop all messages from mailbox - until
      Last/Termporary_Last  message is received - send error message.
    */
    rc = CS_drop_all (msg_ptr_read,
            (envir_ptr->interest[envir_ptr->rss_num].rss_status
              EQ RSS_DOWN) ?
                   ESA_RSS_INACTIVE
                     :
                   ESA_OK);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPFM, 13,
      "BK_msg_seq %d." ,(int)BK_msg_seq);
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_start_service function */
 
/****************************************************
 * Procedure Name: CS_get_next_msg
 * Description   : get the next service message from
 *                 mail box
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :ver 2.0.1.1
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the sole function that actually reads messages
 * from either mailbox or queue. The function first tries to read the
 * next message from the mailbox with either wait or no wait indicator.
 * The wait indicator will cause the read request to wait UNTIL THERE IS
 * A MESSAGE TO READ, and the nowait indicates that the function should
 * return with special returned code if the mailbox is empty. the wait
 * indicator is set according to the following:
 * - CS process must ALWAYS wait on the mailbox - as it never reads
 *   messages from queue.
 * - CD process will NOT wait for mailbox message if the
 *   INIT_SERVICE_SENDED flag, indicating that the process received and
 *   terminate the process of HANDSHAKE service, is SET; and ith the
 *   PROC_MAY_READ_QUE flag, indicating that the CD is not within the
 *   middle of processing service from the ESS (such as OFFLINE
 *   interceptor activating) - and now waiting for next message (of
 *   the same service) from the ESS , is also ON.
 *
 * If the read mailbox request failed due to mailbox empty (it can only
 * be the CD server) - a read request from the queue is issued.
 * The mailbox message is treated according it's type (first message
 * character):
 * - A broadcast message (control message that was sendt from another
 *   CS/CD server to all other servers) - the message is processed
 *   (right now it notifies about the need to load interesting keywords,
 *   diag level changed or interesting Groups/Users/Connections) - and
 *   the function returns to read the next mailbox message.
 * - A control message of "session termination" and "process
 *   termination" causes the function to exit with "process
 *   termination" return code.
 * - A regular message (message from ESS - or from QUEUE) is decrypted
 *   (if it says in the GENERAL HEADER that the message is encrypted).
 *********************************************************************/
 
ESA_RC CS_get_next_msg (MSG_typ             * msg_ptr,
                        RSS_MSG_HDR_rec_typ * msg_hdr)
{
  char                  fn[]="CS_get_next_msg";
  ESA_RC                rc= ESA_OK;
  unsigned int          message_size, comp;
  int                   os_mbx_status;
  int                   encryption_out_len;
  ENC_ERR_rec_typ       encryption_err;
  void                * enc_handle;
  int                   read_from_que = 0;
  ENVIRONMENT_rec_typ * envir_ptr;
  ENC_ENCR_ALGRTM       encr_type;
 
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFR, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPFR, 13, "BK_msg_seq %d." ,(int)BK_msg_seq);
 
  enc_handle = NULL;
  comp= ESA_COMP_ACSGPFR;
  os_mbx_status = ESA_MBX_WAIT;
 
  rc= CS_shutdown_event ();
  if (rc EQ ESA_TERM_CTSA)
     goto cleanup;
  /*
    CHECK if a read from queue may be issued.
  */
 
  if ( (envir_ptr->p_main_name  EQ ESA_ACD_PROC) AND
       (envir_ptr->initial_service EQ INIT_SERVICE_SENDED) AND
       (envir_ptr->read_alternatives EQ PROC_MAY_READ_QUE) )
  {
	 if ( (NumIntrcptMsgInEss GE InterceptMax) AND (InterceptMax GT 0) )
	 {
        os_mbx_status = ESA_MBX_WAIT;
        ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_BASIC,
          "Wait for Interception confirmation Message. "
		  "Don't confirmed Intrcption Messages are %d.",
		  os_mbx_status, NumIntrcptMsgInEss);
	 }
	 else
        os_mbx_status = ESA_MBX_NOWAIT;
  }
 
  ESA_DIAG_printf (ESA_COMP_ACSGPFR, 13,
   "Before ESA_MBX_read: envir_ptr->chanel_i %d, Handshake_init: %d,\
 Read_altrntv: %d",
                   envir_ptr->channel_i,
                   envir_ptr->initial_service,
                   envir_ptr->read_alternatives);
 
  /*
    PROCESS until the read from mailbox returns a message different
    from BROADCAST message.
  */
 
  while (rc EQ ESA_OK) {
 
    /*
      READ next message from mailbox.
    */
    message_size = envir_ptr->max_msg_size;
 
    ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_MORE,
		"     > ESA_MBX_read.");
    rc = ESA_MBX_read (envir_ptr->channel_i,
                       (char *) msg_ptr ,
                       (int *) &message_size,
					   os_mbx_status);
	if ( (rc NE ESA_EOF) AND (rc NE ESA_MBX_EMPTY) )
	{
      ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_MSGHDR,
		"     ==> ESA_MBX_read: Hndl=%p MsgPtr=%p %s=%d to %d bytes.",
		envir_ptr->channel_i, msg_ptr,
		(os_mbx_status EQ ESA_MBX_NOWAIT) ? "ESA_MBX_NOWAIT" : "ESA_MBX_WAIT",
        os_mbx_status, message_size);
      CS_DIAG_MSG (ESA_COMP_ACSGPFR, rc, msg_ptr, message_size, TRUE);
      ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_MSGHDR,
			"     <== ESA_MBX_read: %d bytes with rc=%d (%s).",
	        message_size, rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
	}
	else
      ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_MORE,
			"     < ESA_MBX_read: rc=ESA_MBX_EMPTY");
    /*
      EXIT if read failed (not due to empty mailbox).
    */
	/***************** IS10129 ***************
	   handle communication down scenario
	   which is especially needed when INTERCEPT_SEND_MAX is used */
	if ((rc EQ ESA_CANCEL_SERVICE) AND (InterceptMax GT 0) ) {
		envir_ptr->initial_service = BLANK; /* mark handshake is required */
		NumIntrcptMsgInEss = 0;
		ESA_DIAG_printf (ESA_COMP_ACSGPFR, 1,
		   "ESA_MBX_read: CTSGATE_RC=40 --> rc=ESA_CANCEL_SERVICE & INTERCEPT_SEND_MAX GT 0");
	}
	/***************** end of IS10129 *********************/
 
    if ( (rc NE ESA_OK) AND
         (rc NE ESA_MBX_EMPTY) ) {
      ESA_RC rc_event= ESA_OK;
	
      ESA_DIAG_printf (ESA_COMP_ACSGPFR, 15,
           "Read mailbox returned code %d" , (int)rc);
      rc_event= CS_shutdown_event ();
      if (rc_event EQ ESA_TERM_CTSA)
         rc= rc_event;
      goto cleanup;
    }
    /*
      HANDLE broadcast message and continue the loop.
    */
    if ( (rc EQ ESA_OK) AND
         (strncmp(msg_ptr,CD_SRVR_MSG_BRDCT, 1) EQ 0) ) {
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
         "*****>... Accepted message about SA-Agent file changes.");
      rc= CS_brdcst_msg ((char *)msg_ptr, message_size , EVENT_UNDEF);
      if (rc NE ESA_OK)
        goto cleanup;
      continue;
    }
	
    /*
      if Update service message , continue the loop with NOT WAIT.
    */
    if ( (rc EQ ESA_OK) AND (*msg_ptr EQ UPDATE_ESS_SERVICE) )		/* AV002 */
	{
	   if (NumIntrcptMsgInEss GT 0)
	   {
		   CS_send_end_of_srv_instance();
	       NumIntrcptMsgInEss = 0;
	   }
       ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_BASIC,
          "*****>... Accepted Interception confirmation Message.");
       os_mbx_status = ESA_MBX_NOWAIT;
	   continue;
	}
 
    /*
      EXIT the loop if none BROADCAST message received.
    */
    break;
 
  } /* end while */
 
  /*
    HANDLE both "SERVER EXIT" & "SESSION CLOSED" messages - exit
    with process_termination return code.
  */
  if ( (rc EQ ESA_OK) AND
       (strncmp(msg_ptr,CD_SRVR_MSG_EXIT,1) EQ 0) ) {
    ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_BASIC,
         "*****>... Accepted message about server should exit. Server will go down shortly");
    rc = ESA_TERM_CTSA;
    goto cleanup;
  }
 
  if ( (rc EQ ESA_OK) AND
       (strncmp(msg_ptr,CD_SRVR_MSG_SESS_CLOSED,1) EQ 0) ) {
    ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_BASIC,
         "*****>... Accepted message about session closed. Server will go down shortly.");
    rc = ESA_TERM_CTSA;
    goto cleanup;
  }
 
  if (rc EQ ESA_MBX_EMPTY) {
	comp= ESA_COMP_QUEUE;
    /*
      READ message from queue - if mailbox read returned "mailbox
      empty" status.
    */
    rc = OS_Q_get ((void *) msg_ptr,
                   (int *) & message_size,
                   (int)envir_ptr->max_msg_size,
                   envir_ptr->q_wait,
                   &envir_ptr->q_handle);
	if ( (rc NE ESA_EOF) AND (rc NE ESA_MBX_EMPTY) )
	{
       ESA_DIAG_printf (comp, DIAG_MSGHDR,
	    	"...-> OS_Q_get: Hndl=%p MsgPtr=%p Stat=%d.",
		    &envir_ptr->q_handle, msg_ptr, envir_ptr->q_wait);
       CS_DIAG_MSG (comp, rc, msg_ptr, message_size, TRUE);
       ESA_DIAG_printf (comp, DIAG_MSGHDR,
			"...<- OS_Q_get: rc_act=%d (%s).",
            rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
	}
 
    if (envir_ptr->p_main_name  EQ ESA_ACD_PROC)
       CD_interception_control (rc);
 
    enc_handle = envir_ptr->enc_internal_handle;
    ESA_DIAG_printf (comp, 15,
        "Queue get ended with message size:%d retun code:%s",
                       message_size, ESA_rc2str(rc));
 
    /*
      SET queue read indication.
    */
    read_from_que = 1;
    if (rc NE ESA_OK)
      /*
        EXIT if read queue failed.
      */
      goto cleanup;
  }
 
  /*
    SAVE the GENERAL messaage header.
  */
  rc= CS_get_msg_header ( msg_ptr ,  msg_hdr);
 
  if (
        (memcmp((char *)(&msg_hdr->mhmtyp), END_OF_SERVICE,
                ADINF_TYP_LEN) EQ 0)
       AND
        (envir_ptr->login_mode NE LOGOUT_MODE_LAST)
     )
  {
     rc= ADM_loginout (LOGOUT_MODE_LAST, LOGIN_UNDEFINED_ADMIN, fn);
     ESA_DIAG_printf (comp, 15,"ADM_logout: rc:%s", ESA_rc2str(rc));
  }
  /*
    PROCESS when encryption is active (or debug) for the communication
    messages - and read was done from mailbox, or when encryption is
    active for internal messages and read was done on queue:
  */
 
    if (
        (memcmp((char *)(&msg_hdr->mhmtyp),START_OF_SERVICE,
                ADINF_TYP_LEN) EQ 0)
       AND
        (envir_ptr->encr_ext_act NE NOT_ACT_ENCR)
       AND
        (read_from_que EQ 0)
    )
  {
     if (envir_ptr->enc_external_key_handle NE NULL)
     {
        ENC_term (&envir_ptr->enc_external_key_handle);
        envir_ptr->enc_external_key_handle = NULL;
     }
     if (rc EQ ESA_OK)
      rc = ENC_init_key (msg_hdr->mhsiid,
                         sizeof (MH_siid),
                         envir_ptr->encryption_active_ext,
                         envir_ptr->enc_external_handle,
                         &envir_ptr->enc_external_key_handle,
                         &encryption_err);
 
     if (rc NE ESA_OK)
     {
        CS_encr_msg (&encryption_err);
        ESA_DIAG_printf (comp, 15,
           "External encryption term/init key completed with rc :%s",
                         ESA_rc2str(rc));
 
     }
 
   }
 
   if (read_from_que EQ 0)
      enc_handle = envir_ptr->enc_external_key_handle;
 
    if (
         (
           (envir_ptr->encr_ext_act NE NOT_ACT_ENCR)
          AND
           (read_from_que EQ 0)
         )
        OR
         (
           (envir_ptr->encr_int_act NE NOT_ACT_ENCR)
          AND
           (read_from_que EQ 1)
         )
 
     ) {
 
    /*
      PROCESS when the GENERAL HEADEDR indicates that the message was
      encrypted:
    */
    /*if (msg_hdr->mhcmrs EQ MH_ENCR_ON)*/
    if (
		  (msg_hdr->mhcmrs EQ MH_ENCR_ON)
         OR
		  (msg_hdr->mhcmrs EQ MH_ENCR_NEW)
       )
	{
 
		if (msg_hdr->mhcmrs EQ MH_ENCR_ON)
           encr_type= ENC_DES;
	    else
		   encr_type= ENC_TDES;
 
       if (
		     (envir_ptr->p_main_name EQ ESA_ACS_PROC)
            OR
  		     (msg_hdr->mhsid EQ ESS_INITIAL_SERVICE)
          )
	   {
          envir_ptr->encr_type= encr_type;
          ESA_DIAG_printf (comp, 15,"Encryption type set to %s.",
		  (envir_ptr->encr_type == ENC_DES) ? "ENC_DES" : "ENC_TDES");
	   }
      /*
        DECRYPT the incomming message, save it in special buffer.
      */
      rc = ENC_decr(enc_handle,
                    msg_ptr+sizeof (RSS_MSG_HDR_rec_typ),
                    (int)(message_size-sizeof (RSS_MSG_HDR_rec_typ)),
                    encr_type, /*ENC_FALSE,*/
                    envir_ptr->enc_ptr,
                    &encryption_out_len,
                    &encryption_err);
 
      ESA_DIAG_printf (comp, DIAG_DETAILES+ 1,
		  "     Encryption %s completed with return code:%s.",
		 (encr_type == ENC_DES) ? "ENC_DES" : "ENC_TDES", ESA_rc2str(rc));
 
      if (rc NE ESA_OK) {
        CS_encr_msg (&encryption_err);
        goto cleanup;
      }
      /*
        COPY decrypted message back to the read message buffer.
      */
      memcpy ((char *)(msg_ptr+sizeof (RSS_MSG_HDR_rec_typ)),
              (char *)envir_ptr->enc_ptr,
              message_size- sizeof (RSS_MSG_HDR_rec_typ));
      /*
        CALCULATE new message size.
      */
      message_size=encryption_out_len+ sizeof (RSS_MSG_HDR_rec_typ);
 
      ESA_DIAG_printf (comp, 15,"After ENC_decr: message size %d encr_len %d ",
                     message_size, encryption_out_len);
    } /* END - message was encrypted */
    else {
       if (read_from_que EQ 0) {
          rc = ESA_ERR;
          CTSAMSG_print (ERR_CS_NOT_ENCRYPTED_MSG,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
          goto cleanup;
       }
    }
  } /* END - the encryption is active */
  else {
    if (
		  (msg_hdr->mhcmrs EQ MH_ENCR_ON)
		 OR
		  (msg_hdr->mhcmrs EQ MH_ENCR_NEW)
       )
	{
       rc = ESA_ERR;
       CTSAMSG_print (ERR_CS_ENCRYPTED_MSG,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest, fn);
       goto cleanup;
    }
  }
  /*
    SAVE the length of the message for validty checking.
  */
  envir_ptr->msg_size= message_size;
  envir_ptr->msg_ptr=  msg_ptr;
 
  CS_DIAG_MSG (comp, rc, msg_ptr, message_size, FALSE);
 
  if (message_size LT envir_ptr->max_msg_size)
    *((char *)envir_ptr->msg_ptr+ message_size)= '\0';
 
  cleanup:
 
  if ( (rc NE ESA_OK) AND
       (rc NE ESA_EOF) AND
       (rc NE ESA_TERM_CTSA) AND
       (rc NE ESA_MBX_EMPTY) )
    CTSAMSG_print (ERR_CS_GET_NEXT_FAILED,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn,
                   (read_from_que EQ 1) ? "QUEUE" : "MAILBOX",
                   ESA_rc2str(rc));
  /* fix 062499 */
  if ((rc EQ ESA_FATAL) OR
      (rc EQ ESA_MBX_NOT_EXIST ))
    rc = ESA_FATAL_IO;
  /* fix 062499 */
  ESA_DIAG_printf (comp, 14,"BK_msg_seq %d." ,(int)BK_msg_seq);
  ESA_DIAG_exit (ESA_COMP_ACSGPFR, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_get_next_msg function */
 
/****************************************************
 * Procedure Name: CS_get_aplic_msg
 * Description   : This function adds the size of GENERAL
 *                 HEADER to the message pointer.
 *                 IT SHOULD BE REPLACED BY MACRO A.S.A.P
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_get_aplic_msg (MSG_typ * msg_ptr)
{
  char fn[]="CS_get_aplic_msg";
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Header=%.*s.",
                   sizeof(RSS_MSG_HDR_rec_typ), msg_ptr);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
  return (msg_ptr + sizeof(RSS_MSG_HDR_rec_typ));
} /* END - CS_get_aplic_msg function */
 
/****************************************************
 * Procedure Name: CS_get_rss_msg
 * Description   : Analyze and return the Aplication Header.
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * Currently the Aplication Header contains only the NUMBER
 * OF INLUDED RSS MESSAGES field.
 * The function verifies that the number of included rss messages
 * is valid HEXA number, translates it to decimal number and
 * sets the message pointer right after the header.
 ***************************************************************/
 
MSG_typ * CS_get_rss_msg (NUM_MSGS_typ  * num_msgs,
                          MSG_typ       * msg_ptr)
{
   char                  fn[]="CS_get_rss_msg";
   char                  str [RSS_NUM_MSGS+1];
   ESA_RC                rc;
   ENVIRONMENT_rec_typ * envir_ptr;
   MSG_typ             * ret_val;    /* AJKxxx */
 
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
   memset (str, '\0', sizeof(str));
   memcpy (str, (char *)msg_ptr, RSS_NUM_MSGS);
 
   /*
     CHECK that the number of included message is valid HEXA number.
   */
 
   rc = CS_check_nmb (str, msg_ptr, 0,C_NUM_MSGS);
   if (rc NE ESA_OK)
    goto cleanup;
 
   /*
     TRANSLATE the HEXA number to decimal.
   */
   sscanf (str, "%x", num_msgs);
   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Number Messages=%d (%s)",
                    *num_msgs, str) ;
  cleanup:
 
   if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11, "Fail %s", fn);
 
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_NUM_MSGS);
      ret_val = NULL;   /* AJKxxx */
   }
   else {
      /*
        SET message pointer right after the header.
      */
      ret_val = msg_ptr + RSS_NUM_MSGS;
   }
 
   ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
 
   return ret_val;    /* AJKxxx */
 
} /* END - CS_get_rss_msg function */
 
/****************************************************
 * Procedure Name: CS_get_singl_msg
 * Description   : retrieve a single message from RSS
 *                 message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function analyses an RSS MESSAGE HEADER that contsructs
 * as follows:
 * - The RSS message length
 * - Transaction id.
 * - Action id
 * The RSS message length is checked to be a valid hexadecimal
 * number, it is translated to decimal number and returned along
 * with the Transaction id and Action id.
 *****************************************************/
 
MSG_typ * CS_get_singl_msg (NUM_MSGS_typ * len_msg,
                            TRAN_rec_typ * tran,
                            MSG_typ      * msg_ptr)
{
  char                  fn[]="CS_get_singl_msg";
  char                  str [RSS_MSG_LEN+1];
  ESA_RC                rc;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Single Msg Path=%.*s.",
                   RSS_MSG_LEN+ (sizeof(TRAN_typ) *2),msg_ptr);
 
  /*
    CHECK the RSS message length to be a valid hexadecimal number.
  */
 
  memset (str, '\0', sizeof(str));
  memcpy (str, (char *)msg_ptr, RSS_MSG_LEN);
  rc= CS_check_nmb (str, msg_ptr, 0,C_MSG_LEN);
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    TRANSLATE the hexadecimal number to decimal number.
  */
 
  sscanf (str, "%x", len_msg);
  msg_ptr += RSS_MSG_LEN;
  memcpy ((char *)tran , (char *)msg_ptr , sizeof(TRAN_typ) *2 );
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Single Msg Len= %d (%s)", *len_msg, str);
 
  /*
    SET message pointer to the begining of RSS message body.
  */
 
  msg_ptr = msg_ptr + sizeof(TRAN_typ)*2 ;
 
  cleanup:
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn , C_MSG_LEN);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  if (rc NE ESA_OK)
     return (NULL);
  else
     return (msg_ptr);
} /* END - CS_get_singl_msg function */
 
/****************************************************
 * Procedure Name: CS_get_fld
 * Description   : Retrieve single field from message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function retrieves a single string field from a message.
 * The field is realy a pare of fields in the following structure:
 * - Field length - a string of 3 hexadecimal characters that states
 *                  the length of the field itself.
 * - field data   - a string with "field length" length.
 * The function verifies that the Field length is valid hexadecimal
 * number, that it's not more than the maximum length allowed (input
 * parameter) and that the value itself does not resides beyond the
 * message bounderies. The message pointer is advanced to point to
 * next field (or at buffer's end).
 *********************************************************************/
 
MSG_typ * CS_get_fld ( void              * field,
                       MSG_typ           * msg_ptr,
                       unsigned long int   max_nmb ,
                       const char        * fld_name)
{
  char                  fn[]="CS_get_fld";
  char                  str [STRUCT_LEN+1]; /*, * msg_dmp;*/
  NUM_MSGS_typ          len_msg;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  /*
    KEEP aside the field's length field.
  */
  /*msg_dmp= msg_ptr+ STRUCT_LEN;*/
 
  memset ((char *)field , NULL_CHAR , max_nmb);
  memset (str, NULL_CHAR, sizeof(str));
  memcpy (str, (char *)msg_ptr, STRUCT_LEN);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 2, "Msg Len Str %s.", str);
  /*
    CHECK validity of field length and the field value itself.
  */
  rc= CS_check_nmb (str, msg_ptr, max_nmb,fld_name);
  if (rc NE ESA_OK) {
    msg_ptr= NULL;
    goto cleanup;
  }
  /*
    TRANSLATE the hexadecimal value to decimal vaue.
  */
  sscanf (str, "%x", &len_msg);
  msg_ptr += STRUCT_LEN;
  /*
    COPY the field's value to the output filed's value.
  */
  memcpy ((char *)field , (char *)msg_ptr , len_msg);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 2,
                   "Msg Str %s (length=%d)", field, len_msg);
  /*
    SET the message pointer to point to the next field in message.
  */
  msg_ptr += len_msg;
 
  cleanup:
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 11, "Fail %s", fn);
    CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn , fld_name);
    /*CTSAMSG_print (ERR_3_STRINGS,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn , ": Dump of the invalid field=", msg_dmp);*/
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF,DIAG_COMMON,fn,ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_get_fld function */
 
/****************************************************
 * Procedure Name: CS_get_enum_fld
 * Description   : Retrieve enum field from message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function retrievs an enumareted filed from message
 * buffer. The function actually receives a buffer of the following
 * structure:
 * - ENUM field length - The enum field length, is a field of 3
 *                       hexadecimal character that (up to this point)
 *                       MUST ALWAYS CONTAIN THE VALUE "001".
 * - ENUM value        - A single character representing the value of
 *                       the ENUM field.
 * The function verifies that the "ENUM field length" field contains
 * the value "001" and then verifies that the ENUM field value
 * contains a valid enum value - according to the specific enum field
 * type (input parameter). The value of the enum field - is returned
 * as an integer value.
 *********************************************************************/
 
MSG_typ * CS_get_enum_fld (int        * field,
                           int          fld_type,
                           MSG_typ    * msg_ptr ,
                           const char * fld_name)
{
  char                  fn[]="CS_get_enum_fld";
  char                  str [STRUCT_LEN+1];
  NUM_MSGS_typ          len_msg;
  ESA_RC                rc= ESA_OK;
  unsigned long int     max_nmb= 1;
  unsigned long int     len= STRUCT_LEN+ 1; /* The len value
                       is first set to 4 - so in case of error
                       all length + value fileds will be printed */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "1 CS_get_admin_patrams BK_msg_seq %d." ,
      (int)BK_msg_seq);
  /*
    VERIFY that the ENUM filed length filed contain the value "001".
  */
  memset (str, '\0', sizeof(str));
  memcpy (str, (char *)msg_ptr, STRUCT_LEN);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 2, "Msg Len Str %s.", str);
  rc= CS_check_nmb (str, msg_ptr, max_nmb,fld_name);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "3 CS_get_admin_patrams BK_msg_seq %d."
      ,(int)BK_msg_seq);
  if (rc NE ESA_OK) {
    rc= ESA_WARN;
    goto cleanup;
  }
  len= max_nmb;
 
  sscanf (str, "%x", &len_msg);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "4 CS_get_admin_patrams BK_msg_seq %d."
      ,(int)BK_msg_seq);
  msg_ptr += STRUCT_LEN;
  if (len_msg EQ 0) {
     rc= ESA_SKIP;
     goto cleanup;
  }
 
  /*
    PROCESS according to the filed type - check field's value validity,
    and translate it to output value.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "4.1 CS_get_admin_patrams BK_msg_seq %d."
      ,(int)BK_msg_seq);
 
  switch (fld_type) {
    case FLD_OE_ATTR:
    if (memcmp ((char *)msg_ptr , M_OE_ATTR_ACL, len_msg) EQ 0)
      * field = OE_ATTR_ACL;
    else if (memcmp ((char *)msg_ptr , M_OE_ATTR_NO_ACL, len_msg) EQ 0)
      * field = OE_ATTR_NO_ACL;
    else if (memcmp ((char *)msg_ptr , M_OE_ATTR_IGNORED,len_msg) EQ 0)
      * field = OE_ATTR_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = OE_ATTR_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_DEF_UG_ACTION:
    if (memcmp ((char *)msg_ptr , M_OLD_DEF_UG_ACT_KEEP, len_msg) EQ 0)
      * field = OLD_DEF_UG_ACT_KEEP;
    else if (memcmp ((char *)msg_ptr , M_OLD_DEF_UG_ACT_DROP,
                     len_msg) EQ 0)
      * field = OLD_DEF_UG_ACT_DROP;
    else if (memcmp ((char *)msg_ptr , M_OLD_DEF_UG_ACT_IGNORED,
                     len_msg) EQ 0)
      * field = OLD_DEF_UG_ACT_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = OLD_DEF_UG_ACT_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_SRVC_HOT_PATH:
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
          "4.2 CS_get_admin_patrams BK_msg_seq %d."
          ,(int)BK_msg_seq);
    if      (memcmp ((char *)msg_ptr , M_HOT_PATH_ON, len_msg) EQ 0)
      * field = HOT_PATH_ON;
    else if (memcmp ((char *)msg_ptr , M_HOT_PATH_OFF, len_msg) EQ 0)
      * field = HOT_PATH_OFF;
    else if (memcmp ((char *)msg_ptr , M_HOT_PATH_FULL, len_msg) EQ 0)
      * field = HOT_PATH_FULL;
    else rc= ESA_ERR;
     ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
         "4.3 CS_get_admin_patrams BK_msg_seq %d." ,
         (int)BK_msg_seq);
    break;
 
    case FLD_USER_PASSWD_LIFE:
    if (memcmp ((char *)msg_ptr , M_PASS_LIFE_PERMANENT,len_msg) EQ 0)
      * field = PASS_LIFE_PERMANENT;
    else if (memcmp ((char *)msg_ptr, M_PASS_LIFE_RESET, len_msg) EQ 0)
      * field = PASS_LIFE_RESET;
    else if (memcmp ((char *)msg_ptr, M_PASS_LIFE_IGNORED,
                     len_msg) EQ 0)
      * field = PASS_LIFE_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = PASS_LIFE_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_USER_STAT:
    if (memcmp ((char *)msg_ptr , M_REVOKE , len_msg) EQ 0)
      * field = USER_STAT_REVOKED;
    else if (memcmp ((char *)msg_ptr , M_RESTORE , len_msg) EQ 0)
      * field = USER_STAT_ACTIVE;
    else if (memcmp ((char *)msg_ptr , M_OP_IS_IGNOR , len_msg) EQ 0)
      * field = USER_STAT_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field =  USER_STAT_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_USER_ADMIN:
    if      (memcmp ((char *)msg_ptr , M_USER_IS_ADMIN , len_msg) EQ 0)
      * field = USER_ADM_ADMIN;
    else if (memcmp ((char *)msg_ptr , M_USER_IS_USER , len_msg) EQ 0)
      * field = USER_ADM_NONE;
    else if (memcmp ((char *)msg_ptr, M_USER_IS_AUDITOR, len_msg) EQ 0)
      * field = USER_ADM_AUDIT;
    else if (memcmp ((char *)msg_ptr , M_USER_IS_BOTH , len_msg) EQ 0)
      * field = USER_ADM_ALL;
    else if (memcmp ((char *)msg_ptr, M_USER_IS_IGNORED, len_msg) EQ 0)
      * field = USER_ADM_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = USER_ADM_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_ACE_TYP:
    if      (memcmp ((char *)msg_ptr , M_ACE_IS_USER , len_msg) EQ 0)
      * field = ACE_TYPE_USER;
    else if (memcmp ((char *)msg_ptr , M_ACE_IS_GROUP , len_msg) EQ 0)
      * field = ACE_TYPE_GROUP;
    else if (memcmp ((char *)msg_ptr , M_ACE_IS_BOTH , len_msg) EQ 0)
      * field = ACE_TYPE_USER_AND_GROUP;
    else if (memcmp ((char *)msg_ptr , M_ACE_IS_OTHER, len_msg) EQ 0)
      * field = ACE_TYPE_WORLD;
    else if (memcmp ((char *)msg_ptr ,M_ACE_IS_UNDEFINED,len_msg) EQ 0)
      * field = ACE_TYPE_UNDEFINED;
    else if (memcmp ((char *)msg_ptr , M_ACE_IS_IGNORE, len_msg) EQ 0)
      * field = ACE_TYPE_IGNORED;
    else if (memcmp ((char *)msg_ptr , M_ACE_IS_OE, len_msg) EQ 0)
      * field = ACE_TYPE_OE;
    else if (memcmp ((char *)msg_ptr , M_ACE_IS_MASK, len_msg) EQ 0)
      * field = ACE_TYPE_MASK;
    else if (*msg_ptr EQ BACKSLASH)
      * field = ACE_TYPE_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_ACE_ATTR:
    if (memcmp ((char *)msg_ptr,M_ACE_ATTR_IS_PERMANENT, len_msg) EQ 0)
      * field = ACE_ATTR_PERMANENT;
    else if (memcmp ((char *)msg_ptr , M_ACE_ATTR_IS_REGULAR ,
                     len_msg) EQ 0)
      * field = ACE_ATTR_REGULAR;
    else if (memcmp ((char *)msg_ptr,M_ACE_ATTR_IGNORED, len_msg) EQ 0)
      * field = ACE_ATTR_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = ACE_ATTR_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_ACE_PLACE:
    if      (memcmp ((char *)msg_ptr , M_ACE_LOC_FIRST , len_msg) EQ 0)
      * field = ACE_POS_FIRST;
    else if (memcmp ((char *)msg_ptr , M_ACE_LOC_LAST  , len_msg) EQ 0)
      * field = ACE_POS_LAST ;
    else if (memcmp ((char *)msg_ptr , M_ACE_LOC_BEFORE, len_msg) EQ 0)
      * field = ACE_POS_BEFORE;
    else if (memcmp ((char *)msg_ptr , M_ACE_LOC_AFTER,  len_msg) EQ 0)
      * field = ACE_POS_AFTER;
    else if (memcmp ((char *)msg_ptr, M_ACE_LOC_IGNORED, len_msg) EQ 0)
      * field = ACE_POS_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = ACE_POS_IGNORED;
    else rc= ESA_ERR;
 
    break;
 
    case FLD_U2UG_ATTR:
    if      (memcmp ((char *)msg_ptr , M_U2UG_ATTR_DEFAULT_GROUP,
                     len_msg) EQ 0)
      * field = U2UG_ATTR_DEFAULT_GROUP;
    else if (memcmp ((char *)msg_ptr , M_U2UG_ATTR_UNDEFINED,
                     len_msg) EQ 0)
      * field = U2UG_ATTR_REGULAR;
    else if (memcmp ((char *)msg_ptr,M_U2UG_ATTR_IGNORED,len_msg) EQ 0)
      * field = U2UG_ATTR_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = U2UG_ATTR_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_U2UG_CONN:
    if (memcmp ((char *)msg_ptr , M_U2UG_CONN_NONE , len_msg) EQ 0)
      * field = U2UG_ADM_NONE;
    else if (memcmp ((char *)msg_ptr , M_U2UG_CONN_IS_ADMIN ,
                     len_msg) EQ 0)
      * field = U2UG_ADM_ADMIN;
    else if (memcmp ((char *)msg_ptr , M_U2UG_CONN_IS_AUDIT ,
                     len_msg) EQ 0)
      * field = U2UG_ADM_AUDIT;
    else if (memcmp ((char *)msg_ptr , M_U2UG_CONN_IS_BOTH ,
                     len_msg) EQ 0)
      * field = U2UG_ADM_ALL;
    else if (memcmp ((char *)msg_ptr , M_U2UG_CONN_IGNORE ,
                     len_msg) EQ 0)
      * field = U2UG_ADM_IGNORED;
    else if (*msg_ptr EQ BACKSLASH)
      * field = U2UG_ADM_IGNORED;
    else rc= ESA_ERR;
    break;
 
    case FLD_SEVERITY:
    if (memcmp ((char *)msg_ptr, M_LOGEVENT, len_msg) EQ 0)
       * field = LOGEVENT;
    else if (memcmp ((char *)msg_ptr, M_REGULARALERT, len_msg) EQ 0)
       * field = REGULARALERT;
    else if (memcmp ((char *)msg_ptr, M_URGENTALERT, len_msg) EQ 0)
       * field = URGENTALERT;
    else if (memcmp ((char *)msg_ptr, M_VERYURGENTALERT, len_msg) EQ 0)
       * field = VERYURGENTALERT;
    else rc= ESA_ERR;
    break;
 
    default:
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "CS_get_enum_fld invalid enum field code =%d",
                     fld_type);
    rc= ESA_ERR;
    break;
  }
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "4.5 CS_get_admin_patrams BK_msg_seq %d." ,
      (int)BK_msg_seq);
 
  if (rc EQ ESA_OK)
    /*
      SET message pointer to point to next field.
    */
    msg_ptr += len_msg;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "5 CS_get_admin_patrams BK_msg_seq %d." ,
      (int)BK_msg_seq);
 
  cleanup:
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "6 CS_get_admin_patrams BK_msg_seq %d." ,
      (int)BK_msg_seq);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 2,
      "Msg Field=%d fld_type=%d fld_name=%s." , (int)(*field), (int)fld_type, fld_name);
  if (rc EQ ESA_ERR) { /* ENUM value is illegal for that enum field */
    *((char *)msg_ptr+ len)= '\0';
     CTSAMSG_print (ERR_CS_INVAL_ENUM ,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    fn , fld_name , msg_ptr );
    msg_ptr= NULL;
  }
  if (rc EQ ESA_WARN) { /* ENUM field length is illegal or out of
                           buffer */
     CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    fn , fld_name);
    msg_ptr= NULL;
  }
  if (rc EQ ESA_SKIP) {  /* EMPTY enum field (must always exist) */
    CTSAMSG_print (ERR_CS_MSG_CHKSIZE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, fld_name, str, max_nmb);
    msg_ptr= NULL;
 
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF,DIAG_COMMON,fn,ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_get_enum_fld function */
 
/****************************************************
 * Procedure Name: CS_get_user
 * Description   : retrieve user structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  : Ptr to MSG, NULL on failure
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked whenever a message contains a user
 * structure - and there is a need to analyse it and decompose it
 * into an API user's structure.
 * In addition the function updates the message's pointer to point
 * out to the first field right after the user's details within the
 * message.
 *******************************************************************/
 
MSG_typ * CS_get_user (USER_PARAMS_rec_typ  * usr_prm,
                       MSG_typ              * msg_ptr)
{
  char                  fn[]="CS_get_user";
  unsigned long int     max_nmb;
  int                   enum_int;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)usr_prm , NULL_CHAR , sizeof(USER_PARAMS_rec_typ));
 
  /*
    RETRIEVE user's name.
  */
 
  max_nmb= envir_ptr->rss_limits.max_user_len;
  msg_ptr = CS_get_fld (usr_prm->user ,msg_ptr, max_nmb,
                        C_USER_ID );
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "1: User=%s.", usr_prm->user);
  /*
    RETRIEVE user's parent oe name.
  */
 
  max_nmb= envir_ptr->rss_limits.max_oe_len;
  msg_ptr = CS_get_fld (usr_prm->parent_oe ,msg_ptr, max_nmb,
                        C_USER_OE_PARENT );
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: User Parent Container=%s.", usr_prm->parent_oe);
 
  /*
    RETRIEVE the user's default group name.
  */
 
  max_nmb= envir_ptr->rss_limits.max_ug_len ;
  msg_ptr = CS_get_fld (usr_prm->def_group , msg_ptr, max_nmb ,
                        C_USER_GROUP_DEF);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Default Group=%s.", usr_prm->def_group);
 
  /*
    RETRIEVE the user's password.
  */
 
  max_nmb= envir_ptr->rss_limits.max_pwd_len ;
  msg_ptr = CS_get_fld (usr_prm->passwd , msg_ptr, max_nmb,
                        C_USER_PASSWD);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4: User Password=**...* Length %d.", strlen (usr_prm->passwd));
 
  /*
    RETRIEVE the user's password lifetime type.
  */
 
  enum_int= (int)usr_prm->passwd_life;
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_USER_PASSWD_LIFE,
                             msg_ptr,
                             C_USER_PASSWD_LIFE);
  usr_prm->passwd_life= (PASSWD_LIFE_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "5: Password Life %d.", (int)usr_prm->passwd_life);
 
  /*
    RETRIEVE the user's status (revoke/restor).
  */
 
  enum_int= (int)usr_prm->rev_status;
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_USER_STAT ,
                             msg_ptr ,
                             C_USER_REV_STATUS);
  usr_prm->rev_status= (USER_STATUS_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "6: Revoke Status %d.", (int)usr_prm->rev_status);
 
  /*
    RETRIEVE the user's admin status
  */
 
  enum_int= (int)usr_prm->user_admin;
  msg_ptr = CS_get_enum_fld (&enum_int ,
                             FLD_USER_ADMIN ,
                             msg_ptr ,
                             C_USER_ADMIN);
  usr_prm->user_admin= (USER_ADMIN_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "7: User Admin Mode %d.", (int)usr_prm->user_admin);
 
  /*
    RETRIEVE the def group action (If changed def group)
   */
 
  enum_int= (int)usr_prm->def_ug_action;
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_DEF_UG_ACTION ,
                             msg_ptr ,
                             C_DEF_UG_ACTION);
  usr_prm->def_ug_action= (OLD_DEF_UG_ACTION_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "8: Default Default Group Action %d.", (int)usr_prm->def_ug_action);
 
 cleanup:
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return (msg_ptr);
 
} /* END CS_get_user function */
 
/****************************************************
 * Procedure Name: CS_get_oe
 * Description   : retrieve container structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked whenever a message contains a container
 * structure - and there is a need to analyse it and decompose
 * it into an API container's structure.
 * In addition the function updates the message's pointer to piont
 * out to the first field right after the container's details within
 * the message.
 *******************************************************************/
 
MSG_typ * CS_get_oe (OE_PARAMS_rec_typ * oe_prm,
                     MSG_typ           * msg_ptr)
{
  char                  fn[]="CS_get_oe";
  unsigned long int     max_nmb;
  int                   enum_int;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)oe_prm , NULL_CHAR , sizeof(OE_PARAMS_rec_typ));
  /*
    RETRIEVE the container.
  */
  max_nmb= envir_ptr->rss_limits.max_oe_len;
  msg_ptr = CS_get_fld (oe_prm->oe ,msg_ptr, max_nmb,C_OE_ID);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Container=%s.", (int)oe_prm->oe);
  /*
    RETRIEVE the container's parent container name.
  */
  max_nmb= envir_ptr->rss_limits.max_oe_len;
  msg_ptr = CS_get_fld (oe_prm->parent ,msg_ptr, max_nmb,
                        C_OE_PARENT);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Parent Container=%s.", (int)oe_prm->parent);
  /*
    RETRIEVE the container's attribute.
  */
  enum_int= (int)oe_prm->attr;
  msg_ptr = CS_get_enum_fld (&enum_int ,
                             FLD_OE_ATTR ,
                             msg_ptr ,
                             C_OE_ATTR);
  oe_prm->attr= (OE_ATTR_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Container Attribute=%d.", (int)oe_prm->attr);
 
  cleanup:
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_get_oe function */
 
/****************************************************
 * Procedure Name: CS_get_ug
 * Description   : retrieve user group structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked whenever a message contains a user
 * group structure - and there is a need to analyse it and decompose
 * it into an API user group's structure.
 * In addition the function updates the message's pointer to piont
 * out to the first field right after the user group's details within
 * the message.
 *******************************************************************/
 
MSG_typ * CS_get_ug (UG_PARAMS_rec_typ * ug_prm,
                     MSG_typ           * msg_ptr)
{
  char                  fn[]="CS_get_ug";
  unsigned long int     max_nmb;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)ug_prm , NULL_CHAR , sizeof(UG_PARAMS_rec_typ));
  /*
    RETRIEVE the group name.
  */
  max_nmb= envir_ptr->rss_limits.max_ug_len;
  msg_ptr = CS_get_fld (ug_prm->group ,msg_ptr, max_nmb,C_GROUP_ID);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: User Group=%s.", (int)ug_prm->group);
  /*
    RETRIEVE the group's parent oe name.
  */
  max_nmb= envir_ptr->rss_limits.max_oe_len;
  msg_ptr = CS_get_fld (ug_prm->parent_oe ,msg_ptr, max_nmb,
                        C_GROUP_OE_PARENT);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: User Group Parent Container=%s.", (int)ug_prm->parent_oe);
  /*
    RETRIEVE the groups' parent group name.
  */
  max_nmb= envir_ptr->rss_limits.max_ug_len;
  msg_ptr = CS_get_fld (ug_prm->parent_group ,msg_ptr, max_nmb,
                        C_GROUP_PARENT);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: User Group Parent Group=%s.", (int)ug_prm->parent_group);
 
  cleanup:
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_get_ug function */
 
/****************************************************
 * Procedure Name: CS_get_u2ug
 * Description   : retrieve user to group structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked whenever a message contains a user
 * to group connection structure - and there is a need to analyse it
 * and decompose it into an API user to group's connection structure.
 * In addition the function updates the message's pointer to piont
 * out to the first field right after the user group connection's
 * details within the message.
 *******************************************************************/
 
MSG_typ * CS_get_u2ug (U2UG_PARAMS_rec_typ  * u2ug_prm,
                       MSG_typ              * msg_ptr)
{
  char                  fn[]="CS_get_u2ug";
  int                   enum_int;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    RETRIEVE the connection type (admin,audit etc.).
  */
  enum_int= (int)u2ug_prm->u2ug_admin_data;
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_U2UG_CONN ,
                             msg_ptr ,
                             C_U2UG_MISC);
  u2ug_prm->u2ug_admin_data= (U2UG_ADMIN_typ)enum_int;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	          "3: Admin connection type=%d.", (int)u2ug_prm->u2ug_admin_data);
 
  if (msg_ptr EQ NULL)
    goto cleanup;
  /*
    RETRIEVE the connection attribute (user's default group).
  */
  enum_int= (int)u2ug_prm->u2ug_attr_data;
  msg_ptr = CS_get_enum_fld (&enum_int ,
                             FLD_U2UG_ATTR ,
                             msg_ptr ,
                             C_U2UG_ATTRS);
  u2ug_prm->u2ug_attr_data= (U2UG_ATTR_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	          "4: Attribute connection type=%d.", (int)u2ug_prm->u2ug_attr_data);
  /*
    RETRIEVE the user's default group name.
  */
  msg_ptr = CS_get_fld (u2ug_prm->def_group ,
                        msg_ptr,
                        envir_ptr->rss_limits.max_ug_len,
                        C_U2UG_DEF_GROUP);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	          "5: Default Group of the connection=%s.", u2ug_prm->def_group);
 
  cleanup:
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_get_u2ug function */
 
/****************************************************
 * Procedure Name: CS_get_res
 * Description   : retrieve resource structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked whenever a message contains a resource
 * structure - and there is a need to analyse and decompose it into an
 * API resource structure.
 * In addition the function updates the message's pointer to piont
 * out to the first field right after the resource details within the
 * message.
 *******************************************************************/
 
MSG_typ * CS_get_res ( RES_PARAMS_rec_typ    * res_prm,
                       MSG_typ               * msg_ptr)
{
  char                  fn[]="CS_get_res";
  unsigned long int     max_nmb;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)res_prm , NULL_CHAR , sizeof(RES_PARAMS_rec_typ));
  /*
    RETRIEVE the resource name.
  */
  max_nmb= envir_ptr->rss_limits.max_resource_len;
  msg_ptr = CS_get_fld (res_prm->resource ,msg_ptr, max_nmb,
                        C_RES_ID);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Resource=%s.", res_prm->resource);
  /*
    RETRIEVE the resource type.
  */
  max_nmb= envir_ptr->rss_limits.max_restype_len;
  msg_ptr = CS_get_fld (res_prm->restype ,msg_ptr, max_nmb,C_RES_TYP);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Resource type=%s.", res_prm->restype);
 
  /*
    RETRIEVE the oe.
  */
  max_nmb= envir_ptr->rss_limits.max_oe_len;
  msg_ptr = CS_get_fld (res_prm->parent_oe ,msg_ptr, max_nmb,
                        C_RES_OE_PARENT);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Resource parent Container=%s.", res_prm->parent_oe);
 
  cleanup:
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END CS_get_res function */
 
/****************************************************
 * Procedure Name: CS_get_rss
 * Description   : retrieve RSS PARAMETERSstructure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * The relevant API for this function is NOT YET imnplemented in
 * any of the supported platforms - and the current function does
 * not word AT ALL - should be updated when the time comes!!!!!!
 *********************************************************************/
 
MSG_typ * CS_get_rss ( RSS_PARAMS_rec_typ    * rss_prm,
                       MSG_typ               * msg_ptr)
{
  char                  short_number[6];
  int                   numb;
  char                  fn[]="CS_get_rss";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)rss_prm , NULL_CHAR , sizeof(RSS_PARAMS_rec_typ));
 
  msg_ptr = CS_get_fld (short_number ,
                        msg_ptr,
                        sizeof(short_number) -1,
                        C_MIN_PASS_LEN);
  if (msg_ptr EQ NULL)
     goto cleanup;
  if (strlen(short_number) EQ 0)
     numb = EMPTY_NUMBER;
  else if (strcmp (short_number, BACKSLASH_STR) EQ 0)
    numb = IGNORE_NUMBER ;
  else
    numb = atoi (short_number) ;
 
  rss_prm->min_pass_len = (short)numb;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Rss min password length=%d (%s)", (int)rss_prm->min_pass_len, short_number);
 
  msg_ptr = CS_get_fld (short_number ,
                        msg_ptr,
                        sizeof(short_number) -1,
                        C_MAX_EXPIRE);
  if (msg_ptr EQ NULL)
     goto cleanup;
   if (strlen(short_number) EQ 0)
     numb = EMPTY_NUMBER;
  else if (strcmp (short_number, BACKSLASH_STR) EQ 0)
    numb = IGNORE_NUMBER ;
  else
    numb = atoi (short_number) ;
 
  rss_prm->max_expire = (short)numb;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Rss max expire=%d (%s)", (int)rss_prm->max_expire, short_number);
 
  msg_ptr = CS_get_fld (short_number ,
                        msg_ptr,
                        sizeof(short_number) -1,
                        C_MAX_LOGINS);
  if (msg_ptr EQ NULL)
     goto cleanup;
  if (strlen(short_number) EQ 0)
     numb = EMPTY_NUMBER;
  else if (strcmp (short_number, BACKSLASH_STR) EQ 0)
    numb = IGNORE_NUMBER ;
  else
    numb = atoi (short_number) ;
 
  rss_prm->max_logins = (short)numb;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Rss max logins=%d (%s)", (int)rss_prm->max_logins, short_number);
 
  cleanup:
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
} /* END - CS_get_rss function */
 
/****************************************************
 * Procedure Name: CS_get_ace
 * Description   : retrieve ace structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked whenever a message contains an ACE
 * structure - and there is a need to analyse and decompose it into an
 * API ACE structure.
 * In addition the function updates the message's pointer to piont
 * out to the first field right after the ACE details within the
 * message.
 *******************************************************************/
 
MSG_typ * CS_get_ace ( ACE_rec_typ * ace_prm,
                       MSG_typ     * msg_ptr)
{
  char                  fn[]="CS_get_ace";
  unsigned long int     max_nmb;
  int                   enum_int;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)ace_prm , NULL_CHAR , sizeof(ACE_rec_typ));
  /*
    RETRIEVE the ACE type.
  */
  enum_int= (int)ace_prm->ace_type;
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_ACE_TYP,
                             msg_ptr ,
                             C_ACE_TYPE);
  ace_prm->ace_type= (ACE_TYPE_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Ace type=%d.", (int)ace_prm->ace_type);
 
  /*
    RETRIEVE the ACE user name.
  */
  max_nmb= envir_ptr->rss_limits.max_ace_user_len;
  msg_ptr = CS_get_fld (ace_prm->user_name , msg_ptr, max_nmb,
                        C_ACE_USER);
  if (msg_ptr EQ NULL)
     goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Ace user=%s.", ace_prm->user_name);
  /*
    RETRIEVE the ACE group name.
  */
  max_nmb= envir_ptr->rss_limits.max_ace_ug_len;
  msg_ptr = CS_get_fld (ace_prm->ug_name , msg_ptr, max_nmb,
                        C_ACE_GROUP);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Ace user group=%s.", ace_prm->ug_name);
  /*
    RETRIEVE the ACE container name.
  */
  max_nmb= envir_ptr->rss_limits.max_ace_oe_len;
  msg_ptr = CS_get_fld (ace_prm->oe_name , msg_ptr, max_nmb,
                        C_ACE_CONTAINER);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4: Ace container=%s.", ace_prm->oe_name);
  /*
    RETRIEVE the ACE attributes.
  */
  enum_int= (int)ace_prm->ace_attrs;
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_ACE_ATTR,
                             msg_ptr ,
                             C_ACE_ATTRIBS);
  ace_prm->ace_attrs= (ACE_ATTR_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "5: Ace attributes=%d.", ace_prm->ace_attrs);
 
  cleanup:
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_get_ace function */
 
/****************************************************
 * Procedure Name: CS_get_ace_place
 * Description   : retrieve ace place structure from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is invoked, in order to retrieve, from the message
 * buffer the ACE PLACE details.
 * In addition the function updates the message's pointer to piont
 * out to the first field right after the ACE PLACE details within the
 * message.
 *******************************************************************/
 
MSG_typ * CS_get_ace_place ( ACE_POS_typ * ace_place,
                             MSG_typ     * msg_ptr)
{
  char                  fn[]="CS_get_ace_place";
  int                   enum_int;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    RETRIEVE the ACE place details.
  */
  enum_int= (int)(*ace_place);
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_ACE_PLACE,
                             msg_ptr,
                             C_ACE_PLACE);
  (*ace_place)= (ACE_POS_typ)enum_int;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "6: Ace place=%d.", (int)*ace_place);
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
} /* END - CS_get_ace_place function */
 
/****************************************************
 * Procedure Name: CS_get_cntrlsa_keys
 * Description   : retrieve control/sa keys from
 *                 single message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :ver 2.0.1.1
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated whenever a request to UPDATE
 * interesting keywords is arrived. The function analyzes the
 * input message keywords and builds it in ESAAPI structure.
 *********************************************************************/
 
MSG_typ * CS_get_cntrlsa_keys (RSSAPIKWD_rec_typ  ** api_prm,
                               MSG_typ             * msg_ptr)
{
  char                  fn[]="CS_get_cntrlsa_keys";
  NUM_MSGS_typ          num_msgs;
  short                 api_code;
  RSS_typ               rss_type;
  unsigned short        jj= 0, kk= 0, UpdChecksumKwd= 0;
  unsigned long         tmp_num;
  char                  str [ADINF_NUM_PRS+ ADINF_KEY_LEN+ 1], MsgCode[ADINF_TYP_LEN+ 1]="";
  unsigned long int     max_nmb;
  ESA_RC                rc= ESA_OK, rc2= ESA_OK;
  CTSAMSG_MSGID_typ     func_msg_code;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  /*
      RETRIEVE the rss type's length.
  */
 
  memset (str, '\0', sizeof(str));
  memcpy (str , (char *)msg_ptr , MSG_VAL_LEN);
  max_nmb= RSS_NAME_LEN;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	  "msg_ptr=%p str=%s max_numb=%d kwd=%s.",
	   msg_ptr,   str,   max_nmb,   C_RSS_TYP_VAL_LEN);
  rc= CS_check_nmb (str, msg_ptr, max_nmb,C_RSS_TYP_VAL_LEN);
  if (rc NE ESA_OK) {
     CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    fn , C_RSS_TYP_VAL_LEN);
     rc= ESA_ERR;
     goto cleanup;
  }
 
  sscanf (str, "%lx",(unsigned *)&tmp_num);
  msg_ptr = msg_ptr + MSG_VAL_LEN;
  /*
      RETRIEVE the Rss type.
  */
  memcpy ((char *)rss_type , (char *)msg_ptr , tmp_num);
  rss_type[tmp_num]= '\0';
  msg_ptr += tmp_num;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	   "1: Rss type %s.", rss_type);
 
 
  /*
    RETRIEVE the keywords object type (user,group,connection,ace
    or resource).
  */
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13, "msg_ptr=%c%c %d.",
			(char)(*msg_ptr), (char)*(msg_ptr+ 1), (int)ADINF_TYP_LEN);
  CLEAR (func_msg_code);
  if (memcmp ((char *)msg_ptr, MSG_USER_ADD, ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_USR_KWD_RSLT);
       strcpy (MsgCode, MSG_USER_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG_ADD , ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_GRP_KWD_RSLT);
       strcpy (MsgCode, MSG_UPD_GRP_KWD_RSLT);
  }
  else if (memcmp ((char *)msg_ptr , MSG_OE_ADD , ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_OE_KWD_RSLT);
       strcpy (MsgCode, MSG_UPD_OE_KWD_RSLT);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG2UC_ADD ,ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_U2UG_KWD_RSLT);
       strcpy (MsgCode, MSG_UPD_U2UG_KWD_RSLT);
  }
  else if (memcmp ((char *)msg_ptr , MSG_ACE_ADD ,ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_ACE_KWD_RSLT);
       strcpy (MsgCode, MSG_UPD_ACE_KWD_RSLT);
  }
  else if (memcmp ((char *)msg_ptr , MSG_RES_UPD ,ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_RES_KWD_RSLT);
       strcpy (MsgCode, MSG_UPD_RES_KWD_RSLT);
  }
  else if (memcmp ((char *)msg_ptr , MSG_RSPRM_UPD ,ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_RSS_PRM_RSLT);
       strcpy (MsgCode, MSG_RSPRM_UPD);
  }
  /* WS10078KG - Start */
  else if (memcmp ((char *)msg_ptr , MSG_XROL_ADD ,ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_XROL_KWD_RSLT);
       strcpy (MsgCode, MSG_XROL_ADD );
  }
  if (memcmp ((char *)msg_ptr, MSG_XSGP_ADD, ADINF_TYP_LEN) EQ 0) {
       strcpy (func_msg_code, MSG_UPD_XSGP_KWD_RSLT);
       strcpy (MsgCode, MSG_XSGP_ADD);
  }/* WS10078KG - Ends */
  if (strlen(func_msg_code) NE 0)
     CTSAMSG_print (func_msg_code,
                    envir_ptr->msg_admin_param.ctsamsg_handle,
                    NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    envir_ptr->msg_admin_param.rss_name,
                    envir_ptr->msg_admin_param.admin_uname,
                    envir_ptr->msg_admin_param.admin_gname,
                    envir_ptr->siid);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	   "2.1: Func Msg Code %s (%s).", func_msg_code, MsgCode);
 
  msg_ptr = CS_capi_to_api_id(&api_code , msg_ptr);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	   "api_code=%d msg_ptr=%p.",api_code, msg_ptr);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  memset (str, '\0', sizeof(str));
  /*
    TRANSLATE the number of keywords pairs.
  */
  memcpy (str , (char *)msg_ptr, ADINF_NUM_PRS);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	  "msg_ptr=%p str=%s max_numb=%d kwd=%s.",
	   msg_ptr,   str,   4096, C_NUM_KWDS);
  rc= CS_check_nmb (str,
                    msg_ptr,
                    4096,
                    C_NUM_KWDS);
  if ((rc NE ESA_OK) OR (strlen (str) EQ 0)) {
     CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    fn , C_NUM_KWDS);
     rc= ESA_ERR;
     goto cleanup;
  }
  msg_ptr = msg_ptr + ADINF_NUM_PRS;
  sscanf (str , "%x",&num_msgs);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	   "3: Num Keywords %d (%s)", num_msgs, str);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	   "num_msgs=%d msg_ptr=%p.",num_msgs, msg_ptr);
  if (num_msgs EQ 0) {
     if ((*api_prm) NE NULL)
         (*api_prm)->num_keywords= 0;
     goto cleanup;
  }
/*(  if (num_msgs EQ 0) {
     CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    fn , C_NUM_KWDS);
     rc= ESA_ERR;
     goto cleanup;
  }*/
  memset (str, '\0', sizeof(str));
  /*
    PROCESS all keywords pairs:
  */
  if ((*api_prm) EQ NULL)
     rc= CSA_alloc ((char **)api_prm,
                    0,
                    (sizeof(KWD_rec_typ) * num_msgs) +
                       sizeof(RSSAPIKWD_rec_typ),
                    1,
                    fn,
                    "Max rss-api  keywords");
  else
     rc= CSA_realloc ((char **)api_prm,
                    0,
                    (sizeof(KWD_rec_typ) * num_msgs) +
                       sizeof(RSSAPIKWD_rec_typ),
                    1);
  if (rc NE ESA_OK)
      goto cleanup;
 
  strcpy ((*api_prm)->rss, rss_type);
  (*api_prm)->num_keywords = num_msgs;
  (*api_prm)->api= api_code;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 2,
	   "Number Keywords=%d For Api=%d Rss Type=%s.",
	   (*api_prm)->num_keywords, (*api_prm)->api, (*api_prm)->rss);
 
  for (jj = 0 ; jj LT num_msgs ; jj++) {
    /*
      VERIFY that keyword type is 1a,1b,2a,2b or 00 (=entity kwds).
    */
    memcpy ((char *)(*api_prm)->kwd[jj].addtyp , (char *)msg_ptr ,
            ADINF_TYP_LEN);
    (*api_prm)->kwd[jj].addtyp[ADINF_TYP_LEN] = '\0';
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	  "%d: kwd_type=%s/%p %c/%p.",jj, (*api_prm)->kwd[jj].addtyp,
	  (*api_prm)->kwd[jj].addtyp, msg_ptr[ADINF_TYP_LEN], msg_ptr);
    if ( (memcmp((char *)msg_ptr,M_ADDINFO_1A,ADINF_TYP_LEN) NE 0)  AND
         (memcmp((char *)msg_ptr,M_ADDINFO_1B,ADINF_TYP_LEN) NE 0)  AND
         (memcmp((char *)msg_ptr,M_ADDINFO_2A,ADINF_TYP_LEN) NE 0)  AND
         (memcmp((char *)msg_ptr,M_ADDINFO_2B,ADINF_TYP_LEN) NE 0)  AND
      (memcmp((char *)msg_ptr,M_ADDINFO_ENTITY,ADINF_TYP_LEN) NE 0)) {
          CTSAMSG_print (ERR_CS_INVAL_ENUM ,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         fn , C_ADDINFO_TYP ,
                         (*api_prm)->kwd[jj].addtyp);
          rc= ESA_ERR;
          goto cleanup;
    }
 
    msg_ptr += ADINF_TYP_LEN;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	   "ii 1: Kwd Addinfo Type=%s ", (*api_prm)->kwd[jj].addtyp);
 
    /*
      VERIFY if keyword is checksummable or not
    */
    switch (msg_ptr[0]) {
     case '1':
       /*
         PROCESS all none checksummable keywords:
       */
       if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                  M_ADDINFO_1A, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_1A;
       else if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                       M_ADDINFO_1B, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_1B;
       else if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                       M_ADDINFO_2A, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_2A;
       else if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                       M_ADDINFO_2B, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_2B;
       else
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ENTITY_INFO;
       break;
 
     case '2':
       /*
         PROCESS all checksummable keywords:
       */
       if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                  M_ADDINFO_1A, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_1A_CHECK;
       else if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                       M_ADDINFO_1B, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_1B_CHECK;
       else if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                       M_ADDINFO_2A, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_2A_CHECK;
       else if (memcmp((char *)(*api_prm)->kwd[jj].addtyp,
                       M_ADDINFO_2B, ADINF_TYP_LEN) EQ 0)
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ADDINFO_2B_CHECK;
       else
          (*api_prm)->kwd[jj].keyword_type=KWD_FOR_ENTITY_CHECK;
       if (UpdChecksumKwd EQ 0) {
          for (kk= 0; kk LT envir_ptr->max_rss_num; kk++) {
             if (0  EQ (envir_ptr->interest[kk].pre_num_ugs +
                        envir_ptr->interest[kk].pre_num_oes +
                        envir_ptr->interest[kk].pre_num_users +
                        envir_ptr->interest[kk].pre_num_u2ugs) )
                continue;
             rc2=My_stricmp (envir_ptr->interest[kk].rss_type,rss_type);
	         if (rc2 EQ ESA_OK)
                envir_ptr->interest[kk].UpdChecksumKwd++;
		  }
		  UpdChecksumKwd= 1;
	   }
     break;
 
      default:
          msg_ptr[1] = '\0';
          CTSAMSG_print (ERR_CS_INVAL_ENUM ,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         fn , C_KWD_CHKSUM_TYPE , msg_ptr );
          rc= ESA_ERR;
          break;
    }
    if (rc NE ESA_OK)
       goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	   "ii 2: Kwd Keyword Type=%c ", (*api_prm)->kwd[jj].keyword_type);
 
    msg_ptr += 1;
 
    /*
      RETRIEVE the keyword's length.
    */
 
    memset (str, '\0', sizeof(str));
    memcpy (str , (char *)msg_ptr , ADINF_KEY_LEN);
    max_nmb= envir_ptr->rss_limits.max_addinfo_kwd_len;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	  "msg_ptr=%p str=%s max_nmb=%d kwd=%s.",
	   msg_ptr,   str,   max_nmb,   C_KWD_LEN);
    rc= CS_check_nmb (str, msg_ptr, max_nmb,C_KWD_LEN);
    if (rc NE ESA_OK) {
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_KWD_LEN);
      rc= ESA_ERR;
      goto cleanup;
    }
 
    sscanf (str, "%lx",(unsigned *)&tmp_num);
    (*api_prm)->kwd[jj].keylen = (short)tmp_num;
    msg_ptr = msg_ptr + ADINF_KEY_LEN;
    /*
      RETRIEVE the Keyword.
    */
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	  "%d:(%u) msg_ptr=%.*s/%p.", jj, tmp_num,tmp_num, msg_ptr, msg_ptr);
 
    memcpy ((char *)(*api_prm)->kwd[jj].keyword,
            (char *)msg_ptr,
            tmp_num);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "ii 3: Kwd & Len %.*s %d.",
		tmp_num, (*api_prm)->kwd[jj].keyword, (*api_prm)->kwd[jj].keylen);
 
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
	  "%d:(%u) KeyLen=%d Keyword=%.*s/%p.", jj, tmp_num,
	  (*api_prm)->kwd[jj].keylen,
      tmp_num,(*api_prm)->kwd[jj].keyword,(*api_prm)->kwd[jj].keyword);
 
    msg_ptr += tmp_num;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,"msg buf is <%.140s>", msg_ptr);
  } /* END - for statement */
 
cleanup:
 
  if (rc NE ESA_OK) {
      if ((*api_prm) NE NULL)
         CSA_free ((char **)api_prm);
 
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT ,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  if (rc NE ESA_OK)
     return (NULL);
  else
     return(msg_ptr);
 
} /* END - CS_get_cntrlsa_keys function */
 
/****************************************************
 * Procedure Name: CS_get_admin_params
 * Description   : Analyze "START SERVICE" message body.
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * Thiis function analyzes a "START SERVICE" message details.
 * The message structure is as follows:
 * - RSS ID length
 * - RSS ID
 * - RSS typew length
 * - RSS type.
 * - Administrator name length.
 * - Administrator.
 * - Administrator group length
 * - Administrator.
 * - Hot path length
 * - Hot path (for all service).
 * All fields are checked for validity and stored in the envir
 * variable.
 ********************************************************/
 
MSG_typ * CS_get_admin_params (ADMIN_PARAMS_rec_typ * admin_params,
                               HOT_PATH_typ         * hot_path,
                               MSG_typ              * msg_ptr)
{
  ESA_RC                rc= ESA_OK;
  char                  rss_value[RSSPRM_VALUE_LEN+ 1], HotPathStr[20]="";
  char                  fn[]="CS_get_admin_params";
  int                   enum_int;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  msg_ptr = CS_get_fld(admin_params->rss_name, msg_ptr,
                       RSS_NAME_LEN, C_RSS_NAME);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Rss name %s.",admin_params->rss_name);
 
 
  msg_ptr = CS_get_fld(admin_params->rss_type, msg_ptr,
                       RSS_NAME_LEN ,C_RSS_TYPE);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Rss type %s.",admin_params->rss_type);
 
 
  msg_ptr = CS_get_fld(admin_params->admin_uname, msg_ptr,
                       MAX_RSS_USER_NAME_LEN ,C_ADM_ID);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Admin. user name %s.",admin_params->admin_uname);
 
 
  msg_ptr = CS_get_fld(admin_params->admin_gname, msg_ptr,
                       MAX_RSS_UG_NAME_LEN, C_ADM_G);
  if (msg_ptr EQ NULL)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4: Admin group name %s.",admin_params->admin_gname);
 
  enum_int= (int)(*hot_path);
  msg_ptr = CS_get_enum_fld (&enum_int,
                             FLD_SRVC_HOT_PATH,
                             msg_ptr ,
                             C_HOTPATH);
  (*hot_path)= (HOT_PATH_typ)enum_int;
  if (msg_ptr EQ NULL)
    goto cleanup;
  if (*hot_path EQ HOT_PATH_ON)
	  strcpy (HotPathStr, "HOT_PATH_ON");
  else if (*hot_path EQ HOT_PATH_OFF)
	  strcpy (HotPathStr, "HOT_PATH_OFF");
  else if (*hot_path EQ HOT_PATH_FULL)
	  strcpy (HotPathStr, "HOT_PATH_FULL");
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "5: Hot Path %d (%s).",enum_int, HotPathStr);
 
  /* BS10100 - We want to initialize the password to blank
     to make sure that there is no garbage                 */
  strcpy(admin_params->admin_passwd, "");  /* BS10100 */
 
  strcpy (admin_params->rss_version, CTSAgentVersion());
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "Rss version is %s.",
                    admin_params->rss_version);
 
  admin_params->mode= ADMIN_MODE_NORMAL;
  admin_params->os_proc_handle= envir_ptr->os_proc_handle;
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "Os_proc_handle is %p.",
                    admin_params->os_proc_handle);
 
  envir_ptr->num_intercept_rec= 0;
/*  BSAN101541  envir_ptr->alloc_num_intercept_rec= 0; */
 
  if (strlen (admin_params->rss_name) NE 0)
  {
     rc= rssprm_get (admin_params->rss_name,
                     RSS_TYPE ,
                     RSS_NAME_LEN,
                     rss_value);
     if (rc EQ ESA_OK)
     {
        if (My_stricmp (admin_params->rss_type,
                  rss_value) NE 0)
        {
           CTSAMSG_print (ERR_MISMATCH_RSS_TYPE,
                        envir_ptr->msg_admin_param.ctsamsg_handle,
                        NULL,
                        envir_ptr->msg_admin_param.ctsamsg_dest,
                        admin_params->rss_name,
                        admin_params->rss_type,
                        rss_value);
           msg_ptr = NULL;
        }
     }
     else
        msg_ptr = NULL;
 
  }
 
 cleanup:
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_GET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
} /* END - CS_get_admin_params function */
 
/* BS10100 - Start */
/**************************************************************
 * Procedure Name: CS_get_extended_params
 * Description   : Analyze "START SERVICE" message to read extended
 *                 data. In current implementation we are
 *                 reading Application administrator credentials.
 *                 The format of extension is -
 *                 <Name of Extension><Number of fields in extension
 *                 in HEX (max F - 15 fields in one extension)>
 *                 <Length Of Field1><Field1><Length Of Field2><Field2>
 *                 Ex. PE2EX:2005TLVKP006DEVKP2 ...
 *                 PE2EX: - The name of extension
 *                 2      - Number of fields in extension
 *                 005    - Length of first field (name of admin)
 *                 TLVKP  - Field1 (Name of Administrator)
 * Input         : msg_ptr - remaining message to be parsed
 * Input/Output  : admin_parms - Updated admin structure
 *                 msg_ptr - pointer advanced to next field
 *                 or at end of buffer.
 * Return Value  : none.
 **************************************************************/
ESA_RC CS_get_extended_params (
                            EXTENDED_PARAMS_rec_typ  * extended_params,
                            ADMIN_PARAMS_rec_typ     * admin_params,
                            MSG_typ                  * msg_ptr,
                            RSS_MSG_HDR_rec_typ      * msg_hdr     )
{
   ESA_RC                rc= ESA_OK;
   char                  fn[]="CS_get_extended_params";
   ENVIRONMENT_rec_typ * envir_ptr;
   NUM_MSGS_typ          num_of_fields;
   char                  str[2];
   int                   dummy_pswd = ADMIN_DUMMY_PSWD;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
   /* Read the number of fields in extension before parsing the data */
   memset (str, NULL_CHAR, sizeof(str));
   memcpy (str, (char *)msg_ptr, 1);
 
   /* Translate hex to decimal. */
   sscanf (str, "%x", &num_of_fields);
   msg_ptr += 1;
 
   msg_ptr = CS_get_fld(extended_params->app_admin_uname, msg_ptr,
                        MAX_RSS_USER_NAME_LEN, C_APP_ADM_ID);
   if (msg_ptr EQ NULL)
   {
      rc = ESA_ERR;
      CTSAMSG_print(ERR_CS_MSG_GET_STRUCT,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest, fn);
      goto cleanup;
   }
 
   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES + 1,
      "1 : Application admin - %s.", extended_params->app_admin_uname);
 
   msg_ptr = CS_get_fld(extended_params->app_admin_passwd, msg_ptr,
                        MAX_RSS_PASSWD_LEN, C_APP_ADM_PASSWD);
   if (msg_ptr EQ NULL)
   {
      rc = ESA_ERR;
      CTSAMSG_print(ERR_CS_MSG_GET_STRUCT,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest, fn);
      goto cleanup;
   }
 
   /* If the Application Admin and Transaction Admin are same then  *
    * we update the password of Transaction admin in admin_params   *
    * and do not perform CTSRSSLogin for Application Admin.         *
    * If the transaction is keyword synchronization or update admin *
    * then we want to call the CTSRSSLogin to verify application    *
    * admin to validate the credentials.                            */
 
   if(strlen(extended_params->app_admin_passwd) EQ 0)
   {
      /* If the Application admin password is empty then *
       * we want to set the password to ADMIN_DUMMY_PSWD *
       * before calling CTSRSSLogin                      */
      ESA_DIAG_printf(ESA_COMP_ACSGPF,DIAG_COMMON,
                              "empty password ");
      memcpy(extended_params->app_admin_passwd,&dummy_pswd,4);
      extended_params->app_admin_passwd[4] = NULL_CHAR;
   }
 
   if(
       (strcmp (admin_params->admin_uname,
                 extended_params->app_admin_uname) EQ 0)
                 AND
       (msg_hdr->mhsid NE KEYWORDS_SERVICE)
                 AND
       (msg_hdr->mhsid NE ADMIN_SERVICE)
                 AND
       (msg_hdr->mhsid NE ESS_INITIAL_SERVICE)
     )
   {
       ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
             "Setting password ");
 
       strcpy(admin_params->admin_passwd,
                           extended_params->app_admin_passwd);
   }
   else
   {
      /* Call CTSRSSLogin to validate the Application administrator *
       * credentials.                                               */
 
      CS_DIAG_ADMINPRM (ESA_COMP_ACSGPF, DIAG_COMMON+ 1, FALSE);
 
      /* BS10102 Refer to admin_params instead of envir_ptr */
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
      "Call CTSRSSLogin for rss=%s adm=%s ug=%s mode=%s(%d)",
      admin_params->rss_name, extended_params->app_admin_uname,
      admin_params->admin_gname,"LOGIN_MODE_FIRST", LOGIN_MODE_FIRST);
/*BS10102 "Call CTSRSSLogin for rss=%s adm=%s ug=%s mode=%s(%d)func=%p",
      envir_ptr->msg_admin_param.rss_name,
      extended_params->app_admin_uname,
      envir_ptr->msg_admin_param.admin_gname,"LOGIN_MODE_FIRST",
      LOGIN_MODE_FIRST,envir_ptr->func_ptr.rss_login_ptr); */
 
    /*rc = CTSRSSLogin ( envir_ptr->msg_admin_param.rss_name, BS10102 */
      rc = CTSRSSLogin ( admin_params->rss_name,           /* BS10102 */
                         extended_params->app_admin_uname,
     /* BS10102          envir_ptr->msg_admin_param.admin_gname,      */
     /* BS10102 */       admin_params->admin_gname,
                         extended_params->app_admin_passwd,
                         LOGIN_MODE_FIRST,
                         &envir_ptr->handle_login,
     /* BS10102          &envir_ptr->msg_admin_param,                 */
     /* BS10102 */       admin_params,
                         &envir_ptr->msg_err);
 
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
         "<- CTSRSSLogin USA-API completed with rc=%d (%s) hndl=%p.",
         rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
         envir_ptr->handle_def_login);
 
      if (rc NE ESA_OK)
      {
         strcpy (envir_ptr->login_def_admin , "");
         goto cleanup;
      }
      /* The login was successful lets logout as we login as    *
       * the transaction admin later.                           */
 
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
      "->Call CTSRSSLogout USA-API rss=%s adm=%s ug=%s mode=%s(%d).",
      /* BS10102 Refer to admin_params instead of envir_ptr */
      admin_params->rss_name, extended_params->app_admin_uname,
      admin_params->admin_gname, "LOGOUT_MODE_LAST", LOGOUT_MODE_LAST);
      /*BS10102 envir_ptr->msg_admin_param.rss_name,
      extended_params->app_admin_uname,
      envir_ptr->msg_admin_param.admin_gname, "LOGOUT_MODE_LAST",
      LOGOUT_MODE_LAST);       ************/
 
    /*rc= CTSRSSLogout( envir_ptr->msg_admin_param.rss_name, BS10102 */
      rc= CTSRSSLogout( admin_params->rss_name,           /* BS10102 */
                        extended_params->app_admin_uname,
      /* BS10102        envir_ptr->msg_admin_param.admin_gname,      */
      /* BS10102 */     admin_params->admin_gname,
                        LOGOUT_MODE_LAST,
                        &envir_ptr->handle_login,
      /* BS10102        &envir_ptr->msg_admin_param,                 */
      /* BS10102 */     admin_params,
                        &envir_ptr->msg_err);
 
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
         "<- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
         rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
         envir_ptr->handle_login);
   }
   cleanup:
 
      ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
      return (rc);
}
/* BS10100 - Ends */
 
/****************************************************
 * Procedure Name: CS_confirm
 * Description   : sends confirmation message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to send "CONFIRMATION MESSAGE" back to the
 * ESS. It uses the details from the original message's header to
 * build a confirmation ("CC") message, sets an indication to
 * "Temporary Last" message, and sends it to the ESS.
 *********************************************************************/
 
ESA_RC  CS_confirm (RSS_MSG_HDR_rec_typ * msg_hdr)
{
  char fn[]="CS_confirm";
  char msg_cnfrm[ENC_ADD_MAX_LEN + sizeof(RSS_MSG_CNFRM_rec_typ) + 1];
  RSS_MSG_CNFRM_rec_typ   cnfrm_msg;
  char                    msg_seq [sizeof(MH_seq)+ 1];
  char                    msg_length [RSS_MSG_LEN+ 1];
  ESA_RC                  rc;
  int                     tmp_len;
  ENVIRONMENT_rec_typ   * envir_ptr;
  char                    agent_ver[RSS_VERS_LEN+1]; /* AC001 - CIQ#6 */
 
  CS_get_envir_address (&envir_ptr);
 
  tmp_len = sizeof(RSS_MSG_CNFRM_rec_typ)-
      sizeof(RSS_MSG_HDR_rec_typ)-
      RSS_NUM_MSGS- RSS_MSG_LEN;
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
              "CS_confirm: msg_hdr <%.*s> BK_msg_seq %d.",
                   sizeof (RSS_MSG_HDR_rec_typ),
                   (char *)msg_hdr,
                   (int)BK_msg_seq);
 
  /*
    CREATE a confirmation message and fill in the details from the
    original message mheader.
  */
  CLEAR_STRUCT(cnfrm_msg);
  CLEAR (msg_cnfrm);
  memcpy((char *)(&cnfrm_msg), (char *)msg_hdr ,
         sizeof(RSS_MSG_HDR_rec_typ));
 
  sprintf(msg_seq,"%06d",BK_msg_seq);
  memcpy((char *)(&cnfrm_msg.msg_hdr.mhseq), (char *)msg_seq,
         sizeof(MH_seq));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1v: Msg Seq %.*s (%d)", sizeof(MH_seq), msg_seq, BK_msg_seq);
 
  memcpy((char *)(&cnfrm_msg.msg_hdr.mhmtyp),"C",1);
  memcpy((char *)(&cnfrm_msg.msg_hdr.mhrtyp),"C",1);
  memcpy((char *)(&cnfrm_msg.msg_num_msgs),MH_NMBR_MSGS,
         strlen(MH_NMBR_MSGS));
  sprintf(msg_length,"%04X",tmp_len);
  memcpy((char *)cnfrm_msg.msg_length,(char *)msg_length, RSS_MSG_LEN);
  memcpy((char *)(&cnfrm_msg.msg_tran),MH_TRANSACTION,
         strlen(MH_TRANSACTION));
  memcpy((char *)(&cnfrm_msg.msg_seq),(char *)msg_hdr->mhseq,
         sizeof(MH_seq));
  /* AC001 - CIQ#6 - Start */
  strcpy(agent_ver, AGENT_VERSION);
  strcat(agent_ver, SA_AGENT_VERSION);
  strcpy((char *)(&cnfrm_msg.agent_version), agent_ver);
  /* AC001 - CIQ#6 - End */
  memcpy((char *)(&cnfrm_msg.msg_date),CS_date() , sizeof(CS_DATE));
  memcpy((char *)(&cnfrm_msg.msg_time),CS_time() , sizeof(CS_TIME));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2v: Date %.*s Time %.*s.", DATE_LEN, CS_date(), TIME_LEN, CS_time());
  /*
    SET indication of "Temporary Last" message
  */
  CS_set_tmp_last_msg((MSG_typ * )&cnfrm_msg);
  /*
    SEND the message.
  */
  memcpy ((char *)msg_cnfrm, (char *)&cnfrm_msg,
          strlen ((char *)&cnfrm_msg));
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
                   "CS_confirm: cnfrm_msg <%.*s> len=%d.",
                   sizeof (RSS_MSG_CNFRM_rec_typ),
                   (char *)&cnfrm_msg,
                   (int)strlen ((char *)&cnfrm_msg));
 
  rc = CS_send_msg ((MSG_typ * )msg_cnfrm ,
                    (int)strlen ((char *)&cnfrm_msg));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
                   "*****>... Confirmation message sended to IIQ/IDN with rc=%s (%d).",
				   ESA_rc2str(rc), (int)rc);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return(rc);
} /* END - CS_confirm function */
 
 /****************************************************
 * Procedure Name: CS_send_end_of_dwnld_msg
 * Description   : sends end of dwnld message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC  CS_send_end_of_dwnld_msg (RSS_MSG_HDR_rec_typ   *  msg_hdr)
 
{
  char fn[]="CS_send_end_of_dwnld";
  char                    msg_seq [sizeof(MH_seq)+ 1];
  ESA_RC                  rc;
  RSS_MSG_HDR_rec_typ     dwnld_msg;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memcpy((char *)(&dwnld_msg) , (char *)msg_hdr ,
         sizeof(RSS_MSG_HDR_rec_typ));
  memcpy(&dwnld_msg.mhmtyp,
         MSG_END_OF_DWNLD,
         strlen(MSG_END_OF_DWNLD));
 
  sprintf(msg_seq,"%06d",BK_msg_seq);
 
  memcpy((char *)(&dwnld_msg.mhseq), (char *)msg_seq, sizeof(MH_seq));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1v: Msg Seq %.*s (%d)", sizeof(MH_seq), msg_seq, BK_msg_seq);
 
  CS_set_tmp_last_msg((MSG_typ * )&dwnld_msg);
 
  rc = CS_send_msg ((MSG_typ * )&dwnld_msg ,
                    sizeof(RSS_MSG_HDR_rec_typ));
 
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
 /****************************************************
 * Procedure Name: CS_send_end_of_sync_msg
 * Description   : sends end of sync message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC  CS_send_end_of_sync_msg (RSS_MSG_HDR_rec_typ * msg_hdr)
{
  char fn[]="CS_send_end_of_sync_msg";
  char                    msg_seq [sizeof(MH_seq)+ 1];
  ESA_RC                  rc= ESA_OK;
  RSS_MSG_HDR_rec_typ     dwnld_msg;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memcpy((char *)(&dwnld_msg) , (char *)msg_hdr ,
         sizeof(RSS_MSG_HDR_rec_typ));
  memcpy((char *)(&dwnld_msg.mhmtyp),"G",1);
  memcpy((char *)(&dwnld_msg.mhrtyp),"F",1);
 
  sprintf(msg_seq,"%06d",BK_msg_seq);
 
  memcpy((char *)(&dwnld_msg.mhseq), (char *)msg_seq, sizeof(MH_seq));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1v: Msg Seq %.*s (%d)", sizeof(MH_seq), msg_seq, BK_msg_seq);
 
  CS_set_tmp_last_msg((MSG_typ * )&dwnld_msg);
 
  rc = CS_send_msg ((MSG_typ * )&dwnld_msg ,
                    sizeof(RSS_MSG_HDR_rec_typ));
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: CS_error
 * Description   : Create & send error message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to create and send an ERROR message
 * to the ESS. It is used by the CS_drop_all function to return
 * an error message to the ESS.
 **************************************************************/
 
ESA_RC  CS_error (RSS_MSG_HDR_rec_typ * msg_hdr,
                  ESA_RC                rc_input)
{
  RSS_MSG_ERR_rec_typ   cnfrm_msg;
  char                  msg_seq [sizeof(MH_seq)+ 1];
  char                  msg_length [RSS_MSG_LEN+ 1];
  char                  msg_len_str [STRUCT_LEN+ 1];
  ESA_RC                rc= ESA_OK;
  int                   tmp_len;
  int                   msg_len;
  char                  fn[]="CS_error";
  ERR_STRUCT_rec_typ    MsgErr;
 
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  CLEAR_STRUCT(MsgErr);
  if (rc_input EQ ESA_RSS_INACTIVE)
  {
     strcpy ((char *)MsgErr.err_msg_text,
             (char *)ESA_RSS_INACTIVE_MSG);
     memcpy((char *)MsgErr.err_msg_text+ strlen(ESA_RSS_INACTIVE_MSG),
            (char *)envir_ptr->msg_err.err_msg_text,
            (size_t)MIN (envir_ptr->msg_err.length,
               ERR_MSG_TEXT_LEN- ENC_ADD_MAX_LEN- MsgErr.length- 1));
     MsgErr.length= strlen (MsgErr.err_msg_text);
	 memcpy ((char *)(&envir_ptr->msg_err),
		     (char *)(&MsgErr),
		     sizeof(ERR_STRUCT_rec_typ));
  }
  /*
    CALCULATE the error message size to be inserted to RSS
    HEADER (first field).
  */
 
  tmp_len = sizeof(TRAN_typ) * 2 +
            sizeof(MH_seq) +
            sizeof(CS_DATE) +
            sizeof(CS_TIME) +
            sizeof(STRUCT_LEN) +
			MsgErr.length +
            MIN (envir_ptr->msg_err.length,
                 ERR_MSG_TEXT_LEN- ENC_ADD_MAX_LEN- MsgErr.length- 1);
  /*
    CALCULATE the total error ,message length.
  */
  msg_len = tmp_len +
            sizeof(RSS_MSG_HDR_rec_typ) +
            sizeof(RSS_NUM_MSGS) +
            sizeof(RSS_MSG_LEN);
  /*
    FILL in all details from GENERAL header and error returned.
  */
  CLEAR_STRUCT(cnfrm_msg);
 
  memcpy((char *)(&cnfrm_msg) , (char *)msg_hdr ,
         sizeof(RSS_MSG_HDR_rec_typ));
  sprintf(msg_seq,"%06d",BK_msg_seq);
 
  memcpy((char *)(&cnfrm_msg.msg_hdr.mhseq), (char *)msg_seq,
         sizeof(MH_seq));
  memcpy((char *)(&cnfrm_msg.msg_hdr.mhmtyp), MSG_OF_ERROR,
         ADINF_TYP_LEN);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1v: Msg Seq %.*s (%d)", sizeof(MH_seq), msg_seq, BK_msg_seq);
  memcpy((char *)(&cnfrm_msg.msg_num_msgs) ,MH_NMBR_MSGS,
         strlen(MH_NMBR_MSGS));
  sprintf(msg_length,"%04X",tmp_len);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2v: Msg Len %.*s (%d)", RSS_MSG_LEN, msg_length, tmp_len);
  memcpy((char *)cnfrm_msg.msg_length, (char *)msg_length,
         RSS_MSG_LEN);
  memcpy((char *)(&cnfrm_msg.msg_tran),MH_TRANSACTION,
         strlen(MH_TRANSACTION));
  memcpy((char *)(&cnfrm_msg.msg_seq), (char *)msg_hdr->mhseq ,
      sizeof(MH_seq));
  memcpy((char *)(&cnfrm_msg.msg_date), CS_date(), sizeof(CS_DATE));
  memcpy((char *)(&cnfrm_msg.msg_time), CS_time(), sizeof(CS_TIME));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3v: Date %.*s Time %.*s.", DATE_LEN, CS_date(), TIME_LEN, CS_time());
  sprintf(msg_len_str,"%03X",envir_ptr->msg_err.length);
  memcpy((char *)cnfrm_msg.msg_len, (char *)msg_len_str, STRUCT_LEN);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4v: Err Msg Len %.*s (%d)", STRUCT_LEN, msg_len_str, envir_ptr->msg_err.length);
  memcpy((char *)(&cnfrm_msg.msg_txt),
         (char *)envir_ptr->msg_err.err_msg_text,
         (size_t)MIN (envir_ptr->msg_err.length,
                      ERR_MSG_TEXT_LEN- ENC_ADD_MAX_LEN- 1));
  /*
    SET message to be "LAST" message. (tmp_last replaced to last by
    AVIW on 8/12/95 CS_set_tmp_last_msg((MSG_typ * )&cnfrm_msg);
  */
 
  CS_set_last_msg((MSG_typ * )&cnfrm_msg);
 
  if (envir_ptr->login_mode NE LOGOUT_MODE_LAST)
  {
     rc= ADM_loginout (LOGOUT_MODE_LAST, LOGIN_UNDEFINED_ADMIN, fn);
     ESA_DIAG_printf (ESA_COMP_ACSGPFR, 15,
                      "ADM_logout: rc:%s", ESA_rc2str(rc));
  }
  /*
    SEND message to ESS.
  */
  rc = CS_send_msg ((MSG_typ * )&cnfrm_msg ,
                    msg_len);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return(rc);
} /* END - CS_error function */
 
/****************************************************
 * Procedure Name: CS_date
 * Description   : Prepare a string of current date
 *                 in the form yymmdd.
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
char * CS_date (void)
{
  struct  tm       uxtime;
  time_t           ltime;
  char             cdate[7];
  static CS_DATE   date_rtn;
  char fn[]="CS_date";
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  time (&ltime);
 
  memcpy ((char *)&uxtime,
          (char *)ConvertTimeToTMStruct (&ltime, &uxtime),
          sizeof (struct tm));
 
  sprintf (cdate , "%02d%02d%02d",
           uxtime.tm_year % 100 ,
           uxtime.tm_mon  % 100 +1 ,
           uxtime.tm_mday % 100);
 
  memcpy ((char *)(&date_rtn) , (char *)cdate , sizeof(CS_DATE));
 
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
  return (date_rtn);
} /* END CS_date funcrtion */
 
/****************************************************
 * Procedure Name: CS_drop_all
 * Description   : Drop all messages until end of service
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated when an error occured while
 * handling a message within a service. The function reads
 * all the messages from mailbox until a message with "Last"
 * or "Temporary last" arrives, or until the mailbox returns an
 * error. If the "Temporary last" message received , and "ERROR"
 * message is sent to the ESS.
 * Please note that if the function is invoked from CD process,
 * the read will be performed on the mailbox only - as it is not
 * activated for "UPDATE" service.
 **************************************************************/
 
ESA_RC CS_drop_all (MSG_typ * msg_ptr,
                    ESA_RC    rc_input)
{
  char                      fn[]="CS_drop_all";
  ESA_RC                    rc= ESA_OK;
  RSS_MSG_HDR_rec_typ       msg_hdr, msg_hdr_sav;
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    SAVE the current message header aside.
  */
  memcpy((char *)(&msg_hdr), (char *)msg_ptr ,
         sizeof(RSS_MSG_HDR_rec_typ));
  memcpy((char *)(&msg_hdr_sav) , (char *)(&msg_hdr) ,
         sizeof(RSS_MSG_HDR_rec_typ));
  /*
    REPEAT until Last or Temporary_last message arrives or read
    fails:
  */
  while ((msg_hdr.mhltl NE MH_MESSAGE_LAST_TMP) AND
         (msg_hdr.mhltl NE MH_MESSAGE_LAST) AND
         (rc EQ ESA_OK) ) {
    CLEAR(msg_ptr);
    /*
      READ next message from mailbox.
    */
    rc= CS_get_next_msg (msg_ptr , & msg_hdr);
  }
 
  /*
    PROCESS when Temporary last message received:
  */
  if ( (rc EQ ESA_OK) AND
       (msg_hdr.mhltl EQ MH_MESSAGE_LAST_TMP) )
    /*
      CREATE and send ERROR message.
    */
    rc = CS_error (&msg_hdr_sav, rc_input);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_drop_all function */
 
/****************************************************
 * Procedure Name: CS_fill_in_user
 * Description   : fill user structure
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function scans GET USER request buffer for the "internal
 * requests" from specific point, receives the user name of each
 * request
 *********************************************************************/
 
MSG_typ *  CS_fill_in_user (USER_PARAMS_rec_typ   usr_prm_in[MAX_GET],
                            MSG_typ             * msg_ptr,
                            short               * act_num,
                            short                 num_msgs,
                            TRAN_rec_typ          tran[MAX_GET],
                            GET_USER_MODE       * mode)
{
  char                  fn[]="CS_fill_in_user";
  short                 i;
  NUM_MSGS_typ          msg_len;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  * act_num = num_msgs;
  * mode= GET_FREE_HANDLE_USERS;
 
  /*
    PROCESS all requests (internal messages) in message:
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "****> Fill %d Messages", (int)num_msgs);
  for (i=0; i LT  num_msgs ; i++ ){
    /*
      GET the current message's header.
    */
    msg_ptr = CS_get_singl_msg(&msg_len ,&tran[i], msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      RETRIEVE the user details from current message.
    */
    msg_ptr = CS_get_user(&usr_prm_in[i] , msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      SET the current request's GET mode (All,Wide-card or Many).
    */
    * mode = GET_MANY_USERS;
    strcpy (tran[i].name , usr_prm_in[i].user);
  } /* END - for loop */
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_FUNCTION ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
} /* END - CS_fill_in_user function */
 
/****************************************************
 * Procedure Name: CS_fill_in_ug
 * Description   : fill ug structure
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function scans GET GROUP request buffer for the "internal
 * requests" from specific point, receives the user group name of each
 * request
 *********************************************************************/
 
MSG_typ *  CS_fill_in_ug (UG_PARAMS_rec_typ      ug_prm_in[1],
                          MSG_typ              * msg_ptr,
                          short                * act_num,
                          short                  num_msgs,
                          TRAN_rec_typ           tran[1],
                          GET_GROUP_MODE       * mode)
{
  char                  fn[]="CS_fill_in_ug";
  short                 i;
  NUM_MSGS_typ          msg_len;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  * act_num = num_msgs;
  * mode= GET_FREE_HANDLE_GROUPS;
  /*
    PROCESS all requests (left) in message buffer.`:
  */
  for (i=0; i LT num_msgs ; i++ ){
    /*
      SAVE the current request's transaction & Action id.
    */
    msg_ptr = CS_get_singl_msg (&msg_len,&tran[i], msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      GET the UG details requested.
    */
    msg_ptr = CS_get_ug (&ug_prm_in[i] , msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      SET the current get mode.
    */
    * mode = GET_MANY_GROUPS;
    /*
      EXIT if the MODE was changed.
    */
  }
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "****> Fill %d Messages. Mode=%d.", (int)num_msgs, (int)*mode);
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_FUNCTION ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_fill_in_ug function */
 
 
/****************************************************
 * Procedure Name: CS_fill_in_oe
 * Description   : fill ug structure
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function scans GET CONTAINER request buffer for the "internal
 * requests" from specific point, receives the container of each
 * request
 *********************************************************************/
 
MSG_typ *  CS_fill_in_oe (OE_PARAMS_rec_typ      oe_prm_in[1],
                          MSG_typ              * msg_ptr,
                          short                * act_num,
                          short                  num_msgs,
                          TRAN_rec_typ           tran[1],
                          GET_OE_MODE          * mode)
{
  char                  fn[]="CS_fill_in_oe";
  short                 i;
  NUM_MSGS_typ          msg_len;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  * act_num = num_msgs;
  * mode= GET_FREE_HANDLE_OES;
  /*
    PROCESS all requests (left) in message buffer.`:
  */
  for (i=0; i LT num_msgs ; i++ ){
    /*
      SAVE the current request's transaction & Action id.
    */
    msg_ptr = CS_get_singl_msg (&msg_len,&tran[i], msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      GET the container details requested.
    */
    msg_ptr = CS_get_oe (&oe_prm_in[i] , msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      SET the current get mode.
    */
      * mode = GET_MANY_OES;
    /*
      EXIT if the MODE was changed.
    */
  }
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "****> Fill %d Messages. Mode=%d.", (int)num_msgs, (int)*mode);
 
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_FUNCTION ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_fill_in_oe function */
 
/****************************************************
 * Procedure Name: CS_fill_in_u2ug
 * Description   : fill user to user group structure
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function scans GET U2UG request buffer for the "internal
 * requests" from specific point, receives the user & group names of
 * each request
 *********************************************************************/
 
MSG_typ *  CS_fill_in_u2ug (UG_typ          ug_in[1],
                            USER_typ        user_in[1],
                            MSG_typ       * msg_ptr,
                            short         * act_num,
                            short           num_msgs,
                            TRAN_rec_typ    tran[1],
                            GET_CONN_MODE * mode)
{
  char                  fn[]="CS_fill_in_u2ug";
  short                 i;
  NUM_MSGS_typ          msg_len;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  * act_num = num_msgs;
  * mode= GET_FREE_HANDLE_CONNS;
 
  /*
    PROCESS all requests (left) in message buffer.`:
  */
  for (i=0; i LT  num_msgs ; i++ ){
    /*
      SAVE the current request's transaction & Action id.
    */
    msg_ptr = CS_get_singl_msg (&msg_len,&tran[i],msg_ptr);
    if (msg_ptr EQ NULL)
      break;
    /*
      GET the requested GROUP name.
    */
    msg_ptr = CS_get_fld  (ug_in[i] ,
                           msg_ptr,
                           envir_ptr->rss_limits.max_ug_len ,
                           C_GROUP_ID);
    if (msg_ptr EQ NULL)
      break;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "%d: User Group=%s.", i+ 1, ug_in[i]);
 
    /*
      GET the requested USER name.
    */
    msg_ptr = CS_get_fld  (user_in[i] ,
                           msg_ptr,
                           envir_ptr->rss_limits.max_user_len ,
                           C_USER_ID);
    if (msg_ptr EQ NULL)
      break;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "%d: User=%s.", i+ 1, user_in[i]);
    /*
      SAVE requested user & group names in transactions array.
    */
    strcpy (tran[i].name , user_in[i]);
    strcpy (tran[i].group ,ug_in[i]);
 
    /*
      SET the current get mode.
    */
    if (strlen(user_in[i]) EQ 0)
       * mode = GET_GROUPS_CONNS;
    else if (strlen(ug_in[i]) EQ 0)
       * mode = GET_USERS_CONNS;
    else * mode = GET_MANY_CONNS;
 
    /*
      EXIT if the MODE was changed.
    */
 
  }
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "****> Fill %d Messages.", (int)num_msgs);
  if (msg_ptr EQ NULL)
      CTSAMSG_print (ERR_CS_FUNCTION ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END - CS_fill_in_u2ug function */
 
/****************************************************
 * Procedure Name: CS_reset_cd_msg
 * Description   : INITIALIZE response message.
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to initialize a respond message to ESS. It
 * copies the details from the RSS GENERAL HEADER to the response
 * message and sets the message seq. number (stored in EXTERNAL data
 * BK_msg_seq).
 ********************************************************************/
 
MSG_typ * CS_reset_cd_msg (NUM_MSGS_typ        * cd_msg_len,
                           NUM_MSGS_typ        * cd_num_msgs,
                           MSG_typ             * msg_cd,
                           MSG_typ             * msg_cd_ptr,
                           RSS_MSG_HDR_rec_typ * msg_hdr_cd)
{
  char                  fn[]="CS_reset_cd_msg";
  char                  msg_seq [sizeof(MH_seq)+ 1];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13, "CS_reset_cd_msg");
 
  * cd_msg_len  = 0;
  * cd_num_msgs = 0;
 
  /*
    TRANSLATE current sequence number to hexa and copy it to saved
    message header.
  */
  sprintf(msg_seq,"%06d",BK_msg_seq);
  memcpy((char *)msg_hdr_cd->mhseq, (char *)msg_seq, sizeof(MH_seq));
 
  msg_cd =  msg_cd_ptr;
  memset((char *)msg_cd, '\0', envir_ptr->max_msg_size);
  /*
    COPY saved message header to output message header.
  */
  memcpy((char *)msg_cd , (char *)msg_hdr_cd ,
         sizeof(RSS_MSG_HDR_rec_typ));
 
  /*
    SET output pointer to point to RSS message header and calculate
    the current message length.
  */
  msg_cd = msg_cd + sizeof(RSS_MSG_HDR_rec_typ);
  * cd_msg_len = * cd_msg_len + sizeof(RSS_MSG_HDR_rec_typ);
 
  msg_cd = msg_cd + RSS_NUM_MSGS;
  * cd_msg_len = * cd_msg_len + RSS_NUM_MSGS;
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_cd);
 
} /* END - CS_reset_cd_msg function */
 
 
/****************************************************
 * Procedure Name: CS_add_cs_msg
 * Description   : add entity to cs message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function builds and adds messages, from CTSA to ESS, that
 * contails GET object results. The function is activated after each
 * call (in a loop of calls) to API get function - to ,handle all the
 * retrieved objects in that call.
 * The function handles the following objects:
 * - USERS
 * - GROUPS
 * - CONNECTION
 * - RESOURCES
 * - RSS PARAMETERS
 * - RESOURCE ACL (All ACEs)
 * For each object in the retrieved objects - a full RSS message is
 * created with Transaction & Action id from the original request, a
 * retruned codes and error message buffer (for PreScript, Actual
 * action and PostScript) - that will be filled - only for the first
 * object (from current API GET call), the object existance indicator,
 * the object details and additional information. Whenever the current
 * RSS message causes an overflow of the message buffer - the message
 * written to the CO mailbox - and the message buffer is cleared and
 * loop goes on.
 *********************************************************************/
 
MSG_typ *  CS_add_cs_msg (NUM_MSGS_typ        * cs_msg_len,
                          NUM_MSGS_typ        * cs_num_msgs,
                          short                 func_name,
                          MSG_typ             * msg_cs,
                          MSG_typ             * msg_cs_ptr,
                          short                 actual_num,
                          short                 in_num,
                          USER_PARAMS_rec_typ * usr_prm_out,
                          OE_PARAMS_rec_typ   * oe_prm_out,
                          UG_PARAMS_rec_typ   * ug_prm_out,
                          U2UG_PARAMS_rec_typ * u2ug_prm_out,
                          RES_PARAMS_rec_typ  * res_prm_out,
                          ACE_rec_typ         * ace_prm_out,
                          RSS_PARAMS_rec_typ  * rss_prm_out,
                          ADDINFO_rec_ptr     * addinfo,
                          OBJ_EXISTS_typ      * obj_exists,
                          TRAN_rec_typ        * trana,
                          RSS_MSG_HDR_rec_typ * msg_hdr,
                          RSS_MSG_HDR_rec_typ * msg_hdr_cd,
                          int                   mode,
                          ESA_RC                rc_pre,
                          ESA_RC                rc_act,
                          ESA_RC                rc_pst,
                          ERR_STRUCT_rec_typ  * err_pre,
                          ERR_STRUCT_rec_typ  * err_act,
                          ERR_STRUCT_rec_typ  * err_pst,
                          ESA_RC              * write_mbx_rc)
{
  char                  fn[]="CS_add_cs_msg";
  NUM_MSGS_typ          sngl_msg_len= 0;
  MSG_typ             * buffer_tmp;
  MSG_typ             * buffer;
  ESA_RC                rc;
  int                   i;
  int                   j;
  char                  entity[256];  /* WS10078KM */
  char                  type[16];     /* WS10078KM */
  ENVIRONMENT_rec_typ * envir_ptr;
  /*Nitin*/
  ONE_FIELD_rec_ptr     cpair = NULL; /*502839, cpair2= NULL;*/
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
                   "actual_num=%d.", (int)actual_num);
 
  CS_get_envir_address (&envir_ptr);
 
  *write_mbx_rc = ESA_OK;
 
  buffer_tmp = NULL;
  buffer     = NULL;
 
  if (actual_num EQ 0) {
    actual_num = 1;
    obj_exists[0]=OBJ_NOT_EXIST;
  }
  /*
    ALLOCATE message buffer.
  */
  rc= CSA_alloc ((char **)&buffer_tmp, 0, envir_ptr->max_msg_size,
                 1, fn, "Msg. space");
  if (rc NE ESA_OK) {
    buffer = NULL;
    goto cleanup;
  }
  /*
    PROCESS all objects in list (user,groups,connection,resources etc.)
  */
  for (i =0 ; i LT actual_num ; i++) {
 
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
       "i=%d obj_exists[i]=%d.", (int)i, (int)obj_exists[i]);
 
    buffer =  buffer_tmp; /* buffer_temp points to the rss length
                             position*/
    /*
      CLEAR message buffer.
    */
    CS_CLEARI(buffer, envir_ptr->max_msg_size);
    sngl_msg_len = 0;
 
    buffer = buffer + RSS_MSG_LEN;
    sngl_msg_len = sngl_msg_len + RSS_MSG_LEN;
 
    /*
      PREPARE index for "GET MANY" case. In this case we expect the
      actual_num (number of items found in list) to be equal to the
      in_num (number of requested items in the GET function) - BUT if
      due to some error there are more actual number of items than
      in_num - take the index to be the index of in_num item.
    */
    if (i GE in_num)
      j = in_num - 1;
    else
      j=i;
    /*
      PROCESS according to the OBJECT requested
    */
    switch (func_name) {
      /*
        PROCESS get USERS request.
      */
      case FUNC_GTUSERS:
          /*
             PROCESS get WILD-CARD users.
          */
          if (mode EQ GET_WILD_USERS)
            /*
              FIND user's ,transaction id and action id from list
              of input (wild) users.
            */
            buffer = CS_set_tran_wild_user (buffer ,
                                            in_num,
                                            &usr_prm_out[i],
                                            trana);
          /*
            PROCESS ALL (j index here equal to 0) and MANY users:
          */
          else
            /*
              SET user transaction from transactions entry.
            */
            buffer = CS_set_tran (buffer , &trana[j]);
          break;
      case FUNC_GTUG2UC:
          /*
            PROCESS GET MANY users and groups.
          */
          if ( (mode EQ GET_USERS_CONNS) OR
               (mode EQ GET_GROUPS_CONNS) )
            /*
              FIND transaction and action id from lists.
            */
            buffer = CS_set_tran_wild_u2ug (buffer ,
                                            in_num,
                                            & u2ug_prm_out[i],
                                            trana,
                                            mode);
          /*
            PROCESS ALL connections or SPECIFIC connections get request:
          */
          else
            /*
              GET specific request action & transaction id.
            */
            buffer = CS_set_tran (buffer , &trana[j]);
 
          break;
      /*
        PROCESS all other objects (groups aces etc.).
      */
      default:
          /*
            GET specific request transaction & action id.
          */
          buffer = CS_set_tran (buffer , & trana[j]);
          break;
    }
 
    sngl_msg_len = sngl_msg_len + 2 * sizeof(TRAN_typ);
    /*
      ADD the return codes and error message buffers to message buffer.
    */
    buffer = CS_return_error (buffer,
                              rc_pre,
                              rc_act,
                              rc_pst,
                              err_pre,
                              err_act,
                              err_pst,
                              &sngl_msg_len);
 
    if (buffer EQ NULL)
      goto cleanup;
 
    /*
      CLEAR the error structure after the first message - ALL other
      RSS messages, that will relate to the rest of objects, retrieved
      in the same API GET call, will have empty error structure.
    */
 
    ERROR_CLEAR(err_pre);
    ERROR_CLEAR(err_act);
    ERROR_CLEAR(err_pst);
    /*
      TRANSLATE the object's existance indicator to string.
    */
    buffer = CS_set_exist(buffer, &(obj_exists[i]));
    sngl_msg_len = sngl_msg_len + 1;
 
    if (buffer EQ NULL)
      goto cleanup;
    /*
      PROCESS when the object do exists:
    */
    if (obj_exists[i] EQ OBJ_EXIST) {
      /*
        FILL in the object's details (according to the object's type.
      */
 
 
	/*Nitin*/
      switch (func_name) {
        case FUNC_GTUSERS:
	
	
	/*Nitin More:27 July 2006: Find the user_sta in addinfo and take its value and assign to the
	user revoked status*/
		cpair = ADDINFO_search ("USER_STA", strlen ("USER_STA"), addinfo[i]->pair, addinfo[i]->num_pairs);
		
		if ( cpair)
		{
	   /*WS10082 if (strlen ((char *)cpair->value) GT 0)        */
	   if (cpair->vallen GT 0) /*WS10082 assuming vallen is set*/
		   {		
      /* No need to update ->value as USER_STA is Short WS10082 */
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
        "Value of USER_STA-%s", (char *)cpair->value);
		     usr_prm_out[i].rev_status = atoi(cpair->value);
		    }
		
		 }
    	  	else
		 {
                   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC, "No USER_STA found in Addinfo");
		 }	
	
            buffer = CS_set_user(buffer,
                                 &usr_prm_out[i],
                                 &sngl_msg_len);
 
            strcpy(entity,usr_prm_out[i].user);      /* WS10078KM */
            strcpy(type,"User");                     /* WS10078KM */
            break;
        case FUNC_GETOES:
            buffer = CS_set_oe(buffer,
                               &oe_prm_out[i],
                               &sngl_msg_len);
            strcpy(entity,oe_prm_out[i].oe);         /* WS10078KM */
            strcpy(type,"Container");                /* WS10078KM */
            break;
        case FUNC_GETUGS:
            buffer = CS_set_ug(buffer,
                               &ug_prm_out[i],
                               &sngl_msg_len);
            strcpy(entity,ug_prm_out[i].group);      /* WS10078KM */
            strcpy(type,"Group");                    /* WS10078KM */
            break;
        /* WS10078KG - Start */
        case FUNC_GETXROL:
            buffer = CS_set_ug(buffer,
                               &ug_prm_out[i],
                               &sngl_msg_len);
            strcpy(entity,ug_prm_out[i].group);
            strcpy(type,"Role");
            break;
        case FUNC_GETXSGP:
            buffer = CS_set_ug(buffer,
                               &ug_prm_out[i],
                               &sngl_msg_len);
            strcpy(entity,ug_prm_out[i].group);
            strcpy(type,"Source");
            break;
        /* WS10078KG - End */
        case FUNC_GTUG2UC:
            buffer = CS_set_fld (u2ug_prm_out[i].group,
                                 buffer,
                                 &sngl_msg_len,
                                 envir_ptr->rss_limits.max_ug_len ,
                                 C_GROUP_ID);
            ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "1: Con. Group=%s.",u2ug_prm_out[i].group);
            if (buffer EQ NULL)
              goto cleanup;
 
            buffer = CS_set_fld ((char*) u2ug_prm_out[i].user,
                                 buffer,
                                 &sngl_msg_len,
                                 envir_ptr->rss_limits.max_user_len ,
                                 C_USER_ID);
            ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "1: Con. User=%s.",u2ug_prm_out[i].user);
            if (buffer EQ NULL)
              goto cleanup;
 
            buffer = CS_set_u2ug(buffer,
                                 &u2ug_prm_out[i],
                                 &sngl_msg_len);
            sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
                    ug_prm_out[i].group,         /* WS10078KM */
                    u2ug_prm_out[i].user);       /* WS10078KM */
            strcpy(type,"Connection");           /* WS10078KM */
            break;
        case FUNC_GETRES:
            buffer = CS_set_res (buffer,
                                 &res_prm_out[i],
                                 &sngl_msg_len);
            strcpy(entity,res_prm_out[i].resource);   /* WS10078KM */
            strcpy(type,"Resource");                  /* WS10078KM */
            break;
 
		case FUNC_GTRSPRM:
            buffer = CS_set_rsprm (buffer,
                                   &rss_prm_out[i],
                                   &sngl_msg_len);
           strcpy(entity,"Rss Parameters");          /* WS10078KM */
           strcpy(type,"RSSPARM");                   /* WS10078KM */
            break;
 
		case FUNC_GTRSACL:
            buffer = CS_set_res (buffer,
                                 res_prm_out,
                                 &sngl_msg_len);
            if (buffer EQ NULL)
              goto cleanup;
 
            buffer = CS_set_ace (buffer,
                                 &ace_prm_out[i],
                                 &sngl_msg_len);
            sprintf(entity,"Resource:%s, Ace user:%s",  /* WS10078KM */
                    res_prm_out->resource,              /* WS10078KM */
                    ace_prm_out[i].user_name);          /* WS10078KM */
            strcpy(type,"ResourceAce");                 /* WS10078KM */
            break;
 
      }
 
      if (buffer EQ NULL)
        goto cleanup;
      /*
        FILL in the object's additional information buffer.
      */
  /*buffer = CS_set_addinfo(func_name, buffer, addinfo[i], WS10078KM */
      rc = CS_set_addinfo(func_name, buffer, addinfo[i],/* WS10078KM */
                              &sngl_msg_len);
 /* WS10078KM - Start */
      if (rc NE ESA_OK)
      {
         /* If rc is not ESA_OK then one or more attributes are not *
            set in buffer. We display error and continue.           */
         CTSAMSG_print (ERR_CS_MSG_BUF_OVERFLOW,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   entity,type);
 
      }
 /*
      if (buffer EQ NULL)
        goto cleanup;
  * WS10078KM - End */
    } /* end if exists */
    /*
      UPDATE the current (RSS) message length in RSS HEADER.
    */
    rc= CS_set_sngl_msg_len(buffer_tmp , sngl_msg_len);
    if (rc NE ESA_OK) {
      buffer= NULL;
      goto cleanup;
    }
    /*
      PROCESS when current RSS message - will cause the pre-prepared
      message buffer to be too long:
    */
  /*BS10127* if (* cs_msg_len + sngl_msg_len GT            */
  /*BS10127* envir_ptr->max_msg_size- ENC_ADD_MAX_LEN) {   */
      if ( (* cs_msg_len + sngl_msg_len GT           /*BS10127*/
          envir_ptr->max_msg_size- ENC_ADD_MAX_LEN)  /*BS10127*/
          OR (*cs_num_msgs GT 4090) )  {             /*BS10127*/
	  /* Set Message Type AND Record type */
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
         goto cleanup;
 
      /*
        SEND the buffer message prepared until now (excluding the
        current message buffer.
      */
      rc = CS_send_cd_msg (cs_msg_len ,
                           cs_num_msgs ,
                           msg_cs_ptr);
 
      if (rc NE ESA_OK) {
        *write_mbx_rc = rc;
        buffer = NULL;
        goto cleanup;
      }
      /*
        CLEAR the message buffer and initialize it's fields.
      */
 
      msg_cs=CS_reset_cs_msg(cs_msg_len ,
                             cs_num_msgs ,
                             msg_hdr ,
                             msg_hdr_cd,
                             msg_cs ,
                             msg_cs_ptr);
 
    } /* END - a need to send the message */
    /*
      ADD 1 to number of buffer internal messages.
    */
    *cs_num_msgs = * cs_num_msgs + 1;
    /*
      ADD current RSS message to message buffer.
    */
    msg_cs = CS_add_sngl_to_msg (msg_cs,
                                 buffer_tmp,
                                 sngl_msg_len);
 
    * cs_msg_len = * cs_msg_len  + sngl_msg_len;
 
  } /* END - for all objects received - loop */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "****> Add %d Messages.", (int)actual_num);
 
  cleanup:
 
  if (buffer EQ NULL AND buffer_tmp NE NULL) {
    CTSAMSG_print (ERR_CS_FUNCTION ,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
    msg_cs = NULL;
  }
 
  CSA_free ((char **)&buffer_tmp);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_cs);
 
}  /* EXIT - CS_add_cs_msg function */
 
/****************************************************
 * Procedure Name: CS_add_cd_msg
 * Description   : Add buffer to existing
 *                 cd message.
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function builds a response message to a single request
 * (internal message) of the following form:
 * - The RSS HEADER:
 *      This header includs the msg length, application id &
 *      the action id.
 * - The RETURN CODES structure:
 *      This structure contains, for each of the prescript,actual action
 *      & postscript  the following: the returned code; the message
 *      buffer length and the message buffer. In addition it contains
 *      an indication if the entity exists or not.
 * - The relevant ENTITY structure:
 *   That contains User, User group, User-group connection, or resource
 *   structure, followed by the object's ADDITIONAL INFORMATION - If
 *   HOT PATH was required and the objects exists and this is a set to
 *   an object of that type.
 *
 * In general - a general message buffer is build and filled up with
 * as many messages (built by the current function) as possible - and
 * whenever there is no room form more messages in the buffer - the
 * buffer is sent to the ESS and a new buffer is created.
 *
 * The current function builds a message in temporary buffer. After
 * building the buffer the function decides - if the time has come to
 * send the prepared buffer (excluding the current prepared buffer) to
 * the ESS - by testing the possibility to insert the current message's
 * buffer to the general buffer. If there is not enough room - the
 * buffer is sent, a new message buffer is created and the current
 * created message is padded to it.
 * The function returns the pointer to the message buffer. If the
 * function failed - that buffer points to NULL. If the "write mailbox"
 * request failed - it's returned code is returned in special
 * parameter, this returned code is used to take care of requests to
 * drop the service, exit the process etc.
 *********************************************************************/
 
MSG_typ *  CS_add_cd_msg (NUM_MSGS_typ        * cd_msg_len,
                          NUM_MSGS_typ        * cd_num_msgs,
                          short                 func_name,
                          HOT_PATH_typ          hot_path,
                          OE_PARAMS_rec_typ   * oe_prm,
                          UG_PARAMS_rec_typ   * ug_prm,
                          USER_PARAMS_rec_typ * usr_prm,
                          U2UG_PARAMS_rec_typ * u2ug_prm,
                          RES_PARAMS_rec_typ  * res_prm,
                          RSS_PARAMS_rec_typ  * rss_prm,
                          char                * exists,
                          ADDINFO_rec_typ     * addinfo,
                          MSG_typ             * msg_cd,
                          MSG_typ             * msg_cd_ptr,
                          RSS_MSG_HDR_rec_typ * msg_hdr_cd,
                          ESA_RC                rc_pre,
                          ESA_RC                rc_act,
                          ESA_RC                rc_pst,
                          ERR_STRUCT_rec_typ  * err_pre,
                          ERR_STRUCT_rec_typ  * err_act,
                          ERR_STRUCT_rec_typ  * err_pst,
                          TRAN_rec_typ        * tran,
                          ESA_RC              * write_mbx_rc)
{
  char                  fn[]="CS_add_cd_msg";
  NUM_MSGS_typ          sngl_msg_len;
  MSG_typ             * buffer_tmp;
  MSG_typ             * buffer;
  ESA_RC                rc;
  OBJ_EXISTS_typ        obj_exist= OBJ_IGNORED;
  ENVIRONMENT_rec_typ * envir_ptr;
  /*Nitin*/
  ONE_FIELD_rec_ptr     cpair = NULL; /*502839, cpair2= NULL;*/
  char                  entity[256];  /* WS10078KM */
  char                  type[16];     /* WS10078KM */
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
                   "%s max msg size %d", fn,
                   (int)envir_ptr->max_msg_size);
  /*
    SET the mailbox write returned code to OK - so if it will not be
    activated, it will not indicate any mailbox problem.
  */
  *write_mbx_rc = ESA_OK;
  buffer_tmp = NULL;
  buffer     = NULL;
  /*
    ALLOCATE memory for a temporary buffer to hold the current output
    message.
  */
  rc= CSA_alloc ((char **)&buffer_tmp, 0, envir_ptr->max_msg_size,
                 1, fn, "Msg. space");
  if (rc NE ESA_OK) {
    buffer = NULL;
    goto cleanup;
  }
 
  /*
    SET buffer_temp to point to the rss length position
  */
  buffer = buffer_tmp;
 
  /*
    SKIP the rss message length
  */
  buffer += RSS_MSG_LEN;
  sngl_msg_len = RSS_MSG_LEN;
 
  /*
    SET the transaction and action information
  */
  memcpy((char *)buffer , (char *)tran->transaction ,sizeof(TRAN_typ));
  buffer = buffer + sizeof(TRAN_typ);
  sngl_msg_len = sngl_msg_len + sizeof(TRAN_typ);
  memcpy((char *)buffer , (char *)tran->action , sizeof(TRAN_typ));
  buffer = buffer + sizeof(TRAN_typ);
  sngl_msg_len = sngl_msg_len + sizeof(TRAN_typ);
 
  /*
    FILL in the return codes and error messages information.
  */
 
  buffer = CS_return_error (buffer,
                            rc_pre,
                            rc_act,
                            rc_pst,
                            err_pre,
                            err_act,
                            err_pst,
                            &sngl_msg_len);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,
      "%s CS_return_error: msg_size %d(max %d)",
      fn, (int)sngl_msg_len, (int)envir_ptr->max_msg_size);
 
  if (buffer EQ NULL)
    goto cleanup;
  /*
    FILL in object existence information
  */
  else if (strcmp (exists, ENTITY_NOT_FOUND) EQ 0) {
    obj_exist = OBJ_NOT_EXIST;
    buffer = CS_set_exist(buffer , &obj_exist);
    sngl_msg_len += 1;
  }
  else if (strcmp (exists, ENTITY_FOUND)EQ 0){
    obj_exist = OBJ_EXIST;
    buffer = CS_set_exist(buffer , &obj_exist);
    sngl_msg_len += 1;
  }
  else if (strcmp (exists, ENTITY_ERR)EQ 0){
    obj_exist = OBJ_ERR;
    buffer = CS_set_exist(buffer , &obj_exist);
    sngl_msg_len += 1;
  }
  else {
    obj_exist = OBJ_IGNORED;
    buffer = CS_set_exist(buffer , &obj_exist);
    sngl_msg_len += 1;
  }
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
      "%s CS_st_exist: msg_size %d(max %d)",
      fn, (int)sngl_msg_len, (int)envir_ptr->max_msg_size);
 
  /*
    FILL in the entity information on the following terms:
    - The hot path is on.
    - The object exists.
    - The function is not interesting keywords.
    - The function not any ACE function
  */
  if ( ((hot_path  EQ HOT_PATH_ON) OR
        (hot_path  EQ HOT_PATH_FULL)) AND
       (obj_exist EQ OBJ_EXIST)) {
 
    switch (func_name) {
      case FUNC_STRSPRM:
          buffer = CS_set_rsprm(buffer , rss_prm , &sngl_msg_len);
          strcpy(entity,"Rss Parameters");          /* WS10078KM */
          strcpy(type,"RSSPARM");                   /* WS10078KM */
          break;
      case FUNC_ADDUSER:
 
 
/*Nitin More:27 July 2006: Find the user_sta in addinfo and take its value and assign to the
	user revoked status*/
		cpair = ADDINFO_search ("USER_STA", strlen ("USER_STA"), addinfo->pair, addinfo->num_pairs);
		
		if ( cpair)
		{
	   /*WS10082 if (strlen ((char *)cpair->value) GT 0)        */
	   if (cpair->vallen GT 0) /*WS10082 assuming vallen is set*/
		   {		
      /* No need to update ->value as USER_STA is Short WS10082 */
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
        "Value of USER_STA-%s", (char *)cpair->value);
		     usr_prm->rev_status = atoi(cpair->value);
		    }
		
		 }
    	  	else
		 {
                   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC, "No USER_STA found in Addinfo");
		 }	
	
          buffer = CS_set_user(buffer , usr_prm , &sngl_msg_len);
          strcpy(entity,usr_prm->user);            /* WS10078KM */
	         strcpy(type,"User");                     /* WS10078KM */
          break;
      case FUNC_DELUSER:
          buffer = CS_set_user(buffer , usr_prm , &sngl_msg_len);
          strcpy(entity,usr_prm->user);            /* WS10078KM */
          strcpy(type,"User");                     /* WS10078KM */
          break;
      case FUNC_UPDUSER:
          buffer = CS_set_user(buffer , usr_prm , &sngl_msg_len);
          strcpy(entity,usr_prm->user);            /* WS10078KM */
          strcpy(type,"User");                     /* WS10078KM */
          break;
      case FUNC_REVUSER:
          buffer = CS_set_user(buffer , usr_prm , &sngl_msg_len);
          strcpy(entity,usr_prm->user);            /* WS10078KM */
          strcpy(type,"User");                     /* WS10078KM */
          break;
      case FUNC_UPD_PASS:
          buffer = CS_set_user(buffer , usr_prm , &sngl_msg_len);
          strcpy(entity,usr_prm->user);            /* WS10078KM */
          strcpy(type,"User");                     /* WS10078KM */
          break;
      case FUNC_ADDUG:
          buffer = CS_set_ug(buffer , ug_prm ,&sngl_msg_len);
          strcpy(entity,ug_prm->group);            /* WS10078KM */
          strcpy(type,"Group");                    /* WS10078KM */
          break;
      case FUNC_DELUG:
          buffer = CS_set_ug(buffer , ug_prm ,&sngl_msg_len);
          strcpy(entity,ug_prm->group);            /* WS10078KM */
          strcpy(type,"Group");                    /* WS10078KM */
          break;
      case FUNC_UPDUG:
          buffer = CS_set_ug(buffer , ug_prm ,&sngl_msg_len);
          strcpy(entity,ug_prm->group);            /* WS10078KM */
          strcpy(type,"Group");                    /* WS10078KM */
          break;
      case FUNC_ADDOE:
          buffer = CS_set_oe(buffer , oe_prm ,&sngl_msg_len);
          strcpy(entity,oe_prm->oe);               /* WS10078KM */
          strcpy(type,"Container");                /* WS10078KM */
          break;
      case FUNC_DELOE:
          buffer = CS_set_oe(buffer , oe_prm ,&sngl_msg_len);
          strcpy(entity,oe_prm->oe);               /* WS10078KM */
          strcpy(type,"Container");                /* WS10078KM */
          break;
      case FUNC_UPDOE:
          buffer = CS_set_oe(buffer , oe_prm ,&sngl_msg_len);
          strcpy(entity,oe_prm->oe);               /* WS10078KM */
          strcpy(type,"Container");                /* WS10078KM */
          break;
      case FUNC_ADDU2UG:
          buffer = CS_set_fld ( u2ug_prm->group ,
                                buffer ,
                                &sngl_msg_len,
                                envir_ptr->rss_limits.max_ug_len ,
                                C_GROUP_ID);
          ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "1: Con. Group=%s.",u2ug_prm->group);
          if (buffer NE NULL)
            buffer = CS_set_fld ( u2ug_prm->user , buffer ,
                                  &sngl_msg_len,
                                  envir_ptr->rss_limits.max_user_len ,
                                  C_USER_ID);
            ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "2: Con. User=%s.",u2ug_prm->user);
          if (buffer NE NULL)
            buffer = CS_set_u2ug(buffer ,  u2ug_prm ,&sngl_msg_len);
          break;
      case FUNC_DELU2UG:
          buffer = CS_set_fld ( u2ug_prm->group , buffer ,
                                &sngl_msg_len,
                                envir_ptr->rss_limits.max_ug_len ,
                                C_GROUP_ID);
          ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "1: Con. Group=%s.",u2ug_prm->group);
          if (buffer NE NULL)
            buffer = CS_set_fld ( u2ug_prm->user ,
                                  buffer ,
                                  &sngl_msg_len,
                                  envir_ptr->rss_limits.max_user_len ,
                                  C_USER_ID);
          ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "2: Con. User=%s.",u2ug_prm->user);
          if (buffer NE NULL)
            buffer = CS_set_u2ug(buffer ,  u2ug_prm ,&sngl_msg_len);
          sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
                  u2ug_prm->group,             /* WS10078KM */
                  u2ug_prm->user);             /* WS10078KM */
          strcpy(type,"Connection");           /* WS10078KM */
          break;
      case FUNC_UPDU2UG:
          buffer = CS_set_fld ( u2ug_prm->group ,
                                buffer ,
                                &sngl_msg_len,
                                envir_ptr->rss_limits.max_ug_len ,
                                C_GROUP_ID);
          ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "1: Con. Group=%s.",u2ug_prm->group);
          if (buffer NE NULL)
            buffer = CS_set_fld ( u2ug_prm->user ,
                                  buffer ,
                                  &sngl_msg_len,
                                  envir_ptr->rss_limits.max_user_len ,
                                  C_USER_ID);
          ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "2: Con. User=%s.",u2ug_prm->user);
          if (buffer NE NULL)
            buffer = CS_set_u2ug(buffer ,  u2ug_prm ,&sngl_msg_len);
          sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
                  u2ug_prm->group,             /* WS10078KM */
                  u2ug_prm->user);             /* WS10078KM */
          strcpy(type,"Connection");           /* WS10078KM */
          break;
      case FUNC_ADDRES:
          buffer = CS_set_res(buffer , res_prm ,&sngl_msg_len);
          strcpy(entity,res_prm->resource);   /* WS10078KM */
          strcpy(type,"Resource");            /* WS10078KM */
          break;
      case FUNC_DELRES:
          buffer = CS_set_res(buffer , res_prm ,&sngl_msg_len);
          strcpy(entity,res_prm->resource);   /* WS10078KM */
          strcpy(type,"Resource");            /* WS10078KM */
          break;
      case FUNC_UPDRES:
          buffer = CS_set_res(buffer , res_prm ,&sngl_msg_len);
          strcpy(entity,res_prm->resource);   /* WS10078KM */
          strcpy(type,"Resource");            /* WS10078KM */
          break;
    }/* END of switch according to the function*/
 
    if (buffer EQ NULL)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
        "%s CS_set_FUNC???: msg_size %d(max %d)",
        fn, (int)sngl_msg_len, (int)envir_ptr->max_msg_size);
    /*
      FILL in the additional information.
    */
    /* WS10078KM - Start *
    buffer = CS_set_addinfo(func_name,buffer,addinfo,&sngl_msg_len);*/
    rc = CS_set_addinfo(func_name,buffer,addinfo,&sngl_msg_len);
    /*
    if (buffer EQ NULL)
      goto cleanup;
    */
    if (rc NE ESA_OK)
    {
       /* If rc is not ESA_OK then one or more attributes are not *
          set in buffer. We display error and continue.           */
       CTSAMSG_print (ERR_CS_MSG_BUF_OVERFLOW,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 entity,type);
    }
    /* WS10078KM - End */
  }  /* END - entity should be filled in (hot path is on...) */
 
  /*
    FILL in the current message length (in the begining of the RSS
    HEADER).
  */
  rc= CS_set_sngl_msg_len(buffer_tmp , sngl_msg_len);
  if (rc NE ESA_OK) {
    buffer= NULL;
    goto cleanup;
  }
 
  /*
    PROCESS when the current message will cause the TOTAL message
    length to overflow the allocated buffer:
  */
  /*BS10127* if (*cd_msg_len + sngl_msg_len GE
        envir_ptr->max_msg_size- ENC_ADD_MAX_LEN) {  */
    if( (*cd_msg_len + sngl_msg_len GE             /*BS10127*/
        envir_ptr->max_msg_size- ENC_ADD_MAX_LEN)  /*BS10127*/
        OR (*cd_num_msgs GT 4090) ) {              /*BS10127*/
    /*
      SEND the message buffer (that does NOT include the current
      message) to the ESS.
    */
    rc = CS_send_cd_msg (cd_msg_len ,
                         cd_num_msgs ,
                         msg_cd_ptr);
    if (rc NE ESA_OK) {
      *write_mbx_rc = rc;
      buffer = NULL;
      goto cleanup;
    }
    /*
      PREPARE a new message buffer (the GENERAL header and
      APPLICATION header).
    */
    msg_cd=CS_reset_cd_msg(cd_msg_len ,
                           cd_num_msgs ,
                           msg_cd ,
                           msg_cd_ptr,
                           msg_hdr_cd);
  } /* END - send the message buffer to ESS (without current message
       buffer) */
  /*
    ADD 1 to total number of messages (internal messages) in message
    buffer.
  */
 
  *cd_num_msgs += 1;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "****> Add %d Message.", (int)*cd_num_msgs);
 
  /*
    APPEND the current message buffer to the general message buffer.
  */
  msg_cd = CS_add_sngl_to_msg (msg_cd,buffer_tmp,sngl_msg_len);
  /*
    ADD current message length to the total message buffer length.
  */
  * cd_msg_len += sngl_msg_len;
 
  cleanup:
 
  if (buffer EQ NULL) {
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
    msg_cd = NULL;
  }
  /*
    FREE the temporary allocated message buffer.
  */
  CSA_free ((char **)&buffer_tmp);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_cd);
 
} /* END - CS_add_cd_msg function */
 
/****************************************************
 * Procedure Name: CS_send_end_of_srv_instance
 * Description   : Send end of service message to CO
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION:
 * =====================
 *
 * This function prepare and sends "END_OF_SERVICE" control
 * message (equal to "374" Octal or "FC" hexa) to the CO.
 **********************************************************/
 
void CS_send_end_of_srv_instance (void)
{
  char                  fn[]="CS_send_end_of_srv_instance";
  char                  buffer[2];
  int                   size;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  /*
    * prepare EEND OF SERVICE control message.
  */
 
  size = 1;
  strcpy(buffer, CD_SRVR_MSG_SRVC_DONE);
  /*
    SEND the control message to CO
  */
  rc = CS_send_msg (buffer , size);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
} /* END - CS_send_end_of_srv_instance function */
 
/****************************************************
 * Procedure Name: CS_send_cd_msg
 * Description   : send message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 /*WS10080 - Update description*
 * This function is used in order to broadcast a message to IIQ/IDN.
 * It updates the number of internal messages in the APPLICATION HEADER
 * structure - and sends the message via mailbox to the IOGATE process.
 * If PE2 version is 04 or above then messages with large message size
 * is also supported and the message is divided into sub-messages.
 *********************************************************************/
 
ESA_RC CS_send_cd_msg (NUM_MSGS_typ * cd_msg_len,
                       NUM_MSGS_typ * cd_num_msgs,
                       MSG_typ      * msg_cd_ptr)
{
  char                  fn[]="CS_send_cd_msg";
  ESA_RC                rc= ESA_OK;
  char                  tmp_len[RSS_NUM_MSGS+ 1];
  MSG_typ             * msg_num_ptr;
  ENVIRONMENT_rec_typ * envir_ptr;
  /* WS10080 Start */
  MSG_typ             * one_msg_buff = NULL;
  MSG_typ             * msg_cd_buff_ptr = NULL;
  MSG_typ             * one_msg_buff_ptr = NULL;
  int                   remaining_msg_len=0;
  int                   one_msg_len=0;
  int                   buff_sent_one_msg_len=0;
  RSS_MSG_HDR_rec_typ   msg_hdr;
  char                  msg_hdr_mhltl;
  /* WS10080 End */
 
  CS_get_envir_address (&envir_ptr);
 
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  /*
    FILL in the number of included messages.
  */
  msg_num_ptr = msg_cd_ptr+ sizeof(RSS_MSG_HDR_rec_typ);
  sprintf(tmp_len,"%03X", * cd_num_msgs);
  memcpy((char *)msg_num_ptr , (char *)tmp_len, RSS_NUM_MSGS);
 
  /* WS10080 Start -                                       *
  /*      Before we send message we check following:       *
   *      1. max_msg_size is greater than 32723.           *
   *      max_msg_size is GT 32723 only if its new PE2.    *
   *      one_msg_size is also set if its new PE2.         *
   *      2. If the cd_msg_len is greater than             *
   *         envir_ptr->one_msg_size.                      *
   * If above conditions are satisfied then we divide the  *
   * message into sub-messages and send multiple sub-      *
   * messages. The message type and record type for first  *
   * message is kept original and for subsequent sub-      *
   * messages it is 'S' and 'M' respectively. The MHDLAST  *
   * character is set to blank and only for last message   *
   * it is set to one received from original message.      *
   * Along with above change the header is modified by     *
   * incrementing the sequence number.                     */
 
  if( ((int)envir_ptr->max_msg_size GT 32723) AND
      (int)*cd_msg_len GT (int)envir_ptr->one_msg_size )
  {
     ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                     "Allocating memory to one_msg_buff of len <%d>",
                     (int) envir_ptr->one_msg_size);
 
     rc = CSA_alloc ((char **)&one_msg_buff_ptr, 0,
                     (int) envir_ptr->one_msg_size + 1,
                      1, fn, "one_msg_buff");
     if (rc NE ESA_OK)
        goto cleanup;
 
     one_msg_buff = one_msg_buff_ptr;
     msg_cd_buff_ptr = msg_cd_ptr;
     remaining_msg_len = (int)* cd_msg_len;
 
     one_msg_len = (int)envir_ptr->one_msg_size;
 
     ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                     "remaining_msg_len <%d>, one_msg_len <%d>",
                     remaining_msg_len, one_msg_len);
 
     /* Take backup of header to use it as it is *
      * while preparing sub-messages.            */
     memcpy ((char *)(&msg_hdr), (char *)msg_cd_ptr,
                             sizeof (RSS_MSG_HDR_rec_typ));
     msg_hdr_mhltl = msg_hdr.mhltl;
     /* Change MHDLAST to BLANK which is an indication *
      * that its not the last message.                 */
     msg_hdr.mhltl = MH_MESSAGE_LAST_NOT;
 
     memcpy ((char *)msg_cd_ptr, (char *)(&msg_hdr),
                                sizeof (RSS_MSG_HDR_rec_typ));
 
     /* Set message type and record type  *
      * as 'S' and 'M' for sub messages.  */
     msg_hdr.mhmtyp = 'S';
     msg_hdr.mhrtyp = 'M';
 
     memset ((char *)one_msg_buff, '\0',
                                   (int) envir_ptr->one_msg_size + 1);
 
     ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                     "msg_cd_buff_ptr <%p>",msg_cd_buff_ptr);
 
     /* The buffer to copy number of characters from message */
     buff_sent_one_msg_len = one_msg_len;
     do
     {
        /* Copy characters of length one_msg_len *
         * to form a sub message                 */
        memcpy((char *)one_msg_buff,
                  msg_cd_buff_ptr, buff_sent_one_msg_len);
 
        ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
          "Before cs_send_msg one_msg_buff_ptr=<%p> one_msg_len <%d>",
                        one_msg_buff_ptr, one_msg_len);
 
        /* Send the sub message  */
        rc = CS_send_msg (one_msg_buff_ptr, one_msg_len);
 
        remaining_msg_len = remaining_msg_len - buff_sent_one_msg_len;
        ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                        "remaining_msg_len - %d", remaining_msg_len);
 
        if(remaining_msg_len GT 0)
        {
           /* Advance the pointer to start of next sub   *
            * message or end of last sub message sent.   */
           msg_cd_buff_ptr = msg_cd_buff_ptr + buff_sent_one_msg_len;
           ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                           "after cs_send_msg msg_cd_buff_ptr=<%p>",
                           msg_cd_buff_ptr);
 
           /* Reset the buffer */
           one_msg_buff = one_msg_buff_ptr;
           memset ((char *)one_msg_buff, '\0',
                                      (int) envir_ptr->one_msg_size);
           one_msg_len = 0;
 
           /* Check if the next sub message is last message by        *
            * calculating the size of message remaining. Set MHDLAST  *
            * to the original value if its a last sub-message.        */
 
           if(remaining_msg_len GT
              ((int)envir_ptr->one_msg_size -
                                        sizeof(RSS_MSG_HDR_rec_typ)) )
           {
              buff_sent_one_msg_len = (int) envir_ptr->one_msg_size -
                                          sizeof (RSS_MSG_HDR_rec_typ);
           }
           else
           {
              /* This is last message */
              msg_hdr.mhltl = msg_hdr_mhltl;
              buff_sent_one_msg_len = remaining_msg_len;
           }
           /* Copy the header value to form next sub message */
           memcpy ((char *)one_msg_buff,(char *)(&msg_hdr),
                                         sizeof(RSS_MSG_HDR_rec_typ));
           one_msg_buff += sizeof(RSS_MSG_HDR_rec_typ);
           one_msg_len += sizeof(RSS_MSG_HDR_rec_typ);
           ESA_DIAG_printf(ESA_COMP_ACSGPF, 21,
                     "one_msg_buff_ptr after copying header <%.400s>",
                     (char *)one_msg_buff_ptr);
 
           one_msg_len += buff_sent_one_msg_len;
 
           /* If its aggregation transaction then set a flag to *
            * indicate that the confirmation can be sent when   *
            * last sub-message is sent. The stop_req_msgs is    *
            * set to non zero value for download transaction.   */
           if((BK_msg_seq GT 0) AND
              (envir_ptr->stop_req_msgs GT 0) AND
              (BK_msg_seq % envir_ptr->stop_req_msgs) EQ 0)
           {
              send_mh_message_last_tmp = TRUE;
           }
 
           ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                           "one_msg_len<%d>,remaining_msg_len<%d>",
                           one_msg_len, remaining_msg_len);
 
           ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                           "buff_sent_one_msg_len<%d>",
                           buff_sent_one_msg_len);
 
        }
     }while((msg_cd_buff_ptr NE NULL) AND (remaining_msg_len GT 0));
     CSA_free ((char **)&one_msg_buff_ptr);
  }/*End if((int)*cd_msg_len GT (int)envir_ptr->one_msg_size )*/
  /* WS10080 End */
  else                                                     /*WS10080*/
  {                                                        /*WS10080*/
     /*
       SEND message.
     */
     rc = CS_send_msg (msg_cd_ptr , (int)* cd_msg_len);
  }                                                        /*WS10080*/
 
  cleanup:                                                 /*WS10080*/
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_send_cd_msg function */
 
/****************************************************
 * Procedure Name: CS_return_error
 * Description   : Add rc and error to buffer
 *
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to build the "RETURN CODE STRUCTURE" in
 * a message buffer as part of building response to ESS request.
 * The RETURN CODE STRUCTURE is as follows
 * - PreScript Return code
 * - Actual action (API CALL) retrun code
 * - PostScript Return code
 * - PreScript message buffer length
 * - PreScript message buffer
 * - Actual action message buffer length
 * - Actual action message buffer.
 * - PostScript message buffer length
 * - PostrScript message buffer.
 * - Object exists indicator (Not filled by current function).
 *
 * The function receives the return codes and error structures and
 * builds the message according to the specified structure.
 *********************************************************************/
 
MSG_typ *  CS_return_error (MSG_typ             * buffer,
                            ESA_RC                rc_pre,
                            ESA_RC                rc_act,
                            ESA_RC                rc_pst,
                            ERR_STRUCT_rec_typ  * err_pre,
                            ERR_STRUCT_rec_typ  * err_act,
                            ERR_STRUCT_rec_typ  * err_pst,
                            NUM_MSGS_typ        * sngl_msg_len)
{
  char fn[]="CS_return_error";
  MESA_RC               mrc_pre;
  MESA_RC               mrc_act;
  MESA_RC               mrc_pst;
  int                   err_len;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    TRANSLATE API return codes to protocol return codes.
  */
  mrc_pre = CS_esarc_to_mesarc (rc_pre);
  mrc_act = CS_esarc_to_mesarc (rc_act);
  mrc_pst = CS_esarc_to_mesarc (rc_pst);
 
  /*
    VERIFY that the message buffer may contain the ERROR buffer.
  */
 
  err_len= sizeof(MESA_RC)*3 + (STRUCT_LEN* 3)+
      err_pst->length+ err_act->length+ err_pre->length;
 
  if (envir_ptr->max_msg_size - ENC_ADD_MAX_LEN
      LT *sngl_msg_len + err_len) {
    CTSAMSG_print (ERR_CS_ERR_OVERFLOW,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn ,err_len+ *sngl_msg_len,
                   envir_ptr->max_msg_size);
 
    buffer= NULL;
    goto cleanup;
  }
 
  /*
    FILL in the return codes.
  */
  memcpy((char *)buffer , (char *)(&mrc_pre) , sizeof(MESA_RC));
  buffer += sizeof(MESA_RC);
  * sngl_msg_len += sizeof(MESA_RC);
 
  memcpy((char *)buffer , (char *)(&mrc_act) , sizeof(MESA_RC));
  buffer += sizeof(MESA_RC);
  * sngl_msg_len += sizeof(MESA_RC);
 
  memcpy((char *)buffer , (char *)(&mrc_pst) , sizeof(MESA_RC));
  buffer += sizeof(MESA_RC);
  * sngl_msg_len += sizeof(MESA_RC);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "1: Pre-Act_Post str.path=%.*s%.*s%.*s.",
     sizeof(MESA_RC), (char *)(&mrc_pre), sizeof(MESA_RC),
	 (char *)(&mrc_act), sizeof(MESA_RC), (char *)(&mrc_pst));
  /*
    FILL in the PreScript error buffer.
  */
  if (err_pre->length GT MAX_ERR_MSG_LEN) {
    CTSAMSG_print (ERR_CS_PRESCRIPT_MSGLEN,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn ,err_pre->length, MAX_ERR_MSG_LEN);
    err_len= MAX_ERR_MSG_LEN;
  }
  else
    err_len= err_pre->length;
 
  sprintf(buffer ,"%03X",err_len);
  buffer += STRUCT_LEN;
  * sngl_msg_len += STRUCT_LEN;
 
 
  memcpy((char *)buffer , (char *)err_pre->err_msg_text,
         (unsigned)err_len);
  buffer +=  err_len;
  * sngl_msg_len += err_len;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "2: Pre Err Text Path=%03X%.*s.",
     err_len, err_len, (char *)err_pre->err_msg_text);
 
  /*
    FILL in the actual action error buffer.
  */
  if (err_act->length GT MAX_ERR_MSG_LEN) {
    CTSAMSG_print (ERR_CS_ACTUAL_MSGLEN,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn ,err_act->length, MAX_ERR_MSG_LEN);
    err_len= MAX_ERR_MSG_LEN;
  }
  else
    err_len= err_act->length;
  sprintf(buffer ,"%03X",(unsigned)err_len);
  buffer += STRUCT_LEN;
  * sngl_msg_len += STRUCT_LEN;
 
  memcpy((char *)buffer , (char *)err_act->err_msg_text,
         (unsigned)err_len);
  buffer += err_len;
  * sngl_msg_len += err_len;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "3: Act Err Text Path=%03X%.*s.",
     err_len, err_len, (char *)err_act->err_msg_text);
 
  /*
    FILL in the PostScript error buffer.
  */
  if (err_pst->length GT MAX_ERR_MSG_LEN) {
    CTSAMSG_print (ERR_CS_POSTSCRIPT_MSGLEN,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn ,err_pst->length, MAX_ERR_MSG_LEN);
    err_len= MAX_ERR_MSG_LEN;
  }
  else
    err_len= err_pst->length;
  sprintf(buffer ,"%03X",err_len);
  buffer += STRUCT_LEN;
  * sngl_msg_len += STRUCT_LEN;
 
  memcpy((char *)buffer , (char *)err_pst->err_msg_text,
         (unsigned)err_len);
  buffer += err_len;
  * sngl_msg_len += err_len;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "4: Post Err Text Path=%03X%.*s.",
     err_len, err_len, (char *)err_pst->err_msg_text);
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
} /* END - CS_return_error */
 
/****************************************************
 * Procedure Name: CS_set_tran
 * Description   : Copy Transaction & Action id to message
 *                 buffer.
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_set_tran (MSG_typ       * buffer,
                       TRAN_rec_typ  * tran)
{
  char fn[]="CS_set_tran";
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  memcpy((char *)buffer ,  (char *)tran , sizeof(TRAN_typ) *2 );
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Tran=%.*s.",
	  sizeof(TRAN_typ) *2, tran);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer + sizeof(TRAN_typ) * 2);
} /* END - CS_set_tran function */
 
/****************************************************
 * Procedure Name: CS_set_tran_wild_user
 * Description   : Find tarnsaction id for user wild cases
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to find for a specific retrieved used, out
 * of a list of users that were retrieved due to GET users with
 * wild card, what is it's Transaction & Action id. The input to the
 * API GET function is a LIST of wild card users - and the GET function
 * is called in loop until all relevant users were retrieved. There is
 * no DIRECT way to know for each user - to what wild-card user, from
 * the input list - it relates. The only way to guess it, is to find
 * in the wild-cards users - a user that it's name, up to the astrik
 * character, is the heading substring of the output username.
 * When finding the related input wild card username - the function
 * takes this user request's Transaction & Action id - and set it for
 * requested user message.
 * PLEASE NOTE !!
 * 1. This method is good as long as no wild user in the input list
 *    intersects with another wild user in that list.
 * 2. The function does NOT take in account wild card users that
 *    contains "?" - question mark characters - that should also be
 *    implemented !! However - as up today - this feature is not yet
 *    supported by any RSS.
 *********************************************************************/
 
MSG_typ * CS_set_tran_wild_user (MSG_typ             * buffer,
                                 short                 in_num,
                                 USER_PARAMS_rec_typ * usr_prm_out,
                                 TRAN_rec_typ        * tran)
{
  char fn[]="CS_set_tran_wild_user";
  int   i;
  /*
    PROCESS all users in input list for API GET call:
  */
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  for (i=0 ; i LT in_num ; i++)
    /*
      EXIT if the user name in in_list is the heading string in the
      input user name.
    */
    if (memcmp ((char *)tran[i].name ,
                (char *)usr_prm_out->user,
               (size_t)strlen(tran[i].name)) EQ 0)
      break;
  /*
    SET the transaction & action id - of the wild-card user found (if
    it was found) - or set a fixed string with the value "T_UNNONE".
  */
  if (i LT in_num)
  {
    memcpy((char *)buffer , (char *)tran[i].transaction ,
           sizeof(TRAN_typ) *2 );
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Tran=%.*s.",
  	  sizeof(TRAN_typ) *2, tran[i].transaction);
  }
  else
  {
    memcpy((char *)buffer ,  TRAN_UNNONE , sizeof(TRAN_typ) *2 );
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Tran=%.*s.",
  	  sizeof(TRAN_typ) *2, TRAN_UNNONE);
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer + sizeof(TRAN_typ) * 2);
 
} /* END - CS_set_tran_wild_user */
 
/****************************************************
 * Procedure Name: CS_set_tran_wild_u2ug
 * Description   : set tarnsaction id for u2ug wild cases
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated in order to find the request's
 * Transaction & Action id,  for specific USER - GROUP connection,
 * that was retrieved as part of API GET U2UG with MANY USERS or MANY
 * GROUPS mode. The function scanns the input requests array after the
 * requested user/group accordingly, and returns its Transaction
 * details.
 *********************************************************************/
 
MSG_typ * CS_set_tran_wild_u2ug (MSG_typ             * buffer,
                                 short                 in_num,
                                 U2UG_PARAMS_rec_typ * u2ug_prm_out,
                                 TRAN_rec_typ        * tran,
                                 int                   mode)
{
  char                    fn[]="CS_set_tran_wild_u2ug";
  int                     i;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    PROCESS according to the MODE of GET connections:
  */
  switch (mode) {
    /*
      PROCESS when the list of connections to a given list of users
      was requested:
    */
    case GET_MANY_USERS:
        /*
          SCAN all input users list - until you find the current
          connection's user.
        */
        for (i=0 ; i LT in_num ; i++)
          if (strncmp (tran[i].name ,
                       u2ug_prm_out->user,
                       envir_ptr->rss_limits.max_user_len) EQ 0)
            break;
        break;
    /*
      PROCESS when the list of connections to a given lis og groups
      was requested:
    */
    default:
        /*
          SCAN all input groups - until you find the current
          connection's user.
        */
        for (i=0 ; i LT in_num ; i++)
          if (strncmp (tran[i].group ,
                       u2ug_prm_out->group,
                       envir_ptr->rss_limits.max_ug_len) EQ 0)
            break;
        break;
  }
  /*
    SET the transaction & action id - of the requested user/group found
    - or set a fixed string with the value "T_UNNONE".
  */
  if (i LT in_num)
  {
    memcpy((char *)buffer ,  (char *)tran[i].transaction ,sizeof(TRAN_typ) *2 );
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Tran %.*s.", sizeof(TRAN_typ) *2, tran[i].transaction);
  }
  else
  {
    memcpy((char *)buffer ,  TRAN_UNNONE , sizeof(TRAN_typ) *2 );
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Tran %.*s.", sizeof(TRAN_typ) *2, TRAN_UNNONE);
  }
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer + sizeof(TRAN_typ) * 2);
 
} /* END - CS_set_tran_wild_u2ug function */
 
/****************************************************
 * Procedure Name: CS_set_not_last_msg
 * Description   : Set NOT (temporary) last message (= BLANK)
 *                 indication in message's GENERAL KEADER.
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
void CS_set_not_last_msg (MSG_typ       * msg_ptr)
{
  RSS_MSG_HDR_rec_typ   msg_hdr;
  char fn[]="CS_set_not_last_msg";
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
 
  memcpy ((char *)(&msg_hdr) , (char *)msg_ptr ,sizeof(RSS_MSG_HDR_rec_typ));
  msg_hdr.mhltl = MH_MESSAGE_LAST_NOT;
  memcpy ((char *)msg_ptr , (char *)(&msg_hdr) ,sizeof(RSS_MSG_HDR_rec_typ));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Last Msg Tran %c.", MH_MESSAGE_LAST_NOT);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CS_set_not_last_msg function */
 
/****************************************************
 * Procedure Name: CS_set_tmp_last_msg
 * Description   : SET tmp last message indication to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
void CS_set_tmp_last_msg (MSG_typ       * msg_ptr)
{
  RSS_MSG_HDR_rec_typ   msg_hdr;
  char fn[]="CS_set_tmp_last_msg";
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
 
  memcpy ((char *)(&msg_hdr) , (char *)msg_ptr ,sizeof(RSS_MSG_HDR_rec_typ));
  msg_hdr.mhltl = MH_MESSAGE_LAST_TMP;
  memcpy ((char *)msg_ptr , (char *)(&msg_hdr) ,sizeof(RSS_MSG_HDR_rec_typ));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Last Msg Tran %c.", MH_MESSAGE_LAST_TMP);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CS_set_tmp_last_msg function */
 
/****************************************************
 * Procedure Name: CS_set_plat
 * Description   : copy platform structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_set_plat (MSG_typ                 * buffer,
                       PLATFORM_DETAIL_rec_typ * plat_prm,
                       NUM_MSGS_typ            * msg_len)
{
  char                  fn[]="CS_set_plat";
  char                  chk[CHECKSUM_LEN+1];
  char                  max_size[NUM_DIGITS_IN_INT+ 1];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  buffer = CS_set_fld ( plat_prm->version , buffer , msg_len,
                        sizeof (MH_version) , C_VERSION);
  ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
               "%s=%s.", C_VERSION, plat_prm->version);
  CLEAR (max_size);
 
  sprintf (max_size, "%d", envir_ptr->max_msg_size);
 
  if (buffer NE NULL)
  {
    buffer = CS_set_fld (max_size, buffer, msg_len, NUM_DIGITS_IN_INT, C_MAX_MSG_SIZE);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "%s=%s.",C_MAX_MSG_SIZE, max_size);
  }
  CLEAR (chk);
  memcpy ((char *)chk, (char *)plat_prm->kwds_checksum, CHECKSUM_LEN);
  if (buffer NE NULL)
  {
    buffer = CS_set_fld ( chk , buffer , msg_len, CHECKSUM_LEN, C_CHEKSUM);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "%s=%s.",C_CHEKSUM, chk);
  }
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
}
 
 
/****************************************************
 * Procedure Name: CS_set_exist
 * Description   : Copy exists indication to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to prepare an object's existance indicator
 * in ESS - CTSA message buffer. The enumarated type indicator is
 * translated to an equivelent string - and the buffer pointer is
 * advanced by 1.
 ******************************************************************/
 
MSG_typ * CS_set_exist (MSG_typ         * buffer,
                        OBJ_EXISTS_typ  * obj_exist)
{
  char                    fn[]="CS_set_exist";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
  /*
    TRANSLATE enumerated type existance indicator to string indicator.
  */
  if      (* obj_exist EQ OBJ_EXIST)
    memcpy((char *)buffer , M_OBJ_EXIST , 1);
  else if (* obj_exist EQ OBJ_NOT_EXIST)
    memcpy((char *)buffer , M_OBJ_NOT_EXIST , 1);
  else if (* obj_exist EQ OBJ_ERR)
    memcpy((char *)buffer , M_OBJ_ERR , 1);
  else if (* obj_exist EQ OBJ_IGNORED)
    memcpy((char *)buffer , M_OBJ_UNKNOWN , 1);
  else {
    *((char *)buffer+ 1)= '\0';
    CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn , C_OBJ_EXIST);
    ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
    return (NULL);
  }
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "Exist Code %c (%d)",
	  (char *)buffer, (int)*obj_exist);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
  if (buffer EQ NULL)
    return (NULL);
  return(buffer + 1);
 
} /* END - CS_set_exist function */
 
 
 
/****************************************************
 * Procedure Name: CS_set_rsprm
 * Description   : copy rss_params structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a rss_params structure - as received
 * from an API call, and builds in a rss_params structure as defined
 * in the ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_rsprm (MSG_typ             * buffer,
                        RSS_PARAMS_rec_typ  * rss_prm,
                        NUM_MSGS_typ        * msg_len)
{
  char                    str_number[6];
  char                    fn[]="CS_set_rsprm";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  if (rss_prm->min_pass_len EQ EMPTY_NUMBER)
     str_number[0] = '\0';
  else
     sprintf (str_number, "%d", rss_prm->min_pass_len);
  buffer = CS_set_fld ( str_number , buffer , msg_len,
                        sizeof(str_number) , C_MIN_PASS_LEN);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "1: Min Pwd Len=%s (%d)",
	  str_number, (int)rss_prm->min_pass_len);
 
  if (rss_prm->max_expire EQ EMPTY_NUMBER)
     str_number[0] = '\0';
  else
     sprintf (str_number, "%d", rss_prm->max_expire);
  if (buffer NE NULL)
     buffer = CS_set_fld ( str_number , buffer , msg_len,
                           sizeof(str_number) , C_MAX_EXPIRE);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "2: Max Expire=%s (%d)",
	  str_number, (int)rss_prm->max_expire);
 
  if (rss_prm->max_logins EQ EMPTY_NUMBER)
     str_number[0] = '\0';
  else
     sprintf (str_number, "%d", rss_prm->max_logins);
  if (buffer NE NULL)
     buffer = CS_set_fld ( str_number , buffer , msg_len,
                           sizeof(str_number) , C_MAX_LOGINS);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1, "3: Max Logins=%s (%d)",
	  str_number, (int)rss_prm->max_logins);
 
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_rsprm function */
 
 
 
/****************************************************
 * Procedure Name: CS_set_user
 * Description   : Copy user structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a users parameter structure - as received
 * from an API call, and builds in a user structure as defined in the
 * ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_user (MSG_typ             * buffer,
                       USER_PARAMS_rec_typ * usr_prm_out,
                       NUM_MSGS_typ        * msg_len)
{
  char                    fn[]="CS_set_user";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    FILL in user name.
  */
  buffer = CS_set_fld ( usr_prm_out->user ,
                        buffer ,
                        msg_len,
                        envir_ptr->rss_limits.max_user_len ,
                        C_USER_ID);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: User=%s.",usr_prm_out->user);
  /*
    FILL in user's parent oe name.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( usr_prm_out->parent_oe,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_oe_len ,
                          C_USER_OE_PARENT);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Parent Container=%s.",usr_prm_out->parent_oe);
  /*
    FILL in user's default group.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( usr_prm_out->def_group,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_ug_len ,
                          C_USER_GROUP_DEF);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Default Group=%s.",usr_prm_out->def_group);
  /*
    FILL in the user's password.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( usr_prm_out->passwd ,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_pwd_len ,
                          C_USER_PASSWD);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4: Password ***...* (len=%d)", strlen (usr_prm_out->passwd) );
  /*
    FILL in the user's password lifetime indicator.
  */
  if (buffer NE NULL)
    buffer = CS_set_enum_fld ((int)usr_prm_out->passwd_life,
                              FLD_USER_PASSWD_LIFE,
                              buffer,
                              msg_len ,
                              C_USER_PASSWD_LIFE);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "5: Password Life=%d.",(int)usr_prm_out->passwd_life);
  /*
    FILL in the user revoke/reastor status.
  */
  if (buffer NE NULL)
    buffer = CS_set_enum_fld ((int)usr_prm_out->rev_status,
                              FLD_USER_STAT,
                              buffer,
                              msg_len ,
                              C_USER_REV_STATUS);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "6: Revoke Status=%d.",(int)usr_prm_out->rev_status);
  /*
    FILL in the user type indicator.
  */
  if (buffer NE NULL)
    buffer = CS_set_enum_fld ((int)usr_prm_out->user_admin,
                              FLD_USER_ADMIN,
                              buffer,
                              msg_len ,
                              C_USER_ADMIN);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "7: Admin Type=%d.",(int)usr_prm_out->user_admin);
 
  /*
    FILL the def group action (for changed def group)
   */
  if (buffer NE NULL)
    buffer = CS_set_enum_fld ((int)usr_prm_out->def_ug_action ,
                             FLD_DEF_UG_ACTION ,
                             buffer ,
                             msg_len ,
                             C_DEF_UG_ACTION);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "8: Default User Action=%d.",(int)usr_prm_out->def_ug_action);
 
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_user function */
 
/****************************************************
 * Procedure Name: CS_set_ug
 * Description   : copy ug structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a group's parameter structure - as received
 * from an API call, and builds in a group structure as defined in the
 * ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_ug  (MSG_typ             * buffer,
                      UG_PARAMS_rec_typ   * ug_prm_out,
                      NUM_MSGS_typ        * msg_len)
{
  char                    fn[]="CS_set_ug";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    FILL in the group name.
  */
  buffer = CS_set_fld ( ug_prm_out->group ,
                        buffer ,
                        msg_len,
                        envir_ptr->rss_limits.max_ug_len ,
                        C_GROUP_ID);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: User Group=%s.", ug_prm_out->group);
 
  /*
    FILL in the grpoup's parent oe name.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( ug_prm_out->parent_oe ,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_oe_len ,
                          C_GROUP_OE_PARENT);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Parent Container=%s.", ug_prm_out->parent_oe);
 
  /*
    FILL in the group's parent group name.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( ug_prm_out->parent_group ,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_ug_len ,
                          C_GROUP_PARENT);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Parent Group=%s.", ug_prm_out->parent_group);
 
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_ug function */
 
/****************************************************
 * Procedure Name: CS_set_oe
 * Description   : copy oe structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a container's parameter structure - as
 * received from an API call, and builds in a container structure as
 * defined in the ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_oe  (MSG_typ             * buffer,
                      OE_PARAMS_rec_typ   * oe_prm_out,
                      NUM_MSGS_typ        * msg_len)
{
  char                    fn[]="CS_set_oe";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    FILL in the container name.
  */
  buffer = CS_set_fld ( oe_prm_out->oe ,
                        buffer ,
                        msg_len,
                        envir_ptr->rss_limits.max_oe_len ,
                        C_OE_ID);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Container=%s.", oe_prm_out->oe);
  /*
    FILL in the container's parent container name.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( oe_prm_out->parent ,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_oe_len ,
                          C_OE_PARENT);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Parent Container=%s.", oe_prm_out->parent);
 
  /*
    FILL in the container type
  */
  if (buffer NE NULL)
     buffer = CS_set_enum_fld ((int)oe_prm_out->attr,
                               FLD_OE_ATTR,
                               buffer,
                               msg_len ,
                               C_OE_ATTR);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Container Attribute=%d.", (int)oe_prm_out->attr);
 
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_oe function */
 
/****************************************************
 * Procedure Name: CS_set_u2ug
 * Description   : copy u2ug structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a user to group connection  parameter
 * structure - as received from an API call, and builds in a connection
 * structure as defined in the ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_u2ug  (MSG_typ             * buffer,
                        U2UG_PARAMS_rec_typ * u2ug_prm_out,
                        NUM_MSGS_typ        * msg_len)
{
  char                  fn[]="CS_set_u2ug";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    FILL in the connection type (admin,audit etc.)
  */
  buffer = CS_set_enum_fld ((int)u2ug_prm_out->u2ug_admin_data,
                            FLD_U2UG_CONN,
                            buffer,
                            msg_len ,
                            C_U2UG_MISC);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Connection Type=%d.", (int)u2ug_prm_out->u2ug_admin_data);
 
  /*
    FILL in the connection attribute (default user's group)
  */
  if (buffer NE NULL)
    buffer = CS_set_enum_fld ((int)u2ug_prm_out->u2ug_attr_data,
                            FLD_U2UG_ATTR,
                            buffer,
                            msg_len,
                            C_U2UG_ATTRS);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4: Connection Attribute=%d.", (int)u2ug_prm_out->u2ug_attr_data);
 
  /*
    FILL in the user's default group.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld (u2ug_prm_out->def_group,
                         buffer,
                         msg_len,
                         envir_ptr->rss_limits.max_ug_len ,
                         C_U2UG_DEF_GROUP);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "5: Connection Default Group=%s.", u2ug_prm_out->def_group);
 
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_u2ug function */
 
/****************************************************
 * Procedure Name: CS_set_res
 * Description   : copy res structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a resource parameter structure - as received
 * from an API call, and builds in a resource structure as defined in
 * the ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_res (MSG_typ             * buffer,
                      RES_PARAMS_rec_typ  * res_prm_out,
                      NUM_MSGS_typ        * msg_len)
{
  char                    fn[]="CS_set_res";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    FILL in the resource name.
  */
  buffer = CS_set_fld ( res_prm_out->resource,
                        buffer ,
                        msg_len,
                        envir_ptr->rss_limits.max_resource_len ,
                        C_RES_ID);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Resource=%s.", res_prm_out->resource);
  /*
    FILL in the resource type.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( res_prm_out->restype,
                          buffer , msg_len,
                          envir_ptr->rss_limits.max_restype_len ,
                          C_RES_TYP);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Resource Type=%s.", res_prm_out->restype);
  /*
    FILL in the resource oe parent.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld ( res_prm_out->parent_oe ,
                          buffer ,
                          msg_len,
                          envir_ptr->rss_limits.max_oe_len ,
                          C_RES_OE_PARENT);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Parent Container=%s.", res_prm_out->parent_oe);
 
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_res function */
 
 
/****************************************************
 * Procedure Name: CS_set_ace
 * Description   : copy ace structure to message
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function receives a resource ACE - as received
 * from an API call, and builds in a resource ACE structure as
 * defined in the ESS - CTSA protocol.
 *********************************************************************/
 
MSG_typ * CS_set_ace (MSG_typ             * buffer,
                      ACE_rec_typ         * ace_prm_out,
                      NUM_MSGS_typ        * msg_len)
{
  char                    fn[]="CS_set_ace";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    FILL in the ACE type.
  */
  buffer = CS_set_enum_fld ((int)ace_prm_out->ace_type,
                            FLD_ACE_TYP,
                            buffer,
                            msg_len ,
                            C_ACE_TYPE);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Ace Type=%d.", (int)ace_prm_out->ace_type);
  /*
    FILL in the ACE user name.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld (ace_prm_out->user_name,
                         buffer ,
                         msg_len,
                         envir_ptr->rss_limits.max_ace_user_len ,
                         C_ACE_USER);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Ace User=%s.", (int)ace_prm_out->user_name);
  /*
    FILL in the ACE group.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld (ace_prm_out->ug_name,
                         buffer ,
                         msg_len,
                         envir_ptr->rss_limits.max_ace_ug_len ,
                         C_ACE_GROUP);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "3: Ace Group=%s.", (int)ace_prm_out->ug_name);
  /*
    FILL in the ACE container.
  */
  if (buffer NE NULL)
    buffer = CS_set_fld (ace_prm_out->oe_name,
                         buffer ,
                         msg_len,
                         envir_ptr->rss_limits.max_ace_oe_len ,
                         C_ACE_CONTAINER);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "4: Ace Container=%s.", (int)ace_prm_out->oe_name);
  /*
    FILL in the ACE attributes.
  */
  if (buffer NE NULL)
    buffer = CS_set_enum_fld ((int)ace_prm_out->ace_attrs,
                              FLD_ACE_ATTR,
                              buffer,
                              msg_len ,
                              C_ACE_ATTRIBS);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "5: Ace Attrs=%d.", (int)ace_prm_out->ace_attrs);
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer);
 
} /* END - CS_set_ace function */
 
/****************************************************
 * Procedure Name: CS_add_sngl_to_msg
 * Description   : Append single message (internal message) to message
 *                 buffer.
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_add_sngl_to_msg (MSG_typ     * msg_cs ,
                              MSG_typ     * buffer_tmp ,
                              NUM_MSGS_typ  sngl_msg_len)
{
  char fn[]="CS_add_sngl_to_msg";
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  /*
    COPY hte internal message at the buffer's end.
  */
  memcpy((char *)msg_cs , (char *)buffer_tmp , sngl_msg_len);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Singl Msg=%.*s.", (int)sngl_msg_len, msg_cs);
  /*
    RETURN the pointer to the next internal message location.
  */
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_cs + sngl_msg_len);
 
} /* END - CS_add_sngl_to_msg function */
 
/****************************************************
 * Procedure Name: CS_reset_cs_msg
 * Description   : reset_cs_message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is similar to CS_reset_cd_msg - and should be
 * REPLACED by it!!!!!!
 *********************************************************************/
 
MSG_typ * CS_reset_cs_msg (NUM_MSGS_typ        * cs_msg_len,
                           NUM_MSGS_typ        * cs_num_msgs,
                           RSS_MSG_HDR_rec_typ * msg_hdr,
                           RSS_MSG_HDR_rec_typ * msg_hdr_cd,
                           MSG_typ             * msg_cs,
                           MSG_typ             * msg_cs_ptr)
{
  char                    mhseq [sizeof(MH_seq)+ 1];
  ENVIRONMENT_rec_typ   * envir_ptr;
  char                    fn[]="CS_reset_cs_msg";
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
  * cs_msg_len  = 0;
  * cs_num_msgs = 0;
 
  msg_cs =   msg_cs_ptr;
  memset((char *)msg_cs, '\0', envir_ptr->max_msg_size);
 
  sprintf(mhseq,"%06d",BK_msg_seq);
  memcpy ((char *)msg_hdr->mhseq, (char *)(&mhseq), sizeof(MH_seq));
  memcpy ((char *)msg_hdr_cd->mhseq, (char *)(&mhseq), sizeof(MH_seq));
  msg_hdr_cd->mhltl = MH_MESSAGE_LAST_NOT;
  msg_hdr->mhltl = MH_MESSAGE_LAST_NOT;
 
  if (envir_ptr->p_main_name EQ ESA_ACS_PROC)
    memcpy ((char *)msg_cs, (char *)msg_hdr,
            sizeof(RSS_MSG_HDR_rec_typ));
  else
    memcpy ((char *)msg_cs , (char *)msg_hdr_cd ,
           sizeof(RSS_MSG_HDR_rec_typ));
 
  * cs_msg_len= *cs_msg_len+
        sizeof(RSS_MSG_HDR_rec_typ)+ RSS_NUM_MSGS;
 
  msg_cs = msg_cs + sizeof(RSS_MSG_HDR_rec_typ)+ RSS_NUM_MSGS;
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_cs);
} /* END - CS_reset_cs_msg function */
 
/****************************************************
 * Procedure Name: CS_esarc_tomesarc
 * Description   : convert esa-api rc to comm rc
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function translates ESA API RETURN CODE, that was returned
 * from PreScript,PostScript or API to the return code as defined
 * in the communication protocol of the CTSA and ESS.
 *********************************************************************/
 
MESA_RC  CS_esarc_to_mesarc (ESA_RC rc)
{
 switch ((int)rc) {
   case ESA_OK:            return(MESA_OK);
   case ESA_SKIP:          return(MESA_SKIP);
   case ESA_WARN:          return(MESA_WARN);
   case ESA_ERR:           return(MESA_ERR);
   case ESA_FATAL:         return(MESA_FATAL);
   case ESA_LOCKED:        return(MESA_LOCKED);
   case ESA_KEY_NOT_FOUND: return(MESA_KEY_NOT_FOUND);
   case ESA_DUP_KEY:       return(MESA_DUP_KEY);
   case ESA_EOF:           return(MESA_EOF);
   case ESA_NOT_SUPP:      return(MESA_NOT_SUPP);
   case ESA_RC_UNDEFINED:  return(MESA_RC_UNDEFINED);
   case ESA_RC_VOID:       return(MESA_RC_VOID);
   case ESA_RSS_INACTIVE:  return(MESA_RSS_INACTIVE);
 
 }
 return(MESA_RC_UNDEFINED);
 
} /* END -CS_esarc_to_mesarc function */
 
/****************************************************
 * Procedure Name: CS_capi_to_api_id
 * Description   : Convert communication api id (in string
 *                 format) to api id (in enumarated type) format.
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_capi_to_api_id (short   * api ,
                             MSG_typ * msg_ptr)
{
  ENVIRONMENT_rec_typ   * envir_ptr;
  char                    fn[]="CS_capi_to_api_id";
  char                    ApiStr[30]="", MsgCode[ADINF_TYP_LEN+ 1]="";
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
  if      (memcmp ((char *)msg_ptr , MSG_USER_ADD , 2) EQ 0)  {
     * api = FUNC_ADDUSER;
     strcpy (ApiStr, "FUNC_ADDUSER");
     strcpy (MsgCode, MSG_USER_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_USER_DEL , 2) EQ 0) {
     * api = FUNC_DELUSER;
     strcpy (ApiStr, "FUNC_DELUSER");
     strcpy (MsgCode, MSG_USER_DEL);
  }
  else if (memcmp ((char *)msg_ptr , MSG_USER_UPD , 2) EQ 0) {
     * api = FUNC_UPDUSER;
     strcpy (ApiStr, "FUNC_UPDUSER");
     strcpy (MsgCode, MSG_USER_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_USER_REVOKE , 2) EQ 0) {
     * api = FUNC_REVUSER;
     strcpy (ApiStr, "FUNC_REVUSER");
     strcpy (MsgCode, MSG_USER_REVOKE);
  }
  else if (memcmp ((char *)msg_ptr , MSG_PASSWRD_UPD , 2) EQ 0) {
     * api = FUNC_UPD_PASS;
     strcpy (ApiStr, "FUNC_UPD_PASS");
     strcpy (MsgCode, MSG_PASSWRD_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG_ADD , 2) EQ 0) {
     * api = FUNC_ADDUG;
     strcpy (ApiStr, "FUNC_ADDUG");
     strcpy (MsgCode, MSG_UG_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG_DEL , 2) EQ 0) {
     * api = FUNC_DELUG;
     strcpy (ApiStr, "FUNC_DELUG");
     strcpy (MsgCode, MSG_UG_DEL);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG_UPD , 2) EQ 0) {
     * api = FUNC_UPDUG;
     strcpy (ApiStr, "FUNC_UPDUG");
     strcpy (MsgCode, MSG_UG_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_OE_ADD , 2) EQ 0) {
     * api = FUNC_ADDOE;
     strcpy (ApiStr, "FUNC_ADDOE");
     strcpy (MsgCode, MSG_OE_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_OE_DEL , 2) EQ 0) {
     * api = FUNC_DELOE;
     strcpy (ApiStr, "FUNC_DELOE");
     strcpy (MsgCode, MSG_OE_DEL);
  }
  else if (memcmp ((char *)msg_ptr , MSG_OE_UPD , 2) EQ 0) {
     * api = FUNC_UPDOE;
     strcpy (ApiStr, "FUNC_UPDOE");
     strcpy (MsgCode, MSG_OE_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG2UC_ADD , 2) EQ 0) {
     * api = FUNC_ADDU2UG;
     strcpy (ApiStr, "FUNC_ADDU2UG");
     strcpy (MsgCode, MSG_UG2UC_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG2UC_DEL , 2) EQ 0) {
     * api = FUNC_DELU2UG;
     strcpy (ApiStr, "FUNC_DELU2UG");
     strcpy (MsgCode, MSG_UG2UC_DEL);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG2UC_UPD , 2) EQ 0) {
     * api = FUNC_UPDU2UG;
     strcpy (ApiStr, "FUNC_UPDU2UG");
     strcpy (MsgCode, MSG_UG2UC_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_ACE_ADD , 2) EQ 0) {
     * api = FUNC_ADDACE;
     strcpy (ApiStr, "FUNC_ADDACE");
     strcpy (MsgCode, MSG_ACE_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_ACE_DEL , 2) EQ 0) {
     * api = FUNC_DELACE;
     strcpy (ApiStr, "FUNC_DELACE");
     strcpy (MsgCode, MSG_ACE_DEL);
  }
  else if (memcmp ((char *)msg_ptr , MSG_ACE_UPD , 2) EQ 0) {
     * api = FUNC_UPDACE;
     strcpy (ApiStr, "FUNC_UPDACE");
     strcpy (MsgCode, MSG_ACE_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_RES_UPD , 2) EQ 0) {
     * api = FUNC_UPDRES;
     strcpy (ApiStr, "FUNC_UPDRES");
     strcpy (MsgCode, MSG_RES_UPD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_USER_GET , 2) EQ 0) {
     * api = FUNC_GTUSERS;
     strcpy (ApiStr, "FUNC_GTUSERS");
     strcpy (MsgCode, MSG_USER_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG_GET , 2) EQ 0) {
     * api = FUNC_GETUGS;
     strcpy (ApiStr, "FUNC_GETUGS");
     strcpy (MsgCode, MSG_UG_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_OE_GET , 2) EQ 0) {
     * api = FUNC_GETOES;
     strcpy (ApiStr, "FUNC_GETOES");
     strcpy (MsgCode, MSG_OE_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG2UC_GET , 2) EQ 0) {
     * api = FUNC_GTUG2UC;
     strcpy (ApiStr, "FUNC_GTUG2UC");
     strcpy (MsgCode, MSG_UG2UC_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_RES_GET , 2) EQ 0) {
     * api = FUNC_GETRES;
     strcpy (ApiStr, "FUNC_GETRES");
     strcpy (MsgCode, MSG_RES_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_RSACL_GET , 2) EQ 0) {
     * api = FUNC_GTRSACL;
     strcpy (ApiStr, "FUNC_GTRSACL");
     strcpy (MsgCode, MSG_RSACL_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_RSPRM_GET , 2) EQ 0) {
     * api = FUNC_GTRSPRM;
     strcpy (ApiStr, "FUNC_GTRSPRM");
     strcpy (MsgCode, MSG_RSPRM_GET);
  }
  else if (memcmp ((char *)msg_ptr , MSG_USER_TO_ESS , 2) EQ 0) {
     * api = FUNC_RSUSER;
     strcpy (ApiStr, "FUNC_RSUSER");
     strcpy (MsgCode, MSG_USER_TO_ESS);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG_TO_ESS , 2) EQ 0) {
     * api = FUNC_RSUG;
     strcpy (ApiStr, "FUNC_RSUG");
     strcpy (MsgCode, MSG_UG_TO_ESS);
  }
  else if (memcmp ((char *)msg_ptr , MSG_OE_TO_ESS , 2) EQ 0) {
     * api = FUNC_RSOE;
     strcpy (ApiStr, "FUNC_RSOE");
     strcpy (MsgCode, MSG_OE_TO_ESS);
  }
  else if (memcmp ((char *)msg_ptr , MSG_UG2UC_TO_ESS , 2) EQ 0) {
     * api = FUNC_RSU2UG;
     strcpy (ApiStr, "FUNC_RSU2UG");
     strcpy (MsgCode, MSG_UG2UC_TO_ESS);
  }
  else if (memcmp ((char *)msg_ptr , MSG_PLATFORM_DETAIL , 2) EQ 0) {
     * api = FUNC_PLATFORM_DETAIL;
     strcpy (ApiStr, "FUNC_PLATFORM_DETAIL");
     strcpy (MsgCode, MSG_PLATFORM_DETAIL);
  }
  /* WS10078KG - Start */
  else if (memcmp ((char *)msg_ptr , MSG_XROL_ADD , 2) EQ 0) {
     * api = FUNC_ADDXROL;
     strcpy (ApiStr, "FUNC_ADDXROL");
     strcpy (MsgCode, MSG_XROL_ADD);
  }
  else if (memcmp ((char *)msg_ptr , MSG_XSGP_ADD , 2) EQ 0) {
     * api = FUNC_ADDXSGP;
     strcpy (ApiStr, "FUNC_ADDXSGP");
     strcpy (MsgCode, MSG_XSGP_ADD);
  } /* WS10078KG - End */
  else {
     *((char *)msg_ptr+ 2)= '\0';
     CTSAMSG_print (ERR_CS_INVAL_ENUM,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, C_API, msg_ptr);
    ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
    return (NULL);
 }
  msg_ptr +=2;
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	   "2.2: Api %d (%s) Msg Code %s.", *api, ApiStr, MsgCode);
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
  return(msg_ptr);
 
} /* END CS_capi_to_api_id function */
 
/****************************************************
 * Procedure Name: CS_snd_rss_msg
 * Description   : Send message to ESS about rss changes
 * Input         : rss ,
 *               : api
 *               : data (u2ug_data_rec_typ)
 *               : user_param,
 *               : ug_param
 *               : u2ug_param,
 *               : addinfo
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_snd_rss_msg (RSS_MSG_HDR_rec_typ     * msg_hdr,
                       RSS_typ                   rss,
                       short                     api,
                       void                    * msg_struct,
                       ADDINFO_rec_typ         * addinfo)
{
  char                  fn[]="CS_snd_rss_msg";
  NUM_MSGS_typ          sngl_msg_len, full_msg_len;
  MSG_typ             * msg_ptr, * buffer, * buffer_tmp;
  RSS_MSG_HDR_rec_typ   msg_hdr_cd;
  ESA_RC                rc= ESA_OK;
  char                  mhseq [sizeof(MH_seq)+ 1];
  OBJ_EXISTS_typ        obj_exist;
  char                  rss_typ[RSSPRM_VALUE_LEN];
  ENC_ERR_rec_typ       encryption_err;
  RSS_typ               ess_rss, ess_rss_typ;
 
  PLATFORM_DETAIL_rec_typ * plat_prm= NULL;
  USER_PARAMS_rec_typ     * user_prm= NULL;
  OE_PARAMS_rec_typ       * oe_prm= NULL;
  UG_PARAMS_rec_typ       * ug_prm= NULL;
  CONNECT_PARAMS_rec_typ  * conn_prm= NULL;
  LOGEVT_PARAMS_rec_typ   * logevt_prm= NULL;
  RSS_PARAMS_rec_typ      * rsprm_prm= NULL;
  RSS_STATUS_typ          * rss_status;
  ENVIRONMENT_rec_typ     * envir_ptr;
  /* WS10080 Start */
  MSG_typ                 * one_msg_buff = NULL;
  MSG_typ                 * msg_cd_buff_ptr = NULL;
  MSG_typ                 * one_msg_buff_ptr = NULL;
  int                       remaining_msg_len=0;
  int                       one_msg_len=0;
  int                       buff_sent_one_msg_len=0;
  RSS_MSG_HDR_rec_typ       tmp_msg_hdr;
  char                      msg_hdr_mhltl;
  /* WS10080 End */
 
  char                  entity[256];  /* WS10078KM */
  char                  type[16];     /* WS10078KM */
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Api=%d BK_MsgSeq=%d P_MainName=%d rss=%s.",
	  (int)api, (int)BK_msg_seq, (int)envir_ptr->p_main_name, rss);
 
  rc= CSA_alloc ((char **)&msg_ptr, 0, envir_ptr->max_msg_size,
                 1, fn, "Msg. space");
  if (rc NE ESA_OK) {
    msg_ptr = NULL ;
    goto cleanup;
  }
 
  buffer = msg_ptr;
 
  if (envir_ptr->p_main_name EQ ESA_ACS_PROC) {
    CS_set_not_last_msg ((MSG_typ *)msg_hdr);
    rc= CS_api_to_capi_id (api, (MSG_typ *)msg_hdr);
    if (rc NE ESA_OK)
      goto cleanup;
    sprintf(mhseq,"%06d",BK_msg_seq);
    memcpy ((char *)msg_hdr->mhseq, (char *)mhseq, strlen (mhseq));
    memcpy ((char *)buffer, (char *)msg_hdr,
            sizeof (RSS_MSG_HDR_rec_typ));
  }
  else if (api EQ FUNC_PLATFORM_DETAIL) {
    CS_set_tmp_last_msg ((MSG_typ *)msg_hdr);
    rc= CS_api_to_capi_id (api, (MSG_typ *)msg_hdr);
    if (rc NE ESA_OK)
      goto cleanup;
    sprintf(mhseq,"%06d",BK_msg_seq);
    memcpy ((char *)msg_hdr->mhseq, (char *)mhseq, strlen (mhseq));
    memcpy ((char *)buffer, (char *)msg_hdr,
            sizeof (RSS_MSG_HDR_rec_typ));
  }
  else {
    CS_creat_cd_header(&msg_hdr_cd);
    /* start of service message handling */
    CS_set_not_last_msg ((MSG_typ *)&msg_hdr_cd);
    memcpy((char *)(&msg_hdr_cd.mhmtyp),START_OF_SERVICE,2);
    /* Message header */
    memcpy ((char *)buffer, (char *)(&msg_hdr_cd),
            sizeof (RSS_MSG_HDR_rec_typ));
    buffer += sizeof (RSS_MSG_HDR_rec_typ);
    full_msg_len = sizeof(RSS_MSG_HDR_rec_typ);
    /* Number of aplication messages */
    memcpy ((char *)buffer, MH_NMBR_MSGS,strlen(MH_NMBR_MSGS));
    buffer += strlen(MH_NMBR_MSGS);
    full_msg_len += strlen(MH_NMBR_MSGS);
    /* RSS structure length, transaction and action */
    memcpy ((char *)buffer,MH_TRANSACTION,strlen(MH_TRANSACTION));
    buffer_tmp = buffer;
    buffer += strlen(MH_TRANSACTION);
    sngl_msg_len = strlen(MH_TRANSACTION);
    /* RSS name and type */
    rc= rssprm_get (rss, RSS_TYPE, RSS_NAME_LEN, rss_typ);
    if (rc NE ESA_OK)
      goto cleanup;
    CS_ess_rss_name_type (rss, rss_typ, ess_rss, ess_rss_typ);
    buffer= CS_set_fld (ess_rss,
                        buffer,
                        &sngl_msg_len,
                        RSS_NAME_LEN ,
                        C_RSS_NAME);
    buffer= CS_set_fld (ess_rss_typ,
                        buffer,
                        &sngl_msg_len,
                        RSS_NAME_LEN ,
                        C_RSS_TYPE);
    /* hot path is off */
    memcpy ((char *)buffer,MH_HOTPASOFF,strlen(MH_HOTPASOFF));
    buffer += strlen(MH_HOTPASOFF);
    sngl_msg_len += strlen(MH_HOTPASOFF);
    /* RSS message length */
    rc= CS_set_sngl_msg_len(buffer_tmp , sngl_msg_len);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
    /* send start of service message */
    full_msg_len += sngl_msg_len;
 
    if (envir_ptr->encr_ext_act NE NOT_ACT_ENCR)
    {
      if (envir_ptr->enc_external_key_handle NE NULL)
      {
         ENC_term (&envir_ptr->enc_external_key_handle);
         envir_ptr->enc_external_key_handle = NULL;
      }
      rc = ENC_init_key (msg_hdr_cd.mhsiid,
                         sizeof (MH_siid),
                         envir_ptr->encryption_active_ext,
                         envir_ptr->enc_external_handle,
                         &envir_ptr->enc_external_key_handle,
                         &encryption_err);
 
      if (rc NE ESA_OK)
      {
         CS_encr_msg (&encryption_err);
         ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
            "External encryption term/init key completed with rc:%s",
                    ESA_rc2str(rc));
      }
    }
    rc= CS_send_msg (msg_ptr, (int)full_msg_len);
    if (rc NE ESA_OK)
      goto cleanup;
 
    /* Data message handling */
    buffer=msg_ptr;
    memset ((char *)buffer, '\0', envir_ptr->max_msg_size);
	/* AV002 */
	/*if ( (InterceptDelay EQ 0) AND (InterceptMax GT 0) )
	{
       CS_set_tmp_last_msg ((MSG_typ *)&msg_hdr_cd);
       NumIntrcptMsgInEss++;
       ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_DETAILES+ 1,
          "CS_send_msg: Sended UPDATE_ESS_SERVICE: NumIntrcptMsgInEss=%d ",
		  NumIntrcptMsgInEss);
	}*/
	
	if ( (NumIntrcptMsgInEss LT (InterceptMax - 1)) AND (InterceptMax GT 0) )
	{
		CS_set_last_msg ((MSG_typ *)&msg_hdr_cd);
		NumIntrcptMsgInEss++;
	}
	else if ( (NumIntrcptMsgInEss GE (InterceptMax - 1)) AND (InterceptMax GT 0) )
	{
       CS_set_tmp_last_msg ((MSG_typ *)&msg_hdr_cd);
       NumIntrcptMsgInEss++;
       ESA_DIAG_printf (ESA_COMP_ACSGPFR, DIAG_DETAILES+ 1,
          "CS_send_msg: Sended UPDATE_ESS_SERVICE: NumIntrcptMsgInEss=%d ",
		  NumIntrcptMsgInEss);
	}
	else
       CS_set_last_msg ((MSG_typ *)&msg_hdr_cd);
    memcpy((char *)(&msg_hdr_cd.mhseq),MH_SECOND_MSG,
           strlen(MH_SECOND_MSG));
    rc= CS_api_to_capi_id (api, (MSG_typ *)&msg_hdr_cd);
    if (rc NE ESA_OK)
      goto cleanup;
    memcpy ((char *)buffer, (char *)(&msg_hdr_cd),
            sizeof (RSS_MSG_HDR_rec_typ));
  }
 
 
  buffer += sizeof (RSS_MSG_HDR_rec_typ);
  full_msg_len = sizeof(RSS_MSG_HDR_rec_typ);
 
  memcpy ((char *)buffer,MH_NMBR_MSGS,strlen(MH_NMBR_MSGS));
  buffer += strlen(MH_NMBR_MSGS);
  full_msg_len += strlen(MH_NMBR_MSGS);
 
  /* rss structure length transaction action */
  memcpy ((char *)buffer,MH_TRANSACTION,strlen(MH_TRANSACTION));
  buffer_tmp = buffer;
  buffer += strlen(MH_TRANSACTION);
  sngl_msg_len = strlen(MH_TRANSACTION);
 
  /* Return codes and error messages */
  memcpy ((char *)buffer,MH_RETURN_ERR,strlen(MH_RETURN_ERR));
  buffer += strlen(MH_RETURN_ERR);
  sngl_msg_len += strlen(MH_RETURN_ERR);
 
  /* object exist */
  if (api EQ FUNC_DELUG   OR
      api EQ FUNC_DELOE   OR
      api EQ FUNC_DELUSER OR
      api EQ FUNC_DELU2UG) {
    obj_exist = OBJ_NOT_EXIST;
  }
 
  else obj_exist = OBJ_EXIST;
 
  if (
      (api NE FUNC_PLATFORM_DETAIL)
          AND
      (api NE FUNC_RSS_CHECK)
      )
  {
     buffer = CS_set_exist(buffer , &obj_exist);
     sngl_msg_len += 1;
  }
  switch (api) {
    case FUNC_ADDOE:
    oe_prm= (OE_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_oe  (buffer , oe_prm, &sngl_msg_len);
    strcpy(entity,oe_prm->oe);               /* WS10078KM */
    strcpy(type,"Container");                /* WS10078KM */
    break;
    case FUNC_DELOE:
    oe_prm= (OE_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_oe  (buffer , oe_prm, &sngl_msg_len);
    strcpy(entity,oe_prm->oe);               /* WS10078KM */
    strcpy(type,"Container");                /* WS10078KM */
    break;
    case FUNC_UPDOE:
    oe_prm= (OE_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_oe  (buffer , oe_prm, &sngl_msg_len);
    strcpy(entity,oe_prm->oe);               /* WS10078KM */
    strcpy(type,"Container");                /* WS10078KM */
    break;
    case FUNC_ADDUG:
    ug_prm= (UG_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);            /* WS10078KM */
    strcpy(type,"Group");                    /* WS10078KM */
    break;
    case FUNC_DELUG:
    ug_prm= (UG_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);            /* WS10078KM */
    strcpy(type,"Group");                    /* WS10078KM */
    break;
    case FUNC_UPDUG:
    ug_prm= (UG_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);            /* WS10078KM */
    strcpy(type,"Group");                    /* WS10078KM */
    break;
    case FUNC_ADDUSER:
    user_prm= (USER_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_DELUSER:
    user_prm= (USER_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_UPDUSER:
    user_prm= (USER_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_USERCONN:
    user_prm= (USER_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_RSUSDIS:
    user_prm= (USER_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_RSPWDMOD:
    user_prm= (USER_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_ADDU2UG:
    conn_prm= (CONNECT_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_fld ( conn_prm->group ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_ug_len ,
                            C_GROUP_ID);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Conn. Group=%s.",conn_prm->group);
    if (buffer NE NULL)
      buffer = CS_set_fld ( conn_prm->user ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_user_len ,
                            C_USER_ID);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Conn. User=%s.",conn_prm->user);
    if (buffer NE NULL)
      buffer = CS_set_u2ug(buffer,&conn_prm->u2ug_prm, &sngl_msg_len);
    sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
            conn_prm->group,             /* WS10078KM */
            conn_prm->user);             /* WS10078KM */
    strcpy(type,"Connection");           /* WS10078KM */
    break;
    case FUNC_DELU2UG:
    conn_prm= (CONNECT_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_fld ( conn_prm->group ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_ug_len ,
                            C_GROUP_ID);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Conn. Group=%s.",conn_prm->group);
    if (buffer NE NULL)
      buffer = CS_set_fld ( conn_prm->user ,
                            buffer , &sngl_msg_len,
                            envir_ptr->rss_limits.max_user_len ,
                            C_USER_ID);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Conn. User=%s.",conn_prm->user);
    if (buffer NE NULL)
      buffer = CS_set_u2ug(buffer,&conn_prm->u2ug_prm, &sngl_msg_len);
    sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
            conn_prm->group,             /* WS10078KM */
            conn_prm->user);             /* WS10078KM */
    strcpy(type,"Connection");           /* WS10078KM */
    break;
    case FUNC_UPDU2UG:
    conn_prm= (CONNECT_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
     buffer = CS_set_fld ( conn_prm->group ,
                           buffer ,
                           &sngl_msg_len,
                           envir_ptr->rss_limits.max_ug_len ,
                           C_GROUP_ID);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "1: Conn. Group=%s.",conn_prm->group);
    if (buffer NE NULL)
      buffer = CS_set_fld (conn_prm->user ,
                           buffer ,
                           &sngl_msg_len,
                           envir_ptr->rss_limits.max_user_len ,
                           C_USER_ID);
    ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "2: Conn. User=%s.",conn_prm->user);
    if (buffer NE NULL)
      buffer = CS_set_u2ug(buffer,&conn_prm->u2ug_prm,&sngl_msg_len);
    sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
            conn_prm->group,             /* WS10078KM */
            conn_prm->user);             /* WS10078KM */
    strcpy(type,"Connection");           /* WS10078KM */
    break;
    case FUNC_GTRSPRM:
    rsprm_prm= (RSS_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_rsprm (buffer,rsprm_prm, &sngl_msg_len);
    strcpy(entity,"Rss Parameters");          /* WS10078KM */
    strcpy(type,"RSSPARM");                   /* WS10078KM */
    break;
    case FUNC_RSLOGEVT:
    logevt_prm= (LOGEVT_PARAMS_rec_typ *)msg_struct;
    if (buffer NE NULL)
      buffer = CS_set_logevt (buffer, logevt_prm, &sngl_msg_len);
    strcpy(entity,"RSS Log");                 /* WS10078KM */
    strcpy(type,"RSSLOG");                    /* WS10078KM */
    break;
    case FUNC_RSS_CHECK:
    rss_status= (RSS_STATUS_typ *)msg_struct;
    if (buffer NE NULL) {
      buffer = CS_set_rss_status(buffer, rss_status, &sngl_msg_len);
    }
    strcpy(entity,"RSS");                     /* WS10078KM */
    strcpy(type,"RSS");                       /* WS10078KM */
    break;
    case FUNC_PLATFORM_DETAIL:
    plat_prm= (PLATFORM_DETAIL_rec_typ *)msg_struct;
    if (buffer NE NULL) {
      buffer = CS_set_plat(buffer, plat_prm, &sngl_msg_len);
    }
    strcpy(entity,"PLATFORM");                /* WS10078KM */
    strcpy(type,"PLATFORM");                  /* WS10078KM */
    break;
    default:
    if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_API, (int)api);
    break;
 
  }
 
  if (
      (buffer NE NULL)
          AND
      (api    NE FUNC_RSLOGEVT)
          AND
      (api    NE FUNC_PLATFORM_DETAIL)
          AND
      (api    NE FUNC_RSS_CHECK)
     )
    /* WS10078KM - Start *
    buffer = CS_set_addinfo  (api, buffer, addinfo, &sngl_msg_len); */
    rc = CS_set_addinfo  (api, buffer, addinfo, &sngl_msg_len);
    if (rc NE ESA_OK)
    {
       /* If rc is not ESA_OK then one or more attributes are not *
          set in buffer. We display error and continue.           */
       CTSAMSG_print (ERR_CS_MSG_BUF_OVERFLOW,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      entity,type);
 
    }
 
    /*
    if (buffer EQ NULL) {
        rc= ESA_ERR;
        goto cleanup;
    }
  * WS10078KM - End */
  rc= CS_set_sngl_msg_len(buffer_tmp , sngl_msg_len);
  if (rc NE ESA_OK) {
    goto cleanup;
  }
 
  full_msg_len += sngl_msg_len;
  if (full_msg_len LT 500)
     ESA_DIAG_printf (ESA_COMP_ACSGPF, 16,
            "CS_send_msg: msg=%.*s length=%d.",
             (int)full_msg_len, msg_ptr, (int)full_msg_len);
 
    /* WS10080 Start -                                           *
     *          We want to divide the message into sub messages  *
     *          if following conditions are met:                 *
     *              1. max_msg_size is greater than 32K.         *
     *              2. full_msg_len is more than one_msg_size.   */
 
    ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                    "iiq_version<%d> ", envir_ptr->iiq_version);
 
    ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                 "max_msg_size<%d>,full_msg_len<%d>,one_msg_size<%d>",
                  envir_ptr->max_msg_size, (int)full_msg_len,
                  (int)envir_ptr->one_msg_size);
 
    if( ((int)envir_ptr->max_msg_size GT 32723) AND
        ((int)full_msg_len GT (int)envir_ptr->one_msg_size) )
    {
       ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                       "Allocating memory to one_msg_buff of len <%d>",
                       (int) envir_ptr->one_msg_size);
 
       rc = CSA_alloc ((char **)&one_msg_buff_ptr, 0,
                       (int) envir_ptr->one_msg_size + 1,
                        1, fn, "one_msg_buff");
       if (rc NE ESA_OK)
          goto cleanup;
 
       one_msg_buff = one_msg_buff_ptr;
       msg_cd_buff_ptr = msg_ptr;
       remaining_msg_len = (int)full_msg_len;
 
       one_msg_len = (int)envir_ptr->one_msg_size;
 
       ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                       "remaining_msg_len <%d>, one_msg_len <%d>",
                       remaining_msg_len, one_msg_len);
 
       /* Take backup of header to use it as it is *
        * while preparing sub-messages.            */
       memcpy ((char *)(&tmp_msg_hdr), (char *)msg_ptr,
                               sizeof (RSS_MSG_HDR_rec_typ));
       msg_hdr_mhltl = tmp_msg_hdr.mhltl;
       /* Change MHDLAST to BLANK which is an indication *
        * that its not the last message.                 */
       tmp_msg_hdr.mhltl = MH_MESSAGE_LAST_NOT;
 
       memcpy ((char *)msg_ptr, (char *)(&tmp_msg_hdr),
                                  sizeof (RSS_MSG_HDR_rec_typ));
 
       /* Set message type and record type  *
        * as 'S' and 'M' for sub messages.  */
       tmp_msg_hdr.mhmtyp = 'S';
       tmp_msg_hdr.mhrtyp = 'M';
 
       memset ((char *)one_msg_buff, '\0',
                                     (int) envir_ptr->one_msg_size + 1);
 
       ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                       "msg_cd_buff_ptr <%p>",msg_cd_buff_ptr);
 
       /* The buffer to copy number of characters from message */
       buff_sent_one_msg_len = one_msg_len;
       do
       {
          /* Copy characters of length one_msg_len *
           * to form a sub message                 */
          memcpy((char *)one_msg_buff,
                    msg_cd_buff_ptr, buff_sent_one_msg_len);
 
          ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
            "Before cs_send_msg one_msg_buff_ptr=<%p> one_msg_len <%d>",
                          one_msg_buff_ptr, one_msg_len);
          /* Send the sub message  */
          rc = CS_send_msg (one_msg_buff_ptr, one_msg_len);
 
          remaining_msg_len = remaining_msg_len - buff_sent_one_msg_len;
          ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                          "remaining_msg_len - %d", remaining_msg_len);
 
          if(remaining_msg_len GT 0)
          {
             /* Advance the pointer to start of next sub   *
              * message or end of last sub message sent.   */
             msg_cd_buff_ptr = msg_cd_buff_ptr + buff_sent_one_msg_len;
             ESA_DIAG_printf(ESA_COMP_ACSGPF, 9,
                             "after cs_send_msg msg_cd_buff_ptr=<%p>",
                             msg_cd_buff_ptr);
 
             /* Reset the buffer */
             one_msg_buff = one_msg_buff_ptr;
             memset ((char *)one_msg_buff, '\0',
                                        (int) envir_ptr->one_msg_size);
             one_msg_len = 0;
 
             /* Check if the next sub message is last message by        *
              * calculating the size of message remaining. Set MHDLAST  *
              * to the original value if its a last sub-message.        */
             if(remaining_msg_len GT
                ((int)envir_ptr->one_msg_size -
                                          sizeof(RSS_MSG_HDR_rec_typ)) )
             {
                buff_sent_one_msg_len = (int) envir_ptr->one_msg_size -
                                            sizeof (RSS_MSG_HDR_rec_typ);
             }
             else
             {
                /* This is last message */
                tmp_msg_hdr.mhltl = msg_hdr_mhltl;
                buff_sent_one_msg_len = remaining_msg_len;
             }
             memcpy ((char *)one_msg_buff,(char *)(&tmp_msg_hdr),
                                           sizeof(RSS_MSG_HDR_rec_typ));
             one_msg_buff += sizeof(RSS_MSG_HDR_rec_typ);
             one_msg_len += sizeof(RSS_MSG_HDR_rec_typ);
             ESA_DIAG_printf(ESA_COMP_ACSGPF, 21,
                       "one_msg_buff_ptr after copying header <%.400s>",
                       (char *)one_msg_buff_ptr);
 
             one_msg_len += buff_sent_one_msg_len;
 
             ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                             "one_msg_len<%d>,remaining_msg_len<%d>",
                             one_msg_len, remaining_msg_len);
 
             ESA_DIAG_printf(ESA_COMP_ACSGPF, 6,
                             "buff_sent_one_msg_len<%d>",
                             buff_sent_one_msg_len);
 
          }
       }while((msg_cd_buff_ptr NE NULL) AND (remaining_msg_len GT 0));
       CSA_free ((char **)&one_msg_buff_ptr);
    }/*End if((int)full_msg_len GT (int)envir_ptr->one_msg_size )*/
    else /* WS10080 End */
       rc= CS_send_msg (msg_ptr, (int)full_msg_len);
 
  cleanup:
 
    CSA_free ((char **)&msg_ptr);
    if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return (rc);
}
 
/****************************************************
 * Procedure Name: CS_get_msg_header
 * Description   : retrieve message header from
 *                 communication message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to copy the GENERAL MESSAGE HEADER from
 * one buffer to another.
 *******************************************************/
 
ESA_RC CS_get_msg_header (MSG_typ             *  msg_ptr ,
                          RSS_MSG_HDR_rec_typ *  msg_hdr)
{
  char                      fn[]="CS_get_msg_header";
  ENVIRONMENT_rec_typ     * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  memset ((char *)msg_hdr , NULL_CHAR , sizeof(RSS_MSG_HDR_rec_typ));
 
  memcpy ((char *)msg_hdr , (char *)msg_ptr ,sizeof (RSS_MSG_HDR_rec_typ));
  envir_ptr->aid= msg_hdr->mhaid;
  /*if (envir_ptr->aid == 0)
  {
     if (envir_ptr->aid == MH_MESSAGE_AID)
        envir_ptr->addinfo_val_len= ADINF_VAL_LEN_S;
     else
        envir_ptr->addinfo_val_len= ADINF_VAL_LEN_N;
  )*/
  ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "MsgHdr=%.*s.", sizeof (RSS_MSG_HDR_rec_typ), (char *)msg_hdr);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_OK);
  return(ESA_OK);
} /* END - CS_get_msg_header function */
 
/****************************************************
 * Procedure Name: CS_add_rs_msg
 * Description   : use to add buffer to existing
 *                 rs message.
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :ver 2.0.1.1
 * Scope         :
 ****************************************************/
 
MSG_typ *  CS_add_rs_msg (short                  api,
                          USER_PARAMS_rec_typ  * user_prm,
                          OE_PARAMS_rec_typ    * oe_prm,
                          UG_PARAMS_rec_typ    * ug_prm,
                          U2UG_PARAMS_rec_typ  * u2ug_prm,
                          ADDINFO_rec_typ      * addinfo,
                          NUM_MSGS_typ         * rs_msg_len,
                          NUM_MSGS_typ         * rs_num_msgs,
                          MSG_typ              * msg_rs,
                          MSG_typ              * msg_rs_ptr,
                          NUM_MSGS_typ         * rs_umsg_len,
                          NUM_MSGS_typ         * rs_num_umsgs,
                          MSG_typ              * umsg_rs,
                          MSG_typ              * umsg_rs_ptr,
                          NUM_MSGS_typ         * rs_amsg_len,
                          NUM_MSGS_typ         * rs_num_amsgs,
                          MSG_typ              * amsg_rs,
                          MSG_typ              * amsg_rs_ptr,
                          RSS_MSG_HDR_rec_typ  * msg_hdr_rs,
                          int                  * sw_user,
                          int                  * sw_upd,
                          ESA_RC               * write_mbx_rc)
{
  char           fn[]="CS_add_rs_msg";
  MSG_typ      * buffer_tmp, *buffer_str;
  MSG_typ      * buffer = NULL;     /* AJK001 */
  MSG_typ      * msg_ptr, msgcode[2], * tmp_ptr;
  MSG_typ      * msg = NULL;        /* AJK001 */
  NUM_MSGS_typ   sngl_msg_len, * msg_len, * num_msgs;
  int            tmp_size;
  ESA_RC         rc;
  OBJ_EXISTS_typ obj_exist;
  RSS_MSG_HDR_rec_typ  * tmp_hdr, tmp_hdr_space;
  ENVIRONMENT_rec_typ  * envir_ptr;
  char           entity[256];  /* WS10078KM */
  char           type[16];     /* WS10078KM */
 
  CS_get_envir_address (&envir_ptr);
 
 *write_mbx_rc = ESA_OK;
 
 ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&buffer_str, 0, envir_ptr->max_msg_size,
                   1, fn, "buffer_str");
  if (rc NE ESA_OK)
    goto cleanup;
 
  buffer=     buffer_str;
  buffer_tmp= buffer;
 
  /* rss structure length transaction action */
  memcpy ((char *)buffer, MH_TRANSACTION,strlen(MH_TRANSACTION));
  buffer += strlen(MH_TRANSACTION);
  sngl_msg_len = strlen(MH_TRANSACTION);
 
  /* Return codes and error messages */
  memcpy ((char *)buffer, MH_RETURN_ERR,strlen(MH_RETURN_ERR));
  buffer += strlen(MH_RETURN_ERR);
  sngl_msg_len += strlen(MH_RETURN_ERR);
 
  /* object exist */
  if (api EQ FUNC_DELUG   OR
      api EQ FUNC_DELOE   OR
      api EQ FUNC_DELUSER OR
      api EQ FUNC_DELU2UG) {
    obj_exist = OBJ_NOT_EXIST;
  }
  else obj_exist = OBJ_EXIST;
  buffer = CS_set_exist(buffer , &obj_exist);
  sngl_msg_len += 1;
 
  switch (api) {
    case FUNC_ADDOE:
    if (buffer NE NULL)
      buffer = CS_set_oe  (buffer , oe_prm, &sngl_msg_len);
    strcpy(entity,oe_prm->oe);               /* WS10078KM */
    strcpy(type,"Container");                /* WS10078KM */
    break;
    case FUNC_DELOE:
    if (buffer NE NULL)
      buffer = CS_set_oe  (buffer , oe_prm, &sngl_msg_len);
    strcpy(entity,oe_prm->oe);               /* WS10078KM */
    strcpy(type,"Container");                /* WS10078KM */
    break;
    case FUNC_UPDOE:
    if (buffer NE NULL)
      buffer = CS_set_oe  (buffer , oe_prm, &sngl_msg_len);
    strcpy(entity,oe_prm->oe);               /* WS10078KM */
    strcpy(type,"Container");                /* WS10078KM */
    break;
    case FUNC_ADDUG:
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);            /* WS10078KM */
    strcpy(type,"Group");                    /* WS10078KM */
    break;
    case FUNC_DELUG:
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);            /* WS10078KM */
    strcpy(type,"Group");                    /* WS10078KM */
    break;
    case FUNC_UPDUG:
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);            /* WS10078KM */
    strcpy(type,"Group");                    /* WS10078KM */
    break;
    case FUNC_ADDUSER:
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_DELUSER:
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_UPDUSER:
    if (buffer NE NULL)
      buffer = CS_set_user(buffer , user_prm, &sngl_msg_len);
    strcpy(entity,user_prm->user);           /* WS10078KM */
    strcpy(type,"User");                     /* WS10078KM */
    break;
    case FUNC_ADDU2UG:
    if (buffer NE NULL)
      buffer = CS_set_fld ( ug_prm->group ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_ug_len ,
                            C_GROUP_ID);
    ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "1: Con. Group=%s.",ug_prm->group);
    if (buffer NE NULL)
      buffer = CS_set_fld ( user_prm->user ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_user_len ,
                            C_USER_ID);
    ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "2: Con. User=%s.",user_prm->user);
    if (buffer NE NULL)
      buffer = CS_set_u2ug(buffer , u2ug_prm, &sngl_msg_len);
 
    sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
            ug_prm->group,               /* WS10078KM */
            user_prm->user);             /* WS10078KM */
    strcpy(type,"Connection");           /* WS10078KM */
    break;
    case FUNC_DELU2UG:
    if (buffer NE NULL)
      buffer = CS_set_fld ( ug_prm->group ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_ug_len ,
                            C_GROUP_ID);
    ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "1: Con. Group=%s.",ug_prm->group);
    if (buffer NE NULL)
      buffer = CS_set_fld ( user_prm->user ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_user_len ,
                            C_USER_ID);
    ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "2: Con. User=%s.",user_prm->user);
    if (buffer NE NULL)
      buffer = CS_set_u2ug(buffer , u2ug_prm, &sngl_msg_len);
    sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
            ug_prm->group,               /* WS10078KM */
            user_prm->user);             /* WS10078KM */
    strcpy(type,"Connection");           /* WS10078KM */
    break;
    case FUNC_UPDU2UG:
    if (buffer NE NULL)
     buffer = CS_set_fld ( ug_prm->group ,
                           buffer ,
                           &sngl_msg_len,
                           envir_ptr->rss_limits.max_ug_len ,
                           C_GROUP_ID);
    ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "1: Con. Group=%s.",ug_prm->group);
    if (buffer NE NULL)
      buffer = CS_set_fld ( user_prm->user ,
                            buffer ,
                            &sngl_msg_len,
                            envir_ptr->rss_limits.max_user_len ,
                            C_USER_ID);
    ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "2: Con. User=%s.",user_prm->user);
    if (buffer NE NULL)
      buffer = CS_set_u2ug(buffer , u2ug_prm, &sngl_msg_len);
    sprintf(entity,"Group:%s, User:%s",  /* WS10078KM */
            ug_prm->group,               /* WS10078KM */
            user_prm->user);             /* WS10078KM */
    strcpy(type,"Connection");           /* WS10078KM */
    break;
    /* WS10078KG - Start */
    case FUNC_ADDXROL:
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);
    strcpy(type,"Role");
    break;
    case FUNC_ADDXSGP:
    if (buffer NE NULL)
      buffer = CS_set_ug  (buffer , ug_prm, &sngl_msg_len);
    strcpy(entity,ug_prm->group);
    strcpy(type,"Source");
    break;
    /* WS10078KG - End */
    default:
      CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_API, (int)api);
      buffer= NULL;
    break;
 
  }
  if (buffer EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
 
  }
  rc= CS_api_to_capi_id (api, (MSG_typ *)msg_hdr_rs);
  if (rc NE ESA_OK)
      goto cleanup;
  msgcode[0]= msg_hdr_rs->mhmtyp;
  msgcode[1]= msg_hdr_rs->mhrtyp;
 
  if (buffer NE NULL)
  /* WS10078KM - Start */
  {
  /*buffer = CS_set_addinfo  (api, buffer, addinfo, &sngl_msg_len); */
    rc = CS_set_addinfo (api, buffer, addinfo, &sngl_msg_len);
  }
  if (rc NE ESA_OK)
  {
     /* If rc is not ESA_OK then one or more attributes are not *
        set in buffer. We display error and continue.           */
     CTSAMSG_print (ERR_CS_MSG_BUF_OVERFLOW,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    entity,type);
   }
  /*
  if (buffer EQ NULL) {
      rc= ESA_ERR;
      goto cleanup;
  }
  * WS10078KM - End */
 
  rc= CS_set_sngl_msg_len(buffer_tmp , sngl_msg_len);
  if (rc NE ESA_OK) {
    buffer= NULL;
    goto cleanup;
  }
  *sw_user= 0;
  if (api EQ FUNC_UPDU2UG OR
      api EQ FUNC_UPDUG OR
      api EQ FUNC_UPDOE OR
      api EQ FUNC_UPDUSER) {
    msg_len=  rs_umsg_len;
    num_msgs= rs_num_umsgs;
    msg=      umsg_rs;
    msg_ptr=  umsg_rs_ptr;
    *sw_upd=   1;
  }
  else {
    msg_len=  rs_msg_len;
    num_msgs= rs_num_msgs;
    msg=      msg_rs;
    msg_ptr=  msg_rs_ptr;
    *sw_upd=   0;
 
 
  }
 /*BS10127* if (* msg_len + sngl_msg_len GE
       envir_ptr->max_msg_size- ENC_ADD_MAX_LEN) {   */
  if( (* msg_len + sngl_msg_len GE                /*BS10127*/
      envir_ptr->max_msg_size- ENC_ADD_MAX_LEN)   /*BS10127*/
      OR (*num_msgs GT 4090) )                  { /*BS10127*/
    if (*rs_num_amsgs NE 0 AND
        (api EQ FUNC_ADDU2UG OR api EQ FUNC_UPDU2UG)) {
      rc= CS_send_cd_msg (rs_amsg_len ,
                          rs_num_amsgs ,
                          amsg_rs_ptr);
      if (rc NE ESA_OK) {
        *write_mbx_rc = rc;
        buffer = NULL;
        amsg_rs= NULL; /* For avoid referenced warning*/
        goto cleanup;
      }
      *sw_user= 1;
    }
 
    tmp_hdr = (RSS_MSG_HDR_rec_typ *)msg_ptr;
 
    if ((*msg_ptr EQ DWNLD_SERVICE) AND
        (envir_ptr->stop_req_msgs NE 0) AND
        ((BK_msg_seq % envir_ptr->stop_req_msgs) EQ 0) OR  /*WS10080*/
        (send_mh_message_last_tmp EQ TRUE )              ) /*WS10080*/
	{
       /* Send empty message to ESS (Download continue work) */
       FILE * TmpPtr;
        TmpPtr= envir_ptr->download_hndl;
		envir_ptr->download_hndl= NULL;
        rc= CS_send_receive (tmp_hdr);
        envir_ptr->download_hndl= TmpPtr;
        if (rc NE ESA_OK)
           goto cleanup;
     /* tmp_hdr->mhltl = MH_MESSAGE_LAST_TMP;*/
     send_mh_message_last_tmp = FALSE;                     /*WS10080*/
    }
 
    rc = CS_send_cd_msg (msg_len ,
                         num_msgs ,
                         msg_ptr);
    if (rc NE ESA_OK) {
      *write_mbx_rc = rc;
      buffer = NULL;
      goto cleanup;
    }
    if (tmp_hdr->mhltl EQ MH_MESSAGE_LAST_TMP) {
      tmp_ptr= envir_ptr->msg_ptr;
      tmp_size= envir_ptr->msg_size;
      rc = CS_get_next_msg (msg_ptr , &tmp_hdr_space);
      envir_ptr->msg_ptr= tmp_ptr;
      envir_ptr->msg_size= tmp_size;
      if ((rc EQ ESA_OK) AND
          (memcmp ((char *)(&tmp_hdr_space.mhmtyp) , MSG_END_OF_DWNLD,
                   2) EQ 0))
        rc = ESA_ABORT_REQ;
      if (rc NE ESA_OK) {
       *write_mbx_rc= rc;
       rc = ESA_OK;
       goto cleanup;
      }
    }
 
    msg= CS_reset_rs_msg(msg_len ,
                         num_msgs ,
                         msg ,
                         msg_ptr ,
                         msg_hdr_rs,
                         msgcode);
  }
  * num_msgs += 1;
  msg= CS_add_sngl_to_msg (msg, buffer_tmp, sngl_msg_len);
  * msg_len += sngl_msg_len;
 
  cleanup:
 
  if (buffer EQ NULL)
    rc= ESA_ERR;
  CSA_free ((char **)&buffer_str);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return (msg);
}
 
/****************************************************
 * Procedure Name: CS_reset_rs_msg
 * Description   : use to reset cd message.
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_reset_rs_msg (NUM_MSGS_typ        * rs_len,
                           NUM_MSGS_typ        * rs_num,
                           MSG_typ             * rs,
                           MSG_typ             * rs_ptr,
                           RSS_MSG_HDR_rec_typ * msg_hdr,
                           const char          * msg_code)
{
  char                    fn[]="CS_reset_rs_msg";
  char                    msg_seq [sizeof(MH_seq)+ 1];
  char                    tmp_len[RSS_NUM_MSGS+ 1];
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  * rs_len  = 0;
  * rs_num  = 0;
 
  sprintf(msg_seq,"%06d",BK_msg_seq);
  memcpy((char *)msg_hdr->mhseq, (char *)msg_seq, sizeof(MH_seq));
  msg_hdr->mhmtyp = msg_code[0];
  msg_hdr->mhrtyp = msg_code[1];
  msg_hdr->mhltl  = MH_MESSAGE_LAST_NOT;
 
  rs =  rs_ptr;
  memset ((char *)rs, '\0', envir_ptr->max_msg_size);
 
  memcpy((char *)rs , (char *)msg_hdr , sizeof(RSS_MSG_HDR_rec_typ));
 
  rs = rs + sizeof(RSS_MSG_HDR_rec_typ);
  * rs_len = * rs_len + sizeof(RSS_MSG_HDR_rec_typ);
 
  sprintf(tmp_len,"%03X", (unsigned)*rs_num);
  memcpy((char *)rs, (char *)tmp_len, RSS_NUM_MSGS);
  rs += RSS_NUM_MSGS;
  * rs_len = * rs_len + RSS_NUM_MSGS;
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(rs);
}
 
/****************************************************
 * Procedure Name: CS_brdcst_msg
 * Description   : Keywords/Interesting users Syncronization
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated in order to take care for the following:
 * - A mailbox read request (in function CS_get_next_msg) received
 *   "broadcast" message. This message (right now implemented on NON
 *   MVS CO only) is sent from any CS/CD server and is distributed to
 *   all other servers to notify that eather the "interesting keywords"
 *   file was modified, or that any of the "interesting user/group/
 *   connection" files was modoified.
 * - An OS_event of "Interesting keywords" file modified or any of
 *   "Interesting users/groups/connections" files was modified (right
 *   now the OS_events is implemented on MVS platform only).
 * In case that "broadcast message" was received, the input message
 * pointer points to it and the "in_event" parameter is meaningless
 * and in case of OS_event the message pointer is NULL and the receive
 * event is received in the "in_event" parameter.
 * The function analyses the message (in case it is transfered) and
 * translate it to event code. It activates the load function for
 * keywords or for both the users,groups & connections file according
 * to the evvent.
 *********************************************************************/
 
static ESA_RC CS_brdcst_msg (void          * msg_ptr,
                             int             message_size,
                             ESA_EVENT_typ   in_event )
{
  char                  fn[]="CS_brdcst_msg";
  ESA_RC                rc= ESA_OK;
  BRDCST_rec_typ      * brdcst;
  ESA_EVENT_typ         event = EVENT_IMPUSR_CHANGED;   /* AJK001 */
  unsigned int          jj = 0, ii = 0, rsstbl_num= 0;
  RSSTBL_rec_typ      * rsstbl = NULL;
  RSS_typ               rss_id;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  /*
    PROCESS "broadcast" messages:
  */
  if (msg_ptr NE NULL) {
 
    /*
      SET event type according to message subtype.
    */
    brdcst= (BRDCST_rec_typ *)msg_ptr;
 
    if ((unsigned int)message_size LT sizeof(BRDCST_rec_typ))
      brdcst->msg_subtype = '\0';
 
    if (brdcst->msg_type    EQ CS_BRDCT_EVNT AND
        brdcst->msg_subtype EQ CS_BRDCT_EVNT_INTRST)
       event = EVENT_IMPUSR_CHANGED ;
    if (brdcst->msg_type    EQ CS_BRDCT_EVNT AND
        brdcst->msg_subtype EQ CS_BRDCT_EVNT_KWDS)
       event = EVENT_KEYWORDS_CHANGED ;
    if (brdcst->msg_type    EQ CS_BRDCT_EVNT AND
        brdcst->msg_subtype EQ CS_BRDCT_EVNT_ADMIN)
       event = EVENT_ADMIN_CHANGED;
    if (brdcst->msg_type    EQ CS_BRDCT_EVNT AND
        brdcst->msg_subtype EQ CS_BRDCT_EVNT_OFLI_PARAMS)
       event = EVENT_OFLI_PARAMS_CHANGED;
    if (
        (brdcst->msg_type    NE CS_BRDCT_EVNT)
            OR
        (
            (brdcst->msg_subtype NE CS_BRDCT_EVNT_KWDS)
                AND
            (brdcst->msg_subtype NE CS_BRDCT_EVNT_INTRST)
                AND
            (brdcst->msg_subtype NE CS_BRDCT_EVNT_ADMIN)
                AND
            (brdcst->msg_subtype NE CS_BRDCT_EVNT_OFLI_PARAMS)
        )
       )
    {
       CTSAMSG_print (ERR_CS_BRDCST_MSG,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, brdcst->msg_type, brdcst->msg_subtype);
       goto cleanup;
    }
  } /* END - Broadcast message pointer is NOT NULL */
  else
    event = in_event;
 
  /*
   PROCESS User/Group/Connection file modified event:
  */
  if (
       (event EQ EVENT_IMPOE_CHANGED)       OR
       (event EQ EVENT_IMPUSR_CHANGED)      OR
       (event EQ EVENT_IMPGRP_CHANGED)      OR
       (event EQ EVENT_IMPCNN_CHANGED)      OR
       (event EQ EVENT_OFLI_PARAMS_CHANGED) OR
       (event EQ EVENT_UNDEF)
     )
  {
 
    /*
      LOAD all three User/Groups/Connectoins files
    */
    rc= CARE_int_usr_load ();
    if (rc NE ESA_OK)
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
           "Interesting users file %s failed (rc=%d)",
                       envir_ptr->file_intuser, (int)rc);
    if (rc EQ ESA_OK) {
      rc= CARE_int_ug_load  ();
      if (rc NE ESA_OK)
        ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
           "Interesting groups file %s failed (rc=%d)",
                       envir_ptr->file_intug, (int)rc);
    }
    if (rc EQ ESA_OK) {
      rc= CARE_int_oe_load  ();
      if (rc NE ESA_OK)
        ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
           "Interesting containers file %s failed (rc=%d)",
                       envir_ptr->file_intoe, (int)rc);
    }
    if (rc EQ ESA_OK) {
      rc=CARE_int_u2ug_load();
      if (rc NE ESA_OK)
        ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
           "Interesting groups for conn. file %s failed (rc=%d)",
                       envir_ptr->file_intu2ug, (int)rc);
    }
    if (rc EQ ESA_OK)
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                       "Interesting files loaded successfuly");
    /*
      LOAD (read) the rss offline file into the rss table.
    */
    rc= tbl_load (&rsstbl, (int *)(&rsstbl_num));
    if (rc NE ESA_OK)
      goto cleanup;
    for(ii= 0; ii LT rsstbl_num; ii++)
    {
      memcpy ((char *)rss_id, (char *)rsstbl[ii].rss,sizeof(RSS_typ));
      rss_id[RSS_NAME_LEN]= '\0';
      strtok (rss_id, " ");
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                       "rsstbl: %d rss %s dwnld_sync_method %c.",
                       ii, rss_id, rsstbl[ii].dwnld_sync_method);
      for(jj= 0; jj LT (unsigned int)envir_ptr->max_rss_num; jj++)
      {
        if (My_stricmp(envir_ptr->interest[jj].rss , rss_id) EQ 0)
        {
           envir_ptr->interest[jj].prev_dwnld_sync_method=
               rsstbl[ii].dwnld_sync_method;
           envir_ptr->interest[jj].dwnld_sync_method =
              rsstbl[ii].dwnld_sync_method;
           ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
               "envir_ptr->interest: %d rss %s dwnld_sync_method %c.",
                jj,
                envir_ptr->interest[jj].rss,
                envir_ptr->interest[jj].dwnld_sync_method);
           break;
        }
      }
    }
    if (rsstbl NE NULL)
    {
       CSA_free ((char **)&rsstbl);
       rsstbl = NULL;
    }
    if (rc NE ESA_OK)
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                       "OFLI params from file %s failed (rc=%d)",
                       envir_ptr->file_rssofli, (int)rc);
    else
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                      "OFLI params from file %s loaded successfuly",
                       envir_ptr->file_rssofli);
 
    goto cleanup;
    /* END - Ofli params event */
  } /* END User/Group/Connection file modified event */
 
  /*
    PROCESS important keywords event:
  */
  if  (
         (event EQ EVENT_KEYWORDS_CHANGED)
        OR
         (event EQ EVENT_UNDEF)
      )
  {
    /*
      LOAD interesting keywords.
    */
    rc= rssapikwd_load ();
    if (rc NE ESA_OK)
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                       "Keywords from file %s failed (rc=%d)",
                       envir_ptr->file_rsskwds, (int)rc);
    else
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                       "Keywords from file %s loaded successfuly",
                       envir_ptr->file_rsskwds);
 
    goto cleanup;
  } /* END - Interesting keywords event */
  /*WS10082A RSSADM file is not used in MF
  @*
    PROCESS RSS administrators:
  *@
  if  (
         (strlen (envir_ptr->file_administrators) NE 0)
        AND
		 (
            (event EQ EVENT_ADMIN_CHANGED)
           OR
            (event EQ EVENT_UNDEF)
         )
      )
  {
    @*
      LOAD RSS administrators.
    *@
    rc= ADM_load ();
    if (rc NE ESA_OK)
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                       "Administrators from file %s failed (rc=%d)",
                       envir_ptr->file_administrators, (int)rc);
    else
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
                     "Administrators from file %s loaded successfuly",
                      envir_ptr->file_administrators);
 
    rc= ADM_fill_admin_changes (OPT_TRUE,
                                OPT_TRUE);
    if (rc NE ESA_OK)
       goto cleanup;
  } @* END - administrators event *@
  end of WS10082A  ***********/
 
 
  cleanup:
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
 
  return (rc );
 
} /* END - CS_brdcst_msg function */
 
/****************************************************
 * Procedure Name: CS_init
 * Description   : Init environment data.
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function makes all general initialization activities required
 * by both the CS & CD processes. This activities are the added
 * activities to those ones held by the CG_prolog function.
 *********************************************************************/
 
ESA_RC CS_init (char  * arg1,
                char  * arg2,
                void ** os_cs_init_handle)
{
  char                   fn[]="CS_init";
  ESA_RC                 rc= ESA_OK;
  ENC_BOOLEAN            encryption_active;
  ENC_BOOLEAN            encryption_active_ext;
  ENC_ERR_rec_typ        encryption_err;
  int                    msg_size_o= 0, msg_size_i= 0;
  unsigned int           jj = 0, ii = 0, rsstbl_num= 0;
  char                   interval[RSSPRM_VALUE_LEN+ 1];
  RSSTBL_rec_typ       * rsstbl = NULL;
  RSS_typ                rss_id;
  MBX_QUE_NAME_D_typ     mail_name;
  ENVIRONMENT_rec_typ  * envir_ptr;
  RSS_INTEREST_rec_typ * interest;
 
  CS_get_envir_address (&envir_ptr);
  /*
    INITIALISE generl OS services.
  */
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
          "*****> Proces initialization:");
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
                   "...-> OS_CS_init: main=%s.",
				   CG_main_name (envir_ptr->p_main_name));
  rc = OS_CS_init (CG_main_name (envir_ptr->p_main_name),
                   &envir_ptr->msg_params,
                   os_cs_init_handle);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
   "...<- OS_CS_init: rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK",
			*os_cs_init_handle);
  if (rc NE ESA_OK) {
    CTSAMSG_print (ERR_CS_OS_INIT,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
    goto cleanup;
  }
 
  /*
    INITIALIZE OS events services.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
                   "    =<> Call to OS_EVENT_init: main=%s.",
				   CG_main_name (envir_ptr->p_main_name));
  rc = OS_EVENT_init (&envir_ptr->event_handle ,
                      envir_ptr->p_main_name ,
                      &envir_ptr->msg_admin_param ,
                      &envir_ptr->msg_params);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
   "    <>= OS_EVENT_init completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK",
			envir_ptr->event_handle);
 
  if (rc EQ ESA_OK)
      envir_ptr->event_active = TRUE;
else
  if (rc EQ ESA_NOT_SUPP)
      envir_ptr->event_active = FALSE;
else
      goto cleanup;
 
 
  /*
    ATTACH to INPUT mailbox channel.
  */
  strcpy (mail_name, arg1);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
	       "...-> ESA_MBX_attach: name=%.*s.",
	sizeof(MBX_QUE_NAME_D_typ), mail_name);
  rc = ESA_MBX_attach (mail_name, &(envir_ptr->channel_i));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
			"...<- ESA_MBX_attach: rc=%d (%s) hdl=%p.",
	        rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK",
			envir_ptr->channel_i);
 
  if (rc EQ ESA_OK)
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                     "Input Mail box %s attached successfuly",
                     arg1);
  else {
    CTSAMSG_print (ERR_CS_MBX_ATTACH,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn, arg1);
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                     "Input Mail box %s attache failed", arg1);
    goto cleanup;
  }
  /*
    RETRIEVE the READ mailbox's actual maximum message size.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
       "...-> ESA_MBX_act_msg_size: hdl=%p.", envir_ptr->channel_i);
  rc= ESA_MBX_act_msg_size (envir_ptr->channel_i, &msg_size_i);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
	"...<- ESA_MBX_act_msg_size: rc=%d (%s) MsgSize=%d.",
    rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK", msg_size_i);
  if (rc NE ESA_OK) {
    CTSAMSG_print (ERR_CS_MBX_SIZE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn, arg1);
    goto cleanup;
  }
 
  /*
    ATTACH to OUTPUT mailbox channel.
  */
   strcpy (mail_name, arg2);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
	       "...-> ESA_MBX_attach: name=%.*s.",
	sizeof(MBX_QUE_NAME_D_typ), mail_name);
  rc = ESA_MBX_attach (mail_name, &(envir_ptr->channel_o));
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
			"...<- ESA_MBX_attach: rc=%d (%s) hdl=%p.",
	        rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK",
			envir_ptr->channel_o);
 
  if (rc EQ ESA_OK)
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                     "Output Mail box %s attached successfuly",
                     arg2);
  else {
    CTSAMSG_print (ERR_CS_MBX_ATTACH,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn, arg2);
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                     "Output Mail box %s attache failed", arg2);
    goto cleanup;
  }
  /*
    RETRIEVE the WRITE mailbox's actual maximum message size.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
       "...-> ESA_MBX_act_msg_size: hdl=%p.", envir_ptr->channel_o);
  rc= ESA_MBX_act_msg_size (envir_ptr->channel_o, &msg_size_o);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MSGHDR,
	"...<- ESA_MBX_act_msg_size: rc=%d (%s) MsgSize=%d.",
    rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK", msg_size_o);
  if (rc NE ESA_OK) {
    CTSAMSG_print (ERR_CS_MBX_SIZE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn, arg2);
    goto cleanup;
  }
  /*
    SET read buffer size to the MAXIMUM between the requested message
    size (in CTSPARM file) and the actual message size of input and
    output mailboxws.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
          "*****>... Maximum message size set to %d bytes.",
		  envir_ptr->max_msg_size);
  envir_ptr->msg_size= envir_ptr->max_msg_size;
  if (envir_ptr->msg_size LT msg_size_i)
    envir_ptr->msg_size=   msg_size_i;
  if (envir_ptr->msg_size LT msg_size_o)
    envir_ptr->msg_size=   msg_size_o;
  /* WS10080 Start - Commented out following code as, we dont  *
   *                 want to change max_msg_size to msg_size_i *
   *                 or msg_size_o which is 32000. Also,       *
   *                 the max_msg_size can not be more than     *
   *                 1,048,575 (1M). If the value is more than *
   *                 1M lets reset it to 1M. Dont forget to    *
   *                 initialise envir_ptr->iiq_ver_interceptor */
   /*
  /@
    SET the write message's max.size to be the MINIMUM between the
    numbers from above.
  @/
  if (envir_ptr->max_msg_size GT (unsigned int)msg_size_i)
    envir_ptr->max_msg_size=   msg_size_i;
  if (envir_ptr->max_msg_size GT (unsigned int)msg_size_o)
    envir_ptr->max_msg_size=   msg_size_o;
    */
  if(envir_ptr->max_msg_size GT 1048575 )
     envir_ptr->max_msg_size = 1048575;
 
  envir_ptr->iiq_ver_interceptor = 0;
  /* WS10080 End */
 
  /*
    VERIFY that the maximum message size set - may include at least
    single error message (plus the headers).
  */
  if (envir_ptr->max_msg_size LT ERR_MSG_TEXT_LEN+
      sizeof (RSS_MSG_HDR_rec_typ)+ 5*STRUCT_LEN) {
    CTSAMSG_print (ERR_CS_MBX_SIZE_LESS_MIN,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   envir_ptr->max_msg_size, ERR_MSG_TEXT_LEN+
                   sizeof (RSS_MSG_HDR_rec_typ)+ 5*STRUCT_LEN);
    rc= ESA_FATAL;
    goto cleanup;
  }
 
  /*
    OPEN the queue file.
  */
 
  rc = OS_Q_open (envir_ptr->file_queue,
                  &envir_ptr->q_handle,
                  &envir_ptr->msg_params);
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "queue %s failed (rc=%d)",
                     envir_ptr->file_queue, (int)rc);
    goto cleanup;
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
                     "queue %s opened successfuly",
                     envir_ptr->file_queue);
 
  /*
    INITIALIZE the external encryption - in case it is in ACTIVE or
    DEBUG mode.
  */
 
  if (envir_ptr->encr_ext_act NE NOT_ACT_ENCR) {
    if (envir_ptr->encr_ext_act EQ ACT_ENCR)
      encryption_active_ext = ENC_TRUE;
    else
      encryption_active_ext = ENC_FALSE;
    envir_ptr->encryption_active_ext = encryption_active_ext;
 
    rc= ENC_init_keys (envir_ptr->file_encrext,
                       &envir_ptr->enc_external_handle, /*keys_handle*/
                       &encryption_err);
 
    if (rc NE ESA_OK)
      CS_encr_msg (&encryption_err);
 
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
    "External encryption initialization completed with return code:%s",
                     ESA_rc2str(rc));
 
    if (rc NE ESA_OK)
      goto cleanup;
 
  }/* end of external encryption init */
 
  /*
    INITIALIZE CD's internal encryption - in case it is active.
  */
  if (envir_ptr->encr_int_act NE NOT_ACT_ENCR) {
 
      if (envir_ptr->encr_int_act EQ ACT_ENCR)
        encryption_active = ENC_TRUE;
      else
        encryption_active = ENC_FALSE;
 
      rc = ENC_init_intrn_key (envir_ptr->file_encrint,
                               encryption_active,
                               &envir_ptr->enc_internal_handle,
                               &encryption_err);
 
      if (rc NE ESA_OK)
        CS_encr_msg (&encryption_err);
 
      ESA_DIAG_printf (ESA_COMP_ACSGPFM, 15,
      "Internal encryption init. completed with return code:%s",
                       ESA_rc2str(rc));
 
      if (rc NE ESA_OK)
        goto cleanup;
 
  } /* END of internal encryption init */
 
  /*
   RETRIEVE the lock_wait parameter from RSSPARM file (single parameter
   for all RSS types).
 */
 
  rc= rssprm_get (envir_ptr->all_rss, WAIT_LOCK, 10, interval);
  if (rc EQ ESA_OK) {
    ii= strspn (interval, POSITIVE_VALUE);
    if (ii NE strlen (interval)) {
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     WAIT_LOCK, interval,envir_ptr->file_rssparm);
      goto cleanup;
    }
  }
 
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "%s parameter from %s failed (rc=%d)",
                     WAIT_LOCK, envir_ptr->file_rssparm, (int)rc);
    goto cleanup;
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "%s parameter from %s is %s",
                     WAIT_LOCK, envir_ptr->file_rssparm, interval);
 
  envir_ptr->lock_wait= atoi (interval);
 
  /*
    RETRIEVE the read queue wait time parameter from RSSPARM file
    (single parameter for all RSS types).
 */
 
  /*
    ALLOCATE buffer for encryption/decryption activities - if either
    the internal or external encryption is active.
  */
  if ((envir_ptr->encr_ext_act NE NOT_ACT_ENCR) OR
      (envir_ptr->encr_int_act NE NOT_ACT_ENCR))
    rc= CSA_alloc ((char **)&envir_ptr->enc_ptr, 0,
                   (unsigned)envir_ptr->msg_size,
                   1, fn, "Enc. space");
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    Load list of interesting users, groups and connections.
  */
 
  rc= CARE_int_usr_load ();
  if (rc EQ ESA_OK)
    rc= CARE_int_oe_load  ();
  if (rc EQ ESA_OK)
    rc= CARE_int_ug_load  ();
  if (rc EQ ESA_OK)
    rc=CARE_int_u2ug_load();
  if (rc NE ESA_OK)
    goto cleanup;
 
 /*
    ACCEPT ofli & onli semaphore files for every RSS
  */
 
  for (ii= 0; ii LT (unsigned int)envir_ptr->max_rss_num; ii++) {
 
     rc= rssprm_get (envir_ptr->interest[ii].rss,
                     SYNC_SEMAPHORE,
                     MAX_RSS_RESOURCE_NAME_LEN ,
                     interval);
     if (rc NE ESA_OK)
        goto cleanup;
     strcpy (envir_ptr->interest[ii].file_ofli_semaphore, interval);
     rc=   rssprm_get_opt (envir_ptr->interest[ii].rss,
                       LOG_INTERCEPT_MSG,
					   RSSPRM_VALUE_LEN,
					   interval,
					   OPT_TRUE,
				       OPT_FALSE);
     if (rc EQ ESA_OK)
	 {
        if (My_stricmp(interval, LOG_ANY_MSG_VALUE) EQ 0)
           envir_ptr->interest[ii].LogInterceptMsg=
		         LOG_ANY_MSG;
        else if (My_stricmp(interval, LOG_INTRST_MSG_VALUE) EQ 0)
           envir_ptr->interest[ii].LogInterceptMsg=
				 LOG_INTRST_MSG;
        else if (My_stricmp(interval, LOG_SKIPED_MSG_VALUE) EQ 0)
           envir_ptr->interest[ii].LogInterceptMsg=
				 LOG_SKIPED_MSG;
        else if (My_stricmp(interval, DONTLOG_ANY_MSG_VALUE) EQ 0)
           envir_ptr->interest[ii].LogInterceptMsg=
				 DONTLOG_ANY_MSG;
        else
           envir_ptr->interest[ii].LogInterceptMsg=
		         LOG_ANY_MSG;
	 }
	 else
        envir_ptr->interest[ii].LogInterceptMsg= LOG_ANY_MSG;
 
     rc=   rssprm_get_opt (envir_ptr->interest[ii].rss,
                       LOG_GET_MSG,
					   RSSPRM_VALUE_LEN,
					   interval,
					   OPT_TRUE,
				       OPT_FALSE);
     if (rc EQ ESA_OK)
	 {
        if (My_stricmp(interval, LOG_ANY_MSG_VALUE) EQ 0)
           envir_ptr->interest[ii].LogGetMsg=
		         LOG_ANY_MSG;
        else if (My_stricmp(interval, DONTLOG_ANY_MSG_VALUE) EQ 0)
           envir_ptr->interest[ii].LogGetMsg=
				 DONTLOG_ANY_MSG;
        else
           envir_ptr->interest[ii].LogGetMsg=
		         LOG_ANY_MSG;
	 }
	 else
        envir_ptr->interest[ii].LogGetMsg= LOG_ANY_MSG;
 
	 ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
		             "%d: rss=%s LogInterceptMsg=%c LogGetMsg=%c .",
					 ii, envir_ptr->interest[ii].rss,
                     envir_ptr->interest[ii].LogInterceptMsg,
                     envir_ptr->interest[ii].LogGetMsg);
 
  }
 
  /*
    Load RSS-API params and keywords
  */
 
  rc= rssapiprm_load    ();
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "Parametres from file %s failed (rc=%d)",
                     envir_ptr->file_rssapi, (int)rc);
    goto cleanup;
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "Parametres from file %s loaded successfuly",
                     envir_ptr->file_rssapi);
  rc= rssapikwd_load ();
  if (rc NE ESA_OK)
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "Keywords from file %s failed (rc=%d)",
                     envir_ptr->file_rsskwds, (int)rc);
  else
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "Keywords from file %s loaded successfuly",
                     envir_ptr->file_rsskwds);
  if (rc NE ESA_OK) {
    goto cleanup;
  }
 
    /*
      LOAD (read) the rss offline file into the rss table.
    */
  if(envir_ptr->p_main_name  NE ESA_ACD_PROC)    /*IS10072*/
  {                                              /*IS10072*/
  rc= tbl_load (&rsstbl, (int *)(&rsstbl_num));
  if (rc NE ESA_OK)
      goto cleanup;
  for(ii= 0; ii LT rsstbl_num; ii++)
  {
      memcpy ((char *)rss_id, (char *)rsstbl[ii].rss,sizeof(RSS_typ));
      rss_id[RSS_NAME_LEN]= '\0';
      strtok (rss_id, " ");
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 16,
                       "rsstbl: %d rss %s dwnld_sync_method %c.",
          ii, rss_id, rsstbl[ii].dwnld_sync_method);
      for(jj= 0; jj LT (unsigned int)envir_ptr->max_rss_num; jj++)
      {
        if (My_stricmp(envir_ptr->interest[jj].rss , rss_id) EQ 0)
        {
          envir_ptr->interest[jj].prev_dwnld_sync_method=
              rsstbl[ii].dwnld_sync_method;
          envir_ptr->interest[jj].dwnld_sync_method =
              rsstbl[ii].dwnld_sync_method;
          ESA_DIAG_printf (ESA_COMP_ACSGPF, 16,
             "envir_ptr->interest: %d rss %s dwnld_sync_method %c.",
              jj,
              envir_ptr->interest[jj].rss,
              envir_ptr->interest[jj].dwnld_sync_method);
          break;
         }
      }
  }
 } /*IS10072*/
 
    /*
      LOAD (read) the file of administrators .
    */
  /*WS10082A RSSADM file is not used in MF
  if (strlen (envir_ptr->file_administrators) NE 0)
     rc= ADM_load ();
 
  if (rc NE ESA_OK)
     goto cleanup;
  end of WS10082A ********/
  if (envir_ptr->p_main_name EQ ESA_ACS_PROC)
  {
    for (jj= 0; jj LT (unsigned int)envir_ptr->max_rss_num; jj++)
	{
       interest= envir_ptr->interest+ jj;
	   if (0 LT interest->pre_num_oes+
		      interest->pre_num_ugs+
			  interest->pre_num_u2ugs+
			  interest->pre_num_users)
	   {
          CTSAMSG_print (MSG_AGENT_INTEREST_SCOPE,
                       envir_ptr->msg_admin_param.ctsamsg_handle,
                       NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
			           interest->rss);
          CARE_list_oe  (interest->pre_oes_ptr,
			           interest->pre_num_oes);
          CARE_list_ug  (interest->pre_ugs_ptr,
			           interest->pre_num_ugs);
          CARE_list_u2ug(interest->pre_u2ugs_ptr,
			           interest->pre_num_u2ugs);
          CARE_list_usr (interest->pre_users_ptr,
			           interest->pre_num_users);
	   }
	}
  }
cleanup:
  if (rsstbl NE NULL)
  {
     CSA_free ((char **)&rsstbl);
     rsstbl = NULL;
  }
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_init function */
 
/****************************************************
 * Procedure Name: CS_term
 * Description   : Term. environment parameters
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :ver 2.0.1.1
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated as part of CS/CD process termination,
 * due to termination message received or due to asynchronous signal
 * event capture. In case of "regular" activation, the input parameter
 * "exit_signal" contain zero, otherwise it contains the number of
 * signal that was raised.
 * The function "closes" all open edges of the environment:
 * - Unlocks & closes all locked/opened files.
 * - Releases all global memory segments that were allocated.
 * - Activate all xxx_term function that their related xxx_init
 *   function was activated.
 * - Activates the CG_epilog to release all "general" items allocated
 *   by the CG_prolog function.
 * Please note that the order of activities should be in REVERSE ORDER
 * to the allocation activities done in the CS_init function.
 **********************************************************************/
 
ESA_RC CS_term (ESA_RC        exit_rc,
                int           exit_signal)
{
  char                  fn[]="CS_term";
  ESA_RC                rc= ESA_OK;
  ENC_ERR_rec_typ       encryption_err;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  /*
    LOGOUT from "administrator's account" if you are logged-in.
  */
  if (envir_ptr->login_mode NE LOGOUT_MODE_LAST)
  {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                     "CS_term, about to enter ADM_loginout...");
    rc= ADM_loginout (LOGOUT_MODE_LAST, LOGIN_UNDEFINED_ADMIN, fn);
  }
 
  CS_detach_rss ();
 
  /*
    FREE interesting keywords and global parameters.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
       "CS_term, about to enter CSA_free for envir_ptr->keywords...");
  CSA_free ((char **)&envir_ptr->keywrds);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
      "CS_term, about to enter CSA_free for envir_ptr->params...");
  CSA_free ((char **)&envir_ptr->params);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter CARE_int_usr_free...");
  CARE_int_usr_free ();
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter CARE_int_oe_free...");
  CARE_int_oe_free  ();
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter CARE_int_ug_free...");
  CARE_int_ug_free  ();
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter CARE_int_u2ug_free...");
  CARE_int_u2ug_free  ();
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter ADM_free...");
  /*WS10082A ADM_free(); not needed any more */
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
        "CS_term, about to enter CSA_free for envir_ptr->enc_ptr...");
  CSA_free ((char **)&envir_ptr->enc_ptr);
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
     "CS_term, about to enter CSA_free for envir_ptr->entity_info...");
  CSA_free ((char **)&envir_ptr->entity_info);
  /*
    LOCATE and print all (unexpectedly) allocated segments and open
    files/locks.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
       "CS_term, about to enter ESA_DIAG_get_debug_level (1)...");
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
            "CS_term, about to enter ESA_DIAG_get_debug_level (2)...");
  CSA_print_lock_tbl();
  /*
    UNLOCK files Close them and release lock details for open/locked
    files.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter CSA_close_all...");
  CSA_close_all ();
  /*
    RELEASE internal encryption details - if they were allocated.
  */
  if (envir_ptr->enc_internal_handle NE NULL)
  {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter ENC_term on internal...");
 
    ENC_term (&envir_ptr->enc_internal_handle);
    envir_ptr->enc_internal_handle= NULL;
  }
 
  /*
    RELEASE external encryption details - if they were allocated.
  */
 
  if (envir_ptr->enc_external_handle NE NULL)
  {
     if (envir_ptr->enc_external_key_handle NE NULL)
     {
        ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                  "CS_term, about to enter ENC_term on external...");
        ENC_term (&envir_ptr->enc_external_key_handle);
        envir_ptr->enc_external_key_handle = NULL;
     }
 
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter ENC_term_keys...");
    rc = ENC_term_keys (&envir_ptr->enc_external_handle,
                        &encryption_err);
    envir_ptr->enc_external_handle= NULL;
    if (rc NE ESA_OK)
    {
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                       "CS_term, about to enter ENC_encr_msg...");
      CS_encr_msg (&encryption_err);
 
      ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
      "External encryption termination completed with return code:%s",
                     ESA_rc2str(rc));
 
    }
  }
 
 
  /*
    CLOSE/RELEASE queue.
  */
  if (envir_ptr->q_handle.file NE NULL)
  {
    ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter OS_Q_close...");
    OS_Q_close (&envir_ptr->q_handle);
  }
 
  /*
    DETACH from input and output mailbox channels.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
             "CS_term, about to enter ESA_MBX_detach (channel_i)...");
  rc = ESA_MBX_detach (envir_ptr->channel_i);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
             "CS_term, about to enter ESA_MBX_detach (channel_o)...");
  rc = ESA_MBX_detach (envir_ptr->channel_o);
 
  /*
    TERMINATE usage of OS_events package.
  */
  if (envir_ptr->event_active)
  {
     ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                      "CS_term, about to enter OS_EVENT_term...");
     ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
                   "...-> OS_EVENT_term: hndl=%p.",
				   			envir_ptr->event_handle);
     rc = OS_EVENT_term (&envir_ptr->event_handle ,
                         &envir_ptr->msg_params);
     ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
      "...<- OS_EVENT_term: rc=%d (%s).",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
  }
 
  envir_ptr->event_handle = NULL;
  /*
    TERMINATE usage of OS functions.
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter OS_CS_term...");
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
       "...-> OS_CS_term: main=%s hndl=%p.",
       CG_main_name (envir_ptr->p_main_name),
	   envir_ptr->os_cs_init_handle);
  rc = OS_CS_term (CG_main_name (envir_ptr->p_main_name),
                   &envir_ptr->msg_params,
                   &envir_ptr->os_cs_init_handle);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
      "...<- OS_CS_term: rc=%d (%s).",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
  /*
    ACTIVATE (happy) epilog.
  */
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,
                   "CS_term, about to enter CG_epilog...");
  CG_epilog (exit_rc , exit_signal);
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_term function */
 
/* SAS2IBMN - start  */
/*****************************************************************
*                                                                *
* SAS2IBMN - Remove signal processing                            *
*                                                                *
* Signal processing is removed because it depends on the         *
* HANDLE_ABENDS RSSPARM ALL_RSS parameter which is always N.     *
* If/when recovery is needed, these routines will have to be     *
* written using the appropriate IBM C or LE services.            *
*                                                                *
* Considerations:                                                *
* 1. LE has its own recovery so we should find a way to control  *
*    LE dump and backtrace according to our needs.               *
*                                                                *
******************************************************************
 ****************************************************
 * Procedure Name: CS_term
 * Description   : Term. environment parameters
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :ver 2.0.1.1
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is an asynchronous function that is activated
 * upon signal raise in the process. It activates the CS_term
 * function and handles it the signal id.
 *********************************************************************
 
void CS_signal (int signal_code)
{
  char   fn[]="CS_signal";
 
  printf ("\n Entering CS_signal with sig id: #%d", signal_code);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
   *
    TERMINATE the process.
  *
  CS_term (ESA_OK, signal_code);
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, ESA_RC_VOID);
 
}  * END - CS_signal function *
/* SAS2IBMN - end    */
 
/****************************************************
 * Procedure Name: CS_os_event
 * Description   : CHECK and handl events.
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated from the CS_start_srvice function
 * in order to check if any of the following events (temporary list)
 * took place:
 * - The DIAG LEVELS were modified (by the CTSA_diag utility).
 * - The Important keywords file was modified by another CS/CD server.
 * - Any of the Important Users/Groups/Connection files was modified
 *   by another CS/CD server.
 *
 * The function activates the relevant function for each type of event.
 * Please note that this function is activated in conjunction with the
 * "Broadcast messages" handling - and it is assumed (although it will
 * dump the system) that only one of the above methods is used (right
 * now - the Important user/groups/connections and Interesting keywords
 * are activated only by MVS using the current function - while other
 * platforms uses the "broadcast message method". All platforms uses
 * the diag levels modified via the os_events function).
 *********************************************************************/
 
static ESA_RC CS_os_event (void)
{
  char   fn[]="CS_os_event";
  ESA_RC rc= ESA_OK;
  ESA_EVENT_typ              events[EVENT_TERMINATE + 1];
  ESA_EVENT_STATUS_typ       event_stat[EVENT_TERMINATE + 1];
  void                     * event_data[EVENT_TERMINATE + 1];
  ENVIRONMENT_rec_typ      * envir_ptr;
  char                       EventsStr[250];
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON, fn);
  CLEAR(events);
  CLEAR(event_stat);
  CLEAR(event_data);
 
  /*
    CHECK (and clear event) if DIAG LEVELS were modified.
  */
  events[0]= EVENT_AGENT_SHUTDOWN;
  events[1]= EVENT_DIAG_CHANGED;
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
       "...-> OS_EVENT_clear: EVENT_DIAG_CHANGED,EVENT_AGENT_SHUTDOWN hndl=%p.",
	   envir_ptr->event_handle);
  rc = OS_EVENT_clear ( 2 ,
                        events ,
                        event_stat ,
                        event_data ,
                        envir_ptr->event_handle,
                        &envir_ptr->msg_params);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
      "...<- OS_EVENT_clear: rc=%d (%s).",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
  if (rc EQ ESA_FATAL) /* fatal only !! */
     goto cleanup;
 
  if (
         (rc EQ ESA_OK) AND (event_stat[0] EQ EVENT_ON)
     )
  {
      ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
          "!!!*****>... ShutDown request event accepted.");
	  rc=ESA_TERM_CTSA;
      CTSAMSG_print (ERR_UL_POS_STRING,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest, fn, rc,
					"Accepted shutdown request.");
      goto cleanup;
  }
 
  /*
    LOAD the diag leves file in case that it was modified (ESA_OK =
    file has been modified, ESA_WARN file has not been modified), OR
    if the OS events package does not support that service.
  */
 
  if (
      ( (rc EQ ESA_OK) AND (event_stat[1] EQ EVENT_ON) )
     OR
      (rc EQ ESA_NOT_SUPP) ) {
 
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
       "*****>... Diagnostic changes event accepted.");
    rc = ESA_DIAG_set_debug_levels_file (envir_ptr->file_diaglvl, envir_ptr->p_main_name);
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_OS,
       "Reload Diag.levels file %s completed with rc=%s",
                     envir_ptr->file_diaglvl, ESA_rc2str(rc));
    if (rc NE ESA_OK)
      goto cleanup;
 
  } /* END - diag level should be reloaded */
  else
    rc = ESA_OK;
 
 
  if (rc NE ESA_OK)
     goto cleanup;
 
  CLEAR(events);
  CLEAR(event_stat);
  CLEAR(event_data);
 
  /*
    CHECK (and clear) if any of the interesting keywords, users, groups
    or connections files was modified.
  */
  events[0] = EVENT_KEYWORDS_CHANGED;
  events[1] = EVENT_IMPOE_CHANGED;
  events[2] = EVENT_IMPGRP_CHANGED;
  events[3] = EVENT_IMPUSR_CHANGED;
  events[4] = EVENT_IMPCNN_CHANGED;
  events[5] = EVENT_OFLI_PARAMS_CHANGED;
  events[6] = EVENT_ADMIN_CHANGED;
 
  strcpy (EventsStr,
   "EVENT_KEYWORDS_CHANGED,EVENT_IMPOE_CHANGED,EVENT_IMPGRP_CHANGED");
  strcat (EventsStr,
   "EVENT_IMPUSR_CHANGED,EVENT_IMPCNN_CHANGED,EVENT_ADMIN_CHANGED");
  strcat (EventsStr, "EVENT_OFLI_PARAMS_CHANGED");
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
    "...-> OS_EVENT_clear: hndl=%p Events=%s.",
	   envir_ptr->event_handle, EventsStr);
  rc = OS_EVENT_clear ( 7 ,
                        events ,
                        event_stat ,
                        event_data ,
                        envir_ptr->event_handle,
                        &envir_ptr->msg_params);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_OS,
      "...<- OS_EVENT_clear: rc=%d (%s).",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
  if (rc EQ ESA_FATAL) /* fatal only !! */
     goto cleanup;
 
  if ( (rc EQ ESA_OK) AND (event_stat[0] EQ EVENT_ON) ) {
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
       "*****>... RSS-API keyword changes event accepted.");
    /*
      LOAD Interesting keywords file - if it was modified.
    */
    rc = CS_brdcst_msg (NULL , 0 , EVENT_KEYWORDS_CHANGED);
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_OS,
                     "CS_brdcst_msg for KEYWORDS returned with rc=%s",
                     ESA_rc2str(rc));
    if (rc NE ESA_OK)
      goto cleanup;
  }
 
  if ( (rc EQ ESA_OK) AND
       ( (event_stat[1] EQ EVENT_ON) OR
         (event_stat[2] EQ EVENT_ON) OR
         (event_stat[3] EQ EVENT_ON) OR
         (event_stat[4] EQ EVENT_ON) OR
         (event_stat[5] EQ EVENT_ON) ) ) {
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
     "*****>... Aggregation scope changes event accepted.");
 
    /*
      LOAD all User/Group/Connection in case any one of them was
      modified.
    */
    rc = CS_brdcst_msg (NULL , 0 , EVENT_IMPUSR_CHANGED);
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_OS,
        "CS_brdcst_msg for INTERESTING FILES returned with rc=%s",
                     ESA_rc2str(rc));
    if (rc NE ESA_OK)
      goto cleanup;
  }
 
  if ( (rc EQ ESA_OK) AND (event_stat[6] EQ EVENT_ON) ) {
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
       "*****>... Administrator changes event accepted.");
    /*
      LOAD Administrators file - if it was modified.
    */
    rc = CS_brdcst_msg (NULL , 0 , EVENT_ADMIN_CHANGED);
    ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_OS,
         "CS_brdcst_msg for ADMINISTRATORS returned with rc=%s",
         ESA_rc2str(rc));
    if (rc NE ESA_OK)
      goto cleanup;
  }
 
  rc= ESA_OK;
 
cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_os_event function */
 
/****************************************************
 * Procedure Name: CS_send_ug2uc_msg
 * Description   : Build message for GTUG2UC
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      : Message needs for HOT_PATH_FULL
 * Scope         :
 ****************************************************/
 
ESA_RC CS_send_ug2uc_msg (RSS_MSG_HDR_rec_typ * msg_hdr,
                          TRAN_rec_typ        * tran,
                          char                * ug,
                          char                * usr)
{
  ESA_RC                rc;
  MSG_typ             * buffer = NULL;
  NUM_MSGS_typ          sngl_msg_len= 0, num_msgs= 1;
  MSG_U2UG_rec_typ      u2ug_msg;
  char                  fn[]="CS_send_ug2uc_msg";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF,
                   13,
                   "Group %s User %s.",
                   ug,
                   usr);
  memcpy ((char *)(&u2ug_msg), (char *)msg_hdr,
          sizeof (RSS_MSG_HDR_rec_typ));
  memcpy ((char *)(&u2ug_msg.msg_hdr.mhmtyp), MSG_UG2UC_GET, 2);
  sprintf(u2ug_msg.num_msgs,"%03X", num_msgs);
  CS_set_tran ((char *)u2ug_msg.msg_tran , tran);
 
  buffer = u2ug_msg.msg_u2ug;
  sngl_msg_len = RSS_NUM_MSGS + (sizeof(TRAN_typ)* 2);
 
  buffer = CS_set_fld (ug,
                       buffer,
                       &sngl_msg_len,
                       envir_ptr->rss_limits.max_ug_len ,
                       C_GROUP_ID);
  ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "1: Con. Group=%s.",ug);
  if (buffer EQ NULL)
    goto cleanup;
  buffer = CS_set_fld (usr,
                       buffer,
                       &sngl_msg_len,
                       envir_ptr->rss_limits.max_user_len ,
                       C_USER_ID);
  ESA_DIAG_printf(ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
       "2: Con. User=%s.",usr);
  if (buffer EQ NULL)
    goto cleanup;
 
  if (CS_set_sngl_msg_len((char *)u2ug_msg.msg_length,
                          sngl_msg_len) NE ESA_OK) {
    buffer= NULL;
    goto cleanup;
  }
  envir_ptr->msg_ptr = (char *)&u2ug_msg;
  envir_ptr->msg_size= sizeof (MSG_U2UG_rec_typ);
  /* CS_ug2uc_get is not used with one phase aggregation - WS10082A*
  CS_ug2uc_get ((char *)&u2ug_msg ,
                msg_hdr ,
                msg_hdr ,
                FUNC_GTUG2UC);
  *** end of WS10082A ***/
  cleanup:
 
  if (buffer EQ NULL)
     rc= ESA_ERR;
  else
     rc= ESA_OK;
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return (rc);
}
 
/****************************************************
 * Procedure Name: CS_send_msg
 * Description   : send the message
 *                 mail box
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION:
 * =====================
 *
 * This function is the ONLY function that writes to the CS/CD
 * output mailbox. None "control" messages are encrypted (in case
 * the encryption is active) and their "SEQUENCE NUMBER" is
 * incremented.
 *****************************************************************/
 
ESA_RC CS_send_msg (MSG_typ * msg_ptr,
                    int       msg_length)
{
  char                  fn[]="CS_send_msg";
  ESA_RC                rc= ESA_OK;
  RSS_MSG_HDR_rec_typ   msg_hdr;
  char                  msg_seq [sizeof(MH_seq)+ 1];
  int                   encryption_out_len;
  ENC_ERR_rec_typ       encryption_err;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
  rc= CS_shutdown_event ();
  if (rc EQ ESA_TERM_CTSA)
     goto cleanup;
 
  /*
    PRINTE editted message (on DIAG level only).
  */
/*  CS_print_msg(msg_ptr , msg_length); */
 
  /*
    PROCESS none control messages - identified by size, larger than
    the message header size, and service type (first character in
    message buffer) - not "broadcast message" (that may have any
    length):
  */
  ESA_DIAG_printf (ESA_COMP_ACSGPFW, DIAG_MSGHDR,
		"     ==> ESA_MBX_write: Hndl=%p Msg=%p %s=%d %d bytes.",
		envir_ptr->channel_o, msg_ptr,
		"ESA_MBX_WAIT", ESA_MBX_WAIT, (unsigned int)msg_length);
  CS_DIAG_MSG (ESA_COMP_ACSGPFW, 0, msg_ptr, msg_length, TRUE);
  CS_DIAG_MSG (ESA_COMP_ACSGPFW, 0, msg_ptr, msg_length, FALSE);
 
  if (
       ((unsigned int)msg_length GE sizeof (RSS_MSG_HDR_rec_typ))
      AND
       (strncmp(msg_ptr,CD_SRVR_MSG_BRDCT, 1) NE 0)
     ){
 
    /*
      UPDATE the message's header sequence number and encryption
      indication.
    */
    sprintf(msg_seq,"%06d",BK_msg_seq);
    memcpy ((char *)(&msg_hdr), (char *)msg_ptr,
            sizeof (RSS_MSG_HDR_rec_typ));
    memcpy ((char *)msg_hdr.mhseq, (char *)msg_seq, sizeof(MH_seq));
 
    if (envir_ptr->encr_ext_act EQ NOT_ACT_ENCR)
      msg_hdr.mhcmrs=MH_ENCR_OFF;
    else if (envir_ptr->encr_type EQ ENC_DES)
      msg_hdr.mhcmrs=MH_ENCR_ON;
    else
      msg_hdr.mhcmrs=MH_ENCR_NEW;
 
    memcpy ((char *)msg_ptr, (char *)(&msg_hdr),
            sizeof (RSS_MSG_HDR_rec_typ));
 
    ESA_DIAG_printf (ESA_COMP_ACSGPFW, 15,
        "CS_send_msg: msg_hdr <%.*s> BK_msg_seq %d.",
         sizeof (RSS_MSG_HDR_rec_typ),
         (char *)msg_ptr, (int)BK_msg_seq);
 
    /*
      PROCESS when communication encryption is needed:
    */
    if (envir_ptr->encr_ext_act NE NOT_ACT_ENCR) {
 
      /*
        ENCRYPT the message body.
      */
      ESA_DIAG_printf (ESA_COMP_ACSGPFW, 15,
        "envir_ptr: msg_size=%d max_msg_size=%d.",
        (int)envir_ptr->msg_size, (int)envir_ptr->max_msg_size);
 
      encryption_out_len= envir_ptr->max_msg_size;
      rc = ENC_encr(envir_ptr->enc_external_key_handle,
                    msg_ptr+sizeof (RSS_MSG_HDR_rec_typ),
                    (int)(msg_length - sizeof (RSS_MSG_HDR_rec_typ)),
                    envir_ptr->encr_type, /*ENC_FALSE,*/
                    envir_ptr->enc_ptr,
                    &encryption_out_len,
                    &encryption_err);
 
      if (rc NE ESA_OK) {
        CS_encr_msg (&encryption_err);
        goto cleanup;
      } /* END - Encryption failed */
 
      ESA_DIAG_printf (ESA_COMP_ACSGPFW, 15,
          "Encryption completed with return code:%s enc_out_len=%d.",
                       ESA_rc2str(rc), (int)encryption_out_len);
 
      memcpy ((char *)(msg_ptr + sizeof (RSS_MSG_HDR_rec_typ)),
              (char *)envir_ptr->enc_ptr,
              (unsigned)encryption_out_len);
 
      /*
        RECALCULATE the message length after encryption.
      */
      msg_length = encryption_out_len + sizeof (RSS_MSG_HDR_rec_typ);
    } /* END - Encryption is active */
 
  } /* END - None control message */
 
  if ( (envir_ptr->download_hndl) AND (msg_ptr[0] EQ DWNLD_SERVICE) )
  {
  /*
   * WRITE message of download to file.
   */
     int    coff, cleft, clen, rcc = 0;
     char * str;
 
     coff  = 0;
     cleft = msg_length;
     str= (char *)msg_ptr;
 
     while ( (cleft GT 0) AND (rcc NE EOF) ) {
        clen = strlen((char *)& str [coff])+1;
        rcc= fputs ((char*)&str[coff], envir_ptr->download_hndl);
        cleft = cleft - clen;
        coff  = coff  + clen;
     }
	 if (rcc NE EOF)
        fputs ("\n",envir_ptr->download_hndl);
	 if (rcc EQ EOF)
	 {
        CTSAMSG_print (ERR_FILE,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    fn, "fputs", envir_ptr->file_download, strerror(errno));
        rc= ESA_ERR;
        goto cleanup;
	 } /* if i/o error */
     BK_msg_seq--;
  }
  else
  /*
   * WRITE message to mailbox.
   */
     rc = ESA_MBX_write (envir_ptr->channel_o,
                      (char *) msg_ptr,
                      msg_length ,
                      ESA_MBX_WAIT);
  ESA_DIAG_printf (ESA_COMP_ACSGPFW, DIAG_MSGHDR,
			"     <== ESA_MBX_write: rc=%d (%s).",
	        rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
  ESA_DIAG_printf (ESA_COMP_ACSGPFW, 15,
                   "ESA_MBX_WRITE completed with rc:%d , Msg_size:%d",
                   (int)rc ,
                   msg_length);
 
  if (rc NE ESA_OK) {
     ESA_RC rc_event= ESA_OK;
     rc_event= CS_shutdown_event ();
     if (rc_event EQ ESA_TERM_CTSA)
         rc= rc_event;
	 else
         CTSAMSG_print (ERR_CS_MBX_WRITE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, ESA_rc2str(rc));
    goto cleanup;
  }
  if (msg_length GE sizeof (RSS_MSG_HDR_rec_typ))
     ESA_DIAG_printf (ESA_COMP_ACSGPFW, DIAG_BASIC,
          "*****>... %c%c: Successfully Sent information message to IIQ/IDN.",
          msg_hdr.mhmtyp, msg_hdr.mhrtyp);
 
  /* INCREMENT the global service sequence number - in case it is
     not control message.
  */
  if ((unsigned int)msg_length GE sizeof (RSS_MSG_HDR_rec_typ) AND
      strncmp(msg_ptr,CD_SRVR_MSG_BRDCT, 1) NE 0)
    BK_msg_seq++;
 
  ERROR_CLEAR (&envir_ptr->msg_err);
 
  cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  /* fix 062499 */
  if ((rc EQ ESA_FATAL) OR
      (rc EQ ESA_MBX_NOT_EXIST ))
    rc = ESA_FATAL_IO;
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
  return(rc);
 
  /* fix 062499 */
} /* end of CS_send_msg function */
 
 
/***************************************************************
*                                                              *
* Procedure Name : CS_broadcast                                *
*                                                              *
* Description    : Broadcast file of administrators            *
* INPUT            msg_event_type                              *
*                  event_type                                  *
*                                                              *
* Return Value   : ESA_RC                                      *
***************************************************************/
 
ESA_RC CS_broadcast (char          msg_event_type,
                     ESA_EVENT_typ event_type)
{
  char                  fn [] = "CS_broadcast";
  ESA_RC                rc= ESA_OK;
  ESA_MAIN_NAME_typ     brdcst_dest[2];
  ESA_EVENT_typ         events[4];
  void                * evnt_data[4];
  BRDCST_rec_typ        brdcst;
  int                   event_num;
  char                  EvntTypeStr[30];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,"event: %c %d.",
      msg_event_type, event_type);
 
  if (envir_ptr->event_active)
  {
     ESA_DIAG_printf (ESA_COMP_ACSGPF, 15,"adm. event active.");
 
     /*
        SET "interesting keywords" event for all other servers.
     */
     brdcst_dest[0] = ESA_ACD_PROC;
     brdcst_dest[1] = ESA_ACS_PROC;
     events[0] = event_type;
     evnt_data[0] = NULL;
     if (event_type EQ EVENT_IMPOE_CHANGED)
     {
        events[1] = EVENT_IMPGRP_CHANGED;
        events[2] = EVENT_IMPUSR_CHANGED;
        events[3] = EVENT_IMPCNN_CHANGED;
        evnt_data[1] = NULL;
        evnt_data[2] = NULL;
        evnt_data[3] = NULL;
        event_num= 4;
     }
     else
        event_num= 1;
 
     switch (event_type) {
            case EVENT_DIAG_CHANGED:
               strcpy (EvntTypeStr, "EVENT_DIAG_CHANGED");
               break;
            case EVENT_KEYWORDS_CHANGED:
               strcpy (EvntTypeStr, "EVENT_KEYWORDS_CHANGED");
               break;
            case EVENT_IMPOE_CHANGED:
               strcpy (EvntTypeStr, "EVENT_IMPOE_CHANGED");
               break;
            case EVENT_IMPGRP_CHANGED:
               strcpy (EvntTypeStr, "EVENT_IMPGRP_CHANGED");
               break;
            case EVENT_IMPUSR_CHANGED:
               strcpy (EvntTypeStr, "EVENT_IMPUSR_CHANGED");
               break;
            case EVENT_UNDEF:
               strcpy (EvntTypeStr, "EVENT_UNDEF");
               break;
            case EVENT_IMPCNN_CHANGED:
               strcpy (EvntTypeStr, "EVENT_IMPCNN_CHANGED");
               break;
            case EVENT_OFLI_PARAMS_CHANGED:
               strcpy (EvntTypeStr, "EVENT_OFLI_PARAMS_CHANGED");
               break;
            case EVENT_AGENT_SHUTDOWN:
               strcpy (EvntTypeStr, "EVENT_AGENT_SHUTDOWN");
               break;
            case EVENT_TERMINATE:
               strcpy (EvntTypeStr, "EVENT_TERMINATE");
               break;
			default :
               strcpy (EvntTypeStr, "UNDEFINED!!!");
               break;
	 }
     ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
      "    =<> Call to OS_EVENT_broadcast:  hndl=%p MsgEvntType=%c EvntType=%s.",
	   envir_ptr->event_handle, msg_event_type, EvntTypeStr);
     rc = OS_EVENT_broadcast (event_num ,
                              events ,
                              2 ,
                              brdcst_dest ,
                              evnt_data ,
                              envir_ptr->event_handle ,
                              &envir_ptr->msg_params);
     ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
     "    <>= OS_EVENT_broadcast completed with rc=%d (%s)",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
  }
  else
  {
     /*
       SEND "BROADCAST" message with "Admin changes" subtype -
       to the CO in order to be distributed to all other servers.
     */
     brdcst.cntrl_msg_type= CD_SRVR_MSG_BRDCT[0];
     brdcst.msg_type=       CS_BRDCT_EVNT;
     brdcst.msg_subtype=    msg_event_type;
     rc= CS_send_msg((MSG_typ *)&brdcst, sizeof (BRDCST_rec_typ));
     ESA_DIAG_printf (ESA_COMP_ACSGPF, 11,
         "MSG:Sended broadcast message (rc=%d).", (int)rc);
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
 
  return (rc);
 
}
 
static void CS_ess_rss_name_type (RSS_typ rss,
                                  RSS_typ rss_typ,
                                  RSS_typ ess_rss,
                                  RSS_typ ess_rss_typ)
{
  int                   ii;
  char                  fn [] = "CS_ess_rss_name_type";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 13,"rss=%s rss_typ=%s.",
                   rss, rss_typ);
 
  strcpy (ess_rss,     rss);
  strcpy (ess_rss_typ, rss_typ);
 
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     if (My_stricmp (envir_ptr->interest[ii].rss, rss) EQ 0)
     {
        if (strlen (envir_ptr->interest[ii].ess_rss) NE 0)
           strcpy (ess_rss, envir_ptr->interest[ii].ess_rss);
        break;
     }
  }
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     if (My_stricmp (envir_ptr->interest[ii].rss_type,
         rss_typ) EQ 0)
     {
        if (strlen (envir_ptr->interest[ii].ess_rss_type) NE 0)
           strcpy (ess_rss_typ, envir_ptr->interest[ii].ess_rss_type);
        break;
     }
  }
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, 14,"ess_rss=%s ess_rss_typ=%s.",
                   ess_rss, ess_rss_typ);
  ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_RC_VOID);
 
  return;
 
}
 
static ESA_RC GetAgentPwdChksum   (char          * agent_pwd_chksum)
{
 char        fn[]="GetAgentPwdChksum";
 ESA_RC      rc= ESA_OK;
 FILE    *   fh = NULL;
 ENVIRONMENT_rec_typ * envir_ptr;
 char        msg[80]="";
 char        ddn_with[12]="";                             /* SAS2IBMT */
 
 ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
 
 CS_get_envir_address (&envir_ptr);
 
 strcpy(ddn_with,"DD:");                                  /* SAS2IBMT */
 strcat(ddn_with, envir_ptr->file_agentpwd);              /* SAS2IBMT */
 
 /* SAS2IBMT fh = fopen(envir_ptr->file_agentpwd,"r");               */
 fh = fopen(ddn_with,"r");                                /* SAS2IBMT */
 if (fh EQ NULL) {
   sprintf(msg, "ACSGPF: Open failed for %s\n",
                envir_ptr->file_agentpwd);
   CTSAMSG_print (ERR_UL_STRING,
                  envir_ptr->ctsamsg_handle, NULL,
                  envir_ptr->ctsamsg_dest,
                  msg);
   rc = ESA_FATAL;
   goto exit;
 }
 fgets(agent_pwd_chksum, CHECKSUM_LEN+1, fh);
 
 fclose(fh);
 rc = ESA_OK;
 
 exit:
 ESA_DIAG_exit (ESA_COMP_ACSGPF, DIAG_COMMON, fn, rc);
 return(rc);
}
 
static void CD_interception_control (ESA_RC Read_RC)
{
   static int            InterceptSw;
   static int            InterceptCount;
   unsigned long int     kwd_num= 0;
   int                   my_wait= 0;
   char                * stopptr= NULL;
   ESA_RC                rc= ESA_OK;
   char                  RssprmValue[RSSPRM_VALUE_LEN+ 1];
   char                  fn[]="CD_interception_control";
   ENVIRONMENT_rec_typ * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
	
   ESA_DIAG_enter (ESA_COMP_ACSGPF, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES+ 1,
	  "Intercept: Delay=%d Max=%d Count=%d Read_RC=%d.",
       InterceptDelay, InterceptMax, InterceptCount, Read_RC);
 
   if (InterceptSw EQ 0)
   {
      InterceptSw= 1;
      rc= rssprm_get_opt ((char *)ALL_RSS, INTERCEPT_SEND_MAX,
         		KEYWORD_TYPES_NUM, RssprmValue, OPT_TRUE, OPT_FALSE);
      if (rc EQ ESA_OK)
	  {
         kwd_num= strtoul (RssprmValue, &stopptr, 10);
         if (*stopptr NE '\0')
            ESA_DIAG_printf (ESA_COMP_ACSGPF, 0,
				"Value %s of the %s keyword don't numeric.",
                   RssprmValue, INTERCEPT_SEND_MAX);
		 else
            InterceptMax= kwd_num;
	  }
 
      rc= rssprm_get_opt ((char *)ALL_RSS, INTERCEPT_SEND_DELAY,
         		KEYWORD_TYPES_NUM, RssprmValue, OPT_TRUE, OPT_FALSE);
      if (rc EQ ESA_OK)
	  {
         kwd_num= strtoul (RssprmValue, &stopptr, 10);
         if (*stopptr NE '\0')
            ESA_DIAG_printf (ESA_COMP_ACSGPF, 0,
				"Value %s of the %s keyword don't numeric.",
                   RssprmValue, INTERCEPT_SEND_DELAY);
		 else
		 {
            InterceptDelay= kwd_num;
   /* BS10076 my_wait= atoi(WAIT_QUEUE_VALUE);                       */
   my_wait= atoi(WAIT_QUEUE_TOTALC);                      /* BS10076 */
          if (InterceptDelay GT my_wait)
   {
            InterceptDelay= my_wait;
               ESA_DIAG_printf (ESA_COMP_ACSGPF, 0,
      "Value of the %s keyword will be maximum value %s.",
       /* BS10076 INTERCEPT_SEND_DELAY, WAIT_QUEUE_VALUE);           */
                  INTERCEPT_SEND_DELAY, WAIT_QUEUE_TOTALC); /*BS10076*/
			}
		 }
	  }
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
		  "Interception Parameters Loaded by CD: %s=%d  %s=%d.",
		   INTERCEPT_SEND_DELAY, InterceptDelay, INTERCEPT_SEND_MAX, InterceptMax);
   }
 
   if ( (InterceptDelay EQ 0) OR (InterceptMax EQ 0) )
      goto cleanup;
 
   if (Read_RC EQ ESA_MBX_EMPTY)
   {
      InterceptCount= 0;
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MORE,
		  "Queue is empty, InterceptCount set to %d.", InterceptCount);
      goto cleanup;
   }
   if (InterceptCount LT InterceptMax)
   {
      InterceptCount++;
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MORE,
		  "InterceptCount=%d. Wait will be only after %d not empty records",
		  InterceptCount, InterceptMax);
      goto cleanup;
   }
 
   InterceptCount= 1;
   my_wait= InterceptDelay * 1000;
   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES,
            "...-> OS_CS_wait: wait=%d (%s=%d).",
              my_wait, "Q_GET_INTERVAL", Q_GET_INTERVAL);
   rc= OS_CS_wait ( my_wait );
   ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_DETAILES,
            "...<- OS_CS_wait: rc=%d (%s).",
            rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
cleanup:
 
   ESA_DIAG_exit  (ESA_COMP_ACSGPF, DIAG_COMMON, fn, ESA_OK);
   return;
 
}
 
 
static ESA_RC CS_shutdown_event (void)
{
  char   fn[]="CS_shutdown_event";
  ESA_RC rc= ESA_OK;
  ESA_EVENT_typ              events[2];
  ESA_EVENT_STATUS_typ       event_stat[2];
  void                     * event_data[2];
  ENVIRONMENT_rec_typ      * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGPFM, DIAG_COMMON+ 1, fn);
  CLEAR(events);
  CLEAR(event_stat);
  CLEAR(event_data);
 
  /*
    CHECK (and clear event) if DIAG LEVELS were modified.
  */
  events[0]= EVENT_AGENT_SHUTDOWN;
  events[1]= EVENT_DIAG_CHANGED;
 
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MORE,
       "... -> OS_EVENT_clear: EVENT_AGENT_SHUTDOWN + EVENT_DIAG_CHANGED hndl=%p.",
	   envir_ptr->event_handle);
  rc = OS_EVENT_clear ( 2, events ,event_stat ,event_data ,
                        envir_ptr->event_handle,&envir_ptr->msg_params);
  ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_MORE,
      "...<- OS_EVENT_clear: rc=%d (%s).",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
  if (rc EQ ESA_FATAL) /* fatal only !! */
     goto cleanup;
 
  if ( (rc EQ ESA_OK) AND (event_stat[0] EQ EVENT_ON) )
  {
      ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
          "!!!*****>... ShutDown request event accepted");
	  rc=ESA_TERM_CTSA;
      CTSAMSG_print (ERR_UL_POS_STRING,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest, fn, rc,
					"Accepted shutdown request.");
      goto cleanup;
  }
 
  /*
    LOAD the diag leves file in case that it was modified (ESA_OK =
    file has been modified, ESA_WARN file has not been modified)
  */
 
  if ( (rc EQ ESA_OK) AND (event_stat[1] EQ EVENT_ON) )
  {
     ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_BASIC,
                 "*****>... Diagnostic changes event accepted.");
     rc = ESA_DIAG_set_debug_levels_file (envir_ptr->file_diaglvl, envir_ptr->p_main_name);
     ESA_DIAG_printf (ESA_COMP_ACSGPFM, DIAG_OS,
                "DIAG set levels on file %s completed with code:%s",
                     envir_ptr->file_diaglvl,
                     ESA_rc2str(rc));
     if (rc NE ESA_OK)
        goto cleanup;
 
  } /* END - diag level should be reloaded */
 
  rc= ESA_OK;
 
cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGPFM, DIAG_COMMON+ 1, fn, rc);
  return (rc);
} /* END - CS_shutdown_event function */
 
 
ESA_RC CS_send_receive (RSS_MSG_HDR_rec_typ * srvc_msg_hdr)
{
  RSS_MSG_HDR_rec_typ * tmp_hdr, tmp_hdr_space;
  MSG_typ             * tmp_msg_ptr;
  ESA_RC                rc= ESA_OK;
  NUM_MSGS_typ          tmp_num_msgs= 0;
  NUM_MSGS_typ tmp_msg_len= sizeof(RSS_MSG_HDR_rec_typ) +
                            RSS_NUM_MSGS;
  char         tmp_msg_space[sizeof(RSS_MSG_HDR_rec_typ)+
                            RSS_NUM_MSGS        +
                            ENC_ADD_MAX_LEN     + 1];
  char                  fn[]="CS_send_receive";
  ENVIRONMENT_rec_typ * envir_ptr;
  static int            DwnMsg, SyncMsg, RcvMsg;
  int                   Receive;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  memcpy ((char *)&tmp_msg_space,
          (char *)srvc_msg_hdr,
          sizeof(RSS_MSG_HDR_rec_typ));
  tmp_msg_ptr= tmp_msg_space;
  tmp_hdr = (RSS_MSG_HDR_rec_typ *)tmp_msg_ptr;
 
  if (RcvMsg EQ 0)
  {
     char RcvStr[2];
 
     rc= rssprm_get_opt ((char *)ALL_RSS, SEND_LAST_TMP_MSG, 1,
		                 RcvStr, OPT_TRUE, OPT_TRUE);
     if ( (rc EQ ESA_OK) AND (RcvStr[0] EQ ESS_YES_SIGN) )
	 {
        SyncMsg= TRUE;
		DwnMsg=  TRUE;
        RcvMsg=  TRUE;
	 }
     else if (rc EQ ESA_OK)
	 {
        SyncMsg= FALSE;
		DwnMsg=  FALSE;
        RcvMsg=  TRUE;
	 }
	 else
	 {
        SyncMsg= FALSE;
		DwnMsg= TRUE;
        RcvMsg=  TRUE;
	 }
     ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
       "!!!*****>... After Get SEND_LAST_TMP_MSG: Sync=%d Dwn=%d Rcv=%d (rc=%d)",
		SyncMsg, DwnMsg, RcvMsg, (int)rc);
  }
  if ( (srvc_msg_hdr->mhsid EQ DWNLD_SERVICE) AND (DwnMsg EQ TRUE) )
      Receive= TRUE;
  else if ( (srvc_msg_hdr->mhsid NE DWNLD_SERVICE) AND (SyncMsg EQ TRUE) )
      Receive= TRUE;
  else
      Receive= FALSE;
 
  if (Receive EQ TRUE)
     tmp_hdr->mhltl = MH_MESSAGE_LAST_TMP;
  else
     tmp_hdr->mhltl = MH_MESSAGE_LAST_NOT;
  rc= CS_send_cd_msg (&tmp_msg_len ,
                      &tmp_num_msgs ,
                      tmp_msg_ptr);
  if (rc NE ESA_OK)
     goto cleanup;
 
  if (Receive EQ TRUE)
     rc= CS_get_next_msg (envir_ptr->msg_ptr, &tmp_hdr_space);
 
 cleanup:
 
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return(rc);
}
 
