/*
 * Version Information:
 * ====================
 * File name       : %name: acsinfo.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: leonid_s %
 * Created on      : %date_created: Tue Feb 24 13:35:19 2004 %
 * Current Version : %version: 3 %
 * Last Modified by: %derived_by: leonid_s %
 * Last Modified on: %date_modified: Tue Feb 24 13:35:19 2004 %
 */
 
/***********************************************
 * Mod.ID   Who      When         Description
 * =============================================
 * SAS2IBMA AvnerL   21-Dec-16    SAS/C to IBM C Conversion Project
 * IS10178  SeligT   25-Jul_19    Supporting LID Anywhere in UID
 * WS10078KM KailasP 29-May_20    Dont fail transaction if
 *                                add info exceeds limits.
 * WS10080  KailasP  09-Jul_21    Support MSGSIZE Greater than 32K
 * WS10082K KailasP  04-Jan_23    Addinfo new approach
 * WS10082M MauriC   24-Feb-23    Minor changes
 * WS10082N NuritY   20-Sep-23    Addinfo long value support.
 **********************************************/
#define ACSINFO_C
 
#include "globs.h"
 
 
#include ESA_CS_SINFO
#include ESA_CS_OS
#include ESA_RSSF
#include ESA_RSS
#include ENC_API
#include ESA_ESAADI  /* WS10078KM */
 
/*******************************************************************
* Procedure Name   : CS_addinfo2_add
* Description      : add values of structure to additional info
* Input            : struct_id - code of structure
*                  : struct_ptr - pointer to the structure
* Input/Output     : addinfo2 - pointer to additional info to add
*                  : err
* Return Value     :
* Scope            : global
*******************************************************************/
 
ESA_RC CS_addinfo2_add (short                  struct_id,
                        void                 * struct_ptr,
                        ADDINFO_rec_typ      * addinfo2)
{
  RSS_PARAMS_rec_typ   * rss_prm;
  OE_PARAMS_rec_typ    * oe_params;
  UG_PARAMS_rec_typ    * ug_params;
  RES_PARAMS_rec_typ   * res_params;
  ACE_rec_typ          * ace_params;
  USER_PARAMS_rec_typ  * user_params;
  U2UG_PARAMS_rec_typ  * u2ug_params;
  ESA_RC                 rc= ESA_OK, rc_prm= ESA_OK;
  char                   rssprm_value [RSSPRM_VALUE_LEN+ 1];
  char                   wrk_number [11];
  int                    ii;
  ENVIRONMENT_rec_typ  * envir_ptr;
  char                   fn[]="CS_addinfo2_add";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 13,
                   "%s: struct_id %d", fn, (int)struct_id);
 
  switch (struct_id) {
 
    case STRUC_ACE_REC:
      ace_params= (ACE_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_ACE_TYPE) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)ace_params->ace_type,
                           FLD_ACE_TYP,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_ACE_TYPE);
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_ACE_USER) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(ace_params->user_name);
         strcpy (addinfo2->pair[ii].value, ace_params->user_name);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_ACE_GROUP) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(ace_params->ug_name);
         strcpy (addinfo2->pair[ii].value, ace_params->ug_name);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_ACE_ATTRIBS) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)ace_params->ace_attrs,
                           FLD_ACE_ATTR,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_ACE_ATTRIBS);
 
      break;
 
    case STRUC_RSS_REC:
      rss_prm = (RSS_PARAMS_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_MIN_PASS_LEN) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         sprintf (wrk_number, "%d", (int)rss_prm->min_pass_len);
         addinfo2->pair[ii].vallen= strlen(wrk_number);
         strcpy (addinfo2->pair[ii].value, wrk_number);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_MAX_EXPIRE) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         sprintf (wrk_number, "%d", (int)rss_prm->max_expire);
         addinfo2->pair[ii].vallen= strlen(wrk_number);
         strcpy (addinfo2->pair[ii].value, wrk_number);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_MAX_LOGINS) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         sprintf (wrk_number, "%d", (int)rss_prm->max_logins);
         addinfo2->pair[ii].vallen= strlen(wrk_number);
         strcpy (addinfo2->pair[ii].value, wrk_number);
      }
 
      break;
 
    case STRUC_RES_REC:
      res_params= (RES_PARAMS_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_RES_ID) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(res_params->resource);
         strcpy (addinfo2->pair[ii].value, res_params->resource);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_RES_TYP) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(res_params->restype);
         strcpy (addinfo2->pair[ii].value, res_params->restype);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_RES_OE_PARENT) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(res_params->parent_oe);
         strcpy (addinfo2->pair[ii].value, res_params->parent_oe);
      }
 
      break;
 
    case STRUC_U2UG_REC:
      u2ug_params= (U2UG_PARAMS_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_ID) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(u2ug_params->user);
         strcpy (addinfo2->pair[ii].value, u2ug_params->user);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_GROUP_ID) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(u2ug_params->group);
         strcpy (addinfo2->pair[ii].value, u2ug_params->group);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_U2UG_MISC) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)u2ug_params->u2ug_admin_data,
                           FLD_U2UG_CONN,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_U2UG_MISC);
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_U2UG_ATTRS) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)u2ug_params->u2ug_attr_data,
                           FLD_U2UG_ATTR,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_U2UG_ATTRS);
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_U2UG_DEF_GROUP) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(u2ug_params->def_group);
         strcpy (addinfo2->pair[ii].value, u2ug_params->def_group);
      }
 
      break;
 
    case STRUC_OE_REC:
      oe_params= (OE_PARAMS_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_OE_ID) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(oe_params->oe);
         strcpy (addinfo2->pair[ii].value, oe_params->oe);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_OE_PARENT) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(oe_params->parent);
         strcpy (addinfo2->pair[ii].value, oe_params->parent);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_OE_ATTR) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)oe_params->attr,
                           FLD_OE_ATTR,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_OE_ATTR);
 
      break;
 
    case STRUC_USER_REC:
      user_params= (USER_PARAMS_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_ID) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(user_params->user);
         strcpy (addinfo2->pair[ii].value, user_params->user);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_OE_PARENT) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(user_params->parent_oe);
         strcpy (addinfo2->pair[ii].value, user_params->parent_oe);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_GROUP_DEF) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(user_params->def_group);
         strcpy (addinfo2->pair[ii].value, user_params->def_group);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_PASSWD) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         rc_prm= rssprm_get (
                 envir_ptr->interest[envir_ptr->rss_num].rss,
                 PASS_PASSWORD, 1, rssprm_value);
         if (
               (rc_prm EQ ESA_OK)
              AND
               (strcmp (rssprm_value, PASSWORD_FOR_PASS) EQ 0)
            )
         {
            addinfo2->pair[ii].vallen= strlen(user_params->passwd);
            strcpy (addinfo2->pair[ii].value, user_params->passwd);
         }
         if (rc_prm NE ESA_OK)
             ESA_DIAG_printf (ESA_COMP_ACSINFO, 11,
             "Fail rssprm_get for rss/param type %s/%s.",
             envir_ptr->interest[envir_ptr->rss_num].rss,
             PASS_PASSWORD);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_PASSWD_LIFE) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)user_params->passwd_life,
                           FLD_USER_PASSWD_LIFE,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_USER_PASSWD_LIFE);
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_REV_STATUS) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)user_params->rev_status,
                           FLD_USER_STAT,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_USER_REV_STATUS);
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_USER_ADMIN) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
         CS_enum_fld_to_info ((int)user_params->user_admin,
                           FLD_USER_ADMIN,
                           addinfo2->pair[ii].value,
                           &addinfo2->pair[ii].vallen,
                           C_USER_ADMIN);
      break;
 
    case STRUC_UG_REC:
 
      ug_params= (UG_PARAMS_rec_typ *)struct_ptr;
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_GROUP_ID) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(ug_params->group);
         strcpy (addinfo2->pair[ii].value, ug_params->group);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_GROUP_OE_PARENT) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(ug_params->parent_oe);
         strcpy (addinfo2->pair[ii].value, ug_params->parent_oe);
      }
 
      for (ii= 0; ii LT addinfo2->max_pairs; ii++)
         if (strcmp (addinfo2->pair[ii].keyword,
                     C_GROUP_PARENT) EQ 0)
            break;
      if (ii LT addinfo2->max_pairs)
      {
         addinfo2->pair[ii].vallen= strlen(ug_params->parent_group);
         strcpy (addinfo2->pair[ii].value, ug_params->parent_group);
      }
 
      break;
 
    default:
      CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_STRUCTURE, (int)struct_id);
      rc= ESA_ERR;
      break;
  }
 
  if (rc NE ESA_OK)
     CTSAMSG_print (ERR_CS_FUNCTION,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  if (rc EQ ESA_OK)
      rc= rc_prm;
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, rc);
  return (rc);
}
 
 
/****************************************************************
* Procedure Name   : CS_entity_info_add
* Description      : add data of structure to entity info
* Input            : struct_id - code of structure
*                  : struct_ptr - pointer to the structure
* Output           : entity_info - pointer to entity info to add
*                  : err
* Return Value     :
* Scope            : global
*******************************************************************/
 
ESA_RC CS_entity_info_add (short                  struct_id,
                           void                 * struct_ptr)
{
  char                   fn[]="CS_entity_info_add";
  ACE_POS_typ            ace_pl_opcode;
  ADMIN_PARAMS_rec_typ * admin_params;
  USER_PARAMS_rec_typ  * user_params;
  UG_PARAMS_rec_typ    * ug_params;
  OE_PARAMS_rec_typ    * oe_params;
  ACE_rec_typ          * ace_params;
  RES_PARAMS_rec_typ   * res_params;
  U2UG_PARAMS_rec_typ  * u2ug_params;
  RSS_PARAMS_rec_typ   * rss_prm;
  char                   wrk_number [11];
  char                   func_name [MAX_RSS_ADDINFO_KWD_LEN+ 1];
  char                   action_name [MAX_RSS_ADDINFO_KWD_LEN+ 1];
  char                   rc_name [MAX_RSS_ADDINFO_KWD_LEN+ 1];
  char                   rssprm_value [RSSPRM_VALUE_LEN+ 1];
  ADDINFO_rec_typ      * addinfo;
  ESA_RC               * rc_cnvrt, rc= ESA_OK, rc_prm= ESA_OK;
  int                    failed_on_default = FALSE;
  ENVIRONMENT_rec_typ  * envir_ptr;
 
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 13,
      "%s: struct_id %d pairs: max %d num %d",
      fn,
      (int)struct_id,
      (int)envir_ptr->entity_info->max_pairs,
      (int)envir_ptr->entity_info->num_pairs);
 
  switch (struct_id) {
    case STRUC_PRM_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 3)) {
        rc= ESA_ERR;
        break;
      }
      rss_prm = (RSS_PARAMS_rec_typ *)struct_ptr;
 
      sprintf (wrk_number, "%d", (int)rss_prm->min_pass_len);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
          strlen (C_MIN_PASS_LEN);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_MIN_PASS_LEN);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (wrk_number);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          wrk_number);
      envir_ptr->entity_info->num_pairs++;
 
      sprintf (wrk_number, "%d", (int)rss_prm->max_expire);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
          strlen (C_MAX_EXPIRE);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_MAX_EXPIRE);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (wrk_number);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          wrk_number);
      envir_ptr->entity_info->num_pairs++;
 
      sprintf (wrk_number, "%d", (int)rss_prm->max_logins);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
          strlen (C_MAX_LOGINS);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_MAX_LOGINS);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (wrk_number);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          wrk_number);
      envir_ptr->entity_info->num_pairs++;
 
      break;
 
    case STRUC_RES_ADDINFO:
      addinfo = (ADDINFO_rec_typ *)struct_ptr;
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 13,
          "%s: struct_id %d add pairs %d",
          fn, (int)struct_id, (int)addinfo->num_pairs);
 
      if (envir_ptr->entity_info->max_pairs LT
          envir_ptr->entity_info->num_pairs+ addinfo->num_pairs) {
        rc= ESA_ERR;
        break;
      }
 /* WS10082K - Start                                 *
  * Instead of CS_copy_addinfo_to_addinfo call       */
 /*   CS_copy_addinfo_to_addinfo (envir_ptr->entity_info , addinfo); */
      ADDINFO_copy(envir_ptr->entity_info , addinfo);
 /* WS10082K - End */
      break;
 
    case STRUC_ACT_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 1)) {
        rc= ESA_ERR;
        break;
      }
      strcpy(action_name,
             CS_act_nmbr_to_act_name ((short *) struct_ptr));
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACTION);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACTION);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (action_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          action_name);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_RC_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 1)) {
        rc= ESA_ERR;
        break;
      }
      rc_cnvrt =  struct_ptr;
      strcpy(rc_name,ESA_rc2str ((ESA_RC)*rc_cnvrt));
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACT_RC);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACT_RC);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (rc_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          rc_name);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_PRE_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 1)) {
        rc= ESA_ERR;
        break;
      }
      rc_cnvrt =  struct_ptr;
      strcpy(rc_name,ESA_rc2str ((ESA_RC)*rc_cnvrt));
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_PRE_RC);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_PRE_RC);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (rc_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          rc_name);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_FUNC_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 1)) {
        rc= ESA_ERR;
        break;
      }
      strcpy(func_name,
             CS_func_nmbr_to_func_name (*((short *) struct_ptr)));
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_FUNC_NAME);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_FUNC_NAME);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (func_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          func_name);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_RSS_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 2)) {
        rc= ESA_ERR;
        break;
      }
      admin_params= (ADMIN_PARAMS_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_RSS_NAME);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_RSS_NAME);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->rss_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->rss_name);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_RSS_TYPE);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_RSS_TYPE);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->rss_type);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->rss_type);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_ADMIN_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 5)) {
        ESA_DIAG_printf (ESA_COMP_ACSINFO, 13, "%s: failed ???.", fn);
        rc= ESA_ERR;
        break;
      }
      admin_params= (ADMIN_PARAMS_rec_typ *)struct_ptr;
 
/*----------------- If non native RSS */
     rc= rssprm_get_opt (envir_ptr->interest[envir_ptr->rss_num].rss,
		                 SEND_PWD_TO_SCRIPT, 1, rssprm_value,
						 OPT_TRUE, OPT_FALSE);
     if (
		  (rc EQ ESA_OK)
		 AND
		  (rssprm_value[0] EQ ESS_YES_SIGN)
	    ) {
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ADM_PASSWD);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ADM_PASSWD);
	
	   if ( (envir_ptr->p_main_name  EQ ESA_ACD_PROC) AND
		     (strlen(admin_params->admin_passwd) EQ 0 ) )
	   {
		   envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->def_admin_passwd);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->def_admin_passwd);
 
	   }
	   else
	   {
		   envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->admin_passwd);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->admin_passwd);
 
	   }
	   envir_ptr->entity_info->num_pairs++;
	 }
     rc= ESA_OK;
/*------------------------------------*/
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ADM_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ADM_ID);
	  if ( (envir_ptr->p_main_name  EQ ESA_ACD_PROC) AND
		     (strlen(admin_params->admin_uname) EQ 0 ) )
	   {
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->def_admin);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->def_admin);
	  }
	  else
	  {
		  envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->admin_uname);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->admin_uname);
 
 
	  }
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ADM_G);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ADM_G);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->admin_gname);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->admin_gname);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ADM_VER);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ADM_VER);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (admin_params->rss_version);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          admin_params->rss_version);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ADM_MOD);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ADM_MOD);
      CS_enum_fld_to_info (
          (int)admin_params->mode,
          FLD_ADM_MODE,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_ADM_MOD);
 
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_USER_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 7)) {
        rc= ESA_ERR;
        break;
      }
      user_params= (USER_PARAMS_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
            strlen (C_USER_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_ID);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
            strlen (user_params->user);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          user_params->user);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_USER_OE_PARENT);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_OE_PARENT);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (user_params->parent_oe);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          user_params->parent_oe);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_USER_GROUP_DEF);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_GROUP_DEF);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (user_params->def_group);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          user_params->def_group);
      envir_ptr->entity_info->num_pairs++;
 
      rc_prm= rssprm_get (envir_ptr->interest[envir_ptr->rss_num].rss,
                      PASS_PASSWORD, 1, rssprm_value);
      if (rc_prm NE ESA_OK)
          ESA_DIAG_printf (ESA_COMP_ACSINFO, 11,
           "Fail rssprm_get for rss/param type %s/%s.",
           envir_ptr->interest[envir_ptr->rss_num].rss, PASS_PASSWORD);
      if (
            (rc_prm EQ ESA_OK)
           AND
            (strcmp (rssprm_value, PASSWORD_FOR_PASS) EQ 0)
         ) {
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
            strlen (C_USER_PASSWD);
        strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_PASSWD);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
            strlen (user_params->passwd);
        strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
            user_params->passwd);
        envir_ptr->entity_info->num_pairs++;
      }
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_USER_PASSWD_LIFE);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_PASSWD_LIFE);
      CS_enum_fld_to_info ((int)user_params->passwd_life,
         FLD_USER_PASSWD_LIFE,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_USER_PASSWD_LIFE);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_USER_REV_STATUS);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_REV_STATUS);
      CS_enum_fld_to_info ((int)user_params->rev_status,
          FLD_USER_STAT,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_USER_REV_STATUS);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
          strlen (C_USER_ADMIN);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_ADMIN);
      CS_enum_fld_to_info ((int)user_params->user_admin,
          FLD_USER_ADMIN,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_USER_ADMIN);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_UG_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 3)) {
        rc= ESA_ERR;
        break;
      }
      ug_params= (UG_PARAMS_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_GROUP_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_GROUP_ID);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (ug_params->group);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          ug_params->group);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_GROUP_OE_PARENT);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,
          C_GROUP_OE_PARENT);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (ug_params->parent_oe);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          ug_params->parent_oe);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_GROUP_PARENT);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_GROUP_PARENT);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (ug_params->parent_group);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          ug_params->parent_group);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_OE_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 3)) {
        rc= ESA_ERR;
        break;
      }
      oe_params= (OE_PARAMS_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_OE_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_OE_ID);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (oe_params->oe);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          oe_params->oe);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_OE_PARENT);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_OE_PARENT);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (oe_params->parent);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          oe_params->parent);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
        strlen (C_OE_ATTR);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_OE_ATTR);
      CS_enum_fld_to_info ((int)oe_params->attr,
          FLD_OE_ATTR,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_OE_ATTR);
      envir_ptr->entity_info->num_pairs++;
 
      break;
 
    case STRUC_RES_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 3)) {
        rc= ESA_ERR;
        break;
      }
      res_params= (RES_PARAMS_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_RES_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_RES_ID);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (res_params->resource);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          res_params->resource);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_RES_TYP);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_RES_TYP);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (res_params->restype);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          res_params->restype);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_RES_OE_PARENT);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_RES_OE_PARENT);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (res_params->parent_oe);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          res_params->parent_oe);
      envir_ptr->entity_info->num_pairs++;
 
      break;
 
    case STRUC_U2UG_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 5)) {
        rc= ESA_ERR;
        break;
      }
      u2ug_params= (U2UG_PARAMS_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_USER_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_USER_ID);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (u2ug_params->user);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          u2ug_params->user);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_GROUP_ID);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_GROUP_ID);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (u2ug_params->group);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          u2ug_params->group);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
        strlen (C_U2UG_MISC);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_U2UG_MISC);
      CS_enum_fld_to_info ((int)u2ug_params->u2ug_admin_data,
          FLD_U2UG_CONN,
 envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
 &envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
 ,C_U2UG_MISC);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
        strlen (C_U2UG_ATTRS);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_U2UG_ATTRS);
      CS_enum_fld_to_info ((int)u2ug_params->u2ug_attr_data,
          FLD_U2UG_ATTR,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_U2UG_ATTRS);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_U2UG_DEF_GROUP);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_U2UG_DEF_GROUP);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (u2ug_params->def_group);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          u2ug_params->def_group);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_ACE_PLACE_TYP:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 1)) {
        rc= ESA_ERR;
        break;
      }
      memcpy ((char *)(&ace_pl_opcode),(char *)struct_ptr,
              sizeof (ACE_POS_typ));
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACE_PLACE);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACE_PLACE);
      CS_enum_fld_to_info ((int)ace_pl_opcode,
          FLD_ACE_PLACE,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_ACE_PLACE);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    case STRUC_ACE_REC:
      if (envir_ptr->entity_info->max_pairs LT
          (envir_ptr->entity_info->num_pairs+ 4)) {
        rc= ESA_ERR;
        break;
      }
      ace_params= (ACE_rec_typ *)struct_ptr;
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACE_TYPE);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACE_TYPE);
      CS_enum_fld_to_info ((int)ace_params->ace_type,
          FLD_ACE_TYP,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_ACE_TYPE);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACE_USER);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACE_USER);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (ace_params->user_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          ace_params->user_name);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACE_GROUP);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACE_GROUP);
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen=
              strlen (ace_params->ug_name);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
          ace_params->ug_name);
      envir_ptr->entity_info->num_pairs++;
 
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keylen=
              strlen (C_ACE_ATTRIBS);
      strcpy (
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].keyword
,C_ACE_ATTRIBS);
      CS_enum_fld_to_info ((int)ace_params->ace_attrs,
          FLD_ACE_ATTR,
envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].value,
&envir_ptr->entity_info->pair[envir_ptr->entity_info->num_pairs].vallen
,C_ACE_ATTRIBS);
      envir_ptr->entity_info->num_pairs++;
      break;
 
    default:
      CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_STRUCTURE, (int)struct_id);
      rc= ESA_ERR;
      failed_on_default = TRUE ;
      break;
  }
  if ((rc NE ESA_OK) AND (failed_on_default EQ FALSE))
    CTSAMSG_print (ERR_CS_ENTTY_INFO_OVFLW,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, (int)envir_ptr->entity_info->max_pairs);
  if (rc EQ ESA_OK)
      rc= rc_prm;
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, rc);
  return (rc);
}
 
/******************************************************************
* Procedure Name   : CS_init_entity_info
* Description      : initiate entity info structure
* Input/Output     : entity_info - pointer to entity info to initiate
* Output           : err
* Return Value     :
* Scope            : global
*******************************************************************/
 
void CS_entity_info_init (void)
{
  ENVIRONMENT_rec_typ * envir_ptr;
  char                   fn[]="CS_entity_info_init";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
/*WS10082K* memset (envir_ptr->entity_info, '\0',
          sizeof(ADDINFO_rec_typ)* envir_ptr->num_entity_kwds);*/
  envir_ptr->entity_info->max_pairs= envir_ptr->num_entity_kwds;
/*envir_ptr->entity_info->num_pairs= 0;       *WS10082K*/
  ADDINFO_empty(envir_ptr->entity_info);     /*WS10082K*/
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_RC_VOID);
}
 
/****************************************************
 * Procedure Name: CS_fill_key
 * Description   : fill key structure
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
void CS_fill_key (ADDINFO_rec_ptr   * addinfo,
                  RSSAPIKWD_rec_typ * msg_key,
                  KWD_typ             kwd_types,
                  NUM_MSGS_typ        act_num,
                  NUM_MSGS_typ        max_prs)
{
  unsigned short kk, jj, ll, mm;
  int            ii;
  char           fn[]="CS_fill_key";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 13,
     "CS_fill_key: act %u,prs %u,kwd_t(%d %d %d %d %d %d %d %d %d %d)",
      act_num, max_prs,  (int)kwd_types[0], (int)kwd_types[1],
      (int)kwd_types[2], (int)kwd_types[3], (int)kwd_types[4],
      (int)kwd_types[5], (int)kwd_types[6], (int)kwd_types[7],
      (int)kwd_types[8], (int)kwd_types[9]);
 
  for (jj=0 ; jj LT act_num ; jj++){
    ADDINFO_empty(addinfo[jj]);   /*WS10082K*/
    /* WS10082N addinfo[jj]->max_pairs = max_prs;                */
    /* WS10082N addinfo[jj]->num_pairs = 0;                      */
    for (ii= 0, kk= 0;
         ii LT msg_key->num_keywords AND kk LT max_prs;
         ii++) {
      for (ll= 0, mm= 0; ll LT KEYWORD_TYPES_NUM; ll++) {
        if (msg_key->kwd[ii].keyword_type EQ kwd_types[ll])
          mm=1;
      }
      if (mm NE 0) {
         addinfo[jj]->num_pairs++;
         /*  keyword Type */
         addinfo[jj]->pair[kk].add_typ=
             CS_addinfo_typ_to_enum((MSG_typ*)msg_key->kwd[ii].addtyp);
         /* keyword */
         addinfo[jj]->pair[kk].keylen=  msg_key->kwd[ii].keylen;
         memcpy ((char *)addinfo[jj]->pair[kk].keyword,
                 msg_key->kwd[ii].keyword,
                 (unsigned) msg_key->kwd[ii].keylen);
         addinfo[jj]->pair[kk].keyword[addinfo[jj]->pair[kk].keylen]=
             '\0';
         /* reset value */
         addinfo[jj]->pair[kk].vallen=0;
         addinfo[jj]->pair[kk].value[0]= '\0';
 
         ESA_DIAG_printf (ESA_COMP_ACSINFO, 15,
 /*WS10082K*/             "pair %d [%p-%p] , keylen %d, keyword %s",
 /*WS10082K*/             kk, &(addinfo[jj]->pair[kk]),
 /*WS10082K*/             addinfo[jj]->pair[kk].twin,
 /*WS10082K*/             (int)addinfo[jj]->pair[kk].keylen,
 /*WS10082K*/             addinfo[jj]->pair[kk].keyword);
 /*WS10082K*       "CS_fill_key: pair %d, keylen %d, keyword %s",
 /*WS10082K*               kk, (int)addinfo[jj]->pair[kk].keylen,
 /*WS10082K*               addinfo[jj]->pair[kk].keyword);
 /*WS10082K*              kk, (int)addinfo[jj]->pair[kk].keylen, */
         kk++;
	     }
    }
  }
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_RC_VOID);
}
 
/****************************************************
 * Procedure Name: CS_addinfo_fill
 * Description   : fill every addinfo
 *
 * Input         : info             - Pointer for fill addinfo from
 *               : max_prs          - Number of addinfo pointers
 *                 num_pairs        - number of pairs in every addinfo
 * Input/Output  : addinfo[max_prs] - Pointer to every addinfo
 * Return Value  :
 * Comments      : The caller should verify that:
 *                 The num_pairs in the input addinfo is not
 *                 higher than max_pair in the output addinfos.
 *                 The input addinfo contains only keywords.
 *                 The input addinfo does not contain values.
 *
 * Scope         :
 ****************************************************/
 
void CS_addinfo_fill (ADDINFO_rec_ptr   info,
                      ADDINFO_rec_ptr * addinfo,
                      NUM_MSGS_typ      max_addinfos,      /*WS10082*/
                      NUM_MSGS_typ      num_pairs)
/*WS10082*            NUM_MSGS_typ      max_prs,         */
{
  unsigned int    ii,jj;
  char     fn[]="CS_addinfo_fill";
  ONE_FIELD_rec_ptr  tpair;                                /*WS10082*/
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
/* WS10082* for (ii= 0; ii LT max_prs; ii++ ) {            */
  for (ii= 0; ii LT max_addinfos; ii++ ) {                 /*WS10082*/
    ADDINFO_clear(addinfo[ii]);                            /*WS10082A*/
    memcpy ((char *)addinfo[ii]->pair, (char *)info->pair, /*WS10082*/
             sizeof(ONE_FIELD_rec_typ) * info->num_pairs); /*WS10082*/
    /* WS10082N memcpy ((char *)addinfo[ii], (char *)info,
            sizeof(ADDINFO_rec_typ)* num_pairs);          */
    addinfo[ii]->num_pairs = info->num_pairs;              /*WS10082*/
    tpair = addinfo[ii]->pair;                             /*WS10082*/
    for(jj = 0; jj LT addinfo[ii]->num_pairs; jj++)        /*WS10082*/
      tpair[jj].twin = &(tpair[jj]);                       /*WS10082*/
  }
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_RC_VOID);
}
 
/****************************************************
 * Procedure Name: CS_get_addinfo
 * Description   : retrive addinfo from message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_get_addinfo (ADDINFO_rec_typ ** addinfo,
                          MSG_typ          * msg_ptr)
{
 
#define XLEN  (ADINF_NUM_PRS + ADINF_KEY_LEN + ADINF_VAL_LEN_N+ 1)
 
  char                  fn[]="CS_get_addinfo";
  NUM_MSGS_typ          num_msgs;
  unsigned short        ii;
  unsigned long         tmp_num;
  char                  str [XLEN];  /* AJK */
  ESA_RC                rc= ESA_OK;
  unsigned long int     max_nmb;
  /*WS10082K - start */
  char                  msg[200];
  char                  keyword_name [MAX_RSS_ADDINFO_KWD_LEN+1];
  MSG_typ               *add_typ_ptr, *key_ptr, *val_ptr;
  short                 keylen;
  int                   vallen;
  /* Even though this parameter come in picture while    *
   * creating add info we dont need this parameter to    *
   * trruncate add info parameter. Delete this overhead. */
  /*static int            TruncateAddInfo;     WS10082K */
  ENVIRONMENT_rec_typ * envir_ptr;
  /* WS10082M -start */
  ONE_FIELD_rec_ptr  pair=NULL, new_pair=NULL;
  int                size=0;
  /* WS10082K&M -end   */
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 13, fn);
 
  memset (str, '\0', sizeof(str));
  memcpy (str , (char *)msg_ptr, ADINF_NUM_PRS);
  rc= CS_check_nmb (str, msg_ptr, 0, C_NUM_KWDS);
  if (rc NE ESA_OK) {
    CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn , C_ADDINFO_PAIRS);
    goto cleanup;
  }
  msg_ptr = msg_ptr + ADINF_NUM_PRS;
  sscanf (str , "%x",&num_msgs);
 
  if (num_msgs GT (unsigned)((*addinfo)->max_pairs))
  {
     /* WS10082N - start */
     /* The call to realloc is replaced with calls to free and alloc
      * because we do not need to copy the current addinfo
      * to the new one. We just need allocate a larger one.
     rc= CSA_realloc ((char **)addinfo,
		                    STRUC_ADDINFO,
                      sizeof(ADDINFO_rec_typ),
                      num_msgs);                                   */
     CSA_free((char **)addinfo);
     rc= CSA_alloc ((char **)addinfo,
		                    STRUC_ADDINFO,
                      num_msgs,
                      1,
                      fn,
                      "Addinfo realloc");
     if (rc NE ESA_OK)
        goto cleanup;
 /*WS10082K
      memset((char *)(*addinfo),
		    NULL_CHAR ,
            sizeof(ADDINFO_rec_typ) * num_msgs);
     (*addinfo)->max_pairs= num_msgs;   */
  }
  else                                                    /* WS10082N */
    ADDINFO_empty((*addinfo));        /*WS10082K*/
 
/*(*addinfo)->num_pairs = num_msgs;  *WS10082K*/
  memset (str, '\0', sizeof(str));
 
  for (ii =0 ; ii LT num_msgs ; ii++) {
    /*  keyword Type */
    /*WS10082K */
  /*(*addinfo)->pair[ii].add_typ=CS_addinfo_typ_to_enum(msg_ptr);*/
    add_typ_ptr = msg_ptr;                             /*WS10082K*/
    msg_ptr = msg_ptr + ADINF_TYP_LEN;
    /*  Length of keyword */
    memset (str, '\0', sizeof(str));
    memcpy (str ,(char *)msg_ptr , ADINF_KEY_LEN);
    max_nmb= envir_ptr->rss_limits.max_addinfo_kwd_len ;
    rc= CS_check_nmb (str, msg_ptr, max_nmb,C_KWD_LEN);
    if (rc NE ESA_OK) {
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_ADDINFO_KWD);
      goto cleanup;
    }
 
    sscanf (str, "%lx",(unsigned *)&tmp_num);
    /*(*addinfo)->pair[ii].keylen=(short)tmp_num;  *WS10082K*/
    keylen=(short)tmp_num;                       /*WS10082K*/
    msg_ptr = msg_ptr + ADINF_KEY_LEN;
    /*  Keyword*/
    /* WS10082K - Start */
    /* memcpy ((char *)(*addinfo)->pair[ii].keyword,(char *)msg_ptr ,
            (size_t)(*addinfo)->pair[ii].keylen);
    msg_ptr = msg_ptr + (*addinfo)->pair[ii].keylen;      WS10082A */
    memcpy ((char *)keyword_name,(char *)msg_ptr , keylen);
    keyword_name[keylen]='\0';
    msg_ptr = msg_ptr + keylen;
    /*WS10082K End */
    /*  Length of data */
    memset (str, '\0', sizeof(str));
    memcpy (str ,(char *)msg_ptr, envir_ptr->addinfo_val_len);
    /***** WS10082A ***** irrelevant any more
    if (TruncateAddInfo EQ 0)
	   {
       char rssprm_value[2];
 
       rc= envir_ptr->msg_admin_param.cs_func.rssprm_get_opt_ptr (
		     ALL_RSS, TRUNCATE_ADD_INFO, 1, rssprm_value, OPT_TRUE,OPT_TRUE);
       if (rc EQ ESA_OK)
	      {
          if (rssprm_value[0] EQ ESS_NOT_SIGN)
             TruncateAddInfo= -1;
		  else
             TruncateAddInfo= TRUE;
	   }
	   else
          TruncateAddInfo= FALSE;
	   rc= ESA_OK;
	} ***** WS10082A end *****/
 /*WS10082K - If iiq version is less than 04 then its old IIQ  *
  *           and we will process only values up to 65K for    *
  *           addinfo attributes                               */
	/*if (TruncateAddInfo EQ TRUE)                  *WS10082K*/
	/*WS10082A if ( (TruncateAddInfo EQ TRUE) OR    *WS10082K*/
	if(envir_ptr->iiq_version LT 4)              /*WS10082K&A*/
       max_nmb= 65535;
	else
       max_nmb= envir_ptr->rss_limits.max_addinfo_val_len;
    rc= CS_check_nmb (str, msg_ptr, max_nmb,C_KWD_VAL_LEN);
    if (rc NE ESA_OK) {
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_ADDINFO_VAL);
      goto cleanup;
    }
   sscanf (str, "%lx",(unsigned *)&tmp_num);
	  if (tmp_num LE envir_ptr->rss_limits.max_addinfo_val_len)
       vallen = tmp_num;                             /*WS10082K*/
     /*(*addinfo)->pair[ii].vallen=(short)tmp_num;         *WS10082K*/
	  else
	   {
     /*WS10082K - Start *
      (*addinfo)->pair[ii].vallen=
                  (short)envir_ptr->rss_limits.max_addinfo_val_len;   */
       vallen =  envir_ptr->rss_limits.max_addinfo_val_len;
       /*WS10082K - End */
       CTSAMSG_print (MSG_KWD_VALUE_TRUNCATED,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     keyword_name,                        /*WS10082K*/
					 envir_ptr->rss_limits.max_addinfo_val_len);
	   }
    msg_ptr = msg_ptr + envir_ptr->addinfo_val_len;
    /***** WS10082K start *****
    /* We will use ADDINFO_insert_nonstr to insert keyword and value *
       in addinfo buffer, instead of the memcpy.                     */
    rc = ADDINFO_insert_nonstr(CS_addinfo_typ_to_enum(add_typ_ptr),
                               keyword_name,
                               msg_ptr,
                               vallen,
                               (*addinfo),
                               MAX_RSS_ADDINFO_KWD_LEN,
                               max_nmb,
                               UNIQUE,
                               'Y');
    if (rc NE ESA_OK) {
      sprintf(msg, "Insert <%s> keyword failed", keyword_name);
      CTSAMSG_print (ERR_INTERNAL2,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     "ACSINFO", fn , msg, rc, __LINE__);
      goto cleanup;
    }
    /*** WS10082A drop memcpy as we use ADDINFO_insert_monster instead
    /@  Data @/
    memcpy ((char *)(*addinfo)->pair[ii].value,
		          (char *) msg_ptr ,
            (size_t)(*addinfo)->pair[ii].vallen); */
    /*** WS10082A end ***/
    msg_ptr = msg_ptr + tmp_num;
  }
 
  cleanup:
    ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_RC_VOID);
    if (rc EQ ESA_OK)
      return (msg_ptr);
    else {
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
      return (MSG_typ *)NULL;
    }
} /* End of CS_get_addinfo */
 
/*WS10082K - Remove CS_addinfo_prt and use ADDINFO_dump instead*
/****************************************************
 * Procedure Name: CS_addinfo_prt
 * Description   : print additional information
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ***************************************************@/
 
void CS_addinfo_prt (ADDINFO_rec_typ * addinfo,
                     const char      * text)
{
  int  ii;
  char fn[]="CS_addinfo_prt";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) LT 13)
    goto cleanup;
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 13, text);
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 15,
                   "Number of pairs:%d  Max pairs:%d",
                   addinfo->num_pairs,
                   addinfo->max_pairs);
 
  for (ii =0 ; ii< addinfo->num_pairs ;ii++) {
    /*  Length of keyword @/
 
    ESA_DIAG_printf (ESA_COMP_ACSINFO, 16,
            "Index:%d Type:%s KeyLen:%d KeyVal:%s ValLen:%d Value:%s",
                     ii,
                     CS_addinfo_enum_to_prt(addinfo->pair[ii].add_typ),
                     addinfo->pair[ii].keylen,
                     addinfo->pair[ii].keyword,
                     addinfo->pair[ii].vallen,
                     addinfo->pair[ii].value);
 
  }
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_RC_VOID);
}
** WS10082K - End */
 
/****************************************************
 * Procedure Name: CS_set_addinfo
 * Description   : copy addinfo structure to message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 ****************************************************/
 
/*MSG_typ * CS_set_addinfo (short             func,  * WS10078KM */
ESA_RC    CS_set_addinfo (short             func, /* WS10078KM */
                          MSG_typ         * buffer ,
                          ADDINFO_rec_ptr   addinfo,
                          NUM_MSGS_typ    * addinfo_len)
{
  char                  fn[]="CS_set_addinfo";
  ESA_RC                rc=ESA_OK;                 /* WS10078KM */
  short                 ii;
  MSG_typ             * num_pairs_ptr;
  int                   num_pairs= 0;
  char                  tmp_num_pairs[4];
  char                  msg[200];                  /* WS10078KM */
  char                  isIncompVal[2];            /* WS10078KM */
  ONE_FIELD_rec_ptr     pair;                      /* WS10078KM */
  short                 isIncompleteFlag=FALSE;    /* WS10078KM */
  short                 isIncompleteAttrLen=0;     /* WS10078KM */
  int                   numOfIncompleteAttrs=0;    /* WS10078KM */
  short                 isIncompAttrAdded=FALSE;   /* WS10078KM */
  short                 isIncompletePair=FALSE;    /* WS10082N  */
  ENVIRONMENT_rec_typ * envir_ptr;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, 1,/*DIAG_COMMON,*/ fn);
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 1, /*3,*/
      "func %d msgSize %d (max %d) addinfo pairs=%d val_len=%d.",
      (int)func, (int)(*addinfo_len), (int)envir_ptr->max_msg_size,
      (int)addinfo->num_pairs, (int)envir_ptr->addinfo_val_len);
 
  num_pairs_ptr= buffer;
 
  sprintf(buffer, "%03X", addinfo->num_pairs);
  buffer += ADINF_NUM_PRS;
  * addinfo_len += ADINF_NUM_PRS;
  /* WS10078KM - Start */
  /* Check if isIncomplete is already set in addinfo and *
   * is set to 'Y'. We want to send the attribute only   *
   * if it is 'Y' else we dont want to sent the value    */
 
  pair = ADDINFO_search("isIncomplete", strlen ("isIncomplete"),
                         addinfo->pair,addinfo->num_pairs);
  if (pair NE NULL)
  {
     isIncompletePair = TRUE;                             /* WS10082N */
     /* If isIncomplete attribute is to be sent we want *
        to reserve the length till all the attributes   *
        are processed.                                  */
 
     isIncompleteAttrLen = ADINF_TYP_LEN+ ADINF_KEY_LEN+
                           strlen("isIncomplete")+
                           envir_ptr->addinfo_val_len+2;
 
     if( pair->value[0] EQ 'Y' )
     {
        /* We want to set isIncompleteFlag to value to TRUE      *
         * and delete it from add info to process at the end.    */
        isIncompleteFlag=TRUE;
        ESA_DIAG_printf(ESA_COMP_ACSINFO, 3,
                        "isIncomplete is set with 'Y'.");
     }
     rc = ADDINFO_delete(addinfo, "isIncomplete");
     ESA_DIAG_printf(ESA_COMP_ACSINFO, 66,
                     "Delete isIncomplete ended with rc=%d.", rc);
 
     if(rc NE ESA_OK)
     {
        sprintf(msg,
                "Delete <%s> keyword failed. rc=%d",
                "isIncomplete",rc);
        CTSAMSG_print(ERR_INTERNAL2,
                      envir_ptr->msg_admin_param.ctsamsg_handle,
                      NULL, envir_ptr->msg_admin_param.ctsamsg_dest,
                      "ACSINFO",fn, msg, rc,__LINE__);
        rc=ESA_WARN;
     }
  }
 
/*for (ii =0 ; ii LT addinfo->num_pairs ; ii++) { */
  for (ii =0 ; ii LE addinfo->num_pairs ; ii++) {
 
   if ( ii EQ addinfo->num_pairs )
   {
      /* All the attributes are processed. We want to check *
         if isIncomplete to be added in buffer or not.      */
      isIncompleteAttrLen = 0;
      if( (isIncompleteFlag EQ TRUE) OR (numOfIncompleteAttrs GT 0) )
      {
         isIncompVal[0]='Y';
         isIncompVal[1]='\0';
      }
      else
         isIncompVal[0]='\0';
 
      /* Add the attribute again only if it was there  *
         in the schema. Otherwise we dont want to send *
         the isIncomplete attribute.                   */
      /* WS10082N
      if( (pair NE NULL) AND (isIncompAttrAdded EQ FALSE) )  */
      if( (isIncompletePair EQ TRUE)    AND               /* WS10082N */
          (isIncompAttrAdded EQ FALSE) )                  /* WS10082N */
      {
         rc = ADDINFO_insert(TYPE_1A, "isIncomplete", isIncompVal,
                             addinfo, MAX_RSS_ADDINFO_KWD_LEN,
                             MAX_RSS_ADDINFO_VAL_LEN, UNIQUE);
 
         if(rc NE ESA_OK)
         {
            sprintf(msg,
                    "Insert <%s> keyword failed. rc=%d",
                    "isIncomplete",rc);
            CTSAMSG_print(ERR_INTERNAL2,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL, envir_ptr->msg_admin_param.ctsamsg_dest,
                         "ACSINFO",fn, msg, rc,__LINE__);
            rc=ESA_WARN;
         }
         else
            isIncompAttrAdded=TRUE;
      }
      else
         continue;
   }
 
    ESA_DIAG_printf (ESA_COMP_ACSINFO,66, /*WS10082K*/
        "KP Processing Pair %d AddInfoLen=%d Kwd=%s(%d) Value=%.100s(%d)",
        (int)ii, (int)(*addinfo_len),
        addinfo->pair[ii].keyword, (int)addinfo->pair[ii].keylen,
        addinfo->pair[ii].value, (int)addinfo->pair[ii].vallen);
 
    /* WS10078KM - Ends */
 
    if (envir_ptr->max_msg_size- ENC_ADD_MAX_LEN LT
        (*addinfo_len)+ ADINF_TYP_LEN+
        ADINF_KEY_LEN+ addinfo->pair[ii].keylen+
        envir_ptr->addinfo_val_len+                    /* WS10078KM */
        addinfo->pair[ii].vallen+ isIncompleteAttrLen+ /* WS10078KM */
        RSS_MSG_LEN + sizeof (RSS_MSG_HDR_rec_typ))    /* WS10078KM */
        /* WS10078KM - Keep buffer to add message header and *
         *             isIncomplte attribute itself          */
    {
     /* WS10078KM - We dont want to display error here but form *
                    the message and display error at the end    *
 
     * CTSAMSG_print (ERR_CS_MSG_SET_CHK,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_ADDINFO_PAIRS, envir_ptr->max_msg_size);
       buffer= NULL;
       goto cleanup; */
      ESA_DIAG_printf (ESA_COMP_ACSINFO,1,
          "attr(%s),mxmsg(%d),adilen(%d), keylen(%d),vallen(%d),pairvallen(%d),isincomp(%d)",
          addinfo->pair[ii].keyword,envir_ptr->max_msg_size, (int)(*addinfo_len),
          addinfo->pair[ii].keylen, envir_ptr->addinfo_val_len, addinfo->pair[ii].vallen,
          isIncompleteAttrLen);
 
         numOfIncompleteAttrs++;
       if(numOfIncompleteAttrs EQ 1)
       {
          sprintf(msg,"%s:<%s> %s:<%d>. %s <%d> %s <%d>",
                  "Failed to add keyword",
                  addinfo->pair[ii].keyword, "of len",
                  (int)addinfo->pair[ii].vallen,
                  "Total buffer",
                  (envir_ptr->max_msg_size- ENC_ADD_MAX_LEN),
                  "is less than used buffer",
                  ((*addinfo_len)+ ADINF_TYP_LEN+
                  ADINF_KEY_LEN+ addinfo->pair[ii].keylen+
                  envir_ptr->addinfo_val_len+
                  addinfo->pair[ii].vallen+ isIncompleteAttrLen+
                  sizeof (RSS_MSG_HDR_rec_typ)) );
       }
       continue;
     /* WS10078KM */
    }
    /* WS10078KM - Start */
    /*  Length of keyword */
    if ((unsigned short)addinfo->pair[ii].keylen GT
        envir_ptr->rss_limits.max_addinfo_kwd_len)
    {
       numOfIncompleteAttrs++;
       ESA_DIAG_printf (ESA_COMP_ACSINFO,1,
                        "keylen(%d) is greater than max_addinfo_kwd_len (%d)",
                        addinfo->pair[ii].keylen,  envir_ptr->rss_limits.max_addinfo_kwd_len);
       continue;
    }
 
    if ((unsigned short)addinfo->pair[ii].vallen GT
        envir_ptr->rss_limits.max_addinfo_val_len)
    {
       ESA_DIAG_printf (ESA_COMP_ACSINFO,1,
                        "vallen(%d) is greater than max_addinfo_val_len (%d)",
                        addinfo->pair[ii].vallen,  envir_ptr->rss_limits.max_addinfo_val_len);
       numOfIncompleteAttrs++;
       continue;
    }
 
    /* WS10078KM - Ends */
 
    ESA_DIAG_printf (ESA_COMP_ACSINFO, DIAG_DETAILES+ 2,
        "Pair %d AddInfoLen=%d Kwd=%s(%d) Value=%s(%d)",
        (int)ii, (int)(*addinfo_len),
        addinfo->pair[ii].keyword, (int)addinfo->pair[ii].keylen,
        addinfo->pair[ii].value, (int)addinfo->pair[ii].vallen);
 
    /*  keyword Type */
    memcpy((char *)buffer,
           CS_addinfo_enum_to_prt (addinfo->pair[ii].add_typ),
           ADINF_TYP_LEN);
    if (memcmp ((char *)buffer, M_ADDINFO_UD, ADINF_TYP_LEN) EQ 0)
       continue;
    buffer +=  ADINF_TYP_LEN;
    * addinfo_len += ADINF_TYP_LEN;
 
    /* WS10078KM - Moved check above *
    /*  Length of keyword *
    if ((unsigned short)addinfo->pair[ii].keylen GT
        envir_ptr->rss_limits.max_addinfo_kwd_len) {
      CTSAMSG_print (ERR_CS_INVALID_NUMBER,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, C_ADDINFO_KWD,
                   addinfo->pair[ii].keylen,
                     envir_ptr->rss_limits.max_addinfo_kwd_len);
      buffer= NULL;
      goto cleanup;
    }
    /* WS10078KM */
 
    sprintf(buffer ,"%02X",addinfo->pair[ii].keylen);
    buffer +=  ADINF_KEY_LEN;
    * addinfo_len += ADINF_KEY_LEN;
    /*  Keyword*/
    memcpy ((char *)buffer ,(char *) addinfo->pair[ii].keyword,
           (size_t)addinfo->pair[ii].keylen);
    buffer += addinfo->pair[ii].keylen;
    * addinfo_len += addinfo->pair[ii].keylen;
 
    /* WS10078KM - Moved check above *
    /*  Length of data *
    if ((unsigned short)addinfo->pair[ii].vallen GT
        envir_ptr->rss_limits.max_addinfo_val_len) {
      CTSAMSG_print (ERR_CS_INVALID_NUMBER,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, C_ADDINFO_VAL,
                   addinfo->pair[ii].vallen,
                     envir_ptr->rss_limits.max_addinfo_val_len);
     buffer= NULL;
     goto cleanup;
    }
    /* WS10078KM - Ends */
 
    ESA_DIAG_printf (ESA_COMP_ACSINFO, 66,
        "Step1 buffer=%.*s.", *addinfo_len, buffer);
 
    ESA_DIAG_printf (ESA_COMP_ACSINFO, 9,                   /*WS10080*/
                     "envir_ptr->addinfo_val_len %d",       /*WS10080*/
                     envir_ptr->addinfo_val_len);           /*WS10080*/
 
    if (envir_ptr->addinfo_val_len EQ ADINF_VAL_LEN_N)
       sprintf(buffer ,"%04X",addinfo->pair[ii].vallen);
    else
       sprintf(buffer ,"%.*X",envir_ptr->addinfo_val_len,   /*WS10080*/
                                 addinfo->pair[ii].vallen); /*WS10080*/
    /* sprintf(buffer ,"%03X",addinfo->pair[ii].vallen);     *WS10080*/
    buffer += envir_ptr->addinfo_val_len;
    * addinfo_len += envir_ptr->addinfo_val_len;
 
    ESA_DIAG_printf (ESA_COMP_ACSINFO, 66,
        "Step2 buffer=%.*s.", *addinfo_len, buffer);
 
    /*  Data */
 /*memcpy((char *)buffer , (char *)addinfo->pair[ii].value, WS10082K*/
   memcpy((char *)buffer ,                                /*WS10082K*/
             (char *)addinfo->pair[ii].twin->value,       /*WS10082K*/
           (size_t)addinfo->pair[ii].vallen);
    buffer += addinfo->pair[ii].vallen;
    * addinfo_len += addinfo->pair[ii].vallen;
    ESA_DIAG_printf (ESA_COMP_ACSINFO, 66,
        "Step3 buffer=%.*s.", *addinfo_len, buffer);
 
    /* increment  number of pairs  ---------------*/
    num_pairs++;
  } /* End For WS10078KM */
  /* WS10078KM - Start */
    ESA_DIAG_printf (ESA_COMP_ACSINFO, 6,
        "numOfIncompleteAttrs- %d", numOfIncompleteAttrs);
  if(numOfIncompleteAttrs EQ 1)
  {
     /* We failed to insert only one keyword */
     CTSAMSG_print (ERR_CS_MSG_SET_CHK,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, msg, envir_ptr->max_msg_size);
     rc = ESA_WARN;
  }
  else
  {
     if (numOfIncompleteAttrs GT 1)
     {
        /* We failed to insert more than one keyword */
        memset(msg,'\0',sizeof(msg));
        sprintf(msg,"%d",numOfIncompleteAttrs);
        CTSAMSG_print(ERR_CS_MSG_NUMATR_OVRFLW,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      msg,addinfo->num_pairs);
        rc = ESA_WARN;
     }
     else
     {
        if(isIncompleteFlag EQ TRUE)
        {
           CTSAMSG_print(ERR_CS_MSG_NUMATR_OVRFLW,
                         envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         "1 or more",addinfo->num_pairs);
           rc = ESA_WARN;
        }
     }
  }
  /* WS10078KM - Start */
 
  ESA_DIAG_printf (ESA_COMP_ACSINFO, DIAG_DETAILES+ 1,
        "*****> AddInfo Pairs=%d Addinfo Msg Length=%d.",
        (int)num_pairs, (int)(*addinfo_len));
 
  /* Reset number of pairs in the addinfo ---------------*/
  sprintf(tmp_num_pairs, "%03X", num_pairs);
  memcpy ((char *)num_pairs_ptr,(char *)tmp_num_pairs,3);
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 4,
        "pair out %d/%d msg_size %d.",
        (int)num_pairs, addinfo->num_pairs,  /* WS10078KM */
        (int)(*addinfo_len));                /* WS10078KM */
 
  cleanup:
  if (buffer EQ NULL)
      CTSAMSG_print (ERR_CS_MSG_SET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSINFO, DIAG_COMMON, fn, ESA_RC_VOID);
 
/*return (buffer);    WS10078KM */
  return (rc);     /* WS10078KM */
} /* End of CS_addinfo */
 
/* WS10082K - Start                                          *
 *            CS_copy_addinfo_to_addinfo is not used anymore */
/*
/@***************************************************
 * Procedure Name: CS_copy_addinfo_to_addinfo
 * Description   : copy addinfo to addinfo
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ***************************************************@/
 
ESA_RC CS_copy_addinfo_to_addinfo (ADDINFO_rec_typ * to_addinfo,
                                   ADDINFO_rec_typ * from_addinfo)
{
  short  ii;
  char fn[]="CS_copy_addinfo_to_addinfo";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSINFO, 13,
                   "CS_copy_addinfo_to_addinfo");
 
  for (ii =0 ; ii LT from_addinfo->num_pairs ; ii++) {
    /@  keyword Type @/
    to_addinfo->pair[to_addinfo->num_pairs].add_typ=
      from_addinfo->pair[ii].add_typ;
    /@  Length of keyword @/
    to_addinfo->pair[to_addinfo->num_pairs].keylen=
      from_addinfo->pair[ii].keylen;
    /@  Keyword@/
    strcpy (to_addinfo->pair[to_addinfo->num_pairs].keyword,
            from_addinfo->pair[ii].keyword);
    /@  Length of data @/
    to_addinfo->pair[to_addinfo->num_pairs].vallen=
      from_addinfo->pair[ii].vallen;
    /@  Data @/
    strcpy (to_addinfo->pair[to_addinfo->num_pairs].value,
            from_addinfo->pair[ii].value);
 
    to_addinfo->num_pairs++;
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_OK);
  return(ESA_OK);
 
} /@ End of CS_copy_addinfo_to_addinfo @/
WS10082K - End */
 
/****************************************************
 * Procedure Name: CS_addinfo_typ_to_enum
 * Description   : convert addinfo type to enum
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 ****************************************************/
 
ADDINFO_typ CS_addinfo_typ_to_enum (MSG_typ  * msg_ptr)
{
  char fn[]="CS_addinfo_typ_to_enum";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON+ 1, fn);
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON+ 1, fn, ESA_RC_VOID);
  if     (memcmp ((char *)msg_ptr , M_ADDINFO_1A , ADINF_TYP_LEN) EQ 0)
    return(TYPE_1A);
  else if(memcmp ((char *)msg_ptr , M_ADDINFO_1B , ADINF_TYP_LEN) EQ 0)
    return(TYPE_1B);
  else if(memcmp ((char *)msg_ptr , M_ADDINFO_2A , ADINF_TYP_LEN) EQ 0)
    return(TYPE_2A);
  else if(memcmp ((char *)msg_ptr , M_ADDINFO_2B , ADINF_TYP_LEN) EQ 0)
    return(TYPE_2B);
  else return(TYPE_AI_IGNORED);
}
 
/****************************************************
 * Procedure Name: CS_addinfo_enum_to_prt
 * Description   :
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
const char * CS_addinfo_enum_to_prt (ADDINFO_typ addinfo_typ)
{
   const char * return_ptr;
   char fn[]="CS_addinfo_enum_to_prt";
 
   ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON+ 1, fn);
 
   switch (addinfo_typ) {
 
     case TYPE_1A:
         return_ptr = M_ADDINFO_1A;
         break;
 
     case TYPE_1B:
         return_ptr = M_ADDINFO_1B;
         break;
 
     case TYPE_2A:
         return_ptr = M_ADDINFO_2A;
         break;
 
     case TYPE_2B:
         return_ptr = M_ADDINFO_2B;
         break;
 
     default:
         return_ptr = M_ADDINFO_UD;
         break;
   }
 
   ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON+ 1, fn, ESA_RC_VOID);
   return (return_ptr);
}
 
/****************************************************
 * Procedure Name: CS_enum_fld_to_info
 * Description   : move enum value and enum value length
 *                      to addinfo
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 ****************************************************/
 
void CS_enum_fld_to_info (int          enum_field,
                          int          enum_name,
                          char       * enum_value,
/*WS10082K*/              int        * enum_value_len,
                          const char * fld_name)
/*WS10082K*               short      * enum_value_len, */
{
  MSG_typ      * msg_ptr, msg_str[STRUCT_LEN+ 3];
  NUM_MSGS_typ   msg_len;
  char fn[]="CS_enum_fld_to_info";
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
  msg_ptr= msg_str;
  msg_len= 0;
  msg_ptr= CS_set_enum_fld (enum_field, enum_name,
                            msg_ptr, &msg_len , fld_name);
  if (msg_ptr NE NULL) {
    msg_len -= STRUCT_LEN;
    strcpy (enum_value, msg_ptr- msg_len);
    *enum_value_len= msg_len;
  }
  else
    *enum_value_len= 0;
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON, fn, ESA_RC_VOID);
}
 
/****************************************************
 * Procedure Name: CS_set_enum_fld
 * Description   : set enum field to message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_set_enum_fld   ( int            field,
                              int            fld_nam,
                              MSG_typ      * msg_ptr,
                              NUM_MSGS_typ * msg_len ,
                              const char   * fld_name)
{
  char                  fn[] = "CS_set_enum_fld";
  int                   length;
  ESA_RC                rc= ESA_OK;
  char                  enum_str[10];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSINFO, DIAG_COMMON, fn);
 
  length = 1;
 
  sprintf (enum_str , "%d" , field);
  if (envir_ptr->max_msg_size- ENC_ADD_MAX_LEN LT
      (*msg_len)+ length+ STRUCT_LEN) {
      CTSAMSG_print (ERR_CS_MSG_SET_CHK ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , fld_name , envir_ptr->max_msg_size);
 
      msg_ptr= NULL;
      goto cleanup;
  }
  sprintf(msg_ptr ,"%03X", length);
  msg_ptr +=STRUCT_LEN;
  * msg_len +=STRUCT_LEN;
 
  switch (fld_nam) {
    case FLD_DEF_UG_ACTION:
    if (field EQ OLD_DEF_UG_ACT_KEEP)
      strcpy(msg_ptr , M_OLD_DEF_UG_ACT_KEEP);
    else if (field EQ OLD_DEF_UG_ACT_DROP)
      strcpy(msg_ptr , M_OLD_DEF_UG_ACT_DROP);
    else if (field EQ OLD_DEF_UG_ACT_IGNORED)
      strcpy(msg_ptr , M_OLD_DEF_UG_ACT_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_ACE_PLACE:
    if (field EQ ACE_POS_FIRST)
        strcpy(msg_ptr ,M_ACE_LOC_FIRST);
    else if (field EQ ACE_POS_LAST)
        strcpy(msg_ptr ,M_ACE_LOC_LAST);
    else if (field EQ ACE_POS_BEFORE)
        strcpy(msg_ptr ,M_ACE_LOC_BEFORE);
    else if (field EQ ACE_POS_AFTER)
        strcpy(msg_ptr ,M_ACE_LOC_AFTER);
    else if (field EQ ACE_POS_IGNORED)
        strcpy(msg_ptr ,M_ACE_LOC_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_ADM_MODE:
    if (field EQ ADMIN_MODE_NORMAL)
        strcpy(msg_ptr ,M_NORMAL_MODE);
    else if (field EQ ADMIN_MODE_SIMULATION)
        strcpy(msg_ptr ,M_SIMULATION_MODE);
    else if (field EQ ADMIN_MODE_IGNORED)
        strcpy(msg_ptr ,M_ADMIN_MODE_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_USER_PASSWD_LIFE:
    if (field EQ PASS_LIFE_PERMANENT)
        strcpy(msg_ptr ,M_PASS_LIFE_PERMANENT);
    else if (field EQ PASS_LIFE_RESET)
        strcpy(msg_ptr ,M_PASS_LIFE_RESET);
    else if (field EQ PASS_LIFE_IGNORED)
        strcpy(msg_ptr ,M_PASS_LIFE_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_USER_STAT:
    if (field EQ USER_STAT_REVOKED)
      strcpy(msg_ptr , M_REVOKE);
    else if (field EQ USER_STAT_ACTIVE)
      strcpy(msg_ptr , M_RESTORE);
    else if (field EQ USER_STAT_IGNORED)
      strcpy(msg_ptr , M_OP_IS_IGNOR);
    else rc= ESA_ERR;
    break;
 
    case FLD_USER_ADMIN:
    if (field EQ USER_ADM_ADMIN)
      strcpy(msg_ptr , M_USER_IS_ADMIN);
    else if (field EQ USER_ADM_NONE)
      strcpy(msg_ptr , M_USER_IS_USER);
    else if (field EQ USER_ADM_AUDIT)
      strcpy(msg_ptr , M_USER_IS_AUDITOR);
    else if (field EQ USER_ADM_ALL)
      strcpy(msg_ptr , M_USER_IS_BOTH);
    else if (field EQ USER_ADM_IGNORED)
      strcpy(msg_ptr , M_USER_IS_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_ACE_TYP:
    if (field EQ ACE_TYPE_USER)
    {
      strcpy(msg_ptr , M_ACE_IS_USER);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to USER (1).");   /* IS10178 */
    }
    else if (field EQ ACE_TYPE_GROUP)
    {
      strcpy(msg_ptr , M_ACE_IS_GROUP);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to GROUP (2).");  /* IS10178 */
    }
    else if (field EQ ACE_TYPE_USER_AND_GROUP)
    {
      strcpy(msg_ptr , M_ACE_IS_BOTH);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to BOTH (3).");   /* IS10178 */
    }
    else if (field EQ ACE_TYPE_UNDEFINED)
    {
      strcpy(msg_ptr , M_ACE_IS_UNDEFINED);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8,    /* IS10178 */
          "ACE_TYPE reset to UNDEFINED (7)."); /* IS10178 */
    }
    else if (field EQ ACE_TYPE_WORLD)
    {
      strcpy(msg_ptr , M_ACE_IS_OTHER);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to OTHER (6).");  /* IS10178 */
    }
    else if (field EQ ACE_TYPE_OE)
    {
      strcpy(msg_ptr , M_ACE_IS_OE);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to OE (4).");     /* IS10178 */
    }
    else if (field EQ ACE_TYPE_MASK)
    {
      strcpy(msg_ptr , M_ACE_IS_MASK);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to MASK (5).");   /* IS10178 */
    }
    else if (field EQ ACE_TYPE_IGNORED)
    {
      strcpy(msg_ptr , M_ACE_IS_IGNORE);
      ESA_DIAG_printf (ESA_COMP_ACSINFO, 8, /* IS10178 */
          "ACE_TYPE reset to IGNORE (8)."); /* IS10178 */
    }
    else rc= ESA_ERR;
    break;
 
    case FLD_U2UG_CONN:
 
    if      (field EQ U2UG_ADM_NONE)
      strcpy(msg_ptr , M_U2UG_CONN_NONE);
    else if (field EQ U2UG_ADM_ADMIN)
      strcpy(msg_ptr , M_U2UG_CONN_IS_ADMIN);
    else if (field EQ U2UG_ADM_AUDIT)
      strcpy(msg_ptr , M_U2UG_CONN_IS_AUDIT);
    else if (field EQ U2UG_ADM_ALL)
      strcpy(msg_ptr , M_U2UG_CONN_IS_BOTH);
    else if (field EQ U2UG_ADM_IGNORED)
      strcpy(msg_ptr , M_U2UG_CONN_IGNORE);
    else rc= ESA_ERR;
    break;
 
    case FLD_U2UG_ATTR:
 
    if      (field EQ U2UG_ATTR_DEFAULT_GROUP)
         strcpy(msg_ptr , M_U2UG_ATTR_DEFAULT_GROUP);
    else if (field EQ  U2UG_ATTR_REGULAR)
         strcpy(msg_ptr , M_U2UG_ATTR_UNDEFINED);
    else if (field EQ  U2UG_ATTR_IGNORED)
         strcpy(msg_ptr , M_U2UG_ATTR_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_OE_ATTR:
 
    if      (field EQ OE_ATTR_IGNORED)
         strcpy(msg_ptr , M_OE_ATTR_IGNORED);
    else if (field EQ  OE_ATTR_ACL)
         strcpy(msg_ptr , M_OE_ATTR_ACL);
    else if (field EQ  OE_ATTR_NO_ACL)
         strcpy(msg_ptr , M_OE_ATTR_NO_ACL);
    else rc= ESA_ERR;
    break;
 
    case FLD_ACE_ATTR:
    if      (field EQ ACE_ATTR_PERMANENT)
      strcpy(msg_ptr , M_ACE_ATTR_IS_PERMANENT);
    else if (field EQ ACE_ATTR_REGULAR)
      strcpy(msg_ptr , M_ACE_ATTR_IS_REGULAR);
    else if (field EQ ACE_ATTR_IGNORED)
      strcpy(msg_ptr , M_ACE_ATTR_IGNORED);
    else rc= ESA_ERR;
    break;
 
    case FLD_SEVERITY:
    if      (field EQ LOGEVENT)
      strcpy(msg_ptr , M_LOGEVENT);
    else if (field EQ REGULARALERT)
      strcpy(msg_ptr , M_REGULARALERT);
    else if (field EQ URGENTALERT)
      strcpy(msg_ptr , M_URGENTALERT);
    else if (field EQ VERYURGENTALERT)
      strcpy(msg_ptr , M_VERYURGENTALERT);
    else rc= ESA_ERR;
    break;
 
    default:
    CTSAMSG_print (ERR_CS_NBR2STR,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, C_ENUM, fld_nam);
    msg_ptr= NULL;
    rc= ESA_ERR;
    break;
 
  }
  if (rc NE ESA_OK) {
    CTSAMSG_print (ERR_CS_INVAL_ENUM,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn , fld_name , enum_str);
 
    msg_ptr= NULL;
  }
 
  if (msg_ptr NE NULL) {
    msg_ptr +=length;
    * msg_len +=length;
  }
 
 cleanup:
 
  ESA_DIAG_exit (ESA_COMP_ACSINFO,DIAG_COMMON,fn,ESA_RC_VOID);
 
  return(msg_ptr);
}
