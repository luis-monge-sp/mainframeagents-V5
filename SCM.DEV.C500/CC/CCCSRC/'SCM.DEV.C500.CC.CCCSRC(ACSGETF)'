/*
 * Version Information:
 * ====================
 * File name       : %name: acsgetf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: ihoffma %
 * Created on      : %date_created: Mon Feb 09 11:06:50 2004 %
 * Current Version : %version: 2.1.1 %
 * Last Modified by: %derived_by: ihoffma %
 * Last Modified on: %date_modified: Mon Feb 09 11:06:51 2004 %
 */
 
/**************************************************************
 * Mod.ID  Who      When        Description
 * ============================================================
 * IMH001  Ian H.   09-Feb-04   BSAN101994 for FD5681: If rc = ok on
 *                               return from postscript the value of
 *                               obj_exist should be as returned
 *                               from the USA-API (-it should not
 *                               be changed by the common code).
 * 502839  AvnerL   25-Jun-2009  MF updates for 3.3.00
 * SAS2IBMA AvnerL  21-Dec-16    SAS/C to IBM C Conversion Project
 * AC001   ArunC    12-Apr-2017  CIQ#6-MF acct aggr with conns
 * WS10070 KailasP  23-Mar-2018  Set get_conn flag to 'P' to get
 *                               connection attributes with groups
 *WS10078KGKailasP  08-May-2020  support get Role and get Source
 * WS10079K KailasP 04-Jan-2021  Dont call pre/post scripts for Role
 *                               and Source
 * IS10184  NuritY  20-Aug-2021  Improve Scripts Performance
 * WS10082A AvnerL  20-Dec-2022  Addinfo new approach
 * WS10082K KailasP 24-Jan-2023  Addionfo changes for CSA_alloc
 * IS10188  NuritY  24-Nov-2024  Abend S0C4 when modules above the line
 ***************************************************************/
 
#include "globs.h"
 
#include ESA_MSG
#include ESA_CAREUSR
#include ESA_CS_DBPKG
#include ESA_CS_SINFO
#include ESA_CS_OS
#include ESA_RSSF
#include ESA_OS_OFLI
#include ESA_ADMIN
#include ESA_ESAADI
 
 
RESOURCE_typ GLres;
RESTYPE_typ  GLrestp;
USER_typ     GLuser, GLcuser, GLruser;
UG_typ       GLgroup, GLcgroup, GLrgroup;
OE_typ       GLoe;
 
/****************************************************
 * Procedure Name: CS_download_csa_definitions
 * Description   : gets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function handles all RSS "GET" ("F") services. The function
 * enters a loop that reads messages from mailbox hand handles them.
 * The loop is terminated when the services is terminated (either by
 * "End Service" message, by any other message with "Last" indication,
 * by service/process cancel CONTROL message or due to error in the
 * service handling). The first message to be read - should be sent
 * from the ESS in response to the "Confirmation" message (sent by the
 * calling function). Upon receiving a legal message - the function
 * activates a handler function - according to the requested details :
 * Users, Groups,Connection,Resource ACL ,Resources  & Rss parameters.
 *********************************************************************/
 
ESA_RC CS_download_csa_definitions (MSG_typ             * msg_ptr,
                                    RSS_MSG_HDR_rec_typ * msg_hdr_cd)
{
  char fn[]="CS_download_csa_definitions";
  ESA_RC                    rc;
  RSS_MSG_HDR_rec_typ       msg_hdr;
  RSS_MSG_HDR_rec_typ       msg_hdr_sav;
  TRAN_rec_typ              tran;
  CSFLAG                    current_srv;
  ENVIRONMENT_rec_typ      * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  CSA_print_alloc_tbl (ESA_COMP_ACSGETF, fn, FALSE);
  current_srv =CSON;
  rc = ESA_OK;
  /*
    SAVE message header.
  */
  memcpy ((char *)(&msg_hdr_sav),(char *)msg_hdr_cd,
          sizeof( RSS_MSG_HDR_rec_typ));
  /*
    PROCESS until service termination:
  */
  while (current_srv EQ CSON) {
 
    CLEAR(msg_ptr);
    /*
      READ next message from mailbox.
    */
    rc= CS_get_next_msg (msg_ptr , & msg_hdr);
 
    memcpy ((char *)(&msg_hdr_sav),(char *)(&msg_hdr),
            sizeof( RSS_MSG_HDR_rec_typ));
    memcpy (envir_ptr->siid, msg_hdr.mhsiid, sizeof (MH_siid));
    envir_ptr->siid[sizeof (MH_siid)]= '\0';
	ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
        "AlxChk siid: envir_ptr->siid=%s.",envir_ptr->siid);
    if (rc NE ESA_OK)
       goto cleanup;
 
    /*
      ACTIVATE the relevant function - according to request:
    */
    if (COND(MSG_USER_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get user transaction", MSG_USER_GET);
      /*
        GET user details
      */
      rc=CS_user_get  (msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       FUNC_GTUSERS);
      if (
  		    (rc EQ ESA_OK)
		   AND	
            (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                     "AlxChk ctsamsg: GLuser=%s siid=%s.",
					 GLuser, envir_ptr->siid);
 
         CTSAMSG_print (MSG_USR_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLuser,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
    else if (COND(MSG_OE_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get container transaction", MSG_OE_GET);
      /*
        GET group details
      */
      rc=CS_oe_get    (msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       FUNC_GETOES);
      if (
  		    (rc EQ ESA_OK)
		   AND	
 		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_OE_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLoe,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
    else if (COND(MSG_UG_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get group transaction", MSG_UG_GET);
      /*
        GET group details
      */
      rc=CS_ug_get    (msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       FUNC_GETUGS);
      if (
  		    (rc EQ ESA_OK)
		   AND	
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_GRP_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLgroup,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
  /* WS10078KG - Start */
 else if (COND(MSG_XROL_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get role transaction", MSG_XROL_GET);
      /*
        GET role details
      */
      rc=CS_ug_get(msg_ptr ,
                   &msg_hdr ,
                   msg_hdr_cd ,
                   FUNC_GETXROL);
      if (
  		    (rc EQ ESA_OK)
		   AND	
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_XROL_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLgroup,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
 else if (COND(MSG_XSGP_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get source transaction", MSG_XSGP_GET);
      /*
        GET source details
      */
      rc=CS_ug_get(msg_ptr ,
                   &msg_hdr ,
                   msg_hdr_cd ,
                   FUNC_GETXSGP);
      if (
  		    (rc EQ ESA_OK)
		   AND	
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_XSGP_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLgroup,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
  /* WS10078KG - End */
    else if (COND(MSG_UG2UC_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get user to group connection transaction", MSG_UG2UC_GET);
      /*
        GET user to group connection details
      */
      /*** WS10082A Not used with one phase aggregation ***/
    	 ESA_DIAG_printf (ESA_COMP_ACSGETF, 0,
        "Unexpected flow COND=MSG_UG2UC_GET"); /*** WS10082A ***
      rc=CS_ug2uc_get (msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       FUNC_GTUG2UC);
      if (
		    (rc EQ ESA_OK)
		   AND	
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
		     LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_U2UG_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLcuser, GLcgroup,
					   envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
   *** end of WS10082A ***/
	}
    else if ((COND(MSG_RES_GET)) OR (COND(MSG_FULRES_GET))) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get resource transaction", MSG_RES_GET);
      /*
        GET resource details
      */
      rc=CS_res_get   (msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       &tran ,
                       FUNC_GETRES);
 
      if (
		    (rc EQ ESA_OK)
           AND
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_RES_GET_RSLT,
           envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
           envir_ptr->msg_admin_param.ctsamsg_dest,
           GLres,
           (COND(MSG_FULRES_GET)) ? "with" : "without",
		   GLrestp,
           envir_ptr->msg_admin_param.rss_name,
           envir_ptr->msg_admin_param.admin_uname,
           envir_ptr->msg_admin_param.admin_gname,
           envir_ptr->siid);
	  }
	}
    else if (COND(MSG_RSACL_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get ACL transaction", MSG_RSACL_GET);
      /*
        GET resource ACL details
      */
      rc=CS_rsacl_get (NULL ,
                       NULL ,
                       msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       &tran ,
                       1 ,
                       FUNC_GTRSACL);
 
	  if (
		    (rc EQ ESA_OK)
           AND
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
		 )
	  {
         CTSAMSG_print (MSG_ACE_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       GLruser, GLrgroup,
                       GLres, GLrestp,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
    else if (COND(MSG_RSPRM_GET)) {
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Get RSS parameters transaction", MSG_OE_GET);
      /*
        GET RSS parameters details
      */
      rc=CS_rsprm_get (msg_ptr ,
                       &msg_hdr ,
                       msg_hdr_cd ,
                       FUNC_GTRSPRM);
 
	  if (
		    (rc EQ ESA_OK)
           AND
		    (envir_ptr->interest[envir_ptr->rss_num].LogGetMsg EQ
				LOG_ANY_MSG)
         )
	  {
         CTSAMSG_print (MSG_RSS_PRM_GET_RSLT,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
	  }
	}
    else if (COND(END_OF_SERVICE))
	{
    	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... %s - Accepted end of transaction from IIQ/IDN", END_OF_SERVICE);
      /*
        SET End of service indicator
      */
      current_srv = CSOFF;
	}
    /*
      PROCESS undefined service
    */
    else {
      rc = ESA_FATAL;
      CTSAMSG_print (ERR_CS_UNDEF_MSG_TYP ,
                     envir_ptr->msg_admin_param.ctsamsg_handle,
                     NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, &msg_hdr.mhmtyp);
      goto cleanup;
    }
    /*
      MARK end of service - if process termination was requested.
    */
    if (rc EQ ESA_TERM_CTSA)
      current_srv = CSOFF;
 
    else if (rc NE ESA_OK) {
      goto cleanup;
    }
 
    /*
      MARK end of service if LAST message indication is set.
    */
    else if (msg_hdr.mhltl EQ MH_MESSAGE_LAST)
      current_srv = CSOFF;
 
  }
 
  cleanup:
 
  CSA_print_alloc_tbl (ESA_COMP_ACSGETF, fn, FALSE);
 
  if (rc EQ ESA_CANCEL_SERVICE)
    CTSAMSG_print (ERR_CS_SERVICE_CANCEL,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
  if ((rc NE ESA_OK) AND
      (rc NE ESA_TERM_CTSA)AND
      (rc NE ESA_CANCEL_SERVICE))
    CTSAMSG_print (ERR_CS_SERVICE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, envir_ptr->msg_ptr);
 
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_download_csa_definitions */
 
/****************************************************
 * Procedure Name: CS_user_get
 * Description   : user gets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve user(s) details form RSS and to
 * send the results to the ESS. The function loops over all message's
 * requests (internal messages) - and process all the requests with
 * same mode (All, Wild_card,Many) in single interior loop - until it
 * receives a "NO MORE" users indicator from the API.
 * Although it is "GET" function - PreScript and PostrScripts may be
 * activated (to return more information about the users) - hovever -
 * the scripts are activated ONCE for each activatetion of the API get
 * function.
 * The returned message will contain, after the Application Header
 * (number of messages), for each user, an RSS header, return codes
 * structure and user structure. However, the return codes structure
 * is filled - only for the first user in each API call.
 *********************************************************************/
 
ESA_RC  CS_user_get (MSG_typ               *  msg_ptr ,
                     RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                     RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                     short                    func_name)
{
  char fn[]="CS_user_get";
  OE_typ                oe;
  USER_PARAMS_rec_typ   usr_prm_in[MAX_GET];
  USER_PARAMS_rec_typ   usr_prm_out[MAX_GET];
  OE_PARAMS_rec_typ     oe_prm_out[1];
  UG_PARAMS_rec_typ     ug_prm_out[1];
  U2UG_PARAMS_rec_typ   u2ug_prm_out[1];
  RES_PARAMS_rec_typ    res_prm_out[1];
  ACE_rec_typ           ace_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo[MAX_GET];
  OBJ_EXISTS_typ        obj_exists[MAX_GET];
  TRAN_rec_typ          trana[MAX_GET];
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs, how_many_msgs = 0;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  GET_USER_MODE         mode;
  short                 max_num;
  short                 actual_num;
  short                 in_num;
  HAVE_MORE_typ         have_more;
  void                * handle;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  char                  get_conn = 'N'; /* AC001 - CIQ#6 */
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* AC001 - CIQ#6 - Start */
  if (envir_ptr->iiq_version GT 0) {
    get_conn = 'Y';
    /* WS10070 - start */
     if (envir_ptr->iiq_version GE 2)
        get_conn = 'P';
    /* WS10070 - end */
  }
 
  ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
         "*****>... Get Connection=%c", get_conn);
  /* AC001 - CIQ#6 - End */
 
  CLEAR(oe);
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  for (ii= 0; ii LT MAX_GET; ii++)
  {
         obj_exists[ii] = OBJ_IGNORED;
  }
  ERROR_CLEAR(&err_pre);
  ERROR_CLEAR(&err_act);
  ERROR_CLEAR(&err_pst);
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo[0]  = NULL;
 
  handle = NULL;
 
  max_num       =0;
 
  /*
    SKIP the GENERAL MESSAGE HEADER.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the number of RSS messages (requests within message).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL)
  {
    rc = ESA_ERR;
    goto cleanup;
  }
  how_many_msgs = num_msgs;
  /*
    RETRIEVE the current function pre/actual/post scripts parameters.
    from RSSAPI parameters file.
  */
  rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,func_name,
                      &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    PREPARE the required action keywords (that relates to the required
    RSS).
  */
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                      FUNC_ADDUSER,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE memory segment for response.
  */
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    INITIALIZE the response buffer.
  */
  msg_cs = CS_reset_cs_msg(&cs_msg_len ,
                           &cs_num_msgs ,
                           msg_hdr ,
                           msg_hdr_cd,
                           msg_cs ,
                           msg_cs_ptr);
  /*
    PROCESS all message requests (internal messages):
  */
  while  (
		      (num_msgs GT 0)
             AND
			  (rc_act   NE ESA_FATAL)
             AND
			  (rc_pst   NE ESA_FATAL)
		   )
  {
 
    handle = NULL;
    have_more = HAVE_MORE;
    CLEAR(usr_prm_in);
    /*
      FREE previous allocated additional info buffer.
    */
    CSA_free ((char **)addinfo);
 
    if (num_msgs GT MAX_GET)
      in_num = MAX_GET;
    else
      in_num = num_msgs;
    /*
      FILL in all users from internal message requests. Quit when
      the get mode alters and return number of internal messages that
      were used.
    */
    msg_ptr = CS_fill_in_user (usr_prm_in ,
                               msg_ptr ,
                               &in_num ,
                               in_num,
                               trana,
                               &mode);
    if (msg_ptr EQ NULL)
    {
      rc = ESA_FATAL;
      goto cleanup;
    }
	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... Get for user=%s", usr_prm_in[0].user);
    /*
      CALCULATE the number of requests (internal messages) that were
      left for next loop entries.
    */
    num_msgs = num_msgs - in_num;
    /*
      SET maximum number of users to retrieve according to the get
      mode.
    */
    switch (mode)
    {
      case GET_ALL_USERS:
          max_num = MAX_GET;
          break;
      case GET_WILD_USERS:
          max_num = MAX_GET;
          break;
      case GET_MANY_USERS:
          max_num = in_num;
          break;
      default:
          CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_MODE, (int)mode);
          rc = ESA_FATAL;
          break;
    }
    /*
      ALLOCATE buffer for users' additional info - according to the
      maximum users to retrieve.
    */
    rc= CSA_alloc ((char **)addinfo,
                   STRUC_RES_ADDINFO,
/*WS10082K *       sizeof(ADDINFO_rec_typ) *     */
              (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                             apiprm.script_kwd_num),
                   max_num,
                   fn,
                   "addinfo");
    if (rc NE ESA_OK)
      goto cleanup;
    /*
      PROCESS as long as there are more users that matches the
      required creteria:
    */
 
    rc     = ESA_OK;
    ERROR_CLEAR(&err_pre);
 
      /*
        FILL in the addinfo buffer, the interesting user's keywords.
      */
    CS_fill_key (addinfo ,
                 interest_key,
                 kwd_types,
                 (unsigned) max_num ,
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
    CLEAR(usr_prm_out);
 
    while  (
		      (have_more EQ HAVE_MORE)
             AND
			  (rc_act    NE ESA_FATAL)
             AND
			  (rc_pst    NE ESA_FATAL)
		   )
    {
 
      have_more = NO_MORE ;
      rc_act = ESA_RC_UNDEFINED;
      rc_pst = ESA_RC_UNDEFINED;
      ERROR_CLEAR(&err_act);
      ERROR_CLEAR(&err_pst);
      actual_num = in_num;
 
/*
        PROCESS whwn Actual
		action is required and PreScript did NOT
        return FATAL or SKIP return code:
      */
      if (apiprm.act EQ CS_YES)
      {
 
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          GET (up to) maximum allowed users via API call
        */
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    -> Call to CTSGetUsers USA-API for user=%s.", usr_prm_in[0].user);
        CS_DIAG_USER_IN (ESA_COMP_ACSGETF, mode, oe, max_num,
			in_num, usr_prm_in, handle, addinfo);
        rc_act = envir_ptr->func_ptr.gtusers_ptr ( mode,
                                         oe,
                                         max_num,
                                         &actual_num,
                                         &have_more,
                                         &handle,
                                         in_num,
                                         usr_prm_in,
                                         usr_prm_out,
                                         addinfo,
                                         obj_exists,
                                         &envir_ptr->msg_admin_param,
                                         err_msg,
                                         get_conn); /* AC001 - CIQ#6 */
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetUsers USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc_act EQ ESA_OK)
		   CS_DIAG_USER_OUT (ESA_COMP_ACSGETF, oe, actual_num, have_more,
		    	usr_prm_out, obj_exists, handle, addinfo);
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "AlxChk gtusers: usr_prm_out[0].user=%s siid=%s.",
					 usr_prm_out[0].user, envir_ptr->siid);
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
 
        rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
 
      } /* END - Actual action is required */
      /*
        PROCESS when the PostScript is required:
      */
      if (apiprm.post EQ CS_YES)
      {
 
    	 ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
           "*****>... Start Post script for Get user.");
        ERROR_CLEAR(err_msg);
        /*
          ACTIVATE PostScript
        */
        rc_pst = CS_pre_post_users (SCRIPT_POST ,
                                    actual_num, usr_prm_out, addinfo,
                                    NULL,
                                    &apiprm, rc_act, ESA_RC_UNDEFINED,
									obj_exists);
		if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
        /* IS10184 */  envir_ptr->msg_admin_param.ctsamsg_dest,
        /* IS10184 */  fn, ESA_rc2str(rc_pst), usr_prm_out[0].user);
        /* IS10184     envir_ptr->msg_admin_param.ctsamsg_dest);  */
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
            /* IS10184 */  fn, ESA_rc2str(rc_pst), usr_prm_out[0].user);
            /* IS10184         ESA_rc2str(rc_pst));  */
        ERROR_COPY(&err_pst , err_msg);
        ERROR_CLEAR(err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
      } /* END - PosstScript is required */
 
      ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                       "API run results pre:%d act:%d post%d",
                       ESA_RC_UNDEFINED, rc_act, rc_pst);
      /*
        SET not last message indicator.
      */
      CS_set_not_last_msg(msg_cs_ptr);
      /*
        TRANSLATE the api function id to protocol function string id.
      */
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ADD all retrieved users to reply message buffer.
      */
      msg_cs = CS_add_cs_msg (&cs_msg_len,
                              &cs_num_msgs,
                              func_name,
                              msg_cs,
                              msg_cs_ptr,
                              actual_num,
                              in_num,
                              usr_prm_out,
                              oe_prm_out,
                              ug_prm_out,
                              u2ug_prm_out,
                              res_prm_out,
                              ace_prm_out,
                              rss_prm_out,
                              addinfo,
                              obj_exists,
                              trana,
                              msg_hdr,
                              msg_hdr_cd,
                              mode,
                              ESA_RC_UNDEFINED,
                              rc_act,
                              rc_pst,
                              &err_pre,
                              &err_act,
                              &err_pst,
                              &rc);
      if (rc NE ESA_OK)
        goto cleanup;
      ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
         "AlxChk CS_add_cs_msg: usr_prm_out[0].user=%s siid=%s.",
					 usr_prm_out[0].user, envir_ptr->siid);
	  strcpy (GLuser, usr_prm_out[0].user);
      ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                     "AlxChk: GLuser=%s siid=%s.",
					 GLuser, envir_ptr->siid);
 
      if (msg_cs EQ NULL)
      {
        rc=ESA_FATAL;
        goto cleanup;
      }
      /*
        FILL in the addinfo buffer, the interesting user's keywords.
      */
      if (have_more EQ HAVE_MORE)
      {
        CS_fill_key (addinfo ,
                 interest_key,
                 kwd_types,
                 (unsigned) max_num ,
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
        CLEAR(usr_prm_out);
      }
    } /* END - WHILE HAVE MORE users */
 
  } /* END - WHILE there are internal messages left to process */
 
 
  /*
        SET not last message indicator.
      OR
        SET Temporary Last message indicator.
  */
  if ((rc EQ ESA_OK)               AND
      (how_many_msgs EQ 1)         AND
      (obj_exists[0] EQ OBJ_EXIST) AND
      (envir_ptr->hot_path EQ HOT_PATH_FULL))
      CS_set_not_last_msg(msg_cs_ptr);
  else
      CS_set_tmp_last_msg(msg_cs_ptr);
 
  /*
    TRANSLATE the api function id to protocol function string id.
  */
  CS_api_to_capi_id (func_name , msg_cs_ptr);
  /*
    SEND that (last) users list message to ESS.
  */
  rc = CS_send_cd_msg (&cs_msg_len ,
                       &cs_num_msgs ,
                       msg_cs_ptr);
 
  if (rc NE ESA_OK)
    goto cleanup;
 
  cleanup:
  /*
    PROCESS when the service did not finish naturaly (handle was
    not cleared).
  */
  if (handle NE NULL) {
    /*
      CLEAR the handle.
    */
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    -> Call to CTSGetUsers USA-API with GET_FREE_HANDLE_USERS mode.");
    CS_DIAG_USER_IN (ESA_COMP_ACSGETF, mode, oe, 0, 0, usr_prm_in,
		             handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr ( GET_FREE_HANDLE_USERS,
                                     oe,
                                     max_num,
                                     &actual_num,
                                     &have_more,
                                     &handle,
                                     in_num,
                                     usr_prm_in,
                                     usr_prm_out,
                                     addinfo,
                                     obj_exists,
                                     &envir_ptr->msg_admin_param,
                                     err_msg,
                                     get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetUsers USA-API completed with rc=%d (%s).",
			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSGETF, oe, 0, have_more, usr_prm_out,
		              obj_exists, handle, addinfo);
  }
  /*
    FREE all alocated buffers.
  */
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&interest_key);
 
  if (((rc EQ ESA_OK) OR
       (rc EQ ESA_TERM_CTSA) OR
       (rc EQ ESA_CANCEL_SERVICE)) AND
      (how_many_msgs EQ 1)         AND
      (obj_exists[0] EQ OBJ_EXIST))
  {
 
     char             ug[1] = {'\0'};
        if (envir_ptr->hot_path EQ HOT_PATH_FULL)
           CS_send_ug2uc_msg (msg_hdr, &trana[0],
                              ug,(char *)usr_prm_in[0].user);
        envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_USER ,
                             envir_ptr->empty_oe ,
                             usr_prm_out[0].user,
                             envir_ptr->empty_ug,
                             (envir_ptr->hot_path EQ HOT_PATH_FULL) ?
                                    UPDCONN_YES
                                    :
                                    UPDCONN_NO,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
  }
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_user_get function */
 
/****************************************************
 * Procedure Name: CS_ug_get
 * Description   : ug gets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve group(s) details form RSS and to
 * send the results to the ESS. The function loops over all message's
 * requests (internal messages) - and process all the requests with
 * same mode (All or Many) in single interior loop - until it
 * receives a "NO MORE" users indicator from the API.
 * Although it is "GET" function - PreScript and PostrScripts may be
 * activated (to return more information about the groups) - but
 * the scripts are activated ONCE for each activation of the API get
 * function.
 * The returned message will contain, after the Application Header
 * (number of messages), for each group, an RSS header, return codes
 * structure and group structure. The return codes structure
 * is filled only for the first group in each API call.
 *********************************************************************/
 
ESA_RC  CS_ug_get (MSG_typ               *  msg_ptr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                   short                    func_name)
{
  char fn[]="CS_ug_get";
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm_out[1];
  UG_PARAMS_rec_typ     ug_prm_in [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm_out[MAX_GET];
  USER_PARAMS_rec_typ   usr_prm_out[1];
  U2UG_PARAMS_rec_typ   u2ug_prm_out[1];
  RES_PARAMS_rec_typ    res_prm_out[1];
  ACE_rec_typ           ace_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo[MAX_GET];
  OBJ_EXISTS_typ        obj_exists[MAX_GET];
  TRAN_rec_typ          trana[MAX_GET];
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs, how_many_msgs = 0;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  GET_GROUP_MODE        mode;
  short                 max_num;
  short                 actual_num;
  short                 in_num;
  HAVE_MORE_typ         have_more;
  void                * handle;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  int                   ii;
  int                   num_kwds= 0;  /* WS10078KG */
  short                 api;          /* WS10078KG */
  /* IS10188 char                  entity[16];   /@ WS10078KG @/ */
  char      entity[17] = "";          /* WS10078KG */      /* IS10188 */
 
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
  CLEAR(oe);
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
  for (ii= 0; ii LT MAX_GET; ii++)
  {
     obj_exists[ii] = OBJ_IGNORED;
  }
 
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo[0]  = NULL;
 
  handle = NULL;
 
  max_num       =0;
 
  /* WS10078KG - Start */
  if (func_name EQ FUNC_GETXROL)
  {
     num_kwds = envir_ptr->interest[envir_ptr->rss_num].num_xrol_kwds;
     api = FUNC_ADDXROL;
     strcpy(entity,"Roles keywords");
  }
  else
     if (func_name EQ FUNC_GETXSGP)
     {
       num_kwds = envir_ptr->interest[envir_ptr->rss_num].num_xsgp_kwds;
       api = FUNC_ADDXSGP;
       strcpy(entity,"Sources keywords");
     }
     else
     {
       num_kwds = envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds;
       api = FUNC_ADDUG;
       strcpy(entity,"Groups keywords");
     }
  /* WS10078KG - End */
 
  /*
    SKIP the GENERAL MESSAGE HEADER.
  */
   msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the number of RSS messages (requests within message).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL)
  {
    rc = ESA_ERR;
    goto cleanup;
  }
  how_many_msgs = num_msgs;
 
  /*
    RETRIEVE the current function pre/actual/post scripts parameters.
    from RSSAPI parameters file.
  */
  /* WS10078KG - Start */
  if ( (func_name EQ FUNC_GETXROL) OR (func_name EQ FUNC_GETXSGP) )
  {
    rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                        FUNC_GETUGS, &apiprm);
  }
  else  /* WS10078KG - End */
    rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,func_name,
                        &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    PREPARE the required action keywords (that relates to the required
    RSS).
  */
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
/* WS10078KG  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +*/
/* WS10078KG */  num_kwds)+
                    sizeof(RSSAPIKWD_rec_typ) ,
                 1,
                 fn,
/* WS10078KG */  entity);
/* WS10078KG     "Groups keywords"); */
   if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
/* WS10078KG          FUNC_ADDUG,*/
/* WS10078KG */       api,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE memory segment for response.
  */
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    INITIALIZE the response buffer.
  */
  msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_hdr ,
                         msg_hdr_cd,
                         msg_cs,
                         msg_cs_ptr);
  /*
    PROCESS all message requests (internal messages):
  */
  while  (
		      (num_msgs GT 0)
             AND
			  (rc_act   NE ESA_FATAL)
             AND
			  (rc_pst   NE ESA_FATAL)
		   )
  {
    handle = NULL;
    have_more = HAVE_MORE;
    CLEAR(ug_prm_in);
    /*
      FREE previous allocated additional info buffer.
    */
    CSA_free ((char **)addinfo);
 
    if (num_msgs GT MAX_GET)
      in_num = MAX_GET;
    else in_num = num_msgs;
    /*
      FILL in all groups from internal message requests. Quit when
      the get mode alters and return number of internal messages that
      were used.
    */
    msg_ptr = CS_fill_in_ug    (ug_prm_in,
                                msg_ptr,
                                &in_num,
                                in_num,
                                trana,
                                &mode);
 
    /* WS10078KG */
    strcpy(entity,"group");
    if( (mode EQ GET_MANY_GROUPS) )
    {
      if(func_name EQ FUNC_GETXROL)
      {
         mode = GET_MANY_ROLES;
         strcpy(entity,"role");
      }
      else
         if(func_name EQ FUNC_GETXSGP)
         {
            mode = GET_MANY_SOURCES;
            strcpy(entity,"source");
         }
    }
    /* WS10078KG */
 
    if (msg_ptr EQ NULL)
    {
      rc = ESA_FATAL;
      goto cleanup;
    }
	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
  "*****>... Get for %s=%s",entity, ug_prm_in[0].group); /* WS10078KG*/
 /*     "*****>... Get for group=%s", ug_prm_in[0].group);  WS10078KG*/
    /*
      CALCULATE the number of requests (internal messages) that were
      left for next loop entries.
    */
    num_msgs = num_msgs - in_num;
 
    if (msg_ptr EQ NULL)
    {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      SET maximum number of groups to retrieve according to the get
      mode.
    */
    switch (mode)
    {
      case GET_ALL_GROUPS:
          max_num = MAX_GET;
          break;
      case GET_MANY_GROUPS:
      case GET_MANY_ROLES:                           /* WS10078KG */
      case GET_MANY_SOURCES:                         /* WS10078KG */
          max_num = in_num;
          break;
      default:
          CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_MODE, (int)mode);
          rc = ESA_FATAL;
          break;
    }
    /*
      ALLOCATE buffer for group' additional info - according to the
      maximum groups to retrieve.
    */
    rc= CSA_alloc ((char **)addinfo,
                   STRUC_RES_ADDINFO,
/* WS10082K*       sizeof(ADDINFO_rec_typ) *    */
/* WS10078KG   (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+ */
/* WS10078KG */   (num_kwds +
                             apiprm.script_kwd_num),
                   max_num,
                   fn,
                   "addinfo");
    if (rc NE ESA_OK)
      goto cleanup;
    /*
      PROCESS as long as there are more groups that matches the
      required creteria:
    */
 
    rc     = ESA_OK;
    ERROR_CLEAR(&err_pre);
      /*
        FILL in the addinfo buffer, the interesting group's keywords.
      */
    CS_fill_key (addinfo ,
                   interest_key,
                   kwd_types,
                   (unsigned) max_num ,
/* WS10078KG  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+ */
/* WS10078KG */    num_kwds +
                         apiprm.script_kwd_num);
 
    CLEAR(ug_prm_out);
 
 
    while  (
		      (have_more EQ HAVE_MORE)
             AND
			  (rc_act    NE ESA_FATAL)
             AND
			  (rc_pst    NE ESA_FATAL)
		   )
    {
 
      have_more = NO_MORE ;
      rc_act = ESA_RC_UNDEFINED;
      rc_pst = ESA_RC_UNDEFINED;
      ERROR_CLEAR(&err_act);
      ERROR_CLEAR(&err_pst);
      actual_num = in_num;
 
      /*
        PROCESS whwn Actual action is required and PreScript did NOT
        return FATAL or SKIP return code:
      */
      if (apiprm.act EQ CS_YES)
      {
 
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          GET (up to) maximum allowed maximum groups via API call
        */
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
   /* WS10078KG - Start */
			                     "    -> Call to CTSGetUGs USA-API for %s=%s.",
			                      entity, ug_prm_in[0].group);
			/*"  -> Call to CTSGetUGs USA-API for group=%s.", ug_prm_in[0].group);*/
   /* WS10078KG - End */
 
        CS_DIAG_UG_IN (ESA_COMP_ACSGETF,mode, oe, max_num, in_num,
			ug_prm_in, handle, addinfo);
        rc_act = envir_ptr->func_ptr.getugs_ptr( mode,
                                       oe,
                                       max_num,
                                       &actual_num,
                                       &have_more,
                                       &handle,
                                       in_num,
                                       ug_prm_in,
                                       ug_prm_out,
                                       addinfo,
                                       obj_exists,
                                       &envir_ptr->msg_admin_param,
                                       err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetUGs USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc_act EQ ESA_OK)
		   CS_DIAG_UG_OUT (ESA_COMP_ACSGETF, oe, actual_num, have_more,
			   ug_prm_out, obj_exists, handle, addinfo);
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
 
        rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
      } /* END - Actual action is required */
      /*
        PROCESS when the PostScript is required:
      */
/*    if (apiprm.post EQ CS_YES)  WS10079K */
      if ( (apiprm.post EQ CS_YES)             /* WS10079K */
           AND (func_name NE FUNC_GETXROL)     /* WS10079K */
           AND (func_name NE FUNC_GETXSGP) )   /* WS10079K */
      {
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
/* WS10078KG */ "*****>... Start Post script for Get %s.", entity);
/* WS10078KG "*****>... Start Post script for Get user group."); */
        ERROR_CLEAR(err_msg);
        /*
          ACTIVATE PostScript
        */
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num,
                        ug_prm_out, addinfo, NULL,
                        &apiprm, rc_act, ESA_RC_UNDEFINED, obj_exists);
		
        if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
         /* IS10184 */ envir_ptr->msg_admin_param.ctsamsg_dest,
         /* IS10184 */ fn, ESA_rc2str(rc_pst), ug_prm_out[0].group);
         /* IS10184    envir_ptr->msg_admin_param.ctsamsg_dest);  */
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
            /* IS10184 */  fn, ESA_rc2str(rc_pst), ug_prm_out[0].group);
            /* IS10184     ESA_rc2str(rc_pst));  */
        ERROR_COPY(&err_pst , err_msg);
        ERROR_CLEAR(err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
      } /* END - PosstScript is required */
 
      ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                       "API run results pre:%d act:%d post%d",
                       ESA_RC_UNDEFINED,
                       rc_act,
                       rc_pst);
      /*
        SET not last message indicator.
      */
      CS_set_not_last_msg(msg_cs_ptr);
      /*
        TRANSLATE the api function id to protocol function string id.
      */
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ADD all retrieved groups to reply message buffer.
      */
      msg_cs = CS_add_cs_msg (&cs_msg_len,
                              &cs_num_msgs,
                              func_name,
                              msg_cs,
                              msg_cs_ptr,
                              actual_num,
                              in_num,
                              usr_prm_out,
                              oe_prm_out,
                              ug_prm_out,
                              u2ug_prm_out,
                              res_prm_out,
                              ace_prm_out,
                              rss_prm_out,
                              addinfo,
                              obj_exists,
                              trana,
                              msg_hdr,
                              msg_hdr_cd,
                              mode,
                              ESA_RC_UNDEFINED,
                              rc_act,
                              rc_pst,
                              &err_pre,
                              &err_act,
                              &err_pst,
                              &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
	/*strcpy (GLgroup, ug_prm_out[0].group);   WS10079K */
	  strcpy (GLgroup, ug_prm_in[0].group); /* WS10079K */
 
      if (msg_cs EQ NULL)
      {
        rc=ESA_FATAL;
        goto cleanup;
      }
 
      if (have_more EQ HAVE_MORE)
      {
         CS_fill_key (addinfo ,
                   interest_key,
                   kwd_types,
                   (unsigned) max_num ,
/* WS10078KG   envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+ */
/* WS10078KG */    num_kwds+
                       apiprm.script_kwd_num);
 
        CLEAR(ug_prm_out);
      }
    } /* END - WHILE HAVE MORE users */
 
  } /* END - WHILE there are internal messages left to process */
 
  if ((rc EQ ESA_OK)               AND
      (how_many_msgs EQ 1)         AND
      (obj_exists[0] EQ OBJ_EXIST) AND
      (envir_ptr->hot_path EQ HOT_PATH_FULL))
  {
      /*
        SET not last message indicator.
      */
      CS_set_not_last_msg(msg_cs_ptr);
  }
  else
      /*
        SET Temporary Last message indicator.
      */
      CS_set_tmp_last_msg(msg_cs_ptr);
 
  /*
    TRANSLATE the api function id to protocol function string id.
  */
  rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    SEND that (last) groups list message to ESS.
  */
  rc = CS_send_cd_msg (&cs_msg_len ,
                       &cs_num_msgs ,
                       msg_cs_ptr);
 
 
  if (rc  NE ESA_OK)
    goto cleanup;
 
 cleanup:
 /* WS10079K - Start: We want to call GET_FREE_HANDLE... *
  *            for Role and Source                       *
 /@ WS10078KG - Start @/
 if( (func_name NE FUNC_GETXROL) AND (func_name NE FUNC_GETXSGP) )
 {
 /@ WS10078KG - End @/
  * WS10079K - End */
  /*
    PROCESS when the service did not finish naturaly (handle was
    not cleared).
  */
  if (handle NE NULL) {
    /*
      CLEAR the handle.
    */
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    -> Call to CTSGetUGs USA-API with GET_FREE_HANDLE_GROUPS mode.");
    CS_DIAG_UG_IN (ESA_COMP_ACSGETF, mode, oe, 0, 0, ug_prm_in,
		                 handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr( GET_FREE_HANDLE_GROUPS,
                                   oe,
                                   max_num,
                                   &actual_num,
                                   &have_more,
                                   &handle,
                                   in_num,
                                   ug_prm_in,
                                   ug_prm_out,
                                   addinfo,
                                   obj_exists,
                                   &envir_ptr->msg_admin_param,
                                   err_msg);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetUGs USA-API completed with rc=%d (%s).",
			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_UG_OUT (ESA_COMP_ACSGETF, oe, 0, have_more, ug_prm_out,
		                  obj_exists, handle, addinfo);
  }
/* }/@ WS10078KG @/ WS10079K */
  /*
    FREE all alocated buffers.
  */
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&interest_key);
 
  if (((rc EQ ESA_OK) OR
       (rc EQ ESA_TERM_CTSA) OR
       (rc EQ ESA_CANCEL_SERVICE)) AND
      (how_many_msgs EQ 1)         AND
      (obj_exists[0] EQ OBJ_EXIST))
  {
 
     char             usr[1] = {'\0'};
        if (envir_ptr->hot_path EQ HOT_PATH_FULL)
           CS_send_ug2uc_msg (msg_hdr,
                              &trana[0],
                              (char *)ug_prm_in[0].group,
                              usr);
        envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_GROUP ,
                             envir_ptr->empty_oe ,
                             envir_ptr->empty_user ,
                             ug_prm_out[0].group,
                             (envir_ptr->hot_path EQ HOT_PATH_FULL) ?
                                    UPDCONN_YES
                                    :
                                    UPDCONN_NO,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
  }
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_ug_get function */
 
 
/****************************************************
 * Procedure Name: CS_oe_get
 * Description   : containers gets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve group(s) details form RSS and to
 * send the results to the ESS. The function loops over all message's
 * requests (internal messages) - and process all the requests with
 * same mode (All or Many) in single interior loop - until it
 * receives a "NO MORE" users indicator from the API.
 * Although it is "GET" function - PreScript and PostrScripts may be
 * activated (to return more information about the groups) - but
 * the scripts are activated ONCE for each activation of the API get
 * function.
 * The returned message will contain, after the Application Header
 * (number of messages), for each group, an RSS header, return codes
 * structure and group structure. The return codes structure
 * is filled only for the first group in each API call.
 *********************************************************************/
 
ESA_RC  CS_oe_get (MSG_typ               *  msg_ptr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                   short                    func_name)
{
  char fn[]="CS_oe_get";
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm_in [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm_out[MAX_GET];
  UG_PARAMS_rec_typ     ug_prm_out[MAX_GET];
  USER_PARAMS_rec_typ   usr_prm_out[1];
  U2UG_PARAMS_rec_typ   u2ug_prm_out[1];
  RES_PARAMS_rec_typ    res_prm_out[1];
  ACE_rec_typ           ace_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo[MAX_GET];
  OBJ_EXISTS_typ        obj_exists[MAX_GET];
  TRAN_rec_typ          trana[MAX_GET];
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs, how_many_msgs = 0;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  GET_OE_MODE           mode;
  short                 max_num;
  short                 actual_num;
  short                 in_num;
  HAVE_MORE_typ         have_more;
  void                * handle;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
  CLEAR(oe);
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
  for (ii= 0; ii LT MAX_GET; ii++)
  {
         obj_exists[ii] = OBJ_IGNORED;
  }
 
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo[0]  = NULL;
 
  handle = NULL;
 
  max_num       =0;
 
  /*
    SKIP the GENERAL MESSAGE HEADER.
  */
   msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the number of RSS messages (requests within message).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL)
  {
    rc = ESA_ERR;
    goto cleanup;
  }
  how_many_msgs = num_msgs;
  /*
    RETRIEVE the current function pre/actual/post scripts parameters.
    from RSSAPI parameters file.
  */
  rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,func_name,
                      &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    PREPARE the required action keywords (that relates to the required
    RSS).
  */
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                      FUNC_ADDOE,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE memory segment for response.
  */
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    INITIALIZE the response buffer.
  */
  msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_hdr ,
                         msg_hdr_cd,
                         msg_cs,
                         msg_cs_ptr);
  /*
    PROCESS all message requests (internal messages):
  */
  while  (
		      (num_msgs GT 0)
             AND
			  (rc_act   NE ESA_FATAL)
             AND
			  (rc_pst   NE ESA_FATAL)
		   )
  {
    handle = NULL;
    have_more = HAVE_MORE;
    CLEAR(oe_prm_in);
    /*
      FREE previous allocated additional info buffer.
    */
    CSA_free ((char **)addinfo);
 
    if (num_msgs GT MAX_GET)
      in_num = MAX_GET;
    else in_num = num_msgs;
    /*
      FILL in all groups from internal message requests. Quit when
      the get mode alters and return number of internal messages that
      were used.
    */
    msg_ptr = CS_fill_in_oe    (oe_prm_in,
                                msg_ptr,
                                &in_num,
                                in_num,
                                trana,
                                &mode);
 
    if (msg_ptr EQ NULL)
    {
      rc = ESA_FATAL;
      goto cleanup;
    }
	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... Get for container=%s", oe_prm_in[0].oe);
    /*
      CALCULATE the number of requests (internal messages) that were
      left for next loop entries.
    */
    num_msgs = num_msgs - in_num;
 
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      SET maximum number of groups to retrieve according to the get
      mode.
    */
    switch (mode)
    {
      case GET_ALL_OES:
          max_num = MAX_GET;
          break;
      case GET_MANY_OES:
          max_num = in_num;
          break;
      default:
          CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_MODE, (int)mode);
          rc = ESA_FATAL;
          break;
    }
    /*
      ALLOCATE buffer for group' additional info - according to the
      maximum groups to retrieve.
    */
    rc= CSA_alloc ((char **)addinfo,
                   STRUC_RES_ADDINFO,
/*WS10082K*        sizeof(ADDINFO_rec_typ) *    */
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                             apiprm.script_kwd_num),
                   max_num,
                   fn,
                   "addinfo");
    if (rc NE ESA_OK)
      goto cleanup;
    /*
      PROCESS as long as there are more groups that matches the
      required creteria:
    */
 
    rc     = ESA_OK;
    ERROR_CLEAR(&err_pre);
      /*
        FILL in the addinfo buffer, the interesting group's keywords.
      */
    CS_fill_key (addinfo ,
                 interest_key,
                 kwd_types,
                 (unsigned) max_num ,
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
    CLEAR(oe_prm_out);
 
    while  (
		      (have_more EQ HAVE_MORE)
             AND
			  (rc_act    NE ESA_FATAL)
             AND
			  (rc_pst    NE ESA_FATAL)
		   )
    {
 
      have_more = NO_MORE ;
      rc_act = ESA_RC_UNDEFINED;
      rc_pst = ESA_RC_UNDEFINED;
      ERROR_CLEAR(&err_act);
      ERROR_CLEAR(&err_pst);
      actual_num = in_num;
 
      /*
        PROCESS whwn Actual action is required and PreScript did NOT
        return FATAL or SKIP return code:
      */
      if (apiprm.act EQ CS_YES)
      {
 
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
           goto cleanup;
        /*
          GET (up to) maximum allowed maximum groups via API call
        */
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    -> Call to CTSGetOEs USA-API for container=%s.", oe_prm_in[0].oe);
        CS_DIAG_OE_IN (ESA_COMP_ACSGETF, mode, oe, max_num, in_num,
			oe_prm_in, handle, addinfo);
        rc_act = envir_ptr->func_ptr.getoes_ptr( mode,
                                          oe,
                                          max_num,
                                          &actual_num,
                                          &have_more,
                                          &handle,
                                          in_num,
                                          oe_prm_in,
                                          oe_prm_out,
                                          addinfo,
                                          obj_exists,
                                          &envir_ptr->msg_admin_param,
                                          err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetOEs USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc_act EQ ESA_OK)
		   CS_DIAG_OE_OUT (ESA_COMP_ACSGETF, oe, actual_num, have_more,
		    	oe_prm_out, obj_exists, handle, addinfo);
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
 
        rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
      } /* END - Actual action is required */
      /*
        PROCESS when the PostScript is required:
      */
      if (apiprm.post EQ CS_YES)
      {
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
           "*****>... Start Post script for Get container.");
        ERROR_CLEAR(err_msg);
        /*
          ACTIVATE PostScript
        */
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num,
                        oe_prm_out, addinfo, NULL,
                        &apiprm, rc_act, ESA_RC_UNDEFINED, obj_exists);
 
        if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
         /* IS10184 */ envir_ptr->msg_admin_param.ctsamsg_dest,
         /* IS10184 */ fn, ESA_rc2str(rc_pst), oe_prm_out[0].oe);
         /* IS10184    envir_ptr->msg_admin_param.ctsamsg_dest);  */
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
             /* IS10184 */ fn, ESA_rc2str(rc_pst), oe_prm_out[0].oe);
             /* IS10184    ESA_rc2str(rc_pst));   */
 
        ERROR_COPY(&err_pst , err_msg);
        ERROR_CLEAR(err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
      } /* END - PosstScript is required */
 
      ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                       "API run results pre:%d act:%d post%d",
                       ESA_RC_UNDEFINED,
                       rc_act,
                       rc_pst);
      /*
        SET not last message indicator.
      */
      CS_set_not_last_msg(msg_cs_ptr);
      /*
        TRANSLATE the api function id to protocol function string id.
      */
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ADD all retrieved groups to reply message buffer.
      */
      msg_cs = CS_add_cs_msg (&cs_msg_len,
                              &cs_num_msgs,
                              func_name,
                              msg_cs,
                              msg_cs_ptr,
                              actual_num,
                              in_num,
                              usr_prm_out,
                              oe_prm_out,
                              ug_prm_out,
                              u2ug_prm_out,
                              res_prm_out,
                              ace_prm_out,
                              rss_prm_out,
                              addinfo,
                              obj_exists,
                              trana,
                              msg_hdr,
                              msg_hdr_cd,
                              mode,
                              ESA_RC_UNDEFINED,
                              rc_act,
                              rc_pst,
                              &err_pre,
                              &err_act,
                              &err_pst,
                              &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
	  strcpy (GLoe, oe_prm_out[0].oe);
 
      if (msg_cs EQ NULL)
      {
        rc=ESA_FATAL;
        goto cleanup;
      }
 
      if (have_more EQ HAVE_MORE)
      {
         CS_fill_key (addinfo ,
                   interest_key,
                   kwd_types,
                   (unsigned) max_num ,
               envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
        CLEAR(oe_prm_out);
      }
    } /* END - WHILE HAVE MORE users */
 
  } /* END - WHILE there are internal messages left to process */
 
  if ((rc EQ ESA_OK)               AND
      (how_many_msgs EQ 1)         AND
      (obj_exists[0] EQ OBJ_EXIST) AND
      (envir_ptr->hot_path EQ HOT_PATH_FULL))
  {
      /*
        SET not last message indicator.
      */
      CS_set_not_last_msg(msg_cs_ptr);
  }
  else
      /*
        SET Temporary Last message indicator.
      */
      CS_set_tmp_last_msg(msg_cs_ptr);
 
  /*
    TRANSLATE the api function id to protocol function string id.
  */
  rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    SEND that (last) groups list message to ESS.
  */
  rc = CS_send_cd_msg (&cs_msg_len ,
                       &cs_num_msgs ,
                       msg_cs_ptr);
 
 
  if (rc  NE ESA_OK)
    goto cleanup;
 
 cleanup:
  /*
    PROCESS when the service did not finish naturaly (handle was
    not cleared).
  */
  if (handle NE NULL) {
    /*
      CLEAR the handle.
    */
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    -> Call to CTSGetOEs USA-API with GET_FREE_HANDLE_OES mode.");
    CS_DIAG_OE_IN (ESA_COMP_ACSGETF, mode, oe, 0, 0, oe_prm_in,
		                 handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr( GET_FREE_HANDLE_OES,
                                        oe,
                                        max_num,
                                        &actual_num,
                                        &have_more,
                                        &handle,
                                        in_num,
                                        oe_prm_in,
                                        oe_prm_out,
                                        addinfo,
                                        obj_exists,
                                        &envir_ptr->msg_admin_param,
                                        err_msg);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetOEs USA-API completed with rc=%d (%s).",
			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSGETF, oe, 0, have_more, oe_prm_out,
		                  obj_exists, handle, addinfo);
  }
  /*
    FREE all alocated buffers.
  */
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&interest_key);
 
  if (((rc EQ ESA_OK) OR
       (rc EQ ESA_TERM_CTSA) OR
       (rc EQ ESA_CANCEL_SERVICE)) AND
      (how_many_msgs EQ 1)         AND
      (obj_exists[0] EQ OBJ_EXIST))
  {
 
     envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_CONTAINER ,
                          oe_prm_out[0].oe,
                          envir_ptr->empty_user,
                          envir_ptr->empty_ug,
                          (envir_ptr->hot_path EQ HOT_PATH_FULL) ?
                                    UPDCONN_YES
                                    :
                                    UPDCONN_NO,
                          &envir_ptr->msg_admin_param,
                          &envir_ptr->msg_err);
 
  }
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_oe_get function */
/*** Drop CS_ug2uc_get routine which is not used with one phase
 *** aggregation, implemented 10 years ago.          ***WS10082A***
@****************************************************
 * Procedure Name: CS_ug2uc_get
 * Description   : user group to user connections function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve users to groups connection details
 * form RSS and to send the results to the ESS. The function loops over
 * all message's requests (internal messages) - and process all the
 * requests with same mode (All, Many groups, Many ugs,Many pairs ) in
 * single interior loop - until it receives a "NO MORE" connections
 * indicator from the API.
 * Although it is "GET" function - PreScript and PostrScripts may be
 * activated (to return more information about the connections) - the
 * scripts are activated ONCE for each activation of the API get
 * function.
 * The returned message will contain, after the Application Header
 * (number of messages), for each connection, an RSS header, return
 * codes structure and connection structure. However, the return codes
 * structure is filled only for the first connection in each API call.
 *********************************************************************@
 
ESA_RC  CS_ug2uc_get (MSG_typ               *  msg_ptr ,
                      RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                      RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                      short                    func_name)
{
  char fn[]="CS_ug2uc_get";
  USER_typ              usr_in[MAX_GET];
  OE_typ                oe;
  UG_typ                ug_in[MAX_GET];
  USER_PARAMS_rec_typ   usr_prm_out  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm_out[1];
  UG_PARAMS_rec_typ     ug_prm_out   [MAX_GET];
  U2UG_PARAMS_rec_typ   u2ug_prm_out [MAX_GET];
  RES_PARAMS_rec_typ    res_prm_out[1];
  ACE_rec_typ           ace_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo      [MAX_GET];
  OBJ_EXISTS_typ        obj_exists   [MAX_GET];
  TRAN_rec_typ          trana        [MAX_GET];
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  GET_CONN_MODE         mode;
  short                 max_num;
  short                 actual_num;
  short                 in_num_user;
  short                 in_num_ug= 0;
  HAVE_MORE_typ         have_more;
  void                * handle;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  int                   ii;
  int                   num_of_sended_conn;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
  CLEAR(oe);
 
  for (ii= 0; ii LT MAX_GET; ii++)
  {
         obj_exists[ii] = OBJ_IGNORED;
  }
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo[0]  = NULL;
 
  handle = NULL;
 
  max_num       =0;
 
  @*
    SKIP the GENERAL MESSAGE HEADER.
  *@
 
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  @*
    GET the number of RSS messages (requests within message).
  *@
 
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL)
  {
    rc = ESA_ERR;
    goto cleanup;
  }
  @*
    RETRIEVE the current function pre/actual/post scripts parameters.
    from RSSAPI parameters file.
  *@
  rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                      FUNC_GTUG2UC,
                      &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
  @*
    PREPARE the required action keywords (that relates to the required
    RSS).
  *@
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                      FUNC_ADDU2UG,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
  @*
    ALLOCATE memory segment for response.
  *@
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  @*
    INITIALIZE the response buffer.
  *@
  msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_hdr ,
                         msg_hdr_cd ,
                         msg_cs ,
                         msg_cs_ptr);
  @*
    PROCESS all message requests (internal messages):
  *@
 
  num_of_sended_conn = 0;
 
  while  (
		      (num_msgs GT 0)
             AND
			  (rc_act   NE ESA_FATAL)
             AND
			  (rc_pst   NE ESA_FATAL)
		   )
  {
    handle = NULL;
    have_more = HAVE_MORE;
 
    CLEAR(ug_in);
    CLEAR(usr_in);
    @*
      FREE previous allocated additional info buffer.
    *@
    CSA_free ((char **)addinfo);
 
    if (num_msgs GT MAX_GET)
      in_num_user = MAX_GET;
    else in_num_user = num_msgs;
    @*
      FILL in all groups-users from internal message requests. Quit
      when the get mode alters and return number of internal messages
      that were used.
    *@
    msg_ptr = CS_fill_in_u2ug (ug_in,
                               usr_in,
                               msg_ptr,
                               &in_num_user,
                               in_num_user,
                               trana,
                               &mode);
 
    if (msg_ptr EQ NULL) {
      rc = ESA_FATAL;
      goto cleanup;
    }
	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... Get for user=%s to group%s connection",
        usr_in[0], ug_in[0]);
 
    @*
      CALCULATE the number of requests (internal messages) that were
      left for next loop entries.
    *@
    num_msgs = num_msgs - in_num_user;
 
    in_num_ug = in_num_user;
 
    @*
      SET maximum number of connections to retrieve according to the
      get mode.
    *@
    switch (mode)
    {
      case GET_ALL_CONNS:
          max_num = MAX_GET;
          break;
      case GET_GROUPS_CONNS:
          max_num = MAX_GET;
          break;
      case GET_USERS_CONNS:
          max_num = MAX_GET;
          break;
      case GET_MANY_CONNS:
          max_num = in_num_user;
          break;
      default:
          CTSAMSG_print (ERR_CS_NBR2STR,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, C_MODE, (int)mode);
          rc = ESA_FATAL;
          break;
    }
 
    @*
      ALLOCATE buffer for connections  additional info - according to
      the maximum connections to retrieve.
    *@
 
    rc= CSA_alloc ((char **)addinfo,
                   STRUC_RES_ADDINFO,
 @* WS10082K*      sizeof(ADDINFO_rec_typ)*        *@
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                             apiprm.script_kwd_num),
                   max_num,
                   fn,
                   "addinfo");
    if (rc NE ESA_OK)
      goto cleanup;
 
    @*
      PROCESS as long as there are more connections that matches the
      required creteria:
    *@
 
 
    rc     = ESA_OK;
    ERROR_CLEAR(&err_pre);
      @*
        FILL in the addinfo buffer, the interesting connection's
        keywords.
      *@
    CS_fill_key (addinfo ,
                   interest_key,
                   kwd_types,
                   (unsigned) max_num ,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
    CLEAR(ug_prm_out);
    CLEAR(usr_prm_out);
    CLEAR(u2ug_prm_out);
 
    while  (
		      (have_more EQ HAVE_MORE)
             AND
			  (rc_act    NE ESA_FATAL)
             AND
			  (rc_pst    NE ESA_FATAL)
		   )
    {
 
      have_more = NO_MORE ;
      rc_act = ESA_OK;
      rc_pst = ESA_OK;
 
      ERROR_CLEAR(&err_act);
      ERROR_CLEAR(&err_pst);
 
      actual_num = in_num_user;
 
      @*
        PROCESS whwn Actual action is required and PreScript did NOT
        return FATAL or SKIP return code:
      *@
      if (apiprm.act EQ CS_YES)
      {
 
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
        @*
          GET (up to) maximum allowed maximum connections via API call
        *@
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    -> Call to CTSGetConns USA-API for user=%s to group=%s connection.",
			usr_in[0], ug_in[0]);
        CS_DIAG_UG2UC_IN (ESA_COMP_ACSGETF, mode, max_num, in_num_ug,
			in_num_user, ug_in, usr_in, handle, addinfo);
        rc_act = envir_ptr->func_ptr.gtug2uc_ptr ( mode,
                                         max_num,
                                         &actual_num,
                                         &have_more,
                                         &handle,
                                         in_num_ug,
                                         in_num_user,
                                         ug_in,
                                         usr_in,
                                         u2ug_prm_out,
                                         addinfo,
                                         obj_exists,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetConns USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc EQ ESA_OK)
		   CS_DIAG_UG2UC_OUT (ESA_COMP_ACSGETF,actual_num, have_more,
		    	u2ug_prm_out, obj_exists, handle, addinfo);
        @*
          Remove all not interesting connections for ESS.
          *@
        rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
        CS_remove_not_interes_conn (&actual_num,
                                    mode,
                                    u2ug_prm_out,
                                    addinfo,
                                    obj_exists);
        num_of_sended_conn += actual_num;
 
        @*
          FILL in the usernames & group names in users/groups DETAILS
          arrays - from the users/groups NAMES arrays.
        *@
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
 
        if (rc NE ESA_OK)
            goto cleanup;
 
      } @* END - Actual action is required *@
 
      @*
        PROCESS when the PostScript is required:
      *@
      if (apiprm.post EQ CS_YES)
      {
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
           "*****>... Start Post script for Get user to group connection.");
        ERROR_CLEAR(err_msg);
 
        @*
          ACTIVATE PostScript
        *@
        rc_pst= CS_pre_post_u2ug (SCRIPT_POST, actual_num,u2ug_prm_out,
			                      addinfo, NULL, &apiprm, rc_act,
								  ESA_RC_UNDEFINED, obj_exists);
		if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
         @* IS10184 *@ fn, ESA_rc2str(rc_pst),
         @* IS10184 *@ u2ug_prm_out[0].group, u2ug_prm_out[0].user);
         @* IS10184    envir_ptr->msg_admin_param.ctsamsg_dest);  *@
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
             @* IS10184 *@ fn, ESA_rc2str(rc_pst),
             @* IS10184 *@ u2ug_prm_out[0].group, u2ug_prm_out[0].user);
             @* IS10184    ESA_rc2str(rc_pst));  *@
 
        ERROR_COPY(&err_pst , err_msg);
        ERROR_CLEAR(err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
      } @* END - PosstScript is required *@
 
      ESA_DIAG_printf (ESA_COMP_ACSGETF , 15,
          "actual=%d snd_conn=%d num_msgs=%d pre:%d act:%d post%d",
		   (int)actual_num, (int)num_of_sended_conn, (int)num_msgs,
		   ESA_RC_UNDEFINED, rc_act, rc_pst);
 
      @*
        SET not last message indicator.
      *@
      CS_set_not_last_msg(msg_cs_ptr);
      @*
        TRANSLATE the api function id to protocol function string id.
      *@
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
        goto cleanup;
 
      @*
        ADD all retrieved connections to reply message buffer.
      *@
      if (((num_of_sended_conn EQ 0) AND
           (num_msgs EQ 0)) OR
          (actual_num GT 0))
         msg_cs = CS_add_cs_msg (&cs_msg_len,
                                  &cs_num_msgs,
                                  func_name,
                                  msg_cs,
                                  msg_cs_ptr,
                                  actual_num,
                                  in_num_user,
                                  usr_prm_out,
                                  oe_prm_out,
                                  ug_prm_out,
                                  u2ug_prm_out,
                                  res_prm_out,
                                  ace_prm_out,
                                  rss_prm_out,
                                  addinfo,
                                  obj_exists,
                                  trana,
                                  msg_hdr,
                                  msg_hdr_cd,
                                  mode,
                                  ESA_RC_UNDEFINED,
                                  rc_act,
                                  rc_pst,
                                  &err_pre,
                                  &err_act,
                                  &err_pst,
                                  &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      strcpy (GLcuser, u2ug_prm_out[0].user);
      strcpy (GLcgroup,u2ug_prm_out[0].group);
 
      if (msg_cs EQ NULL)
      {
        rc=ESA_FATAL;
        goto cleanup;
      }
      if (have_more EQ HAVE_MORE)
      {
         CS_fill_key (addinfo ,
                   interest_key,
                   kwd_types,
                   (unsigned) max_num ,
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
         CLEAR(ug_prm_out);
         CLEAR(usr_prm_out);
         CLEAR(u2ug_prm_out);
      }
    } @* END - WHILE HAVE MORE users *@
 
  } @* END - WHILE there are internal messages left to process *@
 
  @*
    SET Temporary Last message indicator.
  *@
  CS_set_tmp_last_msg (msg_cs_ptr);
  @*
    TRANSLATE the api function id to protocol function string id.
  *@
  rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
 
  @*
    SEND that (last) connections list message to ESS.
  *@
  rc = CS_send_cd_msg (&cs_msg_len ,
                       &cs_num_msgs ,
                       msg_cs_ptr);
 
 
  if (rc NE ESA_OK)
    goto cleanup;
 
 cleanup:
  @*
    PROCESS when the service did not finish naturaly (handle was
    not cleared).
  *@
  if (handle NE NULL) {
    @*
      CLEAR the handle.
    *@
     ESA_RC rcc;
     ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    -> Call to CTSGetConns with GET_FREE_HANDLE_CONNS mode.");
     CS_DIAG_UG2UC_IN (ESA_COMP_ACSGETF, mode, 0, 0, 0,
			ug_in, usr_in, handle, addinfo);
     rcc= envir_ptr->func_ptr.gtug2uc_ptr ( GET_FREE_HANDLE_CONNS,
                                      max_num,
                                      &actual_num,
                                      &have_more,
                                      &handle,
                                      in_num_ug,
                                      in_num_user,
                                      ug_in,
                                      usr_in,
                                      u2ug_prm_out,
                                      addinfo,
                                      obj_exists,
                                      &envir_ptr->msg_admin_param,
                                      err_msg);
      ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetConns USA-API completed with rc=%d (%s).",
			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rcc EQ ESA_OK)
	     CS_DIAG_UG2UC_OUT (ESA_COMP_ACSGETF, 0, have_more, u2ug_prm_out,
		              obj_exists, handle, addinfo);
  }
  @*
    FREE all alocated buffers.
  *@
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&interest_key);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} @* END - CS_ug2uc_get function *@
*** end of dropping CS_ug2uc_get by WS10082A ***/
/****************************************************
 * Procedure Name: CS_res_get
 * Description   : resource gets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve resource(s) details form RSS and
 * to send the results to the ESS. The function loops over all
 * message's requests (internal messages) - and process separately
 * each request.  Each request in this case may cause an outpu of many
 * resources - such as all files in input directory or wild card
 * resources. Although the is no limit to the usage of wild card
 * resources each request is handled in get many mode. the function
 * starts an interior loop - until it receives a "NO MORE" resources
 * indicator from the API.
 * Although it is "GET" function - PreScript and PostrScripts may be
 * activated (to return more information about the resources) - the
 * scripts are activated ONCE for each activation of the API get
 * function.
 * The returned message will contain, after the Application Header
 * (number of messages), for each resource, an RSS header, return
 * codes structure and resource structure. However, the return codes
 * structure is filled only for the first connection in each API call.
 * Please note that the PreScript is activated ONCE PER GET REQUEST
 * while the PostScript is activated ONCE PER OUTPUT RESOURCE DETAILS.
 *********************************************************************/
 
ESA_RC  CS_res_get (MSG_typ               *  msg_ptr ,
                    RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                    RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                    TRAN_rec_typ          *  tran,
                    short                    func_name)
{
  char fn[]="CS_res_get";
  RES_PARAMS_rec_typ    res_prm_in;
  RES_PARAMS_rec_typ    res_prm_out[MAX_GET];
  USER_PARAMS_rec_typ   usr_prm_out[1];
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm_out[1];
  UG_PARAMS_rec_typ     ug_prm_out[1];
  U2UG_PARAMS_rec_typ   u2ug_prm_out[1];
  ACE_rec_typ           ace_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo[MAX_GET];
  ADDINFO_rec_typ     * addinfo_in;
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  NUM_MSGS_typ          len_msg;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  GET_RESOURCE_MODE     mode;
  short                 max_num=0;
  short                 actual_num;
  short                 in_num;
  HAVE_MORE_typ         have_more;
  void                * handle;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  short                 j;
  OBJ_EXISTS_typ        obj_exists[MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
  CLEAR(oe);
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
/* deleted  01/03/98
 * for (ii= 0; ii LT MAX_GET; ii++) {
 *        obj_exists[ii] = OBJ_IGNORED;
 * } */
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo_in  = NULL;
  addinfo[0]  = NULL;
 
  handle = NULL;
 
  /*
    SKIP the GENERAL MESSAGE HEADER.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
 
  /*
    GET the number of RSS messages (requests within message).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL) {
    rc = ESA_ERR;
    goto cleanup;
  }
 
  /*
    RETRIEVE the current function pre/actual/post scripts parameters.
    from RSSAPI parameters file.
  */
  rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,func_name,
                      &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    PREPARE the required action keywords (that relates to the required
    RSS).
  */
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
             envir_ptr->interest[envir_ptr->rss_num].num_res_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Resours keywords");
  if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                      FUNC_UPDRES,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    ALLOCATE memory segment for response.
  */
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE memory segment for input additional information.
  */
  rc= CSA_alloc ((char **)&addinfo_in,
                 STRUC_ADDINFO,
 /*WS10082K*     sizeof (ADDINFO_rec_typ),    */
                 envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                             apiprm.script_kwd_num,
 /*WS10082K*/    1,
                 fn,
                 "Addinfo in");
  if (rc NE ESA_OK)
      goto cleanup;
 /*WS10082K Start */
 /*addinfo_in->max_pairs =
      envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                          apiprm.script_kwd_num;   */
 /*WS10082K End */
  /*
    INITIALIZE the response buffer.
  */
  msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_hdr ,
                         msg_hdr_cd ,
                         msg_cs ,
                         msg_cs_ptr);
 
  /*
    SET the input number to 1 - a single request will be processed each
    time.
  */
  in_num  = 1;
  /*
    SET number of output resources to the maximum for regular get or
    to 1 on full resource get request.
  */
  if (COND_P(MSG_FULRES_GET))
    max_num  = 1 ;
  else
    max_num = MAX_GET;
  /*
    SET the get mode - to GET MANY - for single INPUT resource each
    time - the output might be a list of resources for all resources in
    directory for example.
  */
  mode    = GET_MANY_RESOURCES;
  /*
    ALLOCATE memory segment for the output resources additional info.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
 /* WS10082K*   sizeof(ADDINFO_rec_typ) *       */
              (envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                             apiprm.script_kwd_num),
                 max_num,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    PROCESS all message requests (internal messages):
  */
  while  (
		      (num_msgs GT 0)
             AND
			  (rc_act   NE ESA_FATAL)
             AND
			  (rc_pst   NE ESA_FATAL)
		   )
  {
 
    /*
      RECALCULATE the remaining messages (current - 1).
    */
    num_msgs = num_msgs - in_num;
 
    handle = NULL;
    have_more = HAVE_MORE;
    /*
      GET next RSS message HEADER deatils.
    */
    msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      RETRIEVE request's resource parameters.
    */
    msg_ptr = CS_get_res (&res_prm_in , msg_ptr);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
	ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... Get for resource=%s type=%s", res_prm_in.resource, res_prm_in.restype);
    /*
      RETRIEVE request's additional information.
    */
    msg_ptr = CS_get_addinfo(&addinfo_in ,
		                     msg_ptr);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      PROCESS all output resources from GET request:
    */
 
 
    rc     = ESA_OK;
    ERROR_CLEAR(&err_pre);
      /*
        FILL in the addinfo buffer, the interesting resource's
        keywords.
      */
    CS_fill_key (addinfo,
                 interest_key,
                 kwd_types,
                 (unsigned) max_num ,
                 envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                       apiprm.script_kwd_num);
 
    CLEAR(res_prm_out);
 
    /* added 01/03/98             */
    obj_exists[0]= OBJ_IGNORED; /**/
    /*----------------------------*/
 
    while  (
		      (have_more EQ HAVE_MORE)
             AND
			  (rc_act    NE ESA_FATAL)
             AND
			  (rc_pst    NE ESA_FATAL)
		   )
    {
 
      have_more = NO_MORE ;
      rc_act = ESA_RC_UNDEFINED;
      rc_pst = ESA_RC_UNDEFINED;
 
      ERROR_CLEAR(&err_act);
      ERROR_CLEAR(&err_pst);
      actual_num = in_num;
      /*
        PROCESS when ACTUAL activation required and PostScript did not
        return FATAL or SKIP code.
      */
      if (apiprm.act EQ CS_YES)
      {
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          ACTIVATE API GET resource.
        */
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    -> Call to CTSGetRes USA-API for resource=%s %s.",
			res_prm_in.resource, res_prm_in.restype);
        CS_DIAG_RESACL_IN (ESA_COMP_ACSGETF, (int)mode, oe, max_num,
			&res_prm_in, NULL, addinfo_in, handle, addinfo);
        rc_act = envir_ptr->func_ptr.getres_ptr(mode,
                                      oe,
                                      max_num,
                                      &actual_num,
                                      &have_more,
                                      &handle,
                                      &res_prm_in,
                                      addinfo_in,
                                      res_prm_out,
                                      addinfo,
                                      &envir_ptr->msg_admin_param,
                                      err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetRes USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc_act EQ ESA_OK)
		   CS_DIAG_RESACL_OUT (ESA_COMP_ACSGETF, oe, actual_num, have_more,
		    	res_prm_out, NULL, obj_exists, handle, addinfo);
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
        for (j= 0; j LT actual_num; j++)
            obj_exists[j]=OBJ_EXIST;
 
        rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
      }
      /*
        PROCESS when PostScript is required:
      */
      if (apiprm.post EQ CS_YES)
      {
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
           "*****>... Start Post script for Get resource.");
        ERROR_CLEAR(err_msg);
 
        /*
          ACTIVATE the PostScript
        */
        rc_pst = CS_pre_post_res (SCRIPT_POST , actual_num,
                      res_prm_out, addinfo, NULL, addinfo_in,
                      &apiprm, rc_act, ESA_RC_UNDEFINED, obj_exists);
 
		if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_RES_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
         /* IS10184 */ envir_ptr->msg_admin_param.ctsamsg_dest,
         /* IS10184 */ fn, ESA_rc2str(rc_pst), res_prm_out[0].resource,
						   /* IS10184 */ res_prm_out[0].restype);
         /* IS10184    envir_ptr->msg_admin_param.ctsamsg_dest); */
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_RES_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
             /* IS10184 */ fn, ESA_rc2str(rc_pst),
             /* IS10184 */ res_prm_out[0].resource,
						       /* IS10184 */ res_prm_out[0].restype);
             /* IS10184    ESA_rc2str(rc_pst));  */
 
        ERROR_COPY(&err_pst ,err_msg);
        ERROR_CLEAR(err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
      } /* END - PostScript activation */
 
      ESA_DIAG_printf (ESA_COMP_ACSGETF ,15,
                       "API run results pre:%d act:%d post%d",
                       ESA_RC_UNDEFINED,
                       rc_act,
                       rc_pst);
 
      CS_set_not_last_msg(msg_cs_ptr);
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
        goto cleanup;
      /*  01/03/98 - removed by Leonid */
      /*  24/4/98 - restored by AVIW */
      /*  1/6/00 - moved by leonid to up */
      /*if (actual_num GT 0)
           for (j= 0; j LT actual_num; j++)
                obj_exists[j]=OBJ_EXIST;*/
 
 
      /* added 01/03/98               */
      if ( (actual_num GT 0) OR (obj_exists[0] EQ OBJ_IGNORED) ) /**/
	  {
		 /* changed by leonid 1/6/00                               */
         /*if (actual_num GT 0)                                    */
         /*    obj_exists[0]= OBJ_EXIST;                           */
      /*-----------------------------------------------------------*/
 
        /*
        ADD output resources to response message buffer.
        */
        msg_cs = CS_add_cs_msg (&cs_msg_len,
                              &cs_num_msgs,
                              func_name,
                              msg_cs,
                              msg_cs_ptr,
                              actual_num,
                              in_num,
                              usr_prm_out,
                              oe_prm_out,
                              ug_prm_out,
                              u2ug_prm_out,
                              res_prm_out,
                              ace_prm_out,
                              rss_prm_out,
                              addinfo,
                              obj_exists,
                              tran,
                              msg_hdr,
                              msg_hdr_cd,
                              mode,
                              ESA_RC_UNDEFINED,
                              rc_act,
                              rc_pst,
                              &err_pre,
                              &err_act,
                              &err_pst,
                              &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
		strcpy (GLres, res_prm_out[0].resource);
        strcpy (GLrestp , res_prm_out[0].restype);
 
        if (msg_cs EQ NULL)
		{
          rc= ESA_FATAL;
          goto cleanup;
		}
 
      /* added 01/03/98    */
      }                 /**/
      /*------------------*/
	
      if (COND_P(MSG_FULRES_GET))
      {
        /*
          SEND (single) resource details message to ESS.
        */
        if (actual_num EQ 0)
           CS_set_tmp_last_msg (msg_cs_ptr);
        rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
        rc = CS_send_cd_msg (&cs_msg_len ,
                             &cs_num_msgs ,
                             msg_cs_ptr);
        if (rc NE ESA_OK)
          goto cleanup;
        /*
          REINITIALIZE the response buffer.
        */
        if (actual_num GT 0)
        {
           msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                                  &cs_num_msgs ,
                                  msg_hdr ,
                                  msg_hdr_cd ,
                                  msg_cs ,
                                  msg_cs_ptr);
 
           rc = CS_rsacl_get (&(res_prm_out[0]) ,
                              addinfo[0],  /*addinfo_in*/
                              NULL ,
                              msg_hdr ,
                              msg_hdr_cd ,
                              tran ,
                              (have_more EQ HAVE_MORE) ?
                              0
                              :
                              1 ,
                              FUNC_GTRSACL);
               if (rc NE ESA_OK)
                   goto cleanup;
        } /* END - actual number GT 0 */
 
      } /* END - Full resource details is required */
 
      if (have_more EQ HAVE_MORE)
      {
             CS_fill_key (addinfo ,
                          interest_key,
                          kwd_types,
                          (unsigned) max_num ,
                envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                                apiprm.script_kwd_num);
 
             CLEAR(res_prm_out);
      }
    } /* END - While HAVE MORE */
 
  } /* END - WHILE loop on INPUT requests */
 
  /*
    SEND last resources details message - if no ACL details required
   (in that case the TMP_LAST indicator was sent with the last ACL).
  */
  if (NOT COND_P(MSG_FULRES_GET)) {
    CS_set_tmp_last_msg (msg_cs_ptr);
    rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
    /*
      SEND (last) message to ESS.
      */
    rc = CS_send_cd_msg (&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_cs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  } /* END - only resource details (no ACL) */
 
 cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle,
                   NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
  if (handle NE NULL) {
     ESA_RC rcc;
     ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		 "    -> Call to CTSGetRes USA-API with GET_FREE_HANDLE_RESOURCES mode.");
     CS_DIAG_RESACL_IN (ESA_COMP_ACSGETF, (int)GET_FREE_HANDLE_RESOURCES,
		 oe, 0, &res_prm_in, NULL, addinfo_in, handle, addinfo);
     rcc= envir_ptr->func_ptr.getres_ptr(GET_FREE_HANDLE_RESOURCES,
                                  oe,
                                  max_num,
                                  &actual_num,
                                  &have_more,
                                  &handle,
                                  &res_prm_in,
                                  addinfo_in,
                                  res_prm_out,
                                  addinfo,
                                  &envir_ptr->msg_admin_param,
                                  err_msg);
     ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetRes USA-API  completed with rc=%d (%s).",
			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
     if (rcc EQ ESA_OK)
	    CS_DIAG_RESACL_OUT (ESA_COMP_ACSGETF, oe, 0, have_more, res_prm_out,
		   NULL, obj_exists, handle, addinfo);
  }
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&addinfo_in);
  CSA_free ((char **)&interest_key);
 
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_res_get function */
 
/****************************************************
 * Procedure Name: CS_rsacl_get
 * Description   : resource ACL function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve resource(s) ACL details form RSS
 * and to send the results to the ESS. The function loops over all
 * message's requests (internal messages) - and process separately
 * each request.  Each request causes an output of many resource ACEs.
 * The function starts an interior loop - until it receives a "NO MORE"
 * ACEs indicator from the API.
 * Although it is "GET" function - PreScript and PostrScripts may be
 * activated (to return more information about the ACEs) - the
 * scripts are activated ONCE for each activation of the API get
 * function.
 * The returned message will contain, after the Application Header
 * (number of messages), for each resource, an RSS header, return
 * codes structure and resource structure and ACE structure. However,
 * the return codes structure is filled only for the first ACE in each
 * API call.
 * Please note that the PreScript is activated ONCE PER GET REQUEST
 * while the PostScript is activated ONCE PER OUTPUT ACE DETAILS.
 *********************************************************************/
 
ESA_RC  CS_rsacl_get (RES_PARAMS_rec_typ    *  res_prm_in ,
                      ADDINFO_rec_typ       *  addinfo_res_in,
                      MSG_typ               *  msg_ptr ,
                      RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                      RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                      TRAN_rec_typ          *  tran,
                      int                      send_tmp_last,
                      short                    func_name)
{
  char fn[]="CS_rsacl_get";
  RES_PARAMS_rec_typ    res_prm;
  ACE_rec_typ           ace_prm[MAX_GET];
  ACE_POS_typ           ace_place;
  USER_PARAMS_rec_typ   usr_prm_out[1];
  OE_PARAMS_rec_typ     oe_prm_out[1];
  UG_PARAMS_rec_typ     ug_prm_out[1];
  U2UG_PARAMS_rec_typ   u2ug_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo[MAX_GET];
  ADDINFO_rec_typ     * addinfo_res;
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  NUM_MSGS_typ          len_msg;
  GET_ACL_MODE          mode;
  short                 max_num= 0;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  short                 actual_num;
  short                 in_num, sw_have_more;
  HAVE_MORE_typ         have_more;
  void                * handle;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  short                 j;
  OBJ_EXISTS_typ        obj_exists[MAX_GET];
  int                   whole_msg_in = 0;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  if (msg_ptr NE NULL)
    whole_msg_in = 1;
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo_res = NULL;
  addinfo[0]  = NULL;
 
  handle = NULL;
 
  if (whole_msg_in)
  {
    /*
      SKIP the GENERAL MESSAGE HEADER.
    */
    msg_ptr = CS_get_aplic_msg(msg_ptr);
    /*
      GET the number of RSS messages (requests within message).
    */
    msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
    if (msg_ptr EQ NULL)
    {
      rc = ESA_ERR;
      goto cleanup;
    }
  }
  else
    num_msgs = 1;
  /*
    RETRIEVE the current function pre/actual/post scripts parameters.
    from RSSAPI parameters file.
  */
  rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,func_name,
                      &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    PREPARE the required action keywords (that relates to the required
    RSS).
  */
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Aces keywords");
  if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                      FUNC_ADDACE,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE memory segment for response.
  */
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  if (whole_msg_in)
  {
    /*
      ALLOCATE memory segment for input additional information.
    */
    rc= CSA_alloc ((char **)&addinfo_res,
                   STRUC_ADDINFO,
 /*WS10082K*       sizeof (ADDINFO_rec_typ),     */
              envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                         apiprm.script_kwd_num,
 /*WS10082K*/      1,
                   fn,
                   "addinfo res");
    if (rc NE ESA_OK)
      goto cleanup;
    /*WS10082K - Start */
    /*
      SET number of output pairs to the maximum.
    */
 /*WS10082A addinfo_res->max_pairs=
        envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                             apiprm.script_kwd_num;            */
    /*WS10082K - End */
  }
 
  /*
    INITIALIZE the response buffer.
  */
  msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_hdr ,
                         msg_hdr_cd ,
                         msg_cs ,
                         msg_cs_ptr);
  /*
    SET the input number to 1 - a single request will be processed each
    time.
  */
  in_num  = 1;
  max_num = MAX_GET;
  /*
    SET the get mode - to GET MANY - for single INPUT resource each
    time - the output is a list of all the resource ACL's ACEs.
  */
  mode    = GET_RESOURCE_ACL;
  /*
    ALLOCATE memory segment for the output ACEs additional info.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K       sizeof(ADDINFO_rec_typ) *      */
              (envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds+
                             apiprm.script_kwd_num),
                 max_num,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    PROCESS all message requests (internal messages):
  */
  while  (
		      (num_msgs GT 0)
             AND
			  (rc_act   NE ESA_FATAL)
             AND
			  (rc_pst   NE ESA_FATAL)
		   )
  {
    handle = NULL;
    have_more = HAVE_MORE;
    /*
      RECALCULATE the remaining messages (current - 1).
    */
    num_msgs = num_msgs - in_num;
    if (whole_msg_in)
    {
      /*
        GET next RSS message HEADER deatils.
      */
      msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
      if (msg_ptr EQ NULL)
      {
        rc = ESA_ERR;
        goto cleanup;
      }
      /*
        RETRIEVE request's resource parameters.
      */
      msg_ptr = CS_get_res (&res_prm , msg_ptr);
      if (msg_ptr EQ NULL) {
        rc = ESA_ERR;
        goto cleanup;
      }
      /*
        RETRIEVE request's resource additional information.
      */
      msg_ptr = CS_get_addinfo(&addinfo_res ,
		                       msg_ptr);
      if (msg_ptr EQ NULL) {
        rc = ESA_ERR;
        goto cleanup;
      }
    } /* END - the whole message in input */
    else
    {
      memcpy ((char *)(&res_prm) , (char *)res_prm_in ,
              sizeof(RES_PARAMS_rec_typ));
      addinfo_res = addinfo_res_in ;
    }
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
        "*****>... Get for resource=%s type=%s",res_prm.resource, res_prm.restype);
    /*
      PROCESS all output ACEs from GET request:
    */
 
    rc     = ESA_OK;
 
    ERROR_CLEAR(&err_pre);
      /*
        FILL in the addinfo buffer, the interesting ACE's
        keywords.
      */
    CS_fill_key (addinfo ,
                 interest_key,
                 kwd_types,
                 (unsigned) max_num ,
                 envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds+
                       apiprm.script_kwd_num);
 
    CLEAR(ace_prm);
 
    sw_have_more= 0;
    while  (
		      (have_more EQ HAVE_MORE)
             AND
			  (rc_act    NE ESA_FATAL)
             AND
			  (rc_pst    NE ESA_FATAL)
		   )
    {
      have_more = NO_MORE ;
      rc_act = ESA_RC_UNDEFINED;
      rc_pst = ESA_RC_UNDEFINED;
 
      ERROR_CLEAR(&err_act);
      ERROR_CLEAR(&err_pst);
      actual_num = in_num;
      /*
        PROCESS when ACTUAL activation required and PostScript did not
        return FATAL or SKIP code.
      */
      if (apiprm.act EQ CS_YES)
      {
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          ACTIVATE API GET ACL.
        */
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    -> Call to CTSGetResACL USA-API for resource=%s %s.",
			res_prm.resource, res_prm.restype);
        CS_DIAG_RESACL_IN (ESA_COMP_ACSGETF, (int)mode, NULL, max_num,
			&res_prm, ace_prm, NULL, handle, addinfo);
        rc_act = envir_ptr->func_ptr.gtrsacl_ptr(GET_RESOURCE_ACL,
                                       max_num,
                                       &actual_num,
                                       &have_more,
                                       &handle,
                                       &res_prm,
                                       ace_prm,
                                       addinfo,
                                       &envir_ptr->msg_admin_param,
                                       err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetResACL USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc_act EQ ESA_OK)
		   CS_DIAG_RESACL_OUT (ESA_COMP_ACSGETF, NULL, actual_num, have_more,
		    	&res_prm, ace_prm, obj_exists, handle, addinfo);
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
 
        for (j= 0; j LT actual_num; j++)
           obj_exists[j]=OBJ_EXIST;
 
        rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
        if (
              (actual_num EQ 0)
             AND
              (sw_have_more GT 0)
           )
           break;
        sw_have_more += 1;
      }
      /*
        PROCESS when PostScript is required:
      */
      if (apiprm.post EQ CS_YES)
      {
 
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
           "*****>... Start Post script for Get resource acl.");
        /*
          ACTIVATE the PostScript
        */
        rc_pst = CS_pre_post_ace(SCRIPT_POST, actual_num, FUNC_GTRSACL,
                        &res_prm, ace_prm, addinfo, NULL, addinfo_res,
                        &ace_place, &apiprm, rc_act,
						ESA_RC_UNDEFINED, obj_exists);
		if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_ACE_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
         /* IS10184 */ envir_ptr->msg_admin_param.ctsamsg_dest,
         /* IS10184 */ ESA_rc2str(rc_pst),
         /* IS10184 */ (strlen (ace_prm[0].user_name) NE 0) ?
							  /* IS10184 */      ace_prm[0].user_name  :
			      /* IS10184 */     (strlen (ace_prm[0].ug_name) NE 0) ?
								 /* IS10184 */        ace_prm[0].ug_name : ace_prm[0].oe_name,
						   /* IS10184 */ res_prm.resource, res_prm.restype);
         /* IS10184    envir_ptr->msg_admin_param.ctsamsg_dest); */
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_ACE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
             /* IS10184 */ ESA_rc2str(rc_pst),
             /* IS10184 */ (strlen (ace_prm[0].user_name) NE 0) ?
							      /* IS10184 */   ace_prm[0].user_name  :
			          /* IS10184 */     (strlen (ace_prm[0].ug_name) NE 0) ?
								     /* IS10184 */      ace_prm[0].ug_name : ace_prm[0].oe_name,
						       /* IS10184 */ res_prm.resource, res_prm.restype);
             /* IS10184    ESA_rc2str(rc_pst));  */
 
        ERROR_COPY(&err_pst , err_msg);
        ERROR_CLEAR(err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
      } /* END - PostScript activation */
 
      ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                       "API run results pre:%d act:%d post%d",
                       ESA_RC_UNDEFINED,
                       rc_act,
                       rc_pst);
 
      CS_set_not_last_msg(msg_cs_ptr);
      rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
      if (rc NE ESA_OK)
        goto cleanup;
 
      /*
        ADD output resources to response message buffer.
      */
      msg_cs = CS_add_cs_msg (&cs_msg_len,
                              &cs_num_msgs,
                              func_name,
                              msg_cs,
                              msg_cs_ptr,
                              actual_num,
                              in_num,
                              usr_prm_out,
                              oe_prm_out,
                              ug_prm_out,
                              u2ug_prm_out,
                              &res_prm,
                              ace_prm,
                              rss_prm_out,
                              addinfo,
                              obj_exists,
                              tran,
                              msg_hdr,
                              msg_hdr_cd,
                              mode,
                              ESA_RC_UNDEFINED,
                              rc_act,
                              rc_pst,
                              &err_pre,
                              &err_act,
                              &err_pst,
                              &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
	  strcpy (GLres, res_prm.resource);
      strcpy (GLrestp , res_prm.restype);
      strcpy (GLruser , 	  ace_prm[0].user_name);
	  strcpy (GLrgroup ,   ace_prm[0].ug_name);
 
      if (msg_cs EQ NULL)
      {
        rc=ESA_FATAL;
        goto cleanup;
      }
      if (have_more EQ HAVE_MORE)
      {
           CS_fill_key (addinfo ,
                 interest_key,
                 kwd_types,
                 (unsigned) max_num ,
                 envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds+
                       apiprm.script_kwd_num);
 
           CLEAR(ace_prm);
      }
    } /* END - While HAVE MORE */
 
  } /* END - WHILE loop on INPUT requests */
 
  if (send_tmp_last)
    CS_set_tmp_last_msg (msg_cs_ptr);
  rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    SEND (last) message to ESS.
  */
  rc = CS_send_cd_msg (&cs_msg_len ,
                       &cs_num_msgs ,
                       msg_cs_ptr);
 
  if (rc NE ESA_OK)
    goto cleanup;
 
 cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle,
                   NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
  if (handle NE NULL) {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    -> Call to CTSGetResACL USA-API with GET_FREE_HANDLE_ACL mode.");
    CS_DIAG_RESACL_IN (ESA_COMP_ACSGETF, (int)GET_FREE_HANDLE_ACL, NULL,
		0, &res_prm, ace_prm, NULL, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtrsacl_ptr(GET_FREE_HANDLE_ACL,
                                   max_num,
                                   &actual_num,
                                   &have_more,
                                   &handle,
                                   &res_prm,
                                   ace_prm,
                                   addinfo,
                                   &envir_ptr->msg_admin_param,
                                   err_msg);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetResACL USA-API completed with rc=%d (%s).",
			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_RESACL_OUT (ESA_COMP_ACSGETF, NULL, 0, have_more, &res_prm,
		               ace_prm, obj_exists, handle, addinfo);
  }
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  if (whole_msg_in)
    CSA_free ((char **)&addinfo_res);
  CSA_free ((char **)&interest_key);
 
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_rsacl_get function */
 
/****************************************************
 * Procedure Name: CS_rsprm_get
 * Description   : RSS parameters function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used to retrieve RSS PARAMETERS and to send the
 * results to the ESS. The function prepares the RSS addinfo - activate
 * the API RSSPRM GET function and send the nresults back to the ESS.
 * Unluike ALL other GET functions - this function does not activates
 * Pre or Post Scripts and does not receive a message with more than
 * single request (internal message).
 *********************************************************************/
 
ESA_RC  CS_rsprm_get (MSG_typ               *  msg_ptr ,
                      RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                      RSS_MSG_HDR_rec_typ   *  msg_hdr_cd ,
                      short                    func_name)
{
  char fn[]="CS_rsprm_get";
  ACE_rec_typ           ace_prm_out[1];
  USER_PARAMS_rec_typ   usr_prm_out[1];
  OE_PARAMS_rec_typ     oe_prm_out[1];
  UG_PARAMS_rec_typ     ug_prm_out[1];
  U2UG_PARAMS_rec_typ   u2ug_prm_out[1];
  RES_PARAMS_rec_typ    res_prm_out[1];
  RSS_PARAMS_rec_typ    rss_prm_out[1];
  ADDINFO_rec_ptr       addinfo[1];
  MSG_typ             * msg_cs;
  MSG_typ             * msg_cs_ptr;
  NUM_MSGS_typ          num_msgs;
  NUM_MSGS_typ          cs_msg_len;
  NUM_MSGS_typ          cs_num_msgs;
  ESA_RC                rc;
  ESA_RC                rc_act;
  ESA_RC                rc_pst;
  ERR_STRUCT_rec_typ    err_pre;
  ERR_STRUCT_rec_typ    err_act;
  ERR_STRUCT_rec_typ    err_pst;
  ERR_STRUCT_rec_typ  * err_msg;
  RSSAPIKWD_rec_typ   * interest_key;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  OBJ_EXISTS_typ        obj_exists[1];
  TRAN_rec_typ          trana[1];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
  rc     = ESA_OK;
  rc_act = ESA_RC_UNDEFINED;
  rc_pst = ESA_RC_UNDEFINED;
 
  ERROR_CLEAR(&err_pre);
  ERROR_CLEAR(&err_act);
  ERROR_CLEAR(&err_pst);
 
  msg_cs_ptr  = NULL;
  msg_cs      = NULL;
  addinfo[0]  = NULL;
 
  obj_exists[0] = OBJ_EXIST;
  /*
    SKIP the GENERAL MESSAGE HEADER.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the number of RSS messages (requests within message).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
 
  /*
    SAVE action and transaction set up
  */
  memcpy((char *)trana,MH_TRN,strlen(MH_TRN));
 
  if (msg_ptr EQ NULL)
  {
    rc = ESA_ERR;
    goto cleanup;
  }
  /*
    RETRIEVE the current function actual action parameter from RSSAPI
    parameters file. (Pre/Post Scripts are not used here!).
  */
  rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,func_name,
                      &apiprm);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    PREPARE the required action keywords (that relates to the required
    RSS).
  */
  rc= CSA_alloc ((char **)&interest_key,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Rss keywords");
  if (rc NE ESA_OK)
       goto cleanup;
  rc = CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                      FUNC_GTRSPRM,
                      interest_key);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE memory segment for response.
  */
  rc= CSA_alloc ((char **)&msg_cs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "Msg space");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    INITIALIZE the response buffer.
  */
  msg_cs=CS_reset_cs_msg(&cs_msg_len ,
                         &cs_num_msgs ,
                         msg_hdr ,
                         msg_hdr_cd ,
                         msg_cs ,
                         msg_cs_ptr);
  /*
    ALLOCATE memory segment for the output RSS additional info.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
              (envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds+
                             apiprm.script_kwd_num),
                 1,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    FILL in the addinfo buffer, the interesting ACE's
    keywords.
  */
  CS_fill_key (addinfo ,
               interest_key,
               kwd_types,
               1 ,
               envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds+
                       apiprm.script_kwd_num);
 
  /*
    PROCESS when actual action is required:
  */
  if ( apiprm.act EQ CS_YES )
  {
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
        goto cleanup;
    /*
      ACTIVATE API GET ACL.
    */
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    -> Call to CTSGetRSSParams USA-API.");
    CS_DIAG_ADDINFO (ESA_COMP_ACSGETF, addinfo[0], 0,FALSE);
    rc_act = envir_ptr->func_ptr.gtrsprm_ptr ( rss_prm_out,
                                     addinfo[0],
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
	  "     MinPwdLen=%d MaxExpire=%d MaxLogins=%d Err=%.*s.",
      rss_prm_out->min_pass_len, rss_prm_out->max_expire,
	  rss_prm_out->max_logins, err_msg->length, err_msg->err_msg_text);
    if (rc_act EQ ESA_OK)
	   CS_DIAG_ADDINFO (ESA_COMP_ACSGETF, addinfo[0], 0, TRUE);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
			"    <- CTSGetRSSParams USA-API completed with rc=%d (%s).",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
 
    ERROR_COPY(&err_act , err_msg);
    ERROR_CLEAR(err_msg);
 
    rc= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
        goto cleanup;
  }
 
  if (apiprm.post EQ CS_YES)
  {
 
	 ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
           "*****>... Start Post script for Get rss parameter.");
     ERROR_CLEAR(err_msg);
     rc_pst = CS_pre_post_rssprm (SCRIPT_POST ,
                                  rss_prm_out, addinfo, NULL,
                                  &apiprm, rc_act, ESA_RC_UNDEFINED);
	 if (rc_pst EQ ESA_OK)
             CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_SKIP)
             CTSAMSG_print (MSG_RSPRMPOSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
         /* IS10184 */ envir_ptr->msg_admin_param.ctsamsg_dest,
         /* IS10184 */ fn, rss_prm_out[0].min_pass_len,
         /* IS10184 */ rss_prm_out[0].max_expire,
						   /* IS10184 */ rss_prm_out[0].max_logins, ESA_rc2str(rc_pst));
         /* IS10184    envir_ptr->msg_admin_param.ctsamsg_dest);  */
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_RSPRMPOSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
             /* IS10184 */ envir_ptr->msg_admin_param.ctsamsg_dest,
             /* IS10184 */ fn, rss_prm_out[0].min_pass_len,
             /* IS10184 */ rss_prm_out[0].max_expire,
						       /* IS10184 */ rss_prm_out[0].max_logins,
             /* IS10184 */ ESA_rc2str(rc_pst));
             /* IS10184     ESA_rc2str(rc_pst));   */
     ERROR_COPY(&err_pre , err_msg);
     ERROR_CLEAR(err_msg);
     ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC, "<*****... End Post script.");
  } /* END - PostScript activation */
 
  ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
                   "API run results pre:%d act:%d post%d",
                   ESA_RC_UNDEFINED, rc_act, rc_pst);
 
  CS_set_not_last_msg(msg_cs_ptr);
  rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    ADD output resources to response message buffer.
  */
  msg_cs = CS_add_cs_msg (&cs_msg_len,
                          &cs_num_msgs,
                          func_name,
                          msg_cs,
                          msg_cs_ptr,
                          1,
                          1,
                          usr_prm_out,
                          oe_prm_out,
                          ug_prm_out,
                          u2ug_prm_out,
                          res_prm_out,
                          ace_prm_out,
                          rss_prm_out,
                          addinfo,
                          obj_exists,
                          trana,
                          msg_hdr,
                          msg_hdr_cd,
                          GET_MANY_RESOURCES,
                          ESA_RC_UNDEFINED,
                          rc_act,
                          rc_pst,
                          &err_pre,
                          &err_act,
                          &err_pst,
                          &rc);
  if (rc NE ESA_OK)
    goto cleanup;
 
 
  if (msg_cs EQ NULL)
  {
    rc=ESA_FATAL;
    goto cleanup;
  }
 
  CS_set_tmp_last_msg (msg_cs_ptr);
  rc= CS_api_to_capi_id (func_name , msg_cs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SEND (last) message to ESS.
  */
  rc = CS_send_cd_msg (&cs_msg_len ,
                       &cs_num_msgs ,
                       msg_cs_ptr);
 
  if (rc NE ESA_OK)
    goto cleanup;
 
  cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle,
                   NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
  CSA_free ((char **)&msg_cs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&interest_key);
 
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_rsprm_get function */
 
/****************************************************
 * Procedure Name: CS_pre_post_users
 * Description   : pre post for users
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used in order to activate Pre/Post script
 * before/after successive call to get users in a loop (as long
 * as there are more users to get).
 * Although upon successive calls - with the same users input list
 * the Pre/Post script results must be the same, The Pre/post script
 * called in order to reconstruct the addinfo (if it is changed by that
 * call).
 * The function goes over all the input users in the list, and activate
 * the script for it. There is only one reason to do that - the message
 * returned from the script - is added to the script's message buffer;
 * however, the return code returned - is the last user's call returned
 * code, and the additional buffer returned - is supposed to be the
 * same in each call.
 *********************************************************************/
 
ESA_RC CS_pre_post_users    (SCRIPT_ACTION_typ       action,
                             short                   num_msg,
                             USER_PARAMS_rec_typ     usr_prm[1],
                             ADDINFO_rec_ptr         set_addinfo[1],
                             ADDINFO_rec_ptr         get_addinfo[1],
                             RSSAPIPRM_rec_typ     * apiprm,
                             ESA_RC                  rc_act,
                             ESA_RC                  rc_pre,
						     OBJ_EXISTS_typ          obj_exist[1])
{
  char                  fn[]="CS_pre_post_users";
  int                   i;
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK;
  ESA_RC                max_rc = ESA_OK;                  /* IS10184 */
  /* IS10184 SCRIPT_NAME_typ       script_dir;  */
  ENVIRONMENT_rec_typ * envir_ptr;
   /*Nitin*/
  ONE_FIELD_rec_ptr     cpair = NULL; /* 502839 , cpair2= NULL;*/
 
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* IS10184 - removed.  Will be done by OS_CS_script
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  }  */
  /*
    PROCESS all in_users for the API GET function:
  */
  /* IS10184
  for (i =0 ; (i LT num_msg) AND (rc NE ESA_FATAL)  ; i++)    */
  for (i =0 ; (i LT num_msg) ; i++)                       /* IS10184 */
  {
 
    rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
    if (rc NE ESA_OK)
      goto cleanup;
 
    rc = CS_entity_info_add  (STRUC_USER_REC ,&usr_prm[i]);
    if (rc NE ESA_OK)
      goto cleanup;
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(envir_ptr->entity_info,1);
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
 
  /*CS_addinfo_prt(envir_ptr->entity_info,
        "Entity info before script");
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo before script");
 
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo before script");  */
    /*WS10082K - End */
 
    if (apiprm->api NE FUNC_GTUSERS)                      /* IS10184 */
    {                                                     /* IS10184 */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
    };                                                    /* IS10184 */
 
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
       "    =<> Call to OS_CS_script.");
       /* IS10184
     CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm,*/
       CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR,   /* IS10184 */
       action, apiprm,                                    /* IS10184 */
		     set_addinfo[i], (get_addinfo EQ NULL) ? NULL : get_addinfo[i]);
 
    rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                        envir_ptr->msg_admin_param.rss_type,
         /* IS10184     script_dir,   */
                        SCRIPT_DIR,                       /* IS10184 */
                        (action EQ SCRIPT_PRE) ?
                        apiprm->pre_prog
                        :
                        apiprm->post_prog,
                        apiprm->api,
                        action,
                        envir_ptr->entity_info ,
                        set_addinfo[i] ,
                        (get_addinfo EQ NULL) ?
                        NULL
                        :
                        get_addinfo[i] ,
                 envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                        &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[i],0,TRUE);
 
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "POST SCRIPT returned with rc=%d for user %s.",
		   rc, usr_prm[i].user);
/* 	   obj_exist[i]= OBJ_EXIST; */         /* IMH001 */
 
 
	
	/*Nitin More:27 July 2006: Find the user_sta in addinfo
	and take its value and assign to the user revoked status*/
	cpair = ADDINFO_search ("USER_STA", strlen ("USER_STA"),
                   set_addinfo[i]->pair, set_addinfo[i]->num_pairs);
		
	if ( cpair)
	{
   /*WS10082A if (strlen ((char *)cpair->value) GT 0)        */
	  if (cpair->vallen GT 0) /*WS10082A assuming vallen is set*/
	   {		
       /* No need to update ->value as USER_STA is Short WS10082A */
        ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
                     "Value of USER_STA-%s", (char *)cpair->value);
	     usr_prm[i].rev_status = atoi(cpair->value);
	    }
	
	 }
  	else
	 {
      ESA_DIAG_printf (ESA_COMP_ACSGPF, DIAG_BASIC,
                      "No USER_STA found in Addinfo");
	 }	
 
 
    }
    else if (rc EQ ESA_SKIP)
    {
       obj_exist[i]= OBJ_NOT_EXIST;
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
            "User %s is skipped by POST SCRIPT", usr_prm[i].user);
    }
    else
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "User %s: POST SCRIPT returned with rc=%d.",
		          usr_prm[i].user, rc);
 
    /*WS10082K - use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo after script");
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo after script");
    ** WS10082K - End */
 
    if (apiprm->api NE FUNC_GTUSERS)                      /* IS10184 */
      rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
    else                                                  /* IS10184 */
      rc_adm = ESA_OK;                                    /* IS10184 */
 
    /* IS10184 -
    if ( (rc_adm NE ESA_OK) OR ( (rc NE ESA_OK) AND (rc NE ESA_SKIP) ) )
       goto cleanup;   */
    if (rc_adm NE ESA_OK)                                 /* IS10184 */
       goto cleanup;                                      /* IS10184 */
 
    max_rc = MAX(rc, max_rc);  /* save max rc and continue.  IS10184 */
  }
 
 
 
  cleanup:
  rc = MAX(rc, max_rc);                                   /* IS10184 */
  if ( ( (rc EQ ESA_OK) OR (rc EQ ESA_SKIP) ) AND (rc_adm NE ESA_OK) )
     rc= rc_adm;
 
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_users function */
 
/****************************************************
 * Procedure Name: CS_pre_post_ug
 * Description   : pre post for user group
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used in order to activate Pre/Post script
 * before/after successive call to get groups in a loop (as long
 * as there are more groups to get).
 * Although upon successive calls - with the same users input list
 * the Pre/Post script results must be the same, The Pre/post script
 * called in order to reconstruct the addinfo (if it is changed by that
 * call).
 * The function goes over all the input groups in the list, and activate
 * the script for it. There is only one reason to do that - the message
 * returned from the script - is added to the script's message buffer;
 * however, the return code returned - is the last group's call returned
 * code, and the additional buffer returned - is supposed to be the
 * same in each call.
 *********************************************************************/
 
ESA_RC CS_pre_post_ug    (SCRIPT_ACTION_typ       action,
                          short                   num_msg,
                          UG_PARAMS_rec_typ       ug_prm[1],
                          ADDINFO_rec_ptr         set_addinfo[1],
                          ADDINFO_rec_ptr         get_addinfo[1],
                          RSSAPIPRM_rec_typ     * apiprm,
                          ESA_RC                  rc_act,
                          ESA_RC                  rc_pre,
                          OBJ_EXISTS_typ          obj_exist[1])
{
  char                  fn[]="CS_pre_post_ug";
  int                   i;
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK ;
  ESA_RC                max_rc = ESA_OK;                  /* IS10184 */
  /* IS10184 SCRIPT_NAME_typ       script_dir;  */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* IS10184 - removed.  Will be done by OS_CS_script
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  }   */
  /*
    PROCESS all in_groups for the API GET function:
  */
  /* IS10184
  for (i =0 ; (i LT num_msg) AND (rc NE ESA_FATAL)  ; i++)  */
  for (i =0 ; (i LT num_msg) ; i++)                       /* IS10184 */
  {
     /*
      BUILD environment entity additional info
    */
    rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
    if (rc NE ESA_OK)
      goto cleanup;
 
    rc = CS_entity_info_add  (STRUC_UG_REC ,&ug_prm[i]);
    if (rc NE ESA_OK)
      goto cleanup;
 
    /*WS10082K - use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(envir_ptr->entity_info,1);
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(envir_ptr->entity_info,
        "Entity info before script");
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo before script");
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo before script");
    ** WS10082K*/
 
    if (apiprm->api NE FUNC_GETUGS )                      /* IS10184 */
    {                                                     /* IS10184 */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
      if (rc NE ESA_OK)
          goto cleanup;
    };                                                    /* IS10184 */
 
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
                      "    =<> Call to OS_CS_script.");
    /* IS10184
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm, */
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR,      /* IS10184 */
         action, apiprm,                                  /* IS10184 */
		       set_addinfo[i], (get_addinfo EQ NULL) ? NULL : get_addinfo[i]);
    rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                        envir_ptr->msg_admin_param.rss_type,
          /* IS10184    script_dir,  */
                        SCRIPT_DIR,                       /* IS10184 */
                        (action EQ SCRIPT_PRE) ?
                        apiprm->pre_prog
                        :
                        apiprm->post_prog,
                        apiprm->api,
                        action,
                        envir_ptr->entity_info ,
                        set_addinfo[i] ,
                        (get_addinfo EQ NULL) ?
                        NULL
                        :
                        get_addinfo[i] ,
			     envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                        &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[i],0,TRUE);
 
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "POST SCRIPT returned with rc=%d for group %s.",
		   rc, ug_prm[i].group);
/*	   obj_exist[i]= OBJ_EXIST; */         /* IMH001 */
    }
    else if (rc EQ ESA_SKIP)
    {
       obj_exist[i]= OBJ_NOT_EXIST;
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
            "Group %s is skipped by POST SCRIPT", ug_prm[i].group);
    }
    else
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "Group %s: POST SCRIPT returned with rc=%d.",
		   ug_prm[i].group, rc);
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt*/
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo after script");
 
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo after script");
     *WS10082K - End */
    if (apiprm->api NE FUNC_GETUGS )                      /* IS10184 */
      rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
    else                                                  /* IS10184 */
      rc_adm = ESA_OK;                                    /* IS10184 */
 
    /* IS10184 -
    if ( (rc_adm NE ESA_OK) OR ( (rc NE ESA_OK) AND (rc NE ESA_SKIP) ) )
       goto cleanup;  */
    if (rc_adm NE ESA_OK)                                 /* IS10184 */
       goto cleanup;                                      /* IS10184 */
 
    max_rc = MAX(rc, max_rc);  /* save max rc and continue.  IS10184 */
  }
 
  cleanup:
 
  rc = MAX(rc, max_rc);                                   /* IS10184 */
  if ( ( (rc EQ ESA_OK) OR (rc EQ ESA_SKIP) ) AND (rc_adm NE ESA_OK) )
     rc= rc_adm;
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_ug function */
 
 
/****************************************************
 * Procedure Name: CS_pre_post_oe
 * Description   : pre post for containers
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used in order to activate Pre/Post script
 * before/after successive call to get containers in a loop (as long
 * as there are more containers to get).
 * Although upon successive calls - with the same containers input list
 * the Pre/Post script results must be the same, The Pre/post script
 * called in order to reconstruct the addinfo (if it is changed by that
 * call).
 * The function goes over all the input containers in the list, and
 * activate the script for it.
 * There is only one reason to do that - the message returned from the
 * script - is added to the script's message buffer;
 * however, the return code returned - is the last container's call
 * returned code, and the additional buffer returned - is supposed to
 * be the same in each call.
 *********************************************************************/
 
ESA_RC CS_pre_post_oe    (SCRIPT_ACTION_typ       action,
                          short                   num_msg,
                          OE_PARAMS_rec_typ       oe_prm[1],
                          ADDINFO_rec_ptr         set_addinfo[1],
                          ADDINFO_rec_ptr         get_addinfo[1],
                          RSSAPIPRM_rec_typ     * apiprm,
                          ESA_RC                  rc_act,
                          ESA_RC                  rc_pre,
                          OBJ_EXISTS_typ          obj_exist[1])
{
  char                  fn[]="CS_pre_post_oe";
  int                   i;
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK;
  ESA_RC                max_rc = ESA_OK;                  /* IS10184 */
  /* IS10184 SCRIPT_NAME_typ       script_dir;  */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* IS10184 - removed.  Will be done by OS_CS_script
    /@
      RETRIEVE the script dir from RSSPRM file.
    @/
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  }   */
  /*
    PROCESS all in_groups for the API GET function:
  */
  /* IS10184
  for (i =0 ; (i LT num_msg) AND (rc NE ESA_FATAL)  ; i++)  */
  for (i =0 ; (i LT num_msg) ; i++)                       /* IS10184 */
  {
 
    rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
    if (rc NE ESA_OK)
      goto cleanup;
 
    rc = CS_entity_info_add  (STRUC_OE_REC ,&oe_prm[i]);
    if (rc NE ESA_OK)
      goto cleanup;
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(envir_ptr->entity_info,1);
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(envir_ptr->entity_info,
        "Entity info before script");
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo before script");
 
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo before script");
     *WS10082K - End */
 
    if (apiprm->api NE FUNC_GETOES )                      /* IS10184 */
    {                                                     /* IS10184 */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
      if (rc NE ESA_OK)
          goto cleanup;
    };                                                    /* IS10184 */
 
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
                     "    =<> Call to OS_CS_script.");
    /* IS10184
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm, */
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR,      /* IS10184 */
          action, apiprm,                                 /* IS10184 */
		        set_addinfo[i],(get_addinfo EQ NULL) ? NULL : get_addinfo[i]);
    rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                        envir_ptr->msg_admin_param.rss_type,
         /* IS10184     script_dir,   */
                        SCRIPT_DIR,                       /* IS10184 */
                        (action EQ SCRIPT_PRE) ?
                        apiprm->pre_prog
                        :
                        apiprm->post_prog,
                        apiprm->api,
                        action,
                        envir_ptr->entity_info ,
                        set_addinfo[i] ,
                        (get_addinfo EQ NULL) ?
                        NULL
                        :
                        get_addinfo[i] ,
                envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                        &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[i],0,TRUE);
 
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "POST SCRIPT returned with rc=%d for oe %s.",
		   rc, oe_prm[i].oe);
/* 	   obj_exist[i]= OBJ_EXIST;  */              /* IMH001 */
    }
    else if (rc EQ ESA_SKIP)
    {
       obj_exist[i]= OBJ_NOT_EXIST;
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
            "Oe %s is skipped by POST SCRIPT", oe_prm[i].oe);
    }
    else
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "Oe %s: POST SCRIPT returned with rc=%d.",
		   oe_prm[i].oe, rc);
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo after script");
 
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo after script");
     *WS10082K - End*/
 
    if (apiprm->api NE FUNC_GETOES )                      /* IS10184 */
      rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
    else                                                  /* IS10184 */
      rc_adm = ESA_OK;                                    /* IS10184 */
 
    /* IS10184 -
    if ( (rc_adm NE ESA_OK) OR ( (rc NE ESA_OK) AND (rc NE ESA_SKIP) ) )
       goto cleanup;   */
    if (rc_adm NE ESA_OK)                                 /* IS10184 */
       goto cleanup;                                      /* IS10184 */
 
    max_rc = MAX(rc, max_rc);  /* save max rc and continue.  IS10184 */
  }
 
  cleanup:
  rc = MAX(rc, max_rc);                                   /* IS10184 */
 
  if ( ( (rc EQ ESA_OK) OR (rc EQ ESA_SKIP) ) AND (rc_adm NE ESA_OK) )
     rc= rc_adm;
 
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_oe function */
 
/****************************************************
 * Procedure Name: CS_pre_post_u2ug
 * Description   : pre post for user TO group
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used in order to activate Pre/Post script
 * before/after successive call to get connections in a loop (as long
 * as there are more connections to get).
 * Although upon successive calls - with the same users/groups input
 * list the Pre/Post script results must be the same, The Pre/post
 * script called in order to reconstruct the addinfo (if it is changed
 * by that call).
 * The function goes over all the input groups/users in the list, and
 * activate the script for it. There is only one reason to do that -
 * the message returned from the script - is added to the script's
 * message buffer; however, the return code returned - is the last call
 * returned code, and the additional buffer returned - is supposed to
 * be the same in each call.
 *********************************************************************/
 
ESA_RC CS_pre_post_u2ug (SCRIPT_ACTION_typ       action,
                            short                   num_msg,
                            U2UG_PARAMS_rec_typ     u2ug_prm[1],
                            ADDINFO_rec_ptr         set_addinfo[1],
                            ADDINFO_rec_ptr         get_addinfo[1],
                            RSSAPIPRM_rec_typ     * apiprm,
                            ESA_RC                  rc_act,
                            ESA_RC                  rc_pre,
                            OBJ_EXISTS_typ          obj_exist[1])
{
  char                  fn[]="CS_pre_post_u2ug";
  int                   i;
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK;
  ESA_RC                max_rc = ESA_OK;                  /* IS10184 */
  /* IS10184 SCRIPT_NAME_typ       script_dir;  */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* IS10184 - removed.  Will be done by OS_CS_script
    /@
      RETRIEVE the script dir from RSSPRM file.
    @/
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  }  */
  /*
    PROCESS all in_pairs for the API GET function:
  */
  /* IS10184
  for (i =0 ; (i LT num_msg) AND (rc NE ESA_FATAL)  ; i++) */
  for (i =0 ; (i LT num_msg) ; i++)                       /* IS10184 */
  {
 
    rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
    if (rc NE ESA_OK)
      goto cleanup;
 
    rc = CS_entity_info_add  (STRUC_U2UG_REC ,&u2ug_prm[i]);
    if (rc NE ESA_OK)
      goto cleanup;
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(envir_ptr->entity_info,1);
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(envir_ptr->entity_info,
        "Entity info before script");
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo before script");
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo before script");
     *WS10082K - End*/
 
    if (apiprm->api NE FUNC_GTUG2UC)                      /* IS10184 */
    {                                                     /* IS10184 */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
      if (rc NE ESA_OK)
          goto cleanup;
    };                                                    /* IS10184 */
 
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
                   "    =<> Call to OS_CS_script.");
    /* IS10184
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm, */
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR,      /* IS10184 */
       action, apiprm,                                    /* IS10184 */
		     set_addinfo[i],(get_addinfo EQ NULL) ? NULL : get_addinfo[i]);
    rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                        envir_ptr->msg_admin_param.rss_type,
           /* IS10184   script_dir,   */
                        SCRIPT_DIR,                       /* IS10184 */
                        (action EQ SCRIPT_PRE) ?
                        apiprm->pre_prog
                        :
                        apiprm->post_prog,
                        apiprm->api,
                        action,
                        envir_ptr->entity_info ,
                        set_addinfo[i] ,
                        (get_addinfo EQ NULL) ?
                        NULL
                        :
                        get_addinfo[i] ,
                 envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                        &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[i],0,TRUE);
 
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
       "POST SCRIPT returned with rc=%d for conn.user %s to group %s.",
		   rc, u2ug_prm[i].user, u2ug_prm[i].group);
/*	   obj_exist[i]= OBJ_EXIST;  */       /* IMH001 */
    }
    else if (rc EQ ESA_SKIP)
    {
       obj_exist[i]= OBJ_NOT_EXIST;
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
            "Connection User %s to group is skipped by POST SCRIPT",
			u2ug_prm[i].user, u2ug_prm[i].group);
    }
    else
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
       "Conn. User %s to group %s: POST SCRIPT returned with rc=%d.",
		   u2ug_prm[i].user, u2ug_prm[i].group, rc);
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo after script");
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo after script");
     *WS10082K - End*/
 
    if (apiprm->api NE FUNC_GTUG2UC)                      /* IS10184 */
      rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
    else                                                  /* IS10184 */
      rc_adm = ESA_OK;                                    /* IS10184 */
 
    /* IS10184
    if ( (rc_adm NE ESA_OK) OR ( (rc NE ESA_OK) AND (rc NE ESA_SKIP) ) )
       goto cleanup;    */                                /* IS10184 */
    if (rc_adm NE ESA_OK)                                 /* IS10184 */
       goto cleanup;                                      /* IS10184 */
 
    max_rc = MAX(rc, max_rc);  /* save max rc and continue.  IS10184 */
  }
  cleanup:
  rc = MAX(rc, max_rc);                                   /* IS10184 */
  if ( ( (rc EQ ESA_OK) OR (rc EQ ESA_SKIP) ) AND (rc_adm NE ESA_OK) )
     rc= rc_adm;
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_u2ug function */
 
/****************************************************
 * Procedure Name: CS_pre_post_res
 * Description   : pre post for resource
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used in order to activate Pre/Post script
 * before/after successive call to get resources in a loop (as long
 * as there are more resources to get).
 * The function is activated to perform PRE SCRIPT - ONCE PER INPUT
 * RESOURCE REQUEST - with number of messages (num_msg parameter
 * ALWAYS equal to 1. The POST SCRIPT IS ACTIVATED with the list of
 * retrieved resources for each successive call of GET RESOURCE API.
 * The function goes over all the input resources in the list, and
 * activate the script for it. There is only one reason to do that -
 * the message returned from the script - is added to the script's
 * message buffer; however, the return code returned - is the last call
 * returned code, and the additional buffer returned - is supposed to
 * be the same in each call.
 *********************************************************************/
 
ESA_RC CS_pre_post_res     (SCRIPT_ACTION_typ       action,
                            short                   num_msg,
                            RES_PARAMS_rec_typ      res_prm[1],
                            ADDINFO_rec_ptr         set_addinfo[1],
                            ADDINFO_rec_ptr         get_addinfo[1],
                            ADDINFO_rec_typ       * addinfo_res,
                            RSSAPIPRM_rec_typ     * apiprm,
                            ESA_RC                  rc_act,
                            ESA_RC                  rc_pre,
                            OBJ_EXISTS_typ          obj_exist[1])
{
  char                 fn[]="CS_pre_post_res";
  int                   i;
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK;
  ESA_RC                max_rc = ESA_OK;                  /* IS10184 */
  /* IS10184 SCRIPT_NAME_typ       script_dir;   */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* IS10184 - removed.  Will be done by OS_CS_script
    /@
      RETRIEVE the script dir from RSSPRM file.
    @/
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  } */
  /*
    PROCESS all in_pairs from the API GET function:
  */
  /* IS10184
  for (i =0 ; (i LT num_msg) AND (rc NE ESA_FATAL)  ; i++)  */
  for (i =0 ; (i LT num_msg) ; i++)                       /* IS10184 */
  {
     /*
      BUILD environment entity additional info
    */
    rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
    if (rc NE ESA_OK)
      goto cleanup;
 
    rc = CS_entity_info_add  (STRUC_RES_REC ,&res_prm[i]);
    if (rc NE ESA_OK)
      goto cleanup;
    rc = CS_entity_info_add  (STRUC_RES_ADDINFO ,addinfo_res);
    if (rc NE ESA_OK)
      goto cleanup;
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(envir_ptr->entity_info,1);
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(envir_ptr->entity_info,
        "Entity info before script");
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo before script");
 
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo before script");
     *WS10082K - End*/
 
    if (apiprm->api NE FUNC_GETRES )                      /* IS10184 */
    {                                                     /* IS10184 */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
      if (rc NE ESA_OK)
          goto cleanup;
    };                                                    /* IS10184 */
 
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
                    "    =<> Call to OS_CS_script.");
    /* IS10184
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm, */
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR, /* IS10184 */
       action, apiprm,                               /* IS10184 */
		     set_addinfo[i],(get_addinfo EQ NULL) ? NULL : get_addinfo[i]);
    rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                        envir_ptr->msg_admin_param.rss_type,
           /* IS10184   script_dir, */
                        SCRIPT_DIR,                       /* IS10184 */
                        (action EQ SCRIPT_PRE) ?
                        apiprm->pre_prog : apiprm->post_prog,
                        apiprm->api,
                        action,
                        envir_ptr->entity_info ,
                        set_addinfo[i] ,
                        (get_addinfo EQ NULL) ?
                        NULL : get_addinfo[i] ,
			     envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                        &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[i],0,TRUE);
 
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "POST SCRIPT returned with rc=%d for resource %s(%s).",
		   rc, res_prm[i].resource, res_prm[i].restype);
/*	   obj_exist[i]= OBJ_EXIST;  */      /* IMH001 */
    }
    else if (rc EQ ESA_SKIP)
    {
       obj_exist[i]= OBJ_NOT_EXIST;
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
            "Resource %s is skipped by POST SCRIPT",
			res_prm[i].resource, res_prm[i].restype);
    }
    else
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "Resource %s: POST SCRIPT returned with rc=%d.",
		   res_prm[i].resource, res_prm[i].restype, rc);
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo after script");
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo after script");
     *WS10082K - End */
 
    if (apiprm->api NE FUNC_GETRES )                      /* IS10184 */
      rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
    else                                                  /* IS10184 */
      rc_adm = ESA_OK;                                    /* IS10184 */
 
    /* IS10184
    if ( (rc_adm NE ESA_OK) OR ( (rc NE ESA_OK) AND (rc NE ESA_SKIP) ) )
       goto cleanup;     */
    if (rc_adm NE ESA_OK)                                 /* IS10184 */
       goto cleanup;                                      /* IS10184 */
 
    max_rc = MAX(rc, max_rc);  /* save max rc and continue.  IS10184 */
  } /* END - FOR loop */
 
  cleanup:
  rc = MAX(rc, max_rc);                                   /* IS10184 */
  if ( ( (rc EQ ESA_OK) OR (rc EQ ESA_SKIP) ) AND (rc_adm NE ESA_OK) )
     rc= rc_adm;
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_res function */
 
/****************************************************
 * Procedure Name: CS_pre_post_ace
 * Description   : pre post for ace
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is used in order to activate Pre/Post script
 * before/after successive call to get resource ACL in a loop (as long
 * as there are more ACEs to get).
 * The function is activated to perform PRE SCRIPT - ONCE PER INPUT
 * RESOURCE ACL REQUEST - with number of messages (num_msg parameter
 * ALWAYS equal to 1. The POST SCRIPT IS ACTIVATED with the list of
 * retrieved resource ACEs for each successive call of GET ACL API.
 * The function goes over all the input ACEs in the list, and
 * activate the script for it. There is only one reason to do that -
 * the message returned from the script - is added to the script's
 * message buffer; however, the return code returned - is the last call
 * returned code, and the additional buffer returned - is supposed to
 * be the same in each call.
 *********************************************************************/
 
ESA_RC CS_pre_post_ace     (SCRIPT_ACTION_typ       action,
                            short                   num_msg,
                            short                   func_name,
                            RES_PARAMS_rec_typ    * res_prm,
                            ACE_rec_typ             ace_prm[1],
                            ADDINFO_rec_ptr         set_addinfo[1],
                            ADDINFO_rec_ptr         get_addinfo[1],
                            ADDINFO_rec_typ       * addinfo_res,
                            ACE_POS_typ           * ace_place,
                            RSSAPIPRM_rec_typ     * apiprm,
                            ESA_RC                  rc_act,
                            ESA_RC                  rc_pre,
                            OBJ_EXISTS_typ          obj_exist[1])
{
  char                  fn[]="CS_pre_post_ace";
  int                   i;
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK;
  ESA_RC                max_rc = ESA_OK;                  /* IS10184 */
  /* IS10184 SCRIPT_NAME_typ       script_dir;   */
  ENVIRONMENT_rec_typ * envir_ptr;
  char AceName          [sizeof(ACE_USER_typ)+ \
	                     sizeof(ACE_UG_typ)+ sizeof(ACE_OE_typ)]="";
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  /* IS10184 - removed.  Will be done by OS_CS_script
    /@
      RETRIEVE the script dir from RSSPRM file.
    @/
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  }  */
  /*
    PROCESS all in_pairs from the API GET function:
  */
  /* IS10184
  for (i =0 ; (i LT num_msg) AND (rc NE ESA_FATAL)  ; i++)  */
  for (i =0 ; (i LT num_msg) ; i++)                       /* IS10184 */
  {
 
    rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
    if (rc NE ESA_OK)
      goto cleanup;
 
    rc = CS_entity_info_add  (STRUC_RES_REC ,res_prm);
    if (rc NE ESA_OK)
      goto cleanup;
    rc = CS_entity_info_add  (STRUC_RES_ADDINFO ,addinfo_res);
    if (rc NE ESA_OK)
       goto cleanup;
    rc = CS_entity_info_add  (STRUC_ACE_REC ,&ace_prm[i]);
    if (rc NE ESA_OK)
      goto cleanup;
    if (func_name EQ FUNC_ADDACE)
    {
       rc= CS_entity_info_add (STRUC_ACE_PLACE_TYP, ace_place);
       if (rc NE ESA_OK)
          goto cleanup;
    }
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(envir_ptr->entity_info,1);
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(envir_ptr->entity_info,
        "Entity info before script");
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo before script");
 
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo before script");
     *WS10082K - End */
 
    if (apiprm->api NE FUNC_GTRSACL)                      /* IS10184 */
    {                                                     /* IS10184 */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
      if (rc NE ESA_OK)
          goto cleanup;
    };                                                    /* IS10184 */
 
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
                 "    =<> Call to OS_CS_script.");
    /* IS10184
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm, */
    CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR,      /* IS10184 */
         action, apiprm,                                  /* IS10184 */
		       set_addinfo[i],(get_addinfo EQ NULL) ? NULL : get_addinfo[i]);
    rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                        envir_ptr->msg_admin_param.rss_type,
            /* IS10184  script_dir,  */
                        SCRIPT_DIR,                       /* IS10184 */
                        (action EQ SCRIPT_PRE) ?
                         apiprm->pre_prog : apiprm->post_prog,
                        apiprm->api,
                        action,
                        envir_ptr->entity_info ,
                        set_addinfo[i] ,
                        (get_addinfo EQ NULL) ?
                         NULL : get_addinfo[i] ,
			     envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                        &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[i],0,TRUE);
 
    sprintf (AceName, "%s %s %s",
             ace_prm[i].user_name, ace_prm[i].ug_name, ace_prm[i].ug_name);
    if (rc EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "POST SCRIPT returned with rc=%d for ace %s of res. %s(%s).",
		   rc, AceName, res_prm->resource, res_prm->restype);
/* 	   obj_exist[i]= OBJ_EXIST;  */         /* IMH001 */
    }
    else if (rc EQ ESA_SKIP)
    {
       obj_exist[i]= OBJ_NOT_EXIST;
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
            "Ace %s of Resource %s is skipped by POST SCRIPT",
			AceName, res_prm->resource, res_prm->restype);
    }
    else
       ESA_DIAG_printf (ESA_COMP_ACSGETF, 15,
           "Ace %s of Resource %s: POST SCRIPT returned with rc=%d.",
		   AceName, res_prm->resource, res_prm->restype, rc);
 
    /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
    {
      ADDINFO_dump(set_addinfo[i],1);
      if (get_addinfo NE NULL)
        ADDINFO_dump(get_addinfo[i],1);
    }
    /*
    CS_addinfo_prt(set_addinfo[i], "Set Addinfo after script");
    if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[i], "Get Addinfo after script");
       *WS10082K - End */
 
    if (apiprm->api NE FUNC_GTRSACL)                      /* IS10184 */
      rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
    else                                                  /* IS10184 */
      rc_adm = ESA_OK;                                    /* IS10184 */
    /* IS10184
    if ( (rc_adm NE ESA_OK) OR ( (rc NE ESA_OK) AND (rc NE ESA_SKIP) ) )
       goto cleanup;  */
    if (rc_adm NE ESA_OK)                                 /* IS10184 */
       goto cleanup;                                      /* IS10184 */
 
    max_rc = MAX(rc, max_rc);  /* save max rc and continue.  IS10184 */
  }
 
  cleanup:
  rc = MAX(rc, max_rc);                                   /* IS10184 */
  if ( ( (rc EQ ESA_OK) OR (rc EQ ESA_SKIP) ) AND (rc_adm NE ESA_OK) )
     rc= rc_adm;
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_acl function */
 
/****************************************************
 * Procedure Name: CS_remove_not_interes_conn
 * Description   : Remove conections that are not interesting for ESS
 *
 * Input/Output  : Addinfo , Obj-exists and U2uG_params structures
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
void CS_remove_not_interes_conn (short               *actual_num      ,
                                 GET_CONN_MODE        mode            ,
                                 U2UG_PARAMS_rec_typ  u2ug_prm_out [1],
                                 ADDINFO_rec_ptr      addinfo      [1],
                                 OBJ_EXISTS_typ       obj_exists   [1])
{
  char fn[]="CS_remove_not_interes_conn";
  int                 i = 0, j = 0;
  ESS_INTRST_typ      ess_cares= ESS_DONT_CARE;
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf(ESA_COMP_ACSGETF, 15                          ,
                  "IN actual_num %d mode %d.",
                  *actual_num                ,
                  (int)mode                  );
 
  for (i= 0, j = 0     ;
       i LT *actual_num;
       i++             )
  {
 
     /*
       CHECK if current group in list of interest groups for ESS
       */
     if (mode EQ GET_GROUPS_CONNS)
        ess_cares= ESS_GROUP_CARE;
     else
     {
         CARE_int_ug_find (u2ug_prm_out[i].group,
                           M_DWNLD_NAME_REGULAR ,
                           &ess_cares           );
         ESA_DIAG_printf(ESA_COMP_ACSGETF ,15 ,
                  "%d: Group=%s Interesting=%d.",
                  i,
                  u2ug_prm_out[i].group,
                  (int)ess_cares       );
     }
     /*
        If NOT -> skip this group
       */
     if (ess_cares EQ ESS_DONT_CARE)
     {
        ESA_DIAG_printf(ESA_COMP_ACSGETF, 15                    ,
                        "group %s SKIPED"    ,
                        u2ug_prm_out[i].group);
        continue;
     }
     /*
       CHECK if current user in list of interest groups for ESS
       */
     if (mode EQ GET_USERS_CONNS)
        ess_cares= ESS_USER_CARE;
     else
     {
        CARE_int_usr_find (u2ug_prm_out[i].user     ,
                           u2ug_prm_out[i].def_group,
                           M_DWNLD_NAME_REGULAR     ,
                           &ess_cares               );
         ESA_DIAG_printf(ESA_COMP_ACSGETF,15 ,
                  "%d: User=%s Def Group=%s Interesting=%d.",
                  i,
                  u2ug_prm_out[i].user,
                  u2ug_prm_out[i].def_group,
                  (int)ess_cares       );
     }
     /*
       IGNORE none interesting users.
       */
     if (ess_cares EQ ESS_DONT_CARE)
     {
        ESA_DIAG_printf(ESA_COMP_ACSGETF    ,15 ,
                        "User %s SKIPED"    ,
                        u2ug_prm_out[i].user);
        continue;
     }
 
     if (i GT j)
     {
        memcpy ((char *)(&u2ug_prm_out[j])  ,
                (char *)(&u2ug_prm_out[i])  ,
                sizeof (U2UG_PARAMS_rec_typ));
        memcpy ((char *)(&obj_exists[j]),
                (char *)(&obj_exists[i]),
                sizeof (OBJ_EXISTS_typ));
        memcpy ((char *)(&addinfo[j]->pair[0])                   ,
                (char *)(&addinfo[i]->pair[0])                   ,
                sizeof (ONE_FIELD_rec_typ)* addinfo[i]->num_pairs);
        addinfo[j]->num_pairs = addinfo[i]->num_pairs;
        addinfo[j]->max_pairs = addinfo[i]->max_pairs;
     }
     ESA_DIAG_printf(ESA_COMP_ACSGETF , 15,
        "%d(%d): Connection group %s to user %s is interesting",
                     j+1                                       ,
                     i+1                                       ,
                     u2ug_prm_out[j].group                     ,
                     u2ug_prm_out[j].user                      );
 
     j++;
  }
 
  *actual_num = j;
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON , fn ,ESA_OK);
}
 
 
/****************************************************
 * Procedure Name: CS_pre_post_rssprm
 * Description   : pre post for rss params
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_pre_post_rssprm(SCRIPT_ACTION_typ       action,
                          RSS_PARAMS_rec_typ    * rss_prm,
                          ADDINFO_rec_ptr         set_addinfo[1],
                          ADDINFO_rec_ptr         get_addinfo[1],
                          RSSAPIPRM_rec_typ     * apiprm,
                          ESA_RC                  rc_act,
                          ESA_RC                  rc_pre)
{
  char                  fn[]="CS_pre_post_rssprm";
  ESA_RC                rc= ESA_OK, rc_adm= ESA_OK;
  /* IS10184 SCRIPT_NAME_typ       script_dir;   */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  rc= CS_pre_post_common(action, apiprm->api, rc_pre, rc_act);
  if (rc NE ESA_OK)
      goto cleanup;
 
  rc = CS_entity_info_add  (STRUC_PRM_REC ,rss_prm);
  if (rc NE ESA_OK)
      goto cleanup;
  /* IS10184 - removed.  Will be done by OS_CS_script
    /@
      RETRIEVE the script dir from RSSPRM file.
    @/
  rc = rssprm_get_opt (envir_ptr->msg_admin_param.rss_name, SCRIPT_DIR,
            SCRIPT_NAME_LEN, (char *) script_dir, OPT_TRUE, OPT_FALSE);
  if (rc NE ESA_OK)
  {
     script_dir[0] = '\0';
     rc = ESA_OK;
  }  */
 
  /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
  {
    ADDINFO_dump(envir_ptr->entity_info,1);
    ADDINFO_dump(set_addinfo[0],1);
    if (get_addinfo NE NULL)
      ADDINFO_dump(get_addinfo[0],1);
  }
  /*
  CS_addinfo_prt(envir_ptr->entity_info, "Entity info before script");
  CS_addinfo_prt(set_addinfo[0], "Set Addinfo before script");
  if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[0], "Get Addinfo before script");
  *WS10082K - End */
 
  if (apiprm->api NE FUNC_GTRSPRM)                      /* IS10184 */
  {                                                       /* IS10184 */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
    if (rc NE ESA_OK)
        goto cleanup;
  };                                                      /* IS10184 */
 
  ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
             "    =<> Call to OS_CS_script.");
  /* IS10184
  CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, script_dir, action, apiprm, */
  CS_DIAG_SCRIPT_IN (ESA_COMP_ACSGETF, SCRIPT_DIR,        /* IS10184 */
       action, apiprm,                                    /* IS10184 */
	      set_addinfo[0],(get_addinfo EQ NULL) ? NULL : get_addinfo[0]);
  rc =  OS_CS_script (envir_ptr->msg_admin_param.rss_name,
                      envir_ptr->msg_admin_param.rss_type,
         /* IS10184   script_dir,   */
                      SCRIPT_DIR,                         /* IS10184 */
                      (action EQ SCRIPT_PRE) ?
                      apiprm->pre_prog
                      :
                      apiprm->post_prog,
                      apiprm->api,
                      action,
                      envir_ptr->entity_info ,
                      set_addinfo[0] ,
                      (get_addinfo EQ NULL) ?
                      NULL
                      :
                      get_addinfo[0] ,
			     envir_ptr->interest[envir_ptr->rss_num].RssPrmAddInfo,
                      &envir_ptr->msg_admin_param);
    ESA_DIAG_printf (ESA_COMP_ACSGETF, DIAG_BASIC,
		"    <>= OS_CS_script completed with rc=%d (%s).",
		rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
    CS_DIAG_ADDINFO(ESA_COMP_ACSGETF,set_addinfo[0],0,TRUE);
 
  /*WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt */
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13)
  {
    ADDINFO_dump(set_addinfo[0],1);
    if (get_addinfo NE NULL)
      ADDINFO_dump(get_addinfo[0],1);
  }
  /*
  CS_addinfo_prt(set_addinfo[0], "Set Addinfo after script");
  if (get_addinfo NE NULL)
       CS_addinfo_prt(get_addinfo[0], "Get Addinfo after script");
  *WS10082K - End */
 
  if (apiprm->api NE FUNC_GTRSPRM)                      /* IS10184 */
    rc_adm= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
  else                                                  /* IS10184 */
    rc_adm = ESA_OK;                                    /* IS10184 */
 
  if (rc_adm NE ESA_OK)
      goto cleanup;
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_adm;
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_rssprm function */
 
/****************************************************
 * Procedure Name: CS_pre_post_common
 * Description   : pre post common for all api functions
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 *********************************************************************/
 
ESA_RC CS_pre_post_common(SCRIPT_ACTION_typ       action,
                          short                   api,
                          ESA_RC                  rc_pre,
                          ESA_RC                  rc_act)
{
  char                  fn[]="CS_pre_post_common";
  short                 func_name;
  short                 script_action;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSGETF, DIAG_COMMON, fn);
 
  func_name = api;
  script_action= action;
 
  CS_entity_info_init ();
  rc = CS_entity_info_add  (STRUC_ACT_REC ,&script_action);
  if (rc NE ESA_OK)
      goto cleanup;
  rc = CS_entity_info_add  (STRUC_FUNC_REC ,&func_name);
  if (rc NE ESA_OK)
      goto cleanup;
  rc = CS_entity_info_add  (STRUC_RSS_REC ,
      &envir_ptr->msg_admin_param);
  if (rc NE ESA_OK)
      goto cleanup;
  rc = CS_entity_info_add  (STRUC_ADMIN_REC ,
      &envir_ptr->msg_admin_param);
  if (rc NE ESA_OK)
      goto cleanup;
  if (action EQ SCRIPT_POST)
  {
     rc = CS_entity_info_add  (STRUC_RC_REC ,&rc_act);
     if (rc NE ESA_OK)
        goto cleanup;
     rc = CS_entity_info_add  (STRUC_PRE_REC ,&rc_pre);
     if (rc NE ESA_OK)
        goto cleanup;
  }
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSGETF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CS_pre_post_common function */
 
