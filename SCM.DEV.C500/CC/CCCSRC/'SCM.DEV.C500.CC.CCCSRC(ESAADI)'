/*
 * Version Information:
 * ====================
 * File name       : %name: esaadi.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: ihoffma %
 * Created on      : %date_created: Tue Oct 07 17:31:20 2003 %
 * Current Version : %version: 2 %
 * Last Modified by: %derived_by: ihoffma %
 * Last Modified on: %date_modified: Tue Oct 07 17:31:20 2003 %
 */
 
/***********************************************************
 * Mod.ID   Who      When         Description
 * =========================================================
 * IMH001   Ian H.   07-10-2003   Win: Get GLOBAL.dll version
 * SAS2IBMA AvnerL   21-Dec-16    SAS/C to IBM C Conversion Project
 * WS10075  NuritY   16-Dec-19    ADDINFO_delete - copy type
 * IS10183  ThomaS   04/05/21 Don't print PASSWORD and PWPHRASE
 *                            in clear. Print '*****' instead
 ***********************************************************
 *   CHNAGE IDs copied from CTSCADI
 * AS0903   A.Shv    09/03/95 Added new function :
 *                            ADDINFO_clear_value
 *
 * spr125   Alex     07/09/95 Change duplicate quates logic
 *
 * AS0207   Alex     02/07/96 ADDINFO_insert. addinfo overflow
 *                            rc = ESA_FATAL instead ESA_ERR
 * ps0009   Alex     10/10/96 New list's fields separator
 *                            See ADDINFO_addval, _list_search
 *                            _list_diff and ALL calls to this
 *                            functions
 * ps0106   Alex     18/06/97 Add new functions :
 *                            ADDINFO_masupd
 *                            ADDINFO_copy_by_prefix
 * ps0145   Yishay   09/07/97 Add new functions :
 *                            ADDINFO_expand_from_buffer
 *                            ADDINFO_pack_to_buffer
 * ps0288   Alex     09/07/98 Add parameter to :
 *                            ADDINFO_dup_check
 *                            ADDINFO_prefix_search
 * ps0292   AS       24/07/98 Digital certificate support
 * PS0349   Guy      06/12/98 Add quotes for each multivalued
 *                            field value
 * PS0352   Guy      08/12/98 Handle NULL values correctly
 * PS0537   ShmuelK  06/10/02 Change name of pointer variable
 * IS0208   AmirH    30/12/03 Add ADDINFO_value_addval function
 * IS0212   AmirH    06/01/04 Do not add separator to emtpy
 *                            value string
 * IS10094  NuritY   11/06/13 BS10032 changes:
 *                            1. Incorrect length check whe
 *                               update value.
 *                            2. Entries have incorrect type
 *                               after deleting an entry,
 *                               because the type field is not
 *                               copied when compressing the
 *                               list.
 * IS10100  NuritY   29/07/13 Support CTSA internal custom
 *                            fields (CTSACFs).
 * IS10100A NuritY   14/10/13 Add ADDINFO_Split_by_Prefix
 *                            to support RACF command
 *                            limitations.
 * SAS2IBMT SeligT   11/05/17 SAS/C to IBM C Conversion Project
 * IS10181  SeligT   03/06/19 Display Message When ADDINFO
 *                            Value Is Too Large
 * WS10078S SeligT   30/04/20 Support roles, X(ROL), & X(SGP)
 * IS10183  ThomaS   04/05/21 Don't print PASSWORD and PWPHRASE
 *                            in clear. Print '*****' instead
 * WS10081  ThomaS   04/05/21 Don't print PASSWORD and PWPHRASE
 ***********************************************************
 * WS10082  MauriC   29/09/22 Merge ADDINFO CC & SPI routine
 * WS10082K KailasP  28/10/22     Update Addinfo routines
 * WS10082N NuritY   02/10/23     Update Addinfo routines
 * BS10146  NuritY   23/01/25 abend s0c4 when mfa first in addinfo
 ***********************************************************/
 
#include   "globs.h"
 
/*
 *   Standard include files
 */
 
 
#include   STDIO
#include   STDLIB
#include   STRING
#include   CTYPE
 
#include   MEMORY
#include   <ceeedcct.h>                                   /* WS10082N */
#include   <leawi.h>                                      /* WS10082N */
 
/*
 *   ESA include files
 */
#include   ESA_DIAG
#include   ESA_API
#include   ESA_CTSAMSG
#include   ESA_API_CODES
 
#include   ESA_ESAADI
 
/*  WS10082 - start */
 
static ESA_RC ADDINFO_concat_one
                           (char                     *p_func,
                           char                      *p_cmd,
                           ADDINFO_PKB_rec_ptr        pkb_vec,
                           ADDINFO_rec_ptr            p_addinfo,
                           ADDINFO_KDTE_rec_ptr       p_kdt,
                           CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                           CTSAMSG_HANDLE_rec_ptr     p_msgs);
 
static ESA_RC ADDINFO_alloc_twin_pair(ONE_FIELD_rec_ptr  pair);
 
static ESA_RC ADDINFO_free_twin_pair(ONE_FIELD_rec_ptr  pair,
                                     int        ignore_nolong);
 
/*  WS10082 - end   */
 
static char component[] = "ESAADI";
 
/* WS10082 start */
/* WS10082 following 2 defines are taken from CTSCADI CSRC */
#define    ADDINFO_MAX_PKB     50    /* maximum PKB's    */
/* WS10082N - start */
/*  #define    ADDINFO_MAX_PKB_LEN 2049 /@ size of each PKB @/   */
#define    MAX_CMD_LEN         MAX_API_ST   /* command buffer length */
#define    ADDINFO_MAX_PKB_LEN MAX_CMD_LEN  /* size of each PKB     */
 
#define    SEE_PRTDBG_MSG    "See PRTDBG for more details."
 
/* Macro to print the error message when data for the command     *
 * is too long.                                                   *
 *                                                                *
 *  _buf - Message buffer. Should be an array else                *
 *         sizeof(_buf) wont give correct results.                *
 *  _pair - pair.                                                 *
 *  _typ  - the variable into which we canot move.                *
 *  _m    - msgs                                                  *
 *  _d    - dest                                                  *
 *                                                                */
#define    SEND_CMD_TOO_LONG_MSG(_buf, _kw, _ln, _typ, _m, _d, _rc)  \
      snprintf(_buf, sizeof(_buf),                                   \
               "Cannot add <%s> to the command. (len=%d, addto=%s).",\
               _kw, _ln, _typ);                                      \
      strncat(_buf, SEE_PRTDBG_MSG,                                  \
                      sizeof(_buf) - strlen(_buf));                  \
      CTSAMSG_print(ERR_ADI_PROC_ERROR,                              \
                  _m, NULL, _d,                                      \
                  _buf, func);                                       \
      _rc = ESA_FATAL;
/* WS10082N - end   */
 
/* WS10082 regular functions */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_search                             *
*                                                             *
* DESCRIPTION    : Search a keyword in additional info        *
*                                                             *
* INPUT          : kwd              -  keyword                *
*                  pair             -  entry to start search  *
*                  limit            -  max entries to search  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if not found)   *
* WS10082K         The function returns real add info pair.   *
*                                                             *
**************************************************************/
ONE_FIELD_rec_ptr ADDINFO_search (char              *kwd,
                                  int               max_kwdlen,
                                  ONE_FIELD_rec_ptr p_pair,
                                  short             p_limit)
{
 
  /*
   *  Variables
   */
 
   short i = 0;
   int kwdlen = 0;
   /* WS10082N ONE_FIELD_rec_ptr cpair;       */
   ONE_FIELD_rec_ptr cpair = NULL;                       /* S10082N */
   /* ps0537
   ONE_FIELD_rec_ptr rc = NULL; */
   ONE_FIELD_rec_ptr xptr = NULL; /*ps0537*/
   static char func[]="ADDINFO_search";
 
  /*
   *  initialize
   */
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
   if (p_pair EQ NULL)        /* WS10082K */
      goto exit;              /* WS10082K */
 
   if (kwd EQ NULL)
      goto exit ;
   kwdlen = strlen(kwd) ;
   if ( (kwdlen GT max_kwdlen ) OR (kwdlen EQ 0) )
      goto exit ;
 
   /*  WS10082K - Start
   /*  Lets get original pair instead of real */
   /*  pair as we compare keyword name        */
 
   /*  cpair = p_pair;                       */
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                  "Searching attribute %s", kwd);
 
   cpair = get_orig_pair(p_pair);
   /* WS10082K - End   */
 
  /*
   *  Loop on Pairs
   */
   for (i=0; i LT p_limit; i++) {
      if (strcmp(cpair->keyword,kwd) EQ 0) {
        /*rc = cpair;   ps0537*/
        /* WS10082K xptr = cpair; /@ps0537@/ */
        xptr = get_pair(cpair);    /* return real pair.  WS10082K */
        break;
      }
      cpair++;
   } /* while */
 
  /*
   *    Finish
   */
   exit:;
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
     /*ps0537      "Exiting with rc=%X", rc);*/
                   "Exiting with result=%p", xptr);  /*ps0537*/
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 3, func, ESA_OK);
 
/* return rc; ps0537*/
   return xptr; /*ps0537*/
 
} /* ADDINFO_search */
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert                             *
*                                                             *
* DESCRIPTION    : Insert a keyword in additional info        *
*                                                             *
* INPUT          : type             -  addinfo type           *
*                  kwd              -  keyword                *
*                  value            -  value                  *
*                  addinfo          -  additional info        *
*                  dupflag          -  allow duplicate flag   *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
 
ESA_RC ADDINFO_insert  (ADDINFO_typ        type,
                        char               *kwd,
                        char               *val,
                        ADDINFO_rec_ptr    addinfo,
                        int                max_kwdlen,
                        int                max_vallen,
                        ADDINFO_DUPLICATE  dupflag)
 {
 
   /*
    *  Variables
    */
 
    static char func[] = "ADDINFO_insert";
    int i=0;           /*WS10082K*/
    int kwdlen, vallen;
    ONE_FIELD_rec_ptr cpair;
    char        msgbuf[256] = "";                         /* WS10082N */
    ESA_RC rc = ESA_OK ;
 
   /*
    *  initialize
    */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 2, func);
    /*WS10082K - Start */
    if (addinfo EQ NULL) {
       /* WS10082N - start */
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  "no addinfo", func);
       /* WS10082N - end   */
       rc = ESA_FATAL;
       goto exit;
    }
    /*WS10082K - End*/
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,13,
                    "num_pairs = %d, max_pairs = %d",
                    addinfo->num_pairs,addinfo->max_pairs);
 
    if (addinfo->num_pairs GE addinfo->max_pairs) {
       /* WS10082N - start */
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  "Cannot insert because addinfo is full", func);
       /* WS10082N - end   */
       /* rc = ESA_ERR; - deleted  AS0207 */
       rc = ESA_FATAL; /* added    AS0207 */
       goto exit;
    }
 
   /*
    *  Validity checks
    */
 
    kwdlen =strlen(kwd);
    if ((kwdlen EQ 0) OR (kwdlen GT max_kwdlen)) {
       /* WS10082N - start */
       snprintf(msgbuf, sizeof(msgbuf),
               "Cannot insert - no keyword or keyword too long (%d)",
                kwdlen);
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
       /* WS10082N - end   */
       rc = ESA_FATAL;
       goto exit;
    }
 
    vallen = strlen(val);
    /* IS10181 skip the next few instructions - we will
               deal with this in ADDINFO_updval below
    if (vallen GT max_vallen) {
       rc = ESA_FATAL;
       goto exit;
    }                                                               */
 
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
                     "Keyword=(%d/%d) '%s' Value=(%d/%d) '%.100s'",
                     kwdlen, max_kwdlen, kwd, vallen, max_vallen, val);
   /*WS10082K*       "Keyword=(%d/%d) '%s' Value=(%d/%d) '%s'",    */
 
   /*
    *  Verify that keyword is not yet used
    */
 
    if (dupflag EQ UNIQUE)                                /* WS10082N */
    {                                                     /* Ws10082N */
      cpair = addinfo->pair;
      while (i LT addinfo->num_pairs) {
 
         ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
         /*WS10082K*/  "Entry %d,%p-%p: kwd=(%3d)%s,val=(%3d)%.100s",
                       i, cpair, cpair->twin,               /*WS10082K*/
                       cpair->keylen, cpair->keyword,       /*WS10082K*/
                       cpair->vallen, cpair->value);        /*WS10082K*/
            /*WS10082K "Entry %d,%p: kwd=%s(%3d),val=%s(%3d)", */
            /*WS10082K i, cpair,                               */
            /*WS10082K cpair->keyword, cpair->keylen,          */
            /*WS10082K cpair->value, cpair->vallen);           */
 
         /* WS10082N moved this command up
         if (dupflag EQ UNIQUE)                                  */
 
         if (strcmp(cpair->keyword,kwd) EQ 0) {
             /* WS10082N - start */
             /* rc = ESA_ERR;                                */
             snprintf(msgbuf, sizeof(msgbuf),
            "Cannot insert - UNIQUE requested but <%s> already exists",
               kwd);
             CTSAMSG_print(ERR_ADI_PROC_ERROR,
                     NULL, NULL,
                     ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                     msgbuf, func);
             rc = ESA_DUP_KEY;
             /* WS10082N - end   */
             goto exit;
         }
         /* WS10082N
         else if ( *(cpair->keyword) EQ NULL_CHAR)
                ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                              "We have an empty keyword in addinfo");*/
         /*WS10082K*  break;    */
 
         cpair++;
         i++;
 
      } /* while */
    } /* if (dupflag EQ UNIQUE) */                        /* WS10082N */
    else
    {                                                     /* WS10082N */
      i = addinfo->num_pairs;                             /* WS10082N */
      cpair = &addinfo->pair[i];                          /* WS10082N */
    }                                                     /* WS10082N */
 
 
   /*
    *    Add the Keyword
    */
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,13,
                    "Updating entry at %d,%p", i,cpair);
 
    ADDINFO_INIT_PAIR(cpair, i, 1);                       /* WS10082N */
    cpair->add_typ = type;
    cpair->keylen = kwdlen;
    strcpy(cpair->keyword,kwd);
    addinfo->num_pairs++;
 
   /*
    *    Update the value
    */
 
    /* IS10181 Add a return code so the ADDINFO_insert caller
               knows that the input value was too large and was
               truncated.
    ADDINFO_updval(val,max_vallen,cpair);                           */
    if (vallen GT 0)                                      /* WS10082N */
      rc = ADDINFO_updval(val,max_vallen,cpair);  /* IS10181 */
 
   /*
    *    Finish
    */
    exit: ;
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 2, func, rc);
 
    return rc;
 
  } /* ADDINFO_insert */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_updval                             *
*                                                             *
* DESCRIPTION    : Update a value of an exiting entry         *
*                                                             *
* INPUT          : value     - Value to be updated            *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_OK                                     *
*                  ESA_EOF - value is too long.               *
*                  ESA_ERR - long pair handling failed.       *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_updval (char               *addval,
                       int                max_value_len,  /* WS10082N */
                       ONE_FIELD_rec_ptr  pair)
       /* WS10082N     int                max_vallen,                 */
{
 
 /*
  *  Variables
  */
 
  char * ptr = NULL;                                     /* IS10181 */
  int set_done = 0;                                      /* IS10181 */
  ESA_RC rc = ESA_OK;
  int  size = 0;                                         /* WS10082M */
  char               msgbuf[256] = "";                   /* WS10082N */
  ONE_FIELD_rec_ptr  tpair=NULL;                         /* WS10082K */
 
  /* WS10082N - we no longer use max_value_len received from the
   *            caller. Instead we use ADDINFO_LARGE_VAL_LEN.        */
  int  max_vallen = ADDINFO_LARGE_VAL_LEN;               /* WS10082N */
 
  static char func[] = "ADDINFO_updval";
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
  /* WS10082K - Start                                          *
   *            Check if there is enough place for value.      *
   *            If needed allocate large pair.                 */
 
  /* Lets get the real pair if exists */
  tpair = get_pair(pair);      /* tpair -> real pair */
 
  tpair->twin->addval_msg = tpair->addval_msg = 'N';      /* WS10082N */
 
  /*  Check if the pair already has large pair but the value  *
   *  to be updated can fit in small pair. Free large pair.   */
 
  if(tpair->SLType EQ 'L' AND
          (strlen(addval)  LE ADDINFO_SHORT_VAL_LEN))
  {
     tpair = tpair->twin;  /* tpair should point to small pair */
     ADDINFO_free_twin_pair(tpair, 1);  /* free twin pair  */
     if (rc NE ESA_OK)
     {
        /* WS10082N - start */
        snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_free_twin_pair for <%s> failed with rc <%s>",
                 tpair->keyword, ESA_rc2str(rc));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                      NULL, NULL,
                      ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                      msgbuf, func);
        /* WS10082N - end   */
        rc = ESA_ERR;
        goto exit;
     };
  }
  else
  {
    /* Check if the value is more than 1K and requires large  *
     * pair. Else point to correct pair before updating value */
    if(tpair->SLType EQ 'S' AND
            (strlen(addval)  GT ADDINFO_SHORT_VAL_LEN))
    {
       rc = ADDINFO_alloc_twin_pair(tpair);
       if(rc NE ESA_OK)
       {
          /* WS10082N - start */
          snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_alloc_twin_pair for <%s> failed with rc <%s>",
                 tpair->keyword, ESA_rc2str(rc));
          CTSAMSG_print(ERR_ADI_PROC_ERROR,
                        NULL, NULL,
                        ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                        msgbuf, func);
          /* WS10082N - end   */
          rc = ESA_ERR;
          goto exit;
       };
       /* pair should point to large pair */
       tpair = tpair->twin;
    }
  }                                                       /* WS10082N */
 
  /* WS10082K - End */
 
 /*
  *  update value
  */
 /*
  *  Enough place for value ?
  *  If the incoming value parameter is larger than         IS10181
  *  the max_vallen input parameter, take the input value   IS10181
  *  parameter, point to the 16384th character, back up     IS10181
  *  until we find a ADDINFO_LIST_ENTRY (x'01') delimiter,  IS10181
  *  and place a null character on this delimiter.  If      IS10181
  *  there is no delimiter, just place a null character     IS10181
  *  on the 16384th character.                              IS10181
  */
  /* IS10094 if ( strlen(addval) GE max_vallen) {              */
  if ( strlen(addval) GT max_vallen) {              /* IS10094 */
     /* * * * * * IS10181 Start * * * * * */
     for (ptr = addval+max_vallen-1; ptr GT addval; ptr--)
     {
        if (ptr[0] EQ ADDINFO_LIST_ENTRY)
        {
/* WS10078S Do not change the caller's input data
           ptr[0] = NULL_CHAR;                                       */
           rc     = ESA_EOF;
           set_done = 1;
           break;
        }
     }
     if (set_done EQ 0)
     {
        ptr    = addval+max_vallen-1;
/* WS10078S Do not change the caller's input data
        ptr[0] = NULL_CHAR;                                          */
        rc     = ESA_EOF;
     }
     /* skip the next 2 instructions
     rc = ESA_FATAL;
     goto exit;                                                     */
     /* * * * * * IS10181 End * * * * * */
/* Just copy the portion of the caller's input data we want WS10078S */
/*   strncpy(pair->value, addval, ptr-addval);   /@WS10078S@/*WS10082K*/
/*   pair->value[ptr-addval] = NULL_CHAR;        /@WS10078S@/*WS10082K*/
     /* WS10082N  - start */
     snprintf(msgbuf, sizeof(msgbuf),
    "value length (%d) > max allowed (%d). Value for <%s> is truncated",
             pair->vallen, max_vallen, pair->keyword);
     CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
     /* WS10082N  - end   */
 
     strncpy(tpair->value, addval, ptr-addval);  /*WS10082K*/
     tpair->value[ptr-addval] = NULL_CHAR;       /*WS10082K*/
     tpair->twin->addval_msg = tpair->addval_msg = 'Y'; /*Ws10082N*/
  }
  else                           /* WS10078S */
/* This is a regular case when the caller's input data      WS10078S
   fits into the ADDINFO pair->value output area.           WS10078S */
     /* WS10082N strcpy(pair->value,addval);                        */
     strcpy(tpair->value,addval);                         /*WS10082K*/
 
  /* WS10082N pair->vallen = strlen(pair->value);                   */
  tpair->vallen = strlen(tpair->value);                   /*WS10082K*/
 
  /* Lets update the value length at short pair              WS10082K */
  if(tpair->SLType EQ 'L')                                /* WS10082K */
     tpair->twin->vallen = tpair->vallen;                 /* WS10082K */
 
  tpair->twin->addval_msg = tpair->addval_msg;            /* WS10082N */
 /*
  *  finish
  */
 
  exit:;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
  return rc;
 
}
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_dump                               *
*                                                             *
* DESCRIPTION    : Dump Addtional info area                   *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                  print_empty      -  1 print in any case    *
*                                   -  0 print only if value  *
*                                        length > 0           *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_dump (ADDINFO_rec_ptr addinfo,
                     int             print_empty)
{
 
    static char func[] = "ADDINFO_dump";
    int i;
    ESA_RC rc = ESA_OK;
    ONE_FIELD_rec_ptr f_ptr;
 
    /* initialize        */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 0, func);
 
    if (addinfo NE NULL) {
 
       /* addinfo num pairs */
 
       /* WS10082N ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
                       "num_pairs = %d, max_pairs = %d",
                       addinfo->num_pairs,addinfo->max_pairs); */
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,              /*WS10082N*/
            "num_pairs = %d, max_pairs = %d, heap_id = %p", /*WS10082N*/
             addinfo->num_pairs,addinfo->max_pairs,         /*WS10082N*/
             addinfo->heap_id);
 
       /* addinfo pairs */
 
       i = 0;
       f_ptr = addinfo->pair;
       while ( i LT addinfo->num_pairs) {
 
        if ( (print_empty NE 0 ) OR
             (f_ptr->vallen GT 0 ) )
        {                                                 /* WS1082N */
          /* WS10082N - Start: Print common information about pair */
          ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
       "pair(%3d): typ=%i SLTyp=%c flgs=%c/%c kwd=(%3d)%s  (%p-%p)",
                       f_ptr->index,
                       f_ptr->add_typ,
                       f_ptr->SLType,
                       f_ptr->secret,
                       f_ptr->addval_msg,
                       f_ptr->keylen, f_ptr->keyword,
                       f_ptr, f_ptr->twin);
          if (f_ptr->twin NE f_ptr)
            ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
       "twin(%3d): typ=%i SLTyp=%c flgs=%c/%c kwd=(%3d)%s  (%p-%p)",
                         f_ptr->twin->index,
                         f_ptr->twin->add_typ,
                         f_ptr->twin->SLType,
                         f_ptr->twin->secret,
                         f_ptr->twin->addval_msg,
                         f_ptr->twin->keylen, f_ptr->twin->keyword,
                         f_ptr->twin, f_ptr->twin->twin);
          /*WS10082N - End */
          if (strcmp(f_ptr->keyword,                 /*ps0292 */
                   "DCERT.CERTDATA") EQ 0)           /*ps0292 */
            /* WS10082K - start */
            /* ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,   /@ps0292 @/
                "pair no. %3d: %d kwd=%s(%3d) crypted data val=%s(%3d)",
                   i+1, f_ptr->add_typ,                 /@ps0292 @/
                  f_ptr->keyword,f_ptr->keylen,        /@ps0292 @/   */
            ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
                "crypted data val=(%3d)%s",
                 f_ptr->vallen, "...");
            /* WS10082K -  end */
          else                                       /*ps0292 */
            /* IS10100 - start  */
            /* ESA_DIAG_printf(PLT_COMP_API_ADDINFO,0,
                           "pair no. %3d: %d kwd=%s(%3d) val=%s(%3d)",
                           i+1, f_ptr->add_typ,
                           f_ptr->keyword,f_ptr->keylen,
                           f_ptr->value,f_ptr->vallen) ;    */
            /* IS10183 - start  */
            if (  (strcmp(f_ptr->keyword,"PASSWORD") EQ 0)  OR
                  (strcmp(f_ptr->keyword,"PHRASE") EQ 0)    OR
                  (strcmp(f_ptr->keyword,"PWPHRASE") EQ 0)  )
 
              /* WS10082K - start   */
              /* ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                           "pair no. %3d: kwd=%s(%3d) val=%s",
                           i+1, f_ptr->keyword,f_ptr->keylen,
                           "********");                       */
              ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
                             "val=%s", "********");
              /* WS10082K -  end */
            else
            /* IS10183 - end    */
            /* WS10082N - start   */
            {
              /* ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                           "pair no. %3d: kwd=%s(%3d) val=%s(%3d)",
                           i+1, f_ptr->keyword,f_ptr->keylen,
                           f_ptr->value,f_ptr->vallen);              */
              /* print up to 2048 characters from the value  */
              f_ptr = get_pair(f_ptr); /* print value from real pair */
              ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
                         "val=(%d)%.*s",
                         f_ptr->vallen,
                         (f_ptr->vallen GT ADDINFO_SHORT_VAL_LEN * 2 ?
                            ADDINFO_SHORT_VAL_LEN * 2 : f_ptr->vallen),
                         f_ptr->value);
              f_ptr = get_orig_pair(f_ptr);
              /* WS10082N -  end */
             /* IS10100 - end    */
            }                                             /* WS10082N */
 
          f_ptr++;
        }; /* if (print_empty NE 0) OR (f_ptr->vallen GT 0)) WS10082N */
 
        i++;
 
      }
 
    }; /* addinfo pointer not empty */
 
    /* finish            */
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 0, func, rc );
 
    return rc;
 
  } /* ADDINFO_dump */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_alloc                              *
*                                                             *
* DESCRIPTION    : Allocate additional info area              *
*                                                             *
* INPUT          : max_pairs        -  max_pairs              *
*                : addinfo_ptr      -  additional info pointer*
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_alloc (char                       *func,
                      short                      max_pairs,
                      ADDINFO_rec_ptr           *addinfo_ptr,
                      CTSAMSG_DEST_TABLE_rec_ptr dest,
                      CTSAMSG_HANDLE_rec_ptr     msgs)
{
 
    static char fn[] = "ADDINFO_alloc";
    int size;
    int i;                                   /*WS10082K*/
    ESA_RC rc = ESA_OK;
    /* WS10082N - start */
    char   msgbuf[256] = "";
    _INT4  heap_init_size = ADDINFO_HEAP_INIT_SIZE;
    _INT4  heap_incr_size = ADDINFO_HEAP_INCR_SIZE;
    _INT4  heap_opts      = ADDINFO_HEAP_OPT;
    _INT4  heap_id = 0;
    _FEEDBACK  fdbk;
    /* WS10082N - end   */
 
 
    /* Initialize        */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, fn);
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,6,
                    "addinfo pointer at %p, max =%d",
                    addinfo_ptr,max_pairs);
 
    /* Obtain area       */
 
    /* WS10082K size = sizeof (ADDINFO_rec_typ) +
               max_pairs * sizeof(ONE_FIELD_rec_typ);          */
    size = ADDINFO_SIZE(max_pairs);                  /*WS10082K*/
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11, "area size = %d",size);
    /* WS10082N  - start */
    /*
    (*addinfo_ptr) = (ADDINFO_rec_typ *)malloc (size);
    if ((*addinfo_ptr) EQ NULL) {
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 1,
                       "malloc for addinfo buffer failed");
       CTSAMSG_print(ERR_MALLOC, msgs, NULL, dest,
                     "ADDINFO BUFFER", size);
       rc = ESA_ERR;
    }
    else {
       *addinfo_ptr)->num_pairs = 0;
       (*addinfo_ptr)->max_pairs = max_pairs;
 
       ESA_DIAG_printf(PLT_COMP_ACF2_MEMORY, 6,          /@ WS10078S @/
           "Allocate: addr=%X len=%d rtn=%s",            /@ WS10078S @/
           *addinfo_ptr, size, fn);                      /@ WS10078S @/
    }
    */
    /*  Create the privaye HEAP  */
    CEECRHP (&heap_id, &heap_init_size,
             &heap_incr_size, &heap_opts, &fdbk);
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 11,
                    "Heap create:  heap_id = %p   fdbk = %d",
                    heap_id, fdbk.tok_msgno);
    if ( _FBCHECK ( fdbk, CEE000 ) EQ 0 )
    {
      /*  Get addinfo storage in the new heap */
      CEEGTST (&heap_id, &size, (void **)addinfo_ptr, &fdbk);
      ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 11,
      "Heap getstor:  size = %d  heap_id = %p  addinfo = %p  fdbk = %d",
           size, heap_id, *addinfo_ptr, fdbk.tok_msgno);
      if ( _FBCHECK ( fdbk , CEE000 ) EQ 0 )
      {
        ADDINFO_INIT((*addinfo_ptr), max_pairs, 0,
                     heap_id,
                     ESA_COMP_API_ADDINFO);
      }
      else
        sprintf(msgbuf,
  "ADDINFO alloc for <%d> bytes in heap <%p> failed. CEEGTST msg# = %d",
                size, heap_id, fdbk.tok_msgno);
    }
    else
      sprintf(msgbuf, "Heap create failed.  CEECRHP msg# = %d",
               fdbk.tok_msgno);
 
    if (msgbuf[0] NE NULL_CHAR)
    {
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  msgs, NULL, dest,
                  msgbuf, func);
 
       rc = ESA_ERR;
    }
    /* WS1082N - end */
    /* Finish            */
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, fn, rc );
 
    return rc;
 
} /* ADDINFO_alloc */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_free                               *
*                                                             *
* DESCRIPTION    : Free additional info buffer                *
*                                                             *
* INPUT          : addinfo_ptr      -  additional info pointer*
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_free (ADDINFO_rec_ptr *addinfo_ptr)
 
{
 
  static char func[] = "ADDINFO_free";
  char * ptr;
  int index = 0;
  ONE_FIELD_rec_ptr   pair;                          /* WS10082M */
  char               msgbuf[256] = "";                   /* WS10082N */
  _INT4  heap_id = 0;                                    /* WS10082N */
  _FEEDBACK  fdbk;                                       /* WS10082N */
 
  /* Initialize        */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1,func);
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,6,
                  "area at %X",(*addinfo_ptr));
 
  /* Free area       */
 
  /* WS10082N if ((*addinfo_ptr) NE NULL) {   */
  if (addinfo_ptr NE NULL   AND   (*addinfo_ptr) NE NULL) { /*WS10082N*/
    /* WS10082N - start */
 
    /*  free (*addinfo_ptr);    */
    heap_id = (*addinfo_ptr)->heap_id;
    CEEDSHP (&heap_id, &fdbk);
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 6,
          "Heap discard: heap_id = %p  fdbk = %d",
          heap_id, fdbk.tok_msgno);
    if ( _FBCHECK ( fdbk , CEE000 ) NE 0 )
    {
      sprintf(msgbuf,
          "Heap discard for heap id <%p> failed.  CEEDSHP msg# = %d",
           heap_id, fdbk.tok_msgno);
      CTSAMSG_print(ERR_ADI_PROC_ERROR,
                    NULL, NULL,
                    ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                    msgbuf, func);
    }
    /* ESA_DIAG_printf(PLT_COMP_ACF2_MEMORY, 6,           /@ WS10078S @/
                   "Free: addr=%X rtn=%s",                /@ WS10078S @/
                   *addinfo_ptr, func);               /@ WS10078S @/ */
    /* WS10082N - end   */
    (*addinfo_ptr) = NULL;
  }
 
  /* Finish            */
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, ESA_OK );
 
  return ESA_OK;
 
} /* ADDINFO_free    */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_clear_value                        *
*                                                             *
* DESCRIPTION    : Clear value of entering pair               *
*                                                             *
* INPUT          : pair      - -> pair address (short or long)*
*                                                             *
* OUTPUT         : pair      - -> short pair address.         *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                  - ESA_OK                                   *
*                  - ESA_ERR - long pair was not freed        *
*                              becasue the pair is invalid.   *
*                                                             *
**************************************************************/
/* WS10082N ESA_RC ADDINFO_clear_value(ONE_FIELD_rec_ptr  pair) */
ESA_RC ADDINFO_clear_value(ONE_FIELD_rec_ptr * pair)
{
 
 /*
  *  Variables
  */
 
  ESA_RC rc = ESA_OK;
  static char func[] = "ADDINFO_clear_value";
  ONE_FIELD_rec_ptr    spair = NULL;                 /*WS10082K*/
  char                 msgbuf[256] = "";                  /* WS10082N */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
 /* WS10082K - Start                                            *
 /*            1. Get original pair.                            *
  *            2. Check if the pair has Large pair associated.  *
  *            3. Free large pair if any.                       *
  *            4. clean value. (Existing code)                  */
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,6,
                  "Pair %p->%p received", pair, *pair);
 
  spair = get_orig_pair(*pair);
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,6,
                  "After get_orig_pair %p-%p", *pair, spair);
  if(spair->twin NE spair)
  {
     /* WS10082N - start  */
     rc = ADDINFO_free_twin_pair(spair, 1);
     if (rc NE ESA_OK)
     {
        snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_free_twin_pair for <%s> failed with rc <%s>",
                 spair->keyword, ESA_rc2str(rc));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                      NULL, NULL,
                      ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                      msgbuf, func);
        rc = ESA_ERR;
      }
      /* WS10082N - end   */
  };
 
  /* WS10082K - End */
 /*
  *  Clear value
  */
 
 
  /* WS10082N pair->value[0] = NULL_CHAR;  */
  /* WS10082N pair->vallen   = 0;          */
  /* WS10082N - start */
 
  ADDINFO_INIT_PAIR(spair, spair->index, 0);
  if (spair NE *pair)  /* if we received a long pair...             */
    *pair = spair;     /* ... return the short pair.                */
  /* WS10082N - end   */
 
 /*
  *  finish
  */
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
  return rc;
 
}
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_clear                              *
*                                                             *
* DESCRIPTION    : Clear Addtional info area                  *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_clear(ADDINFO_rec_ptr addinfo)
{
 
    static char func[] = "ADDINFO_clear";
    int i;
    ESA_RC rc = ESA_OK;
    ONE_FIELD_rec_ptr f_ptr;
 
    /* initialize        */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
 
    if (addinfo NE NULL) {
 
      /* WS10082N - start */
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,11,
             "addinfo at entry : %p -> num_pair = %d   max_pair = %d",
                   addinfo, addinfo->num_pairs, addinfo->max_pairs);
      /* WS10082N - end */
 
      if ( (addinfo->max_pairs GT 0)   AND            /*WS10082K*/
           (addinfo->num_pairs GT 0) )   {           /*WS10082N*/
        i = 0;
        f_ptr = addinfo->pair;
 
        while ( i LT addinfo->num_pairs) {
           /* WS10082N  - start */
           /* ESA_DIAG_printf(ESA_COMP_API_ADDINFO,11,
                           "pair no. %3d: kwd=%s(%3d) val=%s(%3d)",
                           i+1, f_ptr->keyword,f_ptr->keylen,
                           f_ptr->value,f_ptr->vallen) ;             */
           ESA_DIAG_printf(ESA_COMP_API_ADDINFO,11,
                   "pair no. %3d: (%p->%p) kwd=(%3d)%s   val=(%d)%.*s",
                      i+1, f_ptr, f_ptr->twin,
                           f_ptr->keylen,f_ptr->keyword,
                           f_ptr->vallen, 100, f_ptr->twin->value);
           /* WS10082N  - end   */
 
           /* WS10082N ADDINFO_clear_value(f_ptr);                 */
           ADDINFO_clear_value(&f_ptr);                  /* WS10082N */
           f_ptr++;
           i++;
        } /* while */
 
 
        /* WS10082N  - start */
        /* initialize all unused pairs.                                */
        for (i = addinfo->num_pairs; i LT addinfo->max_pairs; i++)
        {
          ADDINFO_INIT_PAIR(&addinfo->pair[i], i, 1);
           ESA_DIAG_printf(ESA_COMP_API_ADDINFO,11,
                     "pair no. %3d: (%p->%p) kwd=(%3d)%s   val=(%d)%.*s",
                      i+1, &addinfo->pair[i], addinfo->pair[i].twin,
                           addinfo->pair[i].keylen,
                           addinfo->pair[i].keyword,
                           addinfo->pair[i].vallen,
                           addinfo->pair[i].vallen,
                           100, addinfo->pair[i].value);
        }
        /* WS10082N  - end   */
        /* WS10082K - End */
 
      }; /* num_pair > 0 */                               /* WS10082N */
    }; /* addinfo pointer not empty */
 
    /* finish            */
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc );
 
    return rc;
  } /* ADDINFO_clear */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_addval                             *
*                                                             *
* DESCRIPTION    : Conactenate a value to an exiting one      *
*                                                             *
* INPUT          : addval    - Value to be added              *
*                  addsep    - Seperator between value list   *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                  ESA_OK - successful                        *
*                  ESA_EOF - no place for value               *
*                  ESA_ERR - allocation of large pair failed. *
*                                                             *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_addval (char                      *addval,
                       int                        max_vallen,
                       char                       addsep_c,
                       ONE_FIELD_rec_ptr          pair,
                       CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                       CTSAMSG_HANDLE_rec_ptr     p_msgs)
{
 
 /*
  *  Variables
  */
 
  ESA_RC rc = ESA_OK;
  static char func[] = "ADDINFO_addval";
  char   msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];
  char   addsep[2];
  ONE_FIELD_rec_ptr  tpair;                       /*WS10082K*/
  int size=0;                                     /*WS10082K*/
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
  BUILD_STRING_SEPARATOR( addsep, addsep_c)
 
  /*  Lets get real pair before we proceed                WS10082K */
  tpair=get_pair(pair);                                  /*WS10082K*/
 
  if (tpair->vallen EQ 0)                                 /* WS10082N */
    tpair->twin->addval_msg = tpair->addval_msg = 'N';    /* WS10082N */
 /*
  *  Enough place for value ?
  */
  /* WS10082K
  if ( (strlen(addval)+(pair->vallen)) GE max_vallen) {   */
  if((strlen(addval)+(tpair->vallen)) GE                /* WS10082K */
           ADDINFO_LARGE_VAL_LEN) {                     /* WS10082K */
     /* IS10181 With this error, set the rc to the same
                rc as ADDINFO_insert and ADDINFO_updval
     rc = ESA_FATAL;                                                */
     /* WS10082N - start */
     if (tpair->addval_msg EQ 'N')
     {
       snprintf(msgbuf, sizeof(msgbuf),
       "Cannot add value to keyword <%s>. Value length > max allowed. ",
             tpair->keyword);
 
       strncat (msgbuf, SEE_PRTDBG_MSG,
                         sizeof(msgbuf)-strlen(msgbuf) );
 
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  p_msgs, NULL, p_dest,
                  msgbuf, func);
 
       ESA_DIAG_printf (ESA_COMP_API_ADDINFO,0,
       "Value len %d > max allowed %d.  keyword = %s  addval = (%d)%s",
                strlen(addval)+(tpair->vallen), ADDINFO_LARGE_VAL_LEN,
                tpair->keyword, strlen(addval), addval);
       tpair->twin->addval_msg = tpair->addval_msg = 'Y';
 
     }
     /* WS10082N - end */
     rc = ESA_EOF;                                       /* IS10181 */
     goto exit;
  }
  /*WS10082K - Start */
  /* For following conditions we want to allocate Large pair -     *
   * 1. If length of value to be added and current value           *
   *    is more than 1024 (ADDINFO_SHORT_VAL_LEN).                 *
   * 2. Current pair is short pair. Note - we did get_pair above   *
   *    so, if there is twin associated to current pair it should  *
   *    point to large paif if exists.                             */
  if( ((strlen(addval)+(tpair->vallen)) GT ADDINFO_SHORT_VAL_LEN)
      AND (tpair->SLType EQ 'S') )
  {
     rc = ADDINFO_alloc_twin_pair(tpair);
     if (rc NE ESA_OK)
     {
        /* WS10082N - start */
        snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_alloc_twin_pair for <%s> failed with rc <%s>",
                 tpair->keyword, ESA_rc2str(rc));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                      NULL, NULL,
                      ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                      msgbuf, func);
        /* WS10082N - end   */
        rc = ESA_ERR;
        goto exit;
     }
     /* pair should point to large pair */
     tpair = tpair->twin;
  }
  /* WS10082K - End */
 /*
  *  Add seperator
  */
  /*WS10082K - start */
  /* if ( *pair->value NE NULL_CHAR ) {
    if ( (pair->add_typ EQ TYPE_1B)  OR
         (pair->add_typ EQ TYPE_2B)   )
     strcat(pair->value, addsep);
    else {
   sprintf(msgbuf, "Invalid type=%d for list keyword=%s (value=%s %s)",
            pair->add_typ,  pair->keyword, pair->value, addval);   */
                 /* added pair->value and addval to message SAS2IBMT */
  if ( tpair->value[0] NE NULL_CHAR ) {
    if ( (tpair->add_typ EQ TYPE_1B)  OR
         (tpair->add_typ EQ TYPE_2B)   )
     strcat(tpair->value, addsep);
    else {
 
      snprintf(msgbuf, sizeof(msgbuf),
 "Invalid type <%s> for list keyword <%s> (value=%.100s addval=%.100s)",
              tpair->add_typ, tpair->keyword, tpair->value, addval);
     /*WS10082K - End */
     /* WS10082N  CTSAMSG_print(ERR_INTERNAL2, p_msgs, NULL, p_dest,
                    component, func, msgbuf, 0, __LINE__);  */
      CTSAMSG_print(ERR_ADI_PROC_ERROR,                   /* WS1082N */
                  p_msgs, NULL, p_dest,                   /* WS1082N */
                  msgbuf, func);                          /* WS1082N */
     /* WS10082K    strcat(pair->value, addsep);              */
      strcat(tpair->value, addsep);                 /*WS10082K*/
    }
  }
 
 /*
  *  Add value
  */
  /* WS10082K strcat(pair->value,addval);                      */
  /* WS10082K pair->vallen = strlen(pair->value);              */
 
  /*WS10082K - start */
  strcat(tpair->value,addval);
 
  /* Lets update the value in short and long pair */
  tpair->twin->vallen = tpair->vallen = strlen(tpair->value);
 
  ESA_DIAG_printf (ESA_COMP_API_ADDINFO,9,
      "Updating pair (%p) of type %c with vallen(%d) twin vallen (%d)",
       tpair, tpair->SLType, tpair->vallen, tpair->twin->vallen);
  /*WS10082K - End */
 
 /*
  *  finish
  */
 
  exit:;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
  return rc;
 
}
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_delete                             *
*                                                             *
* DESCRIPTION    : Delete an entry from addinfo buffer        *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                  keyword          -  keyword                *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_delete(ADDINFO_rec_ptr addinfo,
                      char            *keyword)
 
{
 
  static char func[] = "ADDINFO_delete";
 
 /*
  *   Variables
  */
 
  ESA_RC rc = ESA_OK ;
  int  found, i;
  ONE_FIELD_rec_ptr  to_pair;       /* WS10082M */
  ONE_FIELD_rec_ptr  last_pair;     /* WS10082M */
  char               msgbuf[256] = "";                    /* WS10082N */
 
 /*
  *   Initialize
  */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
 /*
  *   Search keyword that must be deleted
  */
 
  found =0;
  for ( i=0; NOT(found) AND (i LT addinfo->num_pairs); i++ )
      if (strcmp(addinfo->pair[i].keyword,keyword) EQ 0)
         found = i+1;
 
  if ( NOT(found) ) {
     rc = ESA_ERR ;
     goto exit;
  }
 
/* WS10082K - Start                                      */
  ESA_DIAG_printf (ESA_COMP_API_ADDINFO,6,
               "Found attribute at %d position addinfo_num_pairs: %d",
               found-1, addinfo->num_pairs);
 /*
 * With WS10082 We dont compress the addinfo buffer
 * anymore.  Instead of compressing the addinfo buffer   *
 * the last entry is copied to the deleted addinfo pair. *
 * Addinfo is not sorted so this should not be an issue. *
 * Commenting for loop to compress the buffer and new    *
 * logic to copy the last entry is implemented.          *
 *                                                       */
 /*
  @   Compress information
  @/
 
  for ( i = found-1; i LT (addinfo->num_pairs-1); i++) {
 
     strcpy(addinfo->pair[i].keyword, addinfo->pair[i+1].keyword);
     strcpy(addinfo->pair[i].value  , addinfo->pair[i+1].value  );
     addinfo->pair[i].keylen  = addinfo->pair[i+1].keylen;
     addinfo->pair[i].vallen  = addinfo->pair[i+1].vallen;
     addinfo->pair[i].add_typ = addinfo->pair[i+1].add_typ; /@ IS10094@/
 
  }                                                                   */
 
  to_pair = &addinfo->pair[found-1];
 
  /* If the pair to be deleted has a long pair, free it. */
  if (to_pair->twin->SLType EQ 'L')
     ADDINFO_free_twin_pair(to_pair, 0);
     /* WS10082N - start */
     if (rc NE ESA_OK)
     {
        snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_free_twin_pair for <%s> failed with rc <%s>",
                 to_pair->keyword, ESA_rc2str(rc));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                      NULL, NULL,
                      ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                      msgbuf, func);
     }
     /* WS10082N - start */
 
  last_pair = &addinfo->pair[addinfo->num_pairs-1];
  ESA_DIAG_printf (ESA_COMP_API_ADDINFO,6,
                  "to_pair: %p -> %s    last_pair: %p -> %s",
                   to_pair, to_pair->keyword,
                   last_pair, last_pair->keyword);
 
  /* If the pair to be deleted is not the last pair, copy the *
   * last pair to the deleted pair.                           *
   * (if the pair to be deleted is the last pair, we just     *
   * have to init it.                                         */
  if(to_pair NE last_pair)
  {
    last_pair->index = to_pair->index;
    memcpy((char *)to_pair, (char *)last_pair,
                              sizeof(ONE_FIELD_rec_typ));
 
    if(to_pair->twin->SLType EQ 'L')
    {
      /* Update twin of large pair (if exists)*/
      to_pair->twin->twin = to_pair;
      to_pair->twin->index = to_pair->index;
    }
    else
      to_pair->twin = to_pair;  /* short pair - adjust twin ptr */
  };
 
  /* init the last pair.                       */
  ADDINFO_INIT_PAIR(last_pair, last_pair->index, 1);
 /*WS10082K - End */
 
 /*
  *   Update number of entries
  */
 
  addinfo->num_pairs--;
 
 /*
  *   Finish
  */
 
 exit :;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
 
  return rc;
 
}
 
 /**************************************************************
 *                                                             *
 * Procedure Name : ADDINFO_dup_check adies11                  *
 *                                                             *
 * Description    : Check keywords in addinfo having           *
 *                  the same prefix.                           *
 *                                                             *
 * Input          : addinfo                                    *
 *                  keyword = prefix                           *
 *                                                             *
 * Output         : pair - pair of found keyword.              *
 *                  pair points to real pair           WS10082 *
 *                                                             *
 * Input/Output   :                                            *
 *                                                             *
 * Return Value   : ESA_RC, ESA_FATAL - Duplicate keywords     *
 *                                                             *
 * Side Effects   :                                            *
 *                                                             *
 * Comments       :                                            *
 *                                                             *
 **************************************************************/
 
 ESA_RC ADDINFO_dup_check(ADDINFO_rec_typ           * addinfo,
                          char                      * kwd,
                          int                         max_kwdlen,
 /* PS0288 */             int                  exists_when_empty,
                          ONE_FIELD_rec_ptr         * pair,
                          CTSAMSG_DEST_TABLE_rec_ptr  dest,
                          CTSAMSG_HANDLE_rec_ptr      msgs)
  {
 
  /*
   *  Variables
   */
 
   ESA_RC                     rc=ESA_OK ;
   short                      pairs_left ;
   ONE_FIELD_rec_ptr          pair1 = NULL;
   ONE_FIELD_rec_ptr          pair2 = NULL;
   static  char               func[]="ADDINFO_dup_check";
 
  /*
   *  initialize
   */
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
   *pair = NULL ;
 
  /*
   *  Search keyword
   */
 
   pair1 = ADDINFO_prefix_search(kwd, max_kwdlen,
                                 exists_when_empty,  /* PS0288 */
                                 addinfo->pair, addinfo->num_pairs);
   if ( pair1 NE NULL) {
      *pair = pair1;
      /* WS10082K
      pairs_left = addinfo->num_pairs - (pair1 - addinfo->pair) - 1;*/
      pairs_left = addinfo->num_pairs - pair1->index -1;  /* WS10082N */
 
      if (pairs_left GT 0) {
 
      /*
       *  Search keyword again
       */
 
         pair1 = get_orig_pair(pair1);                    /* WS10082N */
         pair2 = ADDINFO_prefix_search(kwd, max_kwdlen,
                                       exists_when_empty,  /* PS0288 */
                                       pair1+1,pairs_left);
         if (pair2 NE NULL) {
            CTSAMSG_print(ERR_PARAM_MUTUALLY_EXC, msgs, NULL, dest,
                          pair1->keyword, pair1->value ,
                          pair2->keyword, pair2->value );
            rc = ESA_FATAL;
            goto exit;
         }    /* duplicate keywords */
 
      } /* not last pair */
 
   } /* keyword was found */
 
  exit :;
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                   "Exiting with ptr=%X", *pair);
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 3, func, rc);
 
   return rc;
 
} /* ADDINFO_dup_check */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_prefix_search adies12              *
*                                                             *
* DESCRIPTION    : Search a keyword in additional info        *
*                                                             *
* INPUT          : kwd              -  keyword prefix         *
*                  pair             -  entry to start search  *
*                  limit            -  max entries to search  *
*                                                             *
* OUTPUT         : None                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if not found)   *
* WS10082K         Returns real pair in rc.                   *
*                                                             *
**************************************************************/
ONE_FIELD_rec_ptr ADDINFO_prefix_search(char           *kwd,
                                         int          max_kwdlen,
 /* PS0288 */                            int   exists_when_empty,
                                         ONE_FIELD_rec_ptr p_pair,
                                         short             p_limit)
{
 
  /*
   *  Variables
   */
 
   short i ;
   int pfxlen = 0;
   ONE_FIELD_rec_ptr cpair;
   ONE_FIELD_rec_ptr rc = NULL;
   static char func[]="ADDINFO_prefix_search";
 
  /*
   *  initialize
   */
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
 
   if (kwd EQ NULL)
      goto exit ;
   pfxlen = strlen(kwd) ;
   if ( (pfxlen GT max_kwdlen) OR (pfxlen EQ 0) )
      goto exit ;
 
   /* WS10082K  cpair = p_pair;                                 */
   cpair = get_orig_pair(p_pair);                     /*WS10082K*/
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO,9,            /*WS10082K*/
     "Orig pair %p, plimit - %d", cpair, p_limit);    /*WS10082K*/
 
  /*
   *  Loop on Pairs
   */
 
   for (i=0; i LT p_limit; i++) {
      if ( strncmp(cpair->keyword, kwd, pfxlen) EQ 0 ) {
        if ( (cpair->vallen GT 0)   OR                 /* ps0288 */
             ( (cpair->vallen EQ 0) AND exists_when_empty) ) {
                 /*WS10082K rc = cpair;                            */
                 rc = get_pair(cpair); /* Return real pair WS10082K*/
          break;
        }
      }
      cpair++;
   } /* for */
 
  /*
   *    Finish
   */
 
   exit:;
 
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                   "Exiting with rc=%X", rc);
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 3, func, ESA_OK);
 
   return rc;
 
} /* ADDINFO_prefix_search */
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert_cond adies13                *
*                                                             *
* DESCRIPTION    : Search kwd1 with val1 in addinfo1          *
*                  and if it matches, add kwd2 with val2      *
*                  to addinfo2 .                              *
* WS10082K         The addinfo pair returned is real pair.    *
*                                                             *
* INPUT          : kwd1                                       *
*                  val1                                       *
*                  addinfo1                                   *
*                  kwd2                                       *
*                  val2                                       *
*                                                             *
* OUTPUT         : addinfo2                                   *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
**************************************************************/
 
void ADDINFO_insert_cond( char                  * kwd1,
                          char              * val1,
                          ADDINFO_rec_typ   * addinfo1,
                          char              * kwd2,
                          char              * val2,
                          int                 max_kwdlen,
                          int                 max_vallen,
                          ADDINFO_rec_typ   * addinfo2 )
{
 
   static char func[]="ADDINFO_insert_cond";              /* WS10082N */
   ONE_FIELD_rec_ptr   cpair;
   char     msgbuf[256] = "";                             /* WS10082N */
   ESA_RC   rc = ESA_OK;                                  /* WS10082N */
 
   cpair = ADDINFO_search( kwd1, max_kwdlen,
                           addinfo1->pair, addinfo1->num_pairs);
   if (cpair NE NULL)
      if (strcmp(cpair->value, val1) EQ 0 )
         /* WS10082N
         ADDINFO_insert(cpair->add_typ, kwd2, val2, addinfo2, */
         rc = ADDINFO_insert(cpair->add_typ, kwd2,
                             val2, addinfo2,
                             max_kwdlen, max_vallen, UNIQUE);
         /* WS10082N - start */
         if (rc NE ESA_OK)
         {
            snprintf(msgbuf, sizeof(msgbuf),
              "Insert of keyword <%s> to addinfo failed with rc <%s>. ",
                kwd2, ESA_rc2str(rc));
            CTSAMSG_print(ERR_ADI_PROC_ERROR,
                         NULL, NULL,
                        ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                         msgbuf, func);
         };
         /* WS10082N - end  */
 
}
 
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_copy                               *
*                                                             *
* DESCRIPTION    : Copy additional info area                  *
*                                                             *
* INPUT          : to               -  additional info        *
*                  from             -  additional info        *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_copy  (ADDINFO_rec_ptr to,
                      ADDINFO_rec_ptr from)
 
{
 
#define  DIAG_PAIR(_p, _a, name)                                     \
            ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,                  \
       "%s(%3d)(%p-%p): SLTyp=%c flgs=%c/%c k=(%d)%s v=(%d)%.100s",  \
                       name,                                         \
                       _p->index, _p, _p->twin,                      \
                       _p->SLType,                                   \
                       _p->secret,                                   \
                       _p->addval_msg,                               \
                       _p->keylen, _p->keyword,                      \
                       _p->vallen, _p->value);
 
    static char func[] = "ADDINFO_copy";
    char * ptr;                                   /*WS10082K*/
    int  i=0;                                     /*WS10082K*/
    int  size = 0;                                /* WS10082N */
    ONE_FIELD_rec_typ * twin_pair;                /*WS10082K*/
    ONE_FIELD_rec_typ * from_pair;                /*WS10082M*/
    ONE_FIELD_rec_typ * to_pair;                  /*WS10082M*/
    ESA_RC rc = ESA_OK;
    short save_max_pairs;
    char   msgbuf[256] = "";                              /* WS10082N */
 
    /* Initialize        */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
    if ((to EQ NULL) OR (from EQ NULL)) {      /*WS10082K*/
       rc = ESA_FATAL;                         /*WS10082K*/
       goto exit;                              /*WS10082K*/
    }                                          /*WS10082K*/
 
    /* WS10082N - start */
    /* ESA_DIAG_printf(ESA_COMP_API_ADDINFO,1,
                    "FROM: at %X, used %d max %d",
                    from,from->num_pairs,from->max_pairs);
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,1,
                    "TO: at %X, used %d max %d",
                    to,to->num_pairs,to->max_pairs);    */
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                 "entry - FROM: at %p: used=%d  max=%d  heap_id=%p",
                 from, from->num_pairs, from->max_pairs,
                 from->heap_id);
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                  "entry - TO: at %p: used=%d  max=%d  heap_id=%p",
                  to, to->num_pairs, to->max_pairs,
                  to->heap_id);
    /* WS10082N - end   */
 
    if (to->max_pairs LT from->num_pairs) {
      /* WS10082N - start */
      snprintf(msgbuf, sizeof(msgbuf),
              "Target addinfo is short than source (%d < %d)",
               to->max_pairs, from->num_pairs);
      CTSAMSG_print(ERR_ADI_PROC_ERROR,
                 NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf, func);
      /* WS10082N - end */
       rc = ESA_ERR;
       goto exit;
    }
 
    /* We need to clear the receiving addinfo to free long pairs,
       if exist.                                           WS10082N */
    ADDINFO_clear(to);  /* Clear the receiving addinfo     WS10082N */
 
    /* WS10082N save_max_pairs = to->max_pairs;  */
 
    /*  Copy addinfo used pairs.   */
    size = (from->num_pairs * sizeof(ONE_FIELD_rec_typ)); /* WS10082N */
 
    /* Copy only the pairs.                                WS10082N */
    /* memcpy((void *)to,
           (void *)from,
           ADDINFO_size(from->num_pairs) );    */
    memcpy((void *)to->pair,                              /* WS10082N */
           (void *)from->pair,                            /* WS10082N */
           size);                                         /* WS10082N */
    /* WS10082N to->max_pairs = save_max_pairs;  */
    to->num_pairs = from->num_pairs;
 
    /* WS10082K - Start */
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,1,
                    "TO after copy: used=%d    max=%d",
                    to->num_pairs, to->max_pairs);
 
    /* Set twin pointers in to addinfo:                            */
    /* Short pair - reset the twin pointer to point to itself.     */
    /* Long pair - allocate a new long pair and copy the lomg pair */
    /*             from "from".                                    */
    for(i=0; i LT to->num_pairs; i++) {
       from_pair = &(from->pair[i]);
       to_pair = &(to->pair[i]);
 
       /*Handle the pairs present in from addinfo*/
       if(from_pair->twin->SLType EQ 'L')
       {
          if(from_pair->twin EQ from_pair)
          {
            snprintf(msgbuf, sizeof(msgbuf),
                    "Large pair but twin pair pointer (%p) = pair (%p)",
                    from_pair->twin, from_pair);
            CTSAMSG_print(ERR_ADI_PROC_ERROR,
                          NULL, NULL,
                        ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                          msgbuf, func);
            rc = ESA_FATAL;
            goto exit;
          }
 
          /* allocate a new twin pair for to_pair  */
          to_pair->twin = to_pair; /* remove ptr to the "from" twin */
          rc = ADDINFO_alloc_twin_pair(to_pair);
          if (rc EQ ESA_OK)
          {
            /* copy long value to twin pair, with null terminator  */
            memcpy(to_pair->twin->value, from_pair->twin->value,
                   (from_pair->vallen LT ADDINFO_LARGE_VAL_LEN ?
                   from_pair->vallen + 1 : from_pair->vallen) );
 
            DIAG_PAIR(from_pair, from, "from_pair");
            DIAG_PAIR(from_pair->twin, from, "from_twin");
            DIAG_PAIR(to_pair, to, "to_pair");
            DIAG_PAIR(to_pair->twin, to, "to_twin");
          }
          else
          {                                               /* WS10082N */
            /* WS10082N - start */
            snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_alloc_twin_pair for <%s> failed with rc <%s>",
                 to_pair->keyword, ESA_rc2str(rc));
            CTSAMSG_print(ERR_ADI_PROC_ERROR,
                        NULL, NULL,
                        ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                        msgbuf, func);
            /* WS10082N - end   */
            rc = ESA_ERR;
          }                                               /* WS10082N */
      } /*if(to_pair->twin->SLType EQ 'L') */
      else
      {
         /* Shoert pair, just adjust the twin pointer */
         to_pair->twin = to_pair;
      }
    } /* End for */
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                 "exit - FROM: at %X: used=%d  max=%d  heap_id=%p",
                 from, from->num_pairs, from->max_pairs,
                 from->heap_id);
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                  "exit - TO: at %X: used=%d  max=%d  heap_id=%p",
                  to, to->num_pairs, to->max_pairs,
                  to->heap_id);
    /* WS10082K - End */
 
     /* Finish            */
 
   exit: ;
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
 
    return rc;
 
  } /* ADDINFO_copy    */
 
 
 
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_strip_prefix adies16               *
 *                                                             *
 * DESCRIPTION    : Copy prefix keyword from source addinfo    *
 *                  to target addinfo with removing prefix     *
 *                  from keyword                               *
 *                                                             *
 * INPUT          : addinfo                                    *
 *                  keyword                                    *
 *                                                             *
 * OUTPUT         : laddinfo                                   *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 **************************************************************/
 ESA_RC ADDINFO_strip_prefix(char               * keyword,
                             int                  max_kwdlen,
                             int                  max_vallen,
                             ADDINFO_rec_typ    * addinfo,
                             ADDINFO_rec_typ    * laddinfo)
 {
 
   static   char     func[] = "ADDINFO_strip_prefix";
   ESA_RC            rc = ESA_OK;
   ONE_FIELD_rec_ptr cpair;
   char              *work;
   char               msgbuf[256] = "";                   /* WS10082N */
 
  /*
   *    Initialize
   */
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO ,4,func);
 
  /*
   *    Get Parameter
   */
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO , 4,
                   "keyword=%s", keyword);
 
   cpair = ADDINFO_search(keyword, max_kwdlen,
                          addinfo->pair, addinfo->num_pairs);
   if (cpair EQ NULL) {
      rc = ESA_ERR;
      goto exit;
   }
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO , 4,
                   "keyword=%s value=%s",
                   cpair->keyword, cpair->value );
 
   work = strchr( keyword, '.' );
   if ( work EQ NULL )   /* prefix separator not found */
      work = keyword;
   else
      work++;            /* branch over the separator */
 
   rc = ADDINFO_insert(cpair->add_typ,
                       work, cpair->value, laddinfo,
                       max_kwdlen, max_vallen, UNIQUE);
 
   /* WS10082N - start */
   if (rc NE ESA_OK)
   {
      snprintf(msgbuf, sizeof(msgbuf),
            "Insert of keyword <%s> to addinfo failed with rc <%s>. ",
             work, ESA_rc2str(rc));
      CTSAMSG_print(ERR_ADI_PROC_ERROR,
                   NULL, NULL,
                   ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                   msgbuf, func);
   }
   /* WS10082N - end   */
 
  /*
   *    Finish
   */
 
   exit :;
 
   ESA_DIAG_exit( ESA_COMP_API_ADDINFO ,4, func, rc );
 
   return rc;
 
 }
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_get_next                           *
*                                                             *
* DESCRIPTION    : Get next item from ADDINFO                 *
*                                                             *
* INPUT          : pair             -  entry to start loop    *
*                                                             *
* OUTPUT         : None                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if finished)    *
* WS10082K*        Always return real pair.                   *
*                                                             *
**************************************************************/
ONE_FIELD_rec_ptr ADDINFO_get_next(ADDINFO_rec_typ   * addinfo,
                                   ONE_FIELD_rec_ptr   p_pair)
{
 
  /*
   *  Variables
   */
 
   int p_limit;
   int start;                               /*WS10082K*/
   ONE_FIELD_rec_ptr   tpair = NULL;        /*WS10082K*/
   ONE_FIELD_rec_ptr rc = NULL;
   static char func[]="ADDINFO_get_next";
 
  /*
   *  initialize
   */
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
 
   /*WS10082K - Start */
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14, "Addinfo=%p", addinfo);
 
   if (addinfo EQ NULL) {
      /* WS10082N - start */
      CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  "No addinfo", func);
    /* WS10082N - start */
      goto exit;
   }
   /*WS10082K - End */
 
   if ( p_pair EQ NULL ) {
     start = TRUE;                        /*WS10082K*/
     p_limit = addinfo->num_pairs;
     /* WS10082N p_pair  = addinfo->pair;    */
     tpair  = addinfo->pair;             /*WS10082N*/
     /* p_pair--;                          WS10082K */
   }
   else
   {                                      /*WS10082K*/
     start = FALSE;                       /*WS10082K*/
     tpair = get_orig_pair(p_pair);       /*WS10082K*/
     /*WS10082K
     p_limit = addinfo->num_pairs - (p_pair - addinfo->pair) - 1;*/
     p_limit = addinfo->num_pairs - (tpair->index + 1);  /*WS10082K*/
   }
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14,
                    "Num=%d limit=%d", addinfo->num_pairs, p_limit);
 
   if (p_limit EQ 0)
       goto exit;
 
  /*
   *  Get next pair
   */
   /*WS10082K - Start                                     *
    *           If called for first time then, get_pair   *
    *           return real pair. For subsequent calls    *
    *           ppair should return real pair.            */
 
   /* rc = p_pair + 1;                                     */
   if (start EQ TRUE)
      rc = get_pair(tpair);
   else
      rc = ppair(tpair);
   /* WS10082K - End */
 
  /*
   *    Finish
   */
 
   exit:;
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                   "Exiting with rc=%X", rc);
 
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 3, func, ESA_OK);
 
   return rc;
 
} /* ADDINFO_get_next */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_copy_by_prefix adies18             *
*                                                             *
* DESCRIPTION    : Copy ADDINFO pairs by prefix               *
*                                                             *
* INPUT          : addinfo_in                                 *
*                  prefix                                     *
*                                                             *
* OUTPUT         : addinfo_out                                *
*                                                             *
* RETURN VALUE   : return code.                               *
*                                                             *
* NOTES          : The value is copied only when:             *
*                  1. The target addinof does not contain the *
*                     keyword. In this case, the keyword is   *
*                     added.                                  *
*                  2. The target addinfo contains the keyword *
*                     and its value is empty.                 *
*                                                             *
*                  If the target addinfo contains the keyword *
*                  with a value, the value from the source    *
*                  addinfo is not copied.                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_copy_by_prefix(char              *prefix,
                              int                max_kwdlen,
                              int                max_vallen,
                              int                drop_prefix,
                              ADDINFO_rec_typ   *addinfo_in,
                              ADDINFO_rec_typ   *addinfo_out)
{
 
  /*
   *  Variables
   */
 
   ESA_RC   rc = ESA_OK;
   int      len;
   int      skip_prefix;
   ONE_FIELD_rec_ptr cpair   = NULL;
   ONE_FIELD_rec_ptr cpair_o = NULL;
   char     msgbuf[256] = "";                             /* WS10082N */
   static char func[]="ADDINFO_copy_by_prefix";
 
  /*
   *  initialize
   */
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
 
   len = strlen(prefix);
   if ( len EQ 0 )
       goto exit;
 
   while ( cpair = ADDINFO_get_next(addinfo_in, cpair ) ) {
     if ( memcmp(cpair->keyword, prefix, len ) EQ 0 ) {
        if (drop_prefix EQ TRUE)
         skip_prefix = len;
        else
         skip_prefix = 0;
 
        rc = ADDINFO_insert(cpair->add_typ,
                            &(cpair->keyword[skip_prefix]),
                            cpair->value, addinfo_out,
                            max_kwdlen, max_vallen,
                            UNIQUE);
        /* WS10082N if ( rc EQ ESA_FATAL )  /@ Overflow @/   */
        /* WS10082N    goto exit;                             */
        /* WS10082N else {                                    */
 
        /*WS10082K - Check the error code for existing pair*/
        if (rc NE ESA_OK)                                 /* WS10082N */
        {
          if (rc EQ ESA_DUP_KEY)                          /* WS10082N */
          {                                                /*WS10082K*/
            /* WS10082N
            cpair_o = ADDINFO_search(cpair->keyword, max_kwdlen, */
            cpair_o = ADDINFO_search(                    /* WS10082N */
                        &(cpair->keyword[skip_prefix]), /* WS10082N */
                        max_kwdlen,                     /* WS10082N */
                        addinfo_out->pair,
                        addinfo_out->num_pairs);
 
            if ( (cpair_o NE NULL)            AND
                 (strlen(cpair_o->value) EQ 0 )  )
            {                                             /* WS10082N */
              /* WS10082N
              ADDINFO_updval(cpair->value, max_vallen, cpair_o);  */
              rc = ADDINFO_updval(cpair->value,           /* WS10082N */
                                  max_vallen, cpair_o);   /* WS10082N */
              /* WS10082N - start */
              if (rc NE ESA_OK)
              {
                 snprintf(msgbuf, sizeof(msgbuf),
                   "update value for keyword %s failed with rc %s. ",
                    &(cpair->keyword[skip_prefix]), ESA_rc2str(rc));
                 CTSAMSG_print(ERR_ADI_PROC_ERROR,
                          NULL, NULL,
                          ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                          msgbuf, func);
                 if (rc EQ ESA_FATAL)
                   goto exit;
              }
            }
            else  /* not found or has value   */
            {
               snprintf(msgbuf, sizeof(msgbuf),
                   "Cannot copy keyword <%s> - not found or not empty",
                    &(cpair->keyword[skip_prefix]));
                 CTSAMSG_print(ERR_ADI_PROC_ERROR,
                          NULL, NULL,
                          ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                          msgbuf, func);
            }
            /* WS10082N - end   */
          }   /* if (rc EQ ESA_DUP_KEY) */                 /*WS10082K*/
          /* WS10082N - start */
          else   /* insert failed */
          {
             snprintf(msgbuf, sizeof(msgbuf),
               "Insert of keyword %s to addinfo failed with rc %s. ",
                &(cpair->keyword[skip_prefix]), ESA_rc2str(rc));
             CTSAMSG_print(ERR_ADI_PROC_ERROR,
                   NULL, NULL,
                   ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                   msgbuf, func);
 
             if (rc EQ ESA_FATAL)
               goto exit;
          }
          /* WS10082N - end   */
       } /* if (rc NE ESA_OK)  for insert  */
 
     }  /* if ( memcmp(cpair->keyword, prefix, len ) EQ 0 ) */
   } /* while */
 
   /* Finish */
 
   exit: ;
 
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
 
   return rc;
 
  } /* ADDINFO_copy_by_prefix    */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_kdt_search adies19                 *
*                                                             *
* DESCRIPTION    : Locate a keyword in KDT (Keyword           *
*                  Description Table )                        *
*                                                             *
* INPUT          : p_kwd            - keyword to be searched  *
*                  p_kdte           - KDTE to start search    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ADDINFO_KDTE_rec_ptr                       *
*                                                             *
**************************************************************/
ADDINFO_KDTE_rec_ptr ADDINFO_kdt_search(char                 *kwd,
                                        ADDINFO_KDTE_rec_ptr  p_kdte)
 
{
 
   static char func[] = "ADDINFO_kdt_search";
 
   /*
    *     Variables
    */
 
   ADDINFO_KDTE_rec_ptr c_desc;
   ADDINFO_KDTE_rec_ptr rc = NULL;
   int                  length;       /* ps0292 */
   int                  wildcard;     /* ps0292 */
 
   /*
    *     Initialize
    */
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
 
   /*
    *     Locate description for keyword
    */
 
   for (c_desc=p_kdte; *(c_desc->kwd) NE NULL_CHAR; c_desc++ ) {
      ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                      "Checking kwd %s",c_desc->kwd);
 
      /* ps0292
       * Check if KDT keyword includes wildcard symbol '*'
       */
 
      length = strlen(c_desc->kwd) - 1;            /* ps0292 */
      if ( (length) GE 0) {                        /* ps0292 */
         if (c_desc->kwd[length] EQ '*')           /* ps0292 */
            wildcard = TRUE;                       /* ps0292 */
         else                                      /* ps0292 */
            wildcard = FALSE;                      /* ps0292 */
      }                                            /* ps0292 */
                                                   /* ps0292 */
      if ( NOT wildcard ) {                        /* ps0292 */
        if (strcmp(c_desc->kwd,kwd) EQ 0) {
           rc = c_desc;
           break;
        } /* if */
      } /* if */                                   /* ps0292 */
      /* Checking according wildcard */            /* ps0292 */
      else {                                       /* ps0292 */
        if (memcmp(c_desc->kwd, kwd,               /* ps0292 */
                   length ) EQ 0) {                /* ps0292 */
           rc = c_desc;                            /* ps0292 */
           break;                                  /* ps0292 */
        } /* if */                                 /* ps0292 */
      }                                            /* ps0292 */
   } /* for */
 
   /*
    *     finish
    */
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 3,
                   "exiting with rc= %X", rc );
 
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 3, func, ESA_OK);
 
   return rc;
 
}
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_mkt_check adies21                  *
*                                                             *
* DESCRIPTION    : Check that all mandatory keywords were     *
*                  specified                                  *
*                                                             *
* INPUT          : p_func        - function name              *
*                  p_numaddi     - number of addinfo buffers  *
*                  p_addinfo     - pointer to addinfo         *
*                  p_mkte        - MKTE to start with         *
*                  p_dest        - Vector of error msg dests  *
*                  p_msgs        - Error messages buffer      *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_mkt_check( char                      *p_func,
                          short                      p_numaddi,
                          ADDINFO_rec_ptr           *p_addinfo,
                          ADDINFO_MKTE_rec_ptr       p_mkte,
                          ADDINFO_KDTE_rec_ptr       p_kdt,
                          CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                          CTSAMSG_HANDLE_rec_ptr     p_msgs)
{
 
    static char func[] = "ADDINFO_mkt_check";
 
   /*
    *   Variables
    */
 
    ESA_RC               rc = ESA_OK;
    ONE_FIELD_rec_ptr    cpair;
    ADDINFO_KDTE_rec_ptr cdesc;
    short                i;
 
   /*
    *   Initialize
    */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 2, func);
 
    if ( ( p_addinfo EQ NULL ) OR
         ( p_numaddi EQ 0    )  )
       goto exit;
 
   /*
    *    Check for mandatory parameters
    */
 
    while ( *(p_mkte->kwd) NE NULL_CHAR ) {
 
        /* mandatory keyword not supplied */
 
        cpair = NULL;
        for (i=0; i LT p_numaddi; i++)
            if (p_addinfo[i] NE NULL) {
               cpair = ADDINFO_search(p_mkte->kwd,
                                      sizeof(p_mkte->kwd),
                                      p_addinfo[i]->pair,
                                      p_addinfo[i]->num_pairs);
               if (cpair NE NULL)
                  break;
            } /* addinfo buffer exists */
 
        /* mandatory keyword not supplied */
 
        if ( cpair EQ NULL ) {
           CTSAMSG_print(RACF_MANDATORY_MISS,   p_msgs, NULL, p_dest,
                         p_mkte->kwd );
           rc = ESA_ERR;
        }
 
        /* mandatory keyword has no value */
 
        else {
           cdesc = ADDINFO_kdt_search(p_mkte->kwd,p_kdt);
           if (cdesc NE NULL ) {
              if ( (*(cpair->value)   EQ NULL_CHAR)  AND
                   (cdesc->type       EQ KDT_KEY  )  AND
                   (*(cdesc->neg_kwd) EQ NULL_CHAR)      ) {
                   CTSAMSG_print(RACF_MANDATORY_EMPTY,   p_msgs, NULL,
                                 p_dest, p_mkte->kwd );
                 rc = ESA_ERR;
 
              } /* parameter empty */
           } /* kdte located */
        } /* mandatory keyword specified */
 
        p_mkte++;
    }
 
   /*
    *    finish
    */
 
    exit:;
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 2, func, rc);
 
    return rc;
}
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_rkt_check adies22                  *
*                                                             *
* DESCRIPTION    : Verify that no reserved keywords are used  *
*                                                             *
* INPUT          : func          - function name              *
*                  numaddi       - addinfo buffer             *
*                  addinfo       - addinfo vector pointer     *
*                  rkte          - RKTE to start with         *
*                  p_dest        - Vector of error msg dests  *
*                  p_msgs        - Error messages buffer      *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_rkt_check(char                         *p_func,
                            short                      p_numaddi,
                            ADDINFO_rec_ptr           *p_addinfo,
                            ADDINFO_RKTE_rec_ptr       p_rkte,
                            CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                            CTSAMSG_HANDLE_rec_ptr     p_msgs)
{
 
  static char func[] = "ADDINFO_rkt_check";
 
 /*
  *  Variables
  */
 
  ESA_RC               rc = ESA_OK;
  short                i;
  ONE_FIELD_rec_ptr    cpair;
  ADDINFO_RKTE_rec_ptr pw_rkte;
 
 /*
  *  Initialize
  */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
 /*
  *   Check that KWD was not specified in addinfo
  */
 
  for (i=0; i LT p_numaddi; i++) {
      if (p_addinfo[i] NE NULL) {
         for (pw_rkte = p_rkte; *pw_rkte->kwd NE NULL_CHAR; pw_rkte++)
         {
             cpair = ADDINFO_search((char *)pw_rkte->kwd,
                                    sizeof(pw_rkte->kwd),
                                    p_addinfo[i]->pair,
                                    p_addinfo[i]->num_pairs);
             ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
                             "keyword=%s at %X", pw_rkte->kwd,cpair);
             if (cpair NE NULL) {
                CTSAMSG_print(RACF_KEYWORD_RESVD,   p_msgs, NULL,
                              p_dest, pw_rkte->kwd);
                rc = ESA_ERR;
                goto exit;
             } /* reserved keyword found */
          }     /* keywords loop */
      } /* addinfo buffer exists */
  }
 
 /*
  *  finish
  */
 
  exit:  ;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc );
  return rc;
 
}
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_concat adies23                     *
*                                                             *
* DESCRIPTION    : Concatenate Additional Info buffers to     *
*                  command buffer                             *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
ESA_RC ADDINFO_concat( char                      *p_func,
                       char                      *p_cmd,
                       short                      p_numaddi,
                       ADDINFO_rec_ptr           *p_addinfo,
                       ADDINFO_KDTE_rec_ptr       p_kdt,
                       CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                       CTSAMSG_HANDLE_rec_ptr     p_msgs)
{
 
  static char func[] = "ADDINFO_concat";
  ADDINFO_PKB_rec_typ  pkb_vec[ADDINFO_MAX_PKB];
  int                  i;
  int                  ks = 0;                            /* WS10082N */
  char                 msgbuf[256] = "";                  /* WS10082N */
  ESA_RC               rc = ESA_OK;
 
  /***************************************************************
  *    Initialize
  ***************************************************************/
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 2, func);
 
  /*
   *   Initialize PKBs (Primary Keyword Buffers)
   */
 
  for (i=0; i LT ADDINFO_MAX_PKB; i++) {
       pkb_vec[i].no_pkb = 0;
       strcpy(pkb_vec[i].name, NULL_STRING);
       pkb_vec[i].buff = NULL;
       pkb_vec[i].size = ADDINFO_MAX_PKB_LEN;
  }
 
  if ( ( p_addinfo EQ NULL ) OR
       ( p_numaddi EQ 0    )  )
    goto exit;
 
  /***************************************************************
  *    Scan Additional Info Table                                *
  ***************************************************************/
 
  for (i=0; i LT p_numaddi; i++)
      if (p_addinfo[i] NE NULL) {
         rc = ADDINFO_concat_one( p_func, p_cmd, pkb_vec, p_addinfo[i],
                                  p_kdt, p_dest, p_msgs);
         if (rc NE ESA_OK)
            goto exit;
      }
 
  /****************************************************************
  *    Concatenate PKBs to command                                *
  ****************************************************************/
 
  for (i=0; i LT ADDINFO_MAX_PKB; i++) {
      if (pkb_vec[i].buff NE NULL) {
 
         ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,  "%d f=%d b=%s",
                         i, pkb_vec[i].no_pkb , pkb_vec[i].buff);
 
         if (pkb_vec[i].no_pkb EQ 0) {
            if (strlen(pkb_vec[i].buff) GT 0) {
               /* WS10082N - start */
               ks = strlen(p_cmd) + strlen(pkb_vec[i].buff) + 3;
               if (ks  GE  MAX_CMD_LEN)
               {
                 SEND_CMD_TOO_LONG_MSG(msgbuf, pkb_vec[i].name,
                                       ks, "cmd",
                                       p_msgs, p_dest, rc);
                 ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
             "Failed to add <%s> to cmd: pkblen=%d  cmdlen=%d+%d (%d)",
                    pkb_vec[i].name, ks, strlen(p_cmd), MAX_CMD_LEN);
                 break;
               };
               /* WS10082N - start */
               strcat(p_cmd,pkb_vec[i].name);
               strcat(p_cmd,"(");
               strcat(p_cmd,pkb_vec[i].buff);
               strcat(p_cmd,") ");
               ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                               "Loop:p_cmd=%s", p_cmd );
            }
            else break;
         }
      }
      else break;
  }
 
 /****************************************************************
 *    Free PKBs
 ****************************************************************/
 
  exit: ;
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,  "p_cmd=%s", p_cmd );
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                  "Termination cleanup started");
  for (i=0; i LT ADDINFO_MAX_PKB; i++) {
      if (pkb_vec[i].buff NE NULL) {
         ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                         "Buffer %d, at %X size=%d buf=%s",
                         i,pkb_vec[i].buff,pkb_vec[i].size,
                         pkb_vec[i].buff NE NULL);
         free(pkb_vec[i].buff);
      }
      else
        ESA_DIAG_printf(ESA_COMP_API_ADDINFO,8,
                        "Buffer %d, nothing to free",i);
  }
 
  /****************************************************************
  *    finish
  ****************************************************************/
 
  ADDINFO_convert_list_sep( p_cmd,
                            ADDINFO_LIST_ENTRY, ADDINFO_LIST_SUBFIELD,
                            ',', ',' );
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 2, func, rc );
  return rc;
 
}
 
 /* WS10082 note:
 List functions adies24 thru adies28 implemented in ESAADIL */
 
 /* WS10082 SPI functions which are copied from CTSCADI */
 
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_masupd adies61                     *
 *                                                             *
 * DESCRIPTION    : Massive updates of field in addinfo_to by  *
 *                  values of same_name fields in addinfo_from *
 *                                                             *
 * RETURN VALUE   : NONE                                       *
 *                                                             *
 **************************************************************/
 
void ADDINFO_masupd(ADDINFO_rec_ptr              addinfo_to,
                    ADDINFO_rec_ptr              addinfo_from,
                    ADDINFO_masupd_mode          mode,
                    CTSAMSG_DEST_TABLE_rec_typ * dest,
                    CTSAMSG_HANDLE_rec_typ     * msgs)
{
  ONE_FIELD_rec_ptr pair_from, pair_to;
  static  char    func[]="ADDINFO_masupd";
  ESA_RC     rc = ESA_OK;                                 /* WS10082N */
  char       msgbuf[256] = "";                            /* WS10082N */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO ,1,func);
 
  if ( (addinfo_to->num_pairs EQ 0)  OR
       (addinfo_from->num_pairs EQ 0) )
    goto exit;
 
  pair_from = addinfo_from->pair;
 
  while (pair_from NE NULL)
   {
    pair_to = ADDINFO_search(pair_from->keyword,
                        MAX_RSS_ADDINFO_KWD_LEN,
                        addinfo_to->pair,
                        addinfo_to->num_pairs );
    if (pair_to NE NULL)
     /* WS10082N
     ADDINFO_updval(pair_from->value, MAX_RSS_ADDINFO_VAL_LEN, pair_to);
     */
     rc = ADDINFO_updval(pair_from->value,                /* WS10082N */
                     MAX_RSS_ADDINFO_VAL_LEN, pair_to);   /* WS10082N */
    else
    if (mode EQ ADDINFO_masupd_Merge)
     /* WS10082N EADDINFO_insert(pair_from->add_typ, */
     rc = ADDINFO_insert(pair_from->add_typ,              /* WS10082N */
                    pair_from->keyword,
                    pair_from->value,
                    addinfo_to,
                    MAX_RSS_ADDINFO_KWD_LEN,
                    MAX_RSS_ADDINFO_VAL_LEN,
                    UNIQUE);
    /* WS10082N - start */
    if (rc NE ESA_OK)
    {
       snprintf(msgbuf, sizeof(msgbuf),
               "%s for keyword <%s> failed with rc <%s>",
                (pair_to EQ NULL ? "Insert" : "Update value"),
                pair_from->keyword, ESA_rc2str(rc));
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
    }
    /* WS10082N - end   */
 
    pair_from=ADDINFO_get_next(addinfo_from,pair_from);
   }
 
  exit:;
 
  ESA_DIAG_exit( ESA_COMP_API_ADDINFO ,1, func, ESA_OK);
}
 
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_expand_from_buffer adies62         *
 *                                                             *
 * DESCRIPTION    : build addinfo object from a buffer of      *
 *                  null-terminated pairs (kwd,type,value).    *
 *                                                             *
 * RETURN VALUE   : NONE                                       *
 *                                                             *
 **************************************************************/
 
ESA_RC ADDINFO_expand_from_buffer (char *buffer,
                                  int  buffer_length,
                                  ADDINFO_rec_ptr addinfo)
{
  static  char    func[]="ADDINFO_expand_from_buffer";
 
  char *Kwd_Begin, *Value_Begin, *Type_Begin;
  int  Kwd_Length, Value_Length, Type_Length, buffer_loc = 0;
  ADDINFO_typ Type;
  char   msgbuf[256] = "";                                /* WS10082N */
  ESA_RC rc = ESA_OK;
  ESA_RC ins_rc = ESA_OK;                                 /* WS10082N */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO ,1,func);
 
  if ( (buffer_length LE 0) OR ((*buffer) EQ NULL_CHAR) )
   {
    /* WS10082N - start */
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  "No input buffer", func);
    /* WS10082N - start */
    rc = ESA_ERR;
    goto exit;
   };
 
  while (buffer_loc LT buffer_length)
   {
    Kwd_Begin = buffer + buffer_loc;
    Kwd_Length = strlen(Kwd_Begin);
    Type_Begin = Kwd_Begin + Kwd_Length + 1;
    Type_Length = strlen(Type_Begin);
    Value_Begin = Type_Begin + Type_Length + 1;
    Value_Length = strlen(Value_Begin);
 
    if (strcmp(Type_Begin,"1A") EQ 0)
     Type = TYPE_1A;
    else
    if (strcmp(Type_Begin,"1B") EQ 0)
     Type = TYPE_1B;
    else
    if (strcmp(Type_Begin,"2A") EQ 0)
     Type = TYPE_2A;
    else
    if (strcmp(Type_Begin,"2B") EQ 0)
     Type = TYPE_2B;
    else
     {
       /* WS10082N - start */
       snprintf(msgbuf, sizeof(msgbuf),
               "Invalid type %s for keyword %s", Type_Begin, Kwd_Begin);
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
       /* WS10082N - end   */
      rc = ESA_ERR;
      goto exit;
     };
 
    /* WS10082N ADDINFO_insert(Type,   */
    ins_rc = ADDINFO_insert(Type,                         /* WS10082N */
                  Kwd_Begin,
                  Value_Begin,
                  addinfo,
                  MAX_RSS_ADDINFO_KWD_LEN,
                  MAX_RSS_ADDINFO_VAL_LEN,
                  MULTIPLE);
    /* WS10082N - start */
    if (ins_rc NE ESA_OK)
    {
      snprintf(msgbuf, sizeof(msgbuf),
            "Insert of keyword <%s> to addinfo failed with rc <%s>. ",
             Kwd_Begin, ESA_rc2str(rc));
      strncat(msgbuf, SEE_PRTDBG_MSG,
                               sizeof(msgbuf)-strlen(msgbuf));
      CTSAMSG_print(ERR_ADI_PROC_ERROR,
                 NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf, func);
    }
    if (ins_rc GT rc)   rc = ins_rc;
    /* WS10082N - end   */
 
    buffer_loc += Kwd_Length + Type_Length + Value_Length + 3;
   };
 
  exit:;
 
  ESA_DIAG_exit( ESA_COMP_API_ADDINFO ,1, func, rc);
 
  return rc;
}
 
 /**************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_pack_to_buffer adies63             *
 *                                                             *
 * DESCRIPTION    : build a buffer of null-terminated strings  *
 *                  from addinfo object.                       *
 *                                                             *
 * RETURN VALUE   : NONE                                       *
 *                                                             *
 **************************************************************/
 
ESA_RC ADDINFO_pack_to_buffer (char *buffer,
                              int  buffer_length,
                              ADDINFO_rec_ptr addinfo,
                              int  *actual_buffer_length)
{
  static  char    func[]="ADDINFO_pack_to_buffer";
 
  ONE_FIELD_rec_ptr pair = NULL;
  int i, buffer_loc = 0;
  char Type[2];
  char  msgbuf[256] = "";                                 /* WS10082N */
  ESA_RC rc = ESA_OK;
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO,1,func);
 
  for(i=0;i LT addinfo->num_pairs;i++)
   {
    /* WS10082N pair = ADDINFO_get_next(addinfo,pair);  */
    pair = ppairi(addinfo->pair, i); /* get real pair        WS10082N */
 
    if ((buffer_loc + strlen(pair->keyword) + strlen(pair->value) + 32)
                     GT buffer_length)
      {
       /* WS10082N - start */
       snprintf(msgbuf, sizeof(msgbuf),
               "No space in buffer for keyword <%s> (%d+%d+%d+32 > %d)",
               pair->keyword,
               buffer_loc, strlen(pair->keyword), strlen(pair->value),
               buffer_length);
       CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
       /* WS10082N - end   */
       rc = ESA_ERR;
       goto exit;
      };
 
    memcpy(buffer + buffer_loc,pair->keyword,
                               strlen(pair->keyword)+1);
    buffer_loc += strlen(pair->keyword) +1;
 
    switch(pair->add_typ)
     {
      case TYPE_1A: strcpy(Type,"1A");
                    break;
      case TYPE_1B: strcpy(Type,"1B");
                    break;
      case TYPE_2A: strcpy(Type,"2A");
                    break;
      case TYPE_2B: strcpy(Type,"2B");
                    break;
      default:
         /* WS10082N ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,  */
         snprintf(msgbuf, sizeof(msgbuf),                /* WS10082N */
                         "Bad ADDINFO type %d for field %s",
                         pair->add_typ,pair->keyword);
         /* WS10082N - start */
         CTSAMSG_print(ERR_ADI_PROC_ERROR,
                    NULL, NULL,
                    ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                    msgbuf, func);
         /* WS10082N - end   */
         rc = ESA_ERR;
         goto exit;
     };
 
    memcpy(buffer + buffer_loc,Type,strlen(Type)+1);
    buffer_loc += strlen(Type) +1;
 
    memcpy(buffer + buffer_loc,pair->value,strlen(pair->value)+1);
    buffer_loc += strlen(pair->value) +1;
   };
 
  (*actual_buffer_length) = buffer_loc;
 
  exit:;
 
  ESA_DIAG_exit( ESA_COMP_API_ADDINFO ,1, func, rc);
  return rc;
}
 
/* ps0292 Digital certificate functions */
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert_nonstr         adies64      *
*                                                             *
* DESCRIPTION    : Insert a keyword in additional info        *
*                  with non-string data.                      *
*                  previously called _dgt.         WS10082N   *
*                                                             *
* INPUT          : type             -  addinfo type           *
*                  kwd              -  keyword                *
*                  value            -  value                  *
*                  addinfo          -  additional info        *
*                  dupflag          -  allow duplicate flag   *
*                  add_term         -  add string terminator  *
*                                      (Y/N)                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
 
/* WS10082N ESA_RC ADDINFO_insert_dgt(ADDINFO_typ           type,  */
ESA_RC ADDINFO_insert_nonstr(ADDINFO_typ        type,   /* WS10082N */
                            char               *kwd,
                            char               *val,
                            int                 vallen,
                            ADDINFO_rec_ptr     addinfo,
                            int                 max_kwdlen,
                            int                 max_vallen,
                            ADDINFO_DUPLICATE   dupflag,
                            int                 add_term)  /*WS10082N*/
 
 {
 
   /*
    *  Variables
    */
 
    /* WS10082N static char func[] = "ADDINFO_insert_dgt"; */
    static char func[] = "ADDINFO_insert_nonstr";         /* WS10082N */
    int i=0;
    int kwdlen;
    ONE_FIELD_rec_ptr cpair = NULL;
    ESA_RC rc = ESA_OK ;
    char   msgbuf[256] = "";                              /* WS10082N */
 
   /*
    *  initialize
    */
 
    ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 2, func);
 
    /* WS10082N - start */
 
    /* The code below is replaced with a call to ADDINFO_insert   *
     *            to insert the keyword without a value           *
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                    "num_pairs = %d, max_pairs = %d",
                    addinfo->num_pairs,addinfo->max_pairs);
 
    if (addinfo->num_pairs GE addinfo->max_pairs) {
       /@ rc = ESA_ERR; - deleted  AS0207 @/
       rc = ESA_FATAL; /@ added    AS0207 @/
       goto exit;
    }
 
   /@
    *  Validity checks
    @/
 
    kwdlen =strlen(kwd);
    if ((kwdlen EQ 0) OR (kwdlen GT max_kwdlen)) {
       rc = ESA_FATAL;
       goto exit;
    }
 
    if (vallen GT max_vallen) {
       rc = ESA_FATAL;
       goto exit;
    }
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                    "Keyword=(%3d)'%s' Value=(%3d)'%s'",
                    kwdlen,kwd,vallen,val);
 
   /@
    *  Verify that keyword is not yet used
    @/
 
    cpair = addinfo->pair;
    while (i LT addinfo->num_pairs) {
 
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                       i,cpair,
                       "Entry %d,%X: kwd=%s(%3d),val=%s(%3d)",
                       cpair->keyword,cpair->keylen,
                       cpair->value,cpair->vallen);
 
       if (dupflag EQ UNIQUE)
          if (strcmp(cpair->keyword,kwd) EQ 0) {
             rc = ESA_ERR;
             goto exit;
          }
       cpair++;
       i++;
 
    } /@ while @/
 
   /@
    *    Add the Keyword
    @/
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                    "Updating entry at %d,%X", i,cpair);
 
    cpair->add_typ = type;
    cpair->keylen = kwdlen;
    strcpy(cpair->keyword,kwd);
    addinfo->num_pairs++;
 
    ADDINFO_updval_dgt(val,vallen, max_vallen,cpair);
       end of replaced code   */
 
 
    rc = ADDINFO_insert(type,
                        kwd,
                        "",
                        addinfo,
                        MAX_RSS_ADDINFO_KWD_LEN,
                        MAX_RSS_ADDINFO_VAL_LEN,
                        dupflag);
    if (rc EQ ESA_OK)
    {
      cpair = &addinfo->pair[addinfo->num_pairs-1]; /* -> last pair */
      if (vallen GT 0)
        /*    Update the value   */
        rc = ADDINFO_updval_nonstr(val,vallen, max_vallen,cpair,
                                   add_term);
    };
 
    /* If error in insert or updval- issue a message */
    if (rc NE ESA_OK)
    {
      snprintf(msgbuf, sizeof(msgbuf),
            "%s keyword <%s> failed with rc <%s>. ",
             (cpair EQ NULL ? "Insert of" : "Updval for"),
             kwd, ESA_rc2str(rc));
      CTSAMSG_print(ERR_ADI_PROC_ERROR,
                   NULL, NULL,
                   ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                   msgbuf, func);
    };
    /* WS10082 - end  */
 
 
   /*
    *    Finish
    */
    exit: ;
 
    ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 2, func, rc);
 
    return rc;
 
  }
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_updval_nonstr adies65              *
*                                                             *
* DESCRIPTION    : Update a value of an exiting entry         *
*                  with non-string data.                      *
*                  previously called _dgt.         WS10082N   *
*                                                             *
* INPUT          : value     - Value to be updated            *
*                  pair      - Addinto entry                  *
*                  add_term  -  add string terminator (Y/N)   *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
**************************************************************/
/* WS10082N ESA_RC ADDINFO_updval_dgt (char              *addval, */
ESA_RC ADDINFO_updval_nonstr (char              *addval,  /* WS10082N */
                              int                in_vallen,
                              int                max_vallen,
                              ONE_FIELD_rec_ptr  pair,
                              int                add_term) /*WS10082N*/
{
 
 /*
  *  Variables
  */
 
  ESA_RC rc = ESA_OK;
  /* static char func[] = "ADDINFO_updval"; WS10082 */
  static char func[] = "ADDINFO_updval_nonstr"; /* WS10082N */
  int         vallen = 0;                    /* WS10082N */
  ONE_FIELD_rec_ptr  tpair;                  /* WS10082K */
  char        msgbuf[256] = "";                           /* WS10082N */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
  /* Lets get the real pair if exists */
  tpair = get_pair(pair);      /* tpair -> real pair       WS10082K */
  ESA_DIAG_printf (ESA_COMP_API_ADDINFO,1,              /* WS10082K */
                 "tpair is - %p (SLType - %c)",         /* WS10082K */
                 tpair, tpair->SLType);                 /* WS10082K */
 
  /* WS10082N - start */
  tpair->twin->addval_msg = tpair->addval_msg = 'N';
 
  if (add_term EQ 'Y')
    vallen = in_vallen + 1;
  else
    vallen = in_vallen;
 
  /*  If there is a long pair and the value is either too     *
   *  long (error) or has can fit in a small pair - free the  *
   *  long pair.                                              */
 
  if ( (tpair->SLType EQ 'L')   AND
         ( (vallen  LE ADDINFO_SHORT_VAL_LEN)  OR
            (vallen GE ADDINFO_LARGE_VAL_LEN) ) )
  {
     tpair = tpair->twin;  /* tpair should point to small pair */
     ADDINFO_free_twin_pair(tpair, 1);  /* free twin pair  */
     if (rc NE ESA_OK)
     {
        snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_free_twin_pair for <%s> failed with rc <%s>",
                 tpair->keyword, ESA_rc2str(rc));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                      NULL, NULL,
                      ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                      msgbuf, func);
        rc = ESA_ERR;
        goto exit;
     };
  }
  /* WS10082N - end  */
 
 /*
  *  Enough place for value ?
  */
  /* WS10082K if ( vallen GE max_vallen) {                         */
  if ( vallen GE ADDINFO_LARGE_VAL_LEN ) {  /* WS10082K */
    /* WS10082N - start  */
    snprintf(msgbuf, sizeof(msgbuf),
        "vallen (%d) for keyword <%s> is greater than max alloawd (%d)",
         vallen, tpair->keyword, ADDINFO_LARGE_VAL_LEN);
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                   NULL, NULL,
                   ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                   msgbuf, func);
    ADDINFO_INIT_PAIR(tpair, tpair->index, 0);
    /* WS10082N - end    */
    rc = ESA_FATAL;
    goto exit;
  }
 
 /*
  *  update value
  */
 
  /* WS10082K - Start   */
 
  /* Check if the value is more than 1K and requires large  *
  *  pair. Else point to correct pair before updating value */
  if( (tpair->SLType EQ 'S')  AND
       (vallen GT ADDINFO_SHORT_VAL_LEN) )
  {
     rc = ADDINFO_alloc_twin_pair(tpair);
     if(rc NE ESA_OK)
     {
        /* WS10082N - start */
        snprintf(msgbuf, sizeof(msgbuf),
                 "ADDINFO_alloc_twin_pair for <%s> failed with rc <%s>",
                 tpair->keyword, ESA_rc2str(rc));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                      NULL, NULL,
                      ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                      msgbuf, func);
        ADDINFO_INIT_PAIR(tpair, tpair->index, 0);
        /* WS10082N - end */
        rc = ESA_ERR;
        goto exit;
     }
     /* pair should point to large pair */
     tpair = tpair->twin;
 
  }
 
  /* WS10082K - End */
 
  /* WS10082N memcpy(tpair->value, addval, vallen);  */
  /* WS10082N tpair->vallen = vallen;                */
  memcpy(tpair->value, addval, in_vallen);                /* WS10082N */
  if (add_term EQ 'Y')                                    /* WS10082N */
    tpair->value[in_vallen] = NULL_CHAR;                  /* WS10082N */
  tpair->vallen = in_vallen;                              /* WS10082N */
 
  /* WS10082K - Lets update the value at short pair */
  if(tpair->SLType EQ 'L')                       /* WS10082K */
     tpair->twin->vallen = tpair->vallen;        /* WS10082K */
 
 /*
  *  finish
  */
 
  exit:;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
  return rc;
 
}
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_split_by_prefix adies68            *
*                                                             *
* DESCRIPTION    : split the addinfo to 2 or more addinfos:   *
*                  - entries matching the prefix are copied   *
*                    to to_prefix.                            *
*                  - all other entries are copied to          *
*                    to_general.                              *
*                                                             *
* INPUT          : from - input addinfo.                      *
*                  to_prefix_num - number of addinfos in      *
*                                  to_prefix vector.          *
*                                  The last addinto may       *
*                                  have a different number    *
*                                  of pairs.                  *
*                  prefix - prefix for split.                 *
*                                                             *
* OUTPUT         : to_general - addinfo for non-prefix        *
*                               entries.                      *
*                  to_prefix - vector of pointers to addinfos *
*                              for prefix entries.            *
*                                                             *
* RETURN VALUE   : ESA_OK - when all OK.                      *
*                  ESA_ERR - when output overflow.            *
*                                                             *
*                                                             *
* *** ATTEMTION  : This function does not support splitting   *
*                  addinfo contsining non-string digital      *
*                  certificate attributes.                    *
*                                                             *
*                                                             *
**************************************************************/
ESA_RC  ADDINFO_split_by_prefix(ADDINFO_rec_ptr      from,
                                ADDINFO_rec_ptr  to_general,
                                ADDINFO_rec_ptr *to_prefix,
                                int              to_prefix_num,
                                char            *prefix)
{
 
  static char func[] = "ADDINFO_split_by_prefix";
 
  ESA_RC rc = ESA_OK;
  ONE_FIELD_rec_ptr pair = NULL;
  int    i;
  int    j;
  char   msgbuf[256] = "";                                /* WS10082N */
  char   char_addinfo[10] = "";                      /* WS10082N */
  ADDINFO_rec_ptr out;
 
  /*
   *  Initialization
   */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "FROM at %X, used %d  max %d",
                  from,from->num_pairs,from->max_pairs);
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "TO-general at %X,  max %d",
                  to_general,to_general->max_pairs);
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "TO-prefix vec at %X, num %d  max %d",
                  to_prefix, to_prefix_num, to_prefix[0]->max_pairs);
 
  /*
   *  verify output large enough
   *
   *  Note: The last addinfo in the to_prefix vector may have a
   *        different number of pair than the other addinfos in
   *        vector.
   */
 
  if ( ( (to_prefix[0]->max_pairs * (to_prefix_num - 1)) +
       to_prefix[to_prefix_num - 1]->max_pairs  +
       to_general->max_pairs)    LT
       from->num_pairs )
  {
    /* WS10082N - start */
    snprintf(msgbuf, sizeof(msgbuf),
   "Not snough pairs in the output addinfos ((%d * %d) + %d + %d > %d)",
             to_prefix[0]->max_pairs, to_prefix_num - 1,
             to_prefix[to_prefix_num - 1]->max_pairs,
             to_general->max_pairs, from->num_pairs);
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                 NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf, func);
    /* WS10082N - end   */
    rc = ESA_ERR;
    goto exit;
  }
 
  /*
   *  Split the addinfo by prefix.
   */
  j = 0;
 
  for (i = 0 ; i < from->num_pairs  AND  j LT to_prefix_num; i++)
  {
    /* WS10082N pair = ADDINFO_get_next(from, pair);   */
    pair = ppairi(from->pair, i); /* get real pair        WS10082N */
    if (pair NE NULL)
    {
      if ( memcmp(pair->keyword, prefix, strlen(prefix)) EQ 0 )
      {
        if (to_prefix[j]->num_pairs GE to_prefix[j]->max_pairs)
          if (++j GE to_prefix_num)
          {
            /* WS10082N - start */
            snprintf(msgbuf, sizeof(msgbuf),
                    "To addinfos exhausted (%d > %d)",
                    j, to_prefix_num);
            CTSAMSG_print(ERR_ADI_PROC_ERROR,
                    NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf, func);
            /* WS10082N - end   */
            rc = ESA_ERR;
            break;
          }
 
        out = to_prefix[j];
      }
      else
        out = to_general;
 
      /* Insert_dgt is used in order to support non-string values. */
      ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "copy keyword %s to addinfo at %8X",
                  pair->keyword, out);
      rc = ADDINFO_insert(pair->add_typ, pair->keyword,
                          pair->value, out,
                          RCF_ADDINFO_KWD_LEN, RCF_ADDINFO_VAL_LEN,
                          UNIQUE);
      ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "keyword %s was copied to addinfo at %8X",
                  pair->keyword, out);
      if (rc NE ESA_OK)
      {
        /* WS10082N - start */
 
        /* ESA_DIAG_printf(PLT_COMP_API_ADDINFO, 0,
          "Insert of keyword %s(%s)to addinfo at %8X failed with rc %d",
          pair->keyword, pair->value, out, rc);   */
 
        if (out EQ to_general)
          strcpy(char_addinfo, "GENERAL");
        else
          sprintf(char_addinfo, "TO(%d)", j);
 
        snprintf(msgbuf, sizeof(msgbuf),
         "Insert of keyword <%s> to <%s? addinfo failed with rc <%s>. ",
           pair->keyword, char_addinfo, ESA_rc2str(rc));
        strncat(msgbuf, SEE_PRTDBG_MSG,
                sizeof(msgbuf) - strlen(msgbuf));
        CTSAMSG_print(ERR_ADI_PROC_ERROR,
                 NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf, func);
        ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
                 "Insert failed for keyword <%s>, value=(%d)%*.100s",
                 pair->keyword, pair->vallen, pair->value);
 
        /* WS10082N rc = ESA_FATAL;   */
      }
    }
  }
 
  /*
   *  return
   */
 
 exit: ;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
 
  return rc;
 
}  /*  ADDINFO_split_by_prefix      */
/* WS10082 - new routines - start   */
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_count_by_prefix adies69            *
*                                                             *
* DESCRIPTION    : Count the number of entries with a         *
*                  specific prefix.                           *
*                                                             *
* INPUT          : addinfo - ut addinfo.                      *
*                  prefix - prefix for count.                 *
*                  prefix_with_data - count only pairs with   *
*                                     data (TRUE) or all      *
*                                     (FALSE).                *
*                  other_with_data - count only pairs with    *
*                                    data (TRUE) or all       *
*                                    (FALSE).                 *
*                                                             *
* OUTPUT         : prefix_num - number of entries with        *
*                               prefix.                       *
*                  other_num - number of other entries.       *
*                                                             *
* RETURN VALUE   :                                            *
*                                                             *
**************************************************************/
void  ADDINFO_count_by_prefix(ADDINFO_rec_ptr      addinfo,
                              char            *prefix,
                              int             *prefix_num,
                              int             *other_num,
                              int              prefix_with_data,
                              int              other_with_data)
{
 
  static char func[] = "ADDINFO_count_by_prefix";
 
  ONE_FIELD_rec_ptr pair = NULL;
  int    i;
  int    p_num, o_num;
  int    prefix_len = strlen(prefix);
 
  /*
   *  Initialization
   */
 
  ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 1, func);
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "addinfo at %X, used %d  max %d",
                  addinfo,addinfo->num_pairs,addinfo->max_pairs);
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
                  "Prefix = %s", prefix);
 
  p_num = 0;
  o_num = 0;
 
  for (i = 0; i LT addinfo->num_pairs; i++)
  {
    pair = &addinfo->pair[i];
 
    if ( (pair->keylen GT prefix_len)   AND
         (memcmp(pair->keyword, prefix, prefix_len) EQ 0) )
      if ( NOT prefix_with_data   OR
          ( prefix_with_data  AND  pair->vallen GT 0) )
        p_num++;
    else
      if ( NOT other_with_data   OR
          ( other_with_data  AND  pair->vallen GT 0) )
        o_num++;
  }
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 5,
              "There are %d prefix entries and %d general entries",
              p_num, o_num);
 
  *prefix_num = p_num;
  *other_num = o_num;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, ESA_OK);
 
}
 
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_concat_one                         *
*                                                             *
* DESCRIPTION    : Concatenate an Additional Info buffer to   *
*                  command buffer                             *
*                                                             *
* INPUT          :                                            *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
* WS10082:                                                    *
* =======                                                     *
* We verify that there is not overflow when putting the       *
* keyword and value in the command. We do not get the command *
* area length in this routine, but looking at the callers of  *
* ADDINFO_concat we see that all define the command area      *
* with length of API_MAX_ST so this is the length we use for\ *
* overflow verification.                                      *
* In the future we need to change ADDINFO_concat, this        *
* routines and all the callers to get/pass the command area   *
* length.                                                     *
*                                                             *
**************************************************************/
static ESA_RC ADDINFO_concat_one
                           (char                     *p_func,
                           char                      *p_cmd,
                           ADDINFO_PKB_rec_ptr        pkb_vec,
                           ADDINFO_rec_ptr            p_addinfo,
                           ADDINFO_KDTE_rec_ptr       p_kdt,
                           CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                           CTSAMSG_HANDLE_rec_ptr     p_msgs)
{
 
 static char              func[] = "ADDINFO_concat_one";
 ONE_FIELD_rec_ptr        cpair;
 int                      cnum;
 ADDINFO_KDTE_rec_ptr     cdesc;
 char                     pri_kwd[MAX_RSS_ADDINFO_KWD_LEN+1];
 char                     sec_kwd[MAX_RSS_ADDINFO_KWD_LEN+1];
 char                     pkb_desc[MAX_RSS_ADDINFO_KWD_LEN+1+80];
 
 int                      i, j, k;
 char                     *cpri;
 
 char                     temp_kwd[MAX_RSS_ADDINFO_KWD_LEN+1];
 /*WS10082K  char         temp_val[2*MAX_RSS_ADDINFO_VAL_LEN+1];*/
 char                     temp_val[MAX_CMD_LEN];   /* WS10082K */
 ADDINFO_KWD_typ          temp_type;
 ADDINFO_KWD_typ          orig_type;    /* ps0071 */
 ESA_RC                   rc = ESA_OK;
 int                      val2long = FALSE;               /* WS10082N */
 int                      count = 0;                      /* WS10082N */
 char                     msgbuf[256] = "";               /* WS10082N */
 
 /***************************************************************
 *    Initialize
 ***************************************************************/
 
 ESA_DIAG_enter(ESA_COMP_API_ADDINFO,1,"ADDINFO_concat_one");
 
 /***************************************************************
 *    loop on addinfo table
 ****************************************************************/
 
/*cpair = p_addinfo->pair;                                *WS10082K*/
 cnum  = 0;
 
 while (cnum LT p_addinfo->num_pairs) {
    cpair = ppairi(p_addinfo->pair, cnum); /* get real pair  WS10082N */
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                    "Keyword=%s Value='%.100s'",          /*WS10082K*/
                    cpair->keyword,cpair->value);
 
   /*
    *    Locate parameter description in KDT
    */
 
    /* WS10082N - move this command a bit down
    cdesc = ADDINFO_kdt_search(cpair->keyword, p_kdt);              */
 
    cdesc = NULL;                                        /* BS10146 */
    if (memcmp(cpair->keyword,"MFA.",4) EQ 0)            /* WS10081 */
       goto next_pair;                                   /* WS10081 */
 
    cdesc = ADDINFO_kdt_search(cpair->keyword, p_kdt);    /* WS10082N */
 
    if (cdesc EQ NULL) {
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,2,
                       "Keyword=%s not supporetd",
                       cpair->keyword);
       if ( cpair->add_typ EQ TYPE_1A  OR
            cpair->add_typ EQ TYPE_1B   )
          CTSAMSG_print(RACF_KEYWORD_NOSUPP,   p_msgs, NULL, p_dest,
                        cpair->keyword);
       goto next_pair;
    }
 
    strcpy(temp_kwd,cpair->keyword); /* Keyword      */
    temp_type=cdesc->type;           /* keyword type */
    orig_type=cdesc->type;           /* ps0071 */
 
    /* WS10082N - start */
    if (cpair->vallen GE sizeof(temp_val))
    {
      SEND_CMD_TOO_LONG_MSG(msgbuf, cpair->keyword, cpair->vallen,
                           "temp_val", p_msgs, p_dest, rc);
      ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
         "Failed to add %s to cmd: vallen=%d (%d) type=%d",
              cpair->keyword, cpair->vallen, sizeof(temp_val),
              orig_type);
      break;
    };
    /* WS10082N - end   */
 
    if ( temp_type EQ KDT_KEYG )  {        /* spr125 */
       strcpy( temp_val, cpair->value );   /* spr125 */
       temp_type = KDT_KEY;                /* spr125 */
       cdesc->type = KDT_KEY;              /* spr125 */
    }                                      /* spr125 */
    else if ( temp_type EQ KDT_KEYM ) {                   /* PS0349 */
     /*
      *    Add quotes for each value in multivalued field
      */
 
      /* WS10082N - start */
      /* Check if enough space for the value + quates.     *
       * count starts form 2 for the quates we put at      *
       * beginning and at the end.                         */
      k = strlen(cpair->value);
      for (i = 0, count = 2; i LT k; i++)
        if (cpair->value[i] EQ ADDINFO_LIST_ENTRY)
          count+=2;
 
      if ( (cpair->vallen + count) GE sizeof(temp_val) )
      {
        SEND_CMD_TOO_LONG_MSG(msgbuf, cpair->keyword, cpair->vallen,
                              "temp_val", p_msgs, p_dest, rc);
        ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
         "Failed to add %s to cmd: vallen=%d  count=%d (%d) type=%d",
                cpair->keyword, cpair->vallen, count,
                sizeof(temp_val), orig_type);
        break;
      };
      /* WS10082N - end   */
 
      temp_type = KDT_KEY;                                /* PS0349 */
      cdesc->type = KDT_KEY;                              /* PS0349 */
                                                          /* PS0349 */
      /* WS10082N k = strlen(cpair->value);         /@ PS0349 @/   */
                                                          /* PS0349 */
      if (k NE 0) {                                       /* PS0352 */
        j = 1;                                            /* PS0349 */
                                                          /* PS0349 */
        temp_val[0] = QUOTE_CHAR;                         /* PS0349 */
                                                          /* PS0349 */
        for (i=0; i LT k; i++) {                          /* PS0349 */
             temp_val[j] = (cpair->value)[i];             /* PS0349 */
             if (temp_val[j] EQ ADDINFO_LIST_ENTRY) { /* PS0349 */
                temp_val[j] = QUATE_CHAR;                 /* PS0349 */
                temp_val[j+1] = ADDINFO_LIST_ENTRY;       /* PS0349 */
                temp_val[j+2] = QUATE_CHAR;               /* PS0349 */
                j=j+2;                                    /* PS0349 */
             }                                            /* PS0349 */
             j++;                                         /* PS0349 */
        }                                                 /* PS0349 */
        temp_val[j] = QUATE_CHAR;                         /* PS0349 */
        temp_val[j+1] = NULL_CHAR;                        /* PS0349 */
      }                                                   /* PS0352 */
      else                                                /* PS0352 */
        strcpy (temp_val,"");                             /* PS0352 */
    }                                                     /* PS0349 */
    else {                                 /* spr125 */
     /*
      *    Duplicate quates in value
      */
 
      j = 0;
      k = strlen(cpair->value);
 
      /* WS10082N - start */
      /* Check if enough space for the value + double quates.  */
      for (i = 0, count = 0; i LT k; i++)  /* Count the quates */
        if (cpair->value[i] EQ QUATE_CHAR)
          count++;
 
      if ( (cpair->vallen + count) GE sizeof(temp_val) )
      {
        SEND_CMD_TOO_LONG_MSG(msgbuf, cpair->keyword, cpair->vallen,
                              "temp_val", p_msgs, p_dest, rc);
        ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
         "Failed to add %s to cmd: vallen=%d  count=%d (%d) type=%d",
                cpair->keyword, cpair->vallen, count,
                sizeof(temp_val), orig_type);
        break;
      };
      /* WS10082N - end   */
 
      for (i=0; i LT k; i++) {
           temp_val[j] = (cpair->value)[i];
           if (temp_val[j] EQ QUATE_CHAR) {
              temp_val[j+1] = QUATE_CHAR;
              j++;
           }
           j++;
      }
      temp_val[j] = NULL_CHAR;
    }
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                    "Original value=%s New value=%s",
                    cpair->value, temp_val);
 
    if (cdesc->type EQ KDT_IGN)
       goto next_pair;
 
   /*
    *    Handle a KEYED parameter
    */
 
    if (( cdesc->type EQ KDT_KEY    ) AND
        ( temp_val[0] EQ NULL_CHAR  )) {
 
        strcpy(temp_kwd,cdesc->neg_kwd);
        temp_type = KDT_FLG ;
 
        ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                       "Keyed parameter '%s' was changed to flag '%s'",
                        cpair->keyword,cdesc->neg_kwd);
 
    } /* handle a keyed */
 
    /*
     *    Handle a KDT_FLG parameter
     */
 
    if (cdesc->type EQ KDT_FLG) {
       temp_type = KDT_FLG ;
 
       if      (strcmp(temp_val, KWD_FLAG_ON) EQ 0)
               strcpy(temp_kwd,cdesc->kwd);
 
       else if (strcmp(temp_val, KWD_FLAG_OFF) EQ 0 )
               strcpy(temp_kwd,cdesc->neg_kwd);
 
       else {
            ESA_DIAG_printf(ESA_COMP_API_ADDINFO,1,
                            "Flag %s value mismatch",
                            cpair->keyword, temp_val);
            CTSAMSG_print(RACF_UNDEF_OPTION, p_msgs, NULL, p_dest,
                           temp_kwd, temp_val );
            rc = ESA_ERR;
            goto exit;
       }
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                       "Flag parameter '%s' was set to '%s'",
                       cpair->keyword,temp_kwd);
 
    } /* handle a flag) */
 
    /*
     *     If no negative word was found, ignore the keyword
     */
 
    if (*temp_kwd EQ NULL_CHAR) {
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                       "Keyword=%s was ignored, no neg",
                       cpair->keyword);
       goto next_pair;
    }
 
    /*
     *  Primary keyword - concatenate to command buffer
     */
 
    cpri = strchr(temp_kwd,'.');
    if (cpri EQ NULL) {
 
       /* WS10082N - start */
       /* If not enough space for keyword in the command - fail */
       if (temp_type EQ KDT_KEY )
         count = strlen(temp_kwd) + strlen(cdesc->txtl) +
                  strlen(temp_val) + strlen(cdesc->txtr) + 1;
         else if (temp_type EQ KDT_FLG)
           count = strlen(temp_kwd) + 1;
           else count = 1;
 
       if (count+strlen(p_cmd) GE MAX_CMD_LEN)
       {
         SEND_CMD_TOO_LONG_MSG(msgbuf, cpair->keyword, cpair->vallen,
                               "cmd", p_msgs, p_dest, rc);
         ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
     "Failed to add %s to cmd: vallen=%d  cmdlen=%d+%d (%d) type=%d/%d",
               temp_kwd, cpair->vallen,
               strlen(p_cmd), count, MAX_CMD_LEN,
               orig_type, temp_type);
         break;
       };
       /* WS10082N - end   */
 
       if ( temp_type EQ KDT_KEY ) {
          if ( temp_val[0] NE NULL_CHAR) {
            strcat(p_cmd,temp_kwd);
            strcat(p_cmd,cdesc->txtl);
            strcat(p_cmd,temp_val);
            strcat(p_cmd,cdesc->txtr);
          }
          else
            CTSAMSG_print(RACF_KEYWORD_NOVALUE, p_msgs, NULL, p_dest,
                          temp_kwd );
       }
       else if (temp_type EQ KDT_FLG)
           strcat(p_cmd,temp_kwd);
 
       strcat(p_cmd," ");
 
    } /* of primary parameter */
 
    /*
     *  Secondary keyword - concatenate to appropriate PKB
     */
 
    else {
 
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                       "Keyword=%s at %X, sperator at %X",
                       temp_kwd,temp_kwd,cpri);
 
       /* Seperate the Primary and Secondary keywords */
 
       strncpy(pri_kwd,temp_kwd,cpri-temp_kwd); /* primary */
       pri_kwd[cpri-temp_kwd] = NULL_CHAR;      /* primary */
       strcpy(sec_kwd,cpri+1);                  /* secondary */
 
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,
                       "Primary=%s Secondary=%s",
                       pri_kwd,sec_kwd);
 
       /* locate the PKB of the primary keyword */
 
       for (i=0; i LT ADDINFO_MAX_PKB; i++) {
 
           ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
                           "%3d,Name=%s Buff at %X",
                           i,pkb_vec[i].name,pkb_vec[i].buff);
 
           if (  ( *(pkb_vec[i].name) EQ NULL_CHAR    ) OR
                 ( strcmp(pri_kwd,pkb_vec[i].name) EQ 0 ) )
              break;
       }
       if (i GE ADDINFO_MAX_PKB-1) {
          CTSAMSG_print(RACF_PKB_EXC,
                        p_msgs, NULL, p_dest,
                        p_func, ADDINFO_MAX_PKB, cpair->keyword);
          rc = ESA_ERR;
          goto exit;
       }
 
       /* If no PKB matched, allocate a new PKB */
 
       if ( *(pkb_vec[i].name) EQ NULL_CHAR ) {
          strcpy(pkb_vec[i].name,pri_kwd);
          pkb_vec[i].buff = malloc(pkb_vec[i].size);
          if (pkb_vec[i].buff EQ NULL) {
              sprintf(pkb_desc,"PKB (%d) FOR %s",i, cpair->keyword );
              CTSAMSG_print(ERR_MALLOC, p_msgs, NULL, p_dest,
                            pkb_desc, pkb_vec[i].size);
              rc = ESA_ERR;
              goto exit;
          } /* if */
          strcpy(pkb_vec[i].buff, NULL_STRING);
       } /* if */
 
       /* Add secondary keyword to PKB  */
 
       /* WS10082N - start */
       if ( temp_type EQ KDT_KEY )
         count = strlen(sec_kwd) + strlen(cdesc->txtl) +
                  strlen(temp_val) + strlen(cdesc->txtr) + 1;
         else if (temp_type EQ KDT_FLG)
           count = strlen(sec_kwd) + 1;
           else count = 1;
 
       if (count+strlen(pkb_vec[i].buff) GE pkb_vec[i].size)
       {
         SEND_CMD_TOO_LONG_MSG(msgbuf, cpair->keyword, cpair->vallen,
                               "PKB", p_msgs, p_dest, rc);
         ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 0,
     "Failed to add %s to PKB: vallen=%d  PKBlen=%d+%d (%d) type=%d/%d",
                sec_kwd,  strlen(temp_val), strlen(pkb_vec[i].buff),
                count, pkb_vec[i].size, orig_type, temp_type);
          break;
       };
       /* WS10082N - end   */
 
       if ( temp_type EQ KDT_KEY ) {
          if ( temp_val[0] NE NULL_CHAR ) {
            strcat(pkb_vec[i].buff,sec_kwd);
            strcat(pkb_vec[i].buff,cdesc->txtl);
            strcat(pkb_vec[i].buff,temp_val);
            strcat(pkb_vec[i].buff,cdesc->txtr);
          }
          else {
            CTSAMSG_print(RACF_KEYWORD_NOVALUE, p_msgs, NULL, p_dest,
                          temp_kwd );
          }
       }
       else if (temp_type EQ KDT_FLG) {
          strcat(pkb_vec[i].buff,sec_kwd);
          if (strcmp(sec_kwd, "NO_PKB") EQ 0 )
             pkb_vec[i].no_pkb = 1;
       }
 
       strcat(pkb_vec[i].buff," ");
       ESA_DIAG_printf(ESA_COMP_API_ADDINFO,3,  "%d f=%d b=%s",
                      i, pkb_vec[i].no_pkb , pkb_vec[i].buff);
    } /* of secondary parameter */
 
   /*
    *     Next ADDINDO pair
    */
 
    next_pair:;
 
    if (cdesc NE NULL)              /* ps0071 */
        cdesc->type = orig_type;    /* ps0071 */
    cnum++;
    /*WS10082 cpair++;                                          */
  }
 
  exit:;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
 
  return rc;
 
 }
 
/* WS10082 - end of routines copied from CTSCADI   */
 
/* WS10082 - new routines - start   */
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_alloc_twin_pair                    *
*                                                             *
* DESCRIPTION    : Add large pair to existing pair and update *
*                  required fields.                           *
*                                                             *
* INPUT          : pair     - short pair                      *
*                                                             *
* OUTPUT         : None.                                      *
*                  pair is updated with the appropriate data. *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************/
static ESA_RC ADDINFO_alloc_twin_pair( ONE_FIELD_rec_ptr  pair)
{
  static char        func[] = "ADDINFO_alloc_twin_pair";
  int                size = 0;
  ADDINFO_rec_ptr    addinfo_ptr;
  ONE_FIELD_rec_ptr  twin_pair, temp_pair;
  char               msgbuf[256] = "";                    /* WS10082N */
  ESA_RC             rc = ESA_OK;
 
  _FEEDBACK  fdbk;                                        /* WS10082N */
 
  ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 1, func);
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
                  "input pair = %p", pair);
 
  if(pair EQ NULL)
  {
                                                          /* WS10082N */
    CTSAMSG_print(ERR_ADI_PROC_ERROR,                     /* WS10082N */
                 NULL, NULL,                              /* WS10082N */
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 "input pair is NULL", func);             /* WS10082N */
 
     rc = ESA_ERR;
     goto exit;
  }
 
  temp_pair = pair - pair->index;
  addinfo_ptr = (ADDINFO_rec_typ *) ((unsigned char*)temp_pair
                                   -
             (sizeof(ADDINFO_rec_typ) - sizeof(ONE_FIELD_rec_typ)));
 
  /* WS10082N - start */
  ESA_DIAG_printf (ESA_COMP_API_ADDINFO,4,
               "addinfo_ptr %p, num_pair=%d  max_pair=%d  heap_id=%p",
                   addinfo_ptr,
                   addinfo_ptr->num_pairs, addinfo_ptr->max_pairs,
                   addinfo_ptr->heap_id);
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
 "pair(%3d)(%p-%p): typ=%i  SLTyp=%c  secret=%c  kwd=(%d)%s  vallen=%d",
                  pair->index, pair, pair->twin,
                  pair->add_typ,
                  pair->twin->SLType,
                  pair->secret,
                  pair->keylen, pair->keyword, pair->vallen);
  /* WS10082N - start */
 
  /* If long pair already exists - error */
  if (pair->twin NE pair)
  {
    snprintf(msgbuf, sizeof(msgbuf),
    "Cannot allocate long pair - adready exists (%p-%p).  Kwd=<%s>. ",
             pair, pair->twin,
             pair->keyword);
    strncat(msgbuf, SEE_PRTDBG_MSG,
                    sizeof(msgbuf)-strlen(msgbuf));
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                 NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf, func);
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
            "pair(%3d)(%p-%p): typ=%i  SLTyp=%c  secret=%c  kwd=%s",
                    pair->index, pair, pair->twin,
                    pair->add_typ,
                    pair->twin->SLType,
                    pair->secret,
                    pair->keyword );
    rc = ESA_ERR;
    goto exit;
  }
 
  /* Lets allocate large pair and add data to large pair. */
  size = ADDINFO_LARGE_PAIR_SIZE;
  CEEGTST (&addinfo_ptr->heap_id, &size, (void **)&twin_pair, &fdbk);
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 6,
      "Heap getstor:  size = %d  heap_id = %p  pair = %p  fdbk = %d",
           size, addinfo_ptr->heap_id, twin_pair, fdbk.tok_msgno);
  if ( _FBCHECK ( fdbk , CEE000 ) NE 0 )
  {
    sprintf(msgbuf,
       "Long pair alloc failed. Heap = %p  CEEGTST msg# = %d  Kwd=<%s>",
          addinfo_ptr->heap_id, fdbk.tok_msgno, pair->keyword);
    CTSAMSG_print(ERR_INTERNAL3,
                 NULL, NULL,
                 ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                 msgbuf);
     rc = ESA_ERR;
     goto exit;
  }
 
  /* twin pair was allocated - initialize it */
  memcpy(twin_pair, pair, sizeof(ONE_FIELD_rec_typ));
  pair->twin = twin_pair;
  twin_pair->twin = pair;
  twin_pair->SLType = 'L';
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,6,
  "After alloc: Long pair(%3d)(%p-%p): SLTyp=%c  kwd=%s  vallen=%d",
                   pair->index, pair, pair->twin,
                   pair->twin->SLType,
                   pair->twin->keyword,
                   pair->twin->vallen );
 
 exit:;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
 
  return rc;
 
} /* End ADDINFO_alloc_twin_pair*/
 
/**************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_free_twin_pair                     *
*                                                             *
* DESCRIPTION    : Free the lare pair area and reset the      *
*                  pair to be short.                          *
*                                                             *
* INPUT          : pair     - short pair                      *
*                  ignore_nolong - 0/1                        *
*                    What to do when no long entry:           *
*                    0 - fail.                                *
*                    1 - reset the short entry.               *
*                                                             *
* OUTPUT         : None.                                      *
*                  pair is updated with the appropriate data. *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************/
static ESA_RC ADDINFO_free_twin_pair( ONE_FIELD_rec_ptr  pair,
                                      int           ignore_nolong)
{
  static char        func[] = "ADDINFO_free_twin_pair";
  ADDINFO_rec_ptr    addinfo_ptr = NULL;
  ONE_FIELD_rec_ptr  temp_pair = NULL;
  char               msgbuf[256] = "";
  ESA_RC             rc = ESA_OK;
  _FEEDBACK  fdbk;                                        /* WS10082N */
 
  ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 1, func);
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
                  "input pair = %p", pair);
 
  if (pair EQ NULL)
  {
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  "input pair is NULL", func);
    rc = ESA_ERR;
    goto exit;
  };
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
           "pair(%3d)(%p-%p):  SLType = %c    keyword = %s",
            pair->index, pair, pair->twin, pair->SLType,
            pair->keyword);
 
  /* If pair type is not S, fail the request.               */
  if (pair->SLType NE 'S')
  {
    snprintf(msgbuf, sizeof(msgbuf),
                    "input pair type is %c, not S.  Keyword = %s",
                     pair->SLType, pair->keyword);
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
    rc = ESA_ERR;
    goto exit;
  };
 
  /* locate addinfo                 */
  temp_pair = pair - pair->index;   /* temp_pair -> first pair */
 
  /* Locate the addinfo address by subtracting the addinfo       *
   * prefix length from temp_pair.                               *
   * ADDINFO_rec_typ contains 1 pair so addinfo prefix length is *
   * (sizeof(ADDINFO_rec_typ) - sizeof(ONE_FIELD_rec_typ)).      */
 
  addinfo_ptr = (ADDINFO_rec_typ *) ((unsigned char*)temp_pair
                                   -
             (sizeof(ADDINFO_rec_typ) - sizeof(ONE_FIELD_rec_typ)));
 
  ESA_DIAG_printf (ESA_COMP_API_ADDINFO,4,
         "addinfo_ptr %p, num_pair=%d  max_pair=%d   heap_id = %p",
                   addinfo_ptr,
                   addinfo_ptr->num_pairs, addinfo_ptr->max_pairs,
                   addinfo_ptr->heap_id);
 
  if (pair->twin NE NULL)
  {
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,4,
                    "pair: SLTyp=%c  twin->SLType=%c",
                    pair->SLType,
                    pair->twin->SLType);
 
    /* If no large pair - error.         */
    if (pair EQ pair->twin)
    {
      snprintf(msgbuf, sizeof(msgbuf),
               "No long pair to free (%p-%p).  Keyword=%s. ",
               pair, pair->twin,
               pair->keyword);
      strncat(msgbuf, SEE_PRTDBG_MSG,
                      sizeof(msgbuf)-strlen(msgbuf));
    }   /* end of if (pair EQ pair->twin) */
    else   /* we have a twin - free it */
    {
      CEEFRST ((void **)&pair->twin, &fdbk);
      ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 4,
                      "Twin pair free at <%p>:  CEEFRST fdbk = %d",
                      pair->twin, fdbk.tok_msgno);
      if ( _FBCHECK ( fdbk , CEE000 ) NE 0 )
      {
         sprintf(msgbuf,
            "Long pair free failed.  CEEFRST msg# = %d  Kwd=<%s>",
             fdbk.tok_msgno, pair->keyword);
      }
    }
 
  }   /* end of if (pair->twin NE NULL)  */
  else  /* pair->twin EQ NULL  */
  {
      snprintf(msgbuf, sizeof(msgbuf),
               "No pair twin (%p-%p). Keyword=%s. ",
               pair, pair->twin,
               pair->keyword);
      strncat(msgbuf, SEE_PRTDBG_MSG,
                      sizeof(msgbuf)-strlen(msgbuf));
  }
 
  /* If any error with twin pair, issue the message and continue */
  /* according to yhr ignore_notwin parameter.                   */
  if (strlen(msgbuf) NE 0)   /* pair/twin error ? */
  {
    CTSAMSG_print(ERR_ADI_PROC_ERROR,
                  NULL, NULL,
                  ((CTSAMSG_DEST_TABLE_rec_ptr)CTSAMSG_FIND_DEST),
                  msgbuf, func);
 
    ESA_DIAG_printf(ESA_COMP_API_ADDINFO,0,
               "pair(%3d)(%p-%p): typ=%i  SLTyp=%c  secret=%c  kwd=%s",
                    pair->index, pair, pair->twin,
                    pair->add_typ,
                    pair->twin->SLType,
                    pair->secret,
                    pair->keyword );
 
    /*  If we should ignore the error we will reset the pair. */
    /*  Otherwise, we will set an error rc and leave.         */
    if (!ignore_nolong)
    {
      rc = ESA_ERR;
      goto exit;
    };
  };
 
  pair->twin = pair;   /* Update the short pair */
 
  ESA_DIAG_printf(ESA_COMP_API_ADDINFO,6,
                  "updated pair(%3d)(%p-%p): SLTyp=%c-%c  kwd=%s",
                   pair->index, pair, pair->twin,
                   pair->SLType, pair->twin->SLType,
                   pair->keyword );
 
  exit:;
 
  ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 1, func, rc);
   return rc;
 
}   /* End of ADDINFO_free_twin_pair  */
 
/*WS10082K - Removed functions - not used.
 
/@*************************************************************
*                                                      IS0208 *
* PROCEDURE NAME : ADDINFO_value_addval adies67               *
*                                                             *
* DESCRIPTION    : Conactenate a value to an value string     *
*                  and update string length                   *
*                                                             *
* INPUT          : addval    - Subfield / Entry to be added   *
*                  addval_len - Added string length           *
*                  current_val - Addinfo value string         *
*                  current_val_len - Addinfo value string len *
*                  ( passed by address for update )           *
*                  max_vallen - Max value string length       *
*                  addsep_c  - Sufield / List entry seperator *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
* WS10082  MauriC   29/09/22 Remove ADMIN_PARAMS references
*************************************************************@/
ESA_RC ADDINFO_value_addval(char                   *addval,
                             int                   addval_len,
                             char                  *current_val,
                             int                   *current_val_len,
                             int                    max_vallen,
                             char                   addsep_c)
        /@WS10082 not needed ADMIN_PARAMS_rec_typ  *admin_params) @/
{
 
 /@
  *  Variables
  @/
 
  ESA_RC rc = ESA_OK;
  char   *wptr;
  static char func[] = "ADDINFO_value_addval";
 
  /@ WS10082 not needed
  admin_params->cs_func.DIAG_enter_ptr(
     PLT_COMP_API_ADDINFO, 1, func); @/
  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);
 
 /@
  *  Enough place for value ?
  @/
/@if ( (*current_val_len + addval_len) GE max_vallen) {     *WS10082K@/
  if ( (*current_val_len + addval_len) GE                  /@WS10082K@/
              ADDINFO_LARGE_VAL_LEN ) {                    /@WS10082K@/
     rc = ESA_FATAL;
     goto exit;
  }
 
 /@
  *  Add seperator if value is not empty
  @/
  if ( *current_val_len GT 0 ) {                            /@ IS0212 @/
     current_val[ (*current_val_len) ] = addsep_c;
     (*current_val_len)++;
  }
 
 /@
  *  Add value
  @/
  wptr = current_val + (*current_val_len);
  strncpy(wptr, addval, addval_len + 1);
  *current_val_len += addval_len;
 
 /@
  *  finish
  @/
 
  exit:;
 
  /@ WS10082 not needed
  admin_params->cs_func.DIAG_exit_ptr(
     PLT_COMP_API_ADDINFO, 1, func); @/
  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
 
  return rc;
 
} @/
 
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_addval_dgt adies66                 *
*                                                             *
* DESCRIPTION    : Conactenate a value to an exiting one      *
*                                                             *
* INPUT          : addval    - Value to be added              *
*                  addsep    - Seperator between value list   *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
*************************************************************@/
ESA_RC ADDINFO_addval_dgt(char                       *addval,
                           int                        vallen,
                           int                        max_vallen,
                           char                       addsep_c,
                           ONE_FIELD_rec_ptr          pair,
                           CTSAMSG_DEST_TABLE_rec_ptr p_dest,
                           CTSAMSG_HANDLE_rec_ptr     p_msgs)
{
 
 /@
  *  Variables
  @/
 
  ESA_RC rc = ESA_OK;
  char   *wptr;
  static char func[] = "ADDINFO_addval_dgt";
  char   msgbuf[MAX_RSS_ADDINFO_VAL_LEN+100];
  char   addsep[2];
  ONE_FIELD_rec_ptr  tpair,
 
  ESA_DIAG_enter(PLT_COMP_API_ADDINFO, 1, func);
 
  BUILD_STRING_SEPARATOR( addsep, addsep_c)
 
  tpair = get_pair(pair);                              /@WS10082K@/
 /@
  *  Enough place for value ?
  @/
/@if ( (vallen + pair->vallen) GE max_vallen) {         * WS10082K @/
  if ( (vallen + pair->vallen) GE                      /@ WS10082K @/
                ADDINFO_LARGE_VAL_LEN ) {              /@ WS10082K @/
     rc = ESA_FATAL;
     goto exit;
  }
 
 /@
  *  Add seperator
  @/
    /@WS10082K - Start @/
/@if ( *pair->value NE NULL_CHAR ) {
    if ( (pair->add_typ EQ TYPE_1B)  OR
         (pair->add_typ EQ TYPE_2B)   )      @/
  if ( *tpair->value NE NULL_CHAR ) {
    if ( (tpair->add_typ EQ TYPE_1B)  OR
         (tpair->add_typ EQ TYPE_2B)   )
    {
      /@ Check if the value is more than 1K and requires large  *
      *  pair. Else point to correct pair before updating value @/
      if(tpair->SLType EQ 'S' AND
           (strlen(tpair->value) + strlen(addval)) GT ADDINFO_SHORT_VAL_LEN)
      {
         rc = ADDINFO_alloc_twin_pair(tpair);
         if(rc NE ESA_OK)
         {
            ESA_DIAG_printf (PLT_COMP_API_ADDINFO,1,
                             "Failed to allocate twin pair");
            CTSAMSG_print (ERR_INTERNAL2, p_msgs, NULL,
                           p_dest, component, func,
                           "Failed to allocate twin pair", rc, __LINE__);
            goto exit;
         }
         /@ pair should point to large pair @/
         tpair = tpair->twin;
 
      }  /@WS10082K - End @/
      strcat(tpair->value, addsep);
    }    /@WS10082K@/
    else {
      sprintf(msgbuf, "Invalid type=%d for list keyword=%s",
              tpair->add_typ,  tpair->keyword);
      CTSAMSG_print(ERR_INTERNAL2, p_msgs, NULL, p_dest,
                    component, func, msgbuf, 0, __LINE__);
      strcat(tpair->value, addsep);
    }
  }
 
 /@
  *  Add value
  @/
  wptr = tpair->value + tpair->vallen;
  memcpy(wptr,addval,vallen);
  tpair->vallen += vallen;
 
  /@ WS10082K - Lets update the value at short pair @/
  if(tpair->SLType EQ 'L')                       /@ WS10082K @/
     tpair->twin->vallen = tpair->vallen;        /@ WS10082K @/
 /@
  *  finish
  @/
 
  exit:;
 
  ESA_DIAG_exit(PLT_COMP_API_ADDINFO, 1, func, rc);
  return rc;
 
} @/
 /@*************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_get_value                          *
 *                                                             *
 * DESCRIPTION    : Get parameter from ADDINFO                 *
 *                                                             *
 * INPUT          : addinfo                                    *
 *                  parameter_name                             *
 *                                                             *
 * OUTPUT         : parameter_value                            *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 *************************************************************@/
 ESA_RC ADDINFO_get_value(ADDINFO_rec_typ    * addinfo,
                          char               * parameter_name,
                          char               * parameter_val,
                          int                  max_kwdlen,
                          int                  max_vallen)
 {
 
   static char       func[]="ADDINFO_get_value";
   ONE_FIELD_rec_ptr cpair;
   ESA_RC            rc = ESA_OK;
 
  /@
   *    Initialize
   @/
 
   ESA_DIAG_enter(PLT_COMP_API_ADDINFO ,4,func);
 
   if (addinfo EQ NULL) {             /@WS10082K@/
      rc = ESA_FATAL;                 /@WS10082K@/
      goto exit;                      /@WS10082K@/
   }                                  /@WS10082K@/
 
  /@
   *    Get Parameter
   @/
 
   cpair=ADDINFO_search(parameter_name, max_kwdlen,
                        addinfo->pair, addinfo->num_pairs);
   if (cpair NE NULL) {
     if ( strlen(cpair->value) LT max_vallen ) {
       strcpy(parameter_val, cpair->value);
       ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                       "parameter=%s value=%d/%s",
                        parameter_name,
                        strlen(parameter_val), parameter_val);
     }
     else {
        ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                        "parameter=%s value=%d/%s grate then max=%d",
                         parameter_name,
                         strlen(parameter_val),
                         parameter_val, max_vallen);
        *parameter_val = NULL_CHAR;
     }
   }
   else {
     ESA_DIAG_printf(PLT_COMP_API_ADDINFO , 4,
                     "parameter=%s not found",
                      parameter_name);
     *parameter_val = NULL_CHAR;
     rc = ESA_ERR;
   }
 
  /@
   *    Finish
   @/
 
   exit :;           /@ WS10082M @/
 
 
   ESA_DIAG_exit( PLT_COMP_API_ADDINFO ,4, func, rc );
 
   return rc;
 
 }
 
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_kdt_modify adies20                 *
*                                                             *
* DESCRIPTION    : Modify the textl, tetxr for specified      *
*                  entry in KDT table                         *
*                                                             *
* INPUT          : kwd              - keyword                 *
*                  p_kdte           - KDTE table              *
*                  char             - text left               *
*                  char             - text right              *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_OK, ESA_ERR - specified keyword        *
*                                    not found                *
*                                                             *
*************************************************************@/
ESA_RC ADDINFO_kdt_modify(char                     *kwd,
                          ADDINFO_KDTE_rec_ptr  p_kdte,
                          char                 *txtl,
                          char                 *txtr)
 
{
 
   static char func[] = "ADDINFO_kdt_modify";
 
   /@
    *     Variables
    @/
 
   ESA_RC                rc = ESA_OK;
   ADDINFO_KDTE_rec_ptr  fnd = NULL;
 
   /@
    *     Initialize
    @/
 
   ESA_DIAG_enter(ESA_COMP_API_ADDINFO, 3, func);
 
   /@
    *     Locate specified keyword
    @/
 
   fnd = ADDINFO_kdt_search(kwd, p_kdte);
   if ( fnd EQ NULL ) {
      rc = ESA_ERR ;
      goto exit;
   }
 
   fnd->txtl = txtl;   /@ Update ptr to new text left  @/
   fnd->txtr = txtr;   /@ Update ptr to new text right @/
 
   /@
    *     finish
    @/
 
  exit :;
 
   ESA_DIAG_printf(ESA_COMP_API_ADDINFO, 3,
                   "exiting with rc= %d", rc );
 
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 3, func, rc);
 
   return rc;
 
}
 **** WS10082K - end of unused function    ****/
 
/* WS10082 following functions ERROR_add, ERROR_dump     *
   and ERROR_print are removed                           *
***************************************************************
*                                                             *
* PROCEDURE NAME : ERROR_add                                  *
*                                                             *
* DESCRIPTION    : Add error message to error buffer          *
*                                                             *
* INPUT          : p_line   - line to add to buffer           *
*                  p_err    - error buffer                    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ERROR_add (char               * p_line,
                  ERR_STRUCT_rec_ptr   p_err)
{
   static char func[] = "ERROR_add";
   ESA_RC      rc     = ESA_OK;
   short       line_len,line_off;
 
   **
    *     Initialize
    **
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
   if ((p_line EQ NULL) OR (p_err EQ NULL)) {  ** AJK001 **
      rc = ESA_FATAL;
      goto exit;
   }
 
   line_len = strlen (p_line) + 1;
   line_off = p_err->length;
 
    *
    *     Copy line into buffer
    *
 
   if ((line_len+line_off) LT sizeof (p_err->err_msg_text)) {
      strcpy (&(p_err->err_msg_text[line_off]), p_line);
      p_err->length = p_err->length + line_len;
   }
   else
      rc = ESA_ERR;    * No room in buffer *
 
   *
   *  finish
   *
 
  exit:
   ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
   return rc;
}
 
 
***************************************************************
*                                                             *
* PROCEDURE NAME : ERROR_dump                                 *
*                                                             *
* DESCRIPTION    : Dump error message buffer                  *
*                                                             *
* INPUT          : p_err    - error buffer                    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ERROR_dump (ERR_STRUCT_rec_ptr p_err)
{
   static char func [] = "ERROR_dump";
   int         coff, cleft, clen;
 
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
   if (p_err EQ NULL) {   * AJK001 *
      goto exit;
   }
 
    * Error lines *
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 11,
                    "Error buffer size=%d used=%d",
                    sizeof (p_err->err_msg_text), p_err->length);
 
   coff  = 0;
   cleft = p_err->length;
 
   while (cleft GT 0) {
      clen = strlen (&(p_err->err_msg_text[coff]))+1;
      ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 11, "%3d,%s",
                       coff, &(p_err->err_msg_text[coff]));
      cleft = cleft - clen;
      coff  = coff  + clen;
  }  * while *
 
  exit:
  ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, ESA_OK);
 
  return ESA_OK;
 
}  * ERROR_dump *
 
***************************************************************
*                                                             *
* PROCEDURE NAME : ERROR_print                                *
*                                                             *
* DESCRIPTION    : print error message buffer to stdout       *
*                                                             *
* INPUT          : p_err    - error buffer                    *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ERROR_print (ERR_STRUCT_rec_ptr p_err)
{
   static char func [] = "ERROR_print";
   int         coff, cleft, clen;
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
   if (p_err EQ NULL) {   * AJK001 *
      goto exit;
   }
 
   * Error lines *
 
  coff  = 0;
  cleft = p_err->length;
  while (cleft GT 0) {
     clen = strlen (&(p_err->err_msg_text[coff])) + 1;
     printf("- %s", &(p_err->err_msg_text[coff]));
     cleft = cleft - clen;
     coff  = coff  + clen;
  }  * while *
 
  exit:
  ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, ESA_OK);
 
  return ESA_OK;
 
}  * ERROR_print *
*/
 
 
/* WS10082 - The functions below are the original version, before
             implementing WS10082.  Their updated versiona above are
             the active functions.
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_insert adies02                     *
*                                                             *
* DESCRIPTION    : Insert a keyword in additional info        *
*                                                             *
* INPUT          : type             -  addinfo type           *
*                  kwd              -  keyword                *
*                  value            -  value                  *
*                  addinfo          -  additional info        *
*                  dupflag          -  allow duplicate flag   *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_insert  (ADDINFO_typ         type,
                        char              * kwd,
                        char              * val,
                        ADDINFO_rec_ptr     addinfo,
                        int                 max_kwdlen,
                        int                 max_vallen,
                        ADDINFO_DUPLICATE   dupflag)
{
   **
    *  Variables
    **
 
    int               i = 0;
    int               kwdlen, vallen;
    ESA_RC            rc = ESA_OK;
    ONE_FIELD_rec_ptr cpair;
    static char       func [] = "ADDINFO_insert";
 
   **
    *  initialize
    **
 
    ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
    if (addinfo EQ NULL) {  ** AJK001 **
       rc = ESA_FATAL;
       goto exit;
    }
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
                     "num_pairs = %d, max_pairs = %d",
                     addinfo->num_pairs, addinfo->max_pairs);
 
    if (addinfo->num_pairs GE addinfo->max_pairs) {
       ** rc = ESA_ERR; - deleted  AS0207 **
       rc = ESA_FATAL; ** added    AS0207 **
       goto exit;
    }
 
    kwdlen = strlen (kwd);
    vallen = strlen (val);
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
                     "Keyword=(%d/%d) '%s' Value=(%d/%d) '%s'",
                     kwdlen, max_kwdlen, kwd, vallen, max_vallen, val);
 
  **
   **  Validity checks
    **
 
    if ((kwdlen EQ 0) OR (kwdlen GT max_kwdlen)) {
       rc = ESA_FATAL;
       goto exit;
    }
 
    if (vallen GT max_vallen) {
       rc = ESA_FATAL;
       goto exit;
    }
 
   **
    *  Verify that keyword is not yet used
    **
 
    cpair = addinfo->pair;
 
    while (i LT addinfo->num_pairs) {
 
       ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
                        "Entry %d,%p: kwd=%s(%3d),val=%s(%3d)",
                        i, cpair,
                        cpair->keyword, cpair->keylen,
                        cpair->value, cpair->vallen);
 
       if (dupflag EQ UNIQUE)
          if (strcmp (cpair->keyword,kwd) EQ 0) {
             rc = ESA_ERR;
             goto exit;
          }
 
       else if (*(cpair->keyword) EQ NULL_CHAR)
          break;
 
       cpair++;
       i++;
 
    } ** while **
 
    **
     *    Add the Keyword
     **
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
                     "Updating entry at %d,%p", i, cpair);
 
    cpair->add_typ = type;
    cpair->keylen  = kwdlen;
    strcpy (cpair->keyword,kwd);
    addinfo->num_pairs++;
 
    **
     *    Update the value
     **
 
    ADDINFO_updval (val, max_vallen, cpair);
 
    **
     *    Finish
     **
  exit:
 
    ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
 
    return rc;
 
}
 
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_updval adies03                     *
*                                                             *
* DESCRIPTION    : Update a value of an exiting entry         *
*                                                             *
* INPUT          : value     - Value to be updated            *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_updval (char              * addval,
                       int                 max_vallen,
                       ONE_FIELD_rec_ptr   pair)
{
 **
  *  Variables
  **
 
  ESA_RC rc           = ESA_OK;
  static char func [] = "ADDINFO_updval";
 
 
  ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
  if (pair EQ NULL) {  ** AJK001 **
     rc = ESA_FATAL;
     goto exit;
  }
 
 **
  *  Enough place for value ?
  **
  if (strlen (addval) GE (unsigned)max_vallen) {
     rc = ESA_FATAL;
     goto exit;
  }
 
 **
  *  update value
  **
 
  strcpy (pair->value, addval);
  pair->vallen = strlen(pair->value);
 
 **
  *  finish
  **
 
  exit:
 
  ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
  return rc;
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_dump adies04                       *
*                                                             *
* DESCRIPTION    : Dump Addtional info area                   *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                  print_empty      -  1 print in any case    *
*                                   -  0 print only if value  *
*                                        length > 0           *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_dump (ADDINFO_rec_ptr addinfo,
                     int             print_empty)
{
   static char       func[] = "ADDINFO_dump";
 int               i;
 ESA_RC            rc = ESA_OK;
 ONE_FIELD_rec_ptr f_ptr;
 
 
 ** initialize        **
 
 ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
 if (addinfo NE NULL) {
 
    ** addinfo num pairs **
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                     "num_pairs = %d, max_pairs = %d",
                     addinfo->num_pairs, addinfo->max_pairs);
 
    ** addinfo pairs **
 
    i = 0;
    f_ptr = addinfo->pair;
 
    while (i LT addinfo->num_pairs) {
       if ((print_empty NE 0) OR (f_ptr->vallen GT 0))
          ** IS10183 - start  **
          if (  (strcmp(f_ptr->keyword,"PASSWORD") EQ 0)  OR
                (strcmp(f_ptr->keyword,"PHRASE") EQ 0)    OR
                (strcmp(f_ptr->keyword,"PWPHRASE") EQ 0)  )
           ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                           "pair no. %3d: kwd=%s(%3d) val=%s",
                           i+1, f_ptr->keyword,f_ptr->keylen,
                           "********");
          else
          ** IS10183 - end    **
          ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                           "pair no. %3d: kwd=%s(%3d) val=%s(%3d)",
                           i+1, f_ptr->keyword,f_ptr->keylen,
                           f_ptr->value,f_ptr->vallen);
       f_ptr++;
       i++;
    }
 
 } ** addinfo pointer not empty **
 
 ** finish            **
 
 ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
 
 return rc;
 
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_alloc adies05                      *
*                                                             *
* DESCRIPTION    : Allocate additional info area              *
*                                                             *
* INPUT          : max_pairs        -  max_pairs              *
*                : addinfo_ptr      -  additional info pointer*
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_alloc (char                        * func,
                      short                         max_pairs,
                      ADDINFO_rec_typ            ** addinfo_ptr,
                      CTSAMSG_DEST_TABLE_rec_ptr    dest,
                      CTSAMSG_HANDLE_rec_ptr        msgs)
{
 
    static char fn[] = "ADDINFO_alloc";
    int         size;
    ESA_RC      rc = ESA_OK;
 
 
    ** Initialize        **
 
    ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, fn);
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 11,
                     "addinfo pointer at %p, max =%d",
                     addinfo_ptr, max_pairs);
 
    ** Obtain area       **
 
    size = sizeof (ADDINFO_rec_typ) +
           max_pairs * sizeof (ONE_FIELD_rec_typ);
 
    ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11, "area size = %d",size);
 
    (*addinfo_ptr) = (ADDINFO_rec_typ *)malloc (size);
 
    if (*addinfo_ptr EQ NULL) {
 
       ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                        "malloc for addinfo buffer failed (%d bytes)",
                        size);
 
       CTSAMSG_print (ERR_MALLOC, msgs, NULL, dest,
                      "ADDINFO BUFFER", size);
       rc = ESA_ERR;
    }
    else {
       (*addinfo_ptr)->num_pairs = 0;
       (*addinfo_ptr)->max_pairs = max_pairs;
 
       ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 11, "area at %p.",
                        *addinfo_ptr);
    }
 
    ** Finish            **
 
    ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, fn, rc);
 
    return rc;
 
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_free      adies06                  *
*                                                             *
* DESCRIPTION    : Free additional info buffer                *
*                                                             *
* INPUT          : addinfo_ptr      -  additional info pointer*
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_free (ADDINFO_rec_ptr * addinfo_ptr)
{
   static char func[] = "ADDINFO_free";
 
 
   ** Initialize        **
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11,func);
 
   if (addinfo_ptr EQ NULL) {  ** AJK001 **
      goto exit;
   }
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 11,
                   "area at %p.", *addinfo_ptr);
 
   ** Free area       **
 
   if ((*addinfo_ptr) NE NULL) {
      free (*addinfo_ptr);
      (*addinfo_ptr) = NULL;
   }
 
   ** Finish            **
 
  exit:
   ESA_DIAG_exit(ESA_COMP_API_ADDINFO, 11, func, ESA_OK);
 
   return ESA_OK;
 
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_clear_value adies07                *
*                                                             *
* DESCRIPTION    : Clear value of entering pair               *
*                                                             *
* INPUT          : pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_clear_value (ONE_FIELD_rec_ptr pair)
{
  ESA_RC      rc     = ESA_OK;
  static char func[] = "ADDINFO_clear_value";
 
 
  ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
 **
  *  Clear value
  **
 
  if (pair) {  ** AJK001 **
     pair->value[0] = NULL_CHAR;
     pair->vallen   = 0;
  }
 
 **
  *  finish
  **
 
  ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
  return rc;
}
 
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_clear      adies08                 *
*                                                             *
* DESCRIPTION    : Clear Addtional info area                  *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_clear (ADDINFO_rec_ptr addinfo)
{
    int               i;
    ESA_RC            rc = ESA_OK;
    ONE_FIELD_rec_ptr f_ptr;
    static char       func [] = "ADDINFO_clear";
 
 
    ** initialize        **
 
    ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
    if (addinfo NE NULL) {
 
       ** addinfo num pairs **
 
       ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                        "num_pairs = %d, max_pairs = %d",
                        addinfo->num_pairs, addinfo->max_pairs);
 
       ** addinfo pairs **
 
       i = 0;
       f_ptr = addinfo->pair;
 
       while (i LT addinfo->num_pairs) {
          ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                           "pair no. %3d: kwd=%s(%3d) val=%s(%3d)",
                           i+1, f_ptr->keyword,f_ptr->keylen,
                           f_ptr->value, f_ptr->vallen);
          ADDINFO_clear_value (f_ptr);
          f_ptr++;
          i++;
       }
 
    } ** addinfo pointer not empty **
 
    ** finish            **
 
    ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
 
    return rc;
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_addval adies09                     *
*                                                             *
* DESCRIPTION    : Conactenate a value to an exiting one      *
*                                                             *
* INPUT          : addval    - Value to be added              *
*                  addsep    - Seperator between value list   *
*                  pair      - Addinto entry                  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_addval (char                      * addval,
                       int                         max_vallen,
                       char                        addsep_c,
                       ONE_FIELD_rec_ptr           pair,
                       CTSAMSG_DEST_TABLE_rec_ptr  p_dest,
                       CTSAMSG_HANDLE_rec_ptr      p_msgs)
{
 **
  *  Variables
  **
 
  ESA_RC      rc      = ESA_OK;
  static char func [] = "ADDINFO_addval";
  char        msgbuf [MAX_RSS_ADDINFO_VAL_LEN+100];
  char        addsep [2];
 
 
  ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
  if (pair EQ NULL) {  ** AJK001 **
     rc = ESA_FATAL;
     goto exit;
  }
 
  BUILD_STRING_SEPARATOR (addsep, addsep_c)
 
 **
  *  Enough room for value ?
  **
 
  if ((strlen (addval)+(pair->vallen)) GE (unsigned)max_vallen) {
     rc = ESA_FATAL;
     goto exit;
  }
 
 **
  *  Add seperator
  **
 
  if ( *pair->value NE NULL_CHAR) {
     if ((pair->add_typ EQ TYPE_1B) OR (pair->add_typ EQ TYPE_2B))
        strcat(pair->value, addsep);
     else {
        sprintf (msgbuf, "Invalid type=%d for list keyword=%s",
                 pair->add_typ,  pair->keyword);
        CTSAMSG_print (ERR_INTERNAL2, p_msgs, NULL, p_dest,
                       component, func, msgbuf, 0, __LINE__);
        strcat(pair->value, addsep);
     }
  }
 
 **
  *  Add value
  **
  strcat (pair->value,addval);
  pair->vallen = strlen (pair->value);
 
 **
  *  finish
  **
 
  exit:
 
  ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
  return rc;
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_delete       adies10               *
*                                                             *
* DESCRIPTION    : Delete an entry from addinfo buffer        *
*                                                             *
* INPUT          : Addinfo          -  additional info        *
*                  keyword          -  keyword                *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ESA_RC                                     *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_delete (ADDINFO_rec_ptr       addinfo,
                       char            * keyword)
{
  static char func [] = "ADDINFO_delete";
  ESA_RC      rc      = ESA_OK;
  int         found, i;
 
 **
  *   Initialize
  **
 
  ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
  if (addinfo EQ NULL) {  ** AJK001 **
     rc = ESA_FATAL;
     goto exit;
  }
 
 **
  *   Search keyword that must be deleted
  **
 
  found = 0;
 
  for (i=0; NOT (found) AND (i LT addinfo->num_pairs); i++)
     if (strcmp (addinfo->pair[i].keyword, keyword) EQ 0)
        found = i+1;
 
  if (NOT (found)) {
     rc = ESA_ERR;
     goto exit;
  }
 
 **
  *   Compress information
  **
 
  for (i = found-1; i LT addinfo->num_pairs; i++) {
 
     strcpy (addinfo->pair[i].keyword, addinfo->pair[i+1].keyword);
     strcpy (addinfo->pair[i].value,   addinfo->pair[i+1].value  );
     addinfo->pair[i].keylen  = addinfo->pair[i+1].keylen;
     addinfo->pair[i].vallen  = addinfo->pair[i+1].vallen;
     addinfo->pair[i].add_typ = addinfo->pair[i+1].add_typ; ** WS10075**
  }
 
 **
  *   Update number of entries
  **
 
  addinfo->num_pairs--;
 
 **
  *   Finish
  **
 
  exit:
 
  ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
 
  return rc;
}
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_copy       adies14                 *
*                                                             *
* DESCRIPTION    : Copy additional info area                  *
*                                                             *
* INPUT          : to               -  additional info        *
*                  from             -  additional info        *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : none                                       *
*                                                             *
***************************************************************
 
ESA_RC ADDINFO_copy (ADDINFO_rec_ptr to,
                     ADDINFO_rec_ptr from)
{
   static char func[] = "ADDINFO_copy";
   ESA_RC      rc     = ESA_OK;
   short       save_max_pairs;
 
 
   ** Initialize        **
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
   if ((to EQ NULL) OR (from EQ NULL)) {  ** AJK001 **
      rc = ESA_FATAL;
      goto exit;
   }
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                    "FROM: at %p, used %d max %d",
                    from, from->num_pairs, from->max_pairs);
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO,11,
                    "TO at %p, used %d max %d",
                    to, to->num_pairs, to->max_pairs);
 
   ** Copy area       **
 
    if (to->max_pairs LT from->num_pairs) {
       rc = ESA_ERR;
       goto exit;
    }
 
    save_max_pairs = to->max_pairs;
 
    memcpy ((void *)to,
            (void *)from,
            ADDINFO_size(from->num_pairs));
 
    to->num_pairs = from->num_pairs;
    to->max_pairs = save_max_pairs;
 
     ** Finish            **
 
  exit:
 
    ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, rc);
 
    return rc;
 
} ** ADDINFO_copy  **
 /@*************************************************************
 *                                                             *
 * PROCEDURE NAME : ADDINFO_get_value       adies15            *
 *                                                             *
 * DESCRIPTION    : Get parameter from ADDINFO                 *
 *                                                             *
 * INPUT          : addinfo                                    *
 *                  parameter_name                             *
 *                                                             *
 * OUTPUT         : parameter_value                            *
 *                                                             *
 * RETURN VALUE   : ESA_RC                                     *
 *                                                             *
 ***************************************************************
 
ESA_RC ADDINFO_get_value (ADDINFO_rec_typ * addinfo,
                          char            * parameter_name,
                          char            * parameter_val,
                          int               max_kwdlen,
                          int               max_vallen)
{
   static char       func[]="ADDINFO_get_value";
   ONE_FIELD_rec_ptr cpair;
   ESA_RC            rc = ESA_OK;
 
  **
   *    Initialize
   **
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO,11,func);
 
   if (addinfo EQ NULL) {  ** AJK001 **
      rc = ESA_FATAL;
      goto exit;
   }
 
  **
   *    Get Parameter
   **
 
   cpair = ADDINFO_search(parameter_name, max_kwdlen,
                           addinfo->pair, addinfo->num_pairs);
 
   if (cpair NE NULL) {
      if (strlen (cpair->value) LT (unsigned)max_vallen) {
         strcpy (parameter_val, cpair->value);
         ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14,
                          "parameter=%s value=%d/%s",
                          parameter_name,
                          strlen (parameter_val), parameter_val);
      }
      else {
         ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14,
                          "parameter=%s value=%d/%s grate then max=%d",
                          parameter_name,
                          strlen (parameter_val),
                          parameter_val, max_vallen);
         *parameter_val = NULL_CHAR;
      }
   }
   else {
      ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14,
                       "parameter=%s not found",
                       parameter_name);
      *parameter_val = NULL_CHAR;
      rc = ESA_ERR;
   }
 
  **
   *    Finish
   **
 
  exit:
   ESA_DIAG_exit (ESA_COMP_API_ADDINFO,11, func, rc);
 
   return rc;
 }
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_get_next       adies17             *
*                                                             *
* DESCRIPTION    : Get next item from ADDINFO                 *
*                                                             *
* INPUT          : pair             -  entry to start loop    *
*                                                             *
* OUTPUT         : None                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if finished)    *
*                                                             *
***************************************************************
 
ONE_FIELD_rec_ptr ADDINFO_get_next (ADDINFO_rec_typ * addinfo,
                                    ONE_FIELD_rec_ptr   p_pair)
{
  **
   *  Variables
   **
 
   int               p_limit;
   int               start;
   ONE_FIELD_rec_ptr xptr   = NULL;
   static char       func[] = "ADDINFO_get_next";
 
  **
   *  initialize
   **
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14, "Addinfo=%p", addinfo);
 
   if (addinfo EQ NULL) {  ** AJK001 **
      goto exit;
   }
 
   if (p_pair EQ NULL) {
     start   = TRUE;
     p_limit = addinfo->num_pairs;
     p_pair  = addinfo->pair;
     ** p_pair--; **  ** start at pair # -1 **
   }
   else {
     start   = FALSE;
     p_limit = addinfo->num_pairs - (p_pair - addinfo->pair) - 1;
   }
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14,
                    "Num=%d limit=%d", addinfo->num_pairs, p_limit);
 
   if (p_limit EQ 0)
       goto exit;
 
  **
   *  Get next pair
   **
 
   if (start EQ TRUE)
      xptr = p_pair;
   else
      xptr = p_pair + 1;
 
  **
   *    Finish
   **
 
  exit:
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO, 14,
                    "Exiting with xptr=%p", xptr);
 
   ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, ESA_OK);
 
   return xptr;
 
} ** ADDINFO_get_next @/
/@*************************************************************
*                                                             *
* PROCEDURE NAME : ADDINFO_search      adies01   alalal       *
*                                                             *
* DESCRIPTION    : Search a keyword in additional info        *
*                                                             *
* INPUT          : kwd              -  keyword                *
*                  pair             -  entry to start search  *
*                  limit            -  max entries to search  *
*                                                             *
* OUTPUT         : none                                       *
*                                                             *
* RETURN VALUE   : ONE_FIELD_rec_ptr (or NULL if not found)   *
*                                                             *
***************************************************************
ONE_FIELD_rec_ptr ADDINFO_search (char              * kwd,
                                  int                 max_kwdlen,
                                  ONE_FIELD_rec_ptr   p_pair,
                                  short               p_limit)
{
  **
   *  Variables
   **
 
   short             i      = 0;
   int               kwdlen = 0;
   ONE_FIELD_rec_ptr xptr   = NULL;
   ONE_FIELD_rec_ptr cpair;
   static char       func[] = "ADDINFO_search";
 
  **
   *  initialize
   **
 
   ESA_DIAG_enter (ESA_COMP_API_ADDINFO, 11, func);
 
   if (p_pair EQ NULL)   ** AJK001 **
      goto exit;
 
   if (kwd EQ NULL)
      goto exit;
 
   kwdlen = strlen(kwd);
 
   if ((kwdlen GT max_kwdlen) OR (kwdlen EQ 0))
      goto exit;
 
   cpair = p_pair;
 
  **
   *  Loop on Pairs
   **
   for (i=0; i LT p_limit; i++) {
      if (strcmp(cpair->keyword,kwd) EQ 0) {
         xptr = cpair;
         break;
      }
      cpair++;
   } ** while **
 
  **
   *    Finish
   **
   exit:;
 
   ESA_DIAG_printf (ESA_COMP_API_ADDINFO,13,
                   "Exiting with result=%p", xptr);
   ESA_DIAG_exit (ESA_COMP_API_ADDINFO, 11, func, ESA_OK);
 
   return xptr;
 
}
   WS10082 end of original versions.  */
 
