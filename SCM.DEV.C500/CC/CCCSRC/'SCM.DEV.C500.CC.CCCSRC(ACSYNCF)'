/*
 * Version Information:
 * ====================
 * File name       : %name: acsyncf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: ihoffma %
 * Created on      : %date_created: Mon Mar 08 11:16:35 2004 %
 * Current Version : %version: 8 %
 * Last Modified by: %derived_by: ihoffma %
 * Last Modified on: %date_modified: Mon Mar 08 11:16:35 2004 %
 */
 
/***********************************************
 * Mod.ID  Who      When         Description
 * =============================================
 * 376     Leonid   7/5/01       BSAN??????
 * 502839  AvnerL   25-Jun-2009  MF updates for 3.3.00
 * IS10095  AvnerL   6-JUN-2013  Set IS0315 parts which are missing
 * SAS2IBMA AvnerL  21-Dec-16    SAS/C to IBM C Conversion Project
 * AC001   ArunC    12-Apr-2017  CIQ#6-MF acct aggr with conns
 *WS10078KGKailasP  13-May-2020  Compile as STATIST_rec_typ is changed
 **********************************************/
 
#include "globs.h"
 
#include ESA_MSG
#include ESA_CHKSUM
#include ESA_PROC
#include ESA_RSS
#include ESA_RSSF
#include ESA_CAREUSR
#include ESA_QUEUE
#include ESA_OS_OFLI
#include ESA_OS_EVENT
#include ESA_CS_DBPKG
#include ESA_CS_SINFO
#include ESA_PUMP
#include ESA_SYNC
#include ESA_ADMIN
 
/* 30/1/01 Aviw */
/*#define U2UG_CHKSUM_UNIQ    "U2UG_CHKSUM_UNIQ"*/
#define ESS_CHKSUM_UNIQ    "ESS_CHKSUM_UNIQ"
/* static int       CS_trust_u2ug_uniq ;*/
static int      CS_trust_chksum_uniq ;
static int      CS_ug_sorted ;
static int      CS_usr_sorted ;
 
static int      CS_cmpr_ug_entry(const void *elm1 , const void *elm2);
static int      CS_ug_is_sorted(void *first, size_t nument);
static int      CS_cmpr_usr_entry(const void *elm1 , const void *elm2);
static int      CS_usr_is_sorted(void *first, size_t nument);
 
/* 30/1/01 Aviw end*/
 
static UG_typ    CS_lst_chksum_ug;
static int       CS_lst_chksum_ug_idx;
static USER_typ  CS_lst_chksum_user;
static int       CS_lst_chksum_user_idx;
static int       CS_u2ug_sorted ;
 
static int CS_cmpr_u2ug_entry(const void *elm1 , const void *elm2);
 
/* BS2402 */
static int       CS_is_sorted(void *first, size_t nument);
 
/****************************************************
 * Procedure Name: CS_sync_usr_def_ug
 * Description   : Add to Ess & to memory of the interesting users
 *                     these users, that theirs default groups
 *                     in list of interesting groups
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
static ESA_RC CS_sync_usr_def_ug (RSS_MSG_HDR_rec_typ  * msg_hdr,
                            USR_MEM_rec_ptr        usr_mem_ptr,
                            int                    usr_mem_num,
                            char                ** user_memory,
                            int                  * users_in_memory,
                            int                  * user_memory_init,
                            STATIST_rec_typ      * statist)
 
{
  char fn[]="CS_sync_usr_def_ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  ESA_RC                rc_ug= ESA_OK, rc_usr= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  short                 actual_num= 0, filled_num_ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, from_num_ug= 0;
  unsigned int          usrmem_num= 0;
 
  RSSAPIPRM_rec_typ     apiprm;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  UG_typ                ug_in  [MAX_GET];
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
 
  NUM_MSGS_typ          rs_amsg_len= 0, rs_num_amsgs=0;
  MSG_typ             * amsg_rs_ptr=NULL, * amsg_rs=NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
           "num_ugs= %d users_in_memory=%d.",
		    (int)envir_ptr->num_ugs, *users_in_memory);
  CLEAR (usr_in);
  CLEAR (ug_in);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
 
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
                    FUNC_GTUG2UC,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
 
  addinfo[0]= info_ptr;
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *           */
             (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/*  Get connection of every group from list of increment groups
    to ALL users */
  for (from_num_ug= 0, filled_num_ugs = 0;
       from_num_ug LT envir_ptr->num_ugs AND rc EQ ESA_OK;)
  {
 
   CLEAR (ug_in);
   rc= CARE_inc_only_ugs_fill (ug_in, &from_num_ug, &filled_num_ugs);
   for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (usr_in);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K*  envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_GROUPS_CONNS, MAX_GET,
		filled_num_ugs, 0, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(
                    GET_GROUPS_CONNS,MAX_GET,&actual_num,
                    &have_more, &handle, filled_num_ugs,
                    0, ug_in, usr_in, u2ug_data,
                    addinfo, obj_exist,
                    &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
           "after getug2uc: actual_num=%d have_more=%d rc=%d",
            actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
                         "ug=%s usr=%s NOT EXIST ",
                         u2ug_data[ii].group,
                         u2ug_data[ii].user);
        continue;
      }
 
/*----       if user of the connection in list
             increment users */
      rc_usr= CARE_inc_usr_find (u2ug_data[ii].user,
                                 M_DWNLD_NAME_REGULAR);
/*----       if this user had been getted in the program */
      usrmem_num= CS_dwnld_mem_usr_find (*user_memory,
                                         *users_in_memory,
                                         u2ug_data[ii].user);
/*----       if user's default group of the connection in list
             increment groups */
	  if (strlen (u2ug_data[ii].def_group) EQ 0)
		  rc_ug= ESA_ERR;
	  else
          rc_ug= CARE_inc_ug_find (u2ug_data[ii].def_group);
 
      if (
          (rc_usr     EQ  ESA_OK)
              OR
          (usrmem_num LT (unsigned int)*users_in_memory)
              OR
          (rc_ug      NE ESA_OK)
         )
      {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
             "In Conn. ug=%s usr=%s def=%s is not new intersting user",
                          u2ug_data[ii].group, u2ug_data[ii].user,
                          u2ug_data[ii].def_group);
          continue;
      }
 
      usrmem_num= CS_sync_usr_checksum_find (u2ug_data[ii].user,
                                             usr_mem_ptr, usr_mem_num);
 
      if (usrmem_num GE (unsigned int)usr_mem_num)
/*    This user is new interesting user  */
         rc= CS_sync_add_usr (msg_hdr,
                              statist,
                              u2ug_data[ii].user,
                              &rs_amsg_len, &rs_num_amsgs,
                              amsg_rs_ptr, &amsg_rs,
                              user_memory,
                              user_memory_init,
                              users_in_memory);
      else
         rc= CS_dwnld_usr_to_memory (user_memory,
                                     users_in_memory,
                                     user_memory_init,
                                     u2ug_data[ii].user);
      if (rc NE ESA_OK)
         goto cleanup;
    }
   }
  }
 
  if (rs_num_amsgs NE 0) {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                 GET_FREE_HANDLE_CONNS,
                 MAX_GET, &actual_num,
                 &have_more, &handle, MAX_GET, MAX_GET,
                 ug_in, usr_in, u2ug_data,
                 addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  if (rc NE ESA_OK AND rc NE ESA_ABORT_REQ)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_sync_usr_def_ug */
 
 
 
/****************************************************
 * Procedure Name: CS_sync_usr_u2ug
 * Description   : dwnld new interesting connections
 *                   of new increment list of interesting
 *                   users
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
static ESA_RC CS_sync_usr_u2ug (RSS_MSG_HDR_rec_typ * msg_hdr,
                                U2UG_MEM_rec_ptr      u2ug_mem_ptr,
                                int                   u2ug_mem_num,
                                STATIST_rec_typ     * statist,
                                char                * user_memory,
                                int                   users_in_memory)
{
 
  char fn[]="CS_sync_usr_u2ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  ESA_RC                rc_u2ug=ESA_OK,rc_ug=ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0, filled_num_users= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, sw_upd= 0, sw_user= 0;
  U2UG_MEM_rec_ptr      ugmem= NULL;
  int                   u2ugmem_num= 0;
  int                   from_num_user= 0;
  MSG_typ             * msg= NULL;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
 
  U2UG_MEM_rec_typ       def_ugmem;
  RSSAPIKWD_rec_typ    * bufk= NULL;
  ADDINFO_rec_typ      * info_ptr= NULL;
  USER_typ               usr_in [MAX_GET], usr_wild;
  USER_PARAMS_rec_typ    usr_prm;
  UG_typ                 ug_in  [MAX_GET];
  OE_typ                 oe;
  OE_PARAMS_rec_typ      oe_prm;
  UG_PARAMS_rec_typ      ug_prm;
  U2UG_PARAMS_rec_typ    u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ         obj_exist  [MAX_GET];
  ADDINFO_rec_ptr        addinfo    [MAX_GET];
  CONNECT_PARAMS_rec_typ conn_param;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUG2UC,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR internal structures.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (usr_in);
  CLEAR (oe);
  CLEAR (ug_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR (u2ug_data);
  CLEAR (usr_wild);
  /*
    ALLOCATE addinfo connection buffer for checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE add connections messages buffer.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE update connections messages buffer.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    BUILD addinfo for user connection to user-group checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key (addinfo,                                           */
  CS_fill_key (&info_ptr,                               /*WS10082A*/
          bufk,
          kwd_types,
          1,
          envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE buffer for retrieved connections addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *          */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    BUILD msg. header for added connections
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
  /*
    BUILD msg. header for updated connections
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG2UC_UPD);
 
  /*  Get list of increment  users */
  for (from_num_user= 0;
       from_num_user LT (users_in_memory) AND rc EQ ESA_OK;
       from_num_user += filled_num_users)
  {
 
   CLEAR (ug_in);
   CLEAR (usr_in);
   CS_dwld_mem_users_fill (user_memory,
                           users_in_memory,
                           & from_num_user,
                           & filled_num_users,
                           usr_in);
 
   for (have_more=HAVE_MORE;
          (have_more EQ HAVE_MORE)
         AND
          (rc EQ ESA_OK)
         AND
          (filled_num_users GT 0);
       )
   {
    CLEAR (ug_in);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (rc NE ESA_OK)
       goto cleanup;
 
 
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_USERS_CONNS, MAX_GET,
		0, filled_num_users, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(
        GET_USERS_CONNS,MAX_GET,&actual_num,
        &have_more, &handle, 0, filled_num_users,
        ug_in, usr_in, u2ug_data,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
 
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
                         "Conection group=%s to user=%s NOT EXIST ",
                         u2ug_data[ii].group, u2ug_data[ii].user);
        continue;
      }
      /* CHECK if group is already included in increment connections. */
      rc_u2ug= CARE_inc_u2ug_find (u2ug_data[ii].group);
      /* CHECK if group is already included in increment group names. */
      rc_ug= CARE_inc_ug_find (u2ug_data[ii].group);
 
      if (
            (rc_ug NE ESA_OK)
           AND
            (rc_u2ug NE ESA_OK)
         )
      {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group=%s to user=%s def ug=%s Not Interesting",
             u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
         continue;
      }
 
      /*
        CHECK if connection is defined in the ESS.
      */
      u2ugmem_num= CS_sync_u2ug_checksum_find (u2ug_data[ii].group,
                                               u2ug_mem_ptr,
                                               u2ug_mem_num,
                                               u2ug_data[ii].user);
      /*
        PROCESS when the connection is defined in the ESS:
      */
      if (u2ugmem_num LT u2ug_mem_num) {
        ugmem= u2ug_mem_ptr+ u2ugmem_num;
        ugmem->in_rss= '1';
        CLEAR_STRUCT (conn_param);
        strcpy (conn_param.user,  u2ug_data[ii].user);
        strcpy (conn_param.group, u2ug_data[ii].group);
        memcpy ((char *)(&conn_param.u2ug_prm),
                (char *)(&u2ug_data[ii]),
                sizeof (U2UG_PARAMS_rec_typ));
        /*
          CALCULATE the connection's checksum in the RSS.
        */
        rc= CS_sync_get_checksum ((char *)&conn_param, bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDU2UG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
      }
      else
	  {
        api= FUNC_ADDU2UG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s Not in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
	  }
      /*
        PROCESS when ADD/UPDATE connection message should be delivered:
      */
      if (u2ugmem_num GE u2ug_mem_num OR
          memcmp ((char *)checksum, (char *)ugmem->checksum,
                  CHECKSUM_LEN) NE 0) {
        /*
          ADD ADD/UPDATE connection message to message buffer.
        */
        memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
                 sizeof(USER_typ));
        memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
                sizeof(UG_typ));
        memcpy ((char *)usr_prm.def_group,
                (char *)u2ug_data[ii].def_group,
                sizeof(UG_typ));
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s send to IIQ/IDN for %s.",
			ug_prm.group, usr_prm.user, (api EQ FUNC_ADDU2UG) ? "ADD" : "UPDATE");
        msg=    CS_add_rs_msg (api, &usr_prm,&oe_prm, &ug_prm,
                               &u2ug_data[ii], addinfo[ii],
                               &rs_msg_len, &rs_num_msgs,
                               msg_rs, msg_rs_ptr,
                               &rs_umsg_len, &rs_num_umsgs,
                               umsg_rs, umsg_rs_ptr,
                               &rs_amsg_len, &rs_num_amsgs,
                               amsg_rs, amsg_rs_ptr,
                               msg_hdr, &sw_user, &sw_upd,
                               &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
        if (api EQ FUNC_ADDU2UG)
          statist->u2ug_add++;
        else
          statist->u2ug_upd++;
      } /* END ADD/UPDATE message should be delivered. */
      else {
        api= 0;
        statist->u2ug_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s Not sent to IIQ/IDN.",
			u2ug_data[ii].group, u2ug_data[ii].user);
      }
 
      statist->u2ug_ess++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->tmp_num(%d) stop_req_msgs(%d)=%d.",
		    statist->tmp_num, envir_ptr->stop_req_msgs,
			statist->tmp_num % envir_ptr->stop_req_msgs);
        if (statist->tmp_num % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
    } /* END - FOR loop on all current retrieved connections */
 
   } /* END - FOR loop on all connectiuons to current user portion */
 
  } /* END - FOR loop on all interesting users */
 
  if (rs_num_msgs NE 0) {
     rc = CS_send_cd_msg (&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs_ptr);
     if (rc NE ESA_OK)
        goto cleanup;
  }
  if (rs_num_umsgs NE 0) {
     rc = CS_send_cd_msg (&rs_umsg_len ,
                          &rs_num_umsgs ,
                          umsg_rs_ptr);
     if (rc NE ESA_OK)
        goto cleanup;
  }
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_DEL);
  for (u2ugmem_num= 0;
       u2ugmem_num LT u2ug_mem_num AND rc EQ ESA_OK;
       u2ugmem_num++) {
    ugmem= u2ug_mem_ptr+ u2ugmem_num;
    if (
         (ugmem->in_rss NE '1') /* '1' = connection found */
        AND
         (ugmem->in_rss NE '2') /* '2' = USER/GROUP deleted */
       ) {
      statist->u2ug_del++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
      CLEAR (u2ug_data);
      CLEAR_STRUCT (ug_prm);
      CLEAR_STRUCT (usr_prm);
      strcpy (usr_prm.user, ugmem->user);
      strcpy (ug_prm.group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
         "Conection User %s to group %s send to IIQ/IDN for DELETE",
             usr_prm.user, ug_prm.group);
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELU2UG, &usr_prm, &oe_prm,&ug_prm,
                             &u2ug_data[0], addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL) {
        rc = ESA_FATAL;
        goto cleanup;
      }
    }
  } /* END - FOR loop on all ESS connections */
  /*
    SEND left DELETE connection messages.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                 GET_FREE_HANDLE_CONNS,
                 MAX_GET, &actual_num,
                 &have_more, &handle, MAX_GET, MAX_GET,
                 ug_in, usr_in, u2ug_data,
                 addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CSA_free ((char **)&umsg_rs_ptr);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if (rc NE ESA_OK AND rc NE ESA_ABORT_REQ)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_sync_usr_u2ug*/
 
 
 
/****************************************************
 * Procedure Name: CS_sync_ess_definitions
 * Description   : Global sync functions
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the main function that handles GLOBAL SYNC
 * service. It reads messages from the mailbox and porcess them
 * according to their types. The following messages are expected
 * (in the following order - although no check is imposed):
 * - Interesting default groups.
 * - Interesting users
 * - Interesting groups
 * - ESS groups
 * - ESS users
 * - ESS connections
 * - Start sync.
 * - End service.
 *
 * After successfull termination of synchronisation - if the sync type
 * was FULL (i.e the interesting entities were ALL sent from the ESS
 * and they should replace the RSS interesting entities) - the
 * function sends events to nortify other CS/CD servers to re-load
 * the interesting files.
 ********************************************************************/
 
ESA_RC CS_sync_ess_definitions ( MSG_typ              * msg_ptr,
                                 RSS_MSG_HDR_rec_typ  * msg_hdr_cd)
{
  char                 fn[]="CS_sync_ess_definitions";
  ESA_RC               rc= ESA_OK, rc_unlock= ESA_OK;
  ESA_RC               rc_load= ESA_OK;
  char                 last_mhltl=' ';
  OE_MEM_rec_ptr       oe_mem_ptr= NULL;
  UG_MEM_rec_ptr       ug_mem_ptr= NULL;
  USR_MEM_rec_ptr      usr_mem_ptr= NULL;
  U2UG_MEM_rec_ptr     u2ug_mem_ptr= NULL;
  int                  u2ug_mem_num= 0,ug_mem_num= 0;
  int                  usr_mem_num=  0,oe_mem_num= 0;
  int                  sw_sync= 0;
  int                  statist_interval_num= STATIST_INTERVAL;
  int                  stat_interval_chksum_num= STAT_CHKSUM_INTERVAL;
  unsigned int         ii= 0;
  CSFLAG               current_srv= CSON;
  char                 dwnld_sync_method=M_DWNLD_SYNC_METHOD_UNDEFINED;
  RSS_MSG_HDR_rec_typ  msg_hdr;
  RSS_MSG_HDR_rec_typ  msg_hdr_sav;
  DATE_typ             cur_date;
  TIME_typ             cur_time;
  RESOURCE_typ         semaphore_file ;
  char                 rssprm_val[RSSPRM_VALUE_LEN+ 1];
  STATIST_rec_typ      statist;
  ENVIRONMENT_rec_typ *envir_ptr;
  char                 sync_user_list= ' ';
  char                 sync_group_list=' ';
  char                 sync_conn_list= ' ';
  char                 sync_oe_list=   ' ';
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  /*
    CLEAR all temporary used buffers.
  */
  envir_ptr->dwnld_sync_type= SYNC_FULL;
  envir_ptr->stop_req_msgs= 0;
  CLEAR (semaphore_file);
  CLEAR (cur_date);
  CLEAR (cur_time);
  CLEAR_STRUCT (msg_hdr);
  CLEAR_STRUCT (msg_hdr_sav);
 
  /* Set interval for statistic messages */
  envir_ptr->stop_req_msgs= 0;
  rc= rssprm_get (envir_ptr->all_rss, CHECK_SYNC_OBJS, 10, rssprm_val);
  if (rc EQ ESA_OK) {
    ii= strspn (rssprm_val, POSITIVE_VALUE);
    if (ii NE strlen (rssprm_val))
      CTSAMSG_print (
            ERR_CS_PRM_NOT_NUMERIC,
            envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
            envir_ptr->msg_admin_param.ctsamsg_dest,
            CHECK_SYNC_OBJS, rssprm_val,envir_ptr->file_rssparm);
    else
      envir_ptr->stop_req_msgs = atoi (rssprm_val);
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
        "By default %s parameter from %s is %d.",
         CHECK_SYNC_OBJS,
         envir_ptr->file_rssparm, envir_ptr->stop_req_msgs);
 
  /*
    SET interval for statistic messages
  */
 
  rc= rssprm_get_opt (envir_ptr->all_rss, STATIST_INTRVL, 10,
                      rssprm_val, OPT_TRUE, OPT_TRUE);
  if (rc EQ ESA_OK) {
    ii= strspn (rssprm_val, POSITIVE_VALUE);
    if (ii NE strlen (rssprm_val))
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     STATIST_INTRVL, rssprm_val,
                     envir_ptr->file_rssparm);
    else
      statist_interval_num= atoi (rssprm_val);
  }
  rc= rssprm_get_opt (envir_ptr->all_rss, STAT_CHKSUM_INTRVL, 10,
	                  rssprm_val, OPT_TRUE, OPT_TRUE);
  if (rc EQ ESA_OK) {
    ii= strspn (rssprm_val, POSITIVE_VALUE);
    if (ii NE strlen (rssprm_val))
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     STAT_CHKSUM_INTRVL, rssprm_val,
                     envir_ptr->file_rssparm);
    else
      stat_interval_chksum_num= atoi (rssprm_val);
  }
 
  memset ((char *)(&statist), '\0', sizeof(STATIST_rec_typ));
  statist.interval_num= statist_interval_num;
  statist.interval_chksum_num= stat_interval_chksum_num;
  statist.process= SYNC_PROCESS;
 
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
                   "rss id %s rss type %s",
                   envir_ptr->msg_admin_param.rss_name,
                   envir_ptr->msg_admin_param.rss_type);
 
  CSA_print_alloc_tbl (ESA_COMP_ACSSYNC, fn, TRUE);
  CSA_print_lock_tbl();
 
  /*
     27/9/99 Aviw
 
     Get RSS parameter indicating uniqueness of U2UG pairs in
	 checksum messages from ESS (Default = Unique)
 
  */
 
  rc= rssprm_get_opt (envir_ptr->all_rss,
/* 30/1/01 Aviw */
/*               	  U2UG_CHKSUM_UNIQ , */
	                  ESS_CHKSUM_UNIQ ,
					  10,
					  rssprm_val,
					  OPT_TRUE ,
					  OPT_FALSE);
  if (rc EQ ESA_OK)
  {
 
    if (My_stricmp (rssprm_val , ESS_YES_FLAG) EQ ESA_OK)
/*	   CS_trust_u2ug_uniq = 1;*/
	   CS_trust_chksum_uniq = 1;
     else
/*	   CS_trust_u2ug_uniq = 0;*/
	   CS_trust_chksum_uniq = 0;
 
	ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
                     "%s parameter found with value %s" ,
/*                     U2UG_CHKSUM_UNIQ,*/
                     ESS_CHKSUM_UNIQ,
                     rssprm_val);
  }
 else
/*	 CS_trust_u2ug_uniq = 1;*/
	 CS_trust_chksum_uniq = 1;
 
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
      "Connection pairs of checksum are %s trusted to be unique" ,
/*      (CS_trust_u2ug_uniq EQ 0) ? "NOT" : "");*/
      (CS_trust_chksum_uniq EQ 0) ? "NOT" : "");
/* 30/1/01 Aviw end*/
  /*
 
     Clear the last found user and group names and indexes
  */	
 
  memset (CS_lst_chksum_ug , 0 , sizeof(CS_lst_chksum_ug));
  memset (CS_lst_chksum_user , 0 , sizeof(CS_lst_chksum_user));
  CS_lst_chksum_ug_idx = 0;
  CS_lst_chksum_user_idx = 0;
  CS_u2ug_sorted = 0;
 
  /* 30/1/01 Aviw*/
 
  CS_ug_sorted = 0;
  CS_usr_sorted = 0;
  /* 30/1/01 Aviw end*/
 
  /*
    SAVE current message header.
  */
  memcpy ((char *)(&msg_hdr_sav), (char *)msg_hdr_cd,
          sizeof( RSS_MSG_HDR_rec_typ));
  /*
    LOCK offline semaphore to prevent offline interceptor activation or
    another global sync/dwnld activation.
  */
  rc= CSA_lock (
         envir_ptr->interest[envir_ptr->rss_num].file_ofli_semaphore,
         fn, SCOPE_LOCAL);
  if (rc NE ESA_OK)
  {
    CTSAMSG_print (MSG_SYNC_STOPED,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   envir_ptr->msg_admin_param.rss_name);
    goto cleanup;
  }
  /*
    GET messages from ESS of the service
  */
  while (current_srv EQ CSON) {
 
    CLEAR(msg_ptr);
    /*
      READ the next ESS message.
    */
    rc= CS_get_next_msg (msg_ptr , &msg_hdr);
    if (sw_sync EQ 0)                                     /* ??? */
    {                                                     /* ??? */
      if (COND(MSG_GLOBAL_SYNC))                          /* ??? */
         envir_ptr->dwnld_sync_type= DWNLD_SYNC_UNDEFINED;/* ??? */
      else                                                /* ??? */
      {                                                   /* ??? */
         sw_sync++;                                       /* ??? */
         sw_sync++;                                       /* ??? */
         CARE_int_usr_free ();                            /* ??? */
         CARE_int_oe_free  ();                            /* ??? */
         CARE_int_ug_free  ();                            /* ??? */
         CARE_int_u2ug_free();                            /* ??? */
         CTSAMSG_print (MSG_SYNC_STARTED ,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 envir_ptr->msg_admin_param.rss_name);
      }                                                   /* ??? */
 
      CS_get_cur_time (cur_date, cur_time);
 
    }                                                     /* ??? */
    /*
      SAVE current message header.
    */
    memcpy ((char *)(&msg_hdr_sav), (char *)(&msg_hdr),
            sizeof( RSS_MSG_HDR_rec_typ));
 
    last_mhltl= msg_hdr.mhltl;
 
    if (rc NE ESA_OK )
      goto cleanup;
    /*
      PROCESS messages according to messge type:
    */
 
    if (COND(MSG_PARTIAL_OE)) {
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Partial Scope for Containers.", MSG_PARTIAL_OE);
       if (sw_sync EQ 1)
       {
          sw_sync++;
          rc= CS_sync_lists_cmp (dwnld_sync_method,
                                 sync_user_list,
                                 sync_group_list,
                                 sync_conn_list,
                                 sync_oe_list);
       }
       if (rc EQ ESA_OK) /*AND (envir_ptr->num_oes NE 0))*/
          rc= CS_dwnld_inc_oe (msg_ptr, NULL);
    }
    else if (COND(MSG_PARTIAL_UG)) {
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Partial Scope for Default Groups.", MSG_PARTIAL_UG);
       if (sw_sync EQ 1)
       {
          sw_sync++;
          rc= CS_sync_lists_cmp (dwnld_sync_method,
                                 sync_user_list,
                                 sync_group_list,
                                 sync_conn_list,
                                 sync_oe_list);
       }
       if (rc EQ ESA_OK) /*AND (envir_ptr->num_ugs NE 0))*/
          rc= CS_dwnld_inc_ug(msg_ptr, NULL);
    }
    else if (COND(MSG_PARTIAL_USER)) {
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Partial Scope for Users", MSG_PARTIAL_USER);
       if (sw_sync EQ 1)
       {
          sw_sync++;
          rc= CS_sync_lists_cmp (dwnld_sync_method,
                                 sync_user_list,
                                 sync_group_list,
                                 sync_conn_list,
                                 sync_oe_list);
       }
       if (rc EQ ESA_OK) /*AND (envir_ptr->num_users NE 0))*/
          rc= CS_dwnld_inc_usr(msg_ptr, NULL);
    }
    else if (COND(MSG_PARTIAL_UG2UC)) {
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Partial Scope for Groups", MSG_PARTIAL_UG2UC);
       if (sw_sync EQ 1)
       {
          sw_sync++;
          rc= CS_sync_lists_cmp (dwnld_sync_method,
                                 sync_user_list,
                                 sync_group_list,
                                 sync_conn_list,
                                 sync_oe_list);
       }
       if (rc EQ ESA_OK) /*AND (envir_ptr->num_u2ugs NE 0))*/
          rc= CS_dwnld_inc_u2ug (msg_ptr, NULL);
    }
    else if (COND(MSG_INTEREST_OE))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Scope for Containers", MSG_INTEREST_OE);
       rc= CS_dwnld_inc_oe (msg_ptr, &statist);
	}
    else if (COND(MSG_INTEREST_UG))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Scope for Default Groups", MSG_INTEREST_UG);
       rc= CS_dwnld_inc_ug(msg_ptr, &statist);
	}
    else if (COND(MSG_INTEREST_USER))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Scope for Users", MSG_INTEREST_USER);
       rc= CS_dwnld_inc_usr(msg_ptr, &statist);
	}
    else if (COND(MSG_INTEREST_UG2UC))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Scope for Groups", MSG_INTEREST_UG2UC);
       rc= CS_dwnld_inc_u2ug (msg_ptr, &statist);
	}
    else if (COND(MSG_OE_FROM_ESS))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Checksum List for Containers", MSG_OE_FROM_ESS);
       rc= CS_sync_oe_checksum (msg_ptr, &statist, &oe_mem_ptr,
                                &oe_mem_num);
	}
    else if (COND(MSG_UG_FROM_ESS))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Checksum List for Default Groups", MSG_UG_FROM_ESS);
       rc= CS_sync_ug_checksum (msg_ptr, &statist, &ug_mem_ptr,
                                &ug_mem_num);
	}
    else if (COND(MSG_USER_FROM_ESS))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Checksum List for Users", MSG_USER_FROM_ESS);
       rc= CS_sync_usr_checksum(msg_ptr, &statist, &usr_mem_ptr,
                                &usr_mem_num);
	}
    else if (COND(MSG_UG2UC_FROM_ESS))
	{
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
           "*****>... %s - Checksum List for Groups", MSG_UG2UC_FROM_ESS);
       rc= CS_sync_u2ug_checksum(msg_ptr, &statist,
                                 &u2ug_mem_ptr, &u2ug_mem_num,
                                 usr_mem_ptr,   usr_mem_num,
                                 ug_mem_ptr,    ug_mem_num);
	}
    else if (COND(MSG_GLOBAL_SYNC)) {
      /*
        PROCESS the global sync. ACTUAL activities:
      */
       sw_sync++;
       if (sw_sync EQ 1)
       {
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
              "*****>... %s - First Inform. Global Sync Message", MSG_GLOBAL_SYNC);
          rc= CS_get_sync_params (msg_ptr, &dwnld_sync_method,
                          &sync_user_list, &sync_group_list,
                          &sync_conn_list, &sync_oe_list);
          if (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
          {
             CARE_int_usr_free ();
             CARE_int_oe_free  ();
             CARE_int_ug_free  ();
             CARE_int_u2ug_free();
             CTSAMSG_print (MSG_SYNC_STARTED ,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 envir_ptr->msg_admin_param.rss_name);
          }
          else
			  statist.process = PARTIAL_SYNC_PROCESS; /* Added by Amar for Partial Sync */
             CTSAMSG_print (MSG_PARTIAL_SYNC_STARTED ,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 envir_ptr->msg_admin_param.rss_name);
       }
       if (sw_sync GE 2)
       {
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
              "*****>... %s - Last Inform. Global Sync Message", MSG_GLOBAL_SYNC);
          if (sw_sync EQ 2)
          {
 
			 /* if (envir_ptr->dwnld_sync_type EQ SYNC_PARTIAL)
                rc= CS_sync_lists_cmp (dwnld_sync_method,
                                 sync_user_list,
                                 sync_group_list,
                                 sync_conn_list,
                                 sync_oe_list);
             else*/
                rc= CS_dwnld_sync_inc (dwnld_sync_method,
                                 sync_user_list, sync_group_list,
                                 sync_conn_list, sync_oe_list);
          }
          if (rc EQ ESA_OK)
             rc= CS_sync_global (&msg_hdr ,
                              msg_ptr,
                              &oe_mem_ptr,
                              &oe_mem_num,
                              &ug_mem_ptr,
                              &ug_mem_num,
                              &usr_mem_ptr,
                              &usr_mem_num,
                              &u2ug_mem_ptr,
                              &u2ug_mem_num,
                              &statist,
                              &dwnld_sync_method,
                              &sync_user_list,
                              &sync_group_list,
                              &sync_conn_list,
                              &sync_oe_list);
          if (rc EQ ESA_OK)
          /*
            SEND synchronization end message - upon successfull
                 completion.
          */
             rc = CS_send_end_of_sync_msg(&msg_hdr);
          last_mhltl= BLANK;
       }
    } /* END - message is global sync start request */
 
    /*
      PROCESS end of service indicator
    */
    else if (COND(END_OF_SERVICE))
	{
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
              "*****>... %s - End of Global Sync Service", END_OF_SERVICE);
      current_srv = CSOFF;
	}
    /*
      PROCESS undefined service
    */
    else {
      CTSAMSG_print (ERR_CS_UNDEF_MSG_TYP,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn,
                     &msg_hdr.mhmtyp);
      rc= ESA_FATAL;
      goto cleanup;
    } /* undefined service */
 
    /*
      PROCESS CS process termination:
    */
    if (rc EQ ESA_TERM_CTSA) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
            "Accepted TERM_CTSA code");
      /*
        MARK end of service - to exit.
      */
      current_srv = CSOFF;
    }
    /* error occurred */
    else if (rc NE ESA_OK) {
      goto cleanup;
    } /* END - terminate process request */
 
    /*
      CONFIRM message on temp last condition
    */
    else if (last_mhltl EQ MH_MESSAGE_LAST_TMP) {
      rc= CS_confirm (&msg_hdr);
      if (rc NE ESA_OK)
        goto cleanup;
    } /* END - temporary last message */
    /*
      LAST message indication the same as end of service
    */
    else if (last_mhltl EQ MH_MESSAGE_LAST)
      current_srv = CSOFF;
  } /* While there are more messages to come */
 
  if (
        (rc EQ ESA_OK)
       AND
        (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
     )
  {
    /*
      UPDATE the RSSOFLI file with the Global Sync start time
    */
    envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method=
        dwnld_sync_method;
 
    rc= CS_dwnld_sync_start (dwnld_sync_method,
                             cur_date,
                             cur_time);
    rc = OS_OFLI_sync (envir_ptr->msg_admin_param.rss_type ,
                       envir_ptr->msg_admin_param.rss_name ,
                       &envir_ptr->func_ptr,
                       &envir_ptr->msg_admin_param);
  }
  cleanup:
 
  /*
    CLEAR the increment users , groups and connections.
  */
  CSA_free ((char **)&usr_mem_ptr);
  CSA_free ((char **)&u2ug_mem_ptr);
  CSA_free ((char **)&ug_mem_ptr);
  CSA_free ((char **)&oe_mem_ptr);
 
  CARE_inc_oe_free ();
  CARE_inc_ug_free ();
  CARE_inc_usr_free ();
  CARE_inc_u2ug_free ();
 
  /*
    RELOAD the interesting users , groups and connections from files.
  */
 
     rc_load= CARE_int_oe_load ();
     if (rc EQ ESA_OK)
         rc= rc_load;
     rc_load= CARE_int_ug_load ();
     if (rc EQ ESA_OK)
         rc= rc_load;
     rc_load= CARE_int_usr_load ();
     if (rc EQ ESA_OK)
         rc= rc_load;
     rc_load= CARE_int_u2ug_load ();
     if (rc EQ ESA_OK)
         rc= rc_load;
     /*
       PROCESS when the "INTERESTING" files were updated:
     */
     rc_load= CS_broadcast (CS_BRDCT_EVNT_INTRST, EVENT_IMPOE_CHANGED);
     if (rc EQ ESA_OK)
         rc= rc_load;
 
  /*
    SEND log event of synchronization end.
  */
 
  CS_dwnld_event (&statist, STEP_END_PROC, END_FN, rc);
 
  /*
    UNLOCK the sync semaphore file.
  */
  rc_unlock= CSA_unlock
    (envir_ptr->interest[envir_ptr->rss_num].file_ofli_semaphore, fn);
  if (rc EQ ESA_OK)
    rc= rc_unlock;
 
  CSA_print_alloc_tbl (ESA_COMP_ACSSYNC, fn, TRUE);
  CSA_print_lock_tbl();
 
  if (rc EQ ESA_CANCEL_SERVICE)
    CTSAMSG_print (ERR_CS_SERVICE_CANCEL,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
  if ((rc NE ESA_OK) AND
      (rc NE ESA_TERM_CTSA)AND
      (rc NE ESA_CANCEL_SERVICE))
    CTSAMSG_print (ERR_CS_SERVICE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, envir_ptr->msg_ptr);
 
  envir_ptr->dwnld_sync_type= DWNLD_SYNC_UNDEFINED;
 
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_sync_ess_definitions function */
 
/****************************************************
 * Procedure Name: CS_sync_ug_checksum
 * Description   : Load groups and their's checksum to the memory
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function handles a "Default Group Checksum" message. It scans
 * all the users in the message, verfies the group uniquness and adds
 * it to the groups + checksums list in the memory.
 *********************************************************************/
 
ESA_RC CS_sync_ug_checksum (MSG_typ              * msg_ptr,
                            STATIST_rec_typ      * statist,
                            UG_MEM_rec_ptr       * ug_mem_ptr,
                            int                  * ug_mem_num)
{
  char fn[]="CS_sync_ug_checksum";
  ESA_RC                rc= ESA_OK;
  unsigned short        ii= 0, kk= 0;
  size_t                jj= 0;
  int                   ugmem_num= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  char                  checksum[CHECKSUM_LEN+ 1];
  TRAN_rec_typ          tran;
  UG_MEM_rec_typ      * TempUgPtr= NULL; /*[TMP_UGS_NUM];*/
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&TempUgPtr,
                   STRUC_UG_CHECK_REC,
                   sizeof (UG_MEM_rec_typ),
                   TMP_UGS_NUM,
                   fn,
                   "TempUg & checksums");
  if (rc NE ESA_OK)
	  goto cleanup;
 
  /*
    CLEAR all temporary structures.
  */
  memset (TempUgPtr, '\0', sizeof (UG_MEM_rec_typ) * TMP_UGS_NUM);
  CLEAR_STRUCT (tran);
  CLEAR (checksum);
  /*
    GET the general message header.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the RSS message header (= number of internal messages).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL) {
    rc = ESA_ERR;
    goto cleanup;
  }
  /*
    PROCESS all internal messages (groups).
  */
  for (kk =0, jj= 0 ; kk LT num_msgs AND rc EQ ESA_OK; kk++) {
    /*
      GET the internal message header.
    */
    msg_ptr = CS_get_singl_msg(&len_msg, &tran, msg_ptr);
    if (msg_ptr EQ NULL) {
      rc= ESA_ERR;
      goto cleanup;
    }
    /*
      GET current group's name.
    */
    msg_ptr = CS_get_fld (TempUgPtr[jj].ug ,
                          msg_ptr ,
                          envir_ptr->rss_limits.max_ug_len ,
                          C_GROUP_ID);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET the current group's checksum.
    */
    msg_ptr= CS_sync_get_ess_checksum (msg_ptr,TempUgPtr[jj].checksum);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      IGNORE the current group if it is NULL or NEWLINE.
    */
    if (*TempUgPtr[jj].ug EQ '\0' OR *TempUgPtr[jj].ug EQ '\n')
      continue;
 
    /* 30/1/01 Aviw
 
       PROCESS when uniqueness in checksums is not
	   guarentee
    */
	if (CS_trust_chksum_uniq EQ 0)
	{
 
    /*
      VERIFY the current user group's uniqueness among the other
      groups in temporary buffer.
    */
    for (ii= 0; ii LT (unsigned short)jj; ii++)
      if (strcmp (TempUgPtr[ii].ug, TempUgPtr[jj].ug) EQ 0)
        break;
    if (ii LT (unsigned short)jj)
      continue;
    /*
      VERIFY the current group name's uniquness among the groups in
      global memory.
    */
    ugmem_num= CS_sync_ug_checksum_find (TempUgPtr[jj].ug, *ug_mem_ptr,
                                         *ug_mem_num);
    if (ugmem_num LT *ug_mem_num)
      continue;
	}
	/* 30/1/01 Aviw */
 
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16) {
      memcpy ((char *)checksum, (char *)TempUgPtr[jj].checksum,
		     CHECKSUM_LEN);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                     "ug=%s checksum=%s.", TempUgPtr[jj].ug, checksum);
    }
    statist->ug_chk++;
    statist->tmp_num++;
    jj++;
    /*
      PROCESS when the temporary arry of groups is full:
    */
    if (jj EQ TMP_UGS_NUM- 1) {
      /*
        COPY all groups from temporary array to memory.
      */
      rc= CS_sync_ug_checksum_to_mem ((char *)TempUgPtr, ug_mem_ptr,
                                      ug_mem_num, (int)jj);
      memset (TempUgPtr, '\0', sizeof (UG_MEM_rec_typ) * TMP_UGS_NUM);
      jj= 0;
    }  /* END - Temporary array is full */
 
	CS_dwnld_event (statist, STEP_UG_CHKSUM, PROCESS_FN, rc);
 
  } /* END FOR loop on all internal messages */
  /*
    PROCESS when there are groups in the temporary array:
  */
  if (jj NE 0) {
    /*
      COPY all groups from temporary array to memory.
    */
      rc= CS_sync_ug_checksum_to_mem ((char *)TempUgPtr, ug_mem_ptr,
                                      ug_mem_num, (int)jj);
      memset (TempUgPtr, '\0', sizeof (UG_MEM_rec_typ) * TMP_UGS_NUM);
      jj= 0;
  }
 
  cleanup:
 
  CS_dwnld_event (statist, STEP_UG_CHKSUM, END_FN, rc);
  CSA_free ((char **)&TempUgPtr);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END -  CS_sync_ug_checksum function*/
 
/****************************************************
 * Procedure Name: CS_sync_usr_checksum
 * Description   : Load users and their's checksum to the memory
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function handles a "Users Checksum" message. It scans all users
 * in the message, verfies the user uniquness and adds it to the users
 * + checksums list in the memory.
 *********************************************************************/
 
ESA_RC CS_sync_usr_checksum (MSG_typ         * msg_ptr,
                             STATIST_rec_typ * statist,
                             USR_MEM_rec_ptr * usr_mem_ptr,
                             int             * usr_mem_num)
{
  char                  fn[]="CS_sync_usr_checksum";
  ESA_RC                rc= ESA_OK;
  unsigned short        ii= 0, kk= 0;
  size_t                jj= 0;
  int                   usrmem_num= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  char                  checksum[CHECKSUM_LEN+ 1];
  TRAN_rec_typ          tran;
  USR_MEM_rec_typ     * TempUserPtr= NULL; /*[TMP_USERS_NUM];*/
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&TempUserPtr,
                   STRUC_USER_CHECK_REC,
                   sizeof (USR_MEM_rec_typ),
                   TMP_USERS_NUM,
                   fn,
                   "TempUser & checksums");
  if (rc NE ESA_OK)
	  goto cleanup;
  /*
    CLEAR all temporary structures.
  */
  memset (TempUserPtr, '\0', sizeof (USR_MEM_rec_typ) * TMP_USERS_NUM);
  CLEAR_STRUCT (tran);
  CLEAR (checksum);
  /*
    GET the general message header.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the RSS message header (= number of internal messages).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL) {
    rc = ESA_ERR;
    goto cleanup;
  }
  /*
    PROCESS all internal messages (users).
  */
  for (kk =0, jj= 0 ; kk LT num_msgs AND rc EQ ESA_OK; kk++) {
    /*
      GET the internal message header.
    */
    msg_ptr = CS_get_singl_msg(&len_msg, &tran, msg_ptr);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET current user's name.
    */
    msg_ptr = CS_get_fld (TempUserPtr[jj].user,
                          msg_ptr,
                          envir_ptr->rss_limits.max_user_len,
                          C_USER_ID);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET the current user's checksum.
    */
    msg_ptr = CS_sync_get_ess_checksum (msg_ptr,
		                                TempUserPtr[jj].checksum);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      IGNORE the current user if it is NULL or NEWLINE.
    */
    if (*TempUserPtr[jj].user EQ '\0' OR *TempUserPtr[jj].user EQ '\n')
      continue;
 
    /* 30/1/01 Aviw
 
       PROCESS when uniqueness in checksums is not
	   guarentee
    */
	if (CS_trust_chksum_uniq EQ 0)
	{
 
    /*
      VERIFY the current user name's uniqueness among the other
      users in temporary buffer.
    */
    for (ii= 0; ii LT (unsigned short)jj; ii++)
      if (strcmp (TempUserPtr[ii].user, TempUserPtr[jj].user) EQ 0)
        break;
    if (ii LT (unsigned short)jj)
      continue;
    /*
      VERIFY the current user name's uniquness among the users in
      global memory.
    */
    usrmem_num= CS_sync_usr_checksum_find (TempUserPtr[jj].user,
                                  * usr_mem_ptr, * usr_mem_num);
    if (usrmem_num LT *usr_mem_num)
      continue;
	}
    /* 30/1/01 Aviw */
 
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16) {
      memcpy ((char *)checksum, (char *)TempUserPtr[jj].checksum,
		      CHECKSUM_LEN);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                       "usr=%s checksum=%s.", TempUserPtr[jj].user,
					   checksum);
    }
    /*
      PROCESS when the temporary arry of users is full:
    */
    statist->usr_chk++;
    statist->tmp_num++;
    jj++;
    if (jj EQ TMP_USERS_NUM- 1) {
      /*
        COPY all users from temporary array to memory.
      */
      rc= CS_sync_usr_checksum_to_mem ((char *)TempUserPtr,
		          usr_mem_ptr, usr_mem_num, (int)jj);
      memset (TempUserPtr, '\0',
		      sizeof (USR_MEM_rec_typ) * TMP_USERS_NUM);
      jj= 0;
    } /* END - temporary array is full */
 
	CS_dwnld_event (statist, STEP_USR_CHKSUM, PROCESS_FN, rc);
 
  }  /* END FOR loop on all internal messages */
  /*
    PROCESS when there are users in the temporary array:
  */
  if (jj NE 0) {
    /*
      COPY all users from temporary array to memory.
    */
    rc= CS_sync_usr_checksum_to_mem ((char *)TempUserPtr, usr_mem_ptr,
                                       usr_mem_num, (int)jj);
    memset (TempUserPtr, '\0',
		    sizeof (USR_MEM_rec_typ) * TMP_USERS_NUM);
      jj= 0;
  }
 
  cleanup:
 
  CS_dwnld_event (statist, STEP_USR_CHKSUM, END_FN, rc);
  CSA_free ((char **)&TempUserPtr);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_usr_checksum function */
 
/****************************************************
 * Procedure Name: CS_sync_u2ug_checksum
 * Description   : Load connections and their's checksum
 *                      to the memory
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function handles a "Connection Checksum" message. It scans
 * all the users/group pairs in the message, verfies the pair uniquness
 * and adds it to the connections + checksums list in the memory.
 *********************************************************************/
 
ESA_RC CS_sync_u2ug_checksum (MSG_typ                * msg_ptr,
                              STATIST_rec_typ        * statist,
                              U2UG_MEM_rec_ptr       * u2ug_mem_ptr,
                              int                    * u2ug_mem_num,
                              USR_MEM_rec_ptr          usr_mem_ptr,
                              int                      usr_mem_num,
                              UG_MEM_rec_ptr           ug_mem_ptr,
                              int                      ug_mem_num)
{
  char fn[]="CS_sync_u2ug_checksum";
  ESA_RC                rc= ESA_OK;
  unsigned short        ii= 0, kk= 0;
  size_t                jj= 0;
  int                   u2ugmem_num= 0, usrmem_num= 0, ugmem_num= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  char                  checksum[CHECKSUM_LEN+ 1];
  TRAN_rec_typ          tran;
  U2UG_MEM_rec_typ    * TempU2ugPtr= NULL; /*[TMP_U2UGS_NUM];*/
  USR_MEM_rec_ptr       tmp_usr_mem_ptr;
  UG_MEM_rec_ptr        tmp_ug_mem_ptr;
  UG_typ                tmpug;
  USER_typ              tmpuser;
  ENVIRONMENT_rec_typ * envir_ptr;
  int                   is_sorted;  /* 30/1/01 Aviw */
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  rc= CSA_alloc ((char **)&TempU2ugPtr,
                   STRUC_U2UG_CHECK_REC,
                   sizeof (U2UG_MEM_rec_typ),
                   TMP_U2UGS_NUM,
                   fn,
                   "TempU2ug & checksums");
  if (rc NE ESA_OK)
	  goto cleanup;
 
  /*
    CLEAR all temporary structures.
  */
  memset (TempU2ugPtr, '\0',
	      sizeof (U2UG_MEM_rec_typ) * TMP_U2UGS_NUM);
  CLEAR_STRUCT (tran);
  CLEAR (checksum);
  CLEAR (tmpug);
  CLEAR (tmpuser);
 
  /*
      30/1/01 Aviw	
      Sort users checksums (from ESS)
	  according to Username
  */
 
  if (CS_usr_sorted EQ 0)
  {
     is_sorted = CS_usr_is_sorted (usr_mem_ptr, usr_mem_num);
 
     if (is_sorted EQ 0)
     {
        qsort (usr_mem_ptr ,
               usr_mem_num ,
	 	       sizeof(USR_MEM_rec_typ) ,
	 		   CS_cmpr_usr_entry);
     };
	 CS_usr_sorted = 1;
  }
/*
      30/1/01 Aviw	
      Sort groups checksums (from ESS)
	  according to Groupname
  */
 
  if (CS_ug_sorted EQ 0)
  {
     is_sorted = CS_ug_is_sorted (ug_mem_ptr, ug_mem_num);
 
     if (is_sorted EQ 0)
     {
        qsort (ug_mem_ptr ,
               ug_mem_num ,
	 	       sizeof(UG_MEM_rec_typ) ,
	 		   CS_cmpr_ug_entry);
     };
	 CS_ug_sorted = 1;
  }
 
  /*
    GET the general message header.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the RSS message header (= number of internal messages).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL)
  {
    rc = ESA_ERR;
    goto cleanup;
  }
  /*
    PROCESS all internal messages (groups).
  */
  for (kk =0, jj= 0 ; kk LT num_msgs AND rc EQ ESA_OK; kk++)
  {
    /*
      GET the internal message header.
    */
    msg_ptr = CS_get_singl_msg(&len_msg, &tran, msg_ptr);
    if (msg_ptr EQ NULL)
	{
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET connection's group's name.
    */
    msg_ptr = CS_get_fld (tmpug,
                          msg_ptr,
                          envir_ptr->rss_limits.max_ug_len,
                          C_GROUP_ID);
    if (msg_ptr EQ NULL)
	{
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET connection's user name
    */
    msg_ptr = CS_get_fld (tmpuser,
                          msg_ptr,
                          envir_ptr->rss_limits.max_user_len,
                          C_USER_ID);
    if (msg_ptr EQ NULL)
	{
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET the current connection's checksum.
    */
    msg_ptr = CS_sync_get_ess_checksum (msg_ptr,
		                                TempU2ugPtr[jj].checksum);
    if (msg_ptr EQ NULL)
	{
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      IGNORE the current connection if the user or group is NULL or
      NEWLINE.
    */
    if (tmpug[0] EQ '\0' OR tmpug[0] EQ '\n')
      continue;
    if (tmpuser[0] EQ '\0' OR tmpuser[0] EQ '\n')
      continue;
 
    /* 27/9/99 Aviw
 
       PROCESS when uniqueness in pairs of U2UG checksums is not
	   guarentee
    */
/* 30/1/01 Aviw */
/*	if (CS_trust_u2ug_uniq EQ 0)*/
	if (CS_trust_chksum_uniq EQ 0)
	{
 
	  /*
         VERIFY the current pair group's uniqueness among the other
         connections in temporary buffer.
      */
 
	  for (ii= 0; ii LT (unsigned short)jj; ii++)
        if (strcmp (TempU2ugPtr[ii].ug, tmpug) EQ 0 AND
            strcmp (TempU2ugPtr[ii].user, tmpuser) EQ 0)
          break;
 
	  if (ii LT (unsigned short)jj)
        continue;
 
	  /*
         VERIFY the current pair uniquness among the pairs in
         global memory.
      */
 
	  u2ugmem_num= CS_sync_u2ug_checksum_find (tmpug, *u2ug_mem_ptr,
                                               *u2ug_mem_num, tmpuser);
      if (u2ugmem_num LT *u2ug_mem_num)
        continue;
 
      if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
	  {
        memcpy((char *)checksum, (char *)TempU2ugPtr[jj].checksum,
			   CHECKSUM_LEN);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ug=%s usr=%s checksum=%s.",
                         tmpug, tmpuser, checksum);
	  }
 
	}
 
	/*
      VERIFY the current user name's uniquness among the users in
      global memory.
    */
 
    /* 27/9/99 Aviw */
 
	if (strcmp (CS_lst_chksum_user , tmpuser) EQ 0)
      usrmem_num = CS_lst_chksum_user_idx ;
   else
	{
      usrmem_num= CS_sync_usr_checksum_find (tmpuser,
                                             usr_mem_ptr,
		                                     usr_mem_num);
 
      if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                            "tmpuser=%s usrmem_num=%d usr_mem_num=%d.",
                            tmpuser, (int)usrmem_num, (int)usr_mem_num);
 
      strcpy (CS_lst_chksum_user , tmpuser);
	  CS_lst_chksum_user_idx = usrmem_num;
	}
 
   if (usrmem_num GE usr_mem_num)
      continue;
 
    /*
      VERIFY the current group name's uniquness among the groups in
      global memory.
    */
 
 
    /* 27/9/99 Aviw */
 
	if (strcmp (CS_lst_chksum_ug , tmpug) EQ 0)
      ugmem_num = CS_lst_chksum_ug_idx ;
   else
	{
 
	   ugmem_num= CS_sync_ug_checksum_find (tmpug, ug_mem_ptr,
                                            ug_mem_num);
       if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                            "tmpug=%s ugmem_num=%d ug_mem_num=%d.",
                            tmpug, (int)ugmem_num, (int)ug_mem_num);
      strcpy (CS_lst_chksum_ug, tmpug);
	  CS_lst_chksum_ug_idx = ugmem_num;
	}
 
    if (ugmem_num GE ug_mem_num)
         continue;
 
    tmp_ug_mem_ptr = ug_mem_ptr+ ugmem_num;
    tmp_usr_mem_ptr= usr_mem_ptr+ usrmem_num;
    TempU2ugPtr[jj].ug     = tmp_ug_mem_ptr->ug;
    TempU2ugPtr[jj].user   = tmp_usr_mem_ptr->user;
 
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ug=%s usr=%s.",
                         TempU2ugPtr[jj].ug, TempU2ugPtr[jj].user);
 
    statist->u2ug_chk++;
    statist->tmp_num++;
    jj++;
    /*
      PROCESS when the temporary arry of pairs is full:
    */
    if (jj EQ TMP_U2UGS_NUM- 1)
	{
      /*
        COPY all pairs from temporary array to memory.
      */
      rc= CS_sync_u2ug_checksum_to_mem ((char *)TempU2ugPtr,
		                 u2ug_mem_ptr, u2ug_mem_num, (int)jj);
      memset (TempU2ugPtr, '\0',
	          sizeof (U2UG_MEM_rec_typ) * TMP_U2UGS_NUM);
      jj= 0;
 
	}   /* END - Temporary array is full */
 
    CS_dwnld_event (statist, STEP_U2UG_CHKSUM, PROCESS_FN, rc);
 
  } /* END FOR loop on all internal messages */
 
  /*
    PROCESS when there are pairs in the temporary array:
  */
 
  if (jj NE 0)
  {
 
    /*
      COPY all pairs from temporary array to memory.
    */
      rc= CS_sync_u2ug_checksum_to_mem ((char *)TempU2ugPtr,
		              u2ug_mem_ptr, u2ug_mem_num, (int)jj);
      memset (TempU2ugPtr, '\0',
	          sizeof (U2UG_MEM_rec_typ) * TMP_U2UGS_NUM);
      jj= 0;
  }
 
cleanup:
 
  CS_dwnld_event (statist, STEP_U2UG_CHKSUM, END_FN, rc);
  CSA_free ((char **)&TempU2ugPtr);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_u2ug_checksum function */
 
/****************************************************
 * Procedure Name: CS_sync_ug_checksum_to_mem
 * Description   : Add 'j' groups and their's checksum
 *                   to memory.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function copies group's checksum details from fixed array
 * to dynamic allocated memory. It's either allocates new segment or
 * expand an existing segment to include the additional group's details.
 *********************************************************************/
 
ESA_RC CS_sync_ug_checksum_to_mem (char           * tmp,
                                   UG_MEM_rec_ptr * ug_mem_ptr,
                                   int            * ug_mem_num,
                                   int              j)
{
  char fn[]="CS_sync_ug_checksum_to_mem";
  ESA_RC                rc = ESA_OK;
  /*
    PROCESS when no group checksum resides in the memory yet:
  */
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  if (*ug_mem_num EQ 0)
    /*
      ALLOCATE memory segment for the number of input groups.
    */
    rc= CSA_alloc ((char **)ug_mem_ptr,
                   STRUC_UG_CHECK_REC,
                   sizeof (UG_MEM_rec_typ),
                   j,
                   fn,
                   "Group & checksums");
  else
    /*
      REALLOCATE memory segment for the additional number of groups.
    */
    rc= CSA_realloc ((char **)ug_mem_ptr,
                     STRUC_UG_CHECK_REC,
                     sizeof (UG_MEM_rec_typ),
                     *ug_mem_num+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY the input groups details to the "new" segment portion that
    was allocated.
  */
  memcpy ((char *)(*ug_mem_ptr+ *ug_mem_num),
          (char *)tmp,
          sizeof (UG_MEM_rec_typ)* j);
  *ug_mem_num += j;
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return rc;
} /* END - CS_sync_ug_checksum_to_mem function */
 
 
/****************************************************
 * Procedure Name: CS_sync_oe_checksum_to_mem
 * Description   : Add 'j' containers and their's checksum
 *                   to memory.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function copies container's checksum details from fixed array
 * to dynamic allocated memory. It's either allocates new segment or
 * expand an existing segment to include the additional container's
 * details.
 *********************************************************************/
 
ESA_RC CS_sync_oe_checksum_to_mem(char           * tmp,
                                  OE_MEM_rec_ptr * oe_mem_ptr,
                                  int            * oe_mem_num,
                                  int              j)
{
  char fn[]="CS_sync_oe_checksum_to_mem";
  ESA_RC                rc = ESA_OK;
  /*
    PROCESS when no container checksum resides in the memory yet:
  */
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  if (*oe_mem_num EQ 0)
    /*
      ALLOCATE memory segment for the number of input containers.
    */
    rc= CSA_alloc ((char **)oe_mem_ptr,
                   STRUC_OE_CHECK_REC,
                   sizeof (OE_MEM_rec_typ),
                   j,
                   fn,
                   "Containers & checksums");
  else
    /*
      REALLOCATE memory segment for the additional number of containers.
    */
    rc= CSA_realloc ((char **)oe_mem_ptr, STRUC_OE_CHECK_REC,
                     sizeof (OE_MEM_rec_typ),
                     *oe_mem_num+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY the input containers details to the "new" segment portion that
    was allocated.
  */
  memcpy ((char *)(*oe_mem_ptr+ *oe_mem_num),
          (char *)tmp,
          sizeof (OE_MEM_rec_typ)* j);
  *oe_mem_num += j;
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return rc;
} /* END - CS_sync_oe_checksum_to_mem function */
 
/****************************************************
 * Procedure Name: CS_sync_usr_checksum_to_mem
 * Description   : Add 'j' users and their's checksum
 *                   to memory.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function copies user's checksum details from fixed array
 * to dynamic allocated memory. It's either allocates new segment or
 * expand an existing segment to include the additional user's details.
 *********************************************************************/
 
ESA_RC CS_sync_usr_checksum_to_mem (char            * tmp,
                                   USR_MEM_rec_ptr * usr_mem_ptr,
                                   int             * usr_mem_num,
                                   int               j)
{
  char fn[]="CS_sync_usr_checksum_to_mem";
  ESA_RC                rc = ESA_OK;
  /*
    PROCESS when no user checksum resides in the memory yet:
  */
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  if (*usr_mem_num EQ 0)
    /*
      ALLOCATE memory segment for the number of input users.
    */
    rc= CSA_alloc ((char **)usr_mem_ptr,
                   STRUC_USER_CHECK_REC,
                   sizeof (USR_MEM_rec_typ),
                   j,
                   fn,
                   "Users & checksums");
  else
    /*
      REALLOCATE memory segment for the additional number of users.
    */
    rc= CSA_realloc ((char **)usr_mem_ptr, STRUC_USER_CHECK_REC,
                     sizeof (USR_MEM_rec_typ),
                     *usr_mem_num+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY the input users details to the "new" segment portion that
    was allocated.
  */
  memcpy ((char *)(*usr_mem_ptr+ *usr_mem_num),
          (char *)tmp,
          sizeof (USR_MEM_rec_typ)* j);
  *usr_mem_num += j;
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CS_sync_usr_checksum_to_mem function */
 
/****************************************************
 * Procedure Name: CS_sync_u2ug_checksum_to_mem
 * Description   : Add 'j' connections and their's checksum
 *                   to memory.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function copies connection's checksum details from fixed array
 * to dynamic allocated memory. It's either allocates new segment or
 * expand an existing segment to include the additional connection's
 * details.
 *********************************************************************/
 
ESA_RC CS_sync_u2ug_checksum_to_mem (char             * tmp,
                                     U2UG_MEM_rec_ptr * u2ug_mem_ptr,
                                     int              * u2ug_mem_num,
                                     int                j)
{
  char fn[]="CS_sync_u2ug_checksum_to_mem";
  ESA_RC                rc = ESA_OK;
  /*
    PROCESS when no connection checksum resides in the memory yet:
  */
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  if (*u2ug_mem_num EQ 0)
    /*
      ALLOCATE memory segment for the number of input connections.
    */
    rc= CSA_alloc ((char **)u2ug_mem_ptr,
                   STRUC_U2UG_CHECK_REC,
                   sizeof (U2UG_MEM_rec_typ),
                   j,
                   fn,
                   "Connections & checksums");
  else
    /*
      REALLOCATE memory segment for the additional number of
      connections.
    */
    rc= CSA_realloc ((char **)u2ug_mem_ptr, STRUC_U2UG_CHECK_REC,
                     sizeof (U2UG_MEM_rec_typ),
                     *u2ug_mem_num+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY the input connections details to the "new" segment portion
    that was allocated.
  */
  memcpy ((char *)(*u2ug_mem_ptr+ *u2ug_mem_num),
          (char *)tmp,
          sizeof (U2UG_MEM_rec_typ)* j);
  *u2ug_mem_num += j;
 
  cleanup:
 
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CS_sync_u2ug_checksum_to_mem function */
 
/****************************************************
 * Procedure Name: CS_sync_get_ess_checksum
 * Description   : Get checksum field from ESS message
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
MSG_typ * CS_sync_get_ess_checksum (MSG_typ      * msg_ptr,
                                    CHECKSUM_typ   checksum)
{
  char fn[]="CS_sync_get_ess_checksum";
  char        buf [CHECKSUM_LEN+ 1];
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  CLEAR (buf);
  msg_ptr = CS_get_fld (buf, msg_ptr, CHECKSUM_LEN,
                        C_CHEKSUM);
  if (msg_ptr EQ NULL) {
      msg_ptr= NULL;
      goto cleanup;
  }
  memcpy ((char *)checksum, (char *)buf, CHECKSUM_LEN);
  cleanup:
  if (msg_ptr EQ NULL)
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11, "Fail %s", fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON,
                 fn, ESA_RC_VOID);
 
  return (msg_ptr);
} /* END - CS_sync_get_ess_checksum function */
 
/****************************************************
 * Procedure Name: CS_sync_global
 * Description   : global sync. process
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated in order to perform the actual
 * RSS <-> ESS synchronization.
 * The synchronization service first receives and handle messages of
 * the ESS interesting users , group and default_groups, afterwards it
 * receives and handle messages of the the ESS users , groups and
 * connections' checksums. Only after handling the above messages - the
 * ESS sends a (second) START SYNC message that causes the activation
 * of the current function.
 * The function first copies the increment users/groups/connections in
 * the "envir" to the intresesting users/groups/connections in the
 * envir and then it starts to synchronize the D.B entities in the
 * following order:
 * - GROUPS
 * - USERS
 * - CONNECTIONS
 *
 * In general, every synchronization step, involvs with retrieving
 * information from the RSS database, checking each entity existance in
 * "interesting entities list" and for entitiess that do appears in the
 * list, checking it's existance in the ESS entities list and producing
 * ADD entity message for entities that are not defined in the ESS, and
 * UPDATE entity message for entities that are defined in the ESS but
 * the entity's RSS checksum and the entity's ESS checksum does not
 * match. The next step is usually intercepting entities that appear in
 * the ESS entities list and are not defined in the RSS - and producing
 * message to DELET them.
 * The RSS database search may be done, for every entity from user/ug/
 * connection, on ALL entities or via the list of INTERESTING entities.
 * The ESS may decide what will be the type of search , in order to
 * efficient the search process - for that is states the "PROCESS
 * TYPE". Generally the function activates the ALL search if there is
 * a wild card entity among the INTERESTING entities list
 *
 * PLEASE NOTE that if only INTERESTING users are retrieved - users
 * that are supposed to be defined on the ESS due to their default
 * group that is included in the list of INTERESTING default groups -
 * and are NOT defined there - FOR SUCH USERS - the CS_sync_usr
 * function DOES NOT PRODUCE ADD_USER MESSAGES. tHE ADD_USER messages
 * in THIS case are taken care by the function that handles connections
 * (CS_sync_u2ug or CS_sync_u2ug_all).
 *
 * The SYNC process may update the INTERESTING users/groups/connections
 * that are defined in the platform - this is governed by the SYNC TYPE
 * indiicator that equals to - M_SYNC_FULL ! In such case the
 * interesting entities files are updated.
 *
 * In case when the sync type contains the M_SYNC_PARTIAL value - we
 * expect to receive ONLY THE RELEVANT INTERESTING ENTITIES - AND THEIR
 * RELATED ESS (CHECKSUM) ENTITIES - AND NOTHING ELSE !! If, from any
 * reason the ESS will send entities that DOES NOT relate to the
 * INTERESTING entities - they will be deleted !!!
 *
 * IMPORTENT NOTE - Up to now - the ESS ALWAYS uses FULL sync with
 * M_MANY process type !!
 *********************************************************************/
 
ESA_RC CS_sync_global (RSS_MSG_HDR_rec_typ   * msg_hdr ,
                       MSG_typ               * msg_ptr,
                       OE_MEM_rec_ptr        * oe_mem_ptr,
                       int                   * oe_mem_num,
                       UG_MEM_rec_ptr        * ug_mem_ptr,
                       int                   * ug_mem_num,
                       USR_MEM_rec_ptr       * usr_mem_ptr,
                       int                   * usr_mem_num,
                       U2UG_MEM_rec_ptr      * u2ug_mem_ptr,
                       int                   * u2ug_mem_num,
                       STATIST_rec_typ       * statist,
                       char                  * dwnld_sync_method,
                       char                  * sync_user_list,
                       char                  * sync_group_list,
                       char                  * sync_conn_list,
                       char                  * sync_oe_list)
{
  char fn[]="CS_sync_global";
  ESA_RC                rc= ESA_OK, rc_ug= ESA_OK;
  ESA_RC                rc_oe= ESA_OK, rc_u2ug= ESA_OK,rc_usr= ESA_OK;
  char                  interval[RSSPRM_VALUE_LEN+ 1];
  char                * ug_typ_ptr= NULL;
  int                   ug_typ_num= 0;
  char                * user_memory= NULL;
  int                   user_memory_init= 0, users_in_memory= 0;
  int                   is_sorted;                  /* BS2402 */
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  /*
      27/9/99 Aviw	
      Sort connections checksums (from ESS)
	  according to Username + Groupname
  */
 
  if (CS_u2ug_sorted EQ 0)
  {
     /* BS2402 */
     is_sorted = CS_is_sorted (*u2ug_mem_ptr, *u2ug_mem_num);
 
     if (is_sorted EQ 0)
     {
        qsort (*u2ug_mem_ptr ,
               *u2ug_mem_num ,
	 	       sizeof(U2UG_MEM_rec_typ) ,
	 		   CS_cmpr_u2ug_entry);
     }; /* End of BS2402 */
	 CS_u2ug_sorted = 1;
  }
 
  /*
      30/1/01 Aviw	
      Sort users checksums (from ESS)
	  according to Username
 
      THIS USUALLY IS DONE IN U2UG checksums. It will be done here
	  if NO U2UG checksums arrives from ESS
 
  */
 
  if (CS_usr_sorted EQ 0)
  {
     is_sorted = CS_usr_is_sorted (* usr_mem_ptr, * usr_mem_num);
 
     if (is_sorted EQ 0)
     {
        qsort (*usr_mem_ptr ,
               *usr_mem_num ,
	 	       sizeof(USR_MEM_rec_typ) ,
	 		   CS_cmpr_usr_entry);
     };
	 CS_usr_sorted = 1;
  }
/*
      30/1/01 Aviw	
      Sort groups checksums (from ESS)
	  according to Groupname
 
      THIS USUALLY IS DONE IN U2UG checksums. It will be done here
	  if NO U2UG checksums arrives from ESS
 
*/
 
  if (CS_ug_sorted EQ 0)
  {
     is_sorted = CS_ug_is_sorted (*ug_mem_ptr, *ug_mem_num);
 
     if (is_sorted EQ 0)
     {
        qsort (*ug_mem_ptr ,
               *ug_mem_num ,
	 	       sizeof(UG_MEM_rec_typ) ,
	 		   CS_cmpr_ug_entry);
     };
	 CS_ug_sorted = 1;
  }
 
  if (
        (envir_ptr->dwnld_sync_type EQ SYNC_PARTIAL)
       OR
        (*dwnld_sync_method         EQ M_DWNLD_SYNC_METHOD_UNDEFINED)
     )
  {
     rc= CS_get_sync_params (msg_ptr, dwnld_sync_method,
                             sync_user_list, sync_group_list,
                             sync_conn_list, sync_oe_list);
     if (rc NE ESA_OK)
        goto cleanup;
     if (envir_ptr->num_ugs EQ 0)
        *sync_group_list= M_DWNLD_SYNC_LIST_NOT;
     if (envir_ptr->num_users EQ 0)
        *sync_user_list= M_DWNLD_SYNC_LIST_NOT;
     if (envir_ptr->num_u2ugs EQ 0)
        *sync_conn_list= M_DWNLD_SYNC_LIST_NOT;
     if (envir_ptr->num_oes EQ 0)
        *sync_oe_list= M_DWNLD_SYNC_LIST_NOT;
     rc= CS_dwnld_sync_inc (*dwnld_sync_method, *sync_user_list,
                            *sync_group_list, *sync_conn_list,
                            *sync_oe_list);
     if (rc NE ESA_OK)
        goto cleanup;
  }
 
  /* Write to log list of interesting users , groups and default
     groups
     */
 
  if (envir_ptr->dwnld_sync_type EQ SYNC_PARTIAL)
     CTSAMSG_print (MSG_PRTL_SYNC_CRITERIA,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest);
  else
     CTSAMSG_print (MSG_ESS_DWNLD_CRITERIA,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest);
  CARE_list_oe  (envir_ptr->oes_ptr,   envir_ptr->num_oes);
  CARE_list_ug  (envir_ptr->ugs_ptr,   envir_ptr->num_ugs);
  CARE_list_u2ug(envir_ptr->u2ugs_ptr, envir_ptr->num_u2ugs);
  CARE_list_usr (envir_ptr->users_ptr, envir_ptr->num_users);
 
  CLEAR (interval);
  /*
    GET all message header details.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
 
  /*
    SET interesting users,groups & connections pointers and number (in
    memory) to point to the increment users,groups & connections that
    already resides in the memory.
  CARE_inc_to_int_copy ();
  */
 
  /*
    CHECK users,groups & connections in memory - if they include
    "ALL" item .
  */
 
  if (
	    (envir_ptr->num_users EQ 0)
       AND
	    (envir_ptr->num_ugs   EQ 0)
       AND
	    (envir_ptr->num_oes   EQ 0)
       AND
	    (envir_ptr->num_u2ugs EQ 0)
     )
  {
      CTSAMSG_print (MSG_PARTIAL_SYNC_EMPTY,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
				   envir_ptr->msg_admin_param.rss_name);
	  rc= ESA_ERR;
  }
 
  if (rc EQ ESA_OK)
  {
     rc_usr= CARE_inc_usr_find  (envir_ptr->empty_user,
                                 M_DWNLD_NAME_ALL);
     rc_ug=  CARE_inc_ug_find   (envir_ptr->empty_ug);
     rc_oe=  CARE_inc_oe_find   (envir_ptr->empty_oe);
     rc_u2ug=CARE_inc_u2ug_find (envir_ptr->empty_ug);
 
     if (*oe_mem_num)
	 {
       if (*dwnld_sync_method   EQ M_DWNLD_SYNC_METHOD_SUBTREE)
          rc= CS_sync_oe_subtree (msg_hdr, *oe_mem_ptr,
                                  *oe_mem_num, statist);
       else if (rc_oe  EQ ESA_OK)
          rc= CS_sync_oe_all (msg_hdr,
                              *oe_mem_ptr, *oe_mem_num, statist);
       else
          rc= CS_sync_oe (msg_hdr,
                          *oe_mem_ptr, *oe_mem_num, statist);
	 }
     if (rc EQ ESA_NOT_SUPP)
        rc = ESA_OK;
  }
 
  if (rc EQ ESA_OK)
  {
     if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_SUBTREE)
       rc= CS_sync_ug_oe (msg_hdr,
                          *ug_mem_ptr, *ug_mem_num, statist,
                          *u2ug_mem_ptr, *u2ug_mem_num,
                          &ug_typ_ptr, &ug_typ_num);
     else if (
         (rc_ug   EQ ESA_OK)
             OR
         (rc_u2ug EQ ESA_OK)
         )
       rc= CS_sync_ug_all (msg_hdr,
                           *ug_mem_ptr, *ug_mem_num, statist,
                           *u2ug_mem_ptr, *u2ug_mem_num);
     else
        rc= CS_sync_ug (msg_hdr,
                        *ug_mem_ptr, *ug_mem_num, statist,*u2ug_mem_ptr,
                        *u2ug_mem_num);
     if (rc EQ ESA_NOT_SUPP)
        rc = ESA_OK;
  }
  /*
    RELEASE the checksum groups memory - no need for it any more.
  */
  /*
    PROCESS when there is WILD user among the users list,
    OR when the ESS specifically requests that ALL user will be
    retrieved:
  */
  if (rc EQ ESA_OK)
  {
    if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_SUBTREE)
       rc= CS_sync_usr_oe(msg_hdr,
                          *usr_mem_ptr, *usr_mem_num, statist,
                          *u2ug_mem_ptr, *u2ug_mem_num);
    else if (rc_usr EQ ESA_OK)
       rc= CS_sync_usr_all(msg_hdr,
                           *usr_mem_ptr, *usr_mem_num, statist,
                           *u2ug_mem_ptr, *u2ug_mem_num);
    else
      rc= CS_sync_usr    (msg_hdr,
                          *usr_mem_ptr, *usr_mem_num, statist,
                          *u2ug_mem_ptr, *u2ug_mem_num,
                          &user_memory,
                          &user_memory_init,
                          &users_in_memory);
     if (rc EQ ESA_NOT_SUPP)
        rc = ESA_OK;
  }
 
  /*
    DO NOT release the users checksum memory - it will be needed in
    the connections!!!
  */
 
  if (rc EQ ESA_OK)
  {
     if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_SUBTREE)
       rc= CS_sync_u2ug_oe (msg_hdr,
                            *u2ug_mem_ptr, *u2ug_mem_num, statist,
                            ug_typ_ptr, ug_typ_num);
    /*
      PROCESS when there is WILD group among the default-groups
      or the groups-for-connections list; OR when the ESS specifically
      requests that ALL connections will be retrieved:
    */
    else if (
             (rc_ug      EQ ESA_OK)
               OR
             (
               (rc_usr  EQ ESA_OK)
                   AND
               (rc_u2ug EQ ESA_OK)
             )
            )
      /*
        SYNCHRONIZE connection details, and NEW users (in RSS) - defined
        in default groups - RETRIEVE ALL GROUPS - and eliminate
        ones that do not appear in CARE groups/connection groups.
      */
       rc= CS_sync_u2ug_all (msg_hdr,
                            *usr_mem_ptr, *usr_mem_num,*u2ug_mem_ptr,
                            *u2ug_mem_num, statist, (int)rc_usr);
    else if (rc_usr NE ESA_OK) {
        rc= CS_sync_usr_def_ug (msg_hdr,
                                *usr_mem_ptr,
                                *usr_mem_num,
                                &user_memory,
                                &users_in_memory,
                                &user_memory_init,
                                statist);
        if (rc EQ ESA_OK)
           rc= CS_sync_usr_u2ug (msg_hdr, *u2ug_mem_ptr, *u2ug_mem_num,
                              statist, user_memory, users_in_memory);
    }
    else
      /*
        SYNCHRONIZE connection details, and NEW users (in RSS) - defined
        in default groups - RETRIEVE LISTED GROUPS - and eliminate
        ones that do not appear in CARE groups/connection groups.
      */
       rc= CS_sync_u2ug (msg_hdr,
                         *usr_mem_ptr, *usr_mem_num, *u2ug_mem_ptr,
                         *u2ug_mem_num, statist, (int)rc_usr);
    if (rc EQ ESA_NOT_SUPP)
       rc = ESA_OK;
  }
  /*
    LOGOUT from RSS.
  */
  /*
    FREE allocated memory for checksum users and checksum connections.
  */
  CSA_free ((char **)u2ug_mem_ptr);
  *u2ug_mem_num=   0;
  CSA_free ((char **)usr_mem_ptr);
  *usr_mem_num=   0;
  CSA_free ((char **)ug_mem_ptr);
  *ug_mem_num=   0;
  CSA_free ((char **)oe_mem_ptr);
  *oe_mem_num=   0;
 
 
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    PROCESS when the SYNC is FULL (all required users/groups/connections
    were specified:
    UPDATE CARE files with users/groups/connections from sync care
    details (if this is NOT FULL sync - the files are not updated and
    upon reload files - the details from them are reloaded !
  */
 
  if (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
  {
     rc= CARE_int_oes_add (envir_ptr->msg_admin_param.rss_name,
                           M_SYNC_FULL);
     if (rc EQ ESA_OK)
        rc= CARE_int_ugs_add (envir_ptr->msg_admin_param.rss_name,
                              M_SYNC_FULL);
 
     if (rc EQ ESA_OK)
        rc= CARE_int_users_add (envir_ptr->msg_admin_param.rss_name,
                                M_SYNC_FULL);
 
     if (rc EQ ESA_OK)
        rc= CARE_int_u2ugs_add (envir_ptr->msg_admin_param.rss_name,
                                M_SYNC_FULL);
  }
 
  cleanup:
 
  CSA_free ((char **)(&ug_typ_ptr));
  CSA_free ((char **)&user_memory);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_sync_global function */
 
 
/****************************************************
 * Procedure Name: CS_sync_ug_all
 * Description   : user groups syncronization between ESS and RSS
 *                    with get all groups
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS groups and
 * ESS groups. The function retrieves (in loop) ALL RSS groups and
 * on each group performs the following:
 * - If the group DOES not belong to the requested (CARE) groups
 *   or default groups - the group is ignored.
 * - If the group is not defined in the ESS (checksum) groups or
 *   default groups - An ADD group message is produced.
 * - If the group does exists in the ESS list of groups but with
 *   different checksum - an UPDATE group message is produced.
 * Every RSS group THAT WAS FOUND AMONG THE CARE groups AND was found
 * in the ESS (checksum) groups - is considered to be RELEVANT GROUP
 * - for all other groups in the ESS list - a delete message is
 * produced.
 * For all groups that are "deleted" from ESS - all their connections
 * are marked as irrelevant - in order to prevent sending a "DELETE
 * CONNECTION" messages for such groups.
 * Please NOTE that a group that is sent from the ESS and DOES EXIST in
 * the RSS but is DOES NOT appear in the CARE groups list - is
 * considered to be irrelevant - and it is deleted (message) from the
 * ESS.
 *********************************************************************/
 
ESA_RC CS_sync_ug_all (RSS_MSG_HDR_rec_typ  * msg_hdr,
                       UG_MEM_rec_ptr         ug_mem_ptr,
                       int                    ug_mem_num,
                       STATIST_rec_typ      * statist,
                       U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                       int                    u2ug_mem_num)
{
  char                  fn[]="CS_sync_ug_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK, rc_ug;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                     KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			             KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0;
  int                   ugmem_num= 0;
  MSG_typ             * msg=NULL;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  UG_MEM_rec_ptr        ugmem= NULL;
 
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  UG_MEM_rec_typ        def_ugmem;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GETUGS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal buffers.
  */
  CLEAR_STRUCT (usr_prm);
  CLEAR (ug_prm_in);
  CLEAR (oe);
  CLEAR (ug_prm);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE buffer to UG addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to ADD GROUP message.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0, envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to UPDATE GROUP message.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    QUIT if there are no CARE groups.
  */
  if (envir_ptr->num_ugs + envir_ptr->num_u2ugs EQ 0) {
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 13,
       "There are not any increment group");
    goto cleanup;
  }
 
  /*
    Build addinfo for user-groups checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                              */
  CS_fill_key(&info_ptr,                                  /*WS10082A*/
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
               (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    Build msg. header for added groups
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
  /*
    Build msg. header for updated groups
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG_UPD);
 
  /*
    Sync. all user-groups from RSS
  */
  for (have_more=HAVE_MORE, jj= 0;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
 
    CLEAR (ug_prm_in);
    CLEAR (ug_prm);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);
    /*
      RETRIEVE next portion of groups from RSS.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSSYNC, GET_ALL_GROUPS, oe,
				MAX_GET, 0, ug_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getugs_ptr (
                      GET_ALL_GROUPS, oe, MAX_GET,
                      &actual_num, &have_more, &handle, 0,
                      ug_prm_in, ug_prm,addinfo,
                      obj_exist, &envir_ptr->msg_admin_param,
                      &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->getugs: Fail get groups");
      goto cleanup;
    }
    /*
      PROCESS all retrieved groups
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++, jj++) {
      statist->ug_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
			 "Group %s Not Exist", ug_prm[ii].group);
         statist->ug_not_exist++;
         continue;
	  }
      /*
        CHECK if current group in list of interest groups for ESS
      */
      rc_ug= CARE_inc_ug_find (ug_prm[ii].group);
      if (rc_ug NE ESA_OK)
         rc_ug= CARE_inc_u2ug_find (ug_prm[ii].group);
      /*
        If NOT -> skip this group
      */
      if (rc_ug NE ESA_OK) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s SKIPED (Not Interesting)", ug_prm[ii].group);
        continue;
      }
      CLEAR (&def_ugmem);
      ugmem= &def_ugmem;
      /*
        CHECK if group in list of ESS checksum groups
      */
      ugmem_num = CS_sync_ug_checksum_find (ug_prm[ii].group,
                                            ug_mem_ptr, ug_mem_num);
      if (ugmem_num LT ug_mem_num) {
        /*
          CALCULATE group checksum and mark it for POTENTIAL update.
        */
        ugmem= ug_mem_ptr+ ugmem_num;
        ugmem->in_rss= '1';
        rc = CS_sync_get_checksum ((char *)&ug_prm[ii], bufk,
                                   addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s in IIQ/IDN Default group list", ug_prm[ii].group);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
        api= FUNC_UPDUG;
      }
      else
	  {
        api= FUNC_ADDUG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s not in IIQ/IDN Default group list", ug_prm[ii].group);
	  }
      /*
        PROCESS when the group is NOT defined in the ESS or when the
        ESS checksum does not match to the calculated checksum:
      */
      if (ugmem_num GE ug_mem_num OR
          memcmp ((char *)checksum, (char *)ugmem->checksum, CHECKSUM_LEN) NE 0) {
        if (api EQ FUNC_ADDUG)
          statist->ug_add++;
        else
          statist->ug_upd++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Group %s send to IIQ/IDN for %s.",
			ug_prm[ii].group, (api EQ FUNC_ADDUG) ? "ADD" : "UPDATE");
        /*
          ADD the group details to the correct (add/update) messsgae.
        */
        msg=CS_add_rs_msg(api,&usr_prm,&oe_prm,&ug_prm[ii],&u2ug_data,
                            addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
      } /* END - RS message add/update should be send */
      else {
        api= 0;
        statist->ug_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Group %s not send to ESS.",
			ug_prm[ii].group);
      }
 
      statist->ug_ess++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES+ 1,
           "statist->ug_rss(%d) stop_req_msgs(%d) =%d.",
		    statist->ug_rss, envir_ptr->stop_req_msgs,
			statist->ug_rss % envir_ptr->stop_req_msgs);
        if (statist->ug_rss % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on current retrieved groups */
 
  } /* END - FOR loop on ALL groups */
  /*
    SEND ADD groups message - if the message is not empty.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  /*
    SEN UPDATE groups message - if the message is not empty.
  */
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  /*
    Send DELETE messages for all ESS groups that are not in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_DEL);
  /*
    SCAN all ESS groups.
  */
  for (ugmem_num= 0;
       ugmem_num LT ug_mem_num AND rc EQ ESA_OK;
       ugmem_num++) {
    ugmem= ug_mem_ptr+  ugmem_num;
    /*
      PROCESS when group was NOT found among the RSS groups.
    */
    if (ugmem->in_rss NE '1') {
      statist->tmp_num++;
      statist->ug_del++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
      CLEAR_STRUCT (ug_prm[0]);
      /*
        MARK all current group's connections (in ESS) to be irrelevant.
      */
      rc = CS_sync_u2ug_checksum_irlvnt (ugmem->ug,
                                         envir_ptr->empty_user ,
                                         u2ug_mem_ptr,u2ug_mem_num);
      strcpy (ug_prm[0].group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "ug=%s send to IIQ/IDN for DELETE.",ug_prm[0].group);
      /*
        ADD delete current group message to message buffer.
      */
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELUG, &usr_prm, &oe_prm,&ug_prm[0],
                             &u2ug_data, addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      } /* END - Error is send message */
 
    } /* END - Group was NOT found among RSS groups */
 
 
  } /* END - FOR all ESS groups. */
 
  if (rs_num_msgs NE 0) {
    /*
      SEND remain delete message.
    */
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
 
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  } /* END - delete messages left. */
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr(
                 GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
                 &actual_num, &have_more, &handle, MAX_GET,
                 ug_prm_in, ug_prm, addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_ug_all function */
 
 
/****************************************************
 * Procedure Name: CS_sync_ug_oe
 * Description   : user groups syncronization between ESS and RSS
 *                    with get all groups for every subtree
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS groups and
 * ESS groups. The function retrieves (in loop) ALL RSS groups and
 * on each group performs the following:
 * - If the group DOES not belong to the requested (CARE) groups
 *   or default groups - the group is ignored.
 * - If the group is not defined in the ESS (checksum) groups or
 *   default groups - An ADD group message is produced.
 * - If the group does exists in the ESS list of groups but with
 *   different checksum - an UPDATE group message is produced.
 * Every RSS group THAT WAS FOUND AMONG THE CARE groups AND was found
 * in the ESS (checksum) groups - is considered to be RELEVANT GROUP
 * - for all other groups in the ESS list - a delete message is
 * produced.
 * For all groups that are "deleted" from ESS - all their connections
 * are marked as irrelevant - in order to prevent sending a "DELETE
 * CONNECTION" messages for such groups.
 * Please NOTE that a group that is sent from the ESS and DOES EXIST in
 * the RSS but is DOES NOT appear in the CARE groups list - is
 * considered to be irrelevant - and it is deleted (message) from the
 * ESS.
 *********************************************************************/
 
ESA_RC CS_sync_ug_oe  (RSS_MSG_HDR_rec_typ  * msg_hdr,
                       UG_MEM_rec_ptr         ug_mem_ptr,
                       int                    ug_mem_num,
                       STATIST_rec_typ      * statist,
                       U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                       int                    u2ug_mem_num,
                       char                ** ug_typ_ptr,
                       int                  * ug_typ_num)
{
  char fn[]="CS_sync_ug_oe";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, ugmem_num= 0, from_num_oe= 0;
  MSG_typ             * msg=NULL;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  UG_MEM_rec_ptr        ugmem= NULL;
 
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  UG_typ                ug_array   [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  UG_MEM_rec_typ        def_ugmem;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GETUGS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal buffers.
  */
  CLEAR_STRUCT (usr_prm);
  CLEAR (ug_prm_in);
  CLEAR (ug_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE buffer to UG addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),    */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to ADD GROUP message.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to UPDATE GROUP message.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    Build addinfo for user-groups checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                             */
  CS_fill_key(&info_ptr,                                 /*WS10082A*/
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
               (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    Build msg. header for added groups
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
  /*
    Build msg. header for updated groups
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG_UPD);
 
  /*
    Sync. all user-groups from RSS
  */
    /*  Get list of increment containers */
 
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
        "Looping on containers. Total: %d).",  envir_ptr->num_oes );
 
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
    CARE_inc_get_next_oe (oe, from_num_oe);
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
                    "Container %s (No. %d).", oe, from_num_oe);
    for (have_more=HAVE_MORE, jj= 0;
         have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
    {
 
      CLEAR (ug_prm_in);
      CLEAR (ug_prm);
      CLEAR (obj_exist);
      CS_addinfo_fill (
          info_ptr,
          addinfo,
          MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);*/
    /*
      RETRIEVE next portion of groups from RSS.
    */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getugs_ptr.");
      CS_DIAG_UG_IN (ESA_COMP_ACSSYNC, GET_SUBTREE_GROUPS, oe,
				MAX_GET, 0, ug_prm_in, handle, addinfo);
      rc=envir_ptr->func_ptr.getugs_ptr (GET_SUBTREE_GROUPS,
                                    oe, MAX_GET,
                                    &actual_num, &have_more,
                                    &handle, 0, ug_prm_in,
				                    ug_prm, addinfo, obj_exist,
                                    &envir_ptr->msg_admin_param,
                                    &envir_ptr->msg_err);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rc EQ ESA_OK)
          CS_DIAG_UG_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
      rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (apiprm.post EQ CS_YES)
      {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
        }
      } /* END - PosstScript is required */
      if (actual_num GT 0) {
 
          for (ii=0; ii LT actual_num; ii++)
              strcpy(ug_array[ii], ug_prm[ii].group);
 
          rc= CS_dwnld_ug_to_memory ((char *)ug_array, ug_typ_ptr,
                                     ug_typ_num, actual_num);
      }
      if (rc NE ESA_OK)
      {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
                          "->getugs: Fail get groups");
         goto cleanup;
      }
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
                      "getugs: actual_num %d have_more %d",
                      actual_num, have_more);
    /*
      PROCESS all retrieved groups
    */
      for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++, jj++)
      {
        statist->ug_rss++;
        statist->tmp_num++;
        if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
               "Group %s Not Exist", ug_prm[ii].group);
           statist->ug_not_exist++;
          continue;
		}
        CLEAR (&def_ugmem);
        ugmem= &def_ugmem;
        /*
        CHECK if group in list of ESS checksum groups
        */
        ugmem_num = CS_sync_ug_checksum_find (ug_prm[ii].group,
                                              ug_mem_ptr, ug_mem_num);
        if (ugmem_num LT ug_mem_num)
        {
          /*
          CALCULATE group checksum and mark it for POTENTIAL update.
          */
          ugmem= ug_mem_ptr+ ugmem_num;
          ugmem->in_rss= '1';
          rc = CS_sync_get_checksum ((char *)&ug_prm[ii], bufk,
                                     addinfo[ii], checksum);
          if (rc NE ESA_OK)
            goto cleanup;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s in IIQ/IDN Default group list", ug_prm[ii].group);
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
          api= FUNC_UPDUG;
        }
        else
		{
          api= FUNC_ADDUG;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s not in IIQ/IDN Default group list", ug_prm[ii].group);
		}
        /*
        PROCESS when the group is NOT defined in the ESS or when the
        ESS checksum does not match to the calculated checksum:
        */
        if (ugmem_num GE ug_mem_num OR
            memcmp ((char *)checksum, (char *)ugmem->checksum,
                    CHECKSUM_LEN) NE 0)
        {
          if (api EQ FUNC_ADDUG)
            statist->ug_add++;
          else
            statist->ug_upd++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Group %s send to IIQ/IDN for %s.",
			ug_prm[ii].group, (api EQ FUNC_ADDUG) ? "ADD" : "UPDATE");
          /*
          ADD the group details to the correct (add/update) messsgae.
          */
          msg=CS_add_rs_msg (api, &usr_prm,&oe_prm, &ug_prm[ii],
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
          if (rc NE ESA_OK)
            goto cleanup;
 
          if (msg EQ NULL)
          {
            rc = ESA_FATAL;
            goto cleanup;
          }
          if (sw_upd NE 0)
            umsg_rs= msg;
          else
            msg_rs= msg;
        } /* END - RS message add/update should be send */
        else
        {
          api= 0;
          statist->ug_not_chg++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Group %s not send to ESS.",
    			ug_prm[ii].group);
        }
 
        statist->ug_ess++;
        CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
 
        if (envir_ptr->stop_req_msgs NE 0)
		{
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->ug_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->ug_rss, envir_ptr->stop_req_msgs,
			statist->ug_rss % envir_ptr->stop_req_msgs);
          if (statist->ug_rss % envir_ptr->stop_req_msgs EQ 0)
		  {
            rc= CS_send_receive (msg_hdr);
            if (rc NE ESA_OK)
                goto cleanup;
          }
		}
 
      } /* END - FOR loop on current retrieved groups */
 
    } /* END - FOR loop on ALL groups */
 
  }
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  /*
    SEN UPDATE groups message - if the message is not empty.
  */
  if (rs_num_umsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
 
  /*
    Send DELETE messages for all ESS groups that are not in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_DEL);
  /*
    SCAN all ESS groups.
  */
  for (ugmem_num= 0;
       ugmem_num LT ug_mem_num AND rc EQ ESA_OK;
       ugmem_num++)
  {
    ugmem= ug_mem_ptr+  ugmem_num;
    /*
      PROCESS when group was NOT found among the RSS groups.
    */
    if (ugmem->in_rss NE '1')
    {
      statist->tmp_num++;
      statist->ug_del++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
      CLEAR_STRUCT (ug_prm[0]);
      /*
        MARK all current group's connections (in ESS) to be irrelevant.
      */
      rc = CS_sync_u2ug_checksum_irlvnt (ugmem->ug,
                                         envir_ptr->empty_user ,
                                         u2ug_mem_ptr,u2ug_mem_num);
      strcpy (ug_prm[0].group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Group %s send to IIQ/IDN for DELETE.",ug_prm[0].group);
      /*
        ADD delete current group message to message buffer.
      */
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELUG, &usr_prm, &oe_prm,&ug_prm[0],
                             &u2ug_data, addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL)
      {
          rc = ESA_FATAL;
          goto cleanup;
      } /* END - Error is send message */
 
    } /* END - Group was NOT found among RSS groups */
 
 
  } /* END - FOR all ESS groups. */
 
  if (rs_num_msgs NE 0)
  {
    /*
      SEND remain delete message.
    */
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
 
    if (rc NE ESA_OK)
      goto cleanup;
  } /* END - delete messages left. */
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (GET_FREE_HANDLE_GROUPS,
                          oe, MAX_GET,
                          &actual_num, &have_more, &handle, MAX_GET,
                          ug_prm_in, ug_prm, addinfo, obj_exist,
                          &envir_ptr->msg_admin_param,
                          &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_ug_oe function */
 
 
/****************************************************
 * Procedure Name: CS_sync_oe_all
 * Description   : user containers syncronization between ESS and RSS
 *                    with get all containers
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS containers and
 * ESS containers. The function retrieves (in loop) ALL RSS containers
 * and
 * on each container performs the following:
 * - If the container DOES not belong to the requested (CARE) containers
 *   or default containers - the container is ignored.
 * - If the container is not defined in the ESS (checksum) containers or
 *   default containers - An ADD container message is produced.
 * - If the container does exists in the ESS list of containers but with
 *   different checksum - an UPDATE container message is produced.
 * Every RSS container THAT WAS FOUND AMONG THE CARE containers AND was
 * found in the ESS (checksum) containers - is considered to be
 * RELEVANT container - for all other containers in the ESS list -
 * a delete message is produced.
 * For all containers that are "deleted" from ESS - all their
 * connections are marked as irrelevant - in order to prevent sending
 * a "DELETE CONNECTION" messages for such containers.
 * Please NOTE that a container that is sent from the ESS and
 * DOES EXIST in the RSS but is DOES NOT appear in the CARE containers
 * list - is considered to be irrelevant - and it is deleted (message)
 * from the ESS.
 *********************************************************************/
 
ESA_RC CS_sync_oe_all (RSS_MSG_HDR_rec_typ  * msg_hdr,
                       OE_MEM_rec_ptr         oe_mem_ptr,
                       int                    oe_mem_num,
                       STATIST_rec_typ      * statist)
{
  char fn[]="CS_sync_oe_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK, rc_oe;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0;
  int                   oemem_num= 0;
  MSG_typ             * msg=NULL;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  OE_MEM_rec_ptr        oemem= NULL;
 
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  UG_PARAMS_rec_typ     ug_prm;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_MEM_rec_typ        def_oemem;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GETOES,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal buffers.
  */
  CLEAR_STRUCT (usr_prm);
  CLEAR (oe_prm_in);
  CLEAR_STRUCT (ug_prm);
  CLEAR (oe_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_oemem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE buffer to OE addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),  */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to ADD container message.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to UPDATE container message.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    QUIT if there are no CARE containers.
  */
  if (envir_ptr->num_oes EQ 0) {
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 13,
       "There are not any increment container");
    goto cleanup;
  }
 
  /*
    Build addinfo for containers checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                              */
  CS_fill_key(&info_ptr,                                  /*WS10082A*/
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *           */
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    Build msg. header for added containers
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
  /*
    Build msg. header for updated containers
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_OE_UPD);
 
  /*
    Sync. all containers from RSS
  */
  for (have_more=HAVE_MORE, jj= 0;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
 
    CLEAR (oe_prm_in);
    CLEAR (oe_prm);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds); */
    /*
      RETRIEVE next portion of containers from RSS.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSSYNC, GET_ALL_OES, oe,
				MAX_GET, 0, oe_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getoes_ptr (GET_ALL_OES, oe, MAX_GET,
                                  &actual_num, &have_more, &handle, 0,
                                  oe_prm_in, oe_prm, addinfo,
                                  obj_exist,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_OE_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst= CS_pre_post_oe (SCRIPT_POST, actual_num, oe_prm,
                                addinfo, NULL, &apiprm, rc,
								ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
    } /* END - PosstScript is required */
 
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->getoes: Fail get containers");
      goto cleanup;
    }
    /*
      PROCESS all retrieved containers
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++, jj++) {
      statist->oe_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Container %s Not Exist", oe_prm[ii].oe);
         statist->oe_not_exist++;
         continue;
	  }
      /*
        CHECK if current container in list of interest containers
        for ESS
      */
      rc_oe= CARE_inc_oe_find (oe_prm[ii].oe);
 
      /*
        If NOT -> skip this container
      */
      if (rc_oe NE ESA_OK) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s SKIPED (Not interesting)", oe_prm[ii].oe);
        continue;
      }
      CLEAR (&def_oemem);
      oemem= &def_oemem;
      /*
        CHECK if container in list of ESS checksum containers
      */
      oemem_num = CS_sync_oe_checksum_find (oe_prm[ii].oe, oe_mem_ptr,
                                            oe_mem_num);
      if (oemem_num LT oe_mem_num) {
        /*
          CALCULATE container checksum and mark it for POTENTIAL update.
        */
        oemem= oe_mem_ptr+ oemem_num;
        oemem->in_rss= '1';
        rc = CS_sync_get_checksum ((char *)&oe_prm[ii], bufk,
                                   addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDOE;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s in IIQ/IDN oe list", oe_prm[ii].oe);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, oemem->checksum, CHECKSUM_LEN, checksum);
      }
      else
	  {
        api= FUNC_ADDOE;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s not in IIQ/IDN oe list", oe_prm[ii].oe);
	  }
      /*
        PROCESS when the container is NOT defined in the ESS or when the
        ESS checksum does not match to the calculated checksum:
      */
      if (oemem_num GE oe_mem_num OR
          memcmp ((char *)checksum, (char *)oemem->checksum,
                  CHECKSUM_LEN) NE 0) {
        if (api EQ FUNC_ADDOE)
          statist->oe_add++;
        else
          statist->oe_upd++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Container %s send to IIQ/IDN for %s.",
			oe_prm[ii].oe, (api EQ FUNC_ADDOE) ? "ADD" : "UPDATE");
        /*
          ADD the container details to the correct (add/update)
          messsgae.
        */
        msg=CS_add_rs_msg(api,&usr_prm,&oe_prm[ii],&ug_prm,&u2ug_data,
                            addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
      } /* END - RS message add/update should be send */
      else {
        api= 0;
        statist->oe_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s not send to IIQ/IDN", oe_prm[ii].oe);
      }
 
      statist->oe_ess++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->oe_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->oe_rss, envir_ptr->stop_req_msgs,
			statist->oe_rss % envir_ptr->stop_req_msgs);
        if (statist->oe_rss % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on current retrieved containers */
 
  } /* END - FOR loop on ALL containers */
  /*
    SEND ADD containers message - if the message is not empty.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  /*
    SEN UPDATE containers message - if the message is not empty.
  */
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  /*
    Send DELETE messages for all ESS containers that are not in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_DEL);
  /*
    SCAN all ESS containers.
  */
  for (oemem_num= 0;
       oemem_num LT oe_mem_num AND rc EQ ESA_OK;
       oemem_num++) {
    oemem= oe_mem_ptr+  oemem_num;
    /*
      PROCESS when container was NOT found among the RSS containers.
    */
    if (oemem->in_rss NE '1') {
      statist->tmp_num++;
      statist->oe_del++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      CLEAR_STRUCT (oe_prm[0]);
      strcpy (oe_prm[0].oe, oemem->oe);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Container %s Send to IIQ/IDN for DELETE",oe_prm[0].oe);
      /*
        ADD delete current container message to message buffer.
      */
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELOE, &usr_prm, &oe_prm[0],&ug_prm,
                             &u2ug_data, addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      } /* END - Error is send message */
 
    } /* END - container was NOT found among RSS containers */
 
 
  } /* END - FOR all ESS containers. */
 
  if (rs_num_msgs NE 0) {
    /*
      SEND remain delete message.
    */
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
 
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  } /* END - delete messages left. */
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (GET_FREE_HANDLE_OES, oe, MAX_GET,
                          &actual_num, &have_more, &handle, MAX_GET,
                          oe_prm_in, oe_prm, addinfo, obj_exist,
                          &envir_ptr->msg_admin_param,
                          &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_OE_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_oe_all function */
 
 
/****************************************************
 * Procedure Name: CS_sync_oe_subtree
 * Description   : user containers syncronization between ESS and RSS
 *                    with get containers
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS containers and
 * ESS containers. The function retrieves (in loop) ALL RSS containers
 * and on each container performs the following:
 * - If the container DOES not belong to the requested (CARE) containers
 *   or default containers - the container is ignored.
 * - If the container is not defined in the ESS (checksum) containers or
 *   default containers - An ADD container message is produced.
 * - If the container does exists in the ESS list of containers but with
 *   different checksum - an UPDATE container message is produced.
 * Every RSS container THAT WAS FOUND AMONG THE CARE containers AND was
 * found in the ESS (checksum) containers - is considered to be
 * RELEVANT container - for all other containers in the ESS list -
 * a delete message is produced.
 * For all containers that are "deleted" from ESS - all their
 * connections are marked as irrelevant - in order to prevent sending
 * a "DELETE CONNECTION" messages for such containers.
 * Please NOTE that a container that is sent from the ESS and DOES EXIST
 * in the RSS but is DOES NOT appear in the CARE containers list - is
 * considered to be irrelevant - and it is deleted (message) from the
 * ESS.
 *********************************************************************/
 
ESA_RC CS_sync_oe_subtree (RSS_MSG_HDR_rec_typ  * msg_hdr,
                           OE_MEM_rec_ptr         oe_mem_ptr,
                           int                    oe_mem_num,
                           STATIST_rec_typ      * statist)
{
  char fn[]="CS_sync_oe_subtree";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
         		 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, oemem_num= 0, from_num_oe = 0;
  MSG_typ             * msg=NULL;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  OE_MEM_rec_ptr        oemem= NULL;
 
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  UG_PARAMS_rec_typ     ug_prm;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_MEM_rec_typ        def_oemem;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GETOES,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal buffers.
  */
  CLEAR_STRUCT (usr_prm);
  CLEAR (oe_prm_in);
  CLEAR_STRUCT (ug_prm);
  CLEAR (oe_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_oemem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE buffer to OE addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),   */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to ADD container message.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to UPDATE container message.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    QUIT if there are no CARE containers.
  */
  if (envir_ptr->num_oes EQ 0) {
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 13,
       "There are not any increment container");
    goto cleanup;
  }
 
  /*
    Build addinfo for containers checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
                envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                             */
  CS_fill_key(&info_ptr,                                  /*WS10082A*/
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *            */
                (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    Build msg. header for added containers
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
  /*
    Build msg. header for updated containers
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_OE_UPD);
 
  /*
    Sync. all containers from RSS
  */
    /*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
    CARE_inc_get_next_oe (oe, from_num_oe);
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15, "Container %s.", oe);
    for (have_more=HAVE_MORE, jj= 0;
         have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
    {
 
      CLEAR (oe_prm_in);
      CLEAR (oe_prm);
      CLEAR (obj_exist);
      CS_addinfo_fill (
          info_ptr,
          addinfo,
          MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds); */
    /*
      RETRIEVE next portion of containers from RSS.
    */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getoes_ptr.");
      CS_DIAG_OE_IN (ESA_COMP_ACSSYNC, GET_SUBTREE_OES, oe,
				MAX_GET, 0, oe_prm_in, handle, addinfo);
      rc=envir_ptr->func_ptr.getoes_ptr (
                      GET_SUBTREE_OES, oe,MAX_GET,
                      &actual_num, &have_more, &handle, 0,
                      oe_prm_in, oe_prm, addinfo, obj_exist,
                      &envir_ptr->msg_admin_param,&envir_ptr->msg_err);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rc EQ ESA_OK)
         CS_DIAG_OE_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
      rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (apiprm.post EQ CS_YES)
  	  {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
      } /* END - PosstScript is required */
 
      if (rc NE ESA_OK)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
          "->getoes: Fail get containers");
        goto cleanup;
      }
    /*
      PROCESS all retrieved containers
    */
      for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++, jj++)
      {
        statist->oe_rss++;
        statist->tmp_num++;
        if (obj_exist[ii] EQ OBJ_NOT_EXIST)
		{
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
              "Container %s Not Exist", oe_prm[ii].oe);
           statist->oe_not_exist++;
           continue;
		}
 
        CLEAR (&def_oemem);
        oemem= &def_oemem;
      /*
        CHECK if container in list of ESS checksum containers
      */
        oemem_num = CS_sync_oe_checksum_find (oe_prm[ii].oe,oe_mem_ptr,
                                    oe_mem_num);
        if (oemem_num LT oe_mem_num)
		{
        /*
          CALCULATE container checksum and mark it for POTENTIAL update.
        */
          oemem= oe_mem_ptr+ oemem_num;
          oemem->in_rss= '1';
          rc = CS_sync_get_checksum ((char *)&oe_prm[ii], bufk,
                                     addinfo[ii], checksum);
          if (rc NE ESA_OK)
            goto cleanup;
          api= FUNC_UPDOE;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s in IIQ/IDN oe list", oe_prm[ii].oe);
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, oemem->checksum, CHECKSUM_LEN, checksum);
        }
        else
		{
          api= FUNC_ADDOE;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s not in IIQ/IDN oe list", oe_prm[ii].oe);
		}
      /*
        PROCESS when the container is NOT defined in the ESS or when the
        ESS checksum does not match to the calculated checksum:
      */
        if (oemem_num GE oe_mem_num OR
            memcmp ((char *)checksum, (char *)oemem->checksum, CHECKSUM_LEN) NE 0)
		{
          if (api EQ FUNC_ADDOE)
            statist->oe_add++;
          else
            statist->oe_upd++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Container %s send to IIQ/IDN for %s.",
			oe_prm[ii].oe, (api EQ FUNC_ADDOE) ? "ADD" : "UPDATE");
        /*
          ADD the container details to the correct (add/update)
          message.
        */
          msg=CS_add_rs_msg(api,&usr_prm,&oe_prm[ii],&ug_prm,&u2ug_data,
                            addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
          if (rc NE ESA_OK)
            goto cleanup;
 
          if (msg EQ NULL)
		  {
            rc = ESA_FATAL;
            goto cleanup;
          }
          if (sw_upd NE 0)
            umsg_rs= msg;
          else
            msg_rs= msg;
        } /* END - RS message add/update should be send */
        else
		{
          api= 0;
          statist->oe_not_chg++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s not send to IIQ/IDN", oe_prm[ii].oe);
        }
 
        statist->oe_ess++;
        CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
 
        if (envir_ptr->stop_req_msgs NE 0)
		{
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->oe_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->oe_rss, envir_ptr->stop_req_msgs,
			statist->oe_rss % envir_ptr->stop_req_msgs);
          if (statist->oe_rss % envir_ptr->stop_req_msgs EQ 0)
          {
            rc= CS_send_receive (msg_hdr);
            if (rc NE ESA_OK)
                goto cleanup;
          }
		}
 
      } /* END - FOR loop on current retrieved containers */
 
    } /* END - FOR loop on ALL containers */
    /*
      SEND ADD containers message - if the message is not empty.
    */
  }
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
	{
      goto cleanup;
    }
  }
  /*
    SEN UPDATE containers message - if the message is not empty.
  */
  if (rs_num_umsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK)
	{
      goto cleanup;
    }
  }
 
  /*
    Send DELETE messages for all ESS containers that are not in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_DEL);
  /*
    SCAN all ESS containers.
  */
  for (oemem_num= 0;
       oemem_num LT oe_mem_num AND rc EQ ESA_OK;
       oemem_num++)
  {
    oemem= oe_mem_ptr+  oemem_num;
    /*
      PROCESS when container was NOT found among the RSS containers.
    */
    if (oemem->in_rss NE '1')
	{
      statist->tmp_num++;
      statist->oe_del++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      CLEAR_STRUCT (oe_prm[0]);
      strcpy (oe_prm[0].oe, oemem->oe);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Container %s send to IIQ/IDN for DELETE",oe_prm[0].oe);
      /*
        ADD delete current container message to message buffer.
      */
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELOE, &usr_prm, &oe_prm[0],&ug_prm,
                             &u2ug_data, addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL)
	  {
          rc = ESA_FATAL;
          goto cleanup;
      } /* END - Error is send message */
 
    } /* END - container was NOT found among RSS containers */
 
 
  } /* END - FOR all ESS containers. */
 
  if (rs_num_msgs NE 0)
  {
    /*
      SEND remain delete message.
    */
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
 
    if (rc NE ESA_OK)
      goto cleanup;
  } /* END - delete messages left. */
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (GET_FREE_HANDLE_OES, oe, MAX_GET,
                          &actual_num, &have_more, &handle, MAX_GET,
                          oe_prm_in, oe_prm, addinfo, obj_exist,
                          &envir_ptr->msg_admin_param,
                          &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_OE_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_oe_subtree function */
 
/****************************************************
 * Procedure Name: CS_sync_ug
 * Description   : user groups syncronization between ESS and RSS
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS groups and
 * ESS groups. The function retrieves (in loop) THE CARE RSS groups and
 * on each group performs the following:
 * - If the group does not exist in the RSS - the group is ignored.
 * - If the group is not defined in the ESS (checksum) groups or
 *   default groups - An ADD group message is produced.
 * - If the group does exists in the ESS list of groups but with
 *   different checksum - an UPDATE group message is produced.
 * Every RSS group THAT WAS FOUND AMONG THE CARE groups AND was found
 * in the ESS (checksum) groups - is considered to be RELEVANT GROUP
 * - for all other groups in the ESS list - a delete message is
 * produced.
 * For all groups that are "deleted" from ESS - all their connections
 * are marked as irrelevant - in order to prevent sending a "DELETE
 * CONNECTION" messages for such groups.
 * Please NOTE that a group that is sent from the ESS and DOES EXIST in
 * the RSS but is DOES NOT appear in the CARE groups list - is
 * considered to be irrelevant - and it is deleted (message) from the
 * ESS.
 *********************************************************************/
 
ESA_RC CS_sync_ug (RSS_MSG_HDR_rec_typ  * msg_hdr,
                   UG_MEM_rec_ptr         ug_mem_ptr,
                   int                    ug_mem_num,
                   STATIST_rec_typ      * statist,
                   U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                   int                    u2ug_mem_num)
{
  char fn[]="CS_sync_ug";
  MSG_typ             * msg= NULL;
  int                   sw_upd= 0, sw_user= 0, from_num_ug= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0, filled_num_ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii=0;
  UG_MEM_rec_ptr        ugmem= NULL;
  int                   ugmem_num= 0;
 
  UG_MEM_rec_typ        def_ugmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GETUGS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal buffers.
  */
  CLEAR_STRUCT (usr_prm);
  CLEAR (ug_prm_in);
  CLEAR (ug_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE buffer to UG addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),   */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to ADD GROUP message.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to UPDATE GROUP message.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
 
  /*
    Build addinfo for user-groups checksum
 */
  memset ((char *)(&u2ug_data), '\0', sizeof(U2UG_PARAMS_rec_typ));
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
                envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *        */
               (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
 
  /*
    Build msg. header for added groups
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
  /*
    Build msg. header for updated groups
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG_UPD);
  /*
    PROCESS all groups & default groups in CARE list.
  */
  for (from_num_ug= 0;
       ((from_num_ug LT (envir_ptr->num_ugs+ envir_ptr->num_u2ugs))
           AND
        (rc EQ ESA_OK));)
  {
    CLEAR (ug_prm_in);
    CLEAR (ug_prm);
    CLEAR (obj_exist);
    /*
      FILL next portion of groups from CARE list to retrieve from
      RSS.
    */
    rc= CARE_inc_ugs_fill (ug_prm_in, &from_num_ug, &filled_num_ugs);
    CS_addinfo_fill (info_ptr,
              addinfo,
              MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K*   envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);*/
    /*
       RETRIEVE next portion of groups details from RSS.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSSYNC, GET_MANY_GROUPS, oe,
				MAX_GET, filled_num_ugs, ug_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getugs_ptr (GET_MANY_GROUPS, oe, MAX_GET,
                             &actual_num, &have_more, &handle,
                             filled_num_ugs, ug_prm_in, ug_prm,
                             addinfo, obj_exist,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->getugs: Fail get groups");
      goto cleanup;
    }
 
    /*
      PROCESS all retrieved groups
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++) {
      statist->tmp_num++;
      /*
        IGNORE group that does not exist in the RSS.
      */
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s Not exist", ug_prm[ii].group);
        statist->ug_not_exist++;
        continue;
      }
 
      CLEAR (&def_ugmem);
      ugmem= &def_ugmem;
      /*
        CHECK if group in list of ESS checksum groups
      */
      ugmem_num= CS_sync_ug_checksum_find (ug_prm[ii].group,
		                                   ug_mem_ptr, ug_mem_num);
      if (ugmem_num LT ug_mem_num) {
        /*
          CALCULATE the current group's checksum.
        */
        ugmem= ug_mem_ptr+ ugmem_num;
        ugmem->in_rss= '1';
        rc= CS_sync_get_checksum ((char *)&ug_prm[ii], bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDUG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s in IIQ/IDN Default group list", ug_prm[ii].group);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
      }
      else
	  {
        api= FUNC_ADDUG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Group %s not in IIQ/IDN Default group list", ug_prm[ii].group);
	  }
      /*
        PROCESS if the group should be added to the ESS or if the
        group checksum in the ESS does not match the one in the RSS:
      */
      if (ugmem_num GE ug_mem_num OR
          memcmp ((char *)checksum, (char *)ugmem->checksum, CHECKSUM_LEN) NE 0) {
 
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Group %s send to IIQ/IDN for %s.",
			ug_prm[ii].group, (api EQ FUNC_ADDUG) ? "ADD" : "UPDATE");
        /*
          ADD ADD/UPDATE group message to message buffer.
        */
        msg= CS_add_rs_msg (api, &usr_prm, &oe_prm,&ug_prm[ii],
                            &u2ug_data, addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
        if (api EQ FUNC_ADDUG)
          statist->ug_add++;
        else
          statist->ug_upd++;
      }
      else {
        api= 0;
        statist->ug_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Group %s not send to IIQ/IDN.",
			ug_prm[ii].group);
      }
 
      statist->ug_ess++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->tmp_num(%d) stop_req_msgs(%d)=%d.",
		    statist->tmp_num, envir_ptr->stop_req_msgs,
			statist->tmp_num % envir_ptr->stop_req_msgs);
        if (statist->tmp_num % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on retrieved groups */
 
  } /* END - FOR loop on all RSS care groups */
  /*
    SEND the message if there are ADD message notr sent yet.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
 
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  /*
    SEND the message if there are UPDATE message notr sent yet.
  */
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
 
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  /*
    Send DELETE messages for all ESS groups that are not in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_DEL);
  for (ugmem_num= 0;
       ugmem_num LT ug_mem_num AND rc EQ ESA_OK;
       ugmem_num++) {
    ugmem= ug_mem_ptr+  ugmem_num;
    if (ugmem->in_rss NE '1') {
      statist->ug_del++;
      statist->tmp_num++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
      CLEAR_STRUCT (ug_prm[0]);
      /*
        MARK all connections for deleted group to be irrelevant.
      */
      rc = CS_sync_u2ug_checksum_irlvnt (ugmem->ug,
		                                 envir_ptr->empty_user ,
                                 u2ug_mem_ptr,u2ug_mem_num);
      strcpy (ug_prm[0].group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Group %s send to IIQ/IDN for DELETE",ug_prm[0].group);
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELUG, &usr_prm, &oe_prm,
                             &ug_prm[0], &u2ug_data, addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg_rs EQ NULL) {
        rc = ESA_FATAL;
        goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
 
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc=envir_ptr->func_ptr.getugs_ptr (GET_FREE_HANDLE_GROUPS,
                             oe, MAX_GET,
                             &actual_num, &have_more, &handle,
                             filled_num_ugs, ug_prm_in, ug_prm,
                             addinfo, obj_exist,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  if (rc EQ ESA_OK)
      rc= rc_logout;
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_ug function */
 
 
/****************************************************
 * Procedure Name: CS_sync_oe
 * Description   : user containers syncronization between ESS and RSS
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS containers and
 * ESS containers. The function retrieves (in loop) THE CARE RSS
 * containers and on each container performs the following:
 * - If the container does not exist in the RSS - the container is
 * ignored.
 * - If the container is not defined in the ESS (checksum) containers or
 *   default containers - An ADD container message is produced.
 * - If the container does exists in the ESS list of containers but with
 *   different checksum - an UPDATE container message is produced.
 * Every RSS container THAT WAS FOUND AMONG THE CARE containers AND was
 * found in the ESS (checksum) containers - is considered to be RELEVANT
 * container - for all other containers in the ESS list - a delete
 * message is produced.
 * For all containers that are "deleted" from ESS - all their
 * connections are marked as irrelevant - in order to prevent sending
 * a "DELETE CONNECTION" messages for such containers.
 * Please NOTE that a container that is sent from the ESS and
 * DOES EXIST in the RSS but is DOES NOT appear in the CARE containers
 * list - is considered to be irrelevant - and it is deleted (message)
 * from the ESS.
 *********************************************************************/
 
ESA_RC CS_sync_oe (RSS_MSG_HDR_rec_typ  * msg_hdr,
                   OE_MEM_rec_ptr         oe_mem_ptr,
                   int                    oe_mem_num,
                   STATIST_rec_typ      * statist)
{
  char fn[]="CS_sync_oe";
  MSG_typ             * msg= NULL;
  int                   sw_upd= 0, sw_user= 0, from_num_oe= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0, filled_num_oes= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii=0;
  OE_MEM_rec_ptr        oemem= NULL;
  int                   oemem_num= 0;
 
  OE_MEM_rec_typ        def_oemem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  OE_typ                oe;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GETOES,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal buffers.
  */
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (u2ug_data);
  CLEAR (oe_prm_in);
  CLEAR (oe_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_oemem);
  /*
    ALLOCATE buffer to OE addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to ADD container message.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE buffer to UPDATE container message.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
 
  /*
    Build addinfo for containers checksum
 */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *              */
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
 
  /*
    Build msg. header for added containers
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
  /*
    Build msg. header for updated containers
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_OE_UPD);
  /*
    PROCESS all containers & default containers in CARE list.
  */
  for (from_num_oe= 0;
       ((from_num_oe LT envir_ptr->num_oes) AND
        (rc EQ ESA_OK));
       from_num_oe +=MAX_GET) {
    CLEAR (oe_prm_in);
    CLEAR (oe_prm);
    CLEAR (obj_exist);
    /*
      FILL next portion of containers from CARE list to retrieve from
      RSS.
    */
    rc= CARE_inc_oes_fill (oe_prm_in, from_num_oe, &filled_num_oes);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
    /*
       RETRIEVE next portion of containers details from RSS.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSSYNC, GET_MANY_OES, oe,
				MAX_GET, filled_num_oes, oe_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getoes_ptr (GET_MANY_OES,
                             oe,MAX_GET,&actual_num,
                             &have_more, &handle, filled_num_oes,
                             oe_prm_in, oe_prm, addinfo, obj_exist,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_OE_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->getoes: Fail get containers");
      goto cleanup;
    }
 
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
                    "%s: actual_num %d have_more %d",
                    fn, actual_num, have_more);
    /*
      PROCESS all retrieved containers
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++) {
      statist->tmp_num++;
      /*
        IGNORE container that does not exist in the RSS.
      */
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s Not exist", oe_prm[ii].oe);
        statist->oe_not_exist++;
        continue;
      }
 
      CLEAR (&def_oemem);
      oemem= &def_oemem;
      /*
        CHECK if container in list of ESS checksum containers
      */
      oemem_num= CS_sync_oe_checksum_find (oe_prm[ii].oe, oe_mem_ptr,
                                   oe_mem_num);
      if (oemem_num LT oe_mem_num) {
        /*
          CALCULATE the current container's checksum.
        */
        oemem= oe_mem_ptr+ oemem_num;
        oemem->in_rss= '1';
        rc= CS_sync_get_checksum ((char *)&oe_prm[ii], bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDOE;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s in IIQ/IDN oe list", oe_prm[ii].oe);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, oemem->checksum, CHECKSUM_LEN, checksum);
      }
      else
	  {
        api= FUNC_ADDOE;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s not in IIQ/IDN oe list", oe_prm[ii].oe);
	  }
      /*
        PROCESS if the container should be added to the ESS or if the
        container checksum in the ESS does not match the one in the RSS:
      */
      if (oemem_num GE oe_mem_num OR
          memcmp ((char *)checksum, (char *)oemem->checksum,
                  CHECKSUM_LEN) NE 0) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "Container %s send to IIQ/IDN for %s.",
			oe_prm[ii].oe, (api EQ FUNC_ADDOE) ? "ADD" : "UPDATE");
        /*
          ADD ADD/UPDATE container message to message buffer.
        */
        msg= CS_add_rs_msg (api, &usr_prm, &oe_prm[ii],&ug_prm,
                            &u2ug_data, addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
        if (api EQ FUNC_ADDOE)
          statist->oe_add++;
        else
          statist->oe_upd++;
 
      }
      else {
        api= 0;
        statist->oe_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "Container %s not send to IIQ/IDN", oe_prm[ii].oe);
      }
 
      statist->oe_ess++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->tmp_num(%d) stop_req_msgs(%d)=%d.",
		    statist->tmp_num, envir_ptr->stop_req_msgs,
			statist->tmp_num % envir_ptr->stop_req_msgs);
        if (statist->tmp_num % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on retrieved containers */
 
  } /* END - FOR loop on all RSS care containers */
  /*
    SEND the message if there are ADD message notr sent yet.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
 
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  /*
    SEND the message if there are UPDATE message notr sent yet.
  */
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
 
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  /*
    Send DELETE messages for all ESS containers that are not in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_DEL);
  for (oemem_num= 0;
       oemem_num LT oe_mem_num AND rc EQ ESA_OK;
       oemem_num++) {
    oemem= oe_mem_ptr+  oemem_num;
    if (oemem->in_rss NE '1') {
      statist->oe_del++;
      statist->tmp_num++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      CLEAR_STRUCT (oe_prm[0]);
      /*
        MARK all connections for deleted container to be irrelevant.
      */
      strcpy (oe_prm[0].oe, oemem->oe);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Container %s send to IIQ/IDN for DELETE",oe_prm[0].oe);
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELOE, &usr_prm, &oe_prm[0],
                             &ug_prm, &u2ug_data, addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg_rs EQ NULL) {
        rc = ESA_FATAL;
        goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
 
  if (handle NE NULL)
  {
     ESA_RC rcc;
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getoes_ptr.");
     CS_DIAG_OE_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
     rcc= envir_ptr->func_ptr.getoes_ptr( GET_FREE_HANDLE_OES,
                             oe,MAX_GET,&actual_num,
                             &have_more, &handle, filled_num_oes,
                             oe_prm_in, oe_prm, addinfo, obj_exist,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
     if (rcc EQ ESA_OK)
        CS_DIAG_OE_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  if (rc EQ ESA_OK)
      rc= rc_logout;
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_oe function */
 
/****************************************************
 * Procedure Name: CS_sync_ug_checksum_find
 * Description   : search user-group and checksum in memory
 * Input         : ug - user group
 * Output        : record number of the user-group in memory
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
unsigned int CS_sync_ug_checksum_find (UG_typ         ug,
                                       UG_MEM_rec_ptr ug_mem_ptr,
                                       int            ug_mem_num)
{
  unsigned int        ii= 0;
  UG_MEM_rec_ptr      ugmem_ptr= NULL;
  UG_MEM_rec_typ      ug_rec;
  char fn[]="CS_sync_ug_checksum_find";
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "cmp ug=%s.",ug);
 
  /* 30/1/01 Aviw */
 
  /* Perform binary search on ug checksums if qsort was performed */
 
  if (CS_ug_sorted EQ 1)
  {
     strcpy (ug_rec.ug , ug);
 
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ug_mem_ptr=%p.", ug_mem_ptr);
  if (ug_mem_ptr != NULL)
	 ugmem_ptr = bsearch(&ug_rec ,
		                  ug_mem_ptr ,
                          ug_mem_num ,
			              sizeof(UG_MEM_rec_typ) ,
                          CS_cmpr_ug_entry);
 
	 if (ugmem_ptr EQ NULL)
       ii = ug_mem_num + 1;
	else
       ii = (((char *)ugmem_ptr - (char *)ug_mem_ptr)
	         / sizeof(UG_MEM_rec_typ));
  }
  else
  {
     for (ii= 0; ii LT (unsigned int)ug_mem_num; ii++)
	 {
       ugmem_ptr= ug_mem_ptr+ ii;
       if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ii=%d: ug=%s.",
                         ii, ugmem_ptr->ug);
       if (strcmp (ug, ugmem_ptr->ug) EQ 0)
         break;
	 }
  }
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ii=%d ug_mem_num=%d.",
                          ii, ug_mem_num);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, ESA_RC_VOID);
  return (ii);
} /* END - CS_sync_ug_checksum_find function */
 
/****************************************************
 * Procedure Name: CS_sync_oe_checksum_find
 * Description   : search container and checksum in memory
 * Input         : oe - container
 * Output        : record number of the container in memory
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
unsigned int CS_sync_oe_checksum_find (OE_typ         oe,
                                       OE_MEM_rec_ptr oe_mem_ptr,
                                       int            oe_mem_num)
{
  unsigned int        ii= 0;
  OE_MEM_rec_ptr      oemem_ptr= NULL;
  char fn[]="CS_sync_oe_checksum_find";
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  for (ii= 0; ii LT (unsigned int)oe_mem_num; ii++) {
    oemem_ptr= oe_mem_ptr+ ii;
    if (strcmp (oe, oemem_ptr->oe) EQ 0)
      break;
  }
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, ESA_RC_VOID);
  return (ii);
} /* END - CS_sync_oe_checksum_find function */
 
/****************************************************
 * Procedure Name: CS_sync_usr_checksum_find
 * Description   : search user and his checksum in memory
 * Input         : user
 * Output        : record number of the user in memory
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
unsigned int CS_sync_usr_checksum_find (USER_typ        user,
                                        USR_MEM_rec_ptr usr_mem_ptr,
                                        int             usr_mem_num)
{
  unsigned int        ii= 0;
  USR_MEM_rec_ptr     usrmem_ptr= NULL;
  USR_MEM_rec_typ     usr_rec ;
  char fn[]="CS_sync_usr_checksum_find";
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "cmp user=%s.",user);
  /* 30/1/01 Aviw */
 
  /* Perform binary search on use checksums if qsort was performed */
 
  if (CS_usr_sorted EQ 1)
  {
     strcpy (usr_rec.user , user);
 
  if (usr_mem_ptr != NULL)
	 usrmem_ptr = bsearch(&usr_rec ,
		                   usr_mem_ptr ,
                           usr_mem_num ,
			               sizeof(USR_MEM_rec_typ) ,
                           CS_cmpr_usr_entry);
 
	 if (usrmem_ptr EQ NULL)
       ii = usr_mem_num + 1;
	else
       ii = (((char *)usrmem_ptr - (char *)usr_mem_ptr)
	         / sizeof(USR_MEM_rec_typ));
  }
  else
  {
 
	for (ii= 0; ii LT (unsigned int)usr_mem_num; ii++)
	{
      usrmem_ptr= usr_mem_ptr+ ii;
      if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ii=%d: user=%s.",
                         ii, usrmem_ptr->user);
      if (strcmp (user, usrmem_ptr->user) EQ 0)
        break;
  }
  }
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ii=%d usr_mem_num=%d.",
                          ii, usr_mem_num);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, ESA_RC_VOID);
  return (ii);
 
} /* END - CS_sync_usr_checksum_find function */
 
/****************************************************
 * Procedure Name: CS_sync_u2ug_checksum_find
 * Description   : search connection and his checksum in memory
 * Input         : ug - group
 *               : user
 * Output        : record number of the connection in memory
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
unsigned int CS_sync_u2ug_checksum_find (UG_typ           ug,
                                        U2UG_MEM_rec_ptr u2ug_mem_ptr,
                                        int              u2ug_mem_num,
                                        USER_typ         user)
{
  unsigned int        ii= 0;
  U2UG_MEM_rec_ptr    u2ugmem_ptr= NULL;
  U2UG_MEM_rec_typ    u2ug_rec ;
  char fn[]="CS_sync_u2ug_checksum_find";
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "cmp user=%s ug=%s.",user, ug);
 
  /* 27/9/99 Aviw */
 
  /* Perform binary search on u2ug checksums if qsort was performed */
 
  if (CS_u2ug_sorted EQ 1)
  {
 
	 u2ug_rec.user = user ;
	 u2ug_rec.ug = ug;
 
  if (u2ug_mem_ptr != NULL)
	 u2ugmem_ptr = bsearch(&u2ug_rec ,
		                   u2ug_mem_ptr ,
                           u2ug_mem_num ,
			               sizeof(U2UG_MEM_rec_typ) ,
                           CS_cmpr_u2ug_entry);
 
	 if (u2ugmem_ptr EQ NULL)
       ii = u2ug_mem_num + 1;
	else
       ii = (((char *)u2ugmem_ptr - (char *)u2ug_mem_ptr)
	         / sizeof(U2UG_MEM_rec_typ));
  }
 else
 {
    for (ii= 0; ii LT (unsigned int)u2ug_mem_num; ii++)
	{
      u2ugmem_ptr= u2ug_mem_ptr+ ii;
      if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                         "ii=%d: user=%s ug=%s.",
                         ii, u2ugmem_ptr->user, u2ugmem_ptr->ug);
      if (strcmp (ug,   u2ugmem_ptr->ug) EQ 0 AND
          strcmp (user, u2ugmem_ptr->user) EQ 0
         )
        break;
	}
 }
 
 if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16)
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                           "ii=%d u2ug_mem_num=%d.",
                            ii, u2ug_mem_num);
 ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, ESA_RC_VOID);
 return (ii);
 
} /* END - CS_sync_u2ug_checksum_find function */
 
/****************************************************
 * Procedure Name: CS_sync_u2ug_checksum_irlvnt
 * Description   : search connection for deleted users/groups
 *                 and mark it as irrelevant.
 * Input         : ug - group
 *               : user
 * Output        : record number of the connection in memory
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated whenever the sync. operation finds
 * a user or group that should be deleted from the ESS. It scans all
 * the ESS connections (pairs of users and groups) and MARKS the
 * pairs that the user/group appears in - to be IRRELEVANT. The u2ug
 * functions - will ignore such pairs.
 * The function is useful to prevent delivering messages for delete
 * connections of users/groups that were previously deleted - and
 * thus to prevent producing unnecessarily alerts
 *******************************************************************/
 
ESA_RC CS_sync_u2ug_checksum_irlvnt (const UG_typ           ug,
                                     const USER_typ         user,
                                     U2UG_MEM_rec_ptr u2ug_mem_ptr,
                                     int              u2ug_mem_num)
{
  int                 ii;
  U2UG_MEM_rec_ptr    u2ugmem_ptr;
  char fn[]="CS_sync_u2ug_checksum_irlvnt";
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  /*
    SCAN all ESS connections
  */
  for (ii= 0; ii LT u2ug_mem_num; ii++) {
    u2ugmem_ptr= u2ug_mem_ptr+ ii;
    /*
      PROCESS when input user matches the current pair user or the
      input group matches the current pair group:
    */
    if (
         (
            (strlen(ug) GT 0)
           AND
            (strcmp (ug,u2ugmem_ptr->ug) EQ 0)
         )
        OR
         (
            (strlen(user) GT 0)
           AND
            (strcmp (user, u2ugmem_ptr->user) EQ 0)
        )
      )
      /*
        MARK connection to be irrelevant
      */
      u2ugmem_ptr->in_rss = '2';
  } /* end - FOR */
 
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
 
} /* END - CS_sync_u2ug_checksum_irlvnt function */
 
/****************************************************
 * Procedure Name: CS_sync_usr_all
 * Description   : users syncronization between ESS and RSS
 *                   with GET ALL
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS users and
 * ESS users. The function retrieves (in loop) ALL RSS users and
 * on each group performs the following:
 * - If the user DOES not belong to the requested (CARE) users AND it's
 *   default group does not belong to requested default groups -
 *   the user is ignored.
 * - If the user is not defined in the ESS (checksum) users -
 *   - An ADD user message is produced.
 * - If the user does exists in the ESS list of users but with
 *   different checksum - an UPDATE user message is produced.
 * The function activates the CS_sync_usr_check function - in order to
 * locate all RSS users that are not defined in the ESS and to send a
 * DELETE user request to the ESS.
 *********************************************************************/
 
ESA_RC CS_sync_usr_all (RSS_MSG_HDR_rec_typ  * msg_hdr,
                        USR_MEM_rec_ptr        usr_mem_ptr,
                        int                    usr_mem_num,
                        STATIST_rec_typ      * statist,
                        U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                        int                    u2ug_mem_num)
{
  char fn[]="CS_sync_usr_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK, rc_usr;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, sw_upd= 0, sw_user= 0;
  USR_MEM_rec_ptr       usrmem= NULL;
  int                   usrmem_num= 0;
  MSG_typ             * msg= NULL;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
 
  USR_MEM_rec_typ       def_usrmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
  char get_conn = 'N'; /* AC001 - CIQ#6 - new GetUSers parm */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUSERS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal data.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR (usr_prm_in);
  CLEAR (usr_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_usrmem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE user addinfo buffer for checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),   */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE ADD message buffer.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE update user message buffer.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    BUILD addinfo for users checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE memory segments for all retrieved users addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
              (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    BUILD msg. header for added users
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_ADD);
  /*
    BUILD msg. header for updated users
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_UPD);
  /*
    RETRIEVE ALL users from RSS :
  */
  for (have_more= HAVE_MORE, jj= 0;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (usr_prm_in);
    CLEAR (usr_prm);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds);*/
    /*
      GET next portion of users details.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_ALL_USERS,
		oe, MAX_GET, 0, usr_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtusers_ptr(GET_ALL_USERS,
                          oe,MAX_GET,&actual_num,
		                  &have_more, &handle, 0, usr_prm_in,  usr_prm,
                          addinfo, obj_exist,
                          &envir_ptr->msg_admin_param,
                          &envir_ptr->msg_err,
                          get_conn);  /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst= CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->gtusers: Fail get users");
      goto cleanup;
    }
    /*
      PROCESS all retrieved users:
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++, jj++) {
      statist->usr_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "User %s Not Exist", usr_prm[ii].user);
         statist->usr_not_exist++;
         continue;
	  }
      /*
        CHECK if User is interesting for ESS - i.e user found among
        list of interesting users or it's default group was found among
        list of interesting default groups.
      */
      rc_usr=CARE_inc_usr_find(usr_prm[ii].user,
                               M_DWNLD_NAME_REGULAR);
      if (rc_usr NE ESA_OK)
	  {
    	  if (strlen (usr_prm[ii].def_group) EQ 0)
	    	  rc_usr= ESA_ERR;
	      else
		      rc_usr= CARE_inc_ug_find (usr_prm[ii].def_group);
	  }
 
      /*
        IGNORE none interesting users.
      */
      if (rc_usr NE ESA_OK) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                        "User %s Not in Scope", usr_prm[ii].user);
        continue;
      }
      CLEAR  (&def_usrmem);
      usrmem= &def_usrmem;
      /*
        CHECK if users appears in list of ESS users.
      */
      usrmem_num= CS_sync_usr_checksum_find (usr_prm[ii].user,
                                     usr_mem_ptr, usr_mem_num);
      /*
        CALCULATE user's checksum if the usaer was found among
        ESS users.
      */
      if (usrmem_num LT usr_mem_num) {
        usrmem= usr_mem_ptr+ usrmem_num;
        usrmem->in_rss= '1';
        rc= CS_sync_get_checksum ((char *)&usr_prm[ii], bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDUSER;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "User %s in IIQ/IDN user list", usr_prm[ii].user);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, usrmem->checksum, CHECKSUM_LEN, checksum);
      }
      else
	  {
        api= FUNC_ADDUSER;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "User %s Not in IIQ/IDN user list", usr_prm[ii].user);
	  }
      /*
        PROCESS when the user should be ADDED/UPDATED in the ESS.
      */
      if (usrmem_num GE usr_mem_num OR
          memcmp ((char *)checksum, (char *)usrmem->checksum,
                  CHECKSUM_LEN) NE 0) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s send to IIQ/IDN for %s.",
			usr_prm[ii].user, (api EQ FUNC_ADDUSER) ? "ADD" : "UPDATE");
        /*
          ADD the USERS ADD/UPDATE message to the message buffer.
        */
        msg= CS_add_rs_msg (api, &usr_prm[ii],&oe_prm, &ug_prm,
                            &u2ug_data, addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
        if (api EQ FUNC_ADDUSER)
          statist->usr_add++;
        else
          statist->usr_upd++;
      } /* END - User should be ADDED/UPDATED in ESS */
      else {
        api= 0;
        statist->usr_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s Not send to IIQ/IDN.",
			usr_prm[ii].user);
      }
 
      statist->usr_ess++;
      CS_dwnld_event (statist, STEP_USR, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->usr_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->usr_rss, envir_ptr->stop_req_msgs,
			statist->usr_rss % envir_ptr->stop_req_msgs);
        if (statist->usr_rss % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on all retrieved users. */
 
  } /* END - FOR loop on ALL RSS users */
 
  /*
    SEND the remained ADD/UPDATE messages (if there are such messages).
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  /*
    SEND message to delete all users that are defined in the ESS but
    not in the RSS.
  */
  rc= CS_sync_usr_check (msg_hdr, usr_mem_ptr, usr_mem_num,
                         statist, u2ug_mem_ptr,
                         u2ug_mem_num) ;
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr(GET_FREE_HANDLE_USERS,oe,MAX_GET,
                           &actual_num, &have_more, &handle, MAX_GET,
                           usr_prm_in, usr_prm, addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err,
                           get_conn);  /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_USR, END_FN, rc);
 
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_usr_all function */
 
 
/****************************************************
 * Procedure Name: CS_sync_usr_oe
 * Description   : users syncronization between ESS and RSS
 *                   with GET subtree
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS users and
 * ESS users. The function retrieves (in loop) ALL RSS users
 * of every subtree and on each group performs the following:
 * - If the user DOES not belong to the requested (CARE) users AND it's
 *   default group does not belong to requested default groups -
 *   the user is ignored.
 * - If the user is not defined in the ESS (checksum) users -
 *   - An ADD user message is produced.
 * - If the user does exists in the ESS list of users but with
 *   different checksum - an UPDATE user message is produced.
 * The function activates the CS_sync_usr_check function - in order to
 * locate all RSS users that are not defined in the ESS and to send a
 * DELETE user request to the ESS.
 *********************************************************************/
 
ESA_RC CS_sync_usr_oe  (RSS_MSG_HDR_rec_typ  * msg_hdr,
                        USR_MEM_rec_ptr        usr_mem_ptr,
                        int                    usr_mem_num,
                        STATIST_rec_typ      * statist,
                        U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                        int                    u2ug_mem_num)
{
  char fn[]="CS_sync_usr_oe";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, sw_upd= 0, sw_user= 0;
  USR_MEM_rec_ptr       usrmem= NULL;
  int                   usrmem_num= 0, from_num_oe = 0;
  MSG_typ             * msg= NULL;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
 
  USR_MEM_rec_typ       def_usrmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
  char get_conn = 'N';  /* AC001 - CIQ#6 */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUSERS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal data.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR (usr_prm_in);
  CLEAR (usr_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_usrmem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE user addinfo buffer for checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082*       sizeof(ADDINFO_rec_typ),    */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE ADD message buffer.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE update user message buffer.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    BUILD addinfo for users checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE memory segments for all retrieved users addinfo.
  */
  rc= CSA_alloc (
      (char **)addinfo,
      STRUC_RES_ADDINFO,
/*WS10082K* sizeof(ADDINFO_rec_typ) *        */
            (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                     apiprm.script_kwd_num) ,
      MAX_GET,
      fn,
      "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    BUILD msg. header for added users
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_ADD);
  /*
    BUILD msg. header for updated users
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_UPD);
  /*
    RETRIEVE ALL users from every subtree in RSS :
  */
    /*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
    CARE_inc_get_next_oe (oe, from_num_oe);
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15, "Container %s.", oe);
    for (have_more= HAVE_MORE, jj= 0;
         have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
    {
      CLEAR (usr_prm_in);
      CLEAR (usr_prm);
      CLEAR (obj_exist);
      CS_addinfo_fill (
          info_ptr,
          addinfo,
          MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds);*/
      /*
      GET next portion of users details.
      */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
      CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_SUBTREE_USERS,
		oe, MAX_GET, 0, usr_prm_in, handle, addinfo);
      rc=envir_ptr->func_ptr.gtusers_ptr(GET_SUBTREE_USERS,oe,MAX_GET,
		              &actual_num, &have_more, &handle, 0, usr_prm_in,
					  usr_prm, addinfo, obj_exist,
                      &envir_ptr->msg_admin_param,
                      &envir_ptr->msg_err,
                      get_conn);  /* AC001 - CIQ#6 */
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rc EQ ESA_OK)
         CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
      rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (apiprm.post EQ CS_YES)
	  {
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
      } /* END - PosstScript is required */
      if (rc NE ESA_OK)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
           "->gtusers: Fail get users");
       goto cleanup;
      }
      /*
      PROCESS all retrieved users:
      */
      for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++, jj++)
	  {
        statist->usr_rss++;
        statist->tmp_num++;
        if (obj_exist[ii] EQ OBJ_NOT_EXIST)
		{
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
              "User %s Not Exist", usr_prm[ii].user);
           statist->usr_not_exist++;
           continue;
		}
        CLEAR  (&def_usrmem);
        usrmem= &def_usrmem;
        /*
        CHECK if users appears in list of ESS users.
        */
        usrmem_num= CS_sync_usr_checksum_find (usr_prm[ii].user,
                                       usr_mem_ptr, usr_mem_num);
        /*
        CALCULATE user's checksum if the usaer was found among
        ESS users.
        */
        if (usrmem_num LT usr_mem_num)
	    {
          usrmem= usr_mem_ptr+ usrmem_num;
          usrmem->in_rss= '1';
          rc= CS_sync_get_checksum ((char *)&usr_prm[ii], bufk,
                                    addinfo[ii], checksum);
          if (rc NE ESA_OK)
            goto cleanup;
          api= FUNC_UPDUSER;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "User %s in IIQ/IDN user list", usr_prm[ii].user);
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, usrmem->checksum, CHECKSUM_LEN, checksum);
        }
        else
		{
          api= FUNC_ADDUSER;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "User %s Not in IIQ/IDN user list", usr_prm[ii].user);
		}
        /*
        PROCESS when the user should be ADDED/UPDATED in the ESS.
        */
        if (usrmem_num GE usr_mem_num OR
            memcmp ((char *)checksum, (char *)usrmem->checksum,
                    CHECKSUM_LEN) NE 0)
		{
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s send to IIQ/IDN for %s.",
			usr_prm[ii].user, (api EQ FUNC_ADDUSER) ? "ADD" : "UPDATE");
          /*
          ADD the USERS ADD/UPDATE message to the message buffer.
          */
          msg= CS_add_rs_msg (api, &usr_prm[ii],&oe_prm, &ug_prm,
                            &u2ug_data, addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
          if (rc NE ESA_OK)
            goto cleanup;
 
          if (msg EQ NULL)
		  {
            rc = ESA_FATAL;
            goto cleanup;
          }
          if (sw_upd NE 0)
            umsg_rs= msg;
          else
            msg_rs= msg;
          if (api EQ FUNC_ADDUSER)
            statist->usr_add++;
          else
            statist->usr_upd++;
        } /* END - User should be ADDED/UPDATED in ESS */
        else
		{
          api= 0;
          statist->usr_not_chg++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s Not send to ESS.",
			usr_prm[ii].user);
        }
 
        statist->usr_ess++;
        CS_dwnld_event (statist, STEP_USR, PROCESS_FN, rc);
 
        if (envir_ptr->stop_req_msgs NE 0)
		{
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->usr_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->usr_rss, envir_ptr->stop_req_msgs,
			statist->usr_rss % envir_ptr->stop_req_msgs);
          if (statist->usr_rss % envir_ptr->stop_req_msgs EQ 0)
          {
            rc= CS_send_receive (msg_hdr);
            if (rc NE ESA_OK)
                goto cleanup;
          }
		}
 
      } /* END - FOR loop on all retrieved users. */
 
    } /* END - FOR loop on ALL RSS users */
 
  }
  /*
    SEND the remained ADD/UPDATE messages (if there are such messages).
  */
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (rs_num_umsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  /*
    SEND message to delete all users that are defined in the ESS but
    not in the RSS.
  */
  rc= CS_sync_usr_check (msg_hdr,
						 usr_mem_ptr, usr_mem_num,
                         statist, u2ug_mem_ptr,
                         u2ug_mem_num) ;
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr(GET_FREE_HANDLE_USERS,oe,MAX_GET,
                           &actual_num, &have_more, &handle, MAX_GET,
                           usr_prm_in, usr_prm, addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err,
                           get_conn);  /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_USR, END_FN, rc);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_usr_oe function */
 
/****************************************************
 * Procedure Name: CS_sync_usr
 * Description   : users syncronization between ESS and RSS
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is responsible to synchronize the RSS users and
 * ESS users. The function retrieves (in loop) RSS users according to
 * the list of interesting users (care users) from the ESS.
 * On each user it performs the following:
 * - If the user DOES not exist in the RSS - the user is ignored.
 * - If the user is not defined in the ESS (checksum) users -
 *   - An ADD user message is produced.
 * - If the user does exists in the ESS list of users but with
 *   different checksum - an UPDATE user message is produced.
 * Due to it's algorithm the function does not checks the Users that are
 * defined in the ESS as result of having default grou that is included
 * in the interesting default group.
 * In order to check such users and to locate ESS users that are defined
 * in the ESS but not in the RSS, and therefore should be deleted - the
 * function activates the CS_sync_usr_check function.
 *
 * After executing the current function - all users that should be on
 * the ESS due to thier inclusion in the interesting users list are
 * either added or updated. All users that defined in both the ESS
 * and the RSS are updated (if there is such need) and all the users
 * that are defined in the ESS but NOT IN THE RSS - are deleted.
 * The only missing sync is to ADD all the RSS users that SHOULD be
 * defined in the ESS due to their default group that is included in
 * the interest default groups and NOT YET DEFINED ON THE ESS - this
 * will be done on the u2ug function.
 *********************************************************************/
 
ESA_RC CS_sync_usr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                    USR_MEM_rec_ptr        usr_mem_ptr,
                    int                    usr_mem_num,
                    STATIST_rec_typ      * statist,
                    U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                    int                    u2ug_mem_num,
                    char                ** user_memory,
                    int                  * user_memory_init,
                    int                  * users_in_memory)
 
{
  char fn[]="CS_sync_usr";
  ESA_RC            rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ apiprm;
  void            * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short             actual_num= 0, api= 0, filled_num_users= 0;
  HAVE_MORE_typ     have_more= NO_MORE;
  CHECKSUM_typ      checksum;
  int               ii= 0, jj= 0, sw_upd= 0, sw_user= 0;
  USR_MEM_rec_ptr   usrmem= NULL;
  int               usrmem_num= 0;
  int               from_num_user= 0;
  MSG_typ         * msg= NULL;
  NUM_MSGS_typ      rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ      rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ         * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ  	      * amsg_rs_ptr=NULL;
  MSG_typ         * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  char              user_type;
 
  USR_MEM_rec_typ       def_usrmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
  ESA_RC                interest;
  char                  get_conn='N';  /* AC001 - CIQ#6 */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUSERS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all internal data.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR (usr_prm_in);
  CLEAR (usr_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_usrmem);
  CLEAR_STRUCT (u2ug_data);
  /*
    ALLOCATE user addinfo buffer for checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),   */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE ADD message buffer.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    ALLOCATE update user message buffer.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    BUILD addinfo for users checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE memory segments for all retrieved users addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *           */
               (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
      goto cleanup;
  /*
    BUILD msg. header for added users
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_ADD);
  /*
    BUILD msg. header for updated users
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_UPD);
 
  /*
    RETRIEVE the RSS users from the CARE users list. NOTE that users
    that should be treated according to the CARE default groups - will
    be handeled in the u2ug function.
  */
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 16,
                   "envir_ptr->num_users %d.",envir_ptr->num_users);
  for (from_num_user= 0, jj= 0, user_type = M_DWNLD_NAME_REGULAR;
       ((from_num_user LT envir_ptr->num_users) AND (rc EQ ESA_OK));)
  {
 
    CLEAR (usr_prm_in);
    /*
      FILL in the next portion of (wild card) user names from the CARE
      users list.
    */
    rc= CARE_inc_users_fill (usr_prm_in, &from_num_user, user_type,
	                         &filled_num_users);
    /*
      PROCESS (in loop) all the received users. Please note that the
      number of retrieved users does not have to be the same as the
      input users - because of wild-card usage.
    */
    for (have_more= HAVE_MORE, jj= 0;
         (
			 (have_more EQ HAVE_MORE)
		   AND
		     (rc EQ ESA_OK)
		   AND
		     (filled_num_users NE 0)
	     )
		 ;)
    {
      CLEAR (usr_prm);
      CLEAR (obj_exist);
      CS_addinfo_fill (
          info_ptr,
          addinfo,
          MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds);*/
      /*
        GET the next portion of RSS users details.
      */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
      CS_DIAG_USER_IN (ESA_COMP_ACSSYNC,
 (user_type EQ M_DWNLD_NAME_REGULAR) ? GET_MANY_USERS : GET_WILD_USERS,
		oe, MAX_GET, filled_num_users, usr_prm_in, handle, addinfo);
	  if (user_type EQ M_DWNLD_NAME_REGULAR)
         rc=envir_ptr->func_ptr.gtusers_ptr(GET_MANY_USERS,
            oe, MAX_GET,
		          &actual_num, &have_more, &handle, filled_num_users,
				        usr_prm_in, usr_prm, addinfo, obj_exist,
            &envir_ptr->msg_admin_param, &envir_ptr->msg_err,
            get_conn);  /* AC001 - CIQ#6 */
	  else
	     rc=envir_ptr->func_ptr.gtusers_ptr(GET_WILD_USERS,
         oe, MAX_GET,
		       &actual_num, &have_more, &handle, filled_num_users,
				     usr_prm_in, usr_prm, addinfo, obj_exist,
         &envir_ptr->msg_admin_param, &envir_ptr->msg_err,
         get_conn);  /* AC001 - CIQ#6 */
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rc EQ ESA_OK)
         CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
      rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
      if (apiprm.post EQ CS_YES)
	  {
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
      } /* END - PosstScript is required */
      if (rc NE ESA_OK)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
                         "->gtusers: Fail get users");
        goto cleanup;
      }
      /*
        PROCESS all retrieved users:
      */
      for (ii= 0;
           ii LT actual_num AND rc EQ ESA_OK;
           ii++, jj++)
      {
        statist->tmp_num++;
        /*
          IGNORE users that do not exist ion the RSS.
        */
        if (obj_exist[ii] EQ OBJ_NOT_EXIST)
		{
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                          "User %s NOT EXIST", usr_prm[ii].user);
          continue;
        }
        /*
          IGNORE not interesting users.
        */
        interest= CARE_inc_usr_find (usr_prm[ii].user,
                                     M_DWNLD_NAME_REGULAR);
 
        if (interest NE ESA_OK)
		{
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
                   "User %s Not in Scope", usr_prm[ii].user);
          continue;
        }
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
            "%d: User %s users_in_memory=%d.",
			ii, usr_prm[ii].user, *users_in_memory);
        rc= CS_dwnld_usr_to_memory (user_memory,
                                    users_in_memory,
                                    user_memory_init,
                                    usr_prm[ii].user);
        if (rc NE ESA_OK)
           goto cleanup;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
            "%d: users_in_memory=%d.",ii, *users_in_memory);
        CLEAR  (&def_usrmem);
        usrmem= &def_usrmem;
        /*
          CHECK if current user exists in ESS
        */
        usrmem_num= CS_sync_usr_checksum_find (usr_prm[ii].user,
                                       usr_mem_ptr, usr_mem_num);
        /*
          CALCULATE existing user's checksum.
        */
        if (usrmem_num LT usr_mem_num)
		{
          usrmem= usr_mem_ptr+ usrmem_num;
          usrmem->in_rss= '1';
          rc= CS_sync_get_checksum ((char *)&usr_prm[ii], bufk,
                                    addinfo[ii], checksum);
          if (rc NE ESA_OK)
            goto cleanup;
          api= FUNC_UPDUSER;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "User %s in IIQ/IDN user list", usr_prm[ii].user);
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, usrmem->checksum, CHECKSUM_LEN, checksum);
        }
        else {
          api= FUNC_ADDUSER;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
                    "User %s Not in IIQ/IDN user list", usr_prm[ii].user);
		}
        /*
          PROCESS when ADD/UPDATE user message should be sent to ESS:
        */
        if (usrmem_num GE usr_mem_num OR
            memcmp ((char *)checksum, (char *)usrmem->checksum,
                    CHECKSUM_LEN) NE 0)
		{
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s send to IIQ/IDN for %s.",
			usr_prm[ii].user, (api EQ FUNC_ADDUSER) ? "ADD" : "UPDATE");
          /*
            ADD the ADD/UPDATE user message to message buffer
          */
          msg= CS_add_rs_msg (api, &usr_prm[ii],&oe_prm, &ug_prm,
                              &u2ug_data, addinfo[ii],
                              &rs_msg_len, &rs_num_msgs,
                              msg_rs, msg_rs_ptr,
                              &rs_umsg_len, &rs_num_umsgs,
                              umsg_rs, umsg_rs_ptr,
                              &rs_amsg_len, &rs_num_amsgs,
                              amsg_rs, amsg_rs_ptr,
                              msg_hdr, &sw_user, &sw_upd,
                              &rc);
          if (rc NE ESA_OK)
            goto cleanup;
 
          if (msg EQ NULL)
		  {
            rc = ESA_FATAL;
            goto cleanup;
          }
          if (sw_upd NE 0)
            umsg_rs= msg;
          else
            msg_rs= msg;
          if (api EQ FUNC_ADDUSER)
            statist->usr_add++;
          else
            statist->usr_upd++;
        } /* END - ADD/UPDATE user message should be sent */
        else
		{
          api= 0;
          statist->usr_not_chg++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s Not send to ESS.",
			usr_prm[ii].user);
        }
        statist->usr_ess++;
        CS_dwnld_event (statist, STEP_USR, PROCESS_FN, rc);
 
        if (envir_ptr->stop_req_msgs NE 0)
		{
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->tmp_num(%d) stop_req_msgs(%d)=%d.",
		    statist->tmp_num, envir_ptr->stop_req_msgs,
			statist->tmp_num % envir_ptr->stop_req_msgs);
          if (statist->tmp_num % envir_ptr->stop_req_msgs EQ 0)
          {
            rc= CS_send_receive (msg_hdr);
            if (rc NE ESA_OK)
               goto cleanup;
		  }
		
		}
 
      } /* END - FOR loop on all retrieved users */
 
    } /* END - FOR loop on current portion users */
 
    if (
	     (envir_ptr->num_users LE from_num_user)
		AND
		 (user_type     EQ M_DWNLD_NAME_REGULAR)
		AND
		 (rc            EQ ESA_OK)
	  )
    {
		 user_type       = M_DWNLD_NAME_WILD;
 	     from_num_user   = 0;
    }
  } /* END - LOOP on all CARE users list */
  /*
    SEND the remain ADD/UPDATE messages (if such messages left).
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  /*
    CHECK the ESS list of users for users that were not handled;
    if they do exists in the RSS - update them (if there is such need)
    otherwise - delete them.
  */
  rc= CS_sync_usr_check (msg_hdr,
	                     usr_mem_ptr, usr_mem_num,
                         statist, u2ug_mem_ptr,
                         u2ug_mem_num) ;
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr(GET_FREE_HANDLE_USERS,oe,MAX_GET,
                           &actual_num, &have_more, &handle, MAX_GET,
                           usr_prm_in, usr_prm, addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err,
                           get_conn);  /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_USR, END_FN, rc);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_usr function */
 
/****************************************************
 * Procedure Name: CS_sync_u2ug_all
 * Description   : user to user group connections
 *                   with GET ALL
 *               : syncronization between ESS and RSS
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILS DESCRIPTION
 * ===================
 *
 * This function synchronizes ESS and RSS connections. It retrieves
 * and scans ALL RSS connections and handles connections that BOTH
 * it's USER AND GROUP are interesting - all other connections are
 * ignored. For each connection - the function checks it's existance
 * in the ESS, if it does not exist - an ADD connection message is
 * produced otherwise - the function checks that the ESS & RSS
 * connection's checksum are equal - if not and UPDATE connection
 * message is produced.
 * After handling the connections - the function scans all ESS
 * connections - if there are such connections that do not have
 * matching RSS connections - and no delete message - to their USER
 * or GROUP - was sent before, the function produce a DELETE connection
 * message.
 * ANOTHER task of the current function is to identify users that are
 * defined in the RSS but NOT IN THE ESS, that should be defined in the
 * ESS - because their default group appears in the list of interesting
 * default groups - and to send an ADD user message to the ESS - such
 * users were not handled in the CS_sync_usr !! but they WERE handled
 * by the CS_sync_usr_all function.
 *********************************************************************/
 
ESA_RC CS_sync_u2ug_all (RSS_MSG_HDR_rec_typ  * msg_hdr,
                         USR_MEM_rec_ptr        usr_mem_ptr,
                         int                    usr_mem_num,
                         U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                         int                    u2ug_mem_num,
                         STATIST_rec_typ      * statist,
                         int                    user_mode)
{
  char                  fn[]="CS_sync_u2ug_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  ESA_RC                rc_ug, rc_usr=ESA_OK,rc_usr_wild= ESA_OK ,
	                    rc_usr_sav = ESA_OK;
  int                   usrmem_num= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  char                * user_memory=  NULL;
  int                   users_in_memory= 0, user_memory_init=  0;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, sw_upd= 0, sw_user= 0;
  U2UG_MEM_rec_ptr      ugmem= NULL;
  int                   u2ugmem_num= 0;
  MSG_typ             * msg=  NULL;
  unsigned int          user_num_memory;
  U2UG_MEM_rec_typ      def_ugmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET], usr_wild;
  USER_PARAMS_rec_typ   usr_prm;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_typ                ug_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  CONNECT_PARAMS_rec_typ conn_param;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUG2UC,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR internal structures.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (usr_in);
  CLEAR (ug_in);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR (u2ug_data);
  CLEAR (usr_wild);
 
  /*
    ALLOCATE buffer for connection checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),  */
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE buffer for add connection messages.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE buffer for update connection messages.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE buufer for add USERS messages.
  */
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    CHECK if the is a "wild" user among interesting users or
    interesting default groups.
  */
  rc_usr_wild= CARE_inc_usr_find  (usr_wild,
                                   M_DWNLD_NAME_ALL);
  /*
    BUILD addinfo for user connection to user-group checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE buffer for retrieved connections addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    BUILD msg. header for added connections
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
 
  /*
    BUILD msg. header for updated connections
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG2UC_UPD);
  /*
    BUILD msg. header for add users
  */
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
  /*
    PROCESS ALL connections in RSS.
  */
  for (have_more= HAVE_MORE, jj= 0;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (ug_in);
    CLEAR (usr_in);
    CLEAR_STRUCT (ug_prm);
    CLEAR_STRUCT (usr_prm);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    /*
      GET next portion of connections.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_ALL_CONNS, MAX_GET,
		0, 0, ug_in, usr_in, handle, addinfo);
    rc= envir_ptr->func_ptr.gtug2uc_ptr (GET_ALL_CONNS,
                               MAX_GET,&actual_num,
                               &have_more, &handle, 0,
                               0, ug_in, usr_in,
                               u2ug_data, addinfo, obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
 
    /*
      PROCESS all retrieved connections:
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++, jj++)
	{
      statist->u2ug_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection User %s to group %s Not Exist",
			 u2ug_data[ii].user, u2ug_data[ii].group);
         statist->u2ug_not_exist++;
         continue;
	  }
 
      CLEAR_STRUCT (def_ugmem);
      ugmem= &def_ugmem;
      memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
              sizeof(USER_typ));
      memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
              sizeof(UG_typ));
      memcpy ((char *)usr_prm.def_group,
              (char *)u2ug_data[ii].def_group,
              sizeof(UG_typ));
      /*
        CHECK group of connection is interesting for ESS
      */
      rc_ug= CARE_inc_ug_find (u2ug_data[ii].group);
 
	  if (rc_ug NE ESA_OK)
         rc_ug= CARE_inc_u2ug_find (u2ug_data[ii].group);
 
	  /*
        CHECK if user of connection is interesting for ESS or it's
        default group is interesting for ESS.
      */
 
      rc_usr = CARE_inc_usr_find(u2ug_data[ii].user,
                               M_DWNLD_NAME_REGULAR);
 
      rc_usr_sav = rc_usr ;
 
	  if (rc_usr NE ESA_OK)
	  {
          if (strlen (u2ug_data[ii].def_group) EQ 0)
		     rc_usr= ESA_ERR;
	      else
             rc_usr= CARE_inc_ug_find (u2ug_data[ii].def_group);
	  }
 
	  /*
        IGNORE connection if group OR user is not among interesting
        users/group.
      */
 
	  if (
            (rc_usr NE ESA_OK)
           OR
            (rc_ug NE ESA_OK)
         )
      {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
          "User %s to group %s connection (def ug %s) Not in Scope",
                        u2ug_data[ii].user, u2ug_data[ii].group,
                        u2ug_data[ii].def_group);
        continue;
      }
 
	  /*
        CHECK if current connection exists in ESS.
      */
 
      u2ugmem_num= CS_sync_u2ug_checksum_find (u2ug_data[ii].group,
		               u2ug_mem_ptr, u2ug_mem_num, u2ug_data[ii].user);
 
	  /*
        PROCESS when the connection exists in the ESS.
      */
 
	  if (u2ugmem_num LT u2ug_mem_num)
	  {
        ugmem= u2ug_mem_ptr+ u2ugmem_num;
        ugmem->in_rss= '1';
        CLEAR_STRUCT (conn_param);
        strcpy (conn_param.user,      u2ug_data[ii].user);
        strcpy (conn_param.group,     u2ug_data[ii].group);
        memcpy((char *)(&conn_param.u2ug_prm),(char *)(&u2ug_data[ii]),
                sizeof (U2UG_PARAMS_rec_typ));
        /*
          CALCULATE the connection's checksum.
        */
        rc= CS_sync_get_checksum ((char *)&conn_param, bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDU2UG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
      } /* END - the connection exists in ESS */
      else
	  {
        api= FUNC_ADDU2UG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s Not in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
	  }
      /*
        CHECK if user of the connection is in list of interesting
        users (WITHOUT REGARDING INTERESTING DEFAULT GROUP).
      */
 
      /* 27/9/99 Aviw */
 
	  rc_usr = rc_usr_sav;
 
      /*
	  rc_usr=CARE_inc_usr_find(u2ug_data[ii].user,
                               M_DWNLD_NAME_REGULAR);
      */
 
      if (
           (rc_usr      NE ESA_OK) AND
           (rc_usr_wild NE ESA_OK) AND
		   ((ESA_RC)user_mode NE ESA_OK)
		 )
	  {
 
        /*
          CHECK if user is defined in the ESS.
        */
 
        usrmem_num= CS_sync_usr_checksum_find (u2ug_data[ii].user,
                                       usr_mem_ptr, usr_mem_num);
        /*
          Check if current user is list of previously added users.
        */
 
        user_num_memory= CS_dwnld_mem_usr_find (user_memory,
                                                users_in_memory,
                                                u2ug_data[ii].user);
	  }
 
      /*
        NOW we should take care of users that are NOT defined
        is the ESS , they should be defined there due to their default
        group that is included in the interesting groups, AND no add
        message WAS sent to the ESS yet.
      */
 
      if (
           (rc_usr      NE ESA_OK) AND /*The user is not among
                                         interesrting users - therfore
                                         due to prev. elimination -
                                         it's default group MUST be in
                                         interesting default groups. */
           (rc_usr_wild NE ESA_OK) AND /* NO WILD user or default group
                                          was requested - otherwise it
                                          was treated before. */
           (usrmem_num  GE usr_mem_num) AND /* The user is NOT defined
                                               in the ESS */
           ((ESA_RC)user_mode NE ESA_OK) AND /*The get type is not ALL
                                            otherwise it was handeled
                                            in the CS_sync_usr_all */
           (user_num_memory GE (unsigned int)users_in_memory)
		                                     /* the user is not
                                         in list of yet added users*/
		 )
	  {
        /*
           ADD user ADD message to message buffer.
        */
        rc= CS_sync_add_usr (msg_hdr,
			                 statist,
                             u2ug_data[ii].user,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs_ptr, &amsg_rs,
                             &user_memory,
							 &user_memory_init,
							 &users_in_memory);
        if (rc NE ESA_OK)
          goto cleanup;
      }
      /*
        PROCESS when ADD/UPDATE connection message should be delivered:
      */
      if (u2ugmem_num GE u2ug_mem_num OR
          memcmp ((char *)checksum, (char *)ugmem->checksum,
                  CHECKSUM_LEN) NE 0)
	  {
         ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s send to IIQ/IDN for %s.",
	       u2ug_data[ii].group, u2ug_data[ii].user, (api EQ FUNC_ADDU2UG) ? "ADD" : "UPDATE");
        /*
          ADD ADD/UPDATE connection message to message buffer.
        */
        msg= CS_add_rs_msg (api, &usr_prm, &oe_prm,&ug_prm,
                            &u2ug_data[ii], addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
        if (sw_user NE 0)
          amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                   &rs_num_amsgs ,
                                   amsg_rs ,
                                   amsg_rs_ptr ,
                                   msg_hdr,
                                   MSG_USER_ADD);
        if (api EQ FUNC_ADDU2UG)
          statist->u2ug_add++;
        else
          statist->u2ug_upd++;
      } /* END ADD/UPDATE message should be delivered. */
      else {
        api= 0;
        statist->u2ug_not_chg++;
         ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s Not send to IIQ/IDN.",
			ug_prm.group, usr_prm.user);
      }
      statist->u2ug_ess++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->u2ug_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->u2ug_rss, envir_ptr->stop_req_msgs,
			statist->u2ug_rss % envir_ptr->stop_req_msgs);
        if (statist->u2ug_rss % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->tmp_num(%d) stop_req_msgs(%d)=%d.",
		    statist->tmp_num, envir_ptr->stop_req_msgs,
			statist->tmp_num % envir_ptr->stop_req_msgs);
        if (statist->tmp_num % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on current retrieved connections */
 
  } /* END - FOR loop on all RSS connections */
  /*
    SEND ADD/UPDATE connection and ADD user messages that were not sent
    (if such messages exists).
  */
  if (rs_num_amsgs NE 0) {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  /*
    SEND DELETE messages for every connection from list of ESS
    connections, that is not exist in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_DEL);
  for (u2ugmem_num= 0;
       u2ugmem_num LT u2ug_mem_num AND rc EQ ESA_OK;
       u2ugmem_num++) {
    ugmem= u2ug_mem_ptr+ u2ugmem_num;
    if (
         (ugmem->in_rss NE '1') /* '1' = connection found */
        AND
         (ugmem->in_rss NE '2') /* '2' = USER/GROUP deleted */
       ) {
      statist->u2ug_del++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
      CLEAR (u2ug_data);
      CLEAR_STRUCT (ug_prm);
      CLEAR_STRUCT (usr_prm);
      strcpy (usr_prm.user, ugmem->user);
      strcpy (ug_prm.group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
         "Conection User %s to group %s send to IIQ/IDN for DELETE",
             usr_prm.user, ug_prm.group);
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELU2UG, &usr_prm, &oe_prm,
                             &ug_prm, &u2ug_data[0], addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL) {
        rc = ESA_FATAL;
        goto cleanup;
      }
 
    } /* END - connection was not handled and user/group was not
         deleted.
       */
 
  } /* END - FOR loop on all ESS connections */
  /*
    SEND remain DELELE connection messages (if there are such
    messages.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (GET_FREE_HANDLE_CONNS, MAX_GET,
                           &actual_num, &have_more,
                           &handle, MAX_GET, MAX_GET,ug_in,
                           usr_in, u2ug_data,
                           addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)&user_memory);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_u2ug_all function */
 
 
/****************************************************
 * Procedure Name: CS_sync_oe_u2ug
 * Description   : user to user group connections
 *                   with GET SUBTREE for every container from list
 *               : syncronization between ESS and RSS
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILS DESCRIPTION
 * ===================
 *
 * This function synchronizes ESS and RSS connections. It retrieves
 * and scans SUBTREE RSS connections for every container from the
 * list of interesting connections
 * For each connection - the function checks it's existance
 * in the ESS, if it does not exist - an ADD connection message is
 * produced otherwise - the function checks that the ESS & RSS
 * connection's checksum are equal - if not and UPDATE connection
 * message is produced.
 * After handling the connections - the function scans all ESS
 * connections - if there are such connections that do not have
 * matching RSS connections - and no delete message - to their USER
 * or GROUP - was sent before, the function produce a DELETE connection
 * message.
 *********************************************************************/
 
ESA_RC CS_sync_u2ug_oe  (RSS_MSG_HDR_rec_typ  * msg_hdr,
                         U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                         int                    u2ug_mem_num,
                         STATIST_rec_typ      * statist,
                         char                 * ug_typ_ptr,
                         int                    ug_typ_num)
{
  char fn[]="CS_sync_u2ug_oe";
  ESA_RC                rc= ESA_OK,rc_pst,rc_logout= ESA_OK,rc_in_oe;
  RSSAPIPRM_rec_typ     apiprm;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  int                   from_num_ug=0;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0, num_ugs_in;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, sw_upd= 0, sw_user= 0;
  U2UG_MEM_rec_ptr      ugmem= NULL;
  int                   u2ugmem_num= 0;
  MSG_typ             * msg=  NULL;
 
  U2UG_MEM_rec_typ      def_ugmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_typ                ug_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  CONNECT_PARAMS_rec_typ conn_param;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUG2UC,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR internal structures.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (usr_in);
  CLEAR (ug_in);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR (u2ug_data);
 
  /*
    ALLOCATE buffer for connection checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),    */
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE buffer for add connection messages.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE buffer for update connection messages.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE buufer for add USERS messages.
  */
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    BUILD addinfo for user connection to user-group checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
            bufk,
            kwd_types,
            1,
            envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE buffer for retrieved connections addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *            */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    BUILD msg. header for added connections
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
 
  /*
    BUILD msg. header for updated connections
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG2UC_UPD);
  /*
    BUILD msg. header for add users
  */
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
  /*
    PROCESS ALL connections in RSS.
  */
 
  ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
                "%s: Looping on ugs (total %d)",
                fn, ug_typ_num );
 
    /*  Get list of increment containers */
  for (from_num_ug= 0;
       from_num_ug LT ug_typ_num AND rc EQ ESA_OK;
       from_num_ug +=MAX_GET)
  {
 
 
     CLEAR (ug_in);
     rc= CS_dwnld_ugs_fill (ug_in, from_num_ug, &num_ugs_in,
		                   ug_typ_ptr, ug_typ_num);
 
     ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
                    "%s: Processing conns of ug %s (%d)",
                    fn, ug_in, from_num_ug );
 
    for (have_more= HAVE_MORE, jj= 0;
         have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
    {
      CLEAR (usr_in);
      CLEAR_STRUCT (ug_prm);
      CLEAR_STRUCT (usr_prm);
      CLEAR (u2ug_data);
      CLEAR (obj_exist);
      CS_addinfo_fill (
          info_ptr,
          addinfo,
          MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
      /*
      GET next portion of connections.
      */
      rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (rc NE ESA_OK)
        goto cleanup;
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
      CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_GROUPS_CONNS, MAX_GET,
		num_ugs_in, 0, ug_in, usr_in, handle, addinfo);
      rc= envir_ptr->func_ptr.gtug2uc_ptr (GET_GROUPS_CONNS,MAX_GET,
                            &actual_num, &have_more, &handle,
                            num_ugs_in, 0,
                            ug_in, usr_in, u2ug_data,addinfo,obj_exist,
                            &envir_ptr->msg_admin_param,
                            &envir_ptr->msg_err);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rc EQ ESA_OK)
         CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
      rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
      if (apiprm.post EQ CS_YES)
	  {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
      } /* END - PosstScript is required */
      if (rc NE ESA_OK)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
           "->gtug2uc: Fail get connections");
        goto cleanup;
     }
 
      /*
      PROCESS all retrieved connections:
      */
      for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++, jj++)
	  {
        statist->u2ug_rss++;
        statist->tmp_num++;
        if (obj_exist[ii] EQ OBJ_NOT_EXIST)
		{
           ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
              "Connection User %s to Group %s Not Exist",
			   u2ug_data[ii].user, u2ug_data[ii].group);
           statist->u2ug_not_exist++;
           continue;
		}
 
        rc_in_oe= CARE_inc_object_in_oe ((char *)u2ug_data[ii].user,
                                         TYPE_USER);
        if (rc_in_oe NE ESA_OK)
		{
           ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
              "User %s Not in Scope", u2ug_data[ii].user);
            continue;
		}
        CLEAR_STRUCT (def_ugmem);
        ugmem= &def_ugmem;
        memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
                sizeof(USER_typ));
        memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
                sizeof(UG_typ));
        usr_prm.def_group[0] = '\0';
        /*
        CHECK if current connection exists in ESS.
        */
        u2ugmem_num= CS_sync_u2ug_checksum_find (u2ug_data[ii].group,
			u2ug_mem_ptr, u2ug_mem_num, u2ug_data[ii].user);
        /*
        PROCESS when the connection exists in the ESS.
        */
        if (u2ugmem_num LT u2ug_mem_num)
		{
          ugmem= u2ug_mem_ptr+ u2ugmem_num;
          ugmem->in_rss= '1';
          CLEAR_STRUCT (conn_param);
          strcpy (conn_param.user,      u2ug_data[ii].user);
          strcpy (conn_param.group,     u2ug_data[ii].group);
          memcpy ((char *)(&conn_param.u2ug_prm),
                  (char *)(&u2ug_data[ii]),
                sizeof (U2UG_PARAMS_rec_typ));
          /*
          CALCULATE the connection's checksum.
          */
          rc= CS_sync_get_checksum ((char *)&conn_param, bufk,
                                    addinfo[ii], checksum);
          if (rc NE ESA_OK)
            goto cleanup;
          api= FUNC_UPDU2UG;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
        } /* END - the connection exists in ESS */
        else
		{
          api= FUNC_ADDU2UG;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s Not in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
		}
        /*
        PROCESS when ADD/UPDATE connection message should be delivered:
        */
        if (u2ugmem_num GE u2ug_mem_num OR
            memcmp ((char *)checksum, (char *)ugmem->checksum,
                    CHECKSUM_LEN) NE 0)
		{
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s send to IIQ/IDN for %s.",
			u2ug_data[ii].group, u2ug_data[ii].user, (api EQ FUNC_ADDU2UG) ? "ADD" : "UPDATE");
          /*
          ADD ADD/UPDATE connection message to message buffer.
          */
          msg= CS_add_rs_msg (api, &usr_prm, &oe_prm,&ug_prm,
                            &u2ug_data[ii], addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
          if (rc NE ESA_OK)
            goto cleanup;
 
          if (msg EQ NULL)
		  {
            rc = ESA_FATAL;
            goto cleanup;
          }
          if (sw_upd NE 0)
            umsg_rs= msg;
          else
            msg_rs= msg;
          if (sw_user NE 0)
            amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                   &rs_num_amsgs ,
                                   amsg_rs ,
                                   amsg_rs_ptr ,
                                   msg_hdr,
                                   MSG_USER_ADD);
          if (api EQ FUNC_ADDU2UG)
            statist->u2ug_add++;
          else
            statist->u2ug_upd++;
        } /* END ADD/UPDATE message should be delivered. */
        else
		{
          api= 0;
          statist->u2ug_not_chg++;
          ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s Not send to IIQ/IDN.",
			u2ug_data[ii].group, u2ug_data[ii].user);
        }
        statist->u2ug_ess++;
        CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
        if (envir_ptr->stop_req_msgs NE 0)
		{
          ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->u2ug_rss(%d) stop_req_msgs(%d)=%d.",
		    statist->u2ug_rss, envir_ptr->stop_req_msgs,
			statist->u2ug_rss % envir_ptr->stop_req_msgs);
          if (statist->u2ug_rss % envir_ptr->stop_req_msgs EQ 0)
          {
            rc= CS_send_receive (msg_hdr);
            if (rc NE ESA_OK)
               goto cleanup;
          }
		}
 
      } /* END - FOR loop on current retrieved connections */
 
    } /* END - FOR loop on all RSS connections */
 
  }
  /*
    SEND ADD/UPDATE connection and ADD user messages that were not sent
    (if such messages exists).
  */
  if (rs_num_amsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (rs_num_umsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
 
  /*
    SEND DELETE messages for every connection from list of ESS
    connections, that is not exist in RSS
  */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_DEL);
  for (u2ugmem_num= 0;
       u2ugmem_num LT u2ug_mem_num AND rc EQ ESA_OK;
       u2ugmem_num++)
  {
    ugmem= u2ug_mem_ptr+ u2ugmem_num;
    if (
         (ugmem->in_rss NE '1') /* '1' = connection found */
        AND
         (ugmem->in_rss NE '2') /* '2' = USER/GROUP deleted */
       )
	{
      statist->u2ug_del++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
      CLEAR (u2ug_data);
      CLEAR_STRUCT (ug_prm);
      CLEAR_STRUCT (usr_prm);
      strcpy (usr_prm.user, ugmem->user);
      strcpy (ug_prm.group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
         "Conection User %s to Group %s send to IIQ/IDN for DELETE",
             usr_prm.user, ug_prm.group);
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELU2UG, &usr_prm, &oe_prm,
                             &ug_prm, &u2ug_data[0], addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL)
	  {
        rc = ESA_FATAL;
        goto cleanup;
      }
 
    } /* END - connection was not handled and user/group was not
         deleted.
       */
 
  } /* END - FOR loop on all ESS connections */
  /*
    SEND remain DELELE connection messages (if there are such
    messages.
  */
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (GET_FREE_HANDLE_CONNS, MAX_GET,
                           &actual_num, &have_more,
                           &handle, MAX_GET, MAX_GET,ug_in,
                           usr_in, u2ug_data,
                           addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_u2ug_oe function */
 
/****************************************************
 * Procedure Name: CS_sync_u2ug
 * Description   : user to user group connections
 *               : syncronization between ESS and RSS
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILS DESCRIPTION
 * ===================
 *
 * This function synchronizes ESS and RSS connections. It retrieves
 * and scans RSS connections to important GROUPS and DEFAULT GROUPS,
 * and handles connections that it's USER is interesting - all other
 * connections are ignored. For each connection - the function checks
 * it's existance in the ESS, if it does not exist - an ADD connection
 * message is produced otherwise - the function checks that the ESS &
 * RSS connection's checksum are equal - if not and UPDATE connection
 * message is produced.
 * After handling the connections - the function scans all ESS
 * connections - if there are such connections that do not have
 * matching RSS connections - and no delete message - to their USER
 * or GROUP - was sent before, the function produce a DELETE connection
 * message.
 * ANOTHER task of the current function is to identify users that are
 * defined in the RSS but NOT IN THE ESS, that should be defined in the
 * ESS - because their default group appears in the list of interesting
 * default groups - and to send an ADD user message to the ESS - such
 * users were not handled in the CS_sync_usr !! but they WERE handled
 * by the CS_sync_usr_all function.
 *********************************************************************/
 
ESA_RC CS_sync_u2ug     (RSS_MSG_HDR_rec_typ  * msg_hdr,
                         USR_MEM_rec_ptr        usr_mem_ptr,
                         int                    usr_mem_num,
                         U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                         int                    u2ug_mem_num,
                         STATIST_rec_typ      * statist,
                         int                    user_mode)
{
  char fn[]="CS_sync_u2ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  ESA_RC                rc_usr=ESA_OK,rc_usr_wild=ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0, filled_num_u2ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, sw_upd= 0, sw_user= 0;
  U2UG_MEM_rec_ptr      ugmem= NULL;
  int                   u2ugmem_num= 0;
  int                   from_num_u2ug= 0;
  MSG_typ             * msg= NULL;
  int                   usrmem_num= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  char                * user_memory=  NULL;
  int                   users_in_memory= 0, user_memory_init=  0;
 
  U2UG_MEM_rec_typ       def_ugmem;
  RSSAPIKWD_rec_typ    * bufk= NULL;
  ADDINFO_rec_typ      * info_ptr= NULL;
  USER_typ               usr_in [MAX_GET], usr_wild;
  USER_PARAMS_rec_typ    usr_prm;
  UG_typ                 ug_in  [MAX_GET];
  OE_typ                 oe;
  OE_PARAMS_rec_typ      oe_prm;
  UG_PARAMS_rec_typ      ug_prm;
  U2UG_PARAMS_rec_typ    u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ         obj_exist  [MAX_GET];
  ADDINFO_rec_ptr        addinfo    [MAX_GET];
  CONNECT_PARAMS_rec_typ conn_param;
  unsigned int           user_num_memory;
  ENVIRONMENT_rec_typ  * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUG2UC,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR internal structures.
  */
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (usr_in);
  CLEAR (oe);
  CLEAR (ug_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (def_ugmem);
  CLEAR (u2ug_data);
  CLEAR (usr_wild);
  /*
    ALLOCATE addinfo connection buffer for checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE add connections messages buffer.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE update connections messages buffer.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE add users messages buffer.
  */
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    CHECK if wild user appears among the list of interesting
    users.
  */
  rc_usr_wild= CARE_inc_usr_find  (usr_wild,
                                   M_DWNLD_NAME_REGULAR);
  /*
    BUILD addinfo for user connection to user-group checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
          bufk,
          kwd_types,
          1,
          envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  /*
    ALLOCATE buffer for retrieved connections addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *            */
             (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    BUILD msg. header for added connections
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
  /*
    BUILD msg. header for updated connections
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_UG2UC_UPD);
  /*
    BUILD msg. header for add users
  */
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
  /*
    SCAN all interesting groups & interesting default groups:
  */
  for (from_num_u2ug= 0;
       ((from_num_u2ug LT (envir_ptr->num_u2ugs + envir_ptr->num_ugs))
           AND
        (rc EQ ESA_OK));)
  {
 
   CLEAR (ug_in);
   /*
     FILL next potion of group names.
   */
   rc= CARE_inc_u2ugs_fill (ug_in, &from_num_u2ug, &filled_num_u2ugs);
   /*
     SCAN all connections for current groups portion:
   */
   for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (usr_in);
    CLEAR (&ug_prm);
    CLEAR (&usr_prm);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    /*
      RETRIEVE next portion of ALL connections to current portion
      of groups.
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_GROUPS_CONNS, MAX_GET,
		filled_num_u2ugs, 0, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(GET_GROUPS_CONNS,
                             MAX_GET,&actual_num,
                             &have_more, &handle, filled_num_u2ugs,
                             0, ug_in, usr_in, u2ug_data,
                             addinfo, obj_exist,
                             &envir_ptr->msg_admin_param,
                             &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
 
    ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
                    "gtug2uc: actual_num %d have_more %d",
                    actual_num, have_more);
    /*
      SCAN all retrieved connections:
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++) {
      statist->tmp_num++;
      /*
        IGNORE connection that does not exist.
      */
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        statist->u2ug_not_exist++;
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
          "Connection user %s to group %s Not Exist",
                         u2ug_data[ii].user, u2ug_data[ii].def_group);
        continue;
      }
 
      CLEAR (&def_ugmem);
      ugmem= &def_ugmem;
      memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
              sizeof(USER_typ));
      memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
              sizeof(UG_typ));
      memcpy ((char *)usr_prm.def_group,
              (char *)u2ug_data[ii].def_group,
              sizeof(UG_typ));
      /*
        CHECK if the connection's user is an interesting user or that
        his default group is among the list of interesting default
        groups.
      */
 
      rc_usr=CARE_inc_usr_find(u2ug_data[ii].user,
                               M_DWNLD_NAME_REGULAR);
      if (rc_usr NE ESA_OK)
	  {
    	  if (strlen (u2ug_data[ii].def_group) EQ 0)
	     	  rc_usr= ESA_ERR;
	      else
              rc_usr= CARE_inc_ug_find (u2ug_data[ii].def_group);
	  }
      /*
        IGNORE connections to non interesting users.
      */
      if (rc_usr NE ESA_OK) {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
          "Connection user %s to group %s Not in Scope",
                         u2ug_data[ii].user, u2ug_data[ii].def_group);
        continue;
      }
      /*
        CHECK if connection is defined in the ESS.
      */
      u2ugmem_num= CS_sync_u2ug_checksum_find (u2ug_data[ii].group,
		  u2ug_mem_ptr, u2ug_mem_num, u2ug_data[ii].user);
      /*
        PROCESS when the connection is defined in the ESS:
      */
      if (u2ugmem_num LT u2ug_mem_num) {
        ugmem= u2ug_mem_ptr+ u2ugmem_num;
        ugmem->in_rss= '1';
        CLEAR_STRUCT (conn_param);
        strcpy (conn_param.user,  u2ug_data[ii].user);
        strcpy (conn_param.group, u2ug_data[ii].group);
        memcpy ((char *)(&conn_param.u2ug_prm),
                (char *)(&u2ug_data[ii]),
                sizeof (U2UG_PARAMS_rec_typ));
        /*
          CALCULATE the connection's checksum in the RSS.
        */
        rc= CS_sync_get_checksum ((char *)&conn_param, bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDU2UG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, ugmem->checksum, CHECKSUM_LEN, checksum);
      }
      else
	  {
        api= FUNC_ADDU2UG;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
            "Connection group %s to user %s Not in IIQ/IDN conection list",
			u2ug_data[ii].group, u2ug_data[ii].user);
	  }
      /*
        CHECK if current connection's user appears in the list of
        interesting users (DO NOT TAKE IN ACCOUNT THE USER'S DEFAULT
        GROUP).
      */
      rc_usr= CARE_inc_usr_find (u2ug_data[ii].user,
		                         M_DWNLD_NAME_REGULAR);
      /*
        CHECK if the user is defined in the ESS.
      */
      usrmem_num= CS_sync_usr_checksum_find (u2ug_data[ii].user,
                                     usr_mem_ptr, usr_mem_num);
      /*
        Check if current user is list of previously added users.
      */
      user_num_memory= CS_dwnld_mem_usr_find (user_memory,
                                              users_in_memory,
                                              u2ug_data[ii].user);
      /*
        NOW we should take care of users that are NOT defined
        is the ESS , they should be defined there due to their default
        group that is included in the interesting groups, AND no add
        message WAS sent to the ESS yet.
      */
      if (
           (rc_usr      NE ESA_OK) AND /*The user is not among
                                         interesrting users - therfore
                                         due to prev. elimination -
                                         it's default group MUST be in
                                         interesting default groups. */
           (rc_usr_wild NE ESA_OK) AND /* NO WILD user or - otherwise
                                          it was treated before. */
           (usrmem_num GE usr_mem_num) AND  /* The user is NOT defined
                                               in the ESS */
           ((ESA_RC)user_mode NE ESA_OK) AND/* The get type is not ALL
                                           otherwise it was handeled
                                           in the CS_sync_usr_all */
           (user_num_memory GE (unsigned int)users_in_memory)
		                                   /* the user is not
                                         in list of yet added users*/
		 )
	  {
        /*
           ADD user ADD message to message buffer.
        */
        rc= CS_sync_add_usr (msg_hdr,
			                 statist,
                             u2ug_data[ii].user,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs_ptr, &amsg_rs,
                             &user_memory,
							 &user_memory_init,
							 &users_in_memory);
        if (rc NE ESA_OK)
          goto cleanup;
      }
      /*
        PROCESS when ADD/UPDATE connection message should be delivered:
      */
      if (u2ugmem_num GE u2ug_mem_num OR
          memcmp ((char *)checksum, (char *)ugmem->checksum,
                  CHECKSUM_LEN) NE 0) {
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s send to IIQ/IDN for %s.",
			u2ug_data[ii].group, u2ug_data[ii].user, (api EQ FUNC_ADDU2UG) ? "ADD" : "UPDATE");
        /*
          ADD ADD/UPDATE connection message to message buffer.
        */
        msg=    CS_add_rs_msg (api, &usr_prm,&oe_prm, &ug_prm,
                               &u2ug_data[ii], addinfo[ii],
                               &rs_msg_len, &rs_num_msgs,
                               msg_rs, msg_rs_ptr,
                               &rs_umsg_len, &rs_num_umsgs,
                               umsg_rs, umsg_rs_ptr,
                               &rs_amsg_len, &rs_num_amsgs,
                               amsg_rs, amsg_rs_ptr,
                               msg_hdr, &sw_user, &sw_upd,
                               &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
        if (sw_user NE 0)
          amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                   &rs_num_amsgs ,
                                   amsg_rs ,
                                   amsg_rs_ptr ,
                                   msg_hdr,
                                   MSG_USER_ADD);
        if (api EQ FUNC_ADDU2UG)
          statist->u2ug_add++;
        else
          statist->u2ug_upd++;
      } /* END ADD/UPDATE message should be delivered. */
      else {
        api= 0;
        statist->u2ug_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES,
			"Conection Group %s to User %s Not send to IIQ/IDN.",
			u2ug_data[ii].group, u2ug_data[ii].user);
      }
      statist->u2ug_ess++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
      if (envir_ptr->stop_req_msgs NE 0)
	  {
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_COMMON+ 1,
           "statist->tmp_num(%d) stop_req_msgs(%d)=%d.",
		    statist->tmp_num, envir_ptr->stop_req_msgs,
			statist->tmp_num % envir_ptr->stop_req_msgs);
        if (statist->tmp_num % envir_ptr->stop_req_msgs EQ 0)
        {
           rc= CS_send_receive (msg_hdr);
           if (rc NE ESA_OK)
               goto cleanup;
        }
	  }
 
    } /* END - FOR loop on all current retrieved connections */
 
   } /* END - FOR loop on all connectiuons to current group portion */
 
  } /* END - FOR loop on all interesting groups */
  /*
    SEND any left ADD/UPDATE connection or ADD user messages.
  */
  if (rs_num_amsgs NE 0) {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  /*
    SEND DELETE messages for every connection from list of ESS
    connections, that is not exist in RSS
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_DEL);
  for (u2ugmem_num= 0;
       u2ugmem_num LT u2ug_mem_num AND rc EQ ESA_OK;
       u2ugmem_num++) {
    ugmem= u2ug_mem_ptr+ u2ugmem_num;
    if (
         (ugmem->in_rss NE '1') /* '1' = connection found */
        AND
         (ugmem->in_rss NE '2') /* '2' = USER/GROUP deleted */
       ) {
      statist->u2ug_del++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
      CLEAR (u2ug_data);
      CLEAR_STRUCT (ug_prm);
      CLEAR_STRUCT (usr_prm);
      strcpy (usr_prm.user, ugmem->user);
      strcpy (ug_prm.group, ugmem->ug);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
         "Connection User %s to Group %s send to IIQ/IDN for DELETE",
             usr_prm.user, ug_prm.group);
      /*WS10082A addinfo[0]->max_pairs= 0;                         */
      /*WS10082A addinfo[0]->num_pairs= 0;                         */
      ADDINFO_empty(addinfo[0]);                         /*WS10082A*/
      msg_rs= CS_add_rs_msg (FUNC_DELU2UG, &usr_prm, &oe_prm,&ug_prm,
                             &u2ug_data[0], addinfo[0],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
      if (msg_rs EQ NULL) {
        rc = ESA_FATAL;
        goto cleanup;
      }
    }
  } /* END - FOR loop on all ESS connections */
  /*
    SEND left DELETE connection messages.
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (GET_FREE_HANDLE_CONNS, MAX_GET,
                           &actual_num, &have_more,
                           &handle, MAX_GET, MAX_GET,ug_in,
                           usr_in, u2ug_data,
                           addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSYNC, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)&user_memory);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
} /* END - CS_sync_u2ug function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CS_sync_add_usr
*                                                             *
* Description      : Send message to ESS about
*                      new interesting user
* Return Value     : ESA_RC                                   *
*                                                             *
**************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function handles add user messages , that should be delivered
* from the CS_sync_u2ug & CS_sync_u2ug_all function. The function
* (correectly) assumes that it may be activated more than single time
* on the same user; therefore it saves all added users in special
* buffer and before creating the message it makes sure that the users
* was not handled before.
* PLEASE NOTE that besides checking if the user was treated before -
* the function does not perform any algorithm to decide IF THE USERS
* HAS TO BE ADDED TO THE ESS - the decision is purely done by the
* calling function.
*********************************************************************/
 
ESA_RC CS_sync_add_usr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                        STATIST_rec_typ      * statist,
                        USER_typ               user,
                        NUM_MSGS_typ         * rs_amsg_len,
                        NUM_MSGS_typ         * rs_num_amsgs,
                        MSG_typ              * amsg_rs_ptr,
                        MSG_typ             ** amsg_rs,
                        char                ** user_memory,
                        int                  * user_memory_init,
                        int                  * users_in_memory)
{
  char fn[]="CS_sync_add_usr";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  void                * handle= NULL, * handle_for_evnt= NULL;
  int                   sw_upd= 0, sw_user= 0;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
 
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_PARAMS_rec_typ   usr_prm    [1], usr_prm_in[1];
  ADDINFO_rec_ptr       addinfo    [1];
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  OBJ_EXISTS_typ        obj_exist  [1];
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  get_conn = 'N';  /* AC001 - CIQ#6 */
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUSERS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR internal structures.
  */
  CLEAR (usr_prm);
  CLEAR (usr_prm_in);
  CLEAR (oe);
  CLEAR (addinfo);
  CLEAR_STRUCT (u2ug_data);
  CLEAR_STRUCT (ug_prm);
  CLEAR (obj_exist);
  /*
    ALLOCATE user addinfo buffer.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CS_dwnld_usr_to_memory (user_memory,
                              users_in_memory,
                              user_memory_init,
                              user);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    SET user's addinfo keywords.
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get(envir_ptr->msg_admin_param.rss_name,
                         FUNC_ADDUSER,
                         bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  CLEAR (usr_prm);
  CLEAR (&ug_prm);
  CLEAR (&u2ug_data);
  CLEAR (usr_prm_in);
  CLEAR (obj_exist);
  handle= NULL;
  memcpy ((char *)usr_prm_in[0].user, (char *)user, sizeof(USER_typ));
 
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 13,
       "Element 1: %s", usr_prm[0].user);
  /*
    GET current user's details.
  */
  rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
  if (rc NE ESA_OK)
     goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
  CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_MANY_USERS,
		oe, MAX_GET, 1, usr_prm_in, handle, addinfo);
  rc=envir_ptr->func_ptr.gtusers_ptr(GET_MANY_USERS,
                           oe,MAX_GET,&actual_num,
	                       &have_more, &handle, 1, usr_prm_in, usr_prm,
                           addinfo, obj_exist,
                           &envir_ptr->msg_admin_param,
                           &envir_ptr->msg_err,
                           get_conn);  /* AC001 - CIQ#6 */
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
  if (rc EQ ESA_OK)
     CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
  if (apiprm.post EQ CS_YES)
  {
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
  } /* END - PosstScript is required */
  if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "->gtusers: Fail get users");
      goto cleanup;
  }
  /*
    EXIT - if someone already deleted the user.
  */
  if (obj_exist[0] EQ OBJ_NOT_EXIST) {
     ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
        "User=%s Not Exist",usr_prm[0].user);
    goto cleanup;
  }
  statist->usr_add++;
  statist->usr_ess++;
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES,
        "User=%s send to IIQ/IDN for ADD",usr_prm[0].user);
  /*
    ADD user ADD message to message buffer.
  */
  * amsg_rs= CS_add_rs_msg (FUNC_ADDUSER, &usr_prm[0], &oe_prm,
                            &ug_prm, &u2ug_data,
                            addinfo[0],
                            rs_amsg_len, rs_num_amsgs,
                           * amsg_rs, amsg_rs_ptr,
                            rs_amsg_len, rs_num_amsgs,
                           * amsg_rs, amsg_rs_ptr,
                            rs_amsg_len, rs_num_amsgs,
                           * amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
  if (* amsg_rs EQ NULL) {
    rc = ESA_FATAL;
    goto cleanup;
  }
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_usr_add function */
 
/****************************************************
 * Procedure Name: CS_sync_usr_check
 * Description   : users syncronization between ESS and RSS
 * Input         : rss      - RSS name
 *                 func_ptr - pointers to RSS-API functions
 *                 msg_hdr  - message header
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated in order to scan all ESS users, to find
 * users that were not handeled yet and to perform the following:
 * - IF the user exists in the local RSS with different checksum - to
 *   send update message on it.
 * - IF the user does not exit in the local RSS - to send delete request
 *   on it.
 * Please NOTE that the function is activated in two different cases:
 * 1) All the RSS users were scanned - in this case the function may
 *    find user to delete only (update in this case is bug although it
 *    is not checked).
 * 2) All ESS CARE (interesting) users were scanned - in this case the
 *    function completes the search on users that exists in both the
 *    ESS and RSS updates them (if there is a need) and delete the ESS
 *    users that do not exist on the RSS.
 *
 *********************************************************************/
 
ESA_RC CS_sync_usr_check (RSS_MSG_HDR_rec_typ  * msg_hdr,
                          USR_MEM_rec_ptr        usr_mem_ptr,
                          int                    usr_mem_num,
                          STATIST_rec_typ      * statist,
                          U2UG_MEM_rec_ptr       u2ug_mem_ptr,
                          int                    u2ug_mem_num)
{
  char fn[]="CS_sync_usr_check";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK, rc_usr;
  RSSAPIPRM_rec_typ     apiprm;
  MSG_typ             * msg= NULL;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
                         KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
                         KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
                         KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
                         KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, api= 0, filled_num_users= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  CHECKSUM_typ          checksum;
  int                   ii= 0, jj= 0, sw_upd= 0, sw_user= 0;
  USR_MEM_rec_ptr       usrmem= NULL;
  int                   usrmem_num= 0;
  int                   from_num_user= 0, num_check_users= 0;
 
  USR_MEM_rec_typ       def_usrmem;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
  char get_conn ='N';  /* AC001 - CIQ#6 */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name, FUNC_GTUSERS,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  /*
    CLEAR all temporary buffers.
  */
  CLEAR_STRUCT (def_usrmem);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (u2ug_data);
  CLEAR (usr_prm_in);
  CLEAR (usr_prm);
  CLEAR (oe);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  /*
    ALLOCATE additional info buffer for the checksum calculations.
  */
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE delete users message buffer.
  */
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    ALLOCATE update users message buffer.
  */
  rc= CSA_alloc ((char **)&umsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "umsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    BUILD addinfo for users checksum
  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  /*WS10082A addinfo[0]= info_ptr;
  CS_fill_key(addinfo,                                               */
  CS_fill_key(&info_ptr,                                   /*WS10082A*/
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  /*
     ALLOCATE buffer for the retrieved users addinfo.
  */
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *              */
              (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SCAN all ESS users - count the number of unhandled users.
  */
  for (usrmem_num= 0, num_check_users= 0;
       usrmem_num LT usr_mem_num AND rc EQ ESA_OK;
       usrmem_num++) {
    usrmem= usr_mem_ptr+ usrmem_num;
    if (usrmem->in_rss NE '1')
      num_check_users++;
  } /* END - FOR loop */
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
              "num_check_users=%d usr_mem_num=%d.",
			  num_check_users, usr_mem_num);
  /*
    BUILD msg. header for deleted users
  */
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_DEL);
  /*
    BUILD msg. header for updated users
  */
  umsg_rs= CS_reset_rs_msg(&rs_umsg_len ,
                           &rs_num_umsgs ,
                           umsg_rs ,
                           umsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_UPD);
  /*
    PROCESS all unhandled users:
  */
  for (from_num_user= 0, jj= 0;
       from_num_user LT num_check_users AND rc EQ ESA_OK; ) {
 
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
         "START: from_num_user=%d num_check_users=%d.",
		 from_num_user, num_check_users);
		
    CLEAR (usr_prm_in);
    /*
      FILL next portion of unhandled ESS users names.
    */
    rc= CS_sync_fill_checksum_users(usr_prm_in, &from_num_user,
		usr_mem_ptr, usr_mem_num, &filled_num_users);
    CLEAR (usr_prm);
    CLEAR (obj_exist);
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
         "from_num_user=%d num_check_users=%d filled_num_users=%d.",
		 from_num_user, num_check_users, filled_num_users);
    /*
      FILL the addinfo array.
    */
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds);*/
    /*
      RETRIEVE next portions of users that corresponds to current
      users list (exact names).
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
      goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_MANY_USERS,
		oe, MAX_GET, filled_num_users, usr_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtusers_ptr(GET_MANY_USERS,
                        oe,MAX_GET,&actual_num,
		                      &have_more,
                        &handle, filled_num_users, usr_prm_in,
                        usr_prm, addinfo, obj_exist,
                        &envir_ptr->msg_admin_param,
                        &envir_ptr->msg_err,
                        get_conn);  /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (apiprm.post EQ CS_YES)
	{
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 11,
                       "->gtusers: Fail get users");
      goto cleanup;
    }
    /*
      PROCESS the retrieved users:
    */
    for (ii= 0;
         ii LT actual_num AND rc EQ ESA_OK;
         ii++, jj++) {
      statist->tmp_num++;
      /*
         PROCESS users that doers not exist in RSS:
      */
      ess_cares= ESS_USER_CARE;
      rc_usr= CARE_int_usr_find (usr_prm[ii].user     ,
                                 usr_prm[ii].def_group,
                                 M_DWNLD_NAME_REGULAR ,
                                 &ess_cares           );
      if (rc_usr NE ESA_OK)
	  {
    	  if (strlen (usr_prm[ii].def_group) EQ 0)
	    	  rc_usr= ESA_ERR;
	      else
		{
		  ess_cares= ESS_GROUP_CARE;
		  rc_usr= CARE_int_ug_find (usr_prm[ii].def_group,
					    M_DWNLD_NAME_REGULAR ,
					    &ess_cares);
		}
	  }
      if (
		    (obj_exist[ii] EQ OBJ_NOT_EXIST)
		   OR
            (rc_usr NE ESA_OK)
		 )
	  {
        statist->usr_del++;
        /*
          MARK user for deletion
        */
        api= FUNC_DELUSER;
        /*
          MARK all urrent user's connections to be irrelevant.
        */
        rc = CS_sync_u2ug_checksum_irlvnt (envir_ptr->empty_ug,
                                           usr_prm[ii].user,
                                           u2ug_mem_ptr,
                                           u2ug_mem_num);
      } /* END - user does NOT exist in RSS */
      /*
        PROCESS existing users:
      */
      else
	  {
 
        CLEAR  (&def_usrmem);
        usrmem= &def_usrmem;
        /*
          FIND the user location in ESS users
        */
        usrmem_num= CS_sync_usr_checksum_find (usr_prm[ii].user,
                                       usr_mem_ptr, usr_mem_num);
        usrmem= usr_mem_ptr+ usrmem_num;
        /*
          CALCULATE the user's checksum.
        */
        rc= CS_sync_get_checksum ((char *)&usr_prm[ii], bufk,
                                  addinfo[ii], checksum);
        if (rc NE ESA_OK)
          goto cleanup;
        api= FUNC_UPDUSER;
        ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_DETAILES, "Checksum: IIQ/IDN %.*s rss %.*s.",
			CHECKSUM_LEN, usrmem->checksum, CHECKSUM_LEN, checksum);
      } /* END - user exists in RSS */
      /*
        PROCESS when UPDATE/DELETE message should be delivered:
      */
      if ((memcmp((char *)checksum, (char *)usrmem->checksum,
                  CHECKSUM_LEN) NE 0
           AND api NE FUNC_DELUSER) OR
          api EQ FUNC_DELUSER) {
        if (api EQ FUNC_UPDUSER) {
          statist->usr_upd++;
          statist->usr_ess++;
        }
        if (api EQ FUNC_DELUSER) {
          /*WS10082A addinfo[ii]->max_pairs= 0;                      */
          /*WS10082A addinfo[ii]->num_pairs= 0;                      */
          ADDINFO_empty(addinfo[ii]);                      /*WS10082A*/
        }
        /*
          ADD UPDATE/DELETE message to message buffer.
        */
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s send to IIQ/IDN for %s.",
			usr_prm[ii].user, (api EQ FUNC_DELUSER) ? "DELETE" : "UPDATE");
 
        msg= CS_add_rs_msg (api, &usr_prm[ii], &oe_prm,&ug_prm,
                            &u2ug_data, addinfo[ii],
                            &rs_msg_len, &rs_num_msgs,
                            msg_rs, msg_rs_ptr,
                            &rs_umsg_len, &rs_num_umsgs,
                            umsg_rs, umsg_rs_ptr,
                            &rs_amsg_len, &rs_num_amsgs,
                            amsg_rs, amsg_rs_ptr,
                            msg_hdr, &sw_user, &sw_upd,
                            &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
        if (sw_upd NE 0)
          umsg_rs= msg;
        else
          msg_rs= msg;
      } /* END - update/delete message should be delevered */
      else {
        api= 0;
        statist->usr_ess++;
        statist->usr_not_chg++;
        ESA_DIAG_printf(ESA_COMP_ACSSYNC, DIAG_DETAILES, "User %s Not send to ESS.",
			usr_prm[ii].user);
      }
 
    } /* END - FOR loop on retrieved users */
 
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
         "END: from_num_user=%d num_check_users=%d.",
		 from_num_user, num_check_users);
  } /* END - FOR loop on all unhandled ESS users */
  /*
    SEND remaining UPDATE/DELETE messages (if exists).
  */
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_umsgs NE 0) {
    rc = CS_send_cd_msg (&rs_umsg_len ,
                         &rs_num_umsgs ,
                         umsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
   if (handle NE NULL)
   {
      ESA_RC rcc;
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
      CS_DIAG_USER_IN (ESA_COMP_ACSSYNC, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
      rcc= envir_ptr->func_ptr.gtusers_ptr (GET_FREE_HANDLE_USERS,
                        oe,MAX_GET,&actual_num,
		                      &have_more,
                        &handle, filled_num_users, usr_prm_in,
                        usr_prm, addinfo, obj_exist,
                        &envir_ptr->msg_admin_param,
                        &envir_ptr->msg_err,
                        get_conn);  /* AC001 - CIQ#6 */
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rcc EQ ESA_OK)
         CS_DIAG_USER_OUT (ESA_COMP_ACSSYNC, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  if (rc EQ ESA_OK)
      rc= rc_logout;
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&umsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_sync_usr_check function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CS_sync_fill_checksum_users              *
*                                                             *
* Description      : Fill USER_PARAMS array with users , that *
*                    were not handled yet, from list of users *
*                    with checksum.                           *
* Return Value     : ESA_RC                                   *
*                                                             *
**************************************************************/
 
ESA_RC CS_sync_fill_checksum_users
                        (USER_PARAMS_rec_typ   user_prm_in[1],
                         int                 * from_num_user,
                         USR_MEM_rec_ptr       usr_mem_ptr,
                         int                   usr_mem_num,
                         short               * filled_num_users)
{
  USR_MEM_rec_ptr       usrmem= NULL;
  int                   jj;
  char                  fn[]="CS_sync_fill_checksum_users";
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 12,
         "from_num_user=%d usr_mem_num=%d.",
		 *from_num_user, usr_mem_num);
 
  for (*filled_num_users= 0, jj= (*from_num_user);
       (jj LT usr_mem_num) AND ((*filled_num_users) LT MAX_GET);
	   jj++)
  {
    usrmem= usr_mem_ptr+ jj;
    if (usrmem->in_rss NE '1')
	{ /* HANDELED user is marked with '1' */
       ESA_DIAG_printf (ESA_COMP_ACSSYNC, 15,
         "%d usr=%s.", jj, (char *)usrmem);
       strcpy (user_prm_in[*filled_num_users].user,
              (char *)usrmem);
       (*filled_num_users)++;
	   (*from_num_user)++;
	   usrmem->in_rss = '1';
    }
  }
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 12,
         "from_num_user=%d filled_num_users=%d.",
		 *from_num_user, * filled_num_users);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
 
} /* END - CS_sync_fill_checksum_users function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CS_dwnld_sync_start                       *
*                                                             *
* Description      : Update RSSOFLI table after sync  activity*
*                                                             *
* Input            : rss- rss name                            *
*                    dwnld_sync_date - date from to RSS change *
*                                relevant for interceptor     *
*                    dwnld_sync_time - time from to RSS change *
*                                relevant for interceptor     *
*                                                             *
* Return Value     : ESA_RC                                   *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function is responsible to update the relevant RSS entry,
* in the RSS offline file - with the new offline interceptor's
* start date and time.
***************************************************************/
 
ESA_RC CS_dwnld_sync_start (char      dwnld_sync_method,
                            DATE_typ  dwnld_sync_date,
                            TIME_typ  dwnld_sync_time)
{
  char                  fn[]="CS_dwnld_sync_start";
  ESA_RC                rc= ESA_OK;
  int                   ii= 0, jj = 0, rsstbl_num= 0;
  RSSTBL_rec_typ      * rsstbl = NULL;
  RSS_typ               rss_id;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  CLEAR (rss_id);
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, 13,
      "rss %s date %s time %s.",
       envir_ptr->msg_admin_param.rss_name,
	   dwnld_sync_date,
	   dwnld_sync_time);
 
  /*
    LOAD (read) the rss offline file into the rss table.
  */
  rc= tbl_load (&rsstbl, &rsstbl_num);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SEARCH the rss table for current rss.
  */
  for(jj = 0, ii= 0; ii LT rsstbl_num; ii++) {
    memcpy ((char *)rss_id, (char *)rsstbl[ii].rss, sizeof(RSS_typ));
	rss_id[RSS_NAME_LEN]= '\0';
    strtok (rss_id, " ");
    if (My_stricmp (rss_id,
		        envir_ptr->msg_admin_param.rss_name) NE 0)
      continue;
    /*
      UPDATE the current RSS' date and time (in table).
    */
    memcpy ((char *)rsstbl[ii].sync_start_date,
		    (char *)dwnld_sync_date, DATE_LEN);
    memcpy ((char *)rsstbl[ii].sync_start_time,
		    (char *)dwnld_sync_time, TIME_LEN);
	if (dwnld_sync_method NE M_DWNLD_SYNC_METHOD_UNDEFINED)
       rsstbl[ii].dwnld_sync_method = dwnld_sync_method;
    jj = 1;
  }
 
  if (jj EQ 0) {
    rc= ESA_KEY_NOT_FOUND;
    CTSAMSG_print (ERR_CS_RSS_NOTFND,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   envir_ptr->msg_admin_param.rss_name,
				   "any",
				   envir_ptr->file_rssofli);
    goto cleanup;
  }
  /*
    REWRITE the rss offline file details.
  */
  rc= tbl_rebuild (rsstbl, rsstbl_num);
  if (rc NE ESA_OK)
      goto cleanup;
 
  cleanup:
  if (rsstbl NE NULL)
  {
     CSA_free ((char **)&rsstbl);
     rsstbl = NULL;
  }
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_dwnld_sync_start function */
 
/****************************************************
 * Procedure Name: CS_sync_get_checksum
 * Description   : To calculate checksum
 *                    - build string for checksum
 *                    - call 'crc' get checksum
 * Input         : user_param
 *               : ug_param
 *               : u2ug_param
 *               : RSSAPIKWD *bufk
 *                 addinfo
 * Input/Output  : checksum
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function calculates USER , GROUP or CONNECTION checksum for
 * SYNCHRONIZATION with the ESS.
 * The function receives the object's parameters along with the addinfo
 * as it was retrieved from the RSS - and a buffer containing a list
 * of all object keywords - entity and addinfo - including the keyword
 * type. The function builds an array of the entity keywords along with
 * their values from the entity structure according to the entity type.
 * The entity checksum is calculated in loop - the entity keywords
 * array is scanned - every CHECKSUMMABLE entity info or addinfo VALUE
 * is enterd to the checksum calculation , after translating from
 * ebcdic to ascii (if such translation is needed).
 *********************************************************************/
 
ESA_RC CS_sync_get_checksum (void              * check_param,
                             RSSAPIKWD_rec_typ * bufk,
                             ADDINFO_rec_typ   * addinfo,
                             CHECKSUM_typ        checksum)
{
  char fn[]="CS_sync_get_checksum";
  ESA_RC                rc= ESA_OK;
  int                   ii= 9, jj= 0;
  int                   contin= 0, last= 1;
  void                * handle= NULL;
 
  CONNECT_PARAMS_rec_typ  * conn_param;
  USER_PARAMS_rec_typ     * user_param;
  OE_PARAMS_rec_typ       * oe_param;
  UG_PARAMS_rec_typ       * ug_param;
  U2UG_PARAMS_rec_typ     * u2ug_param;
  char                      str_check[MAX_RSS_ADDINFO_VAL_LEN+ 1];
  char                      str_check_ascii[MAX_RSS_ADDINFO_VAL_LEN+ 1];
  ENVIRONMENT_rec_typ     * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter  (ESA_COMP_MORE, DIAG_COMMON, fn);
  /*
    INITIALIZE entity info buffer
  */
  CS_entity_info_init ();
  /*
    FILL in the entity info buffer with keywords and values
    according to the requested operations: USER , UG , CONNECTION.
  */
  if (bufk->api EQ FUNC_ADDUSER)
  {
    user_param= (USER_PARAMS_rec_typ *)check_param;
    ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
                     "user %s def group %s.",
                     user_param->user, user_param->def_group);
    rc= CS_entity_info_add (STRUC_USER_REC,user_param);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (bufk->api EQ FUNC_ADDUG)
  {
    ug_param= (UG_PARAMS_rec_typ *)check_param;
    ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
                     "group %s parent group %s.",
                     ug_param->group, ug_param->parent_group);
    rc= CS_entity_info_add (STRUC_UG_REC, ug_param);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (bufk->api EQ FUNC_ADDOE)
  {
    oe_param= (OE_PARAMS_rec_typ *)check_param;
    ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
             "oe %s parent %s attr %d.",
             oe_param->oe, oe_param->parent, (int)oe_param->attr);
    rc= CS_entity_info_add (STRUC_OE_REC, oe_param);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (bufk->api EQ FUNC_ADDU2UG)
  {
    conn_param= (CONNECT_PARAMS_rec_typ *)check_param;
    u2ug_param= &conn_param->u2ug_prm;
 
    ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
       "conn: user %s group %s %d attr %d def group %s.",
                     u2ug_param->user, u2ug_param->group,
                     (int)u2ug_param->u2ug_admin_data,
                     (int)u2ug_param->u2ug_attr_data,
                     u2ug_param->def_group);
    rc= CS_entity_info_add (STRUC_U2UG_REC,u2ug_param);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  /*
    SCAN all keywords in the input keywords buffer (this buffer was
    prepared by the callingt function, according to the required
    operation, and it conatins a list of ALL keywords and their
    types. The current function should relate ONLY TO KEYWORDS
    THAT THEIR TYPE STATES THAT THEY DO PARTICIPATE IN THE OBJECT
    CHECKSUM CALCULATIONS.
  */
  for (jj= 0; jj LT bufk->num_keywords; jj++) {
    /*
      PROCESS checksummable entity keyword:
    */
    if (bufk->kwd[jj].keyword_type EQ KWD_FOR_ENTITY_CHECK) {
      /*
        LOCATE the required keyword among the pre-prepared entity
        info keywords and values.
      */
      for (ii= 0; ii LT envir_ptr->entity_info[0].num_pairs; ii++) {
        /*
          IGNORE keywords that do not match the current keyword.
        */
       if(bufk->kwd[jj].keylen NE
           envir_ptr->entity_info[0].pair[ii].keylen)
          continue;
        if (memcmp ((char *)bufk->kwd[jj].keyword,
                    (char *)envir_ptr->entity_info[0].pair[ii].keyword,
                    (unsigned)bufk->kwd[jj].keylen) NE 0)
          continue;
        /*
          COPY current entity VALUE to checksum string.
        */
        memset ((char *)str_check, '\0', sizeof (str_check));
        memcpy ((char *)str_check,
                (char *)envir_ptr->entity_info[0].pair[ii].value,
                (unsigned)envir_ptr->entity_info[0].pair[ii].vallen);
 
        strcpy (str_check_ascii,str_check);
 
        ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
                         "Checksum string /%s/ (%d).",
                         str_check_ascii, strlen(str_check_ascii));
/* for MVS */
        /*
          TRANSLATE ebcdic string to ascii string.
        */
        ebc2asc (str_check, str_check_ascii,(int)strlen(str_check));
 /* MVS */
        /*
          ADD current value to checksum calculations.
        */
        ChkSumL (str_check_ascii, (int)strlen(str_check_ascii),
                 contin, &handle, checksum);
        break;
 
      } /* END - FOR loop on entity keywords array. */
 
    } /* END - checksummable entity info keyword */
    /*
      PROCESS checksummable addinfo keyword:
    */
    if (
        (bufk->kwd[jj].keyword_type EQ KWD_FOR_ADDINFO_1A_CHECK)
            OR
        (bufk->kwd[jj].keyword_type EQ KWD_FOR_ADDINFO_1B_CHECK)
            OR
        (bufk->kwd[jj].keyword_type EQ KWD_FOR_ADDINFO_2A_CHECK)
            OR
        (bufk->kwd[jj].keyword_type EQ KWD_FOR_ADDINFO_2B_CHECK)
        ) {
      /*
        LOCATE the addinfo keyword among the input addinfo buffer.
      */
      for (ii= 0; ii LT addinfo->num_pairs; ii++) {
        /*
          IGNORE addinfo keywords that do not match requested keyword.
        */
        if (bufk->kwd[jj].keylen NE addinfo->pair[ii].keylen)
          continue;
        if (memcmp ((char *)bufk->kwd[jj].keyword,
                    (char *)addinfo->pair[ii].keyword,
           (unsigned)bufk->kwd[jj].keylen) NE 0)
          continue;
        /*
          SAVE addinfo VALUE.
        */
        memset ((char *)str_check, '\0', sizeof (str_check));
        memcpy ((char *)str_check, (char *)addinfo->pair[ii].value,
                (unsigned)addinfo->pair[ii].vallen);
 
        strcpy (str_check_ascii,str_check);
 
        ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
                         "Checksum string /%s/ (%d).",
                         str_check_ascii, strlen(str_check_ascii));
/* for MVS */
        /*
          TRANSLATE the addinfo value from ebcdic to ascii.
        */
        ebc2asc (str_check,str_check_ascii,(int)strlen(str_check));
 /* MVS */
        /*
          ADD current addinfo value to object's checksum.
        */
        ChkSumL (str_check_ascii, (int)strlen(str_check_ascii),
                 contin, &handle, checksum);
        break;
 
      } /* END - FOR loop on addinfo keywords */
 
    } /* END - checksummable addinfo keyword */
 
  } /* END - FOR loop on all object keywords */
 
  /* Clear string so that last call to ChkSumL will not add anything
   * to the checksum
   */
  CLEAR (str_check_ascii);
  /*
     TERMINATE object checksum calculations - return the final checksum
  */
  ChkSumL (str_check_ascii, (int)strlen(str_check_ascii),
           last, &handle, checksum);
 
  ESA_DIAG_printf (ESA_COMP_MORE, DIAG_MORE,
                   "checksum %.8s", checksum);
  cleanup:
  ESA_DIAG_exit  (ESA_COMP_MORE, DIAG_COMMON, fn, ESA_OK);
  return (rc);
 
} /* END - CS_sync_get_checksum function */
 
/****************************************************
 * Procedure Name: CS_sync_oe_checksum
 * Description   : Load containers and their's checksum to the memory
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function handles a "Default Container Checksum" message. It
 * scans all the users in the message, verfies the container uniquness
 * and adds it to the containers + checksums list in the memory.
 *********************************************************************/
 
ESA_RC CS_sync_oe_checksum (MSG_typ              * msg_ptr,
                            STATIST_rec_typ      * statist,
                            OE_MEM_rec_ptr       * oe_mem_ptr,
                            int                  * oe_mem_num)
{
  char fn[]="CS_sync_oe_checksum";
  ESA_RC                rc= ESA_OK;
  unsigned short        ii= 0, kk= 0;
  size_t                jj= 0;
  int                   oemem_num= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  char                  checksum[CHECKSUM_LEN+ 1];
  TRAN_rec_typ          tran;
  OE_MEM_rec_typ      * TempOePtr= NULL; /*[TMP_OES_NUM];*/
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
  rc= CSA_alloc ((char **)&TempOePtr,
                   STRUC_OE_CHECK_REC,
                   sizeof (OE_MEM_rec_typ),
                   TMP_OES_NUM,
                   fn,
                   "TempOe & checksums");
  if (rc NE ESA_OK)
	  goto cleanup;
  /*
    CLEAR all temporary structures.
  */
  memset (TempOePtr, '\0', sizeof (OE_MEM_rec_typ) * TMP_OES_NUM);
  CLEAR_STRUCT (tran);
  CLEAR (checksum);
  /*
    GET the general message header.
  */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
  /*
    GET the RSS message header (= number of internal messages).
  */
  msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
  if (msg_ptr EQ NULL) {
    rc = ESA_ERR;
    goto cleanup;
  }
  /*
    PROCESS all internal messages (containers).
  */
  for (kk =0, jj= 0 ; kk LT num_msgs AND rc EQ ESA_OK; kk++) {
    /*
      GET the internal message header.
    */
    msg_ptr = CS_get_singl_msg(&len_msg, &tran, msg_ptr);
    if (msg_ptr EQ NULL) {
      rc= ESA_ERR;
      goto cleanup;
    }
    /*
      GET current container's name.
    */
    msg_ptr = CS_get_fld (TempOePtr[jj].oe,
                          msg_ptr,
                          envir_ptr->rss_limits.max_oe_len,
                          C_OE_ID);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      GET the current container's checksum.
    */
    msg_ptr = CS_sync_get_ess_checksum (msg_ptr,
		                                TempOePtr[jj].checksum);
    if (msg_ptr EQ NULL) {
      rc = ESA_ERR;
      goto cleanup;
    }
    /*
      IGNORE the current container if it is NULL or NEWLINE.
    */
    if (*TempOePtr[jj].oe EQ '\0' OR *TempOePtr[jj].oe EQ '\n')
      continue;
    /*
      VERIFY the current user container's uniqueness among the other
      containers in temporary buffer.
    */
    for (ii= 0; ii LT (unsigned short)jj; ii++)
      if (strcmp (TempOePtr[ii].oe, TempOePtr[jj].oe) EQ 0)
        break;
    if (ii LT (unsigned short)jj)
      continue;
    /*
      VERIFY the current container name's uniquness among the
      containers in global memory.
    */
    oemem_num= CS_sync_oe_checksum_find (TempOePtr[jj].oe, *oe_mem_ptr,
                                         *oe_mem_num);
    if (oemem_num LT *oe_mem_num)
      continue;
 
    if (ESA_DIAG_get_debug_level(ESA_COMP_ACSSYNC) GE 16) {
      memcpy ((char *)checksum, (char *)TempOePtr[jj].checksum,
		      CHECKSUM_LEN);
      ESA_DIAG_printf (ESA_COMP_ACSSYNC, 17,
                     "oe=%s checksum=%s.", TempOePtr[jj].oe, checksum);
    }
    statist->oe_chk++;
    statist->tmp_num++;
    jj++;
    /*
      PROCESS when the temporary arry of containers is full:
    */
    if (jj EQ TMP_OES_NUM- 1) {
      /*
        COPY all containers from temporary array to memory.
      */
      rc= CS_sync_oe_checksum_to_mem ((char *)TempOePtr, oe_mem_ptr,
                                      oe_mem_num, (int)jj);
      memset (TempOePtr, '\0', sizeof (OE_MEM_rec_typ) * TMP_OES_NUM);
      jj= 0;
    }  /* END - Temporary array is full */
 
	CS_dwnld_event (statist, STEP_OE_CHKSUM, PROCESS_FN, rc);
 
  } /* END FOR loop on all internal messages */
  /*
    PROCESS when there are containers in the temporary array:
  */
  if (jj NE 0) {
    /*
      COPY all containers from temporary array to memory.
    */
      rc= CS_sync_oe_checksum_to_mem ((char *)TempOePtr, oe_mem_ptr,
                                      oe_mem_num, (int)jj);
      memset (TempOePtr, '\0', sizeof (OE_MEM_rec_typ) * TMP_OES_NUM);
      jj= 0;
  }
 
  cleanup:
 
  CS_dwnld_event (statist, STEP_OE_CHKSUM, END_FN, rc);
  CSA_free ((char **)&TempOePtr);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END -  CS_sync_oe_checksum function*/
 
 
/****************************************************
 * Procedure Name: CS_get_sync_params
 * Description   : Get method and lists parameters
 * Input         : msg_ptr
 * Output        : dwnld_sync_method
 *               : sync_user_list
 *               : sync_group_list
 *               : sync_conn_list
 *               : sync_oe_list
 * Return Value  :
 * Comments      :ver 2.0.1.1
 * Scope         :
 ****************************************************/
 
ESA_RC CS_get_sync_params (MSG_typ          * msg_ptr,
                           char             * dwnld_sync_method,
                           char             * sync_user_list,
                           char             * sync_group_list,
                           char             * sync_conn_list,
                           char             * sync_oe_list)
{
  char                  fn[]="CS_get_sync_params";
  ESA_RC                rc= ESA_OK;
  char MethodStr[20]="", ListOE[25]="", ListUG[25]="", ListUSR[25]="", ListDUG[25]="";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
  /* First message of dwnld service */
  msg_ptr = CS_get_aplic_msg(msg_ptr);
 
  if (
		  (*msg_ptr NE M_DWNLD_SYNC_METHOD_ALL_RSS)
		AND
		  (*msg_ptr NE M_DWNLD_SYNC_METHOD_LIST)
		AND
          (*msg_ptr NE M_DWNLD_SYNC_METHOD_SUBTREE)
	   )
  {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_SYNC_METHOD);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
		  "SYNC (%d): mode %c rc %d.",
		  envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
  }
  *dwnld_sync_method= *msg_ptr;
  if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_SUBTREE)
     strcpy (MethodStr, "SUBTREE");
  else if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_LIST)
     strcpy (MethodStr, "LIST");
  else
     strcpy (MethodStr, "ALL RSS");
 
  msg_ptr++;
 
  if (
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
		AND
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
		AND
          (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
	   )
  {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
		  "SYNC (%d): mode %c rc %d.",
		  envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
  }
  *sync_oe_list= *msg_ptr;
  if (*sync_oe_list EQ M_DWNLD_SYNC_LIST_NOT)
     strcpy (ListOE, "EMPTY OE LIST");
  else if (*sync_oe_list EQ M_DWNLD_SYNC_LIST_ALL)
     strcpy (ListOE, "ALL OEs");
  else if (*sync_oe_list EQ M_DWNLD_SYNC_LIST_YES)
     strcpy (ListOE, "LIST of OEs");
  msg_ptr++;
 
  if (
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
		AND
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
		AND
          (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
	   )
  {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
		  "SYNC (%d): mode %c rc %d.",
		  envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
  }
  *sync_group_list= *msg_ptr;
  if (*sync_group_list EQ M_DWNLD_SYNC_LIST_NOT)
     strcpy (ListDUG, "EMPTY DEFAULT GROUP LIST");
  else if (*sync_group_list EQ M_DWNLD_SYNC_LIST_ALL)
     strcpy (ListDUG, "ALL DEFAULT GROUPS");
  else if (*sync_group_list EQ M_DWNLD_SYNC_LIST_YES)
     strcpy (ListDUG, "LIST of DEFAULT GROUPS");
  msg_ptr++;
 
  if (
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
		AND
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
		AND
          (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
	   )
  {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
		  "SYNC (%d): mode %c rc %d.",
		  envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
  }
  *sync_user_list= *msg_ptr;
  if (*sync_user_list EQ M_DWNLD_SYNC_LIST_NOT)
     strcpy (ListUSR, "EMPTY USER LIST");
  else if (*sync_user_list EQ M_DWNLD_SYNC_LIST_ALL)
     strcpy (ListUSR, "ALL USERS");
  else if (*sync_user_list EQ M_DWNLD_SYNC_LIST_YES)
     strcpy (ListUSR, "LIST of USERS");
  msg_ptr++;
 
  if (
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
		AND
		  (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
		AND
          (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
	   )
  {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
		  "SYNC (%d): mode %c rc %d.",
		  envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
  }
  *sync_conn_list= *msg_ptr;
  if (*sync_conn_list EQ M_DWNLD_SYNC_LIST_NOT)
     strcpy (ListUG, "EMPTY GROUP LIST");
  else if (*sync_conn_list EQ M_DWNLD_SYNC_LIST_ALL)
     strcpy (ListUG, "ALL GROUPS");
  else if (*sync_conn_list EQ M_DWNLD_SYNC_LIST_YES)
     strcpy (ListUG, "LIST of GROUPS");
  msg_ptr++;
 
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC, "*************");
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
        "*****> Global Sync for RSS %s %s with %s (%c) %s (%c) %s (%c) %s (%c).",
        envir_ptr->interest[envir_ptr->rss_num].rss,
		envir_ptr->interest[envir_ptr->rss_num].rss_type,
		ListOE, *sync_oe_list, ListDUG, *sync_group_list,
		ListUSR, *sync_user_list, ListUG, *sync_conn_list);
 
/* Sync. type (partial OR full) */
  if (envir_ptr->dwnld_sync_type EQ DWNLD_SYNC_UNDEFINED) /* ??? */
  {
    if (
		  (*msg_ptr NE M_SYNC_FULL)
		AND
		  (*msg_ptr NE M_SYNC_PARTIAL)
	   )
    {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_SYNC_TYPE);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
		  "SYNC (%d): type %c rc %d.",
		  envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
    }
    if (*msg_ptr EQ M_SYNC_FULL)
       envir_ptr->dwnld_sync_type= SYNC_FULL;
    if (*msg_ptr EQ M_SYNC_PARTIAL)
       envir_ptr->dwnld_sync_type= SYNC_PARTIAL;
 
    ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC,
        "*****> Global Sync for RSS %s %s is %s (%c %d) by %s Metod.",
        envir_ptr->interest[envir_ptr->rss_num].rss,
		envir_ptr->interest[envir_ptr->rss_num].rss_type,
		(*msg_ptr EQ M_SYNC_FULL) ? "FULL" : "PARTIAL",
		*msg_ptr, (int)envir_ptr->dwnld_sync_type, MethodStr);
  }
  ESA_DIAG_printf (ESA_COMP_ACSSYNC, DIAG_BASIC, "*************");
 
 
  ESA_DIAG_printf(ESA_COMP_ACSSYNC, 15,
	"SYNC (%d): type=%c mode=%c list:ug=%c us=%c cn=%c oe=%c rc %d.",
    envir_ptr->rss_num, envir_ptr->dwnld_sync_type, *dwnld_sync_method,
    *sync_group_list, *sync_user_list, *sync_conn_list,
    *sync_oe_list, (int)rc);
 
	if (rc EQ ESA_OK)
       envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method =
	        *dwnld_sync_method;
 
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
  return(rc);
 
}
 
 
 
 
/****************************************************
 * Procedure Name: CS_send_receive
 * Description   : Send 0 messages To receive if ABORT Global sync
 * Input         : msg_ptr
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
 
/****************************************************
 * Procedure Name: CS_sync_lists_cmp
 * Description   : Compare Current with Prevous lists
 * Input         :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_sync_lists_cmp (char              dwnld_sync_method,
                          char              sync_user_list,
                          char              sync_group_list,
                          char              sync_conn_list,
                          char              sync_oe_list)
{
   ESA_RC                 rc= ESA_OK;
   char                   fn[]="CS_sync_lists_cmp";
   ENVIRONMENT_rec_typ  * envir_ptr;
   RSS_INTEREST_rec_typ * interest;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
   rc= CS_dwnld_sync_inc (dwnld_sync_method,
                          sync_user_list,
                          sync_group_list,
                          sync_conn_list,
                          sync_oe_list);
   if (rc NE ESA_OK)
       goto cleanup;
 
   rc= CARE_interesting_list_check ();
   if (rc NE ESA_OK)
   {
      interest= envir_ptr->interest+ envir_ptr->rss_num;
      CTSAMSG_print (MSG_SYNC_FAIL_MISMATCH,
                     envir_ptr->msg_admin_param.ctsamsg_handle,
                     NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name);
      CTSAMSG_print (MSG_RSS_DWNLD_CRITERIA,
                     envir_ptr->msg_admin_param.ctsamsg_handle,
                     NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest);
      CARE_list_oe  (interest->pre_oes_ptr,interest->pre_num_oes);
      CARE_list_ug  (interest->pre_ugs_ptr,interest->pre_num_ugs);
      CARE_list_u2ug(interest->pre_u2ugs_ptr,interest->pre_num_u2ugs);
      CARE_list_usr (interest->pre_users_ptr,interest->pre_num_users);
   }
   CTSAMSG_print (MSG_ESS_DWNLD_CRITERIA,
                  envir_ptr->msg_admin_param.ctsamsg_handle,
                  NULL,
                  envir_ptr->msg_admin_param.ctsamsg_dest);
   CARE_list_oe  (envir_ptr->oes_ptr,   envir_ptr->num_oes);
   CARE_list_ug  (envir_ptr->ugs_ptr,   envir_ptr->num_ugs);
   CARE_list_u2ug(envir_ptr->u2ugs_ptr, envir_ptr->num_u2ugs);
   CARE_list_usr (envir_ptr->users_ptr, envir_ptr->num_users);
 
cleanup:
 
   CARE_inc_oe_free ();
   CARE_inc_ug_free ();
   CARE_inc_usr_free ();
   CARE_inc_u2ug_free ();
 
   ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);
   return (rc);
}
 
/* 27/9/99 Aviw */
 
/****************************************************
 * Procedure Name: CS_cmpr_u2ug_entry
 * Description   : Compare user + group in u2ug entry of
 *                 connection checksums array (from ESS)
 * Input         :
 * Return Value  : As strcmp returns.
 * Comments      :
 * Scope         :
 ****************************************************/
 
static int CS_cmpr_u2ug_entry(const void *elm1 , const void *elm2)
{
 
   int  rc;
   /*502839 char fn[]="CS_cmpr_u2ug_entry"; */
   rc = strcmp( ((U2UG_MEM_rec_ptr)elm1)->user ,
	            ((U2UG_MEM_rec_ptr)elm2)->user);
 
   if (rc EQ 0)
      rc = strcmp( ((U2UG_MEM_rec_ptr)elm1)->ug ,
	               ((U2UG_MEM_rec_ptr)elm2)->ug);
   return (rc);
}
 
 
/* BS2402 */
/****************************************************
 * Procedure Name: CS_is_sorted
 * Description   : Check if connection checksums array
 *                 is sorted
 * Input         :
 * Return Value  : TRUE - sorted, FALSE - not sorted
 * Comments      :
 * Scope         :
 ****************************************************/
static int CS_is_sorted(void *first, size_t nument)
{
 
   U2UG_MEM_rec_ptr pt1, pt2;
   int              rfc, is_sorted, i;
   /* IS10095 ESA_RC           rc = ESA_OK; */
   char fn[]="CS_is_sorted";
 
   ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
   /* If less than two entries, array is sorted */
   if (nument LT 2)
   {
     is_sorted = TRUE;
     goto cleanup;
   }
   /* Initialize pointers to 1st and 2nd entries */
   pt1=first;
   pt2=pt1+1;
 
   /* Scan checksums array */
   for (i=0; i LT (int)(nument-1); i++)
   {
     /* Compare current entry to next one */
     rfc = CS_cmpr_u2ug_entry(pt1, pt2);
 
     /* current entry bigger than next ... not sorted */
     if (rfc GT 0)
     {
       is_sorted = FALSE;
       goto cleanup;
     }
     /* Move to next entry */
     pt1=pt2;
     pt2++;
   };
   is_sorted = TRUE;
 
cleanup:
   /* IS10095 ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc);*/
   /* Return the real returned rc  IS10095 */
   ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, (ESA_RC) is_sorted);
 
   /* Array is sorted */
   return (is_sorted);
}
 
/* 30/1/01 Aviw */
 
/****************************************************
 * Procedure Name: CS_cmpr_ug_entry
 * Description   : Compare group in ug entry of
 *                 groups checksums array (from ESS)
 * Input         :
 * Return Value  : As strcmp returns.
 * Comments      :
 * Scope         :
 ****************************************************/
 
static int CS_cmpr_ug_entry(const void *elm1 , const void *elm2)
{
   int  rc;
   rc = strcmp(((UG_MEM_rec_ptr)elm1)->ug,
	            ((UG_MEM_rec_ptr)elm2)->ug);
   return (rc);
}
 
 
/****************************************************
 * Procedure Name: CS_ug_is_sorted
 * Description   : Check if groups checksums array
 *                 is sorted
 * Input         :
 * Return Value  : TRUE - sorted, FALSE - not sorted
 * Comments      :
 * Scope         :
 ****************************************************/
static int CS_ug_is_sorted(void *first, size_t nument)
{
 
   UG_MEM_rec_ptr pt1, pt2;
   int              rfc, ug_is_sorted, i;
   /* IS10095 ESA_RC           rc = ESA_OK; */
   char fn[]="CS_ug_is_sorted";
 
   ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
   /* If less than two entries, array is sorted */
   if (nument LT 2)
   {
       ug_is_sorted = TRUE;
       goto cleanup;
   }
   /* Initialize pointers to 1st and 2nd entries */
   pt1=first;
   pt2=pt1+1;
 
   /* Scan checksums array */
   for (i=0; i LT (int)(nument-1); i++)
   {
     /* Compare current entry to next one */
     rfc = CS_cmpr_ug_entry(pt1, pt2);
 
     /* current entry bigger than next ... not sorted */
     if (rfc GT 0)
     {
       ug_is_sorted = FALSE;
       goto cleanup;
     }
     /* Move to next entry */
     pt1=pt2;
     pt2++;
   };
   ug_is_sorted = TRUE;
 
cleanup:
 
   /* IS10095 ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc); */
   /* Return the real returned rc  IS10095 */
   ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, (ESA_RC) ug_is_sorted);
   /* Array is sorted */
   return (ug_is_sorted);
}
 
/****************************************************
 * Procedure Name: CS_cmpr_usr_entry
 * Description   : Compare users entry of
 *                 users checksums array (from ESS)
 * Input         :
 * Return Value  : As strcmp returns.
 * Comments      :
 * Scope         :
 ****************************************************/
 
static int CS_cmpr_usr_entry(const void *elm1 , const void *elm2)
{
   int  rc;
   rc = strcmp(((USR_MEM_rec_ptr)elm1)->user,
	            ((USR_MEM_rec_ptr)elm2)->user);
 
   return (rc);
}
 
 
/****************************************************
 * Procedure Name: CS_usr_is_sorted
 * Description   : Check if users checksums array
 *                 is sorted
 * Input         :
 * Return Value  : TRUE - sorted, FALSE - not sorted
 * Comments      :
 * Scope         :
 ****************************************************/
static int CS_usr_is_sorted(void *first, size_t nument)
{
 
   USR_MEM_rec_ptr pt1, pt2;
   int              rfc, usr_is_sorted, i;
   /* IS10095 ESA_RC           rc = ESA_OK; */
   char fn[]="CS_usr_is_sorted";
 
   ESA_DIAG_enter (ESA_COMP_ACSSYNC, DIAG_COMMON, fn);
 
   /* If less than two entries, array is sorted */
   if (nument LT 2)
   {
      usr_is_sorted = TRUE;
      goto cleanup;
   }
 
   /* Initialize pointers to 1st and 2nd entries */
   pt1=first;
   pt2=pt1+1;
 
   /* Scan checksums array */
   for (i=0; i LT (int)(nument-1); i++)
   {
     /* Compare current entry to next one */
     rfc = CS_cmpr_usr_entry(pt1, pt2);
 
     /* current entry bigger than next ... not sorted */
     if (rfc GT 0)
     {
       usr_is_sorted = FALSE;
       goto cleanup;
     }
 
     /* Move to next entry */
     pt1=pt2;
     pt2++;
   };
   usr_is_sorted = TRUE;
 
cleanup:
 
   /* ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, rc); IS0315 */
   /* Return the real returned rc  IS0315 */
   ESA_DIAG_exit (ESA_COMP_ACSSYNC, DIAG_COMMON, fn, (ESA_RC) usr_is_sorted);
   /* Array is sorted */
   return (usr_is_sorted);
}
 
