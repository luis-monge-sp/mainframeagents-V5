/****************************************************
 * Title           : API Batch program.
 * File Name       : batmain.c
 * Author          : AJK
 * Creation Date   : 11-May-94
 * Description     : Main for test for all API functions
 * Assumptions and
 *   Considerations:
 * $Author:   leonid_s  $
 * $Workfile:   BATMAIN.C  $
 * $Revision:   1.17  $
 * $Log:   //eagle1/versions/300/test/src/BATMAIN.C_v  $
 *
 *    Rev 1.17   Dec 14 1998 16:29:48   leonid_s
 * Changed OE to Container in operation descr
 *
 *    Rev 1.16   Aug 17 1998 11:52:18   ajk
 * Fixed SCCSID for Unix 'what' command
 *
 *    Rev 1.15   Aug 04 1998 14:46:02   leonid_s
 *
 *
 *    Rev 1.14   Apr 22 1998 14:56:06   ajk
 * shortened long lines
 *
 *    Rev 1.13   Apr 22 1998 12:39:12   ajk
 * fixes for Doron
 *
 *    Rev 1.12   Apr 20 1998 14:22:20   leonid_s
 *
 *
 *    Rev 1.11   Sep 16 1997 10:08:50   ajk
 * fixed SCCS id string,again
 *
 *    Rev 1.9   Sep 16 1997 09:57:54   ajk
 * unix-2-dos
 *
 *    Rev 1.8   Sep 15 1997 14:57:02   ajk
 * cosmetics plus changed admin menu entries order
 *
 *    Rev 1.7   Aug 11 1997 10:36:48   ajk
 * Changed version to 2.1.0
 *
 *    Rev 1.6   Jul 24 1997 11:36:56   leonid_s
 *
 *
 *    Rev 1.5   Jul 24 1997 09:01:50   leonid_s
 *     SCCSID("@(#)batmain.c \
 *
 *    Rev 1.4   Jul 23 1997 15:48:20   leonid_s
 * Some lines longer than 72 columns
 *
 *    Rev 1.2   Jul 15 1997 14:33:02   leonid_s
 *****************************************************/
/***********************************************************************
 * Mod.ID  Who      When         Description
 * =====================================================================
 * IMH001  Ian H.   17/9/03      Add support for CheckAndPrintVersion
 * IMH002  Ian H.   16/11/03     Thread-safe code (ERRNO)
 * SAS2IBMT SeligT  16/11/16     SAS/C to IBM C Conversion Project and
 *                               re-design / re-write of BATxxxx rtns
 * BS10062  SeligT  29/08/17     Handle storage allocation errors
 * IS10157  SeligT  17/09/17     Allocate Several Arrays Correctly
 * BS10068  SeligT  17/10/17     CTSBATCH Should Ignore Sequence Numbers
 * BS10076  SeligT  11/12/17     Organize Connector Locking Functions
 *                               and Structures - The change to this
 *                               module is not related to this locking
 *                               issue. It is a simple syntax error
 *                               which causes a S0C4 in trim_blanks.
 *                               Also, every return from this module to
 *                               the caller will now be with a return
 *                               code which comes from max_rc.
 * WS10070 KailasP  16/04/18     Compile only due to change in
 *                               SA_AGENT_VERSION.
 * WS10078KG KailasP 04/05/20    Compile only due to change in
 *                               SA_AGENT_VERSION.
 * WS10079K KailasP  31/12/20    Compile only due to change in
 *                               SA_AGENT_VERSION.
 * WS10080  KailasP  09/07/21    Support MSGSIZE Greater than 32K
 *                               ***only for compile***
 **********************************************************************/
 
#define  THIS_IS_MAIN
#include "globs.h"
 
#include ERRNO     /* IMH001 */
#include STDIO
#include STDLIB
 
#include STRING
 
#include ESA_API
#include ESA_INIT
#include ESA_ADMIN
#include ESA_VER
 
#include "BATUTLS.h"
 
/****************************************************
 ***************************************************/
 
static char dashing [] = "================================";
static char logo_1  [] = "*** Control-SA Batch Program ***";
static char logo_2  [] = SA_AGENT_NAME " " SA_AGENT_VERSION " - " _CTSF_ " ";
 
/****************************************************
 ***************************************************/
 
static void pr_logo (void)
{
   printf ("%s\n", dashing);
   printf ("%s\n", logo_1);
   printf ("%s\n", logo_2);
   printf ("%s\n", dashing);
} /* pr_logo */
 
/****************************************************
 The following routine trims leading and trailing
 blanks in place.  Do not call this routine if the
 entire input line is or may be all spaces.
 ***************************************************/
 
void trim_blanks (char * const str)
{
    char * begin = str;
    char * end   = str;
    if (strcmp (str, NULL) EQ 0)                          /* BS10076 */
    {                                                     /* BS10076 */
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,                  /* BS10076 */
               "trim_blanks cannot operate on NULL input");/*BS10076 */
      printf("trim_blanks cannot operate on NULL input\n");/*BS10076 */
      return;                                             /* BS10076 */
    }                                                     /* BS10076 */
    while (isspace(*begin)) ++begin;
    char * s = begin;
    while (*s NE '\0') if (!isspace(*s++)) end = s;
    *end = '\0';
    const int dist = end - begin;
    if (begin > str && dist > 0) memmove(str, begin, dist + 1);
}
 
/****************************************************
 The following routine trims leading blanks and returns
 a resultant string.  It can be called when the entire
 input line is spaces.
 ***************************************************/
char * trim_leading (char * s)
{
    /* trim leading blanks */
    while (isspace(s[0])) { s++; }
    return s;
} /* trim_leading */
 
 
/****************************************************
 * Procedure Name: main
 * Description   : Invoke all API tests
 * Input         : Input parameter: DDIN(ddn),DDOUT(ddn)
 * Output        : None
 * Return Value  : Always 0
 * Side Effects  : System security is compromised
 * Scope         : Autonomy areas only
 ***************************************************/
 
int main (int argc, char ** argv)
{
   int                  k, opt;
   int                  slots = 0;                        /* IS10157 */
   int                  size = 0;                         /* IS10157 */
   int                  keep_on_looping = 1;
   ESA_RC               rc, rc1;
   PASSWD_typ           admin_upass  = "";
   ENVIRONMENT_rec_typ * envir_ptr;
   char                 ddn_with[50]="";                  /* SAS2IBMT */
   char               * from;
   char               * to;
   static char         func[]="BATMAIN_main";
 
   rssname_passed = 0;
   rsstype_passed = 0;
   admnunm_passed = 0;
   have_request   = 0;
   reached_EOF    = 0;
   max_rc         = 0;
 
   strcpy (admin_uname, "");
   strcpy (admin_name, "");
   strcpy (admin_group, "");
   strcpy (rssname, "");
   strcpy (xrss_type, NATIVE_RSS);
 
/* IMH001 start */
   rc = CheckAndPrintVersion (argc, argv);
   if (rc EQ ESA_OK)
       goto exit2;
 
   rc= ESA_OK;
/* IMH001 end */
 
   /* Extract the DDIN ddname and DDOUT ddname from the input PARM.
      Both of these input parameters are optional.  If they are not
      specified, the DDIN ddname will be set to SYSIN and the DDOUT
      ddname will be set to SYSPRINT.
      The proper format is: DDIN(ddname),DDOUT(ddname) but the code
      below will also work correctly if a blank is used instead of
      a comma between both input parameters.                        */
 
   strcpy(tst_in, "SYSIN");              /* DDIN default SYSIN      */
   strcpy(tst_out, "SYSPRINT");          /* DDOUT default SYSPRINT  */
/* printf("argc = %d\n", argc);                                     */
   for (k = 1; k LT argc; k++) {         /* Skip argv[0] - progname */
   /* printf("k = %d argv[k]= %s\n", k, argv[k]);                   */
      from = strstr(argv[k], "DDIN(");   /* look for DDIN(          */
      if (from) {
             /* printf("The ddin substring is: %s\n", from);        */
                to = strchr(from+5,')'); /* look for close paren    */
                if (to) {
                /* printf("The close character is: %s\n", to);      */
                   strncpy(tst_in,from+5,to-(from+5));
                   tst_in[to-(from+5)]='\0';
                /* printf("The ddname is: %s\n", tst_in);           */
                }
                else printf(" DDIN file name error\n");
      }
      from = strstr(argv[k], "DDOUT(");  /* look for DDOUT(         */
      if (from) {
             /* printf("The ddout substring is: %s\n", from);       */
                to = strchr(from+6,')'); /* look for close paren    */
                if (to) {
                /* printf("The close character is: %s\n", to);      */
                   strncpy(tst_out,from+6,to-(from+6));
                   tst_out[to-(from+6)]='\0';
                /* printf("The ddname is: %s\n", tst_out);          */
                }
                else printf(" DDOUT file name error\n");
      }
   }
 
   /* open sysin and sysprint files */
 
   memset(ddn_with, 0, sizeof(ddn_with));
   strcpy(ddn_with,"DD:");
   strcat(ddn_with, tst_in);
/* printf("About to open fdin file: |%s|\n", ddn_with);              */
   fdin  = fopen (ddn_with,  "rb,type=record");
   if (NOT fdin) {
      perror ("Open IN file");
      rc = ESA_FATAL;
      max_rc = ESA_FATAL;                                 /* BS10076 */
      goto cleanup;
   }
/* printf("Input file opened successfully\n");                       */
   if (strcmp(tst_out, "SYSPRINT") EQ 0) goto skpopen;
   /* When trying to open the SYSPRINT file, I got this error:
      Open OUT file: EDC5045I The operation attempted could not
                     be performed because the file was open.
      That's why we will bypass the open of the SYSPRINT file.       */
   memset(ddn_with, 0, sizeof(ddn_with));
   strcpy(ddn_with,"DD:");
   strcat(ddn_with, tst_out);
/* printf("About to open fdout file: |%s|\n", ddn_with);            */
   fdout  = fopen (ddn_with,  "wb,recfm=*,type=record");
   if (NOT fdout) {
      perror ("Open OUT file");
      rc = ESA_FATAL;
      max_rc = ESA_FATAL;                                 /* BS10076 */
      goto cleanup;
   }
   skpopen:
 
   /* In order to complete initialization, we will call the read_line
      routine. This routine will bypass all initial comment and blank
      lines in the SYSIN file and will (hopefully) encounter the :ENV
      lines. These lines must be the first real lines in the SYSIN
      file.  They will (hopefully) contain the RSS_type (mandatory),
      RSS_name (mandatory), Admin_uname (mandatory), and Admin_group
      (optional) parameters.  Once these parameters are obtained from
      the SYSIN file, we continue with initialization.               */
 
   pr_logo ();
/* printf("About to read the :ENV lines\n");                         */
   opt = read_line();
/* printf("read_line returned option number %d\n", opt);             */
   if (opt EQ 1) {
      rc = env_rtn();         /* go process the :ENV lines           */
      if (rc EQ ESA_FATAL) {               /* error encountered      */
         max_rc = ESA_FATAL;                              /* BS10076 */
         goto cleanup;                     /* error encountered      */
      }
      if (rc EQ ESA_OK) {
         if (have_request) goto cont_init; /* continue initializat'n */
         if (reached_EOF)  goto cleanup;   /* EOF encountered        */
      }
   }
   if ((opt EQ 2) || (opt EQ 3) || (opt EQ 4)) {
      /* other :request line, request parameter line (RPL),
         or ADDINFO / undefined line                                 */
      printf(":ENV lines must be the first lines in SYSIN\n");
      max_rc = ESA_FATAL;                                 /* BS10076 */
      goto cleanup;
   }
   if (opt EQ 6) {
      /* I/O error encountered                                       */
      printf("I/O error when attempting to read :ENV lines\n");
      max_rc = ESA_FATAL;                                 /* BS10076 */
      goto cleanup;
   }
   if (opt EQ 7) goto cleanup;  /* EOF encountered                */
 
   cont_init:
   if (NOT(rsstype_passed) ||
       NOT(rssname_passed) ||
       NOT(admnunm_passed)) {
      printf("RSS_type, RSS_name, and Admin_uname are mandatory parameters\n");
      max_rc = ESA_FATAL;                                 /* BS10076 */
      goto cleanup;
   }
 
   rc = localinit (argc, argv);
 
   if (rc EQ ESA_OK) init_done = 1;
   else {
      if (fderr)         /* don't print if stream was never opened */
         printf ("localinit() failed, rc=%ld\n", rc);
         max_rc = rc;                                     /* BS10076 */
      goto cleanup;
   }
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   /* Call a routine to copy the rss keywords table.  This will enable
      us to get the ADDINFO type (1A, 1B, 2A, 2B) when we are passed
      a keyword name by the user (via SYSIN file).  These four
      statements MAY have to be moved to after the localinit call.   */
 
   envir_ptr->keywrds = NULL;
   envir_ptr->kwd_num = 0;
 
   rc = get_keywords ();
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Just returned from get_keywords. rc=%d", rc);
 
   if (rc NE ESA_OK) {
      max_rc = rc;                                        /* BS10076 */
      goto cleanup;
   }
 
   /* * * * * * * IS10157 start * * * * * * */
   /* We will now allocate five arrays which are based on the size in
      envir_ptr->kwd_num.                                            */
 
   slots = envir_ptr->kwd_num + 10;
   size = slots * sizeof(KEYWORD_typ);
 
   filt_kwd = calloc (slots, sizeof(KEYWORD_typ));
 
   if (NOT filt_kwd) {
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      printf ("Memory allocation failed for filt_kwd, size %d\n",
              size);
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      return ESA_FATAL;
   }
 
   in_kwd = calloc (slots, sizeof(KEYWORD_typ));
 
   if (NOT in_kwd) {
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      printf ("Memory allocation failed for in_kwd, size %d\n",
              size);
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      return ESA_FATAL;
   }
 
   out_kwd = calloc (slots, sizeof(KEYWORD_typ));
 
   if (NOT out_kwd) {
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      printf ("Memory allocation failed for out_kwd, size %d\n",
              size);
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      return ESA_FATAL;
   }
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
       "Allocated 3 kwd arrays. slots=%d size=%d", slots, size);
 
   size = slots * sizeof(VALUE_typ);
 
   filt_val = calloc (slots, sizeof(VALUE_typ));
 
   if (NOT filt_val) {
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      printf ("Memory allocation failed for filt_val, size %d\n",
              size);
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      return ESA_FATAL;
   }
 
   in_val = calloc (slots, sizeof(VALUE_typ));
 
   if (NOT in_val) {
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      printf ("Memory allocation failed for in_val, size %d\n",
              size);
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      return ESA_FATAL;
   }
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
       "Allocated 2 val arrays. slots=%d size=%d", slots, size);
 
   /* * * * * * * IS10157 end * * * * * * */
 
   /*
    *   Get Login parameters
    */
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Admin_uname before call to admin_x_req = %s",
                   admin_uname);
   admin_ptr->cs_func.rssprm_get_ptr (rssname,
                     ADMIN_USER_REQUEST,
                     sizeof (admin_lg_req), admin_lg_req);
 
   admin_ptr->cs_func.rssprm_get_ptr (rssname,
                     ADMIN_FILE_REQUEST,
                     sizeof (admin_pw_req), admin_pw_req);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Admin_uname after call to admin_x_req = %s",
                   admin_uname);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "After rssprm_get_ptr: admin_lg_req=%c admin_pw_req=%c",
                   admin_lg_req[0], admin_pw_req[0]);
 
   if (admin_lg_req[0] EQ 'Y') {
      /*
       * Get ADMIN parameter only if login required
       */
 
      if (strlen(admin_uname) EQ 0) {
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "About to call rssprm_get_ptr with %s",
                         admin_uname);
         rc = admin_ptr->cs_func.rssprm_get_ptr (rssname,
                                  DEFAULT_ADMINISTRATOR,
                                  sizeof (admin_uname), admin_uname);
         if (rc NE ESA_OK) {
            ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                            "Call to rssprm_get_ptr failed");
            max_rc = rc;                                  /* BS10076 */
            goto cleanup;
         }
         else {
            strcpy (admin_ptr->admin_uname, admin_uname);
            strcpy (admin_name, admin_uname);
            ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                            "DEFAULT_ADMINISTRATOR = %s",
                            admin_uname);
         }
      }
      else {
         /*
          *  Set admin user name
          */
         strcpy (admin_ptr->admin_uname, admin_uname);
         strcpy (admin_name, admin_uname);
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "admin_uname was set to %s", admin_uname);
      }
   }
   else if (strlen (admin_uname) GT 0) {
      admin_lg_req[0] = 'Y';
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "admin_lg_req now set to %c", admin_lg_req[0]);
      strcpy (admin_ptr->admin_uname, admin_uname);
      strcpy (admin_name, admin_uname);
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "admin_uname was set to %s", admin_uname);
   }
   if ((admin_lg_req[0] EQ 'N') AND (strlen (admin_uname) EQ 0)) {
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "Admin_uname must be specified when ADMIN_USER_REQ=N");
      max_rc = ESA_FATAL;                                 /* BS10076 */
      goto cleanup;
   }
 
   admin_pass[0] = NULL_CHAR;
 
  /*
   *  Check whether password required and obtained
   */
 
   if ((admin_lg_req[0] EQ 'Y') AND (admin_pw_req[0] EQ 'Y'))
      if (strlen (admin_upass) GT 0)
         strcpy (admin_pass, admin_upass);
 
   /*
    *  Determine whether need LOGIN_FIRST
    */
 
   if (NOT first_login_done) {
      need_login = 0;
      if ((admin_lg_req[0] EQ 'Y') AND (strlen (admin_name) GT 0)
          AND (admin_pw_req[0] NE 'Y' ) )
         need_login = 1;
 
      if (admin_lg_req[0] EQ 'Y' AND admin_pw_req[0] EQ 'Y'   AND
          (strlen (admin_pass) GT 0) AND
          (strlen (admin_name) GT 0))
         need_login = 1;
   }
 
   if (need_login) {
      need_login = 0;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "doing login with: rssname=%s     admin_name=%s",
                      rssname, admin_name);
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "                  admin_group=%s admin_pass=%s",
                      admin_group, admin_pass);
      rc = (*func_struct.rss_login_ptr) (rssname,
                                         admin_name, admin_group,
                                         admin_pass,
                                         LOGIN_MODE_FIRST,
                                         &cs_handle, admin_ptr,
                                         err_ptr);
      if (rc NE ESA_OK) {
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "call to rss_login_ptr failed with rc = %d",
                         rc);
         max_rc = rc;                                     /* BS10076 */
         goto cleanup;
      }
      else {
         admin_ptr->login_handle = cs_handle;
         first_login_done = 1;
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "call to rss_login_ptr ended with ESA_OK");
      }
   }
 
   /* set up fields needed for main loop                             */
 
   req = (REQUEST_rec_typ *) calloc (sizeof (REQUEST_rec_typ), 1);
 
   if (NOT req) {                                         /* BS10062 */
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      printf ("Memory allocation failed for REQUEST_rec_typ, size %d\n",
              sizeof (REQUEST_rec_typ));
      printf ("* * * * * * * * * * Fatal Error * * * * * * * * * *\n");
      return ESA_FATAL;
   }
 
 
   /* main_loop:
      call read_line (read a line - retcode tells us what it is) and
      use the return code to branch to the correct routine. Here are
      the return codes from read_line:
         1 - :ENV request line encountered.  This is an error.  We
             should have processed the :ENV lines already.
         2 - Other :request line encountered.  We will call the
             req_rtn routine to process the :request line.
         3 - Request parameter line (RPL) encountered.  This is an
             internal or input data error.  RPL lines should not be
             encountered in the main_loop.
         4 - ADDINFO (or undefined) line encountered.  This is an
             internal or input data error.  ADDINFO lines should not be
             encountered in the main_loop.
         5 - Comment or blank line encountered.  We will never get this
             because read_line bypasses all of comment / blank lines.
         6 - I/O error encountered. We display an error message and
             go to the cleanup routine.
         7 - EOF encountered.  We branch to the cleanup routine which
             frees and closes what needs to be freed and closed, and we
             then return to the caller.
      end of main_loop                                               */
 
   main_loop:
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "About to enter the main_loop");
   while ((keep_on_looping) && NOT(reached_EOF))  {
      opt = read_line();
      switch (opt) {
         case 1:            /* :ENV request line                   */
            keep_on_looping = 0;
            printf(":ENV request lines already processed - error\n");
            break;
         case 2:            /* other :request line                 */
            rc = req_rtn(); /* go process other :request line      */
            if (rc NE ESA_OK) keep_on_looping = 0;
            ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                            "Just returned from req_rtn with rc = %d", rc);
            break;
         case 3:            /* request parameter line (RPL)        */
            keep_on_looping = 0;
            printf("RPLs encountered in main_loop - error\n");
            break;
         case 4:            /* ADDINFO line or undefined line      */
            keep_on_looping = 0;
            printf("ADDINFO lines encountered in main_loop - error\n");
            break;
      /* case 5:              comment or blank line               */
      /*    break;                                                */
         case 6:           /* I/O error                           */
            keep_on_looping = 0;
            printf("I/O error encountered in main_loop\n");
            break;
         case 7:           /* EOF encountered                     */
            keep_on_looping = 0;
            printf("reached EOF in main_loop\n");
            break;
         default:
            keep_on_looping = 0;
            printf("undefined option in main_loop - error\n");
            break;
      } /* switch */
   } /* while */
 
   /* cleanup routine:
      Free data areas, close both files, and return to the caller  */
 
   cleanup:
 
   if (init_done)
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "In cleanup routine");
   if ( adm_load_done ) {
      /* term the encryption */
      ENC_term (&envir_ptr->enc_internal_handle);
      /*WS10082K - We dont maintain list of admins  **
      /@ free ADM stuff @/
       *WS10082K* ADM_free();    */
   }
 
   if (first_login_done)
      (*func_struct.rss_logout_ptr) (rssname, admin_name,
                                     admin_group,
                                     LOGOUT_MODE_LAST,
                                     &cs_handle,
                                     admin_ptr, err_ptr) ;
 
   if (init_done)
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, max_rc);
 
   rc1 = localterm (max_rc);
 
   exit2:
 
   if (init_done)
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Returning to caller with max_rc = %d", max_rc);
 
   return max_rc;
 
} /* main */
 
/****************************************************
 * Procedure Name: req_rtn
 * Description   : Process all :request lines. These
 *               : are the :request lines processed:
 *               : :LISTACL                  - type 1
 *               : :LISTCONN                 - type 1
 *               : :LISTGROUP                - type 1
 *               : :LISTRES                  - type 1
 *               : :LISTUSER                 - type 1
 *               : :ADDUSER=userid           - type 2
 *               : :CHGPWD=userid            - type 2
 *               : :DELUSER=userid           - type 2
 *               : :DISABLEUSER=userid       - type 2
 *               : :ENABLEUSER=userid        - type 2
 *               : :UNLOCKUSER=userid        - type 2
 *               : :UPDUSER=userid           - type 2
 *               : :ADDGROUP=groupid         - type 3
 *               : :DELGROUP=groupid         - type 3
 *               : :UPDGROUP=groupid         - type 3
 *               : :ADDCONN=(userid,groupid) - type 4
 *               : :DELCONN=(userid,groupid) - type 4
 *               : :UPDCONN=(userid,groupid) - type 4
 *               : This routine calls the parse_process_request_line
 *               : routine which parses and processes the
 *               : request line, determines which one of the
 *               : request routines to call, and calls it.
 * Input         : None
 * Output        : None
 * Input/Output  :
 * Return Value  : Standard return code
 * Side Effects  :
 * Scope         : Internal To API Test Program
 ***************************************************/
 
   ESA_RC req_rtn (void) {
 
   ESA_RC              rc            = ESA_OK;
   static char         func []       = "BATMAIN_req_rtn";
   char                rtn_name [20] = "";
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   rc = parse_process_request_line();
 
   if (rc NE ESA_OK) /* BS10062 return ESA_FATAL; */
   /* * * * BS10062 start * * * */
   {
      if (rc GT max_rc) {
         max_rc = rc;
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "New max_rc value = %d", max_rc);
         ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, ESA_FATAL);
         return ESA_FATAL;
      }
   }
   /* * * * BS10062 end * * * */
 
   switch(req->req_typ) {
     case LISTACL:
        rc = listacl_rtn();
        strcpy(rtn_name, "listacl_rtn");
        break;
     case LISTCONN:
        rc = listconn_rtn();
        strcpy(rtn_name, "listconn_rtn");
        break;
     case LISTGROUP:
        rc = listgroup_rtn();
        strcpy(rtn_name, "listgroup_rtn");
        break;
     case LISTUSER:
        rc = listuser_rtn();
        strcpy(rtn_name, "listuser_rtn");
        break;
     case ADDUSER:
        rc = adduser_rtn();
        strcpy(rtn_name, "adduser_rtn");
        break;
     case CHGPWD:
        rc = chgpwd_rtn();
        strcpy(rtn_name, "chgpwd_rtn");
        break;
     case DELUSER:
        rc = deluser_rtn();
        strcpy(rtn_name, "deluser_rtn");
        break;
     case DISABLEUSER:
        rc = disableuser_rtn();
        strcpy(rtn_name, "disableuser_rtn");
        break;
     case ENABLEUSER:
        rc = enableuser_rtn();
        strcpy(rtn_name, "enableuser_rtn");
        break;
     case UNLOCKUSER:
        rc = unlockuser_rtn();
        strcpy(rtn_name, "unlockuser_rtn");
        break;
     case UPDUSER:
        rc = upduser_rtn();
        strcpy(rtn_name, "upduser_rtn");
        break;
     case ADDGROUP:
        rc = addgroup_rtn();
        strcpy(rtn_name, "addgroup_rtn");
        break;
     case DELGROUP:
        rc = delgroup_rtn();
        strcpy(rtn_name, "delgroup_rtn");
        break;
     case UPDGROUP:
        rc = updgroup_rtn();
        strcpy(rtn_name, "updgroup_rtn");
        break;
     case ADDCONN:
        rc = addconn_rtn();
        strcpy(rtn_name, "addconn_rtn");
        break;
     case DELCONN:
        rc = delconn_rtn();
        strcpy(rtn_name, "delconn_rtn");
        break;
     case UPDCONN:
        rc = updconn_rtn();
        strcpy(rtn_name, "updconn_rtn");
        break;
   } /* switch */
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Just returned from %s with rc = %d", rtn_name, rc);
 
   if (rc GT max_rc) {
      max_rc = rc;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "New max_rc value = %d", max_rc);
      rc = ESA_OK;
   }
 
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, rc);
 
   return ESA_OK;
 
   }
 
 
 
 
 
/****************************************************
 * Procedure Name: read_line
 * Description   : Read a SYSIN line into SYSIN_buffer and return a
 *               : return code which represents the line identifier.
 * Input         : none
 * Output        : see return code
 *               : Also SYSIN_buffer contains the next SYSIN line.
 *               : This is a global field.
 * Input/Output  :
 * Return Value  : return code with line identifier:
 *               : 1 - :ENV request line
 *               : 2 - other :request line
 *               : 3 - request parameter line (RPL)
 *               : 4 - ADDINFO line or undefined
 *               : 5 - comment / blank line (These are not returned.)
 *               : 6 - I/O error
 *               : 7 - EOF
 * Side Effects  :
 * Scope         : local
 ***************************************************/
 
int read_line (void)
{
   int                 num     = 0;
   int                 ret     = 0;
   char              * trimmed_buffer;
   static char         func [] = "BATMAIN_read_line";
 
   if (init_done)
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   if (have_request) goto read_line_parse;
   read_a_line:
   memset(SYSIN_buffer, 0, sizeof(SYSIN_buffer));
   num = fread(SYSIN_buffer, 1, (sizeof(SYSIN_buffer)-1), fdin);
   /* BS10068 SYSIN_buffer[80] = NULL_CHAR;                          */
   SYSIN_buffer[72] = NULL_CHAR;                          /* BS10068 */
 
   if (feof(fdin)) goto encountered_eof;
   else if (ferror(fdin)) goto encountered_ioerror;
   if (init_done)
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "The %d byte line just read = |%s|",
                   num, SYSIN_buffer);
 
   read_line_parse:
   if (init_done)
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "The line that will now be processed = |%s|",
                   SYSIN_buffer);
   have_request = 0;
   if (strncmp (SYSIN_buffer, "*", 1) EQ 0) {
      if (init_done)
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Encountered a comment line");
      goto encountered_comment;
   }
   trimmed_buffer = trim_leading (SYSIN_buffer);
   if (strlen(trimmed_buffer) EQ 0) {
      if (init_done)
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Encountered a blank line");
      goto encountered_allblanks;
   }
   strcpy(SYSIN_buffer, trimmed_buffer);
   if (strncmp (SYSIN_buffer, ":", 1) EQ 0) goto encountered_request;
   else goto encountered_rplorai;
 
   encountered_request:  /* is it :ENV or other valid request?       */
      if (init_done)
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Encountered a :request line");
      if (strncmp (SYSIN_buffer, ":ENV ", 5) EQ 0) goto ret_1;
      else goto ret_2;   /* this request was not yet validated       */
 
   encountered_rplorai:  /* is it valid RPL or ADDINFO?              */
      if (init_done)
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Encountered an RPL or ADDINFO line");
      if ((strncmp (SYSIN_buffer, "USER.", 5) EQ 0)     ||
          (strncmp (SYSIN_buffer, "GROUP.", 6) EQ 0)    ||
          (strncmp (SYSIN_buffer, "CONN.", 5) EQ 0)     ||
          (strncmp (SYSIN_buffer, "FILTER.", 7) EQ 0)   ||
          (strncmp (SYSIN_buffer, "RSS_", 4) EQ 0)      ||
          (strncmp (SYSIN_buffer, "GET_", 4) EQ 0)      ||
          (strncmp (SYSIN_buffer, "Get_", 4) EQ 0)      ||
          (strncmp (SYSIN_buffer, "ADMIN_", 6) EQ 0)    ||
          (strncmp (SYSIN_buffer, "Admin_", 6) EQ 0)) goto ret_3;
      goto ret_4;        /* this input line was not validated yet    */
 
   encountered_comment:
   encountered_allblanks:
      goto read_a_line;
 
   encountered_ioerror:
      if (init_done)
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Incurred an I/O error");
      goto ret_6;
 
   encountered_eof:
      if (init_done)
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Just reached EOF");
      reached_EOF = 1;
      goto ret_7;
 
   ret_1:
      ret = 1;
      goto exit;
 
   ret_2:
      ret = 2;
      goto exit;
 
   ret_3:
      ret = 3;
      goto exit;
 
   ret_4:
      ret = 4;
      goto exit;
 
   ret_6:
      ret = 6;
      goto exit;
 
   ret_7:
      ret = 7;
      goto exit;
 
   exit:
      if (init_done)
      ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, ret);
      return ret;
 
} /* read_line */
 
/****************************************************
 * Procedure Name: env_rtn
 * Description   : Process the :ENV lines (RSS_type, RSS_name, and
 *               : Admin_uname are mandatory. Admin_group is optional.)
 * Input         : none
 * Output        : see return code
 *               : Also SYSIN_buffer contains the next SYSIN line.
 *               : This is a global field.
 * Input/Output  :
 * Return Value  : RSA_OK or ESA_FATAL
 * Side Effects  :
 * Scope         : local
 ***************************************************/
 
   ESA_RC env_rtn (void) {
   ESA_RC rc = ESA_OK;
   int    opt;
   char * token;
   char * trimmed_token;
   static char         func [] = "BATMAIN_env_rtn";
 
/* ESA_DIAG_enter(ESA_COMP_BATCH, 1, func); */
 
      for (;;)  {
         opt = read_line();
         switch (opt) {
            case 1:           /* :ENV request line                   */
            case 4:           /* ADDINFO line or undefined line      */
               printf("unexpected input line - error\n");
               return ESA_FATAL;
            case 2:           /* other :request line                 */
               have_request = 1;
               goto exit0;
            case 3:           /* request parameter line (RPL)        */
               token = strtok(SYSIN_buffer, "=");
               trim_blanks (token);
               if ((strncmp (token, "RSS_name", 8) EQ 0)      ||
                   (strncmp (token, "RSS_NAME", 8) EQ 0))
                                                      goto env_name;
               if ((strncmp (token, "RSS_type", 8) EQ 0)      ||
                   (strncmp (token, "RSS_TYPE", 8) EQ 0))
                                                      goto env_type;
               if ((strncmp (token, "Admin_uname", 11) EQ 0)  ||
                   (strncmp (token, "ADMIN_UNAME", 11) EQ 0))
                                                      goto env_uname;
               if ((strncmp (token, "Admin_group", 11) EQ 0)  ||
                   (strncmp (token, "ADMIN_GROUP", 11) EQ 0))
                                                      goto env_group;
 
               printf("unexpected input line - error\n");
               return ESA_FATAL;
 
               env_name:
                  token = strtok(NULL, "=");
                  trim_blanks (token);
                  if (token) {
                     strcpy(rssname, token);
                     rssname_passed = 1;
                  /* ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                                     "rssname = %s", rssname); */
                  }
                  else {
                         printf("no RSS_name specified - error\n");
                         return ESA_FATAL;
                       }
                  break;
 
               env_type:
                  token = strtok(NULL, "=");
                  trim_blanks (token);
                  if (token) {
                  /* strcpy(xrss_type, token); */
                     memset(xrss_type, 0X00, sizeof(xrss_type));
                  /* bs10068 memcpy(xrss_type, token, 4);            */
                     strcpy(xrss_type, token);            /* BS10068 */
                     rsstype_passed = 1;
                     ESA_DIAG_printf(ESA_COMP_BATCH, 1,   /* BS10068 */
                                     "xrss_type = |%s|", xrss_type);
                  }
                  else {
                         printf("no RSS_type specified - error\n");
                         return ESA_FATAL;
                       }
                  if ((strcmp (xrss_type, "RACF") EQ 0) ||
                      (strcmp (xrss_type, "ACF2") EQ 0) ||
                      (strcmp (xrss_type, "TSS")  EQ 0)) break;
                  printf("invalid RSS_type |%s| specified - error\n",
                         xrss_type);
                  return ESA_FATAL;
 
               env_uname:
                  token = strtok(NULL, "=");
                  trim_blanks (token);
                  if (token) {
                     strcpy(admin_name, token);
                     strcpy(admin_uname, token);
                     admnunm_passed = 1;
                  /* ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                                     "admin_name and uname = %s",
                                     admin_uname);      */
                  }
                  else {
                         printf("no Admin_uname specified - error\n");
                         return ESA_FATAL;
                       }
                  break;
 
               env_group:
                  token = strtok(NULL, "=");
                  trim_blanks (token);
                  if (token) strcpy(admin_group, token);
                  else {
                         printf("no Admin_group specified - error\n");
                         return ESA_FATAL;
                       }
               /* ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                                  "admin_group = %s", admin_group);  */
                  break;
 
         /* case 5:           /* comment or blank line               */
         /*    break;                                                */
 
            case 6:           /* I/O error                           */
               printf("I/O error encountered in env_rtn\n");
               return ESA_FATAL;
 
            case 7:           /* EOF encountered                     */
               reached_EOF = 1;
               goto exit0;
 
            default:
               printf("undefined switch (opt) in env_rtn - error\n");
               return ESA_FATAL;
         } /* switch */
      } /* for */
 
   exit0:
      rc = ESA_OK;
   /* ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, rc); */
      return ESA_OK;
 
   } /* env_rtn */
 
 
/****************************************************
 * Procedure Name: nuke_req_details
 * Description   : Clear values in request struct array
 * Input         : array of request details
 * Output        :
 * Input/Output  :
 * Return Value  : None
 * Side Effects  :
 * Scope         : Internal To API Test Program
 ***************************************************/
 
void nuke_req_details (void)
{
 
   static char         func [] = "BATMAIN_nuke_req_details";
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
      req->req_typ                = 0;
      req->request[0]             = NULL_CHAR;
      req->request_type           = 0;
      req->userid[0]              = NULL_CHAR;
      req->groupid[0]             = NULL_CHAR;
      req->dflt_grpname[0]        = NULL_CHAR;
      req->drop_keepold[0]        = NULL_CHAR;
      strcpy (req->get_conn, "N");
      req->password[0]            = NULL_CHAR;
      req->passwd_life            = PASS_LIFE_IGNORED;
      req->rev_status_dis         = USER_STAT_IGNORED;
      req->user_admin             = USER_ADM_IGNORED;
      req->par_oe[0]              = NULL_CHAR;
      req->grp_par_oe[0]          = NULL_CHAR;
      req->rev_status_ena         = USER_STAT_IGNORED;
      req->rev_status_unl         = USER_STAT_IGNORED;
      req->par_grp[0]             = NULL_CHAR;
      req->u2ug_admin             = U2UG_ADM_IGNORED;
      memset(req->groups_in, 0, sizeof(req->groups_in));
      req->num_groups_in          = 0;
      memset(req->users_in, 0, sizeof(req->users_in));
      req->num_users_in           = 0;
      req->resource[0]            = NULL_CHAR;
      req->restype[0]             = NULL_CHAR;
 
      ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, ESA_OK);
      return;
 
} /* nuke_req_details */
 
 
/****************************************************
 * Procedure Name: parse_process_request_line
 * Description   : Parse and process the request line.
 * Input         : none but SYSIN_buffer is holding the current
 *               : input line. SYSIN_buffer is a global field.
 * Output        : none but the request table is partially completed
 *               : with information found on the request line
 * Input/Output  :
 * Return Value  : return code:
 *               :   ESA_OK
 *               :   ESA_FATAL
 * Side Effects  :
 * Scope         : local
 ***************************************************/
 
   ESA_RC parse_process_request_line (void) {
   ESA_RC rc = ESA_OK;
   char * token;
   char   ididid [30];
   static char         func [] = "BATMAIN_parse_process_request_line";
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   nuke_req_details();
   filter_userid_groupid_encountered = 0;
   addinfo_keyword_encountered = 0;
   filter_conn_encountered  = 0;
   filter_group_encountered = 0;
   filter_user_encountered  = 0;
   filt_i = 0;
   in_i   = 0;
   out_i  = 0;
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "SYSIN_buffer = |%s|", SYSIN_buffer);
   token = strtok(SYSIN_buffer, "=,");
   trim_blanks (token);
   strcpy(req->request, token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "|%s|", req->request);
   if (strncmp(req->request, ":LISTACL", 8)     EQ 0)
   {
     req->request_type = 1;
     req->req_typ = LISTACL;
   }
   if (strncmp(req->request, ":LISTCONN", 9)                EQ 0)
   {
     req->request_type = 1;
     req->req_typ = LISTCONN;
   }
   if (strncmp(req->request, ":LISTGROUP", 10)              EQ 0)
   {
     req->request_type = 1;
     req->req_typ = LISTGROUP;
   }
   if (strncmp(req->request, ":LISTRES", 8)                 EQ 0)
   {
     req->request_type = 1;
     req->req_typ = LISTRES;
   }
   if (strncmp(req->request, ":LISTUSER", 9)                EQ 0)
   {
     req->request_type = 1;
     req->req_typ = LISTUSER;
   }
   if (strncmp(req->request, ":ADDUSER", 8)                 EQ 0)
   {
     req->request_type = 2;
     req->req_typ = ADDUSER;
   }
   if (strncmp(req->request, ":CHGPWD", 7)                  EQ 0)
   {
     req->request_type = 2;
     req->req_typ = CHGPWD;
   }
   if (strncmp(req->request, ":DELUSER", 8)                 EQ 0)
   {
     req->request_type = 2;
     req->req_typ = DELUSER;
   }
   if (strncmp(req->request, ":DISABLEUSER", 12) EQ 0)
   {
     req->request_type = 2;
     req->req_typ = DISABLEUSER;
   }
   if (strncmp(req->request, ":ENABLEUSER", 11)             EQ 0)
   {
     req->request_type = 2;
     req->req_typ = ENABLEUSER;
   }
   if (strncmp(req->request, ":UNLOCKUSER", 11)             EQ 0)
   {
     req->request_type = 2;
     req->req_typ = UNLOCKUSER;
   }
   if (strncmp(req->request, ":UPDUSER", 8)                 EQ 0)
   {
     req->request_type = 2;
     req->req_typ = UPDUSER;
   }
   if (strncmp(req->request, ":ADDGROUP", 9)                EQ 0)
   {
     req->request_type = 3;
     req->req_typ = ADDGROUP;
   }
   if (strncmp(req->request, ":DELGROUP", 9)                EQ 0)
   {
     req->request_type = 3;
     req->req_typ = DELGROUP;
   }
   if (strncmp(req->request, ":UPDGROUP", 9)                EQ 0)
   {
     req->request_type = 3;
     req->req_typ = UPDGROUP;
   }
   if (strncmp(req->request, ":ADDCONN", 8)                 EQ 0)
   {
     req->request_type = 4;
     req->req_typ = ADDCONN;
   }
   if (strncmp(req->request, ":DELCONN", 8)                 EQ 0)
   {
     req->request_type = 4;
     req->req_typ = DELCONN;
   }
   if (strncmp(req->request, ":UPDCONN", 8)                 EQ 0)
   {
     req->request_type = 4;
     req->req_typ = UPDCONN;
   }
   if ((req->request_type EQ 0))
   {
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Invalid / undefined request = %s", req->request);
      printf("Invalid / undefined request = %s\n", req->request);
      ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, ESA_FATAL);  /* BS10062 */
      return ESA_FATAL;
   }
   if ((req->request_type EQ 1)) goto type1;
 
   token = strtok(NULL, "=,");
   if (token EQ NULL)                                     /* BS10076 */
   {                                                      /* BS10076 */
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,                  /* BS10076 */
                   "Invalid request = %s", req->request); /* BS10076 */
      printf("Invalid request = %s\n", req->request);     /* BS10076 */
      ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, ESA_FATAL);  /* BS10076 */
      return ESA_FATAL;                                   /* BS10076 */
   }                                                      /* BS10076 */
   trim_blanks (token);
   strcpy(ididid, token);
   if (strncmp(ididid, "(", 1) EQ 0) {
       strncpy(ididid, " ", 1);
       trim_blanks (ididid);
   }
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "ididid = |%s|", ididid);
   if ((req->request_type EQ 2)) goto type2;
   if ((req->request_type EQ 3)) goto type3;
   strcpy(req->userid, ididid);
 
   token = strtok(NULL, "=,");
   trim_blanks (token);
   strcpy(req->groupid, token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "req->groupid = |%s|", req->groupid);
   if (strncmp(req->groupid+
                       strlen(req->groupid)-1, ")", 1) EQ 0)
   {
     strncpy(req->groupid+
                       strlen(req->groupid)-1, " ", 1);
     ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                     "after strncpy |%s|", req->groupid);
     trim_blanks (req->groupid);
     ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                     "after trim    |%s|", req->groupid);
   }
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "req->groupid = |%s|", req->groupid);
   goto type4;
 
   type1:
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Type1 request found: request=|%s|",
                   req->request);
   goto exit;
 
   type2:
   strcpy(req->userid, ididid);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Type2 request found: request=|%s| userid=|%s|",
                   req->request, req->userid);
   goto exit;
 
   type3:
   strcpy(req->groupid, ididid);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Type3 request found: request=|%s| groupid=|%s|",
                   req->request, req->groupid);
   goto exit;
 
   type4:
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
          "Type4 request found: request=|%s| userid=|%s| groupid=|%s|",
          req->request, req->userid, req->groupid);
   goto exit;
 
   exit:
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, ESA_OK);
 
   return ESA_OK;
 
   }
 
 
 
/****************************************************
 * Procedure Name: rpl_addinfo_loop
 * Description   : Process the RPL and addinfo lines.
 *               : Some details:
 *               :
 *               : We call read_line routine in an endless loop. The
 *               : line we get from the read_line routine can be one
 *               : these:
 *               : -- environment - error
 *               : -- request - set special 'have_request' bit and
 *               :    prepare to call USA-API
 *               : -- RPL - call process_rpl_addinfo_line
 *               :    and continue looping
 *               : -- addinfo - call process_rpl_addinfo_line
 *               :    and continue looping
 *               : -- I/O error - error
 *               : -- EOF - set special 'reached_EOF' bit and
 *               :    prepare to call USA-API
 *               :
 *               : When breaking out of the endless loop (because we
 *               : encountered a :request line or an EOF), we return
 *               : to the caller.
 * Input         : None
 * Output        : None
 * Input/Output  :
 * Return Value  : ESA_OK or ESA_FATAL
 * Side Effects  :
 * Scope         : Internal To API Test Program
 ***************************************************/
 
   ESA_RC rpl_addinfo_loop (void) {
   ESA_RC                rc = ESA_OK;
   int                   opt;
   int                   keep_on_looping = 1;
   static char         func [] = "BATMAIN_rpl_addinfo_loop";
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   while ((keep_on_looping) && !(reached_EOF))  {
      opt = read_line();
      switch (opt) {
         case 1:            /* :ENV request line                   */
            /* error - leave with bad rc                           */
            keep_on_looping = 0;
            printf(":ENV request lines already processed - error\n");
            rc = ESA_FATAL;
            break;
         case 2:            /* other :request line                 */
            /* set 'have_request' bit and prepare to call USA-API  */
            keep_on_looping = 0;
            have_request = 1;
            rc = ESA_OK;
            break;
         case 3:            /* request parameter line (RPL)        */
            /* call process_rpl_addinfo_line and continue looping  */
            rc = process_rpl_addinfo_line();
            if (rc EQ ESA_FATAL) keep_on_looping = 0;
            break;
         case 4:            /* ADDINFO line or undefined line      */
            /* call process_rpl_addinfo_line and continue looping  */
            rc = process_rpl_addinfo_line();
            if (rc EQ ESA_FATAL) keep_on_looping = 0;
            break;
      /* case 5:              comment or blank line               */
      /*    break;                                                */
         case 6:           /* I/O error                           */
            keep_on_looping = 0;
            printf("I/O error encountered\n");
            rc = ESA_FATAL;
            break;
         case 7:           /* EOF encountered                     */
            /* set 'reached_EOF' bit and prepare to call USA-API  */
            keep_on_looping = 0;
            ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                            "reached EOF in rpl_addinfo_loop routine");
            reached_EOF = 1;
            rc = ESA_OK;
            break;
         default:
            keep_on_looping = 0;
            printf("undefined switch (opt) - error\n");
            rc = ESA_FATAL;
            break;
      } /* switch */
   } /* while */
 
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, rc);
 
   return rc;
 
 
   } /* rpl_addinfo_loop */
 
 
 
 
/****************************************************
 * Procedure Name: process_rpl_addinfo_line
 * Description   : Parse and process the RPL or ADDINFO line.
 * Input         : none but SYSIN_buffer is holding the current
 *               : input line. SYSIN_buffer is a global field.
 * Output        : none but the request_table is partially completed
 *               : with information found on the RPL or ADDINFO line
 * Input/Output  :
 * Return Value  : return code:
 *               :   ESA_OK
 *               :   ESA_FATAL
 * Side Effects  :
 * Scope         : local
 ***************************************************/
 
   ESA_RC process_rpl_addinfo_line (void) {
   ESA_RC rc = ESA_OK;
   int    call_type = 0;
   int    i         = 0;
   unsigned long     size;
   char * token;
   char * ptr;
   static char         func [] = "BATMAIN_process_rpl_addinfo_line";
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   strcpy (retvalue,  "");
   strcpy (retvalueL, "");
   strcpy (retvalueR, "");
 
   if (strncmp (SYSIN_buffer, "USER.DFLTGRP", 12) EQ 0)
                              goto user_dflt;
   if (strncmp (SYSIN_buffer, "USER.PASSWORD", 13) EQ 0)
                              goto user_pass;
   if (strncmp (SYSIN_buffer, "USER.GETCONN", 12) EQ 0)
                              goto user_getconn;
   if (strncmp (SYSIN_buffer, "USER.DISABLE", 12) EQ 0)
                              goto user_dis;
   if (strncmp (SYSIN_buffer, "USER.ENABLE", 11) EQ 0)
                              goto user_ena;
   if (strncmp (SYSIN_buffer, "USER.UNLOCK", 11) EQ 0)
                              goto user_unl;
   if (strncmp (SYSIN_buffer, "USER.AUTH", 9) EQ 0)
                              goto user_auth;
   if (strncmp (SYSIN_buffer, "USER.PARENT_CONTAINER", 21) EQ 0)
                              goto user_par;
   if (strncmp (SYSIN_buffer, "FILTER.USERID", 13) EQ 0)
                              goto filt_userid;
   if (strncmp (SYSIN_buffer, "GROUP.PARENT_CONTAINER", 22) EQ 0)
                              goto grp_par_cont;
   if (strncmp (SYSIN_buffer, "GROUP.PARENT", 12) EQ 0)
                              goto grp_par;
   if (strncmp (SYSIN_buffer, "FILTER.GROUPID", 14) EQ 0)
                              goto filt_grpid;
   if (strncmp (SYSIN_buffer, "CONN.AUTH", 9) EQ 0)
                              goto conn_auth;
   if (strncmp (SYSIN_buffer, "FILTER.CONN", 11) EQ 0)
                              goto filt_conn;
   if (strncmp (SYSIN_buffer, "FILTER.GROUP", 12) EQ 0)
                              goto filt_grp;
   if (strncmp (SYSIN_buffer, "FILTER.USER", 11) EQ 0)
                              goto filt_user;
   if (strncmp (SYSIN_buffer, "FILTER.RESNAME", 14) EQ 0)
                              goto filt_rname;
   if (strncmp (SYSIN_buffer, "FILTER.RESTYPE", 14) EQ 0)
                              goto filt_rtype;
   if (strncmp (SYSIN_buffer, "FILTER.", 7) EQ 0)
                              goto process_addinfo_filter;
   goto process_addinfo_input_output;
 
   user_dflt:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.DFLTGRP being processed");
      call_type=2;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalueR, NULL) EQ 0)
                  strcpy (req->dflt_grpname, retvalue);
      else {
         strcpy (req->dflt_grpname, retvalueL);
         if ((strcmp (retvalueR, "DROPOLD") EQ 0)  ||
             (strcmp (retvalueR, "KEEPOLD") EQ 0))
                      strcpy (req->drop_keepold, retvalueR);
         else {
            printf("invalid USER.DFLTGRP(,xxxxx) specified - error\n");
            utl_request_details();
            return ESA_FATAL;
         }
      }
      goto exit;
   user_pass:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.PASSWORD being processed");
      call_type=2;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalueR, NULL) EQ 0)
                  strcpy (req->password, retvalue);
      else {
         strcpy (req->password, retvalueL);
         if (strcmp (retvalueR, "PERM") EQ 0)
             req->passwd_life = PASS_LIFE_PERMANENT;
         else if (strcmp (retvalueR, "TEMP") EQ 0)
             req->passwd_life = PASS_LIFE_RESET;
         else {
            printf("invalid USER.PASSWORD(,xxxx) specified - error\n");
            utl_request_details();
            return ESA_FATAL;
         }
      }
      goto exit;
   user_getconn:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.GETCONN being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalue, "YES") EQ 0)
          strcpy (req->get_conn, "Y");
      else if (strcmp (retvalue, "NO") EQ 0)
          strcpy (req->get_conn, "N");
      else {
         printf("invalid USER.GETCONN specified - error\n");
         utl_request_details();
         return ESA_FATAL;
      }
      goto exit;
   user_dis:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.DISABLE being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalue, "YES") EQ 0)
          req->rev_status_dis = USER_STAT_REVOKED;
      else {
         printf("invalid USER.DISABLE specified - error\n");
         utl_request_details();
         return ESA_FATAL;
      }
      goto exit;
   user_ena:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.ENABLE being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalue, "YES") EQ 0)
          req->rev_status_ena = USER_STAT_ACTIVE;
      else {
         printf("invalid USER.ENABLE specified - error\n");
         utl_request_details();
         return ESA_FATAL;
      }
      goto exit;
   user_unl:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.UNLOCK being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      goto exit;
      /* WE WILL DO THIS LATER!!!   result in retvalue, save the
      value in request table (user.unlock) and return                */
   user_auth:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.AUTH being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalue, "REG") EQ 0)
          req->user_admin = USER_ADM_NONE;
      else if (strcmp (retvalue, "ADMIN") EQ 0)
          req->user_admin = USER_ADM_ADMIN;
      else if (strcmp (retvalue, "AUDIT") EQ 0)
          req->user_admin = USER_ADM_AUDIT;
      else if (strcmp (retvalue, "ADMINAUDIT") EQ 0)
          req->user_admin = USER_ADM_ALL;
      else {
         printf("invalid USER.AUTH specified - error\n");
         utl_request_details();
         return ESA_FATAL;
      }
      goto exit;
   user_par:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "USER.PARENT_CONTAINER being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      strcpy (req->par_oe, retvalue);
      goto exit;
   grp_par_cont:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "GROUP.PARENT_CONTAINER being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      strcpy (req->grp_par_oe, retvalue);
      goto exit;
   filt_userid:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.USERID being processed");
      call_type=3;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      filter_userid_groupid_encountered = 1;
      req->num_users_in = ctr;
      ptr = (char *) &entries;
      for (i = 0; i LT ctr; i++, ptr += 25) {
         strcpy (req->users_in [i], ptr);
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "next user = |%s|  ptr now = |%x|",
                         req->users_in [i], ptr);
      }
      goto exit;
   grp_par:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "GROUP.PARENT being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      strcpy (req->par_grp, retvalue);
      goto exit;
   filt_grpid:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.GROUPID being processed");
      call_type=3;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      filter_userid_groupid_encountered = 1;
      req->num_groups_in = ctr;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "num_groups_in = %d  ctr = %d",
                      req->num_groups_in, ctr);
      ptr = (char *) &entries;
      for (i = 0; i LT ctr; i++, ptr += 25) {
         strcpy (req->groups_in [i], ptr);
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "next group = |%s|  ptr now = |%x|",
                         req->groups_in [i], ptr);
      }
      goto exit;
   conn_auth:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "CONN.AUTH being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalue, "REG") EQ 0)
          req->u2ug_admin = U2UG_ADM_NONE;
      else if (strcmp (retvalue, "ADMIN") EQ 0)
          req->u2ug_admin = U2UG_ADM_ADMIN;
      else if (strcmp (retvalue, "AUDIT") EQ 0)
          req->u2ug_admin = U2UG_ADM_AUDIT;
      else if (strcmp (retvalue, "ADMINAUDIT") EQ 0)
          req->u2ug_admin = U2UG_ADM_ALL;
      else {
         printf("invalid CONN.AUTH specified - error\n");
         utl_request_details();
         return ESA_FATAL;
      }
      goto exit;
   filt_conn:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.CONN being processed");
      filter_conn_encountered  = 1;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "filter_conn_encountered = %d",
                      filter_conn_encountered);
      if ((filter_group_encountered EQ 1) OR
                                    (filter_user_encountered EQ 1)) {
         printf("FILTER.CONN, FILTER.GROUP, FILTER.USER mutually exclusive\n");
         utl_request_details();
         return ESA_FATAL;
      }
      call_type=2;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      if (strcmp (retvalueR, NULL) EQ 0) {
         if (strcmp (retvalue, "*") EQ 0) {
            req->num_users_in = 0;
            req->num_groups_in = 0;
            goto exit;
         }
         else {
            printf("invalid FILTER.CONN specified - error\n");
            utl_request_details();
            return ESA_FATAL;
         }
      }
      else {
         req->num_users_in = 1;
         req->num_groups_in = 1;
         strcpy (req->users_in [0], retvalueL);
         strcpy (req->groups_in [0], retvalueR);
      }
      goto exit;
   filt_grp:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.GROUP being processed");
      filter_group_encountered = 1;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "filter_group_encountered = %d",
                      filter_group_encountered);
      if ((filter_conn_encountered EQ 1) OR
                                   (filter_user_encountered EQ 1)) {
         printf("FILTER.CONN, FILTER.GROUP, FILTER.USER mutually exclusive\n");
         utl_request_details();
         return ESA_FATAL;
      }
      call_type=3;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      req->num_groups_in = ctr;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "num_groups_in = %d  ctr = %d",
                      req->num_groups_in, ctr);
      ptr = (char *) &entries;
      for (i = 0; i LT ctr; i++, ptr += 25) {
         strcpy (req->groups_in [i], ptr);
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "next group = |%s|  ptr now = |%x|",
                         req->groups_in [i], ptr);
      }
      goto exit;
   filt_user:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.USER being processed");
      filter_user_encountered  = 1;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "filter_user_encountered = %d",
                      filter_user_encountered);
      if ((filter_conn_encountered EQ 1) OR
                                   (filter_group_encountered EQ 1)) {
         printf("FILTER.CONN, FILTER.GROUP, FILTER.USER mutually exclusive\n");
         utl_request_details();
         return ESA_FATAL;
      }
      call_type=3;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      req->num_users_in = ctr;
      ptr = (char *) &entries;
      for (i = 0; i LT ctr; i++, ptr += 25) {
         strcpy (req->users_in [i], ptr);
         ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                         "next user = |%s|  ptr now = |%x|",
                         req->users_in [i], ptr);
      }
      goto exit;
   filt_rname:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.RESNAME being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      strcpy (req->resource, retvalue);
      goto exit;
   filt_rtype:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER.RESTYPE being processed");
      call_type=1;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      strcpy (req->restype, retvalue);
      goto exit;
   process_addinfo_filter:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "FILTER. being processed");
      call_type=4;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      /* The result of this call is in the next slot of the filt_kwd
         and filt_val arrays. They will be copied to the ADDINFO
         structure in the utl_obtain_addinfo_pairs routine.          */
      goto exit;
   process_addinfo_input_output:
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "addinfo_input_output being processed");
      call_type=5;
      rc = parse_rpl_addinfo_line(call_type);
      if (rc NE ESA_OK) goto exit;
      /* The result of this call is in the next slot of the in_kwd
         and in_val arrays (if input) or out_kwd array (if output).
         They will be copied to the ADDINFO structure in the
         utl_obtain_addinfo_pairs routine.                           */
      goto exit;
 
   exit:
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, rc);
 
   return rc;
 
   } /* process_rpl_addinfo_line */
 
/****************************************************
 * Procedure Name: parse_rpl_addinfo_line
 * Description   : Parse the RPL or ADDINFO line.
 * Input         : call_type (1=simple  2=paren  3=many
 *               : 4=ADDINFO filter  5=ADDINFO input or output).
 *               : Also SYSIN_buffer is holding the current
 *               : input line. SYSIN_buffer is a global field.
 * Output        : retvalue or retvalueL/retvalueR or entries.
 *               : All of these are global fields.
 * Input/Output  :
 * Return Value  : return code:
 *               :   ESA_OK
 *               :   ESA_FATAL
 * Side Effects  :
 * Scope         : local
 ***************************************************/
 
   ESA_RC parse_rpl_addinfo_line (int call_type) {
   ESA_RC rc = ESA_OK;
   int    num;
   char * token;
   char * left;
   char * right;
   char * ptr;
   char * next;
   char   keyword[MAX_RSS_ADDINFO_KWD_LEN+1];
   char   value  [MAX_RSS_ADDINFO_VAL_LEN+1];
   static char         func [] = "BATMAIN_parse_rpl_addinfo_line";
 
   ESA_DIAG_enter(ESA_COMP_BATCH, 1, func);
 
   ctr = 0;
   if (call_type EQ 4) goto addinfo_filter;
   if (call_type EQ 5) goto addinfo_input_output;
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "SYSIN_buffer = |%s|", SYSIN_buffer);
   token = strtok(SYSIN_buffer, "=");
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Left side = |%s|", token);
   if (token EQ NULL) {
      printf("Error on left side\n");
      goto fatal;
   }
   token = strtok(NULL, "=");
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Right side = |%s|", token);
   if (token EQ NULL) {
      printf("Error on right side\n");
      goto fatal;
   }
   trim_blanks (token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Right (trimmed) = |%s|", token);
   strcpy(retvalue,token);
   if (call_type EQ 1) goto exit;
 
   /* call_type=2 can also be one of these:
      USER.DFLTGRP=groupid    or  USER.DFLTGRP=(groupid,KEEPOLD)
      USER.PASSWORD=password  or  USER.PASSWORD=(password,PERM)
      Since, at this point, we do not know whether the right side of
      the equal sign is a single or multiple value, we will check
      whether the right side of the equal sign begins with an open
      parenthesis or not. This will indicate whether it is a single or
      multiple value.                                                */
   if ((call_type EQ 2) && (strncmp(token, "(", 1) NE 0)) goto exit;
 
   /* call_type=3 can be one of these:
      FILTER.USERID=*     or FILTER.USERID=(userid1,userid2,userid3)
      FILTER.GROUPID=*    or FILTER.GROUPID=(groupid1,groupid2,groupid3)
      FILTER.USER=userid   or FILTER.USER=(userid1,userid2,userid3)
      FILTER.GROUP=groupid or FILTER.GROUP=(groupid1,groupid2,groupid3)
      Since, at this point, we do not know whether the right side of
      the equal sign is a single or multiple value, we will check
      whether the right side of the equal sign begins with an open
      parenthesis or not. This will indicate whether it is a single or
      multiple value.                                                */
   if ((call_type EQ 3) && (strncmp(token, "(", 1) NE 0)) {
      /* either FILTER.USERID=*  or =userid  or =userid*  or         */
      /*        FILTER.GROUPID=* or =groupid or =groupid*            */
      /* so place the single value into the temporary array          */
      ctr = 1;
      ptr = (char *) &entries;
      strcpy(ptr, retvalue);
      goto exit;
   }
 
   /* The following code is executed when call_type=2. We check if
      the retvalue field (which now contains the right side of the
      equal sign) has an open parenthesis. If so, we split the retvalue
      field into the left side and the right side.  This is what we do:
      look for comma - if none, error
      take left side of comma and check if it exists (if no, error)
                                        remove the ( and trim both sides
      take right side of comma and check if it exists (if no, error)
                                        remove the ) and trim both sides
      return the left side (retvalueL) and the right side (retvalueL) */
 
   if ((strncmp(token, "(", 1) EQ 0) && (call_type EQ 2)) {
      left = strtok(token, ",");
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "Left side = |%s|", left);
      if (left EQ NULL) {
         printf("Error on left side\n");
         goto fatal;
      }
      if (strncmp(left, "(", 1) EQ 0) {
          strncpy(left, " ", 1);
          trim_blanks (left);
          ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                          "Left (trimmed) = |%s|", left);
      }
      right = strtok(NULL, ",");
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "Right side = |%s|", right);
      if (right EQ NULL) {
         printf("Error on right side\n");
         goto fatal;
      }
      if (strncmp(right+strlen(right)-1, ")", 1) EQ 0) {
          strncpy(right+strlen(right)-1, " ", 1);
          trim_blanks (right);
          ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                          "Right (trimmed) = |%s|", right);
      }
      strcpy(retvalueL,left);
      strcpy(retvalueR,right);
      if (call_type EQ 2) goto exit;
   }
 
   /* The following code is executed when call_type=3. We have a table
      for 100 entries (times 25 = 2500 bytes) and do a loop looking for
      commas. We take each entry and place it into the userid table
      after making sure that it is not null and then trimming it.
      While looping, count the number of entries in the userid table. */
 
   ptr = (char *) &entries;
 
   next = strtok(token, ",");
   while ((ctr < 100) && (next NE NULL)) {
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "Next entry = |%s|", next);
      if (next EQ NULL) {
         printf("Error while getting next entry\n");
         goto fatal;
      }
      if (strncmp(next, "(", 1) EQ 0) {
          strncpy(next, " ", 1);
      }
      if (strncmp(next+strlen(next)-1, ")", 1) EQ 0) {
          strncpy(next+strlen(next)-1, " ", 1);
      }
      trim_blanks (next);
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "Next (trimmed) = |%s|", next);
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "ptr now (before strcpy) = |%x|", ptr);
      strcpy(ptr, next);
      ptr = ptr + 25;
      ctr++;
      next = strtok(NULL, ",");
   }
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "number of entries found = %d", ctr);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "final ptr value = %x", ptr);
   goto exit;
 
 
   /* The following code is executed when call_type=4. We have already
      allocated a table to contain many keyword and value pairs. Here,
      we will be parsing the FILTER.keyword=value line in the
      SYSIN_buffer and then we will be populating the keyword and value
      pair table.  At the end, before calling the USA-API, we will
      connect (set a pointer from) the user_params structure to the
      keyword and value pair table.                                  */
 
   addinfo_filter:
 
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Filter = |%s|", SYSIN_buffer);
   token = strtok(SYSIN_buffer, ".");
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Ignored part = |%s|", token);
 
   token = strtok(NULL,    "=");
   if ( token EQ NULL ) {
      printf("Error - no keyword\n");
      goto fatal;
   }
   trim_blanks (token);
   strcpy (keyword, token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Keyword part = |%s|", keyword);
 
   token = strtok(NULL,    "=");
   if ( token EQ NULL ) {
      printf("Error - no value\n");
      goto fatal;
   }
   trim_blanks (token);
   strcpy (value, token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Value part = |%s|", value);
 
   if (strncmp(value, "(", 1) EQ 0) {
       strncpy(value, " ", 1);
       trim_blanks (value);
       num = fread(SYSIN_buffer, 1, strlen(SYSIN_buffer)-1, fdin);
       if (feof(fdin)) goto encountered_eof;
       else if (ferror(fdin)) goto encountered_ioerror;
       strcat(value, SYSIN_buffer);
       trim_blanks (value);
       if (strncmp(value+strlen(value)-1, ")", 1) EQ 0) {
           strncpy(value+strlen(value)-1, " ", 1);
           trim_blanks (value);
       }
       else ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                            "No ending parenthesis!!");
   }
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Final value part = |%s|", value);
 
   strcpy (filt_kwd[filt_i],keyword);
   strcpy (filt_val[filt_i],value);
   filt_i++;
 
   goto exit;
 
 
   /* The following code is executed when call_type=5.  This code is
      used to process keyword=value (input) or keyword alone (output).
      We have already allocated a table to contain many keywords
      (if output) or many keyword and value pairs (if input).  Here,
      we will be parsing the keyword=value or keyword line in the
      SYSIN_buffer and then we will be populating the aforementioned
      tables.  At the end, before calling the USA-API, we will
      connect (set a pointer from) the user_params structure to the
      keyword and/or keyword and value pair table.                   */
 
   addinfo_input_output:
 
   trim_blanks (SYSIN_buffer);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "ADDINFO input or output = |%s|", SYSIN_buffer);
   if (strchr(SYSIN_buffer, '=') EQ NULL) { /* output = keyword only */
      strcpy (keyword, SYSIN_buffer);
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "Keyword part = |%s|", keyword);
      memset (value,0,sizeof(value));
      strcpy (out_kwd[out_i],keyword);
      out_i++;
      addinfo_keyword_encountered = 1;
      ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                      "addinfo_keyword_encountered = 1");
      goto addinfo_input_output_exit;
   }
                                    /* input = keyword=value */
   if (strncmp(SYSIN_buffer, "=", 1) EQ 0) {
      printf("Error - no keyword\n");
      goto fatal;
   }
   token = strtok(SYSIN_buffer, "=");
   if ( token EQ NULL ) {
      printf("Error - no keyword\n");
      goto fatal;
   }
   trim_blanks (token);
   strcpy (keyword, token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Keyword part = |%s|", keyword);
 
   token = strtok(NULL,    "=");
   if ( token EQ NULL ) {
      if ((req->req_typ = UPDUSER)  OR
          (req->req_typ = UPDGROUP) OR
          (req->req_typ = UPDCONN)) {
             strcpy (value, NULL_CHAR);
             ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                             "Value part = |%s|", value);
             goto addinfo_input_output_cont;
      }
      printf("Error - no value\n");
      goto fatal;
   }
   trim_blanks (token);
   strcpy (value, token);
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Value part = |%s|", value);
 
   if (strncmp(value, "(", 1) EQ 0) {
       strncpy(value, " ", 1);
       trim_blanks (value);
       num = fread(SYSIN_buffer, 1, strlen(SYSIN_buffer)-1, fdin);
       if (feof(fdin)) goto encountered_eof;
       else if (ferror(fdin)) goto encountered_ioerror;
       strcat(value, SYSIN_buffer);
       trim_blanks (value);
       if (strncmp(value+strlen(value)-1, ")", 1) EQ 0) {
           strncpy(value+strlen(value)-1, " ", 1);
           trim_blanks (value);
       }
       else ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                            "No ending parenthesis!!");
   }
   addinfo_input_output_cont:
   ESA_DIAG_printf(ESA_COMP_BATCH, 1,
                   "Final value part = |%s|", value);
 
   strcpy (in_kwd[in_i],keyword);
   strcpy (in_val[in_i],value);
   in_i++;
 
   addinfo_input_output_exit:
 
   goto exit;
 
   encountered_ioerror:
   encountered_eof:
   printf("Encountered I/O error or EOF. This is an (input) error.\n");
 
   exit:
   rc = ESA_OK;
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, rc);
 
   return rc;
 
   fatal:
   utl_request_details();
   rc = ESA_FATAL;
   ESA_DIAG_exit(ESA_COMP_BATCH, 1, func, rc);
 
   return rc;
 
   } /* parse_rpl_addinfo_line */
