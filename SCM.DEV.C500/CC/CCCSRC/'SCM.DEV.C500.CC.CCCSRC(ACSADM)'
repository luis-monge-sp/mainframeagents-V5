/*
 * Version Information:
 * ====================
 * File name       : %name: acsadm.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: leonid_s %
 * Created on      : %date_created: Thu May 05 17:59:19 2005 %
 * Current Version : %version: 6 %
 * Last Modified by: %derived_by: leonid_s %
 * Last Modified on: %date_modified: Wed Nov 19 18:17:45 2003 %
 */
 
/**************************************************************
 * Mod.ID       Who      When         Description
 * ============================================================
 * IMH001       Ian H.   19-Nov-03    WSAN101342 Thread-safe code (ERRNO)
 * SVK001       SachinK  05-Dec-05    Fixed problem of password getting dumped in diags.
 * BSAN102162   NMore    20-Jan-06    Duplicate record in RSSADM
 * SAS2IBMA     AvnerL   21-Dec-16    SAS/C to IBM C Conversion Project
 * BS10100      KailasP  21-Jun-19    Security vulnabirity fix
 * IS10184      NuritY   01-Sep-21    Improve scripts performance
 *                                    (compile only - new short names)
 * WS10082K     KailasP  24-May-23    Addinfo changes
 * WS10082A     AvnerL   17-Oct-23    RSSADM is not used in MF.Drop it.
 ********************************************************************/
#include   "globs.h"
 
/*
 *   Standard include files
 */
 
 
#include   ERRNO    /* IMH001 */
#include   STDARG
#include   STDIO
#include   STDLIB
#include   STRING
#include   TIME
#include   CTYPE
#include   ENC_API
#include   AR_DES
/*
 *   CONTROL-SA include files
 */
#include   ESA_ADMIN
#include   ESA_DIAG
#include   ESA_CTSAMSG
#include   ESA_INIT
#include   ESA_PROC
#include   ESA_RSSF
 
#define    ADM_owner
 
 
#define  USER_NAME_LEN_FOR_LIST 25
#define  RSS_NAME_LEN_FOR_LIST   RSS_NAME_LEN
 
 
#define CHANGE_INTERVAL_FMT "%06ld"
 
/********************************************/
/*  Typedef for type of administrator       */
/********************************************/
 
 
 
char TokenStr[3]={' ', DB_FIELDS_SEPARATOR_CHAR, '\0'};
/*WS10082A RSSADM file is not used in MF
/*********************************************************************
*                                                                    *
* Procedure Name   : ADM_find                                        *
*                                                                    *
* Description      : determine if the administrator already exists   *
* Input            : administrator                                   *
*                  : rss_name                                        *
* Output           : find_adm_rec                                    *
* Return Value     : ESA_RC : ESA_OK  if administrator already exists*
*                             ESA_EOF if administrator didn't find   *
*                             ESA_ERR in any other situation         *
*********************************************************************@
 
EXT ESA_RC ADM_find (RSS_typ              rss_name,
                     USER_typ             admin_name,
                     MEMBER_ADM_rec_typ * find_adm_rec)
{
  char                  fn[]="ADM_find";
  int                   jj= 0, ii= 0;
  DATE_typ              date_field;
  TIME_typ              time_field;
  ESA_RC                rc= ESA_EOF;
  USER_typ              admin_name_for_cmp;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
     "RSS=%s Admin=%s AdmRec=%p MaxRssNum=%d.",
      rss_name, admin_name , find_adm_rec,
	  envir_ptr->max_rss_num);
  /*
   * Search RSS.
   *@
 
  for (jj= 0; jj LT envir_ptr->max_rss_num; jj++)
  {
      ESA_DIAG_printf (ESA_COMP_ACSADM, 33,
        "RSS=%s envir_ptr->interest[%d].rss=%s.",
	     rss_name, jj, envir_ptr->interest[jj].rss);
      if (My_stricmp (rss_name, envir_ptr->interest[jj].rss) EQ 0)
        break;
  }
  if (jj GE envir_ptr->max_rss_num)
  {
      CTSAMSG_print (ERR_CS_RSS_ENTITY,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     rss_name, envir_ptr->file_rssparm, fn);
      goto cleanup;
  }
  rc= ADM_admin_name_for_cmp (rss_name, admin_name_for_cmp,admin_name);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
        "admin_name_for_cmp %s rc %d.", admin_name_for_cmp, (int)rc);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= ESA_EOF;
  /*
    SEARCH if user is belong to list of administrators
  *@
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
        "envir_ptr->interest[%d].pre_/num_adms=%d adms_ptr=%p.",
        jj, envir_ptr->interest[jj].pre_num_adms,
        envir_ptr->interest[jj].pre_adms_ptr);
 
 
  for(ii= 0; ii LT envir_ptr->interest[jj].pre_num_adms; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
     "Loop entry #%d , About to copy adm dtls from addr %p., size %d",
          ii ,
          (char *)(envir_ptr->interest[jj].pre_adms_ptr + ii) ,
          sizeof (MEMBER_ADM_rec_typ));
     memcpy ((char *)find_adm_rec,
             (char *)(envir_ptr->interest[jj].pre_adms_ptr + ii),
             sizeof (MEMBER_ADM_rec_typ));
 
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
         "About to translate adm's last update time %d to str",
         find_adm_rec->date_of_last_change);
 
     ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
"Before: date & time:Next %d: Adm=%s pwd_change %c interval %d.",
         ii, find_adm_rec->admin_name,
         find_adm_rec->auto_pwd_change,
         find_adm_rec->change_interval);
 
     ADM_time_to_str ((time_t *)&find_adm_rec->date_of_last_change,
                      date_field, time_field);
     ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
 "After:date&time:Next %d: Adm=%s pwd_change %c intrv %d chg %s %s.",
         ii, find_adm_rec->admin_name,
         find_adm_rec->auto_pwd_change,
         find_adm_rec->change_interval, date_field, time_field);
 
     if (strcmp (admin_name_for_cmp, find_adm_rec->admin_name) EQ 0)
     {
        rc= ESA_OK;
        break;
     }
  }
 
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - ADM_find function *@
 
/****************************************************
 * Procedure Name: ADM_free
 * Description   : free memory from list of administrators
 ****************************************************@
 
void ADM_free (void)
{
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
  char fn[]="ADM_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  for (ii= 0;
       (ii LT envir_ptr->max_rss_num) AND (envir_ptr->interest);
	   ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
       "CSA_free envir_ptr->interest[%d].pre_adms_ptr.",
        ii, envir_ptr->interest[ii].pre_adms_ptr);
    CSA_free ((char **)&envir_ptr->interest[ii].pre_adms_ptr);
    envir_ptr->interest[ii].pre_num_adms= 0;
  }
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - ADM_free function *@
 
/****************************************************
 * Procedure Name: ADM_record_maintenance
 * Description   : Add, Update, Delete OR list administrators
 *                      from the file of administrators
 * Input         : adm_rec - record of the administrator
 *               : action (add, update, delete OR list)
 * Return Value  : rc
 ****************************************************@
 
ESA_RC ADM_record_maintenance (ADMINISTRATOR_rec_typ * adm_rec,
                               ADM_ACTION_typ          action)
 
{
   char fn[]="ADM_record_maintenance";
   ADMINISTRATOR_rec_typ * all_adms_ptr= NULL, * admin_ptr, WrkAdmRec;
   ESA_RC                  rc = ESA_OK;
   FILE                  * file_handle= NULL;
   int                     i= 0, ii= 0;
   long int                all_num_adms= 0;
   char                    stamp_admin_name[USER_NAME_LEN_FOR_LIST+ 1];
   char                    stamp_rss_name[RSS_NAME_LEN_FOR_LIST+ 1];
   char                    CompressFileMode[RSSPRM_VALUE_LEN+ 1];
   ENVIRONMENT_rec_typ   * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
"Act=%d Rss=%.*s Pwd:Len=%.*s Chg=%c Ivl=%.*s D=%.*s T=%.*s Adm=%.*s.",
     (int)action, sizeof (RSS_typ), adm_rec->rss_name,
	 3, adm_rec->passwd_len, adm_rec->auto_pwd_change,
	 sizeof (TIME_typ), adm_rec->change_interval,
     sizeof (DATE_typ), adm_rec->last_changed_date,
	 sizeof (TIME_typ), adm_rec->last_changed_time,
     sizeof (USER_typ), adm_rec->admin_name);
 
   if (action NE ADM_RECORD_LIST)
   {
      rc= CSA_lock (envir_ptr->file_administrators, fn, SCOPE_REMOTE);
      if (rc NE ESA_OK)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
            "Failed to lock %s with rc=%d.", envir_ptr->file_administrators, rc);
         goto cleanup;
	  }
   }
   rc= ADM_load_without_rss(&all_num_adms,&all_adms_ptr);
   if (rc NE ESA_OK)
    goto cleanup;
 
   rc= rssprm_get_opt (ALL_RSS,
                      COMPRESS_FILE_MODE,
                      1,
                      CompressFileMode,
                      OPT_TRUE,
                      OPT_TRUE);
   if (rc NE ESA_OK)
   {
      strcpy (CompressFileMode, ESS_NOT_FLAG);
      rc= ESA_OK;
   }
 
   if (action NE ADM_RECORD_LIST)
   {
      ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
       "CSA_open file_administrators=%s.",
        envir_ptr->file_administrators);
      rc= CSA_open (envir_ptr->file_administrators, fn,
                 FILE_CREAT, &file_handle, SCOPE_LOCAL);
      if (rc NE ESA_OK)
        goto cleanup;
 
      rc= CSA_fputs (envir_ptr->file_administrators,
                     FILE_NOTE_LINE,
                     file_handle);
      if (rc NE ESA_OK)
       goto cleanup;
   }
   if (action EQ ADM_RECORD_LIST)
   {
 
      memset (stamp_admin_name, '_', USER_NAME_LEN_FOR_LIST);
      stamp_admin_name[USER_NAME_LEN_FOR_LIST]= '\0';
      memset (stamp_rss_name, '_', RSS_NAME_LEN_FOR_LIST);
      stamp_rss_name[RSS_NAME_LEN_FOR_LIST]= '\0';
    printf("___ %s_%s_____________________________\n",
             stamp_rss_name, stamp_admin_name);
 
      memset (stamp_admin_name, ' ', USER_NAME_LEN_FOR_LIST);
      memset (stamp_rss_name, ' ', RSS_NAME_LEN_FOR_LIST);
      memcpy(stamp_rss_name, "RSS", 3);
      memcpy(stamp_admin_name, "Administrator", 13);
      printf("n/n %s %s Interval Last changes       \n",
             stamp_rss_name, stamp_admin_name);
      memset (stamp_admin_name, '-', USER_NAME_LEN_FOR_LIST);
 
 
      memset (stamp_rss_name, '-', RSS_NAME_LEN_FOR_LIST);
     printf("--- %s %s -------- -------------------\n",
            stamp_rss_name, stamp_admin_name);
 
   }
   if (
       (strlen (adm_rec->rss_name) NE 0)
           AND
       (strlen (adm_rec->admin_name) NE 0)
      )
   {
      rc= ADM_admin_name_for_cmp (adm_rec->rss_name,
                                  adm_rec->admin_name,
                                  adm_rec->admin_name);
      if (rc NE ESA_OK)
         goto cleanup;
   }
 
   for (i= 0; i LT all_num_adms; i++)
   {
      admin_ptr = all_adms_ptr+ i;
      ESA_DIAG_printf (ESA_COMP_ACSADM, 36,
        "admin_ptr=%p i=%d:  Rss=%d %s Adm=%d %s",
         admin_ptr, i,
         sizeof (RSS_typ), adm_rec->rss_name,
	 sizeof (USER_typ), admin_ptr->admin_name);
 
 
      if (
          (action NE ADM_RECORD_ADD)
             AND
          (
             (strlen (adm_rec->rss_name) EQ 0)
                 OR
             (My_stricmp (admin_ptr->rss_name,adm_rec->rss_name) EQ 0)
          )
             AND
          (
             (strlen (adm_rec->admin_name) EQ 0)
                 OR
             (strcmp (admin_ptr->admin_name,adm_rec->admin_name) EQ 0)
          )
        )
      {
         if (action EQ ADM_RECORD_DEL)
            continue;
         if (action EQ ADM_RECORD_UPD)
            admin_ptr = adm_rec;
         if (action EQ ADM_RECORD_SYNC)
         {
            for(ii= 0; ii LT envir_ptr->max_rss_num; ii++)
            {
               ESA_DIAG_printf (ESA_COMP_ACSADM, 36,
                 "Rss=%.*s :envir_ptr->interest[%d].rss=%.*s .",
                  sizeof (RSS_typ), admin_ptr->rss_name, ii,
	              sizeof (RSS_typ), envir_ptr->interest[ii].rss);
               if (My_stricmp (admin_ptr->rss_name,
                           envir_ptr->interest[ii].rss) EQ 0)
                  break;
            }
            if (ii GE envir_ptr->max_rss_num)
               continue;
         }
         if (action EQ ADM_RECORD_LIST)
         {
            admin_ptr->rss_name[RSS_NAME_LEN]      = '\0';
            admin_ptr->change_interval[TIME_LEN]   = '\0';
            admin_ptr->last_changed_time[TIME_LEN] = '\0';
 
            memset (stamp_rss_name, ' ', RSS_NAME_LEN_FOR_LIST);
 
            memset (stamp_admin_name, ' ', USER_NAME_LEN_FOR_LIST);
 
            memcpy (stamp_admin_name, admin_ptr->admin_name,
                    MIN(USER_NAME_LEN_FOR_LIST,
                        strlen(admin_ptr->admin_name)));
 
            memcpy (stamp_rss_name, admin_ptr->rss_name,
                    MIN(RSS_NAME_LEN_FOR_LIST,
                        strlen(admin_ptr->rss_name)));
 
            stamp_admin_name[USER_NAME_LEN_FOR_LIST]= '\0';
 
            printf("%3d %s %s  %s  %c%c%c%c/%c%c/%c%c %c%c.%c%c.%c%c\n",
                   i+ 1, stamp_rss_name, stamp_admin_name,
                   admin_ptr->change_interval,
                   admin_ptr->last_changed_date[0],
                   admin_ptr->last_changed_date[1],
                   admin_ptr->last_changed_date[2],
                   admin_ptr->last_changed_date[3],
                   admin_ptr->last_changed_date[4],
                   admin_ptr->last_changed_date[5],
                   admin_ptr->last_changed_date[6],
                   admin_ptr->last_changed_date[7],
                   admin_ptr->last_changed_time[0],
                   admin_ptr->last_changed_time[1],
                   admin_ptr->last_changed_time[2],
                   admin_ptr->last_changed_time[3],
                   admin_ptr->last_changed_time[4],
                   admin_ptr->last_changed_time[5]);
            continue;
         }
      }
      if (action EQ ADM_RECORD_LIST)
         continue;
      if (strcmp (CompressFileMode, ESS_YES_FLAG) EQ 0)
      {
	     strcpy ((char *)&WrkAdmRec, admin_ptr->rss_name);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, admin_ptr->admin_passwd);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, admin_ptr->passwd_len);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strncat ((char *)&WrkAdmRec, &admin_ptr->auto_pwd_change, 1);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, admin_ptr->change_interval);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, admin_ptr->last_changed_date);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, admin_ptr->last_changed_time);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, admin_ptr->admin_name);
         strcat ((char *)&WrkAdmRec, "\n");
         admin_ptr= &WrkAdmRec;
      }
	  else
	  {
         admin_ptr->rss_name[strlen(admin_ptr->rss_name)]= ' ';
 		 admin_ptr->admin_passwd[strlen(admin_ptr->admin_passwd)]= ' ';
		 admin_ptr->change_interval[TIME_LEN]= ' ';
		 admin_ptr->last_changed_date[DATE_LEN] = ' ';
		 admin_ptr->last_changed_time[TIME_LEN] = ' ';
		 admin_ptr->blank1= ' ';
		 admin_ptr->blank2= ' ';
		 admin_ptr->blank3= ' ';
		 admin_ptr->admin_name[strlen(admin_ptr->admin_name)+1]= '\0';
		 admin_ptr->admin_name[strlen(admin_ptr->admin_name)]= '\n';
	  }
 
      rc= CSA_fputs (envir_ptr->file_administrators,
                     (char *)admin_ptr,
                     file_handle);
      if (rc NE ESA_OK)
       goto cleanup;
 
      ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
                       "record %d is %s.", i+ 1, admin_ptr->rss_name);
   }
 
   /*
    *   Add rows  into the file
    *@
   if (action EQ ADM_RECORD_ADD)
   {
      if (strcmp (CompressFileMode, ESS_YES_FLAG) EQ 0)
      {
	     strcpy ((char *)&WrkAdmRec, adm_rec->rss_name);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, adm_rec->admin_passwd);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, adm_rec->passwd_len);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strncat ((char *)&WrkAdmRec, &adm_rec->auto_pwd_change, 1);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, adm_rec->change_interval);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, adm_rec->last_changed_date);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, adm_rec->last_changed_time);
         strcat ((char *)&WrkAdmRec, DB_FIELDS_SEPARATOR_STR);
	     strcat ((char *)&WrkAdmRec, adm_rec->admin_name);
         strcat ((char *)&WrkAdmRec, "\n");
         adm_rec= &WrkAdmRec;
      }
	  else
	  {
         adm_rec->rss_name[strlen(adm_rec->rss_name)]= ' ';
         adm_rec->admin_passwd[strlen(adm_rec->admin_passwd)]= ' ';
         adm_rec->change_interval[TIME_LEN]= ' ';
         adm_rec->change_interval[TIME_LEN]= ' ';
         adm_rec->last_changed_date[DATE_LEN] = ' ';
         adm_rec->last_changed_time[TIME_LEN] = ' ';
         adm_rec->blank1= ' ';
         adm_rec->blank2= ' ';
         adm_rec->blank3= ' ';
         adm_rec->admin_name[strlen(adm_rec->admin_name)+1]= '\0';
         adm_rec->admin_name[strlen(adm_rec->admin_name)]= '\n';
	  }
      rc= CSA_fputs (envir_ptr->file_administrators,
                     (char *)adm_rec,
                     file_handle);
      if (rc NE ESA_OK)
       goto cleanup;
   }
   if (adm_rec NE NULL)
      ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
               "record %d is %s.", i+ 1, adm_rec->rss_name);
 
  cleanup:
 
   if (action NE ADM_RECORD_LIST)
   {
      CSA_close (envir_ptr->file_administrators, fn);
      CSA_unlock (envir_ptr->file_administrators, fn);
 
   }
   CSA_free ((char **)&all_adms_ptr);
   all_num_adms= 0;
   if (rc NE ESA_OK)
     CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
   ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
   return(rc);
}  /* End of ADM_record_maintenance function *@
 
/**************************************************************
*                                                             *
* Procedure Name   : ADM_load                                 *
*                                                             *
* Description      : Load from file to memory                 *
*                    list of administrators                   *
* Return Value     : rc                                       *
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function loads the list of administrators from
* the "administrator's file" to memory. The administrators are loaded
* to the envir_ptr->intrsrt static data - that is an array with an
* entry per possible RSS on current platform. In each entry (= RSS) -
* there are two data items (among otherS):
* pre_num_adms - The number of administrators in list.
* pre_adms_ptr - A pointer to an array of administrators names
*               (each name in full length of administrators string).
* The function first clears all details of administrators (for
* ALL RSS types) - then reads the administrators into a single
* allocated buffer - than according to the amount of administrators
* for each RSS (that was determinded wile first load) - the
* function allocates a memory segment for the administrators
* of each RSS and fills in the administrators.
**********************************************************************@
 
ESA_RC ADM_load (void)
{
  char                    fn[]="ADM_load";
  ESA_RC                  rc = ESA_OK;
  int                     ii, jj, * nn= NULL;
  ADMINISTRATOR_rec_typ * all_adms_ptr= NULL, * admin_ptr;
  long int                all_num_adms= 0;
  MEMBER_ADM_rec_typ      adm_rec;
  time_t                  t_time;
  struct tm               tm_time;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
 
/*
    CLEAR all RSS all adminstrators details.
  *@
  rc= CSA_alloc ((char **)&nn,
                 0,
                 4,
                 envir_ptr->max_rss_num,
                 fn,
                 "work nn");
  ADM_free();
  /*
   * LOAD all adminstrators from adminstrators file - into a single
   * memory segment - check each adminstrator's validity and count
   * the number of adminstrators for each RSS.
  *@
  rc= ADM_load_without_rss(&all_num_adms,&all_adms_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SCAN all different RSS in platform.
  *@
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "envir_ptr->interest[%d].pre_num_adms=%d / rss=%s ",
      ii, envir_ptr->interest[ii].pre_num_adms,
      envir_ptr->interest[ii].rss);
    /*
       CLEAR the number of adminstrators that already filled
       for current RSS.
    *@
    nn[ii]= 0;
    /@
      PROCESS when the current RSS has adminstrators:
    *@
    if (envir_ptr->interest[ii].pre_num_adms GT 0)
    {
      /*
        ALLOCATE a global memory segment for current RSS adminstrators -
        according to the number of users to current RSS.
      *@
      rc= CSA_alloc ((char **)&envir_ptr->interest[ii].pre_adms_ptr,
                     0, sizeof (MEMBER_ADM_rec_typ),
                     envir_ptr->interest[ii].pre_num_adms,
                     fn, "adminstrators");
      if (rc NE ESA_OK)
        goto cleanup;
 
    } /* END - There are adminstrators in current RSS *@
 
  } /* END - FOR loop on ALL RSS *@
 
  /*
    ROCESS all users that were loaded from file:
  *@
  for (jj= 0; jj LT all_num_adms; jj++)
  {
    /*
      COPY the admi.details into temporary user details buffer.
    *@
    admin_ptr = all_adms_ptr+ jj;
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
         "admin_ptr=%p = all_adms_ptr=%p + %d.",
         admin_ptr, all_adms_ptr, jj);
    /*
      LOCATE current adminstrator's RSS entry in array.
    *@
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
       ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
         "admin_ptr->rss_name=%s envir_ptr->interest[%d].rss=%s ",
         admin_ptr->rss_name, ii, envir_ptr->interest[ii].rss);
      if (My_stricmp(envir_ptr->interest[ii].rss,admin_ptr->rss_name)
          EQ 0)
        break;
    }
    if (ii GE envir_ptr->max_rss_num)
        continue;
    /*
     * Copy the current administrators to the next entry of
     * administrators in the relevant RSS.
    *@
 
    to_time_tm_convert (&tm_time, admin_ptr->last_changed_date,
                        admin_ptr->last_changed_time);
    t_time= mktime (&tm_time);
    adm_rec.passwd_len=
        (unsigned short)atoi(admin_ptr->passwd_len);
    if (adm_rec.passwd_len)
       strcpy (adm_rec.admin_passwd, admin_ptr->admin_passwd);
    else
       adm_rec.admin_passwd[0]= '\0';
    adm_rec.auto_pwd_change = admin_ptr->auto_pwd_change;
    adm_rec.change_interval=
        (unsigned long)atoi(admin_ptr->change_interval);
    adm_rec.date_of_last_change= (unsigned long)t_time;
    strcpy (adm_rec.admin_name, admin_ptr->admin_name);
    memcpy ((char *)(envir_ptr->interest[ii].pre_adms_ptr+ nn[ii]),
            (char *)&adm_rec, sizeof (MEMBER_ADM_rec_typ));
    ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
    "rss %s: pwd_len %s(%d) intrvl %s(%lu) date %s %s(%lu) name %s.",
            envir_ptr->interest[ii].rss, admin_ptr->passwd_len,
            (int)adm_rec.passwd_len,
            admin_ptr->change_interval,
            adm_rec.change_interval,
            admin_ptr->last_changed_date,
            admin_ptr->last_changed_time,
            adm_rec.date_of_last_change,
            adm_rec.admin_name);
 
    /*
      INCREASE by 1 the actual number of users in current RSS entry.
    *@
    nn[ii]++;
    if (My_stricmp (admin_ptr->rss_name, envir_ptr->msg_admin_param.rss_name) EQ ESA_OK)
       ADM_admin_pwd_sync (admin_ptr->admin_name);
  }
 
  cleanup:
  /*
    FREE the temporary allocated segment of all users from file.
  *@
  CSA_free ((char **)&all_adms_ptr);
  CSA_free ((char **)&nn);
 
  if (rc NE ESA_OK)
  {
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
    ADM_free ();
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
          "*****>... %d Administrators from %s file loaded.",
		  all_num_adms, envir_ptr->file_administrators);
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - ADM_load  function *@
 
/**************************************************************
*                                                             *
* Procedure Name   : ADM_load_without_rss                     *
*                                                             *
* Description      : Load data from the file to the memory    *
*                         without rss records                 *
* Input            : rss                                      *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* The function is activated in order to scan the Administrators
* - and to load it to a global memory segment. The segment
* is arranged in array format where every entry contains: RSS name &
* User name. In addition - the function fills in all RSS entries, in
* the RSS array of the envir external data, with the number of
* administrators that resides, in the segment, for them.
* The function scans all records from the file, checks the RSS
* existance the Administrator validity and inserts it to a temporary
* array (that contains fixed number of entries).
* Whenever the temporary array is filled - the memory segment allocated
* for users is expanded by its size - its contents is copied to the
* memory allocated, the number of output administrators is updated
* and the temporary array is cleared - and so on.
**********************************************************************@
 
ESA_RC ADM_load_without_rss (long int               * all_num_adms,
                             ADMINISTRATOR_rec_typ ** all_adms_ptr)
{
  char                    fn[]="ADM_load_without_rss";
  ESA_RC                  rc = ESA_OK;
  ADMINISTRATOR_rec_typ   tmp_adms [TMP_ADMIN_NUM], tmp_line;
  int                     i= 0,j= 0,ii= 0,additional_adms_len= 0;
  char                    line [sizeof (ADMINISTRATOR_rec_typ)];
  FILE                  * file_handle= NULL;
  char                  * admin_name_in= NULL, *rss_in= NULL;
  char                  * adms_in_cont, empty_str= '\0',* newline=NULL;
  char                  * admin_passwd_in= NULL,* auto_pwd_change=NULL;
  char                  * change_interval_in= NULL,*passwd_len_in=NULL;
  char                  * last_changed_date_in = NULL;
  char                  * last_changed_time_in = NULL;
  unsigned int            password_ext_len= PASSWORD_EXT;
  ENVIRONMENT_rec_typ   * envir_ptr;
  char                  * endline;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_DETAILES,
    "...-> : envir_ptr->file_administrators=%s envir_ptr= %p.",
	envir_ptr->file_administrators, envir_ptr);
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
      "struct_size=%d.", sizeof(ADMINISTRATOR_rec_typ));
 
  CLEAR (tmp_adms);
  /*
    OPEN "administrators" file.
  *@
  rc= CSA_open (envir_ptr->file_administrators, fn,
                FILE_OPEN_FOR_UPDATE, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
   goto cleanup;
  /*
     SCAN all file record's.
  *@
  for (i= 1,j= 0; rc EQ ESA_OK ; i++)
  {
    rss_in               = NULL;
    admin_name_in        = NULL;
    adms_in_cont         = &empty_str;
    admin_passwd_in      = NULL;
    passwd_len_in        = NULL;
    auto_pwd_change      = NULL;
    change_interval_in   = NULL;
    last_changed_date_in = NULL;
    last_changed_time_in = NULL;
    additional_adms_len  = 0;
    /*
      READ next file's line (record).
    *@
    rc= CSA_fgets (envir_ptr->file_administrators,
                   line,
                   sizeof(ADMINISTRATOR_rec_typ),
                   file_handle);
    if (rc EQ ESA_EOF)
    {
        rc= ESA_OK;
        break;
    }
    if (rc NE ESA_OK)
        goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_DETAILES+ 1, "->%d record=%s<-", i+ 1, line);
    /*
      COPY the administrator details to NEXT entry.
    *@
    newline = strchr(line,'\n');
    if (newline NE NULL)
       strcpy (newline,"\0");
 
    memcpy ((char *)(&tmp_line), (char *)line,
            sizeof(ADMINISTRATOR_rec_typ));
 
    rss_in               = strtok (line, TokenStr);
    if (tmp_line.admin_passwd[0] EQ ' ')
       admin_passwd_in   = &empty_str;
    else
       admin_passwd_in   = strtok (NULL, TokenStr);
    passwd_len_in        = strtok (NULL, TokenStr);
    auto_pwd_change      = strtok (NULL, TokenStr);
    change_interval_in   = strtok (NULL, TokenStr);
    last_changed_date_in = strtok (NULL, TokenStr);
    last_changed_time_in = strtok (NULL, TokenStr);
    admin_name_in        = strtok (NULL, TokenStr);
    endline              = strtok (NULL, TokenStr);
 
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "rss_in=%p/%s.",              rss_in,
	  (rss_in) ? rss_in : "NULL");
    /* Sachin: Uncomment these lines for special case, if you need
			   to print password in diagnostic logs.
	ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "admin_passwd_in=%p.",     admin_passwd_in);*@
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "passwd_len_in=%p/%s.",       passwd_len_in,
	  (passwd_len_in) ? passwd_len_in : "NULL");
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "auto_pwd_change=%p/%s.",     auto_pwd_change,
	  (auto_pwd_change) ? auto_pwd_change : "NULL");
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "change_interval_in=%p/%s.",  change_interval_in,
	  (change_interval_in) ? auto_pwd_change : "NULL");
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "last_changed_date_in=%p/%s.",last_changed_date_in,
	  (last_changed_date_in) ? last_changed_date_in : "NULL");
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "last_changed_time_in=%p/%s.",last_changed_time_in,
	  (last_changed_time_in) ? last_changed_time_in : "NULL");
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "admin_name_in=%p/%s.",       admin_name_in,
	  (admin_name_in) ? admin_name_in : "NULL");
 
    while (endline NE NULL)
    {
       admin_name_in[strlen(admin_name_in)] = ' ';
       endline           = strtok (NULL, " ");
    }
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
      "admin_name_in=%p/%s.",       admin_name_in,
	  (admin_name_in) ? admin_name_in : "NULL");
 
    /*
      SKIP current user (do not set array index up by 1) if the line
      is empty or the RSS name is empty.
    *@
 
    if(line[0] EQ NULL_CHAR OR line[0] EQ SKIP_LINE OR rss_in EQ NULL)
    {
       ESA_DIAG_printf (ESA_COMP_ACSADM, 15, "Skipped ->%d<- record", i);
       continue;
    }
    /*
      EXIT, returning fatal error if the RSS name or the User name is
      invalid.
    *@
 
    if (strlen(rss_in)       GT RSS_NAME_LEN)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_RSS_NAME , rss_in ,
                     envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
 
    }
    if (strlen(admin_passwd_in) GT password_ext_len)
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_PASSWD,
                      (admin_passwd_in EQ NULL) ?
                      ""
                      :
                      "****",
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    if (strlen(passwd_len_in) GT sizeof(tmp_adms[0].passwd_len))
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_PASSWD_LEN,
                      (passwd_len_in EQ NULL) ?
                      ""
                      :
                      "****",
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    if (
        (auto_pwd_change EQ NULL)
            OR
        (strlen(auto_pwd_change) GT 1)
            OR
        (
            (*auto_pwd_change NE ESS_YES_SIGN)
                AND
            (*auto_pwd_change NE ESS_NOT_SIGN)
        )
       )
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_AUTO_CHANGE,
                      (auto_pwd_change EQ NULL) ?
                      ""
                      :
                      auto_pwd_change,
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    if (
          (change_interval_in EQ NULL)
         OR
          (strlen(change_interval_in) GT
                  sizeof(tmp_adms[0].change_interval))
       )
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_INTERVAL,
                      (change_interval_in EQ NULL) ?
                      ""
                      :
                      change_interval_in,
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    if (
        (last_changed_date_in EQ NULL)
            OR
            (strlen(last_changed_date_in) GT DATE_LEN)
        )
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_DATE,
                      (last_changed_date_in EQ NULL) ?
                      ""
                      :
                      last_changed_date_in,
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    if (
        (last_changed_time_in EQ NULL)
            OR
            (strlen(last_changed_time_in) GT TIME_LEN)
        )
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_TIME,
                      (last_changed_time_in EQ NULL) ?
                      ""
                      :
                      last_changed_time_in,
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    if (
          (strlen(admin_name_in) GT MAX_RSS_USER_NAME_LEN)
         OR
          (MAX_RSS_USER_NAME_LEN LT (strlen(admin_name_in) +
                                     strlen(adms_in_cont) +
                                     additional_adms_len))
       )
    {
       CTSAMSG_print (ERR_CS_PRM_LEN,
                      envir_ptr->msg_params.ctsamsg_handle, NULL,
                      envir_ptr->msg_params.ctsamsg_dest,
                      C_ADM_NAME,
                      (admin_name_in EQ NULL) ?
                      ""
                      :
                      admin_name_in,
                      envir_ptr->file_administrators, i);
       rc= ESA_FATAL;
       goto cleanup;
    }
 
    /*
      LOCATE the admin's RSS among the RSSs known in current platform.
    *@
 
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      /*
        PROCESS when RSS name - found:
      *@
      ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
          "rss_in=%s envir_ptr->interest[%d].rss=%s pre_num_adms=%d.",
		  rss_in, ii, envir_ptr->interest[ii].rss,
		  envir_ptr->interest[ii].pre_num_adms);
      if (My_stricmp (rss_in, envir_ptr->interest[ii].rss) EQ 0)
      {
        /*
          SET number of users in found RSS entry - up by 1
        *@
        envir_ptr->interest[ii].pre_num_adms++;
        break;
      }
    } /* END - FOR loop on known RSSs *@
    /*
      EXIT returning fatal error - if RSS is unknown.
    *@
    if (ii GE envir_ptr->max_rss_num)
      CTSAMSG_print (ERR_CS_RSS_INVALID_NAME,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, rss_in, envir_ptr->file_rssparm);
    /*
      SET the temporary user's array index up by 1.
    *@
	memset ((char *)&tmp_adms[j], ' ', sizeof (ADMINISTRATOR_rec_typ));
    strcpy (tmp_adms[j].rss_name, rss_in);
    strcpy (tmp_adms[j].admin_passwd, admin_passwd_in);
    strcpy (tmp_adms[j].passwd_len, passwd_len_in);
    strcpy (&tmp_adms[j].auto_pwd_change, auto_pwd_change);
    strcpy (tmp_adms[j].change_interval, change_interval_in);
    strcpy (tmp_adms[j].last_changed_date, last_changed_date_in);
    strcpy (tmp_adms[j].last_changed_time, last_changed_time_in);
    strcpy (tmp_adms[j].admin_name, admin_name_in);
    /* Sachin: Uncomment this call and comment the next call to print
			   user password in diagnostic log file.
	ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
		"Ptr=%p Rss=%s Pwd=%s PwdLen=%s PwdChg=%s ChgIntrvl=%s"
		" Date=%s Time=%s Admin=%s.",
        &tmp_adms[j], tmp_adms[j].rss_name, tmp_adms[j].admin_passwd,
		tmp_adms[j].passwd_len, &tmp_adms[j].auto_pwd_change,
		tmp_adms[j].change_interval, tmp_adms[j].last_changed_date,
		tmp_adms[j].last_changed_time, tmp_adms[j].admin_name);*@
	ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
		"Ptr=%p Rss=%s Pwd=%s PwdLen=%s PwdChg=%s ChgIntrvl=%s"
		" Date=%s Time=%s Admin=%s.",
        &tmp_adms[j], tmp_adms[j].rss_name,
		(tmp_adms[j].admin_passwd EQ NULL) ? "" : "****" ,
		tmp_adms[j].passwd_len, &tmp_adms[j].auto_pwd_change,
		tmp_adms[j].change_interval, tmp_adms[j].last_changed_date,
		tmp_adms[j].last_changed_time, tmp_adms[j].admin_name);
 
    j++;
 
    ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
                   "Next %d adm.rec %s.", j, &tmp_adms[j]);
    /*
      PROCESS when the temporary users array is full:
    *@
    if (j GE TMP_ADMIN_NUM)
    {
      /*
        PROCESS if no users memory segment were allocated yet:
      *@
      if (*all_num_adms EQ 0)
        /*
          ALLOCATE memory segment for filled temporary admin array.
        *@
        rc= CSA_alloc ((char **)all_adms_ptr, STRUC_ADM_REC,
                       sizeof (ADMINISTRATOR_rec_typ),
                       j, fn, "All administrators");
      else
        /*
          REALOCATE the memory segment - expand it to contain another
          set of temporary administrators array.
        *@
        rc= CSA_realloc ((char **)all_adms_ptr, STRUC_ADM_REC,
                         sizeof (ADMINISTRATOR_rec_typ),
                         (*all_num_adms)+ j);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        COPY all users in temporary array to the new
        allocated/extended memory segment.
      *@
      memcpy ((char *)((*all_adms_ptr)+(*all_num_adms)),
              (char *)tmp_adms,
              sizeof(ADMINISTRATOR_rec_typ)* j);
    /* Sachin: Uncomment this call and comment the next call to print
			   user password in diagnostic log file.
      ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
		"Ptr=%p Rss=%s Pwd=%s PwdLen=%s PwdChg=%s ChgIntrvl=%s"
		" Date=%s Time=%s Admin=%s.",
         (*all_adms_ptr)+(*all_num_adms),
		 (*all_adms_ptr)[(*all_num_adms)].rss_name,
		 (*all_adms_ptr)[(*all_num_adms)].admin_passwd,
		 (*all_adms_ptr)[(*all_num_adms)].passwd_len,
		 &(*all_adms_ptr)[(*all_num_adms)].auto_pwd_change,
		 (*all_adms_ptr)[(*all_num_adms)].change_interval,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_date,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_time,
		 (*all_adms_ptr)[(*all_num_adms)].admin_name);*@
      ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
		"Ptr=%p Rss=%s Pwd=%s PwdLen=%s PwdChg=%s ChgIntrvl=%s"
		" Date=%s Time=%s Admin=%s.",
         (*all_adms_ptr)+(*all_num_adms),
		 (*all_adms_ptr)[(*all_num_adms)].rss_name,
		 ((*all_adms_ptr)[(*all_num_adms)].admin_passwd EQ NULL) ? " " : "****",
		 (*all_adms_ptr)[(*all_num_adms)].passwd_len,
		 &(*all_adms_ptr)[(*all_num_adms)].auto_pwd_change,
		 (*all_adms_ptr)[(*all_num_adms)].change_interval,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_date,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_time,
		 (*all_adms_ptr)[(*all_num_adms)].admin_name);
 
      /*
        INCREASE the output number of admins in allocated segment - by
        the amount of users from temporary array.
      *@
      (*all_num_adms) += j;
      ESA_DIAG_printf (ESA_COMP_ACSADM, 16,
         "Added Next %d admins to memory %d admins", j, *all_num_adms);
      /*
        CLEAR the temporary array of users.
      *@
      CLEAR (tmp_adms);
      j= 0;
    }
 
  } /* FOR - loop on all file records *@
 
  /*
    EXIT if no (more) admins were added to the temporary admins array
    since it was created/last copied to the memory segment.
  *@
  if (j EQ 0)
    goto cleanup;
  /*
    PROCESS when loop terminated ok.
  *@
  if (rc EQ ESA_OK)
      /*
        PROCESS if no users memory segment were allocated yet:
      *@
      if ((*all_num_adms) EQ 0)
        /*
          ALLOCATE memory segment for the filled users in temporary
          users array.
        *@
        rc= CSA_alloc ((char **)all_adms_ptr, STRUC_ADM_REC,
                       sizeof (ADMINISTRATOR_rec_typ),
                       j, fn, "All administrators");
      else
        /*
          REALOCATE the memory segment - expand it to contain the
          details of admins that were filled in the temporary array.
        *@
        rc= CSA_realloc ((char **)all_adms_ptr, STRUC_ADM_REC,
                         sizeof (ADMINISTRATOR_rec_typ),
                         (*all_num_adms)+ j);
  if (rc EQ ESA_OK)
  {
    /*
      COPY the filled admins in temporary array to the new
      allocated/extended memory segment.
    *@
    memcpy ((char *)((*all_adms_ptr)+ (*all_num_adms)),
            (char *)tmp_adms,
            sizeof (ADMINISTRATOR_rec_typ)* j);
    /* Sachin: Uncomment this call and comment the next call to print
			   user password in diagnostic log file.
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
		"Ptr=%p Rss=%s Pwd=%s PwdLen=%s PwdChg=%s ChgIntrvl=%s"
		" Date=%s Time=%s Admin=%s.",
         (*all_adms_ptr)+(*all_num_adms),
		 (*all_adms_ptr)[(*all_num_adms)].rss_name,
		 (*all_adms_ptr)[(*all_num_adms)].admin_passwd,
		 (*all_adms_ptr)[(*all_num_adms)].passwd_len,
		 &(*all_adms_ptr)[(*all_num_adms)].auto_pwd_change,
		 (*all_adms_ptr)[(*all_num_adms)].change_interval,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_date,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_time,
		 (*all_adms_ptr)[(*all_num_adms)].admin_name);*@
    ESA_DIAG_printf (ESA_COMP_ACSADM, 26,
		"Ptr=%p Rss=%s Pwd=%s PwdLen=%s PwdChg=%s ChgIntrvl=%s"
		" Date=%s Time=%s Admin=%s.",
         (*all_adms_ptr)+(*all_num_adms),
		 (*all_adms_ptr)[(*all_num_adms)].rss_name,
		 ((*all_adms_ptr)[(*all_num_adms)].admin_passwd EQ NULL) ? " " : "****",
		 (*all_adms_ptr)[(*all_num_adms)].passwd_len,
		 &(*all_adms_ptr)[(*all_num_adms)].auto_pwd_change,
		 (*all_adms_ptr)[(*all_num_adms)].change_interval,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_date,
		 (*all_adms_ptr)[(*all_num_adms)].last_changed_time,
		 (*all_adms_ptr)[(*all_num_adms)].admin_name);
    /*
      INCREASE the output number of admins in allocated segment - by
      the number of admins filled in temporary array.
    *@
    (*all_num_adms) += j;
    ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "Added Next %d admins to memory %d admins", j, *all_num_adms);
  }
 
  cleanup:
  /*
    CLOSE "Administrators" file.
  *@
  CSA_close (envir_ptr->file_administrators, fn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_DETAILES,
    "        num_adms = %d.", *all_num_adms);
  ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_DETAILES+ 1,
    "        adms_ptr = %p.", * all_adms_ptr);
  CS_DAIG_RssAdmin (*all_num_adms,* all_adms_ptr);
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - ADM_load_without_rss function *@
 
/**************************************************************
*                                                             *
* Procedure Name   : ADM_time_to_str                          *
*                                                             *
* Description      : Get date & time in string                *
*                                                             *
* input            : time_int                                 *
* Output           : date_field                               *
*                  : time_field                               *
* Return Value     :                                          *
**************************************************************@
 
void ADM_time_to_str (time_t   * time_int,
                      DATE_typ   date_field,
                      TIME_typ   time_field)
{
  char                  fn[]="ADM_time_to_str";
  struct tm uxtime;
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
        "Time integer address is %p. , value is %d" ,
        time_int , *time_int);
 
  memcpy ((char *)&uxtime,
	      (char *)ConvertTimeToTMStruct (time_int, &uxtime),
		  sizeof (struct tm));
  from_time_tm_convert (&uxtime, date_field, time_field);
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
     "Time translated to: Date <%s> & Time <%s>" ,
      date_field , time_field);
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, ESA_RC_VOID);
}
end of WS10082A *********/
/****************************************************
 * Procedure Name: ADM_login_password_generate
 * Description   : Generate a random password (32 characters)
 * Output        : password
 * Return Value  : ESA_OK     upon success
 *               : ESA_FATAL  on any fail situation
 ****************************************************/
 
ESA_RC ADM_login_password_generate (char * passwd)
{
 
 ESA_RC                rc = ESA_OK;
 unsigned char         buffer[RAND_MAX_BUF];
 int                   buffer_len = 0;
 unsigned int          jj;
 unsigned char         random[ENC_HEX_DES_KEY_LEN];
 char                  hexa_random[(ENC_HEX_DES_KEY_LEN*2) + 1];
 ENC_BOOLEAN           enc_flag = ENC_FALSE;
 char                  fn[]="ADM_login_password_generate";
 ENVIRONMENT_rec_typ * envir_ptr;
 
 CS_get_envir_address (&envir_ptr);
 
 ESA_DIAG_enter ( ESA_COMP_ACSADM, DIAG_COMMON, fn );
 
 /***** Generate a weak random *****/
 
  ENC_gtrnd ( RAND_MIN_BUF,     /* minimum buffer length */
              RAND_MAX_BUF,     /* maximum buffer length */
              buffer,   /* buffer for result     */
              &buffer_len,      /* resulting buffer      */
              enc_flag);        /* not in a loop flag    */
 
  /**** Generate a ENC_HEX_DES_KEY_LEN (16) bytes real random ****/
 
  AR_make_random (buffer, buffer_len, random);
 
  /**** Convert to characters hex uppercased string ****/
 
  for (jj = 0; jj LT ENC_HEX_DES_KEY_LEN ; jj++)
       sprintf ( &hexa_random[jj*2],"%02X", random[jj]);
 
  hexa_random[(ENC_HEX_DES_KEY_LEN*2)]= '\0';
 
  strncpy (passwd, hexa_random, MIN(ENC_HEX_DES_KEY_LEN* 2,
           envir_ptr->rss_limits.max_pwd_len));
  *(passwd+ envir_ptr->rss_limits.max_pwd_len)= '\0';
 
/*  ESA_DIAG_printf ( ESA_COMP_ACSADM, 99, "passwd=%s", passwd);*/
 
  ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
 
  return rc;
 
} /* ADM_login_password_generate */
 
/********************************************************************
 * Procedure Name   : ADM_login_password_encrypt
 * Description      : Encrypt password using a des key
 * Input            : passwd    - string to encrypt
 * Output           : enc_passwd- Encrypted password
 *                  : enc_passwd_len - Length of the encryption password
 * Input assumptions:
 * Return Value     : ESA_RC
 * Side Effects     :
 *
 * Function description
 * ====================
 * The function is used to encrypt a password before it is written
 * to the password file
 *******************************************************************/
 
ESA_RC ADM_login_password_encrypt (char * passwd,
                                   char * enc_passwd,
                                   int  * enc_passwd_len)
{
 ESA_RC                rc= ESA_ERR;
 ENC_ERR_rec_typ       encryption_err;
 char                  fn[]="ADM_login_password_encrypt";
 ENVIRONMENT_rec_typ * envir_ptr;
 CS_get_envir_address (&envir_ptr);
 
 
 ESA_DIAG_enter ( ESA_COMP_ACSADM, DIAG_COMMON, fn );
/* ESA_DIAG_printf ( ESA_COMP_ACSADM, 99, "passwd=%s", passwd);*/
 
 if  ( (passwd EQ NULL) OR (enc_passwd EQ NULL) )
 {
     CTSAMSG_print (ERR_PASSWORD_EMPTY,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
     goto cleanup;
 }
 
 if (envir_ptr->encr_int_act EQ NOT_ACT_ENCR)
 {
    strcpy (enc_passwd, passwd);
    *enc_passwd_len= strlen (passwd);
	goto cleanup;
 }
 
 /**** Encrypt using crypt routine ****/
 *enc_passwd_len= PASSWORD_EXT;
 
 rc= ENC_encr(envir_ptr->enc_internal_handle,
              passwd,
              strlen(passwd),
              ENC_SMALLBUFF,
              enc_passwd,
              enc_passwd_len,
              &encryption_err);
 
 cleanup:
 if (rc NE ESA_OK)
     CS_encr_msg (&encryption_err);
 
 ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
 
 return rc;
 
} /* ADM_login_password_encrypt */
 
/********************************************************************
 * Procedure Name   : ADM_login_password_decrypt
 * Description      : Decrypt password using a des key
 * Input            : enc_passwd     - Buffer to decrypt
 *                  : enc_passwd_len - length of buffer to decrypt
 * Output           : passwd         - Decrypted buffer
 * Input assumptions:
 * Return Value     : ESA_RC
 * Side Effects     :
 *
 * Function description
 * ====================
 * The function is used to decrypt a password after it is read
 * from the password file
 *******************************************************************/
 
ESA_RC ADM_login_password_decrypt (char * enc_passwd,
                                   int    enc_passwd_len,
                                   char * passwd)
{
 ESA_RC                rc= ESA_OK;
 int                   result_len = 0;
 ENC_ERR_rec_typ       encryption_err;
 char                  fn[]="ADM_login_password_decrypt";
 ENVIRONMENT_rec_typ * envir_ptr;
 
 CS_get_envir_address (&envir_ptr);
 
 ESA_DIAG_enter ( ESA_COMP_ACSADM, DIAG_COMMON, fn );
 
 if  ( (passwd EQ NULL) OR (enc_passwd EQ NULL) )
 {
    CTSAMSG_print (ERR_PASSWORD_EMPTY,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
    rc = ESA_FATAL;
    goto exit;
 }
 
 if (envir_ptr->encr_int_act EQ NOT_ACT_ENCR)
 {
    memcpy (passwd, enc_passwd, enc_passwd_len);
    passwd[enc_passwd_len/2]= '\0';
	goto exit;
 }
 
 /**** Decrypt using crypt routine ****/
 
 rc= ENC_decr (envir_ptr->enc_internal_handle,
               enc_passwd,
               enc_passwd_len/2,
               ENC_SMALLBUFF, /*ENC_TRUE,*/
               passwd,
               &result_len,
               &encryption_err);
 if (rc NE ESA_OK)
 {
    CS_encr_msg (&encryption_err);
    goto exit;
 }
 
 /**** Convert buffer to string (add null character) *****/
 
 passwd[result_len] = '\0';
/* ESA_DIAG_printf ( ESA_COMP_ACSADM, 99, "passwd=%s", passwd);*/
 
 /**** Finish *****/
 
 exit:
 
 ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
 
 return rc;
 
} /* ADM_login_password_decrypt */
/*WS10082A RSSADM file is not used in MF
/********************************************************************
 * Procedure Name   : ADM_from_char_to_hexa
 * Description      : Convert char. string to hexa. string
 * Input            : char_str
 *                  : char_str_len
 * Output           : hexa_str
 *******************************************************************@
 
void ADM_from_char_to_hexa (char * char_str,
                            int    char_str_len,
                            char * hexa_str)
{
   int           ii;
   unsigned char charstr;
   char          hexachar[4];
   char          fn[]="ADM_from_char_to_hexa";
 
 
    ESA_DIAG_enter ( ESA_COMP_ACSADM, DIAG_COMMON, fn );
 
/*    ESA_DIAG_printf (ESA_COMP_ACSADM, 99,
                     "HEXA char_str=%.*s.",
                     char_str_len,
                     char_str);*@
 
    for (ii= 0; ii < char_str_len; ii++)
    {
       memset (hexachar, '0', 2);
	   hexachar[2]= '\0';
	   charstr= char_str[ii];
       sprintf (hexachar, "%02X", charstr);
       ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
                     "INT of char_str=%u.",
                     (unsigned int)char_str[ii]);
       memcpy (&hexa_str[ii*2], hexachar, 2);
       ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
                     "hexa_str=%.*s.",
					 (ii+1)*2,
                     hexa_str);
    }
 
    ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn,
                    ESA_RC_VOID);  /* STM1 *@
 
} /* ADM_from_char_to_hexa */
 
/********************************************************************
 * Procedure Name   : ADM_from_hexa_to_char
 * Description      : Convert hexa. string to char. string
 * Input            : hexa_str
 *                  : hexa_str_len
 * Output           : char_str
 *******************************************************************@
 
void ADM_from_hexa_to_char (char * hexa_str,
                            int    hexa_str_len,
                            char * char_str)
{
   int          ii;
   unsigned int hexaint;
   char         hexastr[3];
   char         fn[] = "ADM_from_hexa_to_char";
 
 
   ESA_DIAG_enter ( ESA_COMP_ACSADM, DIAG_COMMON, fn );
 
   ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
                     "hexa_str %.*s.",
                     hexa_str_len,
                     hexa_str);
 
   for (ii= 0; ii < hexa_str_len; ii +=2)
   {
      memcpy (hexastr, &hexa_str[ii], 2);
	  hexastr[2]= '\0';
      ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
                     "hexastr %s",
                     hexastr);
	  hexaint= 0;
      sscanf (hexastr, "%x" , &hexaint);
	  char_str[ii/2]= (char)hexaint;
      ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
                     "INT of hexaint %u=%c.",
                      (unsigned int)hexaint, char_str[ii/2]);
   }
 
   ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, ESA_RC_VOID);
}
 
/********************************************************************
 * Procedure Name   : ADM_add
 * Description      : Add administrator to file of administrators
 *                       (update if exists)
 * Input            : rss_name
 *                  : admin_name
 *                  : auto_pwd_change
 *                  : admin_passwd
 * Comments         :ver 2.0.1.1
 * Return Value     : ESA_RC
 *******************************************************************@
 
ESA_RC ADM_add (RSS_typ              rss_name ,
                USER_typ             admin_name,
                char                 auto_pwd_change,
                TIME_typ             change_interval,
                char               * admin_passwd)
{
 
   ESA_RC                  rc= ESA_OK;
   MEMBER_ADM_rec_typ      find_adm_rec;
   ADMINISTRATOR_rec_typ   adm_rec;
   char                    passwd[PASSWORD_EXT];
   int                     passwd_len;
   char                    fn[] = "ADM_add";
   ENVIRONMENT_rec_typ   * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
                     "RSS=%s Admin=%s Auto chg %c Interval %s.",
                     rss_name, admin_name, auto_pwd_change,
                     change_interval);
/*   ESA_DIAG_printf(ESA_COMP_ACSADM,99,"admin_passwd=%s",admin_passwd);*@
 
   /*Nitin-BSAN102162*@
   ESA_DIAG_printf(ESA_COMP_ACSADM,6,"Calling ADM_Load before adding admin from CS Process");
 
   rc=ADM_load();
 
   ESA_DIAG_printf(ESA_COMP_ACSADM,6,"The return value of ADM_Load is %d", rc);
 
 
 
   rc= ADM_find (rss_name, admin_name, &find_adm_rec);
   if (rc EQ ESA_OK)
   {
       rc= ADM_upd (rss_name, admin_name, auto_pwd_change,
                    change_interval, admin_passwd);
       goto cleanup;
   }
 
   memset ((char *)&adm_rec, ' ', sizeof (ADMINISTRATOR_rec_typ));
 
    /* Set RSS name *@
   strcpy (adm_rec.rss_name, rss_name);
 
    /* Set Password *@
   if (strlen (admin_passwd) NE 0)
   {
       if (envir_ptr->encr_int_act NE NOT_ACT_ENCR)
          rc=ADM_login_password_encrypt(admin_passwd,
                                        passwd, &passwd_len);
       else
       {
          strcpy (passwd, admin_passwd);
          passwd_len= strlen (admin_passwd);
       }
       ADM_from_char_to_hexa((char *)passwd,
                             passwd_len,
                             (char *)adm_rec.admin_passwd);
   }
   else
       passwd_len= 0;
 
    adm_rec.admin_passwd[passwd_len*2]= '\0';
    sprintf (adm_rec.passwd_len, "%03d", passwd_len*2);
 
    /* Set Auto change *@
    adm_rec.auto_pwd_change= auto_pwd_change;
 
    /* Set Interval *@
    strcpy (adm_rec.change_interval, change_interval);
 
    if (adm_rec.auto_pwd_change == ESS_NOT_SIGN)
       strcpy (adm_rec.change_interval, "000000");
 
    if (strcmp (adm_rec.change_interval, "000000") EQ 0)
       adm_rec.auto_pwd_change= ESS_NOT_SIGN;
 
    /* Set Administrator name *@
    rc= ADM_admin_name_for_cmp (rss_name, admin_name, admin_name);
    if (rc NE ESA_OK)
       goto cleanup;
    strcpy (adm_rec.admin_name, admin_name);
 
    /* Set last changed date & time *@
    CS_get_cur_time (adm_rec.last_changed_date,
                     adm_rec.last_changed_time);
 
    /* Update file of Administrators *@
    rc= ADM_record_maintenance (&adm_rec, ADM_RECORD_ADD);
    if (rc NE ESA_OK)
       goto cleanup;
 
    /* Load Data from updated file of Administrators *@
    rc= ADM_load();
 
    if (rc NE ESA_OK)
       CTSAMSG_print (ERR_ACCESS_USER,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      "adding", admin_name);
  cleanup:
    ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
    return (rc);
}
 
/********************************************************************
 * Procedure Name   : ADM_upd
 * Description      : Update administrator in file of administrators
 * Input            : rss_name
 *                  : admin_name
 *                  : auto_pwd_change
 *                  : admin_passwd
 * Comments         :ver 2.0.1.1
 * Return Value     : ESA_RC
 *******************************************************************@
 
ESA_RC ADM_upd (RSS_typ              rss_name ,
                USER_typ             admin_name,
                char                 auto_pwd_change,
                TIME_typ             change_interval,
                char               * admin_passwd)
{
 
   ESA_RC                  rc= ESA_OK;
   MEMBER_ADM_rec_typ      find_adm_rec;
   ADMINISTRATOR_rec_typ   adm_rec;
   char                    passwd[PASSWORD_EXT];
   int                     passwd_len;
   char                    fn[] = "ADM_upd";
   ENVIRONMENT_rec_typ   * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
    ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
    ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
                     "RSS=%s Admin=%s Auto chg %c Interval %s.",
                     rss_name, admin_name, auto_pwd_change,
                     change_interval);
/*    ESA_DIAG_printf(ESA_COMP_ACSADM,99,"admin_passwd=%s",admin_passwd);*@
 
    rc= ADM_find (rss_name, admin_name, &find_adm_rec);
    if (rc NE ESA_OK)
    {
       if (
             (strlen (admin_passwd) EQ 0)
            OR
             (admin_passwd[0] EQ '\\')
          )
       {
          CTSAMSG_print (ERR_NO_ADMIN,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 admin_name, rss_name, envir_ptr->file_administrators);
          rc= ESA_KEY_NOT_FOUND;
          goto cleanup;
       }
 
       rc= ADM_add (rss_name, admin_name, auto_pwd_change,
                    change_interval, admin_passwd);
       goto cleanup;
    }
    memset ((char *)&adm_rec, ' ', sizeof (ADMINISTRATOR_rec_typ));
 
    /* Set RSS name *@
    strcpy (adm_rec.rss_name, rss_name);
 
    /* Set Password *@
    if (
          (strlen (admin_passwd) NE 0)
         AND
          (admin_passwd[0] NE '\\')
       )
    {
       if (envir_ptr->encr_int_act NE NOT_ACT_ENCR)
          rc=ADM_login_password_encrypt(admin_passwd,
                                        passwd, &passwd_len);
       else
       {
          strcpy (passwd, admin_passwd);
          passwd_len= strlen (admin_passwd);
       }
       ADM_from_char_to_hexa ((char *)passwd,
                              passwd_len,
                              (char *)adm_rec.admin_passwd);
       adm_rec.admin_passwd[passwd_len*2]= '\0';
       sprintf (adm_rec.passwd_len, "%03d", passwd_len*2);
    }
    else if (admin_passwd[0] EQ '\\')
    {
       strcpy (adm_rec.admin_passwd, find_adm_rec.admin_passwd);
       sprintf (adm_rec.passwd_len, "%03d", find_adm_rec.passwd_len);
    }
    else
       sprintf (adm_rec.passwd_len, "%03d",(int)strlen(admin_passwd));
 
    /* Set Auto change *@
    if (
          (auto_pwd_change NE '\0')
         AND
          (auto_pwd_change NE '\\')
       )
       adm_rec.auto_pwd_change= auto_pwd_change;
    else
       adm_rec.auto_pwd_change= find_adm_rec.auto_pwd_change;
 
    /* Set Interval *@
    if (
          (strlen (change_interval) NE 0)
         AND
          (change_interval[0] NE '\\')
       )
       strcpy (adm_rec.change_interval, change_interval);
    else
       sprintf (adm_rec.change_interval,
                CHANGE_INTERVAL_FMT, /* STM1 *@
                find_adm_rec.change_interval);
 
    if (adm_rec.auto_pwd_change == ESS_NOT_SIGN)
       strcpy (adm_rec.change_interval, "000000");
 
    if (strcmp (adm_rec.change_interval, "000000") EQ 0)
       adm_rec.auto_pwd_change= ESS_NOT_SIGN;
 
    /* Set Administrator name *@
    strcpy (adm_rec.admin_name, admin_name);
 
    /* Set last changed date & time *@
    CS_get_cur_time (adm_rec.last_changed_date,
                     adm_rec.last_changed_time);
 
    /* Update file of Administrators *@
    rc= ADM_record_maintenance (&adm_rec, ADM_RECORD_UPD);
    if (rc NE ESA_OK)
       goto cleanup;
 
    /* Load Data from updated file of Administrators *@
    rc= ADM_load();
 
    if (rc NE ESA_OK)
       CTSAMSG_print (ERR_ACCESS_USER,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      "updating", admin_name);
 
  cleanup:
    ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
    return (rc);
}
 
/********************************************************************
 * Procedure Name   : ADM_del
 * Description      : Delete administrator from file of administrators
 * Input            : rss_name
 *                  : admin_name
 * Comments         :ver 2.0.1.1
 * Return Value     : ESA_RC
 *******************************************************************@
 
ESA_RC ADM_del (RSS_typ                 rss_name ,
                USER_typ                admin_name)
{
 
   ESA_RC                  rc= ESA_OK;
   MEMBER_ADM_rec_typ      find_adm_rec;
   ADMINISTRATOR_rec_typ   adm_rec;
   char                    fn[] = "ADM_del";
   ENVIRONMENT_rec_typ   * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
    ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
    ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
     "RSS=%s Admin=%s.", rss_name, admin_name);
 
    rc= ADM_find (rss_name, admin_name, &find_adm_rec);
    if (rc NE ESA_OK)
    {
       CTSAMSG_print (ERR_NO_ADMIN,
              envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
              envir_ptr->msg_admin_param.ctsamsg_dest,
              admin_name, rss_name, envir_ptr->file_administrators);
       rc= ESA_KEY_NOT_FOUND;
       goto cleanup;
    }
    memset ((char *)&adm_rec, ' ', sizeof (ADMINISTRATOR_rec_typ));
    strcpy (adm_rec.rss_name, rss_name);
    strcpy (adm_rec.admin_name, admin_name);
 
    rc= ADM_record_maintenance (&adm_rec, ADM_RECORD_DEL);
    if (rc NE ESA_OK)
       goto cleanup;
 
    rc= ADM_load();
 
    if (rc NE ESA_OK)
       CTSAMSG_print (ERR_ACCESS_ADMIN,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      "Deleted from Administrator file", admin_name);
 
  cleanup:
    ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
    return (rc);
}
 
/********************************************************************
 * Procedure Name   : ADM_get_passwd
 * Description      : Get password for administrator
 * Input            : rss_name
 * Input/Output     : admin_name
 * Output           : admin_passwd
 *                  : adm_member
 * Return Value     : ESA_RC
 *******************************************************************@
 
ESA_RC ADM_get_passwd (RSS_typ              rss_name ,
                       USER_typ             admin_name,
                       PASSWD_typ           admin_passwd,
                       MEMBER_ADM_rec_typ * out_adm_member)
{
 
   ESA_RC   rc= ESA_OK;
   int      enc_passwd_len;
   char     enc_passwd[PASSWORD_EXT+ 1];
   char     fn[] = "ADM_get_passwd";
   MEMBER_ADM_rec_typ  member_area;
   MEMBER_ADM_rec_typ  * adm_member = &member_area;
   ENVIRONMENT_rec_typ * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
     "RSS=%s Admin=%s.", rss_name, admin_name);
 
   rc= ADM_find (rss_name, admin_name, adm_member);
 
   if (rc NE ESA_OK)
   {
      if (
		   (
	 	     (envir_ptr->msg_ptr NE NULL)
            AND
		     (*envir_ptr->msg_ptr EQ ADMIN_SERVICE)
           )
		   OR
			(strcmp(envir_ptr->msg_admin_param.program_name, ESA_ACSADM)
			EQ 0)
         )
	  {
         admin_passwd[0]= '\0';
         rc= ESA_OK;
	  }
      else
        CTSAMSG_print (ERR_NO_ADMIN,
               envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
               envir_ptr->msg_admin_param.ctsamsg_dest,
               admin_name, rss_name, envir_ptr->file_administrators);
      goto cleanup;
   }
 
   enc_passwd_len= adm_member->passwd_len;
 
   ADM_from_hexa_to_char ((char *)adm_member->admin_passwd,
                          enc_passwd_len,
						  (char *)enc_passwd);
 
   ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
                    "RSS=%s Admin=%s Hexa pass %s.",
                    rss_name, admin_name, enc_passwd);
 
   if (envir_ptr->encr_int_act NE NOT_ACT_ENCR)
      rc= ADM_login_password_decrypt ((char *)enc_passwd,
                                      enc_passwd_len,
                                      (char *)admin_passwd);
   else
   {
      memcpy (admin_passwd, enc_passwd, enc_passwd_len);
      admin_passwd[enc_passwd_len/2]= '\0';
   }
 
   ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
                    "RSS=%s Admin=%s.", rss_name, admin_name);
/* ESA_DIAG_printf(ESA_COMP_ACSADM,99,"admin_passwd=%s",admin_passwd);*@
   if (rc NE ESA_OK)
   {
      CTSAMSG_print (ERR_ACCESS_ADMIN,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     "Decrypt password for ", admin_name);
      goto cleanup;
   }
cleanup:
   if (out_adm_member)
       memcpy (out_adm_member, adm_member,
               sizeof (MEMBER_ADM_rec_typ));
   ESA_DIAG_exit ( ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
   return (rc);
}
end of WS10082A **********/
/**********************************************************************
*                                                                     *
* Procedure Name : ADM_admin_name_for_cmp                             *
*                                                                     *
* Description    : Convert name of the admininistrator to Upercase    *
*                  if ADMIN_CASE_SENC is not sencetive for the RSS    *
* Input          : rss_name                                           *
*                : admin_name                                         *
* Input/Output   : admin_name_for_cmp                                 *
* Return Value   : ESA_RC : ESA_ERR if parameter ADMIN_CASE_SENC is   *
*                      found for RSS rss_name                         *
**********************************************************************/
 
EXT ESA_RC ADM_admin_name_for_cmp (RSS_typ    rss_name,
                                   USER_typ   admin_name_for_cmp,
                                   USER_typ   admin_name)
{
  ESA_RC                rc= ESA_OK;
  char                  case_sensitive[RSSPRM_VALUE_LEN+ 1];
  ENVIRONMENT_rec_typ * envir_ptr;
  char fn[]="ADM_admin_name_for_cmp";
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON+ 1, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  rc= rssprm_get_opt (rss_name,
                      ADMIN_CASE_SENSITIVE,
                      1,
                      case_sensitive,
                      OPT_TRUE,
                      OPT_TRUE);
  if (rc NE ESA_OK)
  {
     case_sensitive[0]= ESS_YES_SIGN;
     rc= ESA_OK;
  }
 
  if (case_sensitive[0] EQ ESS_NOT_SIGN)
     CSupper ((char *)admin_name, (char *)admin_name_for_cmp);
  else
     strcpy (admin_name_for_cmp, admin_name);
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON+ 1, fn, rc);
  return (rc);
}
 
/****************************************************
 * Procedure Name: ADM_loginout
 * Description   : login/logout to/from the RSS security system
 *                     before/after api func
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function activates "administrator" login/logout on behalf
 * of specific RSS. The login is activated right befor activation of
 * API actual call to ESAAPI function and the logout is activated
 * right after it. There are two exceptions for that - the Download &
 * Global-sync activities - that uses the API in loop. In such cases
 * the login is called before the loop, and right AFTER each LOG EVENT
 * registration, and the logout is called at the loop end and right
 * before LOG EVENT registration (in queue).
 * The function verifies that the process is NOT logged into the RSS
 * - in case login requested; and that the process is indeed logged
 * into the RSS - in case logout requested.
 ********************************************************************/
 
ESA_RC ADM_loginout (LOGIN_MODE_typ         login_mode,
                     LOGIN_ADMIN_TYPE_typ   admin_type,
                     char                 * func_name)
{
  char                    fn[]="ADM_loginout";
  ESA_RC                  rc= ESA_OK, rc_def= ESA_OK;
  char                    err_msg_text [ERR_MSG_TEXT_LEN];
  time_t                  current_time;
  double                  diff_time= 0, def_diff_time= 0;
  USER_PARAMS_rec_typ     user_prm;
/*ADDINFO_rec_typ         addinfo, * addinfo_ptr;          *WS10082K*/
  ERR_STRUCT_rec_typ    * err_msg = NULL;
  TIME_typ                change_interval, def_change_interval;
  USER_typ                logon_admin;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
        "Input: login_mode %d Admin_type %d func_name %s.",
         (int)login_mode, (int)admin_type, func_name);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
        "admin: rss=%s admin=%s gname=%s.",
         envir_ptr->msg_admin_param.rss_name,
		 envir_ptr->msg_admin_param.admin_uname,
         envir_ptr->msg_admin_param.admin_gname);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
        "envir: rss=%s admin=%s def_admin=%s group=%s mode=%d.",
  		 envir_ptr->login_rss,
         envir_ptr->login_admin,
         envir_ptr->login_def_admin,
 		 envir_ptr->login_group,
         (int)envir_ptr->login_mode);
 
  change_interval[0]= '\0';
  def_change_interval[0]= '\0';
 
  /*
    FIRST LOGIN MODE .
  */
  if (login_mode EQ LOGIN_MODE_FIRST)
  {
     if (envir_ptr->login_mode NE LOGOUT_MODE_LAST)
     {
        if (strlen (envir_ptr->login_def_admin) NE 0)
        {
           ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogout USA-API for rss=%s def.adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_def_admin,
			envir_ptr->empty_ug,"LOGOUT_MODE_LAST", LOGOUT_MODE_LAST);
           rc_def=envir_ptr->func_ptr.rss_logout_ptr(
                                  envir_ptr->login_rss,
                                  envir_ptr->login_def_admin,
                                  envir_ptr->empty_ug,
                                  LOGOUT_MODE_LAST,
                                  &envir_ptr->handle_def_login,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
           ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
			rc_def, (rc_def EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_def_login);
          envir_ptr->msg_admin_param.login_handle= NULL; /*BSAN101128*/
          CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        }
        /* Logout ESS administrator */
        if (strlen (envir_ptr->login_admin) NE 0)
        {
           ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogout USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_admin, envir_ptr->login_group,
			"LOGOUT_MODE_LAST", LOGOUT_MODE_LAST);
           rc= envir_ptr->func_ptr.rss_logout_ptr(envir_ptr->login_rss,
                                  envir_ptr->login_admin,
                                  envir_ptr->login_group,
                                  LOGOUT_MODE_LAST,
                                  &envir_ptr->handle_login,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
           ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_login);
          envir_ptr->msg_admin_param.login_handle= NULL; /*BSAN101128*/
          CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
      }
     }
     envir_ptr->login_def_admin[0]= '\0';
     envir_ptr->login_admin[0]    = '\0';
     envir_ptr->login_group[0]    = '\0';
     envir_ptr->login_rss[0]      = '\0';
     envir_ptr->login_mode        = LOGOUT_MODE_LAST;
 
     /*
        Exist Default administrator
     */
     if (strlen (envir_ptr->msg_admin_param.def_admin) NE 0)
     {
        rc= ADM_admin_name_for_cmp (
                 envir_ptr->msg_admin_param.rss_name,
                 envir_ptr->login_def_admin,
                 envir_ptr->msg_admin_param.def_admin);
        ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
        "ADM_admin_name_for_cmp rss=%s def.adm login/msg=%s/%s rc=%d.",
		                 envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->login_def_admin,
						 envir_ptr->msg_admin_param.def_admin,
                         (int)rc);
        if (rc NE ESA_OK)
		{
           strcpy (envir_ptr->login_def_admin , "");
           goto cleanup;
		}
           /* FIRST LOGIN into the RSS by Default administrator*/
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogin USA-API for rss=%s def.adm=%s ug=%s mode=%s(%d).",
			envir_ptr->msg_admin_param.rss_name, envir_ptr->login_def_admin,
			envir_ptr->empty_ug,"LOGIN_MODE_FIRST", LOGIN_MODE_FIRST);
/*        ESA_DIAG_printf (ESA_COMP_ACSADM, 99, "pwd=%s",
                         envir_ptr->msg_admin_param.def_admin_passwd);*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        rc = envir_ptr->func_ptr.rss_login_ptr (
                         envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->login_def_admin,
                         envir_ptr->empty_ug,
                         envir_ptr->msg_admin_param.def_admin_passwd,
                         LOGIN_MODE_FIRST,
                         &envir_ptr->handle_def_login,
                         &envir_ptr->msg_admin_param,
                         &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogin USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_def_login);
        if (rc EQ ESA_NOT_SUPP)
            rc= ESA_OK;
 
        if (rc NE ESA_OK)
        {
           strcpy (envir_ptr->login_def_admin , "");
           goto cleanup;
        }
 
        envir_ptr->login_mode= LOGIN_MODE_FIRST;
        envir_ptr->msg_admin_param.login_handle=
            envir_ptr->handle_def_login;
        strcpy (envir_ptr->login_rss,
                envir_ptr->msg_admin_param.rss_name);
        if (envir_ptr->def_adm_member.auto_pwd_change EQ ESS_YES_SIGN)
        {
           time (&current_time);
           def_diff_time= difftime(current_time,
            (time_t)envir_ptr->adm_member.date_of_last_change);/*STM1*/
        }
     }
 
     /*
        Exist ESS administrator that not equal to Default admin.
     */
 
     rc= ADM_admin_name_for_cmp (
             envir_ptr->msg_admin_param.rss_name,
             envir_ptr->login_admin,
             envir_ptr->msg_admin_param.admin_uname);
 
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
        "ADM_admin_name_for_cmp rss=%s adm login/msg=%s/%s rc=%d.",
		                 envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->login_admin,
						 envir_ptr->msg_admin_param.admin_uname,
                         (int)rc);
 
     if (rc NE ESA_OK)
        goto cleanup;
 
     if (
         (strlen(envir_ptr->msg_admin_param.admin_uname) NE 0)
             AND
             (strcmp (envir_ptr->login_def_admin,
                      envir_ptr->login_admin) NE 0)
         )
     {
 
        /* FIRST LOGIN into the RSS by ESS administrator.  */
 
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogin USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
			envir_ptr->msg_admin_param.rss_name,
			envir_ptr->msg_admin_param.admin_uname,
			envir_ptr->msg_admin_param.admin_gname,
			"LOGIN_MODE_FIRST", LOGIN_MODE_FIRST);
/*        ESA_DIAG_printf (ESA_COMP_ACSADM, 99, "pwd=%s.",
                         envir_ptr->msg_admin_param.admin_passwd);*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        rc = envir_ptr->func_ptr.rss_login_ptr (
                          envir_ptr->msg_admin_param.rss_name,
                          envir_ptr->msg_admin_param.admin_uname,
                          envir_ptr->msg_admin_param.admin_gname,
                          envir_ptr->msg_admin_param.admin_passwd,
                          LOGIN_MODE_FIRST,
                          &envir_ptr->handle_login,
                          &envir_ptr->msg_admin_param,
                          &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogin USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_login);
 
        if (rc EQ ESA_NOT_SUPP)
           rc= ESA_OK;
 
        if (rc NE ESA_OK)
        {
            strcpy (envir_ptr->login_admin , "");
           goto cleanup;
        }
 
        envir_ptr->login_mode= LOGIN_MODE_FIRST;
        envir_ptr->msg_admin_param.login_handle=
            envir_ptr->handle_login;
        strcpy (envir_ptr->login_rss,
            envir_ptr->msg_admin_param.rss_name);
        strcpy (envir_ptr->login_admin,
            envir_ptr->msg_admin_param.admin_uname);
        strcpy (envir_ptr->login_group,
            envir_ptr->msg_admin_param.admin_gname);
        if (envir_ptr->adm_member.auto_pwd_change EQ ESS_YES_SIGN)
        {
           time (&current_time);
           diff_time= difftime(current_time,
           (time_t)envir_ptr->adm_member.date_of_last_change);/*STM1*/
        }
     }
     else
        envir_ptr->login_admin[0]= '\0';
 
     if (
         (strlen (envir_ptr->login_def_admin) EQ 0)
             AND
         (strlen (envir_ptr->login_admin) EQ 0)
         )
     {
        envir_ptr->login_mode= LOGIN_MODE_FIRST;
        strcpy (envir_ptr->login_rss,
            envir_ptr->msg_admin_param.rss_name);
     }
     /*
        Need not change paasword
     */
     if (
         (diff_time LE
		  (double)(envir_ptr->adm_member.change_interval * 60))
             AND
         (def_diff_time LE
          (double)(envir_ptr->def_adm_member.change_interval * 60))
         )
        goto cleanup;
  }
 
  /*
     LOGIN MODE or First LOGIN MODE.
  */
 
  if (
      (login_mode EQ LOGIN_MODE)
          OR
      (login_mode EQ LOGIN_MODE_FIRST)
      )
  {
     if (
         (login_mode EQ LOGIN_MODE)
             AND
             (
              (envir_ptr->login_mode EQ LOGIN_MODE)
             OR
              (envir_ptr->login_mode EQ LOGOUT_MODE_LAST)
             )
         )
     {
        CTSAMSG_print (ERR_CS_LOGIN_INV_REQ,
                       envir_ptr->msg_admin_param.ctsamsg_handle,
                       NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       fn, func_name);
        if (envir_ptr->login_mode EQ LOGIN_MODE)
           goto cleanup;
        else
        {
           rc= ESA_ERR;
           goto cleanup;
        }
     }
 
     /*
       Impersonate Default administrator (LOGIN).
     */
     if (
           (strlen (envir_ptr->login_def_admin) NE 0)
          AND
           (
               (admin_type EQ LOGIN_DEFAULT_ADMIN)
              OR
               (
                  (login_mode EQ LOGIN_MODE_FIRST)
                 AND
                  (def_diff_time GT
           (double)(envir_ptr->def_adm_member.change_interval * 60))
               )
              OR
               (
                  (strlen (envir_ptr->login_admin) EQ 0)
                 AND
                  (admin_type EQ LOGIN_ESS_ADMIN)
               )
           )
        )
     {
 
        strcpy (logon_admin, envir_ptr->login_def_admin);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogin USA-API for rss=%s def.adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_def_admin,
			envir_ptr->empty_ug, "LOGIN_MODE", LOGIN_MODE);
/*        ESA_DIAG_printf (ESA_COMP_ACSADM, 99, "pwd=%s.",
                         envir_ptr->msg_admin_param.def_admin_passwd);*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        rc = envir_ptr->func_ptr.rss_login_ptr (envir_ptr->login_rss,
                        envir_ptr->login_def_admin,
                        envir_ptr->empty_ug,
                        envir_ptr->msg_admin_param.def_admin_passwd,
                        LOGIN_MODE,
                        &envir_ptr->handle_def_login,
                        &envir_ptr->msg_admin_param,
                        &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogin USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_def_login);
        if (rc EQ ESA_NOT_SUPP)
           rc= ESA_OK;
 
        if (rc NE ESA_OK)
           goto cleanup;
 
        envir_ptr->msg_admin_param.login_handle=
            envir_ptr->handle_def_login;
     }
 
     /*
       Impersonate ESS administrator (LOGIN).
     */
     if (
           (strlen (envir_ptr->login_admin) NE 0)
          AND
           (
              (admin_type EQ LOGIN_ESS_ADMIN)
             OR
              (
                 (login_mode EQ LOGIN_MODE_FIRST)
                AND
                 (diff_time GT
                   (double)(envir_ptr->adm_member.change_interval*60))
              )
          /*   OR
              (
                 (strlen (envir_ptr->login_def_admin) EQ 0)
                AND
                 (admin_type EQ LOGIN_DEFAULT_ADMIN)
              ) */
           )
        )
     {
        strcpy (logon_admin, envir_ptr->login_admin);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogin USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_admin,
			envir_ptr->login_group, "LOGIN_MODE", LOGIN_MODE);
/*        ESA_DIAG_printf (ESA_COMP_ACSADM, 99, "pwd=%s.",
                         envir_ptr->msg_admin_param.admin_passwd);*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        rc = envir_ptr->func_ptr.rss_login_ptr (envir_ptr->login_rss,
                               envir_ptr->login_admin,
                               envir_ptr->login_group,
                               envir_ptr->msg_admin_param.admin_passwd,
                               LOGIN_MODE,
                               &envir_ptr->handle_login,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogin USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_login);
 
        if (rc EQ ESA_NOT_SUPP)
           rc= ESA_OK;
 
        if (rc NE ESA_OK)
           goto cleanup;
 
        envir_ptr->msg_admin_param.login_handle=
            envir_ptr->handle_login;
     }
 
     envir_ptr->login_mode= LOGIN_MODE;
 
     err_msg_text[0]= '\0';
 
     rc= ESA_DIAG_check (err_msg_text);
     if (rc NE ESA_OK)
     {
        rc = ESA_OK;
        CTSAMSG_print (ERR_CS_LOGIN_DIAG,
                       envir_ptr->msg_admin_param.ctsamsg_handle,
                       NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       func_name,
                       CG_name (envir_ptr->p_main_name));
        ESA_DIAG_deactivate ();
     }
     if (login_mode EQ LOGIN_MODE)
        goto cleanup;
  }
 
  /*** WS10082A drop this code as RSSADM file is not used in MF ***
  if (login_mode EQ LOGIN_MODE_FIRST)
  {
     /*
       Change PASSWORD of Default administrator (when FIRST LOGIN MODE)
     *@
     if (def_diff_time GT
         (double)(envir_ptr->def_adm_member.change_interval * 60))
     {
        ADM_login_password_generate
          (envir_ptr->msg_admin_param.def_admin_passwd);
        err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
        ERROR_CLEAR(err_msg);
        memset((char *)&user_prm, NULL_CHAR,
               sizeof(USER_PARAMS_rec_typ));
        memset((char *)&addinfo, NULL_CHAR, sizeof(ADDINFO_rec_typ));
        /*WS10082K - Check this *@
        addinfo.num_pairs= 0;
        addinfo.max_pairs= 0;
        strcpy (user_prm.user, envir_ptr->def_adm_member.admin_name);
        strcpy (user_prm.passwd,
                envir_ptr->msg_admin_param.def_admin_passwd);
        user_prm.parent_oe[0]= BACKSLASH;
        user_prm.def_group[0]= BACKSLASH;
        user_prm.passwd_life=  PASS_LIFE_PERMANENT;
        user_prm.rev_status=   USER_STAT_IGNORED;
        user_prm.user_admin=   USER_ADM_ADMIN;
        user_prm.def_ug_action=OLD_DEF_UG_ACT_IGNORED;
 
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	     		"    -> Call to CTSUpdPassword USA-API for user %s.",user_prm.user);
		addinfo_ptr= &addinfo;
        CS_DIAG_USER (ESA_COMP_ACSADM, DIAG_BASIC,&user_prm,
				            &addinfo_ptr, NULL, 0, TRUE);
        rc= envir_ptr->func_ptr.updpass_ptr(&user_prm, &addinfo,
                                 &envir_ptr->msg_admin_param, err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	     		"    <- CTSUpdPassword USA-API completed with rc=%d (%s)",
		      rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        CS_DIAG_USER (ESA_COMP_ACSADM, DIAG_BASIC,&user_prm,
				            &addinfo_ptr, NULL, 0, TRUE);
        if (rc EQ ESA_OK)
           sprintf (def_change_interval,
                    CHANGE_INTERVAL_FMT, /* STM1 *@
                    envir_ptr->def_adm_member.change_interval);
        else
           goto cleanup;
     }
 
     /*
       Change PASSWORD of ESS administrator (when FIRST LOGIN MODE)
     *@
     if (diff_time GT
            (double)(envir_ptr->adm_member.change_interval * 60))
     {
        ADM_login_password_generate
            (envir_ptr->msg_admin_param.admin_passwd);
        err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
        ERROR_CLEAR(err_msg);
        memset((char *)&user_prm, NULL_CHAR,
               sizeof(USER_PARAMS_rec_typ));
        memset((char *)&addinfo, NULL_CHAR, sizeof(ADDINFO_rec_typ));
        addinfo.num_pairs= 0;
        addinfo.max_pairs= 0;
        strcpy (user_prm.user, envir_ptr->adm_member.admin_name);
        strcpy (user_prm.passwd,
                envir_ptr->msg_admin_param.admin_passwd);
        user_prm.parent_oe[0]= BACKSLASH;
        user_prm.def_group[0]= BACKSLASH;
        user_prm.passwd_life=  PASS_LIFE_PERMANENT;
        user_prm.rev_status=   USER_STAT_IGNORED;
        user_prm.user_admin=   USER_ADM_ADMIN;
        user_prm.def_ug_action=OLD_DEF_UG_ACT_IGNORED;
 
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	     		"    -> Call to CTSUpdPassword USA-API for user %s.",user_prm.user);
		addinfo_ptr= &addinfo;
        CS_DIAG_USER (ESA_COMP_ACSADM, DIAG_BASIC,&user_prm,
				            &addinfo_ptr, NULL, 0, TRUE);
        rc= envir_ptr->func_ptr.updpass_ptr(&user_prm, &addinfo,
                                       &envir_ptr->msg_admin_param,
                        err_msg);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	     		"    <- CTSUpdPassword USA-API completed with rc=%d (%s)",
		      rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        CS_DIAG_USER (ESA_COMP_ACSADM, DIAG_BASIC,&user_prm,
				            &addinfo_ptr, NULL, 0, TRUE);
        if (rc EQ ESA_OK)
           sprintf (change_interval, CHANGE_INTERVAL_FMT,  /* STM1 *@
                    envir_ptr->adm_member.change_interval);
        else
           goto cleanup;
     }
  }
  *** end of WS10082A ***/
  /*
     LOGOUT MODE or First LOGIN MODE.
  */
 
  if (
      (login_mode EQ LOGOUT_MODE)
          OR
      (login_mode EQ LOGIN_MODE_FIRST)
      )
  {
 
     if (
           (strlen (envir_ptr->login_def_admin) NE 0)
          AND
           (
              (admin_type EQ LOGIN_DEFAULT_ADMIN)
             OR
              (
                 (login_mode EQ LOGIN_MODE_FIRST)
                AND
                 (def_diff_time GT
           (double)(envir_ptr->def_adm_member.change_interval * 60))
              )
             OR
              (
                 (strlen (envir_ptr->login_admin) EQ 0)
                AND
                 (admin_type EQ LOGIN_ESS_ADMIN)
              )
           )
        )
     {
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogout USA-API for rss=%s def.adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_def_admin,
			envir_ptr->empty_ug, "LOGOUT_MODE", LOGOUT_MODE);
        rc = envir_ptr->func_ptr.rss_logout_ptr (envir_ptr->login_rss,
                                  envir_ptr->login_def_admin,
                                  envir_ptr->empty_ug,
                                  LOGOUT_MODE,
                                  &envir_ptr->handle_def_login,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_def_login);
        envir_ptr->msg_admin_param.login_handle= NULL; /*BSAN101128*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        if (rc EQ ESA_NOT_SUPP)
           rc= ESA_OK;
 
        if (rc NE ESA_OK)
           goto cleanup;
 
     }
 
     if (
           (strlen (envir_ptr->login_admin) NE 0)
          AND
           (
              (admin_type EQ LOGIN_ESS_ADMIN)
             OR
              (
                 (login_mode EQ LOGIN_MODE_FIRST)
                AND
                 (diff_time GT
                  (double)(envir_ptr->adm_member.change_interval*60))
              )
          /*   OR
              (
                 (strlen (envir_ptr->login_def_admin) EQ 0)
                AND
                 (admin_type EQ LOGIN_DEFAULT_ADMIN)
              ) */
           )
        )
     {
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogout USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_admin,
			envir_ptr->login_group, "LOGOUT_MODE", LOGOUT_MODE);
        rc = envir_ptr->func_ptr.rss_logout_ptr (envir_ptr->login_rss,
                                     envir_ptr->login_admin,
                                     envir_ptr->login_group,
                                     LOGOUT_MODE,
                                     &envir_ptr->handle_login,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_login);
        envir_ptr->msg_admin_param.login_handle= NULL; /*BSAN101128*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
 
        if (rc EQ ESA_NOT_SUPP)
           rc= ESA_OK;
 
        if (rc NE ESA_OK)
           goto cleanup;
 
     }
 
     envir_ptr->login_mode= LOGOUT_MODE;
     ESA_DIAG_activate ();
     if (login_mode EQ LOGOUT_MODE)
        goto cleanup;
  }
  /*WS10082A RSSADM file is not used in MF
  if (login_mode EQ LOGIN_MODE_FIRST)
  {
     /*
       Change PASSWORD in File of administrators)
     *@
     if (def_diff_time GT
         (double)(envir_ptr->def_adm_member.change_interval * 60))
        rc= ADM_upd(envir_ptr->msg_admin_param.rss_name,
                    envir_ptr->def_adm_member.admin_name,
                    envir_ptr->def_adm_member.auto_pwd_change,
                    def_change_interval,
                    envir_ptr->msg_admin_param.def_admin_passwd);
 
     if (diff_time GT
            (double)(envir_ptr->adm_member.change_interval * 60))
        rc= ADM_upd(envir_ptr->msg_admin_param.rss_name,
                    envir_ptr->adm_member.admin_name,
                    envir_ptr->adm_member.auto_pwd_change,
                    change_interval,
                    envir_ptr->msg_admin_param.admin_passwd);
     goto cleanup;
  }
  end of WS10082A ***********/
  /*
    LAST LOGOUT MODE .
  */
 
  if (login_mode EQ LOGOUT_MODE_LAST)
  {
     if (strlen (envir_ptr->login_def_admin) NE 0)
     {
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogout USA-API for rss=%s def.adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_def_admin,
			envir_ptr->empty_ug,"LOGOUT_MODE_LAST", LOGOUT_MODE_LAST);
        rc_def= envir_ptr->func_ptr.rss_logout_ptr(
                                  envir_ptr->login_rss,
                                  envir_ptr->login_def_admin,
                                  envir_ptr->empty_ug,
                                  LOGOUT_MODE_LAST,
                                  &envir_ptr->handle_def_login,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogout USA-API  completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_def_login);
        envir_ptr->msg_admin_param.login_handle= NULL; /*BSAN101128*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        envir_ptr->login_def_admin[0]= '\0';
     }
     /* Logout ESS administrator */
     if (strlen (envir_ptr->login_admin) NE 0)
     {
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
	    	"    -> Call to CTSRSSLogout USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
			envir_ptr->login_rss, envir_ptr->login_admin,
			envir_ptr->login_group,"LOGOUT_MODE_LAST", LOGOUT_MODE_LAST);
        rc= envir_ptr->func_ptr.rss_logout_ptr(envir_ptr->login_rss,
                                  envir_ptr->login_admin,
                                  envir_ptr->login_group,
                                  LOGOUT_MODE_LAST,
                                  &envir_ptr->handle_login,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC,
			"    <- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			envir_ptr->handle_login);
        envir_ptr->msg_admin_param.login_handle= NULL; /*BSAN101128*/
        CS_DIAG_ADMINPRM (ESA_COMP_ACSADM, DIAG_COMMON+ 1, FALSE);
        envir_ptr->login_admin[0]= '\0';
        envir_ptr->login_group[0]= '\0';
     }
 
     envir_ptr->login_mode= LOGOUT_MODE_LAST;
     envir_ptr->login_rss[0]=       '\0';
     goto cleanup;
  }
 
  CTSAMSG_print (ERR_CS_NBR2STR,
                 envir_ptr->msg_admin_param.ctsamsg_handle,
                 NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 func_name, C_LOGINOUT, login_mode);
  rc= ESA_ERR;
 
cleanup:
  if (rc NE ESA_OK)
     strcpy (envir_ptr->login_group, "???");
 
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - ADM_loginout function */
/*WS10082A RSSADM file is not used in MF
/**************************************************************
*                                                             *
* Procedure Name   : ADM_fill_admin_changes                   *
*                                                             *
* Description      : Fill fields:                             *
*                   admin_passwd, def_admin, def_admin_passwd *
*   			    in env.msg_admin_params structure         *
* Input              fill def_admin & def_admin_passwd  0/1   *
*                    fill admin_passwd                  0/1   *
* Return Value     : ESA_RC                                   *
*                                                             *
**************************************************************@
 
ESA_RC ADM_fill_admin_changes (OPTION_typ    fill_def_admin,
                               OPTION_typ    fill_admin)
{
  char                  fn[]="ADM_fill_admin_changes";
  ESA_RC                rc = ESA_OK;
  char                  prm_value[RSSPRM_VALUE_LEN+ 1];
  char                  prm_name [RSSPRM_NAME_LEN+ 1];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
       "fill: def_admin=%s/%d admin=%s/%d rss=%s type=%s gname=%s.",
        envir_ptr->msg_admin_param.def_admin, (int)fill_def_admin,
        envir_ptr->msg_admin_param.admin_uname, (int)fill_admin,
        envir_ptr->msg_admin_param.rss_name,
        envir_ptr->msg_admin_param.rss_type,
        envir_ptr->msg_admin_param.admin_gname);
  prm_value[0]= '\0';
 
  /* BS10100 - We are reseting password before this method *
  if (fill_admin EQ OPT_TRUE)
     strcpy (envir_ptr->msg_admin_param.admin_passwd, "");
  *@
  if (strlen (envir_ptr->msg_admin_param.rss_name) EQ 0)
      goto cleanup;
 
  if (fill_def_admin EQ OPT_TRUE)
  {
     strcpy (envir_ptr->msg_admin_param.def_admin, "");
     strcpy (envir_ptr->msg_admin_param.def_admin_passwd, "");
 
     rc= rssprm_get (envir_ptr->msg_admin_param.rss_name,
                     ADMIN_USER_REQUEST ,
                     1,
                     prm_value);
     if (rc NE ESA_OK)
        goto cleanup;
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "ADMIN_USER_REQUEST=%s.", prm_value);
 
 
     if (prm_value[0] EQ ESS_YES_SIGN) {
 
        if (envir_ptr->p_main_name EQ ESA_ACS_PROC)
            strcpy (prm_name, DEFAULT_CS_ADMINISTRATOR);
        if (envir_ptr->p_main_name EQ ESA_ACD_PROC)
            strcpy (prm_name, DEFAULT_CD_ADMINISTRATOR);
 
        rc= rssprm_get_opt (envir_ptr->msg_admin_param.rss_name,
                       prm_name,
                       MAX_RSS_USER_NAME_LEN,
                       prm_value,
                       OPT_TRUE,
                       OPT_FALSE);
        if (rc NE ESA_OK)
           rc= rssprm_get(envir_ptr->msg_admin_param.rss_name,
                          DEFAULT_ADMINISTRATOR,
                          MAX_RSS_USER_NAME_LEN,
                          prm_value);
        if (rc NE ESA_OK)
           goto cleanup;
        ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
          "prm_value=%s.", prm_value);
 
        strcpy (envir_ptr->msg_admin_param.def_admin,
                prm_value);
 
        ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
            "ADM_admin_name_for_cmp def_admin=%s.",
             envir_ptr->msg_admin_param.def_admin);
     }
     else
     {
     /*Nitin 12 Dec 2005*@
        fill_def_admin= OPT_FALSE;
        strcpy (envir_ptr->msg_admin_param.def_admin,
        "");
     }
  }
 
  if (strlen (envir_ptr->file_administrators) EQ 0)
      goto cleanup;
 
  rc= rssprm_get (envir_ptr->msg_admin_param.rss_name,
                  ADMIN_FILE_REQUEST,
                  1,
                  prm_value);
  if (
        (rc NE ESA_OK)
       OR
        (prm_value[0] NE ESS_YES_SIGN)
     )
     goto cleanup;
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "ADMIN_FILE_REQUEST=%s.", prm_value);
 
  if (
        (fill_admin EQ OPT_TRUE)
       AND
        (strlen (envir_ptr->msg_admin_param.admin_uname) NE 0)
     )
  {
     rc= ADM_get_passwd (envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->msg_admin_param.admin_uname,
                         envir_ptr->msg_admin_param.admin_passwd,
                         &envir_ptr->adm_member);
 
     if (rc NE ESA_OK)
        goto cleanup;
 
     ESA_DIAG_printf (ESA_COMP_ACSADM, 33,
                   "Rss=%s type=%s admin=%s rc=%d.",
                    envir_ptr->msg_admin_param.rss_name,
                    envir_ptr->msg_admin_param.rss_type,
                    envir_ptr->msg_admin_param.admin_uname,
                    (int)rc);
  }
 
  if (fill_def_admin EQ OPT_TRUE)
  {
        rc= ADM_get_passwd (envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->msg_admin_param.def_admin,
                         envir_ptr->msg_admin_param.def_admin_passwd,
                         &envir_ptr->def_adm_member);
 
        if (rc NE ESA_OK)
           goto cleanup;
 
        ESA_DIAG_printf (ESA_COMP_ACSADM, 33,
                     "Rss=%s type=%s def_admin=%s rc=%d.",
                      envir_ptr->msg_admin_param.rss_name,
                      envir_ptr->msg_admin_param.rss_type,
                      envir_ptr->msg_admin_param.def_admin,
                      (int)rc);
  }
 
cleanup:
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, 33,
       "def_admin=<%s> admin=<%s> rss=%s type=%s gname=%s.",
        envir_ptr->msg_admin_param.def_admin,
        envir_ptr->msg_admin_param.admin_uname,
        envir_ptr->msg_admin_param.rss_name,
        envir_ptr->msg_admin_param.rss_type,
        envir_ptr->msg_admin_param.admin_gname);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
  return (rc);
}
 
/***************************************************************
*                                                              *
* Procedure Name : ADM_admin_is_def_admin                      *
*                                                              *
* Description    : If administrator is is an administrator     *
*                                                              *
* Input          rss_name                                      *
*                admin                                         *
*                                                              *
* Return Value  : ESA_RC == ESA_OK  if admin is a def_admin    *
*               :        == ESA_EOF if admin is not a def_admin*
*                        == ESA_ERR in other case              *
***************************************************************@
 
ESA_RC ADM_admin_is_def_admin (RSS_typ     rss_name,
                               USER_typ    admin)
{
  char                 fn [] = "ADM_admin_is_def_admin";
  ESA_RC               rc_lcl = ESA_OK, rc= ESA_EOF;
  USER_typ             wrk_admin, def_admin, del_admin;
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
       "rss=%s admin=%s.",
        rss_name, admin);
 
  rc_lcl= rssprm_get (rss_name,                 /*after 3.0.1*@
                      ADMIN_USER_REQUEST,       /*after 3.0.1*@
                      1,                        /*after 3.0.1*@
                      wrk_admin);               /*after 3.0.1*@
  if (rc_lcl NE ESA_OK)                         /*after 3.0.1*@
     goto cleanup;                              /*after 3.0.1*@
  ESA_DIAG_printf (ESA_COMP_ACSADM, 15,          /*after 3.0.1*@
       "ADMIN_USER_REQUEST=%s.", wrk_admin);    /*after 3.0.1*@
                                                /*after 3.0.1*@
  if (wrk_admin[0] EQ ESS_NOT_SIGN)             /*after 3.0.1*@
  {                                             /*after 3.0.1*@
     rc= ESA_KEY_NOT_FOUND;                     /*after 3.0.1*@
     goto cleanup;                              /*after 3.0.1*@
  }                                             /*after 3.0.1*@
 
  rc_lcl= ADM_admin_name_for_cmp (rss_name,
                                  del_admin,
                                  admin);
  if (rc_lcl NE ESA_OK)
     goto cleanup;
 
  /* Default administrator *@
  rc_lcl= rssprm_get (rss_name,
                      DEFAULT_ADMINISTRATOR,
                      MAX_RSS_USER_NAME_LEN,
                      wrk_admin);
  if (rc_lcl NE ESA_OK)
     goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "DEFAULT_ADMINISTRATOR=%s.", wrk_admin);
 
  rc_lcl= ADM_admin_name_for_cmp (rss_name,
                                  def_admin,
                                  wrk_admin);
  if (rc_lcl NE ESA_OK)
     goto cleanup;
 
  if (strcmp (del_admin, def_admin) EQ 0)
     rc= ESA_OK;
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
          "%s: default administrator=%s (for compare=%s) rc=%d.",
           del_admin, wrk_admin, def_admin, rc);
 
  /* Default CS administrator *@
  rc_lcl= rssprm_get_opt (rss_name,
                          DEFAULT_CS_ADMINISTRATOR,
                          MAX_RSS_USER_NAME_LEN,
                          wrk_admin,
                          OPT_TRUE,
                          OPT_FALSE);
  if (rc_lcl EQ ESA_OK)  {
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "DEFAULT_CS_ADMINISTRATOR=%s.", wrk_admin);
     rc_lcl= ADM_admin_name_for_cmp (rss_name,
                                     def_admin,
                                     wrk_admin);
     if (rc_lcl NE ESA_OK)
        goto cleanup;
 
     if (strcmp (del_admin, def_admin) EQ 0)
        rc= ESA_OK;
     ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
          "%s: default CS administrator=%s (for compare=%s) rc=%d.",
           del_admin, wrk_admin, def_admin, rc);
  }
 
  /* Default CD administrator *@
  rc_lcl= rssprm_get_opt (rss_name,
                          DEFAULT_CD_ADMINISTRATOR,
                          MAX_RSS_USER_NAME_LEN,
                          wrk_admin,
                          OPT_TRUE,
                          OPT_FALSE);
  if (rc_lcl EQ ESA_OK)  {
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "DEFAULT_CD_ADMINISTRATOR=%s.", wrk_admin);
     rc_lcl= ADM_admin_name_for_cmp (rss_name,
                                     def_admin,
                                     wrk_admin);
     if (rc_lcl NE ESA_OK)
        goto cleanup;
 
     if (strcmp (del_admin, def_admin) EQ 0)
         rc= ESA_OK;
     ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
          "%s: default CD administrator=%s (for compare=%s) rc=%d.",
           del_admin, wrk_admin, def_admin, rc);
  }
 
 
  /* Default OFLI administrator *@
  rc_lcl= rssprm_get_opt (rss_name,
                          DEFAULT_OFLI_ADMINISTRATOR,
                          MAX_RSS_USER_NAME_LEN,
                          wrk_admin,
                          OPT_TRUE,
                          OPT_FALSE);
  if (rc_lcl EQ ESA_OK)  {
     ESA_DIAG_printf (ESA_COMP_ACSADM, 15,
       "DEFAULT_OFLI_ADMINISTRATOR=%s.", wrk_admin);
     rc_lcl= ADM_admin_name_for_cmp (rss_name,
                                     def_admin,
                                     wrk_admin);
     if (rc_lcl NE ESA_OK)
        goto cleanup;
 
     if (strcmp (del_admin, def_admin) EQ 0)
        rc= ESA_OK;
 
     ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
          "%s: default OFLI administrator=%s (for compare=%s) rc=%d.",
           del_admin, wrk_admin, def_admin, rc);
  }
  rc_lcl= ESA_OK;
 
cleanup:
 
  if (rc_lcl NE ESA_OK)
      rc= rc_lcl;
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
 
  return (rc);
 
}
 
/***************************************************************
*                                                              *
* Procedure Name : ADM_admin_pwd_sync                          *
*                                                              *
* Description    : Administrator password syncronization       *
*   			                                                        *
* Input            admin_name                                  *
*   			                                                        *
* Return Value   :                                             *
***************************************************************@
 
ESA_RC ADM_admin_pwd_sync (USER_typ  admin_name)
{
  ESA_RC                  rc= ESA_OK;
  USER_typ                admin_name_for_cmp;
  PASSWD_typ              admin_passwd;
  int                     sw_def_admin;
  char                    fn[]="ADM_admin_pwd_sync";
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON+ 1, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
                   "rss=%s admin_name=%s def_admin=%s admin=%s.",
                   envir_ptr->msg_admin_param.rss_name,
                   admin_name,
                   envir_ptr->msg_admin_param.def_admin,
                   envir_ptr->msg_admin_param.admin_uname);
 
  if (strlen (envir_ptr->msg_admin_param.rss_name) EQ 0)
      goto cleanup;
 
  rc= ADM_admin_name_for_cmp (envir_ptr->msg_admin_param.rss_name,
                              admin_name_for_cmp,
                              envir_ptr->msg_admin_param.def_admin);
  if (rc NE ESA_OK)
     goto cleanup;
 
  if (strcmp (admin_name, admin_name_for_cmp) NE 0)
  {
     rc= ADM_admin_name_for_cmp (
                envir_ptr->msg_admin_param.rss_name,
                admin_name_for_cmp,
                envir_ptr->msg_admin_param.admin_uname);
     if (rc NE ESA_OK)
        goto cleanup;
     if (strcmp (admin_name, admin_name_for_cmp) NE 0)
        goto cleanup;
     else
        sw_def_admin= 0;
  }
  else
    sw_def_admin= 1;
 
  rc= ADM_get_passwd (envir_ptr->msg_admin_param.rss_name,
                      admin_name,
                      admin_passwd,
                      &envir_ptr->adm_member);
  if (rc NE ESA_OK)
     goto cleanup;
 
  if (sw_def_admin)
     strcpy (envir_ptr->msg_admin_param.def_admin_passwd,
             admin_passwd);
  else
     strcpy (envir_ptr->msg_admin_param.admin_passwd, admin_passwd);
 
 
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON+ 1, fn, rc);
  return (rc);
}
 
@***************************************************************
*                                                              *
* Procedure Name : ADM_admin_data_sync                         *
*                                                              *
* Description    : Sync. file of administrators &              *
*                        relevant data in CD/CS                *
*                                                              *
* Input          : admin_user                                  *
*                  admin_passwd                                *
*                                                              *
* Return Value   : ESA_RC                                      *
***************************************************************@
 
ESA_RC ADM_admin_data_sync (USER_typ    admin_user,
                            PASSWD_typ  admin_passwd)
{
  char                  fn[]="ADM_admin_data_sync";
  ESA_RC                rc= ESA_OK;
  MEMBER_ADM_rec_typ    find_adm_rec;
  TIME_typ              change_interval;
  USER_typ              admin_name_for_cmp, def_admin, admin_uname;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
 
  /*do not expose password, password printing removed*@
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13,
       "admin=%s.", admin_user);
 
  rc= ADM_admin_name_for_cmp (envir_ptr->msg_admin_param.rss_name,
                              admin_name_for_cmp,
                              admin_user);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= ADM_find (envir_ptr->msg_admin_param.rss_name,
                admin_name_for_cmp,
                &find_adm_rec);
  if (rc EQ ESA_OK)
  {
     change_interval[0] = '\0';
     sprintf (change_interval, CHANGE_INTERVAL_FMT, /* STM1 *@
              find_adm_rec.change_interval);
     rc= ADM_upd(envir_ptr->msg_admin_param.rss_name,
                 find_adm_rec.admin_name,
                 find_adm_rec.auto_pwd_change,
                 change_interval,
                 admin_passwd);
     if (rc NE ESA_OK)
        goto cleanup;
     rc= ADM_admin_name_for_cmp (envir_ptr->msg_admin_param.rss_name,
                              def_admin,
                              envir_ptr->msg_admin_param.def_admin);
     if (rc NE ESA_OK)
        goto cleanup;
     if (strcmp (def_admin, admin_name_for_cmp) EQ 0)
         strcpy (envir_ptr->msg_admin_param.def_admin_passwd,
                admin_passwd);
     else
     {
        rc= ADM_admin_name_for_cmp (
                    envir_ptr->msg_admin_param.rss_name,
                    admin_uname,
                    envir_ptr->msg_admin_param.admin_uname);
        if (rc NE ESA_OK)
           goto cleanup;
        if (strcmp (admin_uname, admin_name_for_cmp) EQ 0)
           strcpy (envir_ptr->msg_admin_param.admin_passwd,
                   admin_passwd);
     }
 
  }
 
cleanup:
 
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
 
  return (rc);
 
}
 
void CS_DAIG_RssAdmin (long int                all_num_adms,
                       ADMINISTRATOR_rec_typ * all_adms_ptr)
{
   int                   jj= 0;
   ADMINISTRATOR_rec_typ * adms_ptr= NULL;
   char fn[]="CS_DAIG_RssAdmin";
 
   ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
   if (ESA_DIAG_get_debug_level(ESA_COMP_ACSCB) LE DIAG_BASIC)
		goto cleanup;
 
   ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "     RssAdmin rows --------------------");
   for (jj= 0;
        (all_adms_ptr NE NULL) AND (jj LT all_num_adms);
		jj++)
   {
      adms_ptr= all_adms_ptr+ jj;
	  /*do not expose password, password printing removed*@
      ESA_DIAG_printf (ESA_COMP_ACSCB, 0,
		  "       %d :rss=%s Chg:%c Intrvl=%s Date=%s %s Adm=%s",
	      jj+ 1, adms_ptr->rss_name, adms_ptr->auto_pwd_change,  adms_ptr->change_interval,
		  adms_ptr->last_changed_date, adms_ptr->last_changed_time, adms_ptr->admin_name);
   }
   ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "     ---------------------------------");
cleanup:
   ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, ESA_RC_VOID);
   return;
}
 
ESA_RC ADM_next_apc (int                * from_rss_num,
                     int                * from_adm_num,
                     MEMBER_ADM_rec_typ * apc_adm_rec)
{
  char                  fn[]="ADM_next_apc";
  MEMBER_ADM_rec_typ  * WrkAdmRec= NULL;
  int                   jj= 0, ii= 0;
  ESA_RC                rc= ESA_EOF;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSADM, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13, "Enter from:_rss=%d (max=%d) _adm=%d.",
	  *from_rss_num, envir_ptr->max_rss_num, *from_adm_num);
 
  for (ii= *from_rss_num; ii LT envir_ptr->max_rss_num; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSADM, 13, "%d rss=%s adm_num=%d.",
		 ii, envir_ptr->interest[ii].rss, envir_ptr->interest[ii].pre_num_adms);
 
     for (jj= *from_adm_num; jj LT envir_ptr->interest[ii].pre_num_adms; jj++)
	 {
        ESA_DIAG_printf (ESA_COMP_ACSADM, 13, "pre_num_adms=%d.",
		   envir_ptr->interest[ii].pre_num_adms);
 
        WrkAdmRec= envir_ptr->interest[ii].pre_adms_ptr+ jj;
        ESA_DIAG_printf (ESA_COMP_ACSADM, 13, "%d %p: Adm=%s APC=%c-%d Date=%d.",
		   jj , WrkAdmRec, WrkAdmRec->admin_name , WrkAdmRec->auto_pwd_change,
		   WrkAdmRec->change_interval, WrkAdmRec->date_of_last_change);
 
		if (WrkAdmRec->change_interval EQ 0)
           continue;
		break;
	 }
	 if (jj LT envir_ptr->interest[ii].pre_num_adms)
	 {
		rc= ESA_OK;
        (*from_adm_num)= jj+ 1;
		memcpy ((char *)apc_adm_rec, (char *)WrkAdmRec, sizeof(MEMBER_ADM_rec_typ));
		break;
	 }
	 else
	 {
        (*from_rss_num)++;
		(*from_adm_num)= 0;
	 }
     ESA_DIAG_printf (ESA_COMP_ACSADM, 13, "    from:_rss=%d _adm=%d.",
   	    *from_rss_num, *from_adm_num);
  }
 
  ESA_DIAG_printf (ESA_COMP_ACSADM, 13, "Exit from:_rss=%d _adm=%d.",
	  *from_rss_num, *from_adm_num);
  ESA_DIAG_exit (ESA_COMP_ACSADM, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - ADM_next_apc function *@
end of WS10082A ******************/
 
 
