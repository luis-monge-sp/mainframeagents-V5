/*
 * Version Information:
 * ====================
 * File name       : %name: esarssf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: ihoffma %
 * Created on      : %date_created: Tue Oct 07 17:53:08 2003 %
 * Last Modified by: %derived_by: ihoffma %
 * Last Modified on: %date_modified: Tue Oct 07 17:53:09 2003 %
 * Current Version : %version: 3 %
 */
 
/***********************************************************
 * Mod.ID   Who      When            Description
 * =========================================================
 * IMH001   Ian H.   7th Oct. 2003   Win: Get COMMON.dll version
 * IS10105  AvnerL   25 NOV 2013     Allow any host_id in RSSOFLI
 * SAS2IBMA AvnerL   21-Dec-16       SAS/C to IBM C Conversion Project
 *WS10078KM KailasP  15-Jun-20       handle message size issue
 *WS10082A  AvnerL   17-Oct-23       Drop ADM_load as not used
 ***********************************************************/
 
#include "globs.h"
 
#include ESA_INIT
#include ESA_RSSF
#include ESA_QUEUE
#include ESA_PROC
#include ESA_RSS
#include ESA_CS_OS
#include ESA_CS_SINFO
#include ESA_OS_CONSOLE
#include ESA_OS_PROC
#include ESA_ADMIN
#include ENC_API
 
char ActionString[15];
 
void CS_action_string (ACTION_typ action);
 
ESA_RC CTSApiProcInit (char                  * ProgramName,
				       char                  * ProgramMain,
                       int                     ArgC,
                       char                 ** ArgV,
					   void                 ** EncrHndl,
					   void                 ** ProcHndl,
                       ADMIN_PARAMS_rec_typ  * AdminPrm)
{
  char                  fn[]="CTSApiProcInit";
  ESA_RC                rc= ESA_OK;
  char                  failmsg [512];
  ENC_BOOLEAN           encryption_active;
  ENC_ERR_rec_typ       encription_err;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
/*
  if (ProcHndl)
  {
     rc= OS_PROC_init (ESA_ONLI_PROC,
                       ProcHndl,
                       ArgC,
                       ArgV);
     if (rc NE ESA_OK)
	 {
       sprintf (failmsg, "%s: OS_PROC_init Failed.\n", fn);
       fprintf (stderr,failmsg);
       OS_CONSOLE_print (failmsg,
		                 OS_CONS_ROLLABLE_YES,
		                 OS_CONS_SEV_ERROR);
       return (rc);
	 }
  }
*/
  rc= CG_prolog2 (ProgramName, ProgramMain, ArgC, ArgV);
 
  if (rc NE ESA_OK) {
    sprintf (failmsg, PROLOG_PROC_INIT_ERROR,
             CG_name (ESA_EXTERNAL),
             ESA_rc2str(rc));
    printf (failmsg);
    OS_CONSOLE_print (failmsg,
                      OS_CONS_ROLLABLE_YES,
                      OS_CONS_SEV_ERROR);
    return (rc);
  }
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "CG_prolog2 completed with return code:%s",
                   ESA_rc2str(rc));
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  envir_ptr->msg_admin_param.cs_func.LOG_event_ptr= &LOG_event;
  envir_ptr->msg_admin_param.cs_func.RssTblGet_ptr= &RssTblGet;
  envir_ptr->msg_admin_param.cs_func.RssTblSet_ptr= &RssTblSet;
 
  memcpy (AdminPrm,
          &envir_ptr->msg_admin_param,
          sizeof (ADMIN_PARAMS_rec_typ));
 
  /* encryption initialization */
  if (EncrHndl)
  {
     if (envir_ptr->encr_int_act NE NOT_ACT_ENCR)
	 {
        if (envir_ptr->encr_int_act EQ ACT_ENCR)
           encryption_active = ENC_TRUE;
        else
           encryption_active = ENC_FALSE;
 
        rc= ENC_init_intrn_key (envir_ptr->file_encrint,
                             encryption_active,
                             EncrHndl,
                             &encription_err);
        if (rc NE ESA_OK)
           CS_encr_msg (&encription_err);
 
        ESA_DIAG_printf (ESA_COMP_ESARSSF,15,
           "Encryption initialization completed with return code:%s",
                   ESA_rc2str(rc));
	 }
  }
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                  envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                  envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
ESA_RC CTSApiProcTerm (ESA_RC    exit_status,
  					   void   ** EncrHndl,
                       void   ** ProcHndl)
{
  char                     fn[]="CTSApiProcTerm";
  ESA_RC                   rc= ESA_OK;
  ENVIRONMENT_rec_typ    * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  if (EncrHndl)
     ENC_term (EncrHndl);
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_OS,
                   "...-> OS_PROC_term: EXTERNAL, os_proc_handle=%p.",
				   *ProcHndl);
  rc= OS_PROC_term (ESA_EXTERNAL, ProcHndl);
  ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_OS,
	"...<- OS_PROC_term: rc=%d (%s).",
			rc, (rc EQ ESA_OK) ? "OS==OK" : "OS##OK");
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
 
  CG_epilog(exit_status , OS_PROC_get_exception());
 
  return(rc);
}
 
 
/****************************************************
 * Procedure Name : rsinit
 * Description    : RSS functions initialization
 *
 * Input          : rss_name - RSS name when available.
 *                             NULL if not available
 *                  rss_type - Mandatory information.
 *                  handle   - NULL on first call, filled by callee,
 *                             used by callee to store all the
 *                             initialization information.
 *                  intercept- OFLI / ONLI
 *
 * Output        : Time Range ...
 *                 start_date
 *                 start_time the date and time of the
 *                            first entry that the interceptor
 *                            shold start with.
 *                 end_date
 *                 end_time   the date and time of the
 *                            last entry.
 *                            if fields are empty
 *                            then the last entry is the last
 *                            in the log or file.
 *
 *                 CTSAMSG stuff
 *
 * Return Value   : ESA_RC / ESA_FATAL
 * Side Effects   :
 * Comments       : RSS dependent operations to be performed
 *                  prior to RSS function call:
 *                  Open the queue.
 *                  ESA_DIAG initialization.
 *                  CTSAMSG initialization.
 *                  Get the start date and time
 *                      off line interceptor should start
 *                      with.
 *                  rslogevnt Off Line Intercept started.
 *                  OS_CS_lock on the handled rss
 ***************************************************/
ESA_RC CTSInterceptorInit (RSS_typ                  rss_type,
                           RSS_typ                  rss_name,
                           void                  ** handle,
                           void                  ** EncrHndl,
                           INTERCEPTOR_typ          intercept_typ,
                           TIME_RANGE_rec_typ     * time_range,
                           ADMIN_PARAMS_rec_typ   * admin_prm,
                           int                      argc_prm,
                           char                  ** argv_prm)
 
{
  char                 fn[]="CTSInterceptorInit";
  ESA_RC               rc= ESA_OK;
  char                 failmsg [512];
  char                 interval[RSSPRM_VALUE_LEN+ 1];
  ENC_BOOLEAN          encryption_active;
  ENC_ERR_rec_typ      encription_err;
  unsigned int         ii= 0;
  ESA_MAIN_NAME_typ    p_main_name;
  MEMBER_ADM_rec_typ   adm_member;
   char                onli_semaphore[256];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  * handle   = NULL; /* The handle should be removed from parameters
                        list along with the InterceptorTerm function */
  if (intercept_typ EQ INTERCEPT_OFFLINE)
      memset((char *)time_range,NULL_CHAR,sizeof(TIME_RANGE_rec_typ));
 
  /* Load CONTROL/SA parameters */
 
  if (intercept_typ EQ INTERCEPT_OFFLINE)
    p_main_name= ESA_OFLI_PROC;
  else if (intercept_typ EQ INTERCEPT_ONLINE)
	p_main_name= ESA_ONLI_PROC;
  else
	p_main_name= ESA_EXTERNAL;
 
  rc= CG_prolog (p_main_name, argc_prm, argv_prm);
 
  envir_ptr->msg_admin_param.cs_func.LOG_event_ptr= &LOG_event;
  envir_ptr->msg_admin_param.cs_func.RssTblGet_ptr= &RssTblGet;
  envir_ptr->msg_admin_param.cs_func.RssTblSet_ptr= &RssTblSet;
 
  CLEAR(interval);
 
  if (rc NE ESA_OK) {
    sprintf (failmsg, PROLOG_PROC_INIT_ERROR,
             CG_name (p_main_name),
             ESA_rc2str(rc));
    printf (failmsg);
    OS_CONSOLE_print (failmsg,
                      OS_CONS_ROLLABLE_YES,
                      OS_CONS_SEV_ERROR);
 
    return (rc);
  }
  /* Open the queue */
  rc = OS_Q_open (envir_ptr->file_queue,
                  &envir_ptr->q_handle,
                  &envir_ptr->msg_params);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                     "queue open error return code:%s",
                     ESA_rc2str(rc));
    goto cleanup;
  }
 
  *handle= &envir_ptr->q_handle;
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF,13,
                   "CG_prolog completed with return code:%s",
                   ESA_rc2str(rc));
 
  /* encryption initialization */
 
  if (envir_ptr->encr_int_act NE NOT_ACT_ENCR) {
    if (envir_ptr->encr_int_act EQ ACT_ENCR)
      encryption_active = ENC_TRUE;
    else
      encryption_active = ENC_FALSE;
 
    rc = ENC_init_intrn_key (envir_ptr->file_encrint,
                             encryption_active,
                             &envir_ptr->enc_internal_handle,
                             &encription_err);
    if (rc NE ESA_OK)
      CS_encr_msg (&encription_err);
 
    ESA_DIAG_printf (ESA_COMP_ESARSSF,15,
    "Encryption initialization completed with return code:%s",
                   ESA_rc2str(rc));
 
    if (rc NE ESA_OK)
      goto cleanup;
	if (EncrHndl)
	   *EncrHndl= envir_ptr->enc_internal_handle;
  }
  /* get rss name... if rss name is empty */
  if (rss_name[0] EQ NULL_CHAR) {
    rc = rssprm_get_name (rss_type ,RSS_TYPE , interval);
 
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
       "parameters get error keyword:%s return code:%s",
                       RSS_TYPE, ESA_rc2str(rc));
 
      goto cleanup;
    }
 
    strcpy(envir_ptr->rss_name, interval);
    strcpy(rss_name, interval);
 
  }
  else
    strcpy(envir_ptr->rss_name,rss_name);
 
  for (ii= 0; ii LT (unsigned int)envir_ptr->max_rss_num; ii++)
  {
     if (My_stricmp (envir_ptr->interest[ii].rss, rss_name) EQ 0)
	 {
        envir_ptr->rss_num= ii;
        break;
	 }
  } /* END - FOR loop */
 
 
  /* get rss type... if rss type is empty */
  if (rss_type[0] EQ NULL_CHAR) {
    rc = rssprm_get( rss_name, RSS_TYPE, sizeof (interval),
                     interval);
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
       "parameters get error keyword:%s return code:%s",
                       RSS_TYPE, ESA_rc2str(rc));
      goto cleanup;
    }
 
    strcpy(rss_type, interval);
  }
 
  strcpy(envir_ptr->rss_type,rss_type);
 
  strcpy (envir_ptr->msg_admin_param.rss_name, rss_name);
  strcpy (envir_ptr->msg_admin_param.rss_type, rss_type);
  envir_ptr->msg_admin_param.program_name=
            CG_main_name (envir_ptr->p_main_name);
 
  /* Lock Init  */
  rc= rssprm_get (ALL_RSS, WAIT_LOCK, 10, interval);
  if (rc EQ ESA_OK) {
    ii= strspn (interval, POSITIVE_VALUE);
    if (ii NE strlen (interval)) {
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     WAIT_LOCK, interval,
                     envir_ptr->file_rssparm);
      goto cleanup;
    }
  }
 
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                     "%s parameter from %s failed (rc=%d)",
                     WAIT_LOCK, envir_ptr->file_rssparm, (int)rc);
    goto cleanup;
  }
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                     "%s parameter from %s is %s",
                     WAIT_LOCK, envir_ptr->file_rssparm, interval);
 
  envir_ptr->lock_wait= atoi (interval);
 
  rc= rssprm_get (envir_ptr->all_rss, WAIT_QUEUE, 10, interval);
  if (rc EQ ESA_OK) {
    ii= strspn (interval, POSITIVE_VALUE);
    if (ii NE strlen (interval)) {
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     WAIT_QUEUE, interval,
                     envir_ptr->file_rssparm);
      goto cleanup;
    }
  }
 
  if (rc NE ESA_OK) {
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                     "%s parameter from %s failed (rc=%d)",
                     WAIT_QUEUE, envir_ptr->file_rssparm, (int)rc);
    goto cleanup;
  }
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                     "%s parameter from %s is %s",
                     WAIT_QUEUE, envir_ptr->file_rssparm, interval);
 
  envir_ptr->q_wait= atoi (interval);
 
 
  if (intercept_typ NE INTERCEPT_OFFLINE)
  {
     if (intercept_typ EQ INTERCEPT_ONLINE)
	 {
        rc= rssprm_get (envir_ptr->rss_name, ONLI_SEMAPHORE,
                        MAX_RSS_RESOURCE_NAME_LEN, interval);
        if (rc EQ ESA_OK)
           strcpy (envir_ptr->interest[0].file_onli_semaphore, interval);
        if (strlen(envir_ptr->interest[0].file_onli_semaphore) NE 0)
		{
           sprintf( onli_semaphore, "%s.%s",
                 envir_ptr->interest[0].file_onli_semaphore,
                 envir_ptr->host_name );
           rc= CSA_lock ( onli_semaphore,fn, SCOPE_LOCAL);
 
           if (rc NE ESA_OK)
              goto cleanup;
		}
	 }
     rc= envir_ptr->msg_admin_param.cs_func.rssprm_get_opt_ptr (
		                        envir_ptr->msg_admin_param.rss_name,
                                ADMIN_USER_REQUEST ,
                                1,
                                interval,
                                OPT_TRUE,
                                OPT_FALSE);
     if (rc NE ESA_OK)
        strcpy (interval, ESS_NOT_FLAG);
	 rc= ESA_OK;
     ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
       "ADMIN_USER_REQUEST=%s.", interval);
  /*WS10082A RSSADM file is not used in MF
     if (
		   (strlen (envir_ptr->file_administrators) NE 0)
          AND
		   (interval[0] EQ ESS_YES_SIGN)
        )
	 {
 
	    rc= ADM_load ();
        if (rc NE ESA_OK) {
           ESA_DIAG_printf (ESA_COMP_ESARSSF, 11,
                           "RSS %s/%s ADM_load failed",
                            envir_ptr->msg_admin_param.rss_name,
							envir_ptr->msg_admin_param.rss_type);
           rc = ESA_FATAL;
           goto cleanup;
        }
        rc = envir_ptr->msg_admin_param.cs_func.rssprm_get_opt_ptr (
		                        envir_ptr->msg_admin_param.rss_name,
                                DEFAULT_ADMINISTRATOR,
                                sizeof (USER_typ)- 1,
                                envir_ptr->msg_admin_param.admin_uname,
                                OPT_TRUE,
                                OPT_FALSE);
        if (rc NE ESA_OK )  {
           rc = ESA_FATAL;
           goto cleanup;
		}
        envir_ptr->msg_admin_param.admin_gname[0]= NULL_CHAR;
 
	    rc = ADM_get_passwd (envir_ptr->msg_admin_param.rss_name,
                             envir_ptr->msg_admin_param.admin_uname,
                             envir_ptr->msg_admin_param.admin_passwd,
                             &adm_member);
 
        if (rc NE ESA_OK) {
           ESA_DIAG_printf (ESA_COMP_ESARSSF, 11,
                          "RSS %s/%s ADM_get_passwd failed for %s.",
                           envir_ptr->msg_admin_param.rss_name,
						   envir_ptr->msg_admin_param.rss_type,
						   envir_ptr->msg_admin_param.admin_uname);
           goto cleanup;
        }
	
        ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
             "ADM_fill_admin_changes completed with return code:%s",
              ESA_rc2str(rc));
 
        ADM_free ();
        if (rc NE ESA_OK)
           goto cleanup;
 
     }
  end of WS10082A ********/
  }
  if (intercept_typ EQ INTERCEPT_OFFLINE)
  {
     rc= rssprm_get (envir_ptr->rss_name,
                     SYNC_SEMAPHORE,
                     MAX_RSS_RESOURCE_NAME_LEN,
                     interval);
     if (rc EQ ESA_OK)
         strcpy (envir_ptr->interest[0].file_ofli_semaphore, interval);
     if (strlen(envir_ptr->interest[0].file_ofli_semaphore) NE 0)
     {
 
       /* lock rss beforre starting */
       rc= CSA_lock (envir_ptr->interest[0].file_ofli_semaphore,
                     fn, SCOPE_REMOTE);
       if (rc NE ESA_OK) {
          CTSAMSG_print (MSG_OFLI_STOPPED,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name);
          goto cleanup;
       }
       /* retrive start date and time for the OFLI */
 
       rc = CS_intercept_starttime (envir_ptr->rss_name,
                                    time_range);
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                          "intercept start time error return code:%s",
                          ESA_rc2str(rc));
          goto cleanup;
       }
 
       /* send start OFLI message to ESS by using rslogevt */
 
       if (envir_ptr->q_handle.file NE NULL)
          rc = CTSLogEvent (rss_type,
                            envir_ptr->rss_name,
                            &envir_ptr->q_handle,
                            MSG_OFLI_STARTED,
                            envir_ptr->rss_name);
 
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                         "rslogevt - %s, error return code:%s",
                         MSG_OFLI_STARTED , ESA_rc2str(rc));
          goto cleanup;
       }
     }
  }
 
  memcpy (admin_prm,
          &envir_ptr->msg_admin_param,
          sizeof (ADMIN_PARAMS_rec_typ));
 
  cleanup:
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  *handle= NULL;
 
  ESA_DIAG_exitEx (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc, 0, __LINE__, __FILE__);
  return(rc);
}
 
/****************************************************
 * Procedure Name : CTSInterceptorTerm
 * Description    : RSS functions termination
 *
 * Input          : handle   - Free by callee,
 *                  intercept- OFLI / ONLI
 *                  exit_status - The interceptor's exit status.
 *                  Time Range ...
 *                  start_date
 *                  start_time the date and time of the
 *                             first entry that the interceptor
 *                             shold start with.
 *                  end_date
 *                  end_time   the date and time of the
 *                             last entry.
 *                             if fields are empty
 *                             then the last entry is the last
 *                             in the log or file.
 *
 *
 * Output         :
 *
 * Return Value   : ESA_RC / ESA_FATAL
 * Side Effects   :
 * Comments       : RSS function cleanup operations.
 *                  Close the Queue.
 *                  CTSAMSG termination.
 *                  rslogevnt Off Line Intercept end
 *                  OS_CS_unlock
 ***************************************************/
 
ESA_RC CTSInterceptorTerm (void                  ** handle,
                           INTERCEPTOR_typ          intercept_typ,
                           ESA_RC                   exit_status,
                           TIME_RANGE_rec_typ     * time_range,
                           ADMIN_PARAMS_rec_typ   * admin_prm)
{
  char                  fn[]="CTSInterceptorTerm";
  ESA_RC                rc= ESA_OK;
  TIME_typ              start_time;
  DATE_typ              start_date;
  CTSAMSG_MSGID_typ     msgid;
  char                  onli_semaphore[256];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  /* term the encryption */
 
  ENC_term (&envir_ptr->enc_internal_handle);
 
  if (intercept_typ EQ INTERCEPT_OFFLINE)
  {
     if (strlen ((char *)time_range) NE 0)
     {
 
        memcpy((char *)start_time,
               (char *)time_range->end_time,TIME_LEN);
        memcpy((char *)start_date,
               (char *)time_range->end_date,DATE_LEN);
 
        if (exit_status EQ ESA_OK)
           rc=CS_intercept_end (envir_ptr->rss_name,
                                start_date,
                                start_time);
 
        ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                         "intercept completed with return code:%s",
                         ESA_rc2str(rc));
 
        if (exit_status EQ ESA_OK)
            strcpy (msgid, MSG_OFLI_END_OK);
        else if (exit_status EQ ESA_LOCKED)
            strcpy (msgid, MSG_OFLI_STOPPED);
        else
            strcpy (msgid, MSG_OFLI_END_ERR);
        rc = CTSLogEvent (envir_ptr->rss_type,
                          envir_ptr->rss_name,
                          &envir_ptr->q_handle,
                          (const char *)msgid ,
                          envir_ptr->rss_name);
 
        ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                     "rslogevt code %s completed with return code:%s",
                     (exit_status EQ ESA_OK) ?
                       MSG_OFLI_END_OK : MSG_OFLI_END_ERR ,
                       ESA_rc2str(rc));
     }
  } /*end if of OFLI*/
 
 
  if (envir_ptr->q_handle.file NE NULL)
    rc= OS_Q_close (&envir_ptr->q_handle);
 
  *handle = NULL; /* To be removed when the handle will be removed
                     from the InterceptorInit & Term */
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                   "queue close completed with return code:%s",
                   ESA_rc2str(rc));
 
  if (
      strlen(envir_ptr->interest[0].file_onli_semaphore) NE 0
       AND
      intercept_typ EQ INTERCEPT_ONLINE
     )
 
     sprintf( onli_semaphore, "%s.%s",
              envir_ptr->interest[0].file_onli_semaphore,
              envir_ptr->host_name );
     rc= CSA_unlock (onli_semaphore, fn);
 
  if (
      strlen(envir_ptr->interest[0].file_ofli_semaphore) NE 0
       AND
      intercept_typ EQ INTERCEPT_OFFLINE
      )
     rc= CSA_unlock (envir_ptr->interest[0].file_ofli_semaphore, fn);
 
  /*
    UNLOCK files Close them and release lock details for open/locked
    files.
  */
  CSA_close_all ();
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
 
  CG_epilog(exit_status , OS_PROC_get_exception());
 
  return(rc);
}
 
/****************************************************
 * Procedure Name: CTSPassModEvent
 * Description   : User's password was modified
 * Input         :
 * Output        : user name, addional info
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSPassModEvent (RSS_typ                  rss_type,
                        RSS_typ                  rss_name,
                        void                   * handle,
                        USER_typ                 user,
                        PASSWD_typ               passwd,
                        ADDINFO_rec_typ        * addinfo,
                        ADMIN_PARAMS_rec_typ   * admin_params)
{
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  char                  fn[]="CTSPassModEvent";
  ENVIRONMENT_rec_typ * envir_ptr;
  unsigned int          password_ext_len;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  password_ext_len= \
   (((MAX_RSS_PASSWD_LEN+(int)sizeof(int)) % 16) EQ 0) \
   ? \
   (MAX_RSS_PASSWD_LEN + (int)sizeof(int))* 2 \
   : \
   (MAX_RSS_PASSWD_LEN + (int)sizeof(int) + \
   (16-((MAX_RSS_PASSWD_LEN+(int)sizeof(int))% 16)))*2;
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSPWDMOD,
                          &msg_len);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (user, msg_ptr, &msg_len, MAX_RSS_USER_NAME_LEN ,C_USER_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.", C_USER_ID, user);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 16,
      "After set user:msg=%.*s.", msg_len, temp_msg);
  msg_ptr= CS_set_fld (passwd, msg_ptr, &msg_len, password_ext_len+ 1 ,C_USER_PASSWD);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=***.. by len=%d.",
	  C_USER_PASSWD, strlen(passwd));
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
  ESA_DIAG_printf(ESA_COMP_ESARSSF, 16,
      "After set password:msg=%.*s.", msg_len, temp_msg);
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
/*WS10078KM - Start *
/*msg_ptr= CS_set_addinfo(FUNC_RSPWDMOD, msg_ptr, addinfo , &msg_len);*/
  rc = CS_set_addinfo(FUNC_RSPWDMOD, msg_ptr, addinfo , &msg_len);
/*if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }*/
  if (rc NE ESA_OK)
  {
     /* If rc is not ESA_OK then one or more attributes are not *
        set in buffer. We display error and continue.           */
     CTSAMSG_print (ERR_CS_MSG_BUF_OVERFLOW,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    user,"User");
 
  }
  /* WS10078KM - Ends */
  ESA_DIAG_printf(ESA_COMP_ESARSSF, 16,
      "After set addinfo:msg=%.*s.", msg_len, temp_msg);
 
  rc= CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                          RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
  ESA_DIAG_printf(ESA_COMP_ESARSSF, 16,
      "After set sngl msg:msg=%.*s.", msg_len, temp_msg);
 
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s USER=%s PWDLen=%d PGM=%s wrote to queue.",
      fn, rss_name, rss_type, user, strlen (passwd), admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: rsuser
 * Description   : User state changed - user was added, deleted
 *                 or updated.
 * Input         :
 * Output        : RSS name, user data, action type.
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSUserEvent (RSS_typ                  rss_type,
                     RSS_typ                  rss_name,
                     void                   * handle,
                     USER_typ                 user,
                     ACTION_typ               action,
                     ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSUserEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSUSER,
                          &msg_len);
 
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (CS_act_to_actname((int)action),
                       msg_ptr,
                       &msg_len,
                       1 ,
                       C_ACTION);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_ACTION, CS_act_to_actname((int)action));
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (user, msg_ptr, &msg_len, MAX_RSS_USER_NAME_LEN, C_USER_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",C_USER_ID, user);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  rc=CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                         RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CS_action_string (action);
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s USER=%s ACT=%s PGM=%s wrote to queue.",
      fn, rss_name, rss_type, user, ActionString, admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: rsug
 * Description   : User group state changed - user group was added,
 *                 deleted or updated.
 * Input         :
 * Output        : RSS name, user group data, action type.
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSUGEvent (RSS_typ                  rss_type,
                   RSS_typ                  rss_name,
                   void                   * handle,
                   UG_typ                   ug,
                   ACTION_typ               action,
                   ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSUGEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSUG,
                          &msg_len);
 
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (CS_act_to_actname((int)action),
                       msg_ptr,
                       &msg_len,
                       1 ,
                       C_ACTION);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_ACTION, CS_act_to_actname((int)action));
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (ug, msg_ptr, &msg_len, MAX_RSS_UG_NAME_LEN ,C_GROUP_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",C_GROUP_ID, ug);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                      RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CS_action_string (action);
 
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s GROUP=%s ACT=%s PGM=%s wrote to queue.",
      fn, rss_name, rss_type, ug, ActionString, admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: rsu2ug
 * Description   : User to User-Group connection state changed -
 *                 connection was added, deleted or updated.
 * Input         :
 * Output        : RSS name, user data, user group data,
 *                 connection data, action type.
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSConnEvent (RSS_typ                  rss_type,
                     RSS_typ                  rss_name,
                     void                   * handle,
                     UG_typ                   ug,
                     USER_typ                 user,
                     ACTION_typ               action,
                     ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSConnEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSU2UG,
                          &msg_len);
 
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (CS_act_to_actname((int)action),
                       msg_ptr,
                       &msg_len,
                       1,
                       C_ACTION);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_ACTION, CS_act_to_actname((int)action));
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (ug, msg_ptr, &msg_len, MAX_RSS_UG_NAME_LEN,C_GROUP_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",C_GROUP_ID, ug);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (user, msg_ptr, &msg_len, MAX_RSS_USER_NAME_LEN,C_USER_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",C_USER_ID, user);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                      RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CS_action_string (action);
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s GROUP=%s USER=%s ACT=%s PGM=%s wrote to queue.",
      fn, rss_name, rss_type, ug, user, ActionString, admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: rsprmmod
 * Description   : Notify that RSS parameters have changed
 * Input         :
 * Output        :
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSParamsModEvent (RSS_typ                  rss_type,
                          RSS_typ                  rss_name,
                          void                   * handle,
                          ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSParamsModEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSPRMMOD,
                          &msg_len);
 
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                      RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s PGM=%s wrote to queue.",
      fn, rss_name, rss_type, admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: rsusdis
 * Description   : User was disabled (revoked)
 * Input         :
 * Output        : user name, addional info
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSUserRevokedEvent (RSS_typ                  rss_type,
                            RSS_typ                  rss_name,
                            void                   * handle,
                            USER_typ                 user,
                            ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSUserRevokedEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSUSDIS,
                          &msg_len);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (user, msg_ptr, &msg_len, MAX_RSS_USER_NAME_LEN,C_USER_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",C_USER_ID, user);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  CS_set_sngl_msg_len(temp_msg+sizeof (RSS_MSG_HDR_rec_typ)+
                      RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s USER=%s PGM=%s wrote to queue.",
      fn, rss_name, rss_type, user, admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/**************************************************************
 * Procedure Name   : CS_intercept_change
 *
 * Description      : Change 'range time' in specific 'rss' record
 *                       in file 'rssproc' from ESS message
 * input            : range time
 *                    rss
 * Return Value     : ESA_RC
 *                                                             *
 **************************************************************/
 
extern ESA_RC CS_intercept_change (TIME_RANGE_rec_typ   * range_time)
{
  char                  fn[]="CS_intercept_change";
  ESA_RC                rc= ESA_OK;
  RSSTBL_rec_typ      * rsstbl = NULL;
  int                   i= 0, rsstbl_num= 0;
  RSS_typ               rss_id;
  OS_host_name_typ      host_id;
  ENVIRONMENT_rec_typ * envir_ptr;
  char					one_rssofli[2];		/*IS10105*/
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "rss=%s from/till date=%s/%s time=%s/%s",
                   envir_ptr->msg_admin_param.rss_name,
                   range_time->from_date,
                   range_time->end_date, range_time->from_time,
                   range_time->end_time);
 
  rc= tbl_load (&rsstbl, &rsstbl_num);
  if (rc NE ESA_OK)
    goto cleanup;
 
  for(i= 0; i LT rsstbl_num; i++) {
    memcpy ((char *)rss_id, (char *)rsstbl[i].rss, sizeof(RSS_typ));
    strtok (rss_id, " ");
    memcpy ((char *)host_id, (char *)rsstbl[i].host,
            sizeof(OS_host_name_typ));
    strtok (host_id, " ");
    strtok (host_id, "\n");
 
	/* IS10105 start - when ONE_RSSOFLI parm is Y, allow any host_id in RSSOFLI */
	rc= envir_ptr->msg_admin_param.cs_func.rssprm_get_opt_ptr (
			envir_ptr->msg_admin_param.rss_name,
			"ONE_RSSOFLI" ,
			1,
			one_rssofli,
			OPT_TRUE,
			OPT_TRUE);
     if (rc NE ESA_OK)
        strcpy (one_rssofli, ESS_NOT_FLAG);
	 rc= ESA_OK;
     ESA_DIAG_printf (ESA_COMP_ESARSSF, 6,
       "at CS_intercept_change ONE_RSSOFLI=<%s>.", one_rssofli);
 
    /* dropped by IS10105 if (My_stricmp (rss_id,envir_ptr->msg_admin_param.rss_name) NE 0 OR*/
	
	if (My_stricmp (rss_id,envir_ptr->msg_admin_param.rss_name) NE 0) continue;
	if ((one_rssofli[0] NE ESS_YES_SIGN) AND
	    (strcmp (host_id, envir_ptr->host_name) NE 0)) continue;
	/* IS10105 end */
 
    /* dropped by IS10105 if (My_stricmp (rss_id,
                    envir_ptr->msg_admin_param.rss_name) NE 0 OR
        strcmp (host_id, envir_ptr->host_name) NE 0)
      continue; */
 
    memcpy ((char *)rsstbl[i].intercept_end_date,
            (char *)range_time->from_date,
            DATE_LEN);
    memcpy ((char *)rsstbl[i].intercept_end_time,
            (char *)range_time->from_time,
            TIME_LEN);
    memcpy ((char *)rsstbl[i].intercept_till_date,
            (char *)range_time->end_date,
            DATE_LEN);
    memcpy ((char *)rsstbl[i].intercept_till_time,
            (char *)range_time->end_time,
            TIME_LEN);
    break;
  }
  if (i GE rsstbl_num) {
    rc= ESA_KEY_NOT_FOUND;
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 11,"Rss=%s not found",
                     envir_ptr->msg_admin_param.rss_name);
    CTSAMSG_print (ERR_CS_RSS_NOTFND,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   envir_ptr->msg_admin_param.rss_name,
                   envir_ptr->host_name, envir_ptr->file_rssofli);
    goto cleanup;
  }
 
  rc= tbl_rebuild (rsstbl, rsstbl_num);
  cleanup:
  if (rsstbl NE NULL)
  {
     CSA_free ((char **)&rsstbl);
     rsstbl = NULL;
  }
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return (rc);
}
 
/**************************************************************
* Procedure Name   : CS_intercept_starttime                   *
*                                                             *
* Description      : get the interceptor start time           *
*                                                             *
* Return Value     : ESA_RC                                   *
**************************************************************/
 
ESA_RC CS_intercept_starttime (RSS_typ              rss_name,
                               TIME_RANGE_rec_typ * time_range)
{
  char                  fn[]="CS_intercept_starttime";
  int                   i = 0, rsstbl_num= 0;
  ESA_RC                rc= ESA_OK;
  RSSTBL_rec_typ      * rsstbl = NULL;
  RSS_typ               rss_id;
  OS_host_name_typ      host_id;
  char                * endstr= NULL;
  char                  EmptyStr[DATE_LEN]= "00000000";
  char					one_rssofli[2];		/*IS10105*/
 
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  memset ((char *)time_range, '\0', sizeof (TIME_RANGE_rec_typ));
 
  rc= tbl_load (&rsstbl, &rsstbl_num);
  if (rc NE ESA_OK)
    goto cleanup;
 
  for (i= 0; i LT rsstbl_num; i++) {
     memcpy ((char *)rss_id, (char *)rsstbl[i].rss, sizeof(RSS_typ));
     rss_id[RSS_NAME_LEN]= '\0';
     endstr= strchr((char *)rss_id, ' ');
     if (endstr NE NULL)
        *endstr= '\0';
 
    memcpy ((char *)host_id, (char *)rsstbl[i].host,
            sizeof(OS_host_name_typ));
    host_id[sizeof(OS_host_name_typ)- 1]= '\0';
    endstr= strchr((char *)host_id, ' ');
    if (endstr NE NULL)
       *endstr= '\0';
    endstr= strchr((char *)host_id, '\n');
    if (endstr NE NULL)
       *endstr= '\0';
 
/* IS10105 start - when ONE_RSSOFLI parm is Y, allow any host_id in RSSOFLI */
	rc= envir_ptr->msg_admin_param.cs_func.rssprm_get_opt_ptr (
			envir_ptr->msg_admin_param.rss_name,
			"ONE_RSSOFLI" ,
			1,
			one_rssofli,
			OPT_TRUE,
			OPT_TRUE);
     if (rc NE ESA_OK)
        strcpy (one_rssofli, ESS_NOT_FLAG);
	 rc= ESA_OK;
     ESA_DIAG_printf (ESA_COMP_ESARSSF, 6,
       "at CS_intercept_starttime ONE_RSSOFLI=<%s>.", one_rssofli);
	
    if (My_stricmp (rss_id, rss_name) EQ 0)
	/* dropped by IS10105 AND
        (strcmp (host_id, envir_ptr->host_name) EQ 0) */
		if (one_rssofli[0] EQ ESS_YES_SIGN)
			break;
		else if (strcmp (host_id, envir_ptr->host_name) EQ 0) break;
 
        /* IS10105
       break; */
	   /* end of IS10105 */
 
    /* dropped by IS10105 if ((My_stricmp (rss_id, rss_name) EQ 0)
        AND
        (strcmp (host_id, envir_ptr->host_name) EQ 0)
        )
       break; */
  }
 
  if (i GE rsstbl_num) {
    rc= ESA_KEY_NOT_FOUND;
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 11,"Rss=%s not found",
                     rss_name);
    CTSAMSG_print (ERR_CS_RSS_NOTFND,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   rss_name, envir_ptr->host_name,
				   envir_ptr->file_rssofli);
    goto cleanup;
  }
 
  if (memcmp ((char *)rsstbl[i].intercept_end_date,
              (char *)rsstbl[i].sync_start_date,
              DATE_LEN) GT 0 OR
      (memcmp ((char *)rsstbl[i].intercept_end_date,
               (char *)rsstbl[i].sync_start_date,
               DATE_LEN) EQ 0 AND
       memcmp ((char *)rsstbl[i].intercept_end_time,
               (char *)rsstbl[i].sync_start_time,
               TIME_LEN) GT 0)) {
    memcpy ((char *)time_range->from_time,
            (char *)rsstbl[i].intercept_end_time, TIME_LEN);
    memcpy ((char *)time_range->from_date,
            (char *)rsstbl[i].intercept_end_date, DATE_LEN);
  }
  else {
    memcpy ((char *)time_range->from_time,
            (char *)rsstbl[i].sync_start_time, TIME_LEN);
    memcpy ((char *)time_range->from_date,
            (char *)rsstbl[i].sync_start_date, DATE_LEN);
  }
  memcpy ((char *)time_range->end_time,
          (char *)rsstbl[i].intercept_till_time, TIME_LEN);
  memcpy ((char *)time_range->end_date,
          (char *)rsstbl[i].intercept_till_date, DATE_LEN);
 
  if (
	    (memcmp ((char *)rsstbl[i].intercept_till_date,
	             (char *)EmptyStr, DATE_LEN) NE 0)
       OR
        (memcmp ((char *)rsstbl[i].intercept_till_time,
		         (char *)EmptyStr, TIME_LEN) NE 0)
	 ) {
 
     CTSAMSG_print (MSG_OFLI_PREV_FAILED,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    rss_name);
 
     CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                  envir_ptr->msg_admin_param.rss_name,
                  NULL,
                  MSG_OFLI_PREV_FAILED,
                  rss_name);
  }
  memcpy ((char *)rsstbl[i].intercept_till_date,
	      (char *)rsstbl[i].intercept_end_date, DATE_LEN);
  memcpy ((char *)rsstbl[i].intercept_till_time,
		  (char *)rsstbl[i].intercept_end_time, TIME_LEN);
 
  rc= tbl_rebuild (rsstbl, rsstbl_num);
 
  cleanup:
  if (rsstbl NE NULL)
  {
     CSA_free ((char **)&rsstbl);
     rsstbl = NULL;
  }
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  if (rc EQ ESA_OK)
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 14,
     "rss_name=%s(rsstbl_num=%d i=%d) from/till date=%s/%s time=%s/%s",
                   rss_name, rsstbl_num, i, time_range->from_date,
                   time_range->from_time, time_range->end_date,
                   time_range->end_time);
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, ESA_OK);
 
  return(rc);
}
 
/**************************************************************
 * Procedure Name   : CS_intercept_end                        *
 * Description      : Signal to CS that interceptor has       *
 *                    finished its activity                   *
 * Input            : rss            - RSS name               *
 *                    end_date - date and time when interceptor
 *                               wrote last record.           *
 *                    end_time -                              *
 * Return Value     : ESA_OK/ESA_FATAL                        *
 *************************************************************/
 
extern ESA_RC CS_intercept_end (RSS_typ                  rss,
                                DATE_typ                 end_date,
                                TIME_typ                 end_time)
{
  char                  fn[]="CS_intercept_end";
  ESA_RC                rc= ESA_OK;
  RSSTBL_rec_typ      * rsstbl = NULL;
  int                   i= 0, rsstbl_num= 0;
  RSS_typ               rss_id;
  OS_host_name_typ      host_id;
  char                * endstr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
  char					one_rssofli[2];		/*IS10105*/
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "rss=%s end_date=%s end_time=%s",
                    rss, end_date, end_time);
 
  rc= tbl_load (&rsstbl, &rsstbl_num);
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 15,
                   "TBL_LOAD: num_rec=%d rc=%d",
                    (int)rsstbl_num, (int)rc);
 
  if (rc NE ESA_OK)
     goto cleanup;
 
  for (i= 0; i LT rsstbl_num; i++) {
 
    memcpy ((char *)rss_id, (char *)rsstbl[i].rss, sizeof(RSS_typ));
    rss_id[RSS_NAME_LEN]= '\0';
    endstr= strchr((char *)rss_id, ' ');
    if (endstr NE NULL)
       *endstr= '\0';
 
    memcpy ((char *)host_id, (char *)rsstbl[i].host,
            sizeof(OS_host_name_typ));
 
    host_id[sizeof(OS_host_name_typ)- 1]= '\0';
 
    endstr= strchr((char *)host_id, ' ');
 
    if (endstr NE NULL)
       *endstr= '\0';
 
    endstr= strchr((char *)host_id, '\n');
 
    if (endstr NE NULL)
        *endstr= '\0';
 
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 16,
                     "%d: rss_id=%s host_id=%s.",i,rss_id,host_id);
 
/* IS10105 start - when ONE_RSSOFLI parm is Y, allow any host_id in RSSOFLI */
	rc= envir_ptr->msg_admin_param.cs_func.rssprm_get_opt_ptr (
			envir_ptr->msg_admin_param.rss_name,
			"ONE_RSSOFLI" ,
			1,
			one_rssofli,
			OPT_TRUE,
			OPT_TRUE);
     if (rc NE ESA_OK)
        strcpy (one_rssofli, ESS_NOT_FLAG);
	 rc= ESA_OK;
     ESA_DIAG_printf (ESA_COMP_ESARSSF, 6,
       "at CS_intercept_end ONE_RSSOFLI=<%s>.", one_rssofli);
	
    /* dropped by IS10105 if (My_stricmp (rss_id, rss) NE 0 OR*/
	/* IS10105 part 2 - start */
	if (My_stricmp (rss_id, rss) NE 0) continue;
	if ((one_rssofli[0] NE ESS_YES_SIGN) AND
	    (strcmp(host_id, envir_ptr->host_name) NE 0)) continue;
	/* IS10105 part 2 - end */
 
    /* dropped by IS10105 if (My_stricmp (rss_id, rss) NE 0 OR
        strcmp (host_id, envir_ptr->host_name) NE 0)
       continue; */
 
    memcpy ((char *)rsstbl[i].intercept_end_date, (char *)end_date,
            DATE_LEN);
 
    memcpy ((char *)rsstbl[i].intercept_end_time, (char *)end_time,
            TIME_LEN);
 
    memset ((char *)rsstbl[i].intercept_till_date, '0', DATE_LEN);
 
    memset ((char *)rsstbl[i].intercept_till_time, '0', TIME_LEN);
    break;
  }
 
  if (i GE rsstbl_num) {
    rc= ESA_KEY_NOT_FOUND;
    ESA_DIAG_printf (ESA_COMP_ESARSSF, 11,"Rss=%s not found", rss);
    CTSAMSG_print (ERR_CS_RSS_NOTFND,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   rss, envir_ptr->host_name,
				   envir_ptr->file_rssofli);
    goto cleanup;
  }
 
  rc= tbl_rebuild (rsstbl, rsstbl_num);
  if (rc NE ESA_OK)
      goto cleanup;
 
  cleanup:
  if (rsstbl NE NULL)
  {
     CSA_free ((char **)&rsstbl);
     rsstbl = NULL;
  }
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return (rc);
}
 
/****************************************************
 * Procedure Name: CTSOEEvent
 * Description   : Container  was added deleted or updated.
 * Input         :
 * Output        : RSS name, OE data, action type.
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSOEEvent (RSS_typ                  rss_type,
                   RSS_typ                  rss_name,
                   void                   * handle,
                   OE_typ                   oe,
                   ACTION_typ               action,
                   ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSOEEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSOE,
                          &msg_len);
 
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (CS_act_to_actname((int)action),
                       msg_ptr,
                       &msg_len,
                       1 ,
                       C_ACTION);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_ACTION, CS_act_to_actname((int)action));
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (oe, msg_ptr, &msg_len, MAX_RSS_OE_NAME_LEN ,C_OE_ID);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",C_OE_ID, oe);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                      RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc = rss_queue_put (handle,temp_msg,msg_len);
 
  cleanup:
  CS_action_string (action);
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s CONTAINER=%s ACT=%s PGM=%s wrote to queue.",
      fn, rss_name, rss_type, oe, ActionString, admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
/****************************************************
 * Procedure Name: CTSRssStatusEvent
 * Description   : RSS status changed.
 * Input         :
 * Output        : RSS name, Rss Status.
 * Input/Output  :
 * Return Value  : ESA_RC
 * Side Effects  :
 * Scope         :
 ***************************************************/
 
ESA_RC CTSRssStatusEvent (RSS_typ                  rss_type,
                          RSS_typ                  rss_name,
                          void                   * handle,
                          RSS_STATUS_typ         * rss_status,
                          ADMIN_PARAMS_rec_typ   * admin_params)
{
  char                  fn[]="CTSRssStatusEvent";
  MSG_typ             * msg_ptr= NULL;
  MSG_typ             * temp_msg= NULL;
  NUM_MSGS_typ          msg_len= 0;
  ESA_RC                rc= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "rss_name=%s rss_type=%s rss_status=%d.",
                   rss_name, rss_type, (int)(*rss_status));
 
  rc= CSA_alloc ((char **)&temp_msg,0,envir_ptr->max_msg_size,
                 1, fn, "temp_msg");
  if (rc NE ESA_OK)
    goto cleanup;
 
  msg_ptr= temp_msg;
 
  msg_len=0;
 
  /* creat message header */
 
  msg_ptr = rss_msg_headr(rss_name,
                          rss_type,
                          msg_ptr,
                          FUNC_RSS_CHECK,
                          &msg_len);
 
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  CS_set_rss_status (msg_ptr, rss_status, &msg_len);
 
  msg_ptr++;
  msg_ptr= CS_set_fld (admin_params->program_name, msg_ptr, &msg_len,
                       FUNC_NAME_LEN, C_FUNC_NAME);
  ESA_DIAG_printf(ESA_COMP_ACSCDCS, DIAG_DETAILES+ 1, "%s=%s.",
	  C_FUNC_NAME, admin_params->program_name);
  if (msg_ptr EQ NULL) {
    rc= ESA_ERR;
    goto cleanup;
  }
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "rs_msg_headr: msg=%.*s.",
                    msg_len, msg_ptr);
 
  CS_set_sngl_msg_len(temp_msg +sizeof (RSS_MSG_HDR_rec_typ)+
                      RSS_NUM_MSGS, msg_len);
  if (rc NE ESA_OK)
    goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "rs_msg_headr: msg=%.*s.",
                    msg_len, msg_ptr);
 
  rc = rss_queue_put (handle, temp_msg, msg_len);
 
  cleanup:
  CSA_free ((char **)&temp_msg);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else
    ESA_DIAG_printf (ESA_COMP_ESARSSF, DIAG_BASIC,
      "*****>... %s for RSS=%s TYPE=%s %s=%d PGM=%s wrote to queue.",
      fn, rss_name, rss_type, ((*rss_status) EQ RSS_UP) ? "RSS_UP" : "RSS_DOWN",
      (int)(*rss_status), admin_params->program_name);
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, rc);
  return(rc);
}  /* End of CTSRssStatusEvent */
 
/****************************************************
 * Procedure Name: CS_set_rss_status
 * Description   : Copy status indication to message
 * Input         :
 * Input/Output  :
 * Return Value  :
 * Comments      :
 * Scope         :
 ******************************************************************/
MSG_typ * CS_set_rss_status (MSG_typ         * buffer,
                             RSS_STATUS_typ  * rss_status,
                             NUM_MSGS_typ    * msg_len)
{
  char fn[]="CS_set_rss_status";
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "msg_len=%d rss_status=%d.",
                   (int)(*msg_len), (int)(*rss_status));
 
  if      ((* rss_status) EQ RSS_UP)
    memcpy((char *)buffer , M_RSS_ACTIVE , 1);
  else
    memcpy((char *)buffer , M_RSS_INACTIVE , 1);
 
  (*msg_len) += 1;
 
  ESA_DIAG_printf (ESA_COMP_ESARSSF, 13,
                   "msg_len=%d rss_status=%c.",
                   (int)(*msg_len), (*buffer));
 
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, ESA_RC_VOID);
  return(buffer + 1);
 
} /* END - CS_set_rss_status */
 
void CS_action_string (ACTION_typ action)
{
  char fn[]="CS_action_string";
 
  ESA_DIAG_enter (ESA_COMP_ESARSSF, DIAG_COMMON, fn);
 
  switch (action) {
    case ACT_UNKNOWN:
     strcpy (ActionString, "ACT_UNKNOWN");
     break;
 
    case ACT_ADD:
     strcpy (ActionString, "ACT_ADD");
     break;
 
    case ACT_UPDATE:
     strcpy (ActionString, "ACT_UPDATE");
     break;
 
    case ACT_DELETE:
     strcpy (ActionString, "ACT_DELETE");
     break;
 
    case ACT_REVOKE:
     strcpy (ActionString, "ACT_REVOKE");
     break;
 
    case ACT_PWD_UPD:
     strcpy (ActionString, "ACT_PWD_UPD");
     break;
 
    case ACT_CONN_UPD:
     strcpy (ActionString, "ACT_CONN_UPD");
     break;
 
    default:
     strcpy (ActionString, "ACT_UNKNOWN");
  }
  ESA_DIAG_exit (ESA_COMP_ESARSSF, DIAG_COMMON, fn, ESA_RC_VOID);
}
 
