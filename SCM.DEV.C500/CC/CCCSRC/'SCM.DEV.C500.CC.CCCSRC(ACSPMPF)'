/*
 * Version Information:
 * ====================
 * File name       : %name: acspmpf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: leonid_s %
 * Created on      : %date_created: Tue Feb 17 12:52:30 2004 %
 * Current Version : %version: 6 %
 * Last Modified by: %derived_by: leonid_s %
 * Last Modified on: %date_modified: Tue Feb 17 12:52:31 2004 %
 */
 
/***********************************************
 * Mod.ID  Who			When         Description
 * =============================================
 * AGGR	   Ajay V		24/06/13	 Bug 11666 (for IdentityIQ)-
 *									 Aggregation performance improvement for Agents.
 * sasc	   NuritV		23/08/16	 Corret SAS/C compile errors.
 * SAS2IBMT SeligT 30/06/16  SAS/C to IBM C Conversion Project
 * AC001   ArunC   12/04/17  CIQ#6-MF acct aggr with conns
 * WS10070 KailasP 23/03/18  set get_conn to 'P' to get
 *                           connection attributes with groups
 * WS10077 KailasP 05/03/20  Set get_conn when called with filter
 * WS10078KGKailasP 23/04/20 Support Role and Source
 * BS10106  KailasP 06/08/20 Dont create list of users
 *                           processed during aggregation
 * WS10079K KailasP 04/01/21 Free handle allocated
 * WS10082K KailasP 11/04/23 Changes related to ADDINFO
 **********************************************/
 
#include "globs.h"
 
#include ERRNO
#include ESA_MSG
#include ESA_CAREUSR
#include ESA_PROC
#include ESA_CS_DBPKG
#include ESA_CS_SINFO
#include ESA_CS_OS
#include ESA_OS_OFLI
#include ESA_OS_EVENT
#include ESA_PUMP
#include ESA_RSS
#include ESA_ADMIN
#include ESA_ESAADI   /*WS10082M*/
 
static ESA_RC CS_dwnld_int_ug_oe  (char ** ug_typ_ptr,
                                   int   * ug_mem_num);
 
static ESA_RC CS_dwnld_u2ug_oe_add (RSS_MSG_HDR_rec_typ  * msg_hdr,
                             STATIST_rec_typ      * statist,
                             char                 * ug_typ_ptr,
                             int                    ug_mem_num);
 
/****************************************************
 * Procedure Name: CS_dwld_mem_users_fill
 * Description   : Fill next portion of users from the
 *                 memory list of interesting users
 * Comments      :
 * Scope         :
 ****************************************************/
 
void CS_dwld_mem_users_fill (char     * user_memory,
                             int        num_of_user,
                             int      * from_num_user,
                             short    * filled_num_users,
                             USER_typ * usr_in)
{
  int  ii;
  char fn[]="CS_dwld_mem_users_fill";
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSPMPF, 13,
                   "Num.of users=%d Fron user num=%d.",
                   num_of_user, * from_num_user);
 
  (*filled_num_users)= 0;
  for (ii= (*from_num_user);
       ii LT num_of_user AND (*filled_num_users) LT MAX_GET;
       ii++, (*filled_num_users)++)
  {
     strcpy (usr_in[*filled_num_users],
		     user_memory+ (sizeof (USER_typ)* ii));
     ESA_DIAG_printf (ESA_COMP_ACSPMPF, 16,
                      "%d+ %d: user=%s.",
                       ii, *filled_num_users ,
					   usr_in[*filled_num_users]);
  }
 
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, ESA_OK);
 
}
 
 
 
/****************************************************
 * Procedure Name: CS_dwnld_ess_definitions
 * Description   : download functions
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_ess_definitions (MSG_typ              * msg_ptr,
                                 RSS_MSG_HDR_rec_typ  * msg_hdr_cd)
{
  char                  fn[]="CS_dwnld_ess_definitions";
  ESA_RC                rc=      ESA_OK, rc_unlock= ESA_OK;
  ESA_RC                rc_load= ESA_OK, rc_send=   ESA_OK;
  int                   sw= 0, sw_abort= 0;
  unsigned int          ii = 0;
  CSFLAG                current_srv= CSON;
  char                  dwnld_sync_method=' ',dwnld_type=' ',
                        dwnld_from=' ';
  char download_type; /*AGGR */
  char                  dwnld_user_list, dwnld_group_list;
  char                  dwnld_conn_list, dwnld_oe_list;
  char                  last_mhltl= ' ';
  char                  ddn_with[50]="";                  /* SAS2IBMT */
  OE_typ                dwnld_from_oe;
  UG_typ                dwnld_from_group;
  USER_typ              dwnld_from_user;
  STATIST_rec_typ       statist;
  RESOURCE_typ          semaphore_file ;
  char                  interval[RSSPRM_VALUE_LEN+ 1];
  RSS_MSG_HDR_rec_typ   msg_hdr, msg_hdr_sav;
  DATE_typ              cur_date;
  TIME_typ              cur_time;
  ENVIRONMENT_rec_typ * envir_ptr;
  RSS_INTEREST_rec_typ * interest;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  memset ((char *)(&statist), '\0', sizeof(STATIST_rec_typ));
  memset ((char *)semaphore_file, '\0', sizeof(RESOURCE_typ));
  memset ((char *)(&msg_hdr), '\0', sizeof( RSS_MSG_HDR_rec_typ));
  envir_ptr->dwnld_sync_type= DWNLD_SYNC_UNDEFINED;
  CLEAR(dwnld_from_oe);
  CLEAR(dwnld_from_group);
  CLEAR(dwnld_from_user);
 
/* Set interval for statistic messages */
  envir_ptr->stop_req_msgs= 0;
  rc= rssprm_get (envir_ptr->all_rss, STOP_REQ_MSGS, 10, interval);
  if (rc EQ ESA_OK) {
    ii= strspn (interval, POSITIVE_VALUE);
    if (ii NE strlen (interval))
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     STOP_REQ_MSGS, interval,envir_ptr->file_rssparm);
    else
      envir_ptr->stop_req_msgs = atoi (interval);
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
                     "By default %s parameter from %s is %d.",
                     STOP_REQ_MSGS, envir_ptr->file_rssparm,
					 envir_ptr->stop_req_msgs);
 
  statist.interval_num= STATIST_INTERVAL;
  rc= rssprm_get_opt (envir_ptr->all_rss, STATIST_INTRVL, 10,
                	  interval, OPT_TRUE, OPT_TRUE);
  if (rc EQ ESA_OK) {
    ii= strspn (interval, POSITIVE_VALUE);
    if (ii NE strlen (interval))
      CTSAMSG_print (ERR_CS_PRM_NOT_NUMERIC,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     STATIST_INTRVL, interval,
                     envir_ptr->file_rssparm);
    else
      statist.interval_num= atoi (interval);
  }
  else
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
        "%s parameter from %s is %s",
        STATIST_INTRVL, envir_ptr->file_rssparm, interval);
 
  statist.process= DWNLD_PROCESS;
 
  CSA_print_alloc_tbl (ESA_COMP_ACSPMPF, fn, TRUE);
  CSA_print_lock_tbl();
 
  memcpy ((char *)(&msg_hdr_sav), (char *)msg_hdr_cd,
          sizeof( RSS_MSG_HDR_rec_typ));
 
  rc= CSA_lock (
      envir_ptr->interest[envir_ptr->rss_num].file_ofli_semaphore,
      fn, SCOPE_LOCAL);
  if (rc NE ESA_OK)
  {
    CTSAMSG_print (MSG_DWNLD_STOPED,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
				   envir_ptr->msg_admin_param.rss_name);
    goto cleanup;
  }
 
  CARE_inc_oe_free ();
  CARE_inc_ug_free ();
  CARE_inc_usr_free ();
  CARE_inc_u2ug_free ();
 
/* Get messages from ESS */
  while (current_srv EQ CSON) {
 
    CLEAR(msg_ptr);
 
    rc= CS_get_next_msg (msg_ptr , &msg_hdr);
 
    memcpy ((char *)(&msg_hdr_sav) , (char *)(&msg_hdr),
            sizeof( RSS_MSG_HDR_rec_typ));
 
    last_mhltl= msg_hdr.mhltl;
 
    if (rc NE ESA_OK ) {
      goto cleanup;
    }
 
    /* intersting user-groups */
    else if (COND(MSG_INTEREST_OE)) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
           "*****>... %s - Scope for Containers.", MSG_INTEREST_OE);
      rc=CS_dwnld_inc_oe(msg_ptr, &statist);
    }
    /* intersting user-groups */
    else if (COND(MSG_INTEREST_UG)) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
           "*****>... %s - Scope for Default Groups.", MSG_INTEREST_UG);
      rc=CS_dwnld_inc_ug(msg_ptr, &statist);
    }
    /* intersting users */
    else if (COND(MSG_INTEREST_USER)) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
           "*****>... %s - Scope for Users.", MSG_INTEREST_USER);
      rc=CS_dwnld_inc_usr(msg_ptr, &statist);
    }
    /* intersting connections */
    else if (COND(MSG_INTEREST_UG2UC)) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
           "*****>... %s - Scope for Groups.", MSG_INTEREST_UG2UC);
      rc=CS_dwnld_inc_u2ug(msg_ptr, &statist);
    }
    /* Start dwnld */
    else if (COND(MSG_DWNLD)) {
       sw++;
       if (sw EQ 1)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
           "*****>... %s - First Inform. Aggregation Message.", MSG_DWNLD);
          CLEAR (cur_date);
          CLEAR (cur_time);
          CS_get_cur_time (cur_date, cur_time);
          rc= CS_get_dwnld_params (msg_ptr,&dwnld_sync_method,
                                   &dwnld_type,
                                  &dwnld_from, &dwnld_user_list,
                                  &dwnld_group_list,
                                  &dwnld_conn_list, &dwnld_oe_list,
                                  dwnld_from_oe,
                                  dwnld_from_group, dwnld_from_user, &download_type); /* AGGR */
       }
       if (sw EQ 2)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
           "*****>... %s - Last Inform. Aggregation Message.", MSG_DWNLD);
		  if (envir_ptr->dwnld_sync_type EQ DWNLD_INITIAL)
		  {
             rc= rssprm_get_opt (envir_ptr->interest[envir_ptr->rss_num].rss,
				                 DOWNLOAD_TO_FILE, 1,interval, OPT_TRUE, OPT_TRUE);
             if (rc EQ ESA_OK)
			 {
                if (interval[0] EQ ESS_YES_SIGN)
				{
                   char download_msg[512];
                   strcpy(ddn_with,"DD:");                    /* SAS2IBMT */
                   strcat(ddn_with, envir_ptr->file_download);/* SAS2IBMT */
                   /* strcpy(ddn_with,"//'");                    SAS2IBMT */
                   /* strcat(ddn_with, envir_ptr->file_download); SAS2IBMT */
                   /* strcat(ddn_with,"'");                      SAS2IBMT */
                   ESA_DIAG_printf(ESA_COMP_ACSPMPF, 0,       /* SAS2IBMT */
                       "ACSPMPF: About to fopen %s", envir_ptr->file_download);
                   /* SAS2IBMT
                   envir_ptr->download_hndl= fopen (envir_ptr->file_download, FILE_APPEND); */
                   envir_ptr->download_hndl= fopen (ddn_with, FILE_APPEND); /* SAS2IBMT */
		           if (envir_ptr->download_hndl)
				   {
              sprintf (download_msg, "Start Aggregation for Connector %s.\n",
              envir_ptr->interest[envir_ptr->rss_num].rss);
		            fputs (download_msg, envir_ptr->download_hndl);
				   }
		           else
				   {
                      rc= ESA_ERR;
                      CTSAMSG_print(ERR_IO,
						  envir_ptr->ctsamsg_handle, NULL, envir_ptr->ctsamsg_dest,
                          fn, "open", envir_ptr->file_download, strerror(errno));
                      goto cleanup;
				   }
				}
			 }
		  }
          rc= CS_download (&msg_hdr, &statist,
                           &dwnld_sync_method, &dwnld_type, &dwnld_from,
                           &dwnld_user_list, &dwnld_group_list,
                           &dwnld_conn_list, &dwnld_oe_list,
                           dwnld_from_oe,
                           dwnld_from_group,dwnld_from_user, download_type); /* AGGR */
 
		  if (rc EQ ESA_ABORT_REQ)
              sw_abort= 1;
          if (
               (rc EQ ESA_OK)
              OR
               (rc EQ ESA_ABORT_REQ)
             )
          {
             /* Update RSSOFLI file with Download statr time */
             if (
                   (rc EQ ESA_OK)
                  AND
                   (dwnld_type EQ M_DWNLD_INITIAL)
                )
             {
                rc= CS_dwnld_sync_start(dwnld_sync_method,
					                    cur_date,
                                        cur_time);
                if (rc EQ ESA_OK)
                    rc= OS_OFLI_sync (
                           envir_ptr->msg_admin_param.rss_type ,
                           envir_ptr->msg_admin_param.rss_name ,
                           &envir_ptr->func_ptr,
                           &envir_ptr->msg_admin_param);
             }
             if (envir_ptr->download_hndl)
			 {
         char download_msg[512];
 
         sprintf (download_msg, "End Aggregation for Connector %s.\n",
			    envir_ptr->interest[envir_ptr->rss_num].rss);
                fputs (download_msg, envir_ptr->download_hndl);
                rc= fclose (envir_ptr->download_hndl);
                envir_ptr->download_hndl= NULL;
                if (rc NE ESA_OK) {
                  /*envir_ptr->msg_dest->dests[CTSAMSG_DEST_CNSL].active= FLAG_YES;*/
                  CTSAMSG_print (ERR_CS_CLOSE_FILE,
                       envir_ptr->ctsamsg_handle, NULL,
                       envir_ptr->ctsamsg_dest,
                       fn, envir_ptr->file_download, "fclose", strerror(errno)) ;
                  /*envir_ptr->msg_dest->dests[CTSAMSG_DEST_CNSL].active= FLAG_NO;*/
				}
			 }
             rc_send= CS_send_end_of_dwnld_msg(&msg_hdr);
             if (rc NE ESA_OK)
        envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method =
        envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method;
             else
        envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method=
        envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method;
             last_mhltl = BLANK;
          }
       }
    }
 
    /* End of service indicator */
    else if (COND(END_OF_SERVICE))
	{
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
         "*****>... %s - End of Aggregation Service.", END_OF_SERVICE)  ;
      current_srv = CSOFF;
	}
    /* undefined service */
    else {
      CTSAMSG_print (ERR_CS_UNDEF_MSG_TYP,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest, fn,
                     &msg_hdr.mhmtyp);
      rc = ESA_FATAL;
      goto cleanup;
    }
 
    /* close CS */
    if (rc EQ ESA_TERM_CTSA) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15, "Accepted TERM_CTSA code");
      current_srv = CSOFF;
    }
 
    /* error occurred */
    else  if (
               (rc NE ESA_OK)
              AND
               (rc NE ESA_ABORT_REQ)
             )
              goto cleanup;
 
    /* last message indication the same as end of service*/
    else if (msg_hdr.mhltl EQ MH_MESSAGE_LAST)
      current_srv = CSOFF;
 
    /* confirm message on temp last condition */
    else if (last_mhltl EQ MH_MESSAGE_LAST_TMP) {
      rc = CS_confirm (&msg_hdr);
      if (rc NE ESA_OK) {
        goto cleanup;
      }
    }
  }
 
  cleanup:
 
  if ( (sw_abort) AND (rc NE ESA_TERM_CTSA) )
      rc= ESA_ABORT_REQ;
 
  CARE_inc_oe_free ();
  CARE_inc_ug_free ();
  CARE_inc_usr_free ();
  CARE_inc_u2ug_free ();
  CARE_int_oe_free ();
  CARE_int_ug_free ();
  CARE_int_usr_free ();
  CARE_int_u2ug_free ();
  envir_ptr->oes_ptr= NULL;
  envir_ptr->num_oes= 0;
  envir_ptr->ugs_ptr= NULL;
  envir_ptr->num_ugs= 0;
  envir_ptr->users_ptr= NULL;
  envir_ptr->num_users= 0;
  envir_ptr->u2ugs_ptr= NULL;
  envir_ptr->num_u2ugs= 0;
 
  /* WS10078KG - Lets not Rebuild care files of other    *
   *             entities during source/role aggregation */
  if ( download_type NE DWNLD_ROLE_SERVICE AND
            download_type NE DWNLD_SOURCE_SERVICE )
  {
    /* WS10078KG  */
     rc_load= CARE_int_oe_load ();
     if (rc_load EQ ESA_OK)
         rc_load= CARE_int_ug_load ();
     if (rc_load EQ ESA_OK)
         rc_load= CARE_int_usr_load ();
     if (rc_load EQ ESA_OK)
         rc_load= CARE_int_u2ug_load ();
     if (rc EQ ESA_OK)
         rc= rc_load;
     if (rc EQ ESA_OK)
     {
           interest= envir_ptr->interest+ envir_ptr->rss_num;
      	 if (0 LT interest->pre_num_oes+
      		      interest->pre_num_ugs+
      			  interest->pre_num_u2ugs+
      			  interest->pre_num_users)
      	 {
              CTSAMSG_print (MSG_AGENT_INTEREST_SCOPE,
                             envir_ptr->msg_admin_param.ctsamsg_handle,
                             NULL,
                             envir_ptr->msg_admin_param.ctsamsg_dest,
      					   interest->rss);
              CARE_list_oe  (interest->pre_oes_ptr,
      			           interest->pre_num_oes);
              CARE_list_ug  (interest->pre_ugs_ptr,
      			           interest->pre_num_ugs);
              CARE_list_u2ug(interest->pre_u2ugs_ptr,
      			           interest->pre_num_u2ugs);
              CARE_list_usr (interest->pre_users_ptr,
      			           interest->pre_num_users);
      	 }
     }
  } /* WS10078KG */
 
  CS_dwnld_event (&statist, STEP_END_PROC, END_FN, rc);
 
  if (rc EQ ESA_OK AND
      (dwnld_type EQ M_DWNLD_INITIAL OR
       dwnld_type EQ M_DWNLD_INCREMENT))
     rc= CS_broadcast (CS_BRDCT_EVNT_INTRST,
                       EVENT_IMPOE_CHANGED);
 
  rc_unlock= CSA_unlock
     (envir_ptr->interest[envir_ptr->rss_num].file_ofli_semaphore, fn);
  if (rc EQ ESA_OK)
    rc= rc_unlock;
  if ((rc EQ ESA_OK) OR (rc EQ ESA_ABORT_REQ))
       rc= rc_send;
 
  CSA_print_alloc_tbl (ESA_COMP_ACSPMPF, fn, TRUE);
  CSA_print_lock_tbl();
 
  if (rc EQ ESA_CANCEL_SERVICE)
    CTSAMSG_print (ERR_CS_SERVICE_CANCEL,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn);
 
  if ((rc NE ESA_OK) AND
      (rc NE ESA_TERM_CTSA)AND
      (rc NE ESA_CANCEL_SERVICE))
    CTSAMSG_print (ERR_CS_SERVICE,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   fn, envir_ptr->msg_ptr);
 
  envir_ptr->dwnld_sync_type= DWNLD_SYNC_UNDEFINED;
 
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
 
  if (envir_ptr->download_hndl)
  {
     fclose (envir_ptr->download_hndl);
     envir_ptr->download_hndl= NULL;
  }
  return(rc);
 
} /* End of CS_dwnld_ess_definitions */
 
 
 
/****************************************************
 * Procedure Name: CS_get_dwnld_params
 * Description   : Get download process parameters:
 * Input         : msg_ptr
 * Output        : dwnld_sync_method,
 *               : dwnld_type,
 *                 dwnld_from,
 *                 dwnld_user_list,
 *                 dwnld_group_list,
 *                 dwnld_conn_list,
 *                 dwnld_oe_list,
 *                 dwnld_from_oe,
 *                 dwnld_from_group,
 *                 dwnld_from_user)
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_get_dwnld_params (MSG_typ          * msg_ptr,
                            char             * dwnld_sync_method,
                            char             * dwnld_type,
                            char             * dwnld_from,
                            char             * dwnld_user_list,
                            char             * dwnld_group_list,
                            char             * dwnld_conn_list,
                            char             * dwnld_oe_list,
                            OE_typ             dwnld_from_oe,
                            UG_typ             dwnld_from_group,
                            USER_typ           dwnld_from_user,
							char *download_type) /* AGGR */
{
  char                  fn[]="CS_get_dwnld_params";
  ESA_RC                rc= ESA_OK;
  char  MethodStr[20]="", ListOE[25]="", ListUG[25]="", ListUSR[25]="", ListDUG[25]="";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
    /* First message of dwnld service */
    msg_ptr = CS_get_aplic_msg(msg_ptr);
 
    /* Get dwnld first/increment code */
    if (*msg_ptr NE M_DWNLD_INITIAL     AND
        *msg_ptr NE M_DWNLD_INCREMENT)
    {
       *((char *)msg_ptr+ 2)= '\0';
       CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      fn , C_DWNLD_TYPE);
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Proc type %c.",*msg_ptr);
       rc = ESA_ERR;
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Aggregation (%d): type %c rc %d.",
                    envir_ptr->rss_num, *msg_ptr, (int)rc);
       goto cleanup;
    }
    *dwnld_type= *msg_ptr;
    if (*msg_ptr EQ M_DWNLD_INITIAL)
        envir_ptr->dwnld_sync_type= DWNLD_INITIAL;
    if (*msg_ptr EQ M_DWNLD_INCREMENT)
        envir_ptr->dwnld_sync_type= DWNLD_INCREMENT;
 
    /* Get dwnld ALL/MANY/OE code */
    msg_ptr++;
    if (
        (*msg_ptr NE M_DWNLD_SYNC_METHOD_ALL_RSS)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_METHOD_LIST)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_METHOD_SUBTREE)
        )
    {
       *((char *)msg_ptr+ 1)= '\0';
       CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      fn , C_DWNLD_SYNC_METHOD);
       rc = ESA_ERR;
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Aggregation (%d): mode %c rc %d.",
                    envir_ptr->rss_num, *msg_ptr, (int)rc);
       goto cleanup;
    }
    *dwnld_sync_method= *msg_ptr;
    if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_SUBTREE)
		strcpy (MethodStr, "SUBTREE");
	else if (*dwnld_sync_method EQ M_DWNLD_SYNC_METHOD_LIST)
		strcpy (MethodStr, "LIST");
	else
		strcpy (MethodStr, "ALL RSS");
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_BASIC, "*************");
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_BASIC,
     "*****> Aggregation for RSS %s %s is %s (%c %d) by %s Metod.",
     envir_ptr->interest[envir_ptr->rss_num].rss,
		envir_ptr->interest[envir_ptr->rss_num].rss_type,
		(*dwnld_type EQ M_DWNLD_INITIAL) ? "INITIAL" : "INCREMENTAL",
		*dwnld_type, (int)envir_ptr->dwnld_sync_type, MethodStr);
 
    /* Get dwnld from the beginning/user/group/connection code */
    msg_ptr++;
    if (*msg_ptr NE M_DWNLD_FROM_NOT_SPECIFIED   AND
        *msg_ptr NE M_DWNLD_FROM_SPEC_CONTAINER  AND
        *msg_ptr NE M_DWNLD_FROM_SPEC_USER       AND
        *msg_ptr NE M_DWNLD_FROM_SPEC_GROUP      AND
        *msg_ptr NE M_DWNLD_FROM_SPEC_CONNECTION)
    {
       *((char *)msg_ptr+ 1)= '\0';
       CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      fn , C_DWNLD_FROM);
       rc = ESA_ERR;
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Aggregation (%d): from %c rc %d.",
                    envir_ptr->rss_num, *msg_ptr, (int)rc);
       goto cleanup;
    }
    *dwnld_from= *msg_ptr;
    msg_ptr++;
 
    if (
        ((*dwnld_type)    EQ M_DWNLD_INCREMENT)
            AND
            ((*dwnld_sync_method)  NE
             envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method)
            AND
            ((*dwnld_sync_method)  NE M_DWNLD_SYNC_METHOD_ALL_RSS)
        )
    {
        *((char *)msg_ptr)= '\0';
        CTSAMSG_print (ERR_DWNLD_CHANGE_MODE,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
        ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
     "Aggregation with type %c curr.mode %c prev. mode %c unsupported",
        *dwnld_type, *dwnld_sync_method,
        envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method);
        rc = ESA_ERR;
        goto cleanup;
    }
 
    /* Get 'from container' data */
    msg_ptr = CS_get_fld (dwnld_from_oe ,
                          msg_ptr,
                          envir_ptr->rss_limits.max_oe_len,
                          C_OE_ID);
    if (msg_ptr EQ NULL)
    {
        rc = ESA_ERR;
        goto cleanup;
    }
 
    /* Get 'from group' data */
    msg_ptr = CS_get_fld (dwnld_from_group ,
                          msg_ptr,
                          envir_ptr->rss_limits.max_ug_len,
                          C_GROUP_ID);
    if (msg_ptr EQ NULL)
    {
        rc = ESA_ERR;
        goto cleanup;
    }
 
    /* Get 'from user' data */
    msg_ptr = CS_get_fld (dwnld_from_user ,
                          msg_ptr,
                          envir_ptr->rss_limits.max_user_len,
                            C_USER_ID);
    if (msg_ptr EQ NULL)
    {
        rc = ESA_ERR;
        goto cleanup;
    }
 
    if (
        (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
        )
    {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                   "Aggregation (%d): mode %c rc %d.",
                   envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
    }
    *dwnld_oe_list= *msg_ptr;
	if (*dwnld_oe_list EQ M_DWNLD_SYNC_LIST_NOT)
		strcpy (ListOE, "EMPTY OE LIST");
	else if (*dwnld_oe_list EQ M_DWNLD_SYNC_LIST_ALL)
		strcpy (ListOE, "ALL OEs");
	else if (*dwnld_oe_list EQ M_DWNLD_SYNC_LIST_YES)
		strcpy (ListOE, "LIST of OEs");
    msg_ptr++;
 
    if (
        (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
        )
    {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                   "Aggregation (%d): mode %c rc %d.",
                   envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
    }
    *dwnld_group_list= *msg_ptr;
	if (*dwnld_group_list EQ M_DWNLD_SYNC_LIST_NOT)
		strcpy (ListDUG, "EMPTY DEFAULT GROUP LIST");
	else if (*dwnld_group_list EQ M_DWNLD_SYNC_LIST_ALL)
		strcpy (ListDUG, "ALL DEFAULT GROUPS");
	else if (*dwnld_group_list EQ M_DWNLD_SYNC_LIST_YES)
		strcpy (ListDUG, "LIST of DEFAULT GROUPS");
    msg_ptr++;
 
    if (
        (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
        )
    {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                   "Aggregation (%d): mode %c rc %d.",
                   envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
    }
    *dwnld_user_list= *msg_ptr;
	if (*dwnld_user_list EQ M_DWNLD_SYNC_LIST_NOT)
		strcpy (ListUSR, "EMPTY USER LIST");
	else if (*dwnld_user_list EQ M_DWNLD_SYNC_LIST_ALL)
		strcpy (ListUSR, "ALL USERS");
	else if (*dwnld_user_list EQ M_DWNLD_SYNC_LIST_YES)
		strcpy (ListUSR, "LIST of USERS");
    msg_ptr++;
 
    if (
        (*msg_ptr NE M_DWNLD_SYNC_LIST_NOT)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL)
            AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_YES)
			   AND                                         /* AGGR */
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL_GROUPS)
          AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL_ACCS)
          AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL_ACC_CONN)
          /* WS10078KG - Start */
          AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL_ROLES)
          AND
            (*msg_ptr NE M_DWNLD_SYNC_LIST_ALL_SOURCES)
          /* WS10078KG - End */
        )
    {
      *((char *)msg_ptr+ 1)= '\0';
      CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn , C_DWNLD_LIST);
      rc = ESA_ERR;
      ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                   "Aggregation (%d): mode %c rc %d.",
                   envir_ptr->rss_num, *msg_ptr, (int)rc);
      goto cleanup;
    }
    *dwnld_conn_list= *msg_ptr;
    *download_type = DWNLD_SERVICE;       /* AGGR */
	if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_NOT)
		strcpy (ListUG, "EMPTY GROUP LIST");
	else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_ALL)
		strcpy (ListUG, "ALL GROUPS");
	else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_YES)
		strcpy (ListUG, "LIST of GROUPS");
	else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_ALL_GROUPS)    /* AGGR */
	{
	   strcpy (ListUG, "ALL GROUPS");
	   *download_type = DWNLD_GROUP_SERVICE;
	   *dwnld_conn_list = M_DWNLD_SYNC_LIST_ALL;
	}
    else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_ALL_ACCS)
	{
	   strcpy (ListUG, "ALL GROUPS");
	   *download_type = DWNLD_USER_SERVICE;
	   *dwnld_conn_list = M_DWNLD_SYNC_LIST_ALL;
	}
    else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_ALL_ACC_CONN)
	{
       strcpy (ListUG, "ALL GROUPS");
	   *download_type = DWNLD_USER_CONN_SERVICE;
	   *dwnld_conn_list = M_DWNLD_SYNC_LIST_ALL;
	}
 /* WS10078KG - Start */
 else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_ALL_ROLES)
 {
    strcpy (ListUG, "ALL ROLES");
    *download_type = DWNLD_ROLE_SERVICE;
    *dwnld_conn_list = M_DWNLD_SYNC_LIST_ALL;
 }
 else if (*dwnld_conn_list EQ M_DWNLD_SYNC_LIST_ALL_SOURCES)
 {
    strcpy (ListUG, "ALL SOURCES");
    *download_type = DWNLD_SOURCE_SERVICE;
    *dwnld_conn_list = M_DWNLD_SYNC_LIST_ALL;
 }
 /* WS10078KG - End */
 
	ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
 "**> Aggregation for Connector %s %s with %s (%c) %s (%c) %s (%c) %s (%c) (%c).", /* AGGR */
 envir_ptr->interest[envir_ptr->rss_num].rss,
		envir_ptr->interest[envir_ptr->rss_num].rss_type,
		ListOE, *dwnld_oe_list, ListDUG, *dwnld_group_list,
	ListUSR, *dwnld_user_list, ListUG, *dwnld_conn_list, *download_type); /* AGGR */
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_BASIC, "*************");
 
    if (*dwnld_type EQ M_DWNLD_INITIAL)
    {
       CARE_int_oe_free ();
       CARE_int_usr_free ();
       CARE_int_ug_free  ();
       CARE_int_u2ug_free  ();
    }
    if (*dwnld_type EQ M_DWNLD_INCREMENT)
    {
       if (ESA_DIAG_get_debug_level(ESA_COMP_ACSPMPF) GE 16)
       {
          CARE_int_list_oe();
          CARE_int_list_ug();
          CARE_int_list_u2ug();
          CARE_int_list_usr();
       }
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
     "Aggregation (%d): type %c mode curr/prev %c/%c from %c rc %d.",
      envir_ptr->rss_num, *dwnld_type, *dwnld_sync_method,
      envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method,
      *dwnld_from, (int)rc);
    if (rc EQ ESA_OK)
       envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method =
           *dwnld_sync_method;
 
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return(rc);
}
 
 
 
/****************************************************
 * Procedure Name: CS_dwnld_inc_oe
 * Description   : Handle "INTERESTING CONTAINERS"
 *                 message.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION:
 * =====================
 *
 * This function is activated by the "GLOBAL SYNC" handler and by the
 * "download" service handler upon receiving a message of interesting
 * containerss. The function scans all container names in the list
 * verify it's uniqness (among other containers in current message,
 * among previouse received container names , and adds the container
 * names to the list of increment container names in the memory.
 *******************************************************************/
 
ESA_RC  CS_dwnld_inc_oe (MSG_typ         * msg_ptr,
                         STATIST_rec_typ * statist)
{
  char fn[]="CS_dwnld_inc_oe";
  unsigned int          ii=0;
  int                   jj= 0, kk= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  ESA_RC                rc= ESA_OK, rc_oe= ESA_OK;
  ESS_INTRST_typ        interest= ESS_DONT_CARE;
  MEMBER_OE_rec_typ     tmp_oe [TMP_OES_NUM];
  TRAN_rec_typ          tran;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Started %s.",fn);
  /*
    CLEAR temporary buffers.
  */
  CLEAR (tmp_oe);
  CLEAR_STRUCT(tran);
 
  if (msg_ptr NE NULL)
  {
     /*
       GET the GENERAL message header.
     */
     msg_ptr = CS_get_aplic_msg(msg_ptr);
     /*
       GET the RSS message header (number of internal messages).
     */
     msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
     if (msg_ptr EQ NULL)
     {
       rc = ESA_ERR;
       goto cleanup;
     }
  }
  else
  {
     num_msgs = 1;
     tmp_oe[0].oe[0] = '\0';
     tmp_oe[0].member_type = M_DWNLD_NAME_ALL;
  }
 /*
    PROCESS all internal RSS messages (containing the int. oes):
  */
  for (ii =0,jj= 0; ii LT num_msgs AND rc EQ ESA_OK; ii++)
  {
     if (msg_ptr NE NULL)
     {
        /*
         * GET internal message's transaction & action id.
         */
        msg_ptr = CS_get_singl_msg(&len_msg, &tran , msg_ptr);
        if (msg_ptr EQ NULL)
        {
           rc = ESA_ERR;
           goto cleanup;
        }
        /*
         * GET next increment container name
         */
        if (*msg_ptr NE M_DWNLD_NAME_REGULAR)
        {
          CTSAMSG_print (ERR_CS_MSG_GET_FLD,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               fn, C_MEMBER_TYPE);
          ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Member type %c.",*msg_ptr);
          rc = ESA_ERR;
          goto cleanup;
        }
        tmp_oe[jj].member_type = *msg_ptr;
        msg_ptr++;
        msg_ptr = CS_get_fld (tmp_oe[jj].oe ,
                              msg_ptr,
                              envir_ptr->rss_limits.max_oe_len ,
                              C_OE_ID);
        if (msg_ptr EQ NULL)
        {
           rc = ESA_ERR;
           goto cleanup;
        }
     }
     if (tmp_oe[jj].oe[0] EQ '\n')
        tmp_oe[jj].oe[0] = '\0';
     if (tmp_oe[jj].member_type EQ M_DWNLD_NAME_ALL)
        tmp_oe[jj].oe[0] = '\0';
    /*
      IGNORE null group names if type is M_DWNLD_NAME_ALL.
    */
    if (
        (strlen (tmp_oe[jj].oe) EQ 0)
            AND
            (tmp_oe[jj].member_type NE M_DWNLD_NAME_ALL)
        )
	{
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Current empty container with %c type SKIPPED !!!", tmp_oe[jj].member_type);
      continue;
	}
 
    /*
      SEARCH the current container name among the container names
      that have already been processed in current message (duplicate
      container names).
    */
    for (kk= 0; kk LT jj; kk++)
    {
       if (
           (strcmp (tmp_oe[kk].oe, tmp_oe[jj].oe) EQ 0)
               AND
               (tmp_oe[kk].member_type EQ tmp_oe[jj].member_type)
           )
          break;
    }
    if (kk LT jj)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
               "Current Duplicate container=%s !!!", tmp_oe[jj].oe);
       continue;
    }
 
    /*
      CHECK if container is already included in increment
      container names.
    */
    rc_oe= CARE_inc_oe_find (tmp_oe[jj].oe);
    if (rc_oe EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
           "Incremental Duplicate container=%s !!!", tmp_oe[jj].oe);
       continue;
    }
 
    /*
      CHECK if container is already included in interesting container
      names.
    */
    if (envir_ptr->dwnld_sync_type NE SYNC_PARTIAL)
    {
       CARE_int_oe_find (tmp_oe[jj].oe, &interest);
       if (interest EQ ESS_OE_CARE)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
                        "Duplicate container=%s SKIPPED !!!", tmp_oe[jj].oe);
          continue;
       }
    }
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES+ 1,
                     "container=%s type %c ADDED to list",
                     tmp_oe[jj].oe, tmp_oe[jj].member_type);
    /*
      ADD this container in list of containers processed in
      current message.
    */
    if (statist NE NULL)
       statist->oe_inc++;
    jj++;
 
    /*
      PROCESS when the temporary containers array is full:
    */
    if (jj EQ TMP_OES_NUM- 1)
    {
       /*
         COPY all containers from temporary array to memory, and
         clear the array.
         */
       rc= CARE_inc_oe_to_memory (tmp_oe, jj);
       CLEAR (tmp_oe);
       jj= 0;
    }
  }
  /*
    PROCESS when the temporary array contains containers:
  */
  if (jj NE 0)
  {
      /*
        COPY all containers from temporary array to memory,
        and clear the array.
      */
      rc= CARE_inc_oe_to_memory (tmp_oe, jj);
      CLEAR (tmp_oe);
      jj= 0;
  }
  cleanup:
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Ended %s.",fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_dwnld_inc_oe function */
 
/****************************************************
 * Procedure Name: CS_dwnld_inc_ug
 * Description   : Handle "INTERESTING DEFAULT GROUPS"
 *                 message.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION:
 * =====================
 *
 * This function is activated by the "GLOBAL SYNC" handler and by the
 * "download" service handler upon receiving a message of interesting
 * "DEFAULT" groups. The function scans all group names in the list
 * verify it's uniqness (among other groups in current message,
 * among previouse received DEFAULT group names and among the previouse
 * defined interesting DEFAULT groups), and adds the group names to the
 * list of increment DEFAULT group names in the memory.
 *******************************************************************/
 
ESA_RC  CS_dwnld_inc_ug (MSG_typ         * msg_ptr,
                         STATIST_rec_typ * statist)
{
  char fn[]="CS_dwnld_inc_ug";
  unsigned int          ii=0;
  int                   jj= 0, kk= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  ESA_RC                rc= ESA_OK, rc_ug= ESA_OK;
  ESS_INTRST_typ        interest= ESS_DONT_CARE;
  MEMBER_UG_rec_typ     tmp_ug [TMP_UGS_NUM];
  TRAN_rec_typ          tran;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Started %s.",fn);
  /*
    CLEAR temporary buffers.
  */
  CLEAR (tmp_ug);
  CLEAR_STRUCT(tran);
  /*
    GET the GENERAL message header.
  */
  if (msg_ptr NE NULL)
  {
     msg_ptr = CS_get_aplic_msg(msg_ptr);
     /*
       GET the RSS message header (number of internal messages).
     */
     msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
     if (msg_ptr EQ NULL)
     {
       rc = ESA_ERR;
       goto cleanup;
     }
  }
  else
  {
     num_msgs = 1;
     tmp_ug[0].ug[0] = '\0';
     tmp_ug[0].member_type = M_DWNLD_NAME_ALL;
  }
  /*
    PROCESS all internal RSS messages (containing the interesting ugs):
  */
  for (ii =0, jj= 0; ii LT num_msgs AND rc EQ ESA_OK; ii++)
  {
 
     if (msg_ptr NE NULL)
     {
       /*
         GET internal message's transaction & action id.
       */
       msg_ptr = CS_get_singl_msg(&len_msg, &tran , msg_ptr);
       if (msg_ptr EQ NULL)
       {
         rc = ESA_ERR;
         goto cleanup;
       }
       /*
         GET next increment group name
       */
       if (*msg_ptr NE M_DWNLD_NAME_REGULAR)
       {
          CTSAMSG_print (ERR_CS_MSG_GET_FLD,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               fn, C_MEMBER_TYPE);
          ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Member type %c.",*msg_ptr);
          rc = ESA_ERR;
          goto cleanup;
       }
       tmp_ug [jj].member_type = *msg_ptr;
 
       msg_ptr++;
 
       msg_ptr = CS_get_fld (tmp_ug[jj].ug ,
                             msg_ptr,
                             envir_ptr->rss_limits.max_ug_len ,
                             C_GROUP_ID);
       if (msg_ptr EQ NULL)
       {
         rc = ESA_ERR;
         goto cleanup;
       }
     }
     if (tmp_ug[jj].ug[0] EQ '\n')
        tmp_ug[jj].ug[0] = '\0';
     if (tmp_ug[jj].member_type EQ M_DWNLD_NAME_ALL)
        tmp_ug[jj].ug[0] = '\0';
 
    /*
      IGNORE null group names if type is M_DWNLD_NAME_ALL.
    */
    if (
         (strlen (tmp_ug[jj].ug) EQ 0)
        AND
         (tmp_ug[jj].member_type NE M_DWNLD_NAME_ALL)
       )
	{
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Current empty default group with %c type SKIPPED !!!", tmp_ug[jj].member_type);
      continue;
	}
    /*
      SEARCH the current group name among the group names that were
      already processed in current message (duplicate group names).
    */
    for (kk= 0; kk LT jj; kk++)
    {
      if (
          (strcmp (tmp_ug[kk].ug, tmp_ug[jj].ug) EQ 0)
              AND
              (tmp_ug[kk].member_type EQ tmp_ug[jj].member_type)
          )
        break;
    }
    if (kk LT jj)
    {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Current Duplicate group=%s SKIPPED !!!", tmp_ug[jj].ug);
      continue;
    }
    /*
      CHECK if group is already included in increment group names.
    */
    rc_ug= CARE_inc_ug_find (tmp_ug[jj].ug);
    if (rc_ug EQ ESA_OK)
    {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Incremental Duplicate def.group=%s SKIPPED !!!", tmp_ug[jj].ug);
      continue;
    }
    /*
      CHECK if group is already included in interesting group names.
    */
    if (envir_ptr->dwnld_sync_type NE SYNC_PARTIAL)
    {
       CARE_int_ug_find (tmp_ug[jj].ug, M_DWNLD_NAME_IGNORE, &interest);
       if (interest EQ ESS_GROUP_CARE)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
              "Duplicate def.group=%s SKIPPED !!!", tmp_ug[jj].ug);
          continue;
       }
    }
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
                     "def.group=%s type %c ADDED to list.",
                     tmp_ug[jj].ug, tmp_ug[jj].member_type);
    /*
      ADD this group in list of groups processed in current message.
    */
    if (statist NE NULL)
        statist->ug_inc++;
    jj++;
    /*
      PROCESS when the temporary groups array is full:
    */
    if (jj EQ TMP_UGS_NUM- 1) {
      /*
        COPY all groups from temporary array to memory, and clear the
        array.
      */
      rc= CARE_inc_ug_to_memory (tmp_ug, jj);
      CLEAR (tmp_ug);
      jj= 0;
    }
  }
  /*
    PROCESS when the temporary array contains groups:
  */
  if (jj NE 0)
  {
      /*
        COPY all groups from temporary array to memory, and clear the
        array.
      */
      rc= CARE_inc_ug_to_memory (tmp_ug, jj);
      CLEAR (tmp_ug);
      jj= 0;
  }
  cleanup:
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Ended %s.",fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
 
  return(rc);
 
} /* END - CS_dwnld_inc_ug function */
 
/****************************************************
 * Procedure Name: CS_dwnld_inc_u2ug
 * Description   : Handle "INTERESTING CONNECTION GROUPS"
 *                 message.
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION:
 * =====================
 *
 * This function is activated by the "GLOBAL SYNC" handler and by the
 * "download" service handler upon receiving a message of interesting
 * "CONNECTION" groups. The function scans all group names in the list
 * verify it's uniqness (among other groups in current message,
 * among increment DEFAULT groups from previouse messages, among
 * increment CONNECTION groups from previouse messages, the previouse
 * defined interesting DEFAULT groups and among the previouse defined
 * interesting CONNECTION groups), and adds the group names to the list
 * of increment CONNECTION group names in the memory.
 *******************************************************************/
 
ESA_RC CS_dwnld_inc_u2ug (MSG_typ         * msg_ptr,
                          STATIST_rec_typ * statist)
{
  char fn[]="CS_dwnld_inc_u2ug";
  unsigned int          ii= 0;
  int                   jj= 0,kk= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  ESA_RC                rc= ESA_OK, rc_ug= ESA_OK, rc_u2ug= ESA_OK;
  ESS_INTRST_typ        interest= ESS_DONT_CARE;
  TRAN_rec_typ          tran;
  MEMBER_UG_rec_typ     tmp_ug [TMP_UGS_NUM];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Started %s.",fn);
  /*
    CLEAR temporary buffers.
  */
  CLEAR (tmp_ug);
  CLEAR_STRUCT(tran);
 
  if (msg_ptr NE NULL)
  {
     /*
       GET the GENERAL message header.
     */
     msg_ptr = CS_get_aplic_msg(msg_ptr);
     /*
       GET the RSS message header (number of internal messages).
     */
     msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
     if (msg_ptr EQ NULL)
     {
       rc = ESA_ERR;
       goto cleanup;
     }
  }
  else
  {
     num_msgs = 1;
     tmp_ug[0].ug[0] = '\0';
     tmp_ug[0].member_type = M_DWNLD_NAME_ALL;
  }
 
  /*
    PROCESS all internal RSS messages (containing the interesting ugs):
  */
  for (ii =0, jj= 0; ii LT num_msgs AND rc EQ ESA_OK; ii++)
  {
     if (msg_ptr NE NULL)
    {
       /*
         GET internal message's transaction & action id.
       */
       msg_ptr = CS_get_singl_msg(&len_msg, &tran , msg_ptr);
       if (msg_ptr EQ NULL)
       {
         rc = ESA_ERR;
         goto cleanup;
       }
       /*
         GET next increment connection group name
       */
       if (*msg_ptr NE M_DWNLD_NAME_REGULAR)
       {
          CTSAMSG_print (ERR_CS_MSG_GET_FLD,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               fn, C_MEMBER_TYPE);
          ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Member type %c.",*msg_ptr);
          rc = ESA_ERR;
          goto cleanup;
       }
       tmp_ug[jj].member_type = *msg_ptr;
       msg_ptr++;
       msg_ptr = CS_get_fld (tmp_ug[jj].ug ,
                             msg_ptr,
                             envir_ptr->rss_limits.max_ug_len,
                             C_GROUP_ID);
       if (msg_ptr EQ NULL)
       {
         rc = ESA_ERR;
         goto cleanup;
       }
      }
     if (tmp_ug[jj].ug[0] EQ '\n')
        tmp_ug[jj].ug[0] = '\0';
     if (tmp_ug[jj].member_type EQ M_DWNLD_NAME_ALL)
        tmp_ug[jj].ug[0] = '\0';
 
    /*
      IGNORE null group names if type is M_DWNLD_NAME_ALL.
    */
    if (
         (strlen (tmp_ug[jj].ug) EQ 0)
        AND
         (tmp_ug[jj].member_type NE M_DWNLD_NAME_ALL)
       )
	{
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Current empty group with %c type SKIPPED !!!", tmp_ug[jj].member_type);
      continue;
	}
    /*
      SEARCH the current group name among the group names that were
      already processed in current message (duplicate group names).
    */
    for (kk= 0; kk LT jj; kk++)
    {
       if (
           (strcmp (tmp_ug[kk].ug, tmp_ug[jj].ug) EQ 0)
               AND
           (tmp_ug[kk].member_type EQ tmp_ug[jj].member_type)
           )
        break;
    }
    if (kk LT jj)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
          "Current Duplicate conn. group=%s !!!", tmp_ug[jj].ug);
       continue;
    }
 
    /*
      CHECK if group is already included in increment DEFAULT group
      names.
    */
    rc_ug= CARE_inc_ug_find (tmp_ug[jj].ug);
    if (rc_ug EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
          "Incremental Duplicate conn. group=%s !!!", tmp_ug[jj].ug);
       continue;
    }
    /*
      CHECK if group is already included in increment CONNECTION group
      names.
    */
    rc_u2ug= CARE_inc_u2ug_find (tmp_ug[jj].ug);
    if (rc_u2ug EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Incremental Duplicate group=%s SKIPPED !!!", tmp_ug[jj].ug);
       continue;
    }
    /*
      CHECK if groups is already included in list of interesting
      DEFAULT group mnames s or list of interesting CONNECTION grou
      names.
    */
    if (envir_ptr->dwnld_sync_type NE SYNC_PARTIAL)
    {
       CARE_int_ug_find (tmp_ug[jj].ug,M_DWNLD_NAME_REGULAR,&interest);
       if (interest NE ESS_DONT_CARE)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "Duplicate group=%s SKIPPED !!!", tmp_ug[jj].ug);
          continue;
       }
    }
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES+ 1,
                     "group=%s type %c ADDED.",
                     tmp_ug[jj].ug, tmp_ug[jj].member_type);
    /*
      ADD current connection group to the temporary array of increment
      connection groups
    */
    if (statist NE NULL)
        statist->u2ug_inc++;
    jj++;
    /*
      PROCESS when the temporary groups array is full:
    */
    if (jj EQ TMP_UGS_NUM- 1)
    {
      /*
        COPY all groups from temporary array to list of increment
        connection groups in the memory.
      */
      rc= CARE_inc_u2ug_to_memory (tmp_ug, jj);
      CLEAR (tmp_ug);
      jj= 0;
    } /* END - Temporary array is full */
  } /* END - FOR loop on all internal groups (messages) */
  /*
    PROCESS when temporary groups array contains groups:
  */
  if (jj NE 0)
  {
      /*
        COPY all groups from temporary array to list of increment
        connection groups in the memory.
      */
      rc= CARE_inc_u2ug_to_memory (tmp_ug, jj);
      CLEAR (tmp_ug);
      jj= 0;
  }
  cleanup:
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Ended %s.",fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_dwnld_inc_u2ug function */
 
/****************************************************
 * Procedure Name: CS_dwnld_inc_usr
 * Description   :
 *                 Get from ESS list of intersting users
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION:
 * =====================
 *
 * This function is activated by the "GLOBAL SYNC" handler and by the
 * "download" service handler upon receiving a message of interesting
 * users. The function scans all user names in the list, verify it's
 * uniqness (among other users in current message,among increment users
 * from previouse messages and among the previouse defined interesting
 * users), and adds the Uuser names to the list of increment user names
 * in the memory.
 ********************************************************************/
 
ESA_RC  CS_dwnld_inc_usr (MSG_typ         * msg_ptr,
                          STATIST_rec_typ * statist)
{
  char fn[]="CS_dwnld_inc_usr";
  ESA_RC                rc= ESA_OK, rc_usr= ESA_OK, rc_logout= ESA_OK;
  unsigned int          ii= 0;
  int                   jj= 0, kk= 0;
  NUM_MSGS_typ          num_msgs= 0, len_msg= 0;
  ESS_INTRST_typ        interest= ESS_DONT_CARE;
  TRAN_rec_typ          tran;
  MEMBER_USER_rec_typ   tmp_user [TMP_USERS_NUM];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Started %s.",fn);
  /*
    CLEAR temporary buffers.
  */
  CLEAR (tmp_user);
  CLEAR_STRUCT(tran);
 
  if (msg_ptr NE NULL)
  {
     /*
       GET the GENERAL message header.
     */
     msg_ptr = CS_get_aplic_msg(msg_ptr);
     /*
       GET the RSS message header (number of internal messages).
     */
     msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
     if (msg_ptr EQ NULL)
     {
       rc = ESA_ERR;
       goto cleanup;
     }
  }
  else
  {
     num_msgs = 1;
     tmp_user[0].user[0] = '\0';
     tmp_user[0].member_type = M_DWNLD_NAME_ALL;
  }
  /*
    PROCESS all internal RSS messages (containing the
    interesting users):
  */
  for (ii =0, jj= 0; ii LT num_msgs AND rc EQ ESA_OK; ii++)
  {
 
     if (msg_ptr NE NULL)
     {
       /*
         GET internal message's transaction & action id.
       */
       msg_ptr = CS_get_singl_msg(&len_msg, &tran , msg_ptr);
       if (msg_ptr EQ NULL)
       {
         rc = ESA_ERR;
         goto cleanup;
       }
       /*
         GET next increment member type and user name
       */
       if (
             (*msg_ptr NE M_DWNLD_NAME_REGULAR)
            AND
             (*msg_ptr NE M_DWNLD_NAME_WILD)
          )
       {
          CTSAMSG_print (ERR_CS_MSG_GET_FLD,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               fn, C_MEMBER_TYPE);
          ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Member type %c.",*msg_ptr);
          rc = ESA_ERR;
          goto cleanup;
       }
       tmp_user[jj].member_type = *msg_ptr;
       msg_ptr++;
       msg_ptr = CS_get_fld (tmp_user[jj].user ,
                             msg_ptr,
                             envir_ptr->rss_limits.max_user_len,
                             C_USER_ID);
       if (msg_ptr EQ NULL)
       {
         rc = ESA_ERR;
         goto cleanup;
       }
    }
    if (tmp_user[jj].user[0] EQ '\n')
        tmp_user[jj].user[0] = '\0';
    if (tmp_user[jj].member_type EQ M_DWNLD_NAME_ALL)
        tmp_user[jj].user[0] = '\0';
    /*
      IGNORE null group names if type is M_DWNLD_NAME_ALL.
    */
    if (
         (strlen (tmp_user[jj].user) EQ 0)
        AND
         (tmp_user[jj].member_type NE M_DWNLD_NAME_ALL)
       )
	{
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
          "Current empty user with %c type SKIPPED !!!", tmp_user[jj].member_type);
      continue;
	}
    /*
      SEARCH the current user name among the user names that were
      already processed in current message (duplicate user names).
    */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
    for (kk= 0; kk LT jj; kk++)
    {
        if (tmp_user[kk].member_type EQ M_DWNLD_NAME_IGNORE)
           continue;
        if (tmp_user[kk].member_type EQ M_DWNLD_NAME_ALL)
           break;
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
    		"...-> ismaskmatch_ptr: Obj=%s (%s)  Mask=%s (%s)",
			(char *)tmp_user[jj].user, "TYPE_USER",
            (char *)tmp_user[kk].user,
			(tmp_user[kk].member_type EQ M_DWNLD_NAME_WILD) ?
                       "MASK_WILD" : "MASK_REGULAR");
        rc = envir_ptr->func_ptr.ismaskmatch_ptr (tmp_user[jj].user,
                (char *)tmp_user[kk].user, TYPE_USER,
                   (tmp_user[kk].member_type EQ M_DWNLD_NAME_WILD) ?
                       MASK_WILD : MASK_REGULAR,
                   &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- ismaskmatch_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
 
        if (rc EQ ESA_OK)
           break;
        if (
            (rc NE ESA_OK)
                AND
            (tmp_user[jj].member_type EQ M_DWNLD_NAME_WILD)
            )
        {
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
    		"...-> ismaskmatch_ptr: Obj=%s (%s)  Mask=%s (%s)",
			(char *)tmp_user[kk].user, "TYPE_USER",
            (char *)tmp_user[jj].user, "MASK_WILD");
           rc = envir_ptr->func_ptr.ismaskmatch_ptr (tmp_user[kk].user,
                               (char *)tmp_user[jj].user,
                               TYPE_USER,
                               MASK_WILD,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- ismaskmatch_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
           if (rc EQ ESA_OK)
              tmp_user[kk].member_type = M_DWNLD_NAME_IGNORE ;
        }
    }
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    rc = ESA_OK;
    /*
      CHECK if user is already included in increment user names.
    */
    if (kk LT jj)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "Current Duplicate user=%s SKIPPED !!!", tmp_user[jj].user);
       continue;
    }
    /* sasc   rc_usr=   (tmp_user[jj].user,
                               tmp_user[jj].member_type);   */
    rc_usr = CARE_inc_usr_find (tmp_user[jj].user,        /* sasc   */
                               tmp_user[jj].member_type); /* sasc   */
    if (rc_usr EQ ESA_OK)
    {
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "Incremental Duplicate user=%s SKIPPED !!!", tmp_user[jj].user);
       continue;
    }
    /*
      CHECK if user is already included in interesting user names.
    */
    if (envir_ptr->dwnld_sync_type NE SYNC_PARTIAL)
    {
       CARE_int_usr_find (tmp_user[jj].user,
                          envir_ptr->empty_ug,
                          tmp_user[jj].member_type,
                          &interest);
       if (interest EQ ESS_USER_CARE)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "Duplicate user=%s SKIPPED !!!", tmp_user[jj].user);
          continue;
       }
    }
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES+ 1,
        "user=%s type %c ADDED to list",
		tmp_user[jj].user, tmp_user[jj].member_type);
    /*
      ADD this user in list of users processed in current message.
    */
    if (statist NE NULL)
        statist->usr_inc++;
    jj++;
    /*
      PROCESS when the temporary users array is full:
    */
    if (jj EQ TMP_USERS_NUM- 1)
    {
      /*
        COPY all users from temporary array to memory, and clear the
        array.
      */
      rc= CARE_inc_usr_to_memory (tmp_user, jj);
      CLEAR (tmp_user);
      jj= 0;
    }
  } /* END FOR loop on all internal messages */
  /*
    PROCESS when temporary users array is not empty:
  */
  if (jj NE 0)
  {
      /*
        COPY all users from temporary array to memory, and clear the
        array.
      */
      rc= CARE_inc_usr_to_memory (tmp_user, jj);
      CLEAR (tmp_user);
      jj= 0;
  }
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf(ESA_COMP_ACSPMPF, DIAG_DETAILES, "Ended %s.",fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CS_dwnld_inc_usr function */
 
 
 
 
/****************************************************
 * Procedure Name: CS_download
 * Description   : dwnld process:
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_download (RSS_MSG_HDR_rec_typ * msg_hdr ,
                    STATIST_rec_typ     * statist,
                    char                * dwnld_sync_method,
                    char                * dwnld_type,
                    char                * dwnld_from,
                    char                * dwnld_user_list,
                    char                * dwnld_group_list,
                    char                * dwnld_conn_list,
                    char                * dwnld_oe_list,
                    OE_typ                dwnld_from_oe,
                    UG_typ                dwnld_from_group,
                    USER_typ              dwnld_from_user,
					char service_type)                             /* AGGR */
{
  char fn[]="CS_download";
  ESA_RC                rc= ESA_OK, rc_ug= ESA_OK;
  ESA_RC                rc_oe=ESA_OK,rc_u2ug= ESA_OK, rc_usr= ESA_OK;
  char                * user_memory= NULL;
  int                   users_in_memory= 0,user_memory_init= 0;
  ESS_INTRST_typ        oe_care= ESS_DONT_CARE;
  ESS_INTRST_typ        ug_care= ESS_DONT_CARE;
  ESS_INTRST_typ        u2ug_care= ESS_DONT_CARE;
  ESS_INTRST_typ        user_care= ESS_DONT_CARE;
  char                  interval [RSSPRM_VALUE_LEN+ 1];
  char                * ug_typ_ptr= NULL;
  int                   ug_mem_num= 0;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR (interval);
 
  rc= CS_dwnld_sync_inc (*dwnld_sync_method,
	                     *dwnld_user_list,
                         *dwnld_group_list,
						 *dwnld_conn_list,
                         *dwnld_oe_list);
  if (rc NE ESA_OK)
     goto cleanup;
  rc_usr= CARE_inc_usr_find  (envir_ptr->empty_user,
	                          M_DWNLD_NAME_ALL);
  rc_oe=  CARE_inc_oe_find   (envir_ptr->empty_oe);
  rc_ug=  CARE_inc_ug_find   (envir_ptr->empty_ug);
  rc_u2ug=CARE_inc_u2ug_find (envir_ptr->empty_ug);
  CARE_int_u2ug_find (envir_ptr->empty_ug,
	                  M_DWNLD_NAME_ALL,
					  &u2ug_care);
  CARE_int_usr_find (envir_ptr->empty_user,
	                 envir_ptr->empty_ug,
					 M_DWNLD_NAME_ALL,
                     &user_care);
  CARE_int_ug_find (envir_ptr->empty_ug,
	                M_DWNLD_NAME_ALL,
					&ug_care);
  CARE_int_oe_find (envir_ptr->empty_oe,
	                &oe_care);
 
  /* Write to log list of interesting users , groups and def.groups */
  if (*dwnld_from     EQ M_DWNLD_FROM_SPEC_GROUP)
      CTSAMSG_print ( MSG_DWNLD_RESTART_GROUP ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name,
                     dwnld_from_group);
   else if (*dwnld_from     EQ M_DWNLD_FROM_SPEC_USER)
      CTSAMSG_print ( MSG_DWNLD_RESTART_USER ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name,
                     dwnld_from_user);
   else if (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONNECTION)
      CTSAMSG_print ( MSG_DWNLD_RESTART_CON ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name,
                     dwnld_from_user,
					 dwnld_from_group);
   else if (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONTAINER)
      CTSAMSG_print ( MSG_DWNLD_RESTART_OE ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name,
                     dwnld_from_oe);
  else
  {
     CTSAMSG_print ( MSG_DWNLD_STARTED ,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     envir_ptr->msg_admin_param.rss_name);
 
     /* WS10078KG - Lets not check care file of other    *
      *             entities for source/role aggregation */
     if ( service_type NE DWNLD_ROLE_SERVICE AND
               service_type NE DWNLD_SOURCE_SERVICE )
     {
     /* WS10078KG  */
     CARE_list_oe  (envir_ptr->oes_ptr,   envir_ptr->num_oes);
     CARE_list_ug  (envir_ptr->ugs_ptr,   envir_ptr->num_ugs);
     CARE_list_u2ug(envir_ptr->u2ugs_ptr, envir_ptr->num_u2ugs);
     CARE_list_usr (envir_ptr->users_ptr, envir_ptr->num_users);
     }     /* WS10078KG */
  }
 
 
/* dwnld of containers */
  if (
      (envir_ptr->num_oes     GT 0)
          AND
          (
              (*dwnld_from     EQ M_DWNLD_FROM_NOT_SPECIFIED)
                  OR
                  (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONTAINER)
              )
		/* AGGR - S */
		AND
		(   (service_type EQ DWNLD_SERVICE)
		   OR
		    (service_type EQ DWNLD_USER_CONN_SERVICE)
		)
		/* AGGR - E */
  /* WS10078KG - Start */
  AND
    (service_type NE DWNLD_ROLE_SERVICE )
  AND
    (service_type NE DWNLD_SOURCE_SERVICE )
  /* WS10078KG - End */
    )
  {
     if (*dwnld_sync_method  EQ M_DWNLD_SYNC_METHOD_SUBTREE)
	 {
		 if (service_type EQ DWNLD_USER_CONN_SERVICE) /* AGGR */
		 {
            rc= CS_dwnld_oe_subtree_aggr (msg_hdr,
                                  statist);
		 }
		 else
         {
         rc= CS_dwnld_oe_subtree (msg_hdr,
                                  statist);
		 }
	 }
     else if (rc_oe  EQ ESA_OK)
	 {
		 if (service_type EQ DWNLD_USER_CONN_SERVICE) /* AGGR */
		 {
            rc= CS_dwnld_oe_all_aggr (msg_hdr,
                             dwnld_from_oe,
                             statist);
		 }
		 else
		 {
         rc= CS_dwnld_oe_all (msg_hdr,
                             dwnld_from_oe,
                             statist);
		 }
	 }
     else
	 {
	 	 if (service_type EQ DWNLD_USER_CONN_SERVICE) /* AGGR */
		 {
             rc= CS_dwnld_oe_aggr (msg_hdr,
                          statist);
		 }
		 else
		 {
         rc= CS_dwnld_oe (msg_hdr,
                          statist);
		 }               /* AGGR */
  }
  }
  if (rc EQ ESA_NOT_SUPP)
      rc = ESA_OK;
  if (rc NE ESA_OK)
    goto cleanup;
 
/* dwnld of groups */
  if (
       ( (*dwnld_from     EQ M_DWNLD_FROM_NOT_SPECIFIED)
          OR
      (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONTAINER)
         OR
        (*dwnld_from     EQ M_DWNLD_FROM_SPEC_GROUP))
	   /* AGGR - S */
		AND
		(service_type NE DWNLD_USER_SERVICE )
  /* WS10078KG - Start */
  AND
  (service_type NE DWNLD_ROLE_SERVICE )
  AND
  (service_type NE DWNLD_SOURCE_SERVICE )
  /* WS10078KG - End */
     )
	   /* AGGR - E */
  {
     if ((*dwnld_sync_method      EQ M_DWNLD_SYNC_METHOD_SUBTREE) AND              /* AGGR */
	   (service_type EQ DWNLD_USER_CONN_SERVICE))
	 {
         rc= CS_dwnld_ug_oe_aggr (msg_hdr,
                            statist,
							&ug_typ_ptr,&ug_mem_num);
	 }
	 else
     if (*dwnld_sync_method      EQ M_DWNLD_SYNC_METHOD_SUBTREE)
        rc= CS_dwnld_ug_oe (msg_hdr,
                            statist,
							&ug_typ_ptr,&ug_mem_num);
 
     else if (
         (rc_ug   EQ ESA_OK)
             OR
         (rc_u2ug EQ ESA_OK)
      )
	 {                                                           /* AGGR */
		 if (service_type EQ DWNLD_USER_CONN_SERVICE)
		 {
           rc= CS_dwnld_ug_all_aggr (msg_hdr,
                             dwnld_from_group, statist);
		 }
		 else
		 {
        rc= CS_dwnld_ug_all (msg_hdr,
                             dwnld_from_group, statist);
		 }                                         /* AGGR */
	 }
     else
        rc= CS_dwnld_ug (msg_hdr,
                         statist );
  }
  if (rc EQ ESA_NOT_SUPP)
      rc = ESA_OK;
  if (rc NE ESA_OK)
    goto cleanup;
 
/* dwnld of users */
  if (
       ( (*dwnld_from     EQ M_DWNLD_FROM_NOT_SPECIFIED)
      OR
       (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONTAINER)
      OR
       (*dwnld_from     EQ M_DWNLD_FROM_SPEC_GROUP)
      OR
        (*dwnld_from     EQ M_DWNLD_FROM_SPEC_USER))
		/* AGGR - S */
		AND
		(service_type NE DWNLD_GROUP_SERVICE
		)
        /* AGGR - E */
  /* WS10078KG - Start */
  AND
  (service_type NE DWNLD_ROLE_SERVICE )
  AND
  (service_type NE DWNLD_SOURCE_SERVICE )
  /* WS10078KG - End */
       )
  {
     if (*dwnld_sync_method  EQ M_DWNLD_SYNC_METHOD_SUBTREE)
        rc= CS_dwnld_usr_oe (msg_hdr,
                             statist);
     else if (rc_usr EQ ESA_OK)
        rc= CS_dwnld_usr_all(msg_hdr,
                            dwnld_from_user,
                            statist );
     else
        rc= CS_dwnld_usr (msg_hdr,
                          statist,
                          &user_memory,
                          &users_in_memory,
                          &user_memory_init);
  }
  if (rc EQ ESA_NOT_SUPP)
      rc = ESA_OK;
  if (rc NE ESA_OK)
    goto cleanup;
 
/* dwnld of connections */
  if (
        ((*dwnld_from     EQ M_DWNLD_FROM_NOT_SPECIFIED)
       OR
        (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONTAINER)
       OR
        (*dwnld_from     EQ M_DWNLD_FROM_SPEC_GROUP)
       OR
        (*dwnld_from     EQ M_DWNLD_FROM_SPEC_USER)
       OR
        (*dwnld_from     EQ M_DWNLD_FROM_SPEC_CONNECTION) )
		/* AGGR - S */
		AND
		(service_type NE DWNLD_GROUP_SERVICE AND
		 service_type NE DWNLD_USER_SERVICE
		)
        /* AGGR - E */
  /* WS10078KG - Start */
  AND
  (service_type NE DWNLD_ROLE_SERVICE )
  AND
  (service_type NE DWNLD_SOURCE_SERVICE )
  /* WS10078KG - End */
     )
  {
     if (*dwnld_sync_method      EQ M_DWNLD_SYNC_METHOD_SUBTREE)
     {
        rc= CS_dwnld_u2ug_oe (msg_hdr,
                              statist,
							  ug_typ_ptr,
							  ug_mem_num);
        if ( (envir_ptr->dwnld_sync_type EQ DWNLD_INCREMENT) AND (rc EQ ESA_OK) )
        {
           CSA_free ((char **)(&ug_typ_ptr));
           ug_mem_num= 0;
           rc= CS_dwnld_int_ug_oe  (&ug_typ_ptr,
                                    &ug_mem_num);
           if (rc EQ ESA_OK)
              rc=CS_dwnld_u2ug_oe_add (msg_hdr,
                                    statist,
			                        ug_typ_ptr,
						            ug_mem_num);
        }
     }
     else if (
                (rc_ug      EQ ESA_OK)
               OR
                (ug_care    EQ ESS_GROUP_CARE)
               OR
			    (
				   (
                      (user_care  EQ ESS_USER_CARE)
                     OR
                      (rc_usr     EQ ESA_OK)
                   )
                  AND
				   (
                      (rc_u2ug    EQ ESA_OK)
                     OR
                      (u2ug_care  EQ ESS_U2UG_CARE)
                   )
                )
             )
        rc= CS_dwnld_u2ug_all(msg_hdr,
                              &user_memory,
							  &users_in_memory,
							  &user_memory_init,
                              dwnld_from_group,
							  dwnld_from_user,
							  statist);
     else if (
			    (user_care  NE ESS_USER_CARE)
               AND
                (rc_usr     NE ESA_OK)
             ) {
        rc= CS_dwnld_usr_def_ug (msg_hdr,
			                     &user_memory,
			                     &users_in_memory,
							     &user_memory_init,
                                 statist);
        if (rc EQ ESA_OK)
           rc= CS_dwnld_usr_u2ug (msg_hdr,
                               &user_memory,
							   &users_in_memory,
							   &user_memory_init,
							   statist);
	 }
     else {
        rc= CS_dwnld_u2ug (msg_hdr,
                           &user_memory,
						   &users_in_memory,
						   &user_memory_init,
						   statist);
        if ( (envir_ptr->dwnld_sync_type EQ DWNLD_INCREMENT) AND (rc EQ ESA_OK) )
           rc=CS_dwnld_u2ug_add (msg_hdr,
                                 statist);
	 }
  }
  if (rc EQ ESA_NOT_SUPP)
      rc = ESA_OK;
  if (rc NE ESA_OK)
    goto cleanup;
  /* WS10078KG - Start */
  /* download of Roles or Sources */
      if ( service_type EQ DWNLD_ROLE_SERVICE OR
           service_type EQ DWNLD_SOURCE_SERVICE )
      {
            rc= CS_dwnld_xref_all (msg_hdr, statist , service_type);
      }
  if (rc EQ ESA_NOT_SUPP)
      rc = ESA_OK;
  if (rc NE ESA_OK)
    goto cleanup;
  /* WS10078KG - Ends */
 
  cleanup:
     /* WS10078KG - Lets not Rebuild care files of other    *
      *             entities during source/role aggregation */
    if ( service_type NE DWNLD_ROLE_SERVICE AND
              service_type NE DWNLD_SOURCE_SERVICE )
    {
     /* WS10078KG  */
       /*
          Rebuid files of interesting groups, users and
          groups for connections for incremental download
       */
 
       if (rc EQ ESA_OK)
           rc= CARE_int_oes_add (envir_ptr->msg_admin_param.rss_name,
                                 *dwnld_type);
       if (rc EQ ESA_OK)
           rc= CARE_int_ugs_add (envir_ptr->msg_admin_param.rss_name,
                                 *dwnld_type);
       if (rc EQ ESA_OK)
           rc= CARE_int_users_add (envir_ptr->msg_admin_param.rss_name,
                                   *dwnld_type);
       if (rc EQ ESA_OK)
           rc= CARE_int_u2ugs_add (envir_ptr->msg_admin_param.rss_name,
                                   *dwnld_type);
    } /* WS10078KG */
 
  CSA_free ((char **)(&ug_typ_ptr));
  CSA_free ((char **)(&user_memory));
  if (rc NE ESA_OK AND rc NE ESA_ABORT_REQ)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return(rc);
} /* End of CS_dwnld */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_ug
 * Description   : dwnld new increment list of intteresting
 *                        user groups
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_ug (RSS_MSG_HDR_rec_typ  * msg_hdr,
                    STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs= 0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  int                   sw_upd= 0,sw_user= 0,ii= 0,from_num_ug= 0;
  int                   num_inc_ugs= 0,num_inc_u2ugs= 0;
  short                 actual_num= 0,filled_num_ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  ESS_INTRST_typ        ess_cares;
 
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  RSSAPIPRM_rec_typ     apiprm;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETUGS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),        */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_u2ugs = envir_ptr->num_u2ugs;
  num_inc_ugs  = envir_ptr->num_ugs;
 
/*      Build addinfo for user-groups checksum */
  rc= CSA_alloc (
          (char **)&bufk,
          0,
          (sizeof(KWD_rec_typ) *
          envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
          sizeof(RSSAPIKWD_rec_typ),
          1, fn, "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *            */
                   envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added groups */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
/*  Get list of increment groups and connection groups */
  for (from_num_ug= 0;
       from_num_ug LT num_inc_ugs+ num_inc_u2ugs AND rc EQ ESA_OK;)
  {
    CLEAR (ug_prm_in);
    CLEAR (ug_prm);
    CLEAR (oe);
    CLEAR (obj_exist);
    rc= CARE_inc_ugs_fill (ug_prm_in, &from_num_ug, &filled_num_ugs);
 
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        (unsigned int)filled_num_ugs,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/  + apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds); */
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_MANY_GROUPS, oe,
				MAX_GET, filled_num_ugs, ug_prm_in,
				handle, addinfo);
    rc=envir_ptr->func_ptr.getugs_ptr (
        GET_MANY_GROUPS, oe, MAX_GET,
        &actual_num,
        &have_more, &handle, filled_num_ugs,
        ug_prm_in, ug_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
          "->getugs: Fail get groups");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "after getugs: actual_num=%d have_more=%d rc=%d",
                    actual_num, have_more, (int)rc);
 
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "group=%s NOT EXIST", ug_prm[ii].group);
        statist->ug_not_exist++;
        continue;
      }
      CARE_int_ug_find (ug_prm[ii].group, M_DWNLD_NAME_REGULAR,
                        &ess_cares);
      if (ess_cares NE ESS_DONT_CARE)
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
        "Group %s SKIPPED (Aggregated in prev. aggregation",ug_prm[ii].group);
        continue;
      }
      statist->ug_add++;
      statist->ug_ess++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "ug=%s ADDED",ug_prm[ii].group);
      msg_rs=CS_add_rs_msg (FUNC_ADDUG, &usr_prm, &oe_prm, &ug_prm[ii],
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
            "->CS_send_cd_msg: Fail send msg");
      goto cleanup;
    }
  }
 
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
        GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
        &actual_num, &have_more,
        &handle, MAX_GET, ug_prm_in, ug_prm,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
/*  if (addinfo[0] NE NULL)
    free (addinfo[0]);*/
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_ug */
 
/****************************************************
 * Procedure Name: CS_dwnld_usr
 * Description   : dwnld new increment list of interesting users
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_usr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                     STATIST_rec_typ      * statist,
                     char                ** user_memory,
                     int                  * users_in_memory,
                     int                  * user_memory_init)
{
  char fn[]="CS_dwnld_usr";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  void                * handle, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num, filled_num_users;
  HAVE_MORE_typ         have_more;
  int                   ii, from_num_user, num_inc_users;
  ESS_INTRST_typ        ess_cares;
  int                   sw_upd, sw_user;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  char                  user_type;
  ENVIRONMENT_rec_typ * envir_ptr;
  char get_conn = 'N';   /* AC001 - CIQ#6 */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  num_inc_users = envir_ptr->num_users;
 
  /* WS10077 - Start */
  if (envir_ptr->iiq_version GT 0) {
    get_conn = 'Y';
    if (envir_ptr->iiq_version GE 2)
       get_conn = 'P';
  }
  /* WS10077 - End */
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUSERS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),    */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
 
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (u2ug_data);
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *          */
               (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_ADD);
 
/*  Get list of increment  users */
  for (from_num_user= 0, user_type = M_DWNLD_NAME_REGULAR;
       from_num_user LT num_inc_users AND rc EQ ESA_OK;)
  {
 
   CLEAR (usr_prm_in);
   rc= CARE_inc_users_fill (usr_prm_in,
                            &from_num_user, user_type,
                            &filled_num_users);
   for (have_more=HAVE_MORE;
          (have_more EQ HAVE_MORE)
         AND
          (rc EQ ESA_OK)
         AND
          (filled_num_users GT 0);
       )
   {
    CLEAR (usr_prm);
    CLEAR (obj_exist);
    CLEAR (oe);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSPMPF,
		(user_type EQ M_DWNLD_NAME_REGULAR) ? GET_MANY_USERS
		                                    : GET_WILD_USERS,
		oe, MAX_GET, filled_num_users, usr_prm_in,
		handle, addinfo);
    if (user_type EQ M_DWNLD_NAME_REGULAR)
       rc=envir_ptr->func_ptr.gtusers_ptr(
               GET_MANY_USERS, oe, MAX_GET,
               &actual_num, &have_more, &handle,
               filled_num_users, usr_prm_in,
               usr_prm, addinfo,
               obj_exist, &envir_ptr->msg_admin_param,
               &envir_ptr->msg_err, get_conn); /* AC001 - CIQ#6 */
    else
       rc=envir_ptr->func_ptr.gtusers_ptr(
               GET_WILD_USERS, oe, MAX_GET,
               &actual_num, &have_more, &handle,
               filled_num_users, usr_prm_in,
               usr_prm, addinfo,
               obj_exist, &envir_ptr->msg_admin_param,
               &envir_ptr->msg_err, get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSSETF, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK)
    {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtusers: Fail get users");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                   "after gtusers: actual_num=%d have_more=%d rc=%d",
                   actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "usr=%s NOT EXIST",usr_prm[ii].user);
        statist->usr_not_exist++;
        continue;
      }
/*----       if user  list interesting users
             or user's default group in list interesting groups */
      CARE_int_usr_find (usr_prm[ii].user, usr_prm[ii].def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
/*           If YES -> skip this user */
      if (ess_cares NE ESS_DONT_CARE)
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
         "User %s def ug %s SKIPPED (Aggregated in prev. aggregation)",
         usr_prm[ii].user, usr_prm[ii].def_group);
        continue;
      }
      statist->usr_add++;
      statist->usr_ess++;
      CS_dwnld_event (statist, STEP_USR, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "User %s def ug %s ADDED", usr_prm[ii].user, usr_prm[ii].def_group);
      /* BS10106 - Start: We dont want to create the list of users *
      rc= CS_dwnld_usr_to_memory (user_memory, users_in_memory,
								  user_memory_init, usr_prm[ii].user);
      if (rc NE ESA_OK)
         goto cleanup;
        *BS10106 - Ends */
      msg_rs=CS_add_rs_msg (FUNC_ADDUSER, &usr_prm[ii],&oe_prm,&ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
   }
   if (
         (num_inc_users LE from_num_user)
        AND
         (user_type     EQ M_DWNLD_NAME_REGULAR)
        AND
         (rc            EQ ESA_OK)
      )
   {
         user_type       = M_DWNLD_NAME_WILD;
          from_num_user   = 0;
   }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr(
                   GET_FREE_HANDLE_USERS, oe,
                   MAX_GET, &actual_num,
                   &have_more, &handle, MAX_GET, usr_prm_in,
                   usr_prm, addinfo, obj_exist,
                   &envir_ptr->msg_admin_param, &envir_ptr->msg_err,
                   get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_USR, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_usr */
 
/****************************************************
 * Procedure Name: CS_dwnld_u2ug
 * Description   : dwnld new interesting connections
 *                   of new increment list of interesting
 *                   user groups and users
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_u2ug (RSS_MSG_HDR_rec_typ   * msg_hdr,
                      char                 ** user_memory,
                      int                   * users_in_memory,
                      int                   * user_memory_init,
                      STATIST_rec_typ       * statist)
{
  char fn[]="CS_dwnld_u2ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  ESA_RC                rc_ug= ESA_OK, rc_usr= ESA_OK;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, filled_num_u2ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, from_num_u2ug= 0;
  int                   num_inc_u2ugs= 0, num_inc_ugs= 0;
  unsigned int          usrmem_num= 0;
  ESS_INTRST_typ        ess_u2ugcares, ess_cares= ESS_DONT_CARE;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  UG_typ                ug_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  OE_typ                oe;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR (usr_in);
  CLEAR (ug_in);
  CLEAR (oe);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUG2UC,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc (
      (char **)&info_ptr,
      STRUC_ADDINFO,
 /*   sizeof(ADDINFO_rec_typ),              *WS10082K*/
      envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
          apiprm.script_kwd_num ,
      1,                                   /*WS10082K*/
      fn,
      "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  num_inc_u2ugs = envir_ptr->num_u2ugs;
  num_inc_ugs = envir_ptr->num_ugs;
 
  handle= NULL;
 
/*      Build addinfo for user connection to user-group checksum  */
  rc= CSA_alloc (
         (char **)&bufk,
         0,
         (sizeof(KWD_rec_typ) *
            envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
               sizeof(RSSAPIKWD_rec_typ),
         1,
         fn,
         "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *        */
             (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
 
/* Build msg. header for add users */
 
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
 
/*  Get connection of every group from list of increment groups and
    increment connection groups to ALL users */
  for (from_num_u2ug= 0, filled_num_u2ugs = 0;
       from_num_u2ug LT num_inc_u2ugs+ num_inc_ugs AND rc EQ ESA_OK;)
  {
 
   CLEAR (ug_in);
   rc= CARE_inc_u2ugs_fill (ug_in,&from_num_u2ug,&filled_num_u2ugs);
   for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (usr_in);
    CLEAR (oe);
    CLEAR_STRUCT (ug_prm);
    CLEAR_STRUCT (usr_prm);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_GROUPS_CONNS, MAX_GET,
		filled_num_u2ugs, 0, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(
        GET_GROUPS_CONNS,MAX_GET,&actual_num,
        &have_more, &handle, filled_num_u2ugs,
        0, ug_in, usr_in, u2ug_data,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
           "after getug2uc: actual_num=%d have_more=%d rc=%d",
            actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
                         "ug=%s usr=%s NOT EXIST ",
                         u2ug_data[ii].group,
                         u2ug_data[ii].user);
        continue;
      }
      memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
              sizeof(USER_typ));
      memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
              sizeof(UG_typ));
      memcpy ((char *)usr_prm.def_group,
              (char *)u2ug_data[ii].def_group,
              sizeof(UG_typ));
 
/*----       if user of the connection in list interesting users
             or user's default group in list interesting groups */
      CARE_int_usr_find (u2ug_data[ii].user, u2ug_data[ii].def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
/*----       if user of the connection in list
             increment users */
      rc_usr= CARE_inc_usr_find (usr_prm.user, M_DWNLD_NAME_REGULAR);
/*----       if user's default group of the connection in list
             increment groups */
	  if (strlen (u2ug_data[ii].def_group) EQ 0)
		  rc_ug= ESA_ERR;
	  else
          rc_ug= CARE_inc_ug_find (usr_prm.def_group);
/*----       if group of the connection in list interesting groups
              (ESS_U2UG_CARE) */
      CARE_int_u2ug_find (u2ug_data[ii].group,
                          M_DWNLD_NAME_REGULAR, &ess_u2ugcares);
/*           If NOT -> skip connection (not interesting) */
      if (
          (
              (ess_cares EQ ESS_DONT_CARE)
                  AND
                  (rc_ug NE ESA_OK)
                  AND
                  (rc_usr NE ESA_OK)
              )
              OR
              (
                  (ess_u2ugcares EQ  ESS_U2UG_CARE)
                      AND
                      (ess_cares     NE  ESS_DONT_CARE)
                  )
          )
      {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
       "Conn.ug=%s to usr=%s def ug=%s SKIPPED (Aggregated in prev. Aggregation or not interesting)",
           u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
         continue;
      }
/*----       if this user had been getted in the program */
      usrmem_num= CS_dwnld_mem_usr_find (* user_memory, * users_in_memory, u2ug_data[ii].user);
/*           If this user is new interesting user
                 - Check and Send msg. to ESS about NEW int. user */
      if ( (rc_ug EQ ESA_OK) AND (rc_usr NE ESA_OK) AND (ess_cares EQ ESS_DONT_CARE) AND
           (usrmem_num GE (unsigned int)*users_in_memory) )
	  {
          rc= CS_dwnld_add_usr (msg_hdr,
								user_memory,
		                        users_in_memory,
                                user_memory_init,
								statist,
                                u2ug_data[ii].user,
                                &rs_amsg_len,
								&rs_num_amsgs,
                                amsg_rs_ptr,
								&amsg_rs);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
            u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
	  }
	  else
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s already ADDED before",
            u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
      statist->u2ug_add++;
      statist->u2ug_ess++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
      msg_rs= CS_add_rs_msg (FUNC_ADDU2UG, &usr_prm, &oe_prm, &ug_prm,
                             &u2ug_data[ii], addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
      if (sw_user NE 0)
        amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                 &rs_num_amsgs ,
                                 amsg_rs ,
                                 amsg_rs_ptr ,
                                 msg_hdr,
                                 MSG_USER_ADD);
    }
   }
  }
  if (rs_num_amsgs NE 0) {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                 GET_FREE_HANDLE_CONNS,
                 MAX_GET, &actual_num,
                 &have_more, &handle, MAX_GET, MAX_GET,
                 ug_in, usr_in, u2ug_data,
                 addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
 
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_u2ug */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_usr_to_memory
 * Description   : load  users to memory
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_usr_to_memory (char    ** user_memory,
                              int       * usr_used,
                              int       * user_memory_init,
                              USER_typ    usr)
{
  char                  fn[]="CS_dwnld_usr_to_memory";
  ESA_RC                rc= ESA_OK;
  char                * memusr;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
      "usr=%s", usr);
 
  if (*usr_used EQ 0) {
    rc= CSA_alloc ((char **)user_memory,
                   0,
                   sizeof(USER_typ),
                   DEFAULT_BUFFER_INIT,
                   fn,
                   "mem. for users");
    if (rc NE ESA_OK)
      goto cleanup;
    *user_memory_init= DEFAULT_BUFFER_INIT;
  }
  if (*usr_used GE *user_memory_init) {
    rc= CSA_realloc ((char **)user_memory, 0, sizeof(USER_typ),
        *user_memory_init+ DEFAULT_BUFFER_INC);
    if (rc NE ESA_OK)
      goto cleanup;
    *user_memory_init += DEFAULT_BUFFER_INC;
  }
  memusr= *user_memory+ (*usr_used)* sizeof (USER_typ);
  strcpy (memusr, usr);
  (*usr_used)++;
  cleanup:
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* CS_dwnld_usr_to_memory */
 
 
 
/**************************************************************
*                                                             *
* Procedure Name   : CS_dwnld_add_usr
*                                                             *
* Description      : Send message to ESS about
*                      new interesting user
* Return Value     : ESA_RC                                   *
*                                                             *
**************************************************************/
 
ESA_RC CS_dwnld_add_usr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                         char                ** user_memory,
                         int                  * users_in_memory,
                         int                  * user_memory_init,
                         STATIST_rec_typ      * statist,
                         USER_typ               user,
                         NUM_MSGS_typ         * rs_amsg_len,
                         NUM_MSGS_typ         * rs_num_amsgs,
                         MSG_typ              * amsg_rs_ptr,
                         MSG_typ             ** amsg_rs)
{
  char fn[]="CS_dwnld_add_usr";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  OBJ_EXISTS_typ        obj_exist= OBJ_EXIST;
  void                * handle= NULL, * handle_for_evnt= NULL;
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   sw_upd= 0, sw_user= 0;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_PARAMS_rec_typ   usr_prm [1], usr_prm_in [1];
  ADDINFO_rec_ptr       addinfo [1];
  ENVIRONMENT_rec_typ * envir_ptr;
  char get_conn = 'N';  /* AC001 - CIQ#6 */
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUSERS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),   */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (u2ug_data);
  CLEAR (usr_prm_in);
  CLEAR (usr_prm);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  handle= NULL;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  CLEAR_STRUCT (obj_exist);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (u2ug_data);
  CLEAR (oe);
  CLEAR (usr_prm);
  CLEAR (usr_prm_in);
  /* BS10106 - Start We dont want to create list of users *
  rc= CS_dwnld_usr_to_memory (user_memory,
	                          users_in_memory,
							  user_memory_init,
							  user);
  if (rc NE ESA_OK)
      goto cleanup;
     BS10106 - Ends */
  memcpy ((char *)usr_prm_in[0].user, (char *)user, sizeof(USER_typ));
 
  ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_COMMON,
                   "Elements 1: %s", usr_prm_in[0].user);
 
  rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
  if (rc NE ESA_OK)
     goto cleanup;
 
  ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
  CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_MANY_USERS,
		oe, 1, 1, usr_prm_in, handle, addinfo);
  rc= envir_ptr->func_ptr.gtusers_ptr (
                    GET_MANY_USERS, oe, 1, &actual_num,
                    &have_more, &handle, 1, usr_prm_in,
                    usr_prm, addinfo, &obj_exist,
                    &envir_ptr->msg_admin_param,
                    &envir_ptr->msg_err, get_conn); /* AC001 - CIQ#6 */
  ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
  if (rc EQ ESA_OK)
     CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   usr_prm, &obj_exist, handle, addinfo);
 
  rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
  if (apiprm.post EQ CS_YES)
  {
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, &obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
  } /* END - PosstScript is required */
  if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtusers: Fail get users");
      goto cleanup;
  }
  if (obj_exist NE OBJ_NOT_EXIST) {
      statist->usr_add++;
      statist->usr_ess++;
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
                       "user %s ADDED (def ug %s)",
                       usr_prm[0].user, usr_prm[0].def_group);
     * amsg_rs= CS_add_rs_msg (FUNC_ADDUSER, &usr_prm[0], &oe_prm,
                               &ug_prm, &u2ug_data, addinfo[0],
                               rs_amsg_len, rs_num_amsgs,
                               * amsg_rs, amsg_rs_ptr,
                               rs_amsg_len, rs_num_amsgs,
                               * amsg_rs, amsg_rs_ptr,
                               rs_amsg_len, rs_num_amsgs,
                               * amsg_rs, amsg_rs_ptr,
                               msg_hdr, &sw_user, &sw_upd,
                               &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (*amsg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
  }
 
  cleanup:
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr (GET_FREE_HANDLE_USERS,
                    oe, 1, &actual_num,
                    &have_more, &handle, 1, usr_prm_in,
                    usr_prm, addinfo, &obj_exist,
                    &envir_ptr->msg_admin_param,
                    &envir_ptr->msg_err, get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   usr_prm, &obj_exist, handle, addinfo);
  }
  if (rc EQ ESA_OK)
      rc= rc_logout;
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_add_usr */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_u2ug_add
 * Description   : Add new interesting connections between
 *                     old (prev) list of interesting groups and
 *                     new increment list of interesting users
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_u2ug_add (RSS_MSG_HDR_rec_typ  * msg_hdr,
                          STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_u2ug_add";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  ESA_RC                rc_usr= ESA_OK, rc_ug= ESA_OK;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, filled_num_u2ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, from_num_u2ug= 0;
  int                   num_inc_users= 0, num_inc_ugs= 0;
  int                   num_int_u2ugs= 0, num_int_ugs= 0;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  UG_typ                ug_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  OE_typ                oe;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUG2UC,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
 /*WS10082K*     sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
 /*WS10082K*/    1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (ug_prm);
  CLEAR (oe);
  CLEAR (ug_in);
  CLEAR (usr_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR (u2ug_data);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_int_u2ugs =
      envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs;
  num_int_ugs = envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs;
 
/*      Build addinfo for user connection to user-group checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_users = envir_ptr->num_users;
  num_inc_ugs = envir_ptr->num_ugs;
  if (num_inc_users+ num_inc_ugs EQ 0)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
 
/*  Get connection of every group of old (prev) list of interesting
        groups and connection groups to ALL users*/
  for (from_num_u2ug= 0, filled_num_u2ugs = 0;
       from_num_u2ug LT num_int_u2ugs+ num_int_ugs AND rc EQ ESA_OK;)
  {
   CLEAR (ug_in);
   rc= CARE_int_u2ugs_fill (ug_in, &from_num_u2ug, &filled_num_u2ugs);
   for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (usr_in);
    CLEAR_STRUCT (ug_prm);
    CLEAR_STRUCT (usr_prm);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_GROUPS_CONNS, MAX_GET,
		filled_num_u2ugs, 0, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(
        GET_GROUPS_CONNS,MAX_GET,&actual_num,
        &have_more, &handle, filled_num_u2ugs,
        0,ug_in, usr_in, u2ug_data,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "ug=%s usr=%s NOT EXIST ",
                         u2ug_data[ii].group,
                         u2ug_data[ii].user);
        continue;
      }
      memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
              sizeof(USER_typ));
      memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
              sizeof(UG_typ));
      memcpy ((char *)usr_prm.def_group,
              (char *)u2ug_data[ii].def_group,
              sizeof(UG_typ));
 
/*----       if user of the connection in list interesting users
             or user's default group in list interesting groups */
      CARE_int_usr_find (u2ug_data[ii].user, u2ug_data[ii].def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
/*     if user of the connection in list increment users */
      rc_usr= CARE_inc_usr_find  (u2ug_data[ii].user,
                                  M_DWNLD_NAME_REGULAR);
/*     if user's def.group of the connection in list
          increment user groups */
	  if (strlen (u2ug_data[ii].def_group) EQ 0)
		  rc_ug= ESA_ERR;
	  else
          rc_ug= CARE_inc_ug_find  (u2ug_data[ii].def_group);
/*     If NOT -> skip the connection */
      if (
            (
               (rc_usr NE ESA_OK)
              AND
               (rc_ug NE ESA_OK)
            )
           OR
            (ess_cares NE ESS_DONT_CARE)
         )
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
     "Connection ug=%s to usr=%s def=%s SKIPPED (Aggregated in prev. Aggregation or not interesting)",
            u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
        continue;
      }
      statist->u2ug_add++;
      statist->u2ug_ess++;
      CS_dwnld_event (statist, STEP_U2UG_ADD, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
           u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
      msg_rs= CS_add_rs_msg (FUNC_ADDU2UG, &usr_prm, &oe_prm, &ug_prm,
                             &u2ug_data[ii], addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
   }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                   GET_FREE_HANDLE_CONNS, MAX_GET,
                   &actual_num, &have_more,
                   &handle, MAX_GET, MAX_GET,ug_in,
                   usr_in, u2ug_data, addinfo, obj_exist,
                   &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG_ADD, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_u2ug_add */
 
/****************************************************
 * Procedure Name: CS_dwnld_ug_all
 * Description   : ALL user group dwnld
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_ug_all (RSS_MSG_HDR_rec_typ * msg_hdr,
                        UG_typ                dwnld_from_group,
                        STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_ug_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, num_inc_ugs= 0, num_inc_u2ugs= 0;
  short                 num_ugs_in;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETUGS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
 /*WS10082K*     sizeof(ADDINFO_rec_typ),        */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
 /*WS10082K*/    1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (usr_prm);
  CLEAR (ug_prm);
  CLEAR (oe);
  CLEAR (ug_prm_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (u2ug_data);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_u2ugs = envir_ptr->num_u2ugs;
  num_inc_ugs = envir_ptr->num_ugs;
  if (rc NE ESA_OK OR num_inc_ugs+ num_inc_u2ugs EQ 0)
    goto cleanup;
  handle= NULL;
/*      Build addinfo for user-groups checksum */
  memset ((char *)(&usr_prm), '\0', sizeof(USER_PARAMS_rec_typ));
  memset ((char *)(&u2ug_data), '\0', sizeof(U2UG_PARAMS_rec_typ));
 
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
                envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *       */
                  (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
/*  Sync. all user-groups from RSS  */
  for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    num_ugs_in = 0;
    CLEAR (ug_prm_in);
    CLEAR (ug_prm);
    CLEAR (oe);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);*/
    if (strlen (dwnld_from_group) NE 0)
    {
       num_ugs_in = 1;
       strcpy (ug_prm_in[0].group, dwnld_from_group);
    }
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_ALL_GROUPS, oe,
				MAX_GET, num_ugs_in, ug_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getugs_ptr (
        GET_ALL_GROUPS, oe, MAX_GET,
        &actual_num,
        &have_more, &handle, num_ugs_in,
        ug_prm_in, ug_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->getugs: Fail get groups");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->ug_rss++;
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "group=%s Not Exist", ug_prm[ii].group);
        statist->ug_not_exist++;
        continue;
      }
 
      CARE_int_ug_find (ug_prm[ii].group, M_DWNLD_NAME_REGULAR,
                        &ess_cares);
      if (ess_cares NE ESS_DONT_CARE )
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Group %s SKIPPED (Aggregated in previous Aggregation)", ug_prm[ii].group);
        continue;
      }
 
      statist->ug_add++;
      statist->ug_ess++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Group=%s ADDED",ug_prm[ii].group);
      msg_rs=CS_add_rs_msg (FUNC_ADDUG, &usr_prm, &oe_prm, &ug_prm[ii],
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
                  GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
                  &actual_num, &have_more,
                  &handle, MAX_GET, ug_prm_in, ug_prm,
                  addinfo, obj_exist,
                  &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_ug_all */
																/* AGGR */
/****************************************************
 * Procedure Name: CS_dwnld_ug_all_aggr
 * Description   : ALL group dwnld
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_ug_all_aggr (RSS_MSG_HDR_rec_typ * msg_hdr,
                        UG_typ                dwnld_from_group,
                        STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_ug_all_aggr";
  ESA_RC                rc= ESA_OK, /*rc_pst, */ rc_logout= ESA_OK;
  /* sasc int                   sw_upd= 0, sw_user= 0; */
  NUM_MSGS_typ   rs_msg_len= 0; /* sasc rs_umsg_len= 0,rs_amsg_len= 0;*/
  NUM_MSGS_typ   rs_num_msgs=0; /* sasc rs_num_umsgs=0,rs_num_amsgs=0;*/
  MSG_typ      * msg_rs_ptr=NULL; /* sasc *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL; */
  MSG_typ      * msg_rs=NULL;  /* sasc *umsg_rs=NULL, *amsg_rs=NULL; */
  void                 * handle= NULL; /* sasc * handle_for_evnt= NULL;*/
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  /* sasc int           ii= 0, */
  int                   num_inc_ugs= 0, num_inc_u2ugs= 0;
  short                 num_ugs_in;
  /* sasc ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;   */
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  OE_typ                oe;
/*  OE_PARAMS_rec_typ     oe_prm;*/
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETUGS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
 /*WS10082K*/    1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (usr_prm);
  CLEAR (ug_prm);
  CLEAR (oe);
  CLEAR (ug_prm_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (u2ug_data);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_u2ugs = envir_ptr->num_u2ugs;
  num_inc_ugs = envir_ptr->num_ugs;
  if (rc NE ESA_OK OR num_inc_ugs+ num_inc_u2ugs EQ 0)
    goto cleanup;
  handle= NULL;
/*      Build addinfo for user-groups checksum */
  memset ((char *)(&usr_prm), '\0', sizeof(USER_PARAMS_rec_typ));
  memset ((char *)(&u2ug_data), '\0', sizeof(U2UG_PARAMS_rec_typ));
 
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
                envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *        */
                  (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
/*  Sync. all user-groups from RSS  */
  for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    num_ugs_in = 0;
    CLEAR (ug_prm_in);
    CLEAR (ug_prm);
    CLEAR (oe);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);*/
    if (strlen (dwnld_from_group) NE 0)
    {
       num_ugs_in = 1;
       strcpy (ug_prm_in[0].group, dwnld_from_group);
    }
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_ALL_GROUPS, oe,
				MAX_GET, num_ugs_in, ug_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getugs_ptr (
        GET_ALL_GROUPS, oe, MAX_GET,
        &actual_num,
        &have_more, &handle, num_ugs_in,
        ug_prm_in, ug_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
/*
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
        }
    } * END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->getugs: Fail get groups");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
/*
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->ug_rss++;
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "group=%s Not Exist", ug_prm[ii].group);
        statist->ug_not_exist++;
        continue;
      }
 
      CARE_int_ug_find (ug_prm[ii].group, M_DWNLD_NAME_REGULAR,
                        &ess_cares);
      if (ess_cares NE ESS_DONT_CARE )
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Group %s SKIPPED (Downloaded in previous download)", ug_prm[ii].group);
        continue;
      }
 
      statist->ug_add++;
      statist->ug_ess++;
      CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Group=%s ADDED",ug_prm[ii].group);
      msg_rs=CS_add_rs_msg (FUNC_ADDUG, &usr_prm, &oe_prm, &ug_prm[ii],
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    } */
  }
/*  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  } */
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
                  GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
                  &actual_num, &have_more,
                  &handle, MAX_GET, ug_prm_in, ug_prm,
                  addinfo, obj_exist,
                  &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
/*  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn); */
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_ug_all_aggr */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_usr_all
 * Description   : ALL users dwnld
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_usr_all (RSS_MSG_HDR_rec_typ * msg_hdr,
                         USER_typ              dwnld_from_user,
                         STATIST_rec_typ     * statist)
{
  char fn[]="CS_dwnld_usr_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  short                 num_users_in;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0,num_inc_users= 0,sw_upd= 0,sw_user= 0;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  get_conn = 'N';  /* AC001 - CIQ#6 */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  /* AC001 - CIQ#6 - Start */
  if (envir_ptr->iiq_version GT 0) {
    get_conn = 'Y';
    /* WS10070 - start */
    if (envir_ptr->iiq_version GE 2)
       get_conn = 'P';
    /* WS10070 - end */
  }
 
  ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
             "*****>... Get Connection=%c", get_conn);
  /* AC001 - CIQ#6 - End */
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUSERS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),       */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (ug_prm);
  CLEAR (usr_prm);
  CLEAR (usr_prm_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (u2ug_data);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_users = envir_ptr->num_users;
  if (num_inc_users EQ 0 OR rc NE ESA_OK)
    goto cleanup;
/*      Build addinfo for users checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *       */
              (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_ADD);
 
/* Sync. all users from RSS */
  for (have_more=HAVE_MORE;
       (have_more EQ HAVE_MORE) AND (rc EQ ESA_OK);) {
    num_users_in = 0;
    CLEAR (usr_prm_in);
    CLEAR (usr_prm);
    CLEAR (oe);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
 /*WS10082K*/ ( envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds +
 /*WS10082K*/ apiprm.script_kwd_num)  );
 /*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds); */
    if (strlen (dwnld_from_user) NE 0)
    {
       num_users_in = 1;
       strcpy (usr_prm_in[0].user, dwnld_from_user);
    }
 
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_MANY_USERS,
		oe, MAX_GET, num_users_in, usr_prm_in,
		handle, addinfo);
    rc= envir_ptr->func_ptr.gtusers_ptr (
                    GET_ALL_USERS, oe, MAX_GET,
                    &actual_num, &have_more, &handle,
                    num_users_in,usr_prm_in, usr_prm,
                    addinfo, obj_exist,
                    &envir_ptr->msg_admin_param, &envir_ptr->msg_err,
                    get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtusers: Fail get users");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->usr_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "User %s Not Exist", usr_prm[ii].user);
         statist->usr_not_exist++;
         continue;
	  }
/*----       if user in list interesting users */
      CARE_int_usr_find (usr_prm[ii].user, usr_prm[ii].def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
/*           If YES -> skip this user */
      if (ess_cares NE ESS_DONT_CARE)
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
         "User %s def ug %s SKIPPED (Aggregated in prev. Aggregation)",
         usr_prm[ii].user, usr_prm[ii].def_group);
        continue;
      }
      statist->usr_add++;
      statist->usr_ess++;
      CS_dwnld_event (statist, STEP_USR, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "user %s def ug %s ADDED", usr_prm[ii].user, usr_prm[ii].def_group);
      msg_rs= CS_add_rs_msg (FUNC_ADDUSER,&usr_prm[ii],&oe_prm,&ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
	ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr(
                 GET_FREE_HANDLE_USERS,oe,MAX_GET,
                 &actual_num, &have_more, &handle, MAX_GET,
                 usr_prm_in, usr_prm, addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err,
                 get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_USR, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_usr_all*/
 
/****************************************************
 * Procedure Name: CS_dwnld_u2ug_all
 * Description   : ALL user to user group connection dwnld
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_u2ug_all  (RSS_MSG_HDR_rec_typ  * msg_hdr,
                           char                ** user_memory,
                           int                  * users_in_memory,
                           int                  * user_memory_init,
                           UG_typ                 dwnld_from_group,
                           USER_typ               dwnld_from_user,
                           STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_u2ug_all";
  ESA_RC                rc_logout= ESA_OK;
  ESA_RC                rc=ESA_OK, rc_usr=ESA_OK,rc_ug=ESA_OK, rc_pst;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  short                 num_users_in;
  short                 num_ugs_in;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0,usrmem_num= 0,sw_upd= 0,sw_user= 0;
  ESS_INTRST_typ        ess_ugcares, ess_cares= ESS_DONT_CARE;
  /*int                   num_inc_ugs= 0,num_inc_u2ugs=0;*/
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  UG_typ                ug_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  OE_typ                oe;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUG2UC,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR (ug_in);
  CLEAR (oe);
  CLEAR (usr_in);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
/*  num_inc_u2ugs = envir_ptr->num_u2ugs;
  num_inc_ugs = envir_ptr->num_ugs;
  if (rc NE ESA_OK OR num_inc_ugs+ num_inc_u2ugs EQ 0)
    goto cleanup;*/
 
  handle= NULL;
/*      Build addinfo for user conn. to user-group checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
	                      FUNC_ADDU2UG,
						  bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *        */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
/* Build msg. header for add users */
 
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
 
  for (have_more= HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (ug_in);
    CLEAR (usr_in);
    CLEAR_STRUCT (ug_prm);
    CLEAR_STRUCT (usr_prm);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    num_ugs_in = 0;
    num_users_in = 0;
 
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds); */
    if ((strlen (dwnld_from_group) NE 0) AND
        (strlen (dwnld_from_user) NE 0))
    {
       num_users_in = 1;
       num_ugs_in = 1;
       strcpy (ug_in[0],  dwnld_from_group);
       strcpy (usr_in[0], dwnld_from_user);
    }
 
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_ALL_CONNS, MAX_GET,
		num_ugs_in, num_users_in, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr (
        GET_ALL_CONNS, MAX_GET, &actual_num,
        &have_more, &handle, num_ugs_in,
        num_users_in, ug_in, usr_in,
        u2ug_data, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
 
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "%s: actual_num=%d have_more=%d rc=%d",
                    fn, actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->u2ug_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "Conn,user %s to group %s Not Exist",
			 u2ug_data[ii].user, u2ug_data[ii].group);
         statist->u2ug_not_exist++;
         continue;
	  }
      memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
              sizeof(USER_typ));
      memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
              sizeof(UG_typ));
      memcpy ((char *)usr_prm.def_group,
              (char *)u2ug_data[ii].def_group,
              sizeof(UG_typ));
 
/*           If group of the connection is interesting */
      CARE_int_ug_find (
          ug_prm.group,M_DWNLD_NAME_REGULAR,&ess_ugcares);
 
/*           If user in list of increment users */
      rc_usr= CARE_inc_usr_find (u2ug_data[ii].user,
                                 M_DWNLD_NAME_REGULAR);
/*           If user's default group  in list of increment groups */
	  if (strlen (u2ug_data[ii].def_group) EQ 0)
		  rc_ug= ESA_ERR;
	  else
          rc_ug= CARE_inc_ug_find (u2ug_data[ii].def_group);
/*           If user is interesting user */
      CARE_int_usr_find (u2ug_data[ii].user ,u2ug_data[ii].def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
/*    IF NOT -> SKIP the connections */
      if (
 
           (
             (ess_cares   NE ESS_DONT_CARE)
            AND
             (ess_ugcares NE ESS_DONT_CARE)
           )
          OR
           (
             (rc_usr      NE ESA_OK)
            AND
             (rc_ug       NE ESA_OK)
            AND
             (ess_cares   EQ ESS_DONT_CARE)
           )
        )
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
    "Connection ug=%s to usr=%s def=%s SKIPPED (Aggregated in prev. Aggregation or not interesting).",
             u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
        continue;
      }
/*----       if this user had been getted in the program
              as interest user */
      usrmem_num= CS_dwnld_mem_usr_find (* user_memory,
		                                 * users_in_memory,
                                           u2ug_data[ii].user);
      if (
            (rc_ug      EQ ESA_OK)
           AND
            (rc_usr     NE ESA_OK)
           AND
            (ess_cares  EQ ESS_DONT_CARE)
           AND
            (usrmem_num GE *users_in_memory)
         )
	  {
          rc= CS_dwnld_add_usr (msg_hdr,
								user_memory,
								users_in_memory,
                                user_memory_init,
								statist,
                                u2ug_data[ii].user,
                                &rs_amsg_len,
								&rs_num_amsgs,
                                amsg_rs_ptr,
								&amsg_rs);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
             u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
	  }
	  else
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s already ADDED before",
             u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
 
      statist->u2ug_add++;
      statist->u2ug_ess++;
 
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
 
      msg_rs= CS_add_rs_msg (FUNC_ADDU2UG, &usr_prm, &oe_prm, &ug_prm,
                             &u2ug_data[ii], addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
      if (sw_user NE 0)
        amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                 &rs_num_amsgs ,
                                 amsg_rs ,
                                 amsg_rs_ptr ,
                                 msg_hdr,
                                 MSG_USER_ADD);
    }
  }
  if (rs_num_amsgs NE 0) {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                  GET_FREE_HANDLE_CONNS, MAX_GET,
                  &actual_num, &have_more,
                  &handle, MAX_GET, MAX_GET,ug_in,
                  usr_in, u2ug_data, addinfo, obj_exist,
                  &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_u2ug_all */
 
/****************************************************
 * Procedure Name: CS_dwnld_u2ug_oe
 * Description   : ALL user to user group connection dwnld
 *                     for every container from the list
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_u2ug_oe (RSS_MSG_HDR_rec_typ  * msg_hdr,
                         STATIST_rec_typ      * statist,
                         char                 * ug_typ_ptr,
                         int                    ug_mem_num)
{
  char fn[]="CS_dwnld_u2ug_oe";
  ESA_RC                rc_logout= ESA_OK, rc_usr= ESA_OK;
  ESA_RC                rc= ESA_OK, rc_pst;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  short                 num_users_in= 0;
  short                 num_ugs_in;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0,sw_upd= 0,sw_user= 0,from_num_ug= 0;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  UG_typ                ug_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
                    FUNC_GTUG2UC ,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR (ug_in);
  CLEAR (usr_in);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
/*      Build addinfo for user conn. to user-group checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
/* Build msg. header for add users */
 
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
 
/*  Get list of increment containers */
  for (from_num_ug= 0;
       from_num_ug LT ug_mem_num AND rc EQ ESA_OK;
       from_num_ug +=MAX_GET)
  {
 
     CLEAR (ug_in);
     rc= CS_dwnld_ugs_fill (ug_in, from_num_ug, &num_ugs_in,
                           ug_typ_ptr, ug_mem_num);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (usr_in);
       CLEAR_STRUCT (ug_prm);
       CLEAR_STRUCT (usr_prm);
       CLEAR (u2ug_data);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K*  envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
       CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_GROUPS_CONNS, MAX_GET,
		num_ugs_in, num_users_in, ug_in, usr_in, handle, addinfo);
       rc=envir_ptr->func_ptr.gtug2uc_ptr(
           GET_GROUPS_CONNS, MAX_GET,
           &actual_num,
           &have_more, &handle, num_ugs_in,
           num_users_in, ug_in, usr_in,
           u2ug_data, addinfo, obj_exist,
           &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
          CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
       if (apiprm.post EQ CS_YES)
       {
         rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
         if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
         }
       } /* END - PosstScript is required */
       if (rc NE ESA_OK)
       {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
            "->gtug2uc: Fail get connections");
         goto cleanup;
       }
 
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "%s: actual_num=%d have_more=%d rc=%d",
                    fn, actual_num, have_more, (int)rc);
 
       for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
         statist->u2ug_rss++;
         statist->tmp_num++;
         if (obj_exist[ii] EQ OBJ_NOT_EXIST)
		 {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
               "Conn,user %s to group %s Not Exist",
			    u2ug_data[ii].user, u2ug_data[ii].group);
            statist->u2ug_not_exist++;
            continue;
		 }
         memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
                 sizeof(USER_typ));
         memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
                 sizeof(UG_typ));
         usr_prm.def_group[0] = '\0';
 
/*           If user in list of increment users */
         rc_usr= CARE_inc_usr_find (u2ug_data[ii].user,
                                    M_DWNLD_NAME_REGULAR);
/*           If user is interesting user */
         CARE_int_usr_find (u2ug_data[ii].user ,usr_prm.def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
/*       IF NOT -> SKIP the connections */
         if (
                (rc_usr      NE ESA_OK)
               AND
                (ess_cares   EQ ESS_DONT_CARE)
            )
		 {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
   "Connection ug=%s to usr=%s def=%s SKIPPED (Aggregated in prev. Aggregation or not interesting).",
                         u2ug_data[ii].group, u2ug_data[ii].user,
                         u2ug_data[ii].def_group);
            continue;
		 }
         statist->u2ug_add++;
         statist->u2ug_ess++;
 
         CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
             u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
 
         msg_rs= CS_add_rs_msg (FUNC_ADDU2UG,&usr_prm,&oe_prm,&ug_prm,
                             &u2ug_data[ii], addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
         if (rc NE ESA_OK)
           goto cleanup;
 
         if (msg_rs EQ NULL)
         {
            rc = ESA_FATAL;
            goto cleanup;
         }
         if (sw_user NE 0)
           amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                 &rs_num_amsgs ,
                                 amsg_rs ,
                                 amsg_rs_ptr ,
                                 msg_hdr,
                                 MSG_USER_ADD);
       }
     }
  }
  if (rs_num_amsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                 GET_FREE_HANDLE_CONNS, MAX_GET,
                 &actual_num, &have_more,
                 &handle, MAX_GET, MAX_GET,ug_in,
                 usr_in, u2ug_data, addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_u2ug_oe */
 
/* WS10078KG - Start */
/****************************************************
 * Procedure Name: CS_dwnld_xref_all
 * Description   : ALL xref records (XROL/XSGP) download
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_xref_all (RSS_MSG_HDR_rec_typ  * msg_hdr,
                          STATIST_rec_typ      * statist,
                          char                   service_type)
{
  char                  fn[]="CS_dwnld_xref_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  int                   sw_upd= 0, sw_user= 0, step;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL;
  KWD_typ kwd_types=  { KWD_FOR_ADDINFO_1A_CHECK,
	                       KWD_FOR_ADDINFO_1A,
                        KWD_FOR_ADDINFO_1B_CHECK,
			                     KWD_FOR_ADDINFO_1B,
                        0,0,
                        KWD_FOR_ADDINFO_2A_CHECK,
	                       KWD_FOR_ADDINFO_2A,
                        KWD_FOR_ADDINFO_2B_CHECK,
			                     KWD_FOR_ADDINFO_2B };
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, num_kwds= 0;
  short                 num_ugs_in;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
  short                 api;
  char                  msg_code[2], entity[7];
  GET_GROUP_MODE        mode;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  if (service_type EQ DWNLD_SOURCE_SERVICE)
  {
     num_kwds = envir_ptr->interest[envir_ptr->rss_num].num_xsgp_kwds;
     api = FUNC_ADDXSGP;
     strcpy(msg_code,MSG_XSGP_ADD);
     strcpy(entity, "source");
     mode = GET_ALL_SOURCES;
     step = STEP_SOURCE;
  }
  else
  {
     num_kwds = envir_ptr->interest[envir_ptr->rss_num].num_xrol_kwds;
     api = FUNC_ADDXROL;
     strcpy(msg_code,MSG_XROL_ADD);
     strcpy(entity, "role");
     mode = GET_ALL_ROLES;
     step = STEP_ROLE;
  }
 
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),  */
                 num_kwds,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR (ug_prm);
  CLEAR (ug_prm_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  handle= NULL;
 
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) * num_kwds)
                     + sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Xref keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          api, bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              num_kwds);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
 /*WS10082K*     sizeof(ADDINFO_rec_typ) * num_kwds,   */
 /*WS10082K*/    num_kwds,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added roles */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          msg_code);
 
/*  Sync. all roles from RSS  */
  for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    num_ugs_in = 0;
    CLEAR (ug_prm_in);
    CLEAR (ug_prm);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
        num_kwds);
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_ALL_GROUPS, NULL,
				MAX_GET, num_ugs_in, ug_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getugs_ptr (
        mode , NULL, MAX_GET,
        &actual_num,
        &have_more, &handle, num_ugs_in,
        ug_prm_in, ug_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, NULL, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->getugs: Fail get %s record ", entity);
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      if(mode EQ GET_ALL_SOURCES)
         statist->source_rss++;
      else
         statist->role_rss++;
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "%s =%s Not Exist", entity, ug_prm[ii].group);
        statist->ug_not_exist++;
        continue;
      }
      if(mode EQ GET_ALL_SOURCES)
      {
         statist->source_add++;
         statist->source_ess++;
      }
      else
      {
         statist->role_add++;
         statist->role_ess++;
      }
 
      CS_dwnld_event (statist, step, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "%s =%s ADDED",entity, ug_prm[ii].group);
      msg_rs=CS_add_rs_msg ( api, NULL, NULL,
                             &ug_prm[ii],NULL, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  /* WS10079K - Start */
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, NULL,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
                  GET_FREE_HANDLE_GROUPS, NULL, MAX_GET,
                  &actual_num, &have_more,
                  &handle, MAX_GET, ug_prm_in, ug_prm,
                  addinfo, obj_exist,
                  &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
	if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, NULL, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
 
  /*CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, NULL, 0, have_more,
			               ug_prm, obj_exist, handle, addinfo);*/
  /* WS10079K - End */
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, step, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_xref_all */
/* WS10078KG - End */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_mem_usr_find
 * Description   : search user in memory
 * Input         :
 * Output        : record number of the user in memory
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
unsigned int CS_dwnld_mem_usr_find (char    * user_memory,
                                    int        users_in_memory,
                                    USER_typ   usr)
{
  unsigned int         ii;
  char fn[]="CS_dwnld_mem_usr_find";
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  for (ii= 0; ii LT (unsigned int)users_in_memory; ii++) {
    if (strcmp (usr, user_memory+ sizeof (USER_typ)* ii) EQ 0)
      break;
  }
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return (ii);
}
 
 
/****************************************************
 * Procedure Name: CS_dwnld_event
 * Description   : send to ESS and to CTSAMSG file
 *                   information message about process
 * Input         :
 * Output        :
 ****************************************************/
 
void CS_dwnld_event (STATIST_rec_typ * statist,
                    int                step,
                    int                step_type,
                    ESA_RC             exit_status)
{
  char                     fn[]="CS_dwnld_event";
  ESA_RC                   rc= ESA_OK;
  static int               sw_que= 0;
  void                   * handle_for_evnt= NULL;
  char                     date_str[sizeof(CS_DATE)+1];
  char                     time_str[sizeof(CS_TIME)+1];
  int                      users=0,groups=0,connections=0,oes=0;
  int                      roles=0,sources=0;  /* WS10078KG */
  char                     msg[100], *msgptr;   /* WS10078KG */
  CTSAMSG_MSGID_typ        msgid;
  ENVIRONMENT_rec_typ    * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  CLEAR_STRUCT (msgid);
  CLEAR (date_str);
  CLEAR (time_str);
  if (
	    (
           (step EQ STEP_OE)
          OR
           (step EQ STEP_UG)
          OR
           (step EQ STEP_USR)
          OR
           (step EQ STEP_U2UG)
          OR
           (step EQ STEP_U2UG_ADD)
  /* WS10078KG - Start */
          OR
           (step EQ STEP_ROLE)
          OR
           (step EQ STEP_SOURCE)
  /* WS10078KG - End */
        )
       AND
	    (statist->tmp_num LT statist->interval_num)
	   AND
        (step_type NE END_FN)
     )
    goto cleanup;
 
  if (
	    (
           (step EQ STEP_OE_CHKSUM)
          OR
           (step EQ STEP_UG_CHKSUM)
          OR
           (step EQ STEP_USR_CHKSUM)
          OR
           (step EQ STEP_U2UG_CHKSUM)
        )
       AND
	    (statist->tmp_num LT statist->interval_chksum_num)
	   AND
        (step_type NE END_FN)
     )
    goto cleanup;
 
  statist->tmp_num= 0;
  switch (step) {
    case STEP_OE:
        /* WS10078KG - Start */
        if (statist->oe_rss EQ 0)
          oes=  statist->oe_ess;
        else
          oes=  statist->oe_rss;
        sprintf(msg," %d containers ", oes);
        goto printMsg;
        /* WS10078KG - End */
 
    case STEP_UG:
        /* WS10078KG - Start */
        if (statist->ug_rss EQ 0)
          groups=  statist->ug_ess;
        else
          groups=  statist->ug_rss;
        sprintf(msg," %d groups ", groups);
        goto printMsg;
        /* WS10078KG - End */
 
    case STEP_USR:
        /* WS10078KG - Start */
        if (statist->usr_rss EQ 0)
          users=  statist->usr_ess;
        else
          users=  statist->usr_rss;
        sprintf(msg," %d users ", users);
        goto printMsg;
        /* WS10078KG - End */
    case STEP_U2UG:
        /* WS10078KG - Start */
        if (statist->u2ug_rss EQ 0)
          connections=  statist->u2ug_ess;
        else
          connections=  statist->u2ug_rss;
        sprintf(msg," %d connections ", connections);
        goto printMsg;
        /* WS10078KG - End */
    case STEP_U2UG_ADD:
        /* WS10078KG - Start */
        if (statist->ug_rss EQ 0)
          groups=  statist->ug_ess;
        else
          groups=  statist->ug_rss;
        sprintf(msg," %d groups ", groups);
        goto printMsg;
        /* WS10078KG - End */
    case STEP_ROLE:                  /* WS10078KG */
        /* WS10078KG - Start */
        if (statist->role_rss EQ 0)
          roles=  statist->role_ess;
        else
          roles=  statist->role_rss;
        sprintf(msg," %d roles ", roles);
        goto printMsg;
        /* WS10078KG - End */
    case STEP_SOURCE:                /* WS10078KG */
        /* WS10078KG - Start */
        if (statist->source_rss EQ 0)
          sources=  statist->source_ess;
        else
          sources=  statist->source_rss;
        sprintf(msg," %d sources ", sources);
        goto printMsg;
        /* WS10078KG - End */
    /* WS10078KG - Moved to specific case *
        if (statist->oe_rss EQ 0)
          oes=  statist->oe_ess;
        else
          oes=  statist->oe_rss;
 
        if (statist->ug_rss EQ 0)
          groups=  statist->ug_ess;
        else
          groups=  statist->ug_rss;
 
        if (statist->usr_rss EQ 0)
          users=  statist->usr_ess;
        else
          users=  statist->usr_rss;
 
        if (statist->u2ug_rss EQ 0)
          connections=  statist->u2ug_ess;
        else
          connections=  statist->u2ug_rss;
                                             */
printMsg:
        /* WS10078KG - End  */
 
        CTSAMSG_print (ERR_CS_STATIST_REC,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       statist->process,
 /* WS10078KG */       STATIST_PROCESSED, msg);
 /* WS10078KG *        STATIST_PROCESSED, oes, users, groups,
                       connections); */
        break;
 
    /* WS10078KG - Following code is used to print statistics during *
       checksum calculation. We are not supporting global sync or    *
       offline interceptor yet hence disabling the code to display   *
       statistics.                                                   *
 
    case STEP_OE_CHKSUM:
    case STEP_UG_CHKSUM:
    case STEP_USR_CHKSUM:
    case STEP_U2UG_CHKSUM:
        oes=          statist->oe_chk;
        groups=       statist->ug_chk;
        users=        statist->usr_chk;
        connections=  statist->u2ug_chk;
 
        CTSAMSG_print (ERR_CS_STATIST_REC,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       statist->process,
                       STATIST_CHKPROCESSED, oes, users, groups,
                       connections);
        break;
    * WS10078KG */
	case STEP_END_PROC:
        if (exit_status EQ ESA_OK)
        {
 /* WS10078KG - Following code is used to print statistics during *
    global sync. We are not supporting global sync yet hence      *
    disabling the code to display statistics                      *
 
          oes   =      statist->oe_chk;
          groups=      statist->ug_chk;
          users=       statist->usr_chk;
          connections= statist->u2ug_chk;
 
         if(oes NE 0 OR users NE 0 OR groups NE 0 OR connections NE 0)
            CTSAMSG_print (
                  ERR_CS_STATIST_REC,
                  envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                  envir_ptr->msg_admin_param.ctsamsg_dest,
                  statist->process,
                  STATIST_CHECKSUM, oes, users, groups,
                  connections);
 
          oes=         statist->oe_del;
          groups=      statist->ug_del;
          users=       statist->usr_del;
          connections= statist->u2ug_del;
 
         if(oes NE 0 OR users NE 0 OR groups NE 0 OR connections NE 0)
            CTSAMSG_print (
                 ERR_CS_STATIST_REC,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 statist->process,
                 STATIST_DELETED, oes, users, groups,
                 connections);
 
          oes=         statist->oe_upd;
          groups=      statist->ug_upd;
          users=       statist->usr_upd;
          connections= statist->u2ug_upd;
 
         if(oes NE 0 OR users NE 0 OR groups NE 0 OR connections NE 0)
            CTSAMSG_print (
                 ERR_CS_STATIST_REC,
                 envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                 envir_ptr->msg_admin_param.ctsamsg_dest,
                 statist->process,
                 STATIST_UPDATED, oes, users, groups, connections);
 
          oes=         statist->oe_not_chg;
          groups=      statist->ug_not_chg;
          users=       statist->usr_not_chg;
          connections= statist->u2ug_not_chg;
 
         if(oes NE 0 OR users NE 0 OR groups NE 0 OR connections NE 0)
            CTSAMSG_print (
                  ERR_CS_STATIST_REC,
                  envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                  envir_ptr->msg_admin_param.ctsamsg_dest,
                  statist->process,
                  STATIST_NOT_CHANGED, oes, users, groups,
                  connections);
          WS10078KG - End*/
 
          oes=         statist->oe_add;
          groups=      statist->ug_add;
          users=       statist->usr_add;
          connections= statist->u2ug_add;
          roles=       statist->role_add;              /* WS10078KG */
          sources=     statist->source_add;            /* WS10078KG */
 /* WS10078KG - Start */
          msgptr = msg;
          if(oes NE 0)
            msgptr += sprintf(msgptr," %d containers ",oes);
          if(groups NE 0)
            msgptr += sprintf(msgptr," %d groups ",groups );
          if(users NE 0)
            msgptr += sprintf(msgptr," %d users ",users );
          if(connections NE 0)
            msgptr += sprintf(msgptr," %d connections ",connections );
          if(roles NE 0)
            msgptr += sprintf(msgptr," %d roles ",roles );
          if(sources NE 0)
            msgptr += sprintf(msgptr," %d sources ",sources );
 /* WS10078KG - End */
         if(oes NE 0 OR users NE 0 OR groups NE 0 OR connections NE 0
            OR roles NE 0 OR sources NE 0 )             /* WS10078KG */
            CTSAMSG_print (
                  ERR_CS_STATIST_REC,
                  envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                  envir_ptr->msg_admin_param.ctsamsg_dest,
                  statist->process,
 /* WS10078KG */  STATIST_ADDED, msg);
 /* WS10078KG     STATIST_ADDED, oes, users, groups,
                  connections);  */
 
          oes=          statist->oe_ess;
          groups=       statist->ug_ess;
          users=        statist->usr_ess;
          connections=  statist->u2ug_ess;
          roles=        statist->role_ess;              /* WS10078KG */
          sources=      statist->source_ess;            /* WS10078KG */
 /* WS10078KG - Start */
          msg[0] = '\0';                                /* WS10079K */
 
          msgptr = msg;
          if(oes NE 0)
            msgptr += sprintf(msgptr," %d containers ",oes);
          if(groups NE 0)
            msgptr += sprintf(msgptr," %d groups ",groups );
          if(users NE 0)
            msgptr += sprintf(msgptr," %d users ",users );
          if(connections NE 0)
            msgptr += sprintf(msgptr," %d connections ",connections );
          if(roles NE 0)
            msgptr += sprintf(msgptr," %d roles ",roles );
          if(sources NE 0)
            msgptr += sprintf(msgptr," %d sources ",sources );
 /* WS10078KG - End */
          if(msg[0] EQ '\0')                            /* WS10079K */
             sprintf(msg,"No entity aggregated");       /* WS10079K */
 
          CTSAMSG_print (ERR_CS_STATIST_REC,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         statist->process,
/* WS10078KG */          STATIST_RESUME, msg);
/* WS10078KG             STATIST_RESUME, oes, users, groups,
                         connections); */
 
          if (strcmp (statist->process, DWNLD_PROCESS) EQ 0)
             strcpy ((char *)msgid, MSG_DWNLD_END_OK);
          else {
             strcpy ((char *)msgid, MSG_SYNC_END_OK);
             rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                              envir_ptr->msg_admin_param.rss_name,
                              handle_for_evnt,
                              MSG_SYNC_SUMMARY ,
                              envir_ptr->msg_admin_param.rss_name,
                              "CONTAINERS" ,
                              statist->oe_add,
                              statist->oe_del,
                              statist->oe_upd,
                              (statist->oe_chk +  statist->oe_add
                               - statist->oe_del));
             rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                              envir_ptr->msg_admin_param.rss_name,
                              handle_for_evnt,
                              MSG_SYNC_SUMMARY ,
                              envir_ptr->msg_admin_param.rss_name,
                              "USERS" ,
                              statist->usr_add,
                              statist->usr_del,
                              statist->usr_upd,
                              (statist->usr_chk +  statist->usr_add
                               - statist->usr_del));
             rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                              envir_ptr->msg_admin_param.rss_name,
                              handle_for_evnt,
                              MSG_SYNC_SUMMARY ,
                              envir_ptr->msg_admin_param.rss_name,
                              "GROUPS" ,
                              statist->ug_add,
                              statist->ug_del,
                              statist->ug_upd,
                              (statist->ug_chk +  statist->ug_add
                               - statist->ug_del));
             rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                              envir_ptr->msg_admin_param.rss_name,
                              handle_for_evnt,
                              MSG_SYNC_SUMMARY ,
                              envir_ptr->msg_admin_param.rss_name,
                              "CONNECTIONS" ,
                              statist->u2ug_add,
                              statist->u2ug_del,
                              statist->u2ug_upd,
                              (statist->u2ug_chk +  statist->u2ug_add
                               - statist->u2ug_del));
 
          }
          CTSAMSG_print (msgid,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         envir_ptr->msg_admin_param.rss_name) ;
 
        } /* ENDED OK */
        else
        {
 
          if (strcmp (statist->process, DWNLD_PROCESS) EQ 0)
		  {
             if (exit_status EQ ESA_ABORT_REQ)
                 strcpy ((char *)msgid, MSG_DWNLD_ABORTED);
			 else
                 strcpy ((char *)msgid, MSG_DWNLD_FAILED);
		  }
          else
             strcpy ((char *)msgid, MSG_SYNC_FAILED);
 
          CTSAMSG_print (msgid,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         envir_ptr->msg_admin_param.rss_name,
                         ESA_rc2str(exit_status));
        } /* END - SYNC/DWNLD FAILED */
 
        break;
 
  } /* END - switch step */
 
  memcpy ((char *)date_str, CS_date(), sizeof(CS_DATE));
  memcpy ((char *)time_str, CS_time(), sizeof(CS_TIME));
 
  if (sw_que EQ 0) {
      if (step EQ STEP_END_PROC)
        if (exit_status EQ ESA_OK) {
          if (strcmp (statist->process, DWNLD_PROCESS) EQ 0)
            strcpy ((char *)msgid, MSG_DWNLD_END_OK);
          else
            strcpy ((char *)msgid, MSG_SYNC_END_OK);
          rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                         envir_ptr->msg_admin_param.rss_name,
                         handle_for_evnt,
                         (const char *)msgid,
                         envir_ptr->msg_admin_param.rss_name);
        }
        else {
          if (strcmp (statist->process, DWNLD_PROCESS) EQ 0)
            strcpy ((char *)msgid, MSG_DWNLD_FAILED);
          else
            strcpy ((char *)msgid, MSG_SYNC_FAILED);
          rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                         envir_ptr->msg_admin_param.rss_name,
                         handle_for_evnt,
                         (const char *)msgid,
                         envir_ptr->msg_admin_param.rss_name,
                         ESA_rc2str(exit_status));
        }
      else {
        if (strcmp (statist->process, DWNLD_PROCESS) EQ 0)
            {
               strcpy ((char *)msgid, MSG_DWNLD_PROGRESS);
               rc= CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                                envir_ptr->msg_admin_param.rss_name,
                                handle_for_evnt,
                                (const char *)msgid,
                                envir_ptr->msg_admin_param.rss_name,
                                oes,
                                users,
                                groups,
                                connections);
            }
      }
  }
  if (rc NE ESA_OK)
    sw_que= 1;
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/****************************************************
 * Procedure Name: CS_dwnld_oe_all
 * Description   : dwnld ALL  containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_oe_all (RSS_MSG_HDR_rec_typ  * msg_hdr,
                        OE_typ                 dwnld_from_oe,
                        STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_oe_all";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, num_inc_oes= 0;
  short                 num_oes_in;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  OE_typ                oe;
  UG_PARAMS_rec_typ     ug_prm;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETOES,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (usr_prm);
  CLEAR (oe);
  CLEAR (oe_prm);
  CLEAR (oe_prm_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (u2ug_data);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_oes = envir_ptr->num_oes;
  if (rc NE ESA_OK OR num_inc_oes EQ 0)
    goto cleanup;
  handle= NULL;
  memset ((char *)(&usr_prm), '\0', sizeof(USER_PARAMS_rec_typ));
  memset ((char *)(&u2ug_data), '\0', sizeof(U2UG_PARAMS_rec_typ));
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *   */
                (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added container */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
/*  Sync. all containers from RSS  */
  for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    num_oes_in = 0;
    CLEAR (oe_prm_in);
    CLEAR (oe_prm);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
    if (strlen (dwnld_from_oe) NE 0)
    {
       num_oes_in = 1;
       strcpy (oe_prm_in[0].oe, dwnld_from_oe);
    }
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_ALL_OES, oe,
				MAX_GET, num_oes_in, oe_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getoes_ptr (
        GET_ALL_OES, oe, MAX_GET,&actual_num,
        &have_more, &handle, num_oes_in,
        oe_prm_in, oe_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
          "->getoes: Fail get containers with rc %d.", (int)rc);
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->oe_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "Oe %s Not Exist", oe_prm[ii].oe);
         statist->oe_not_exist++;
         continue;
	  }
      CARE_int_oe_find (oe_prm[ii].oe, &ess_cares);
      if (ess_cares NE ESS_DONT_CARE )
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Container %s SKIPPED (Aggregated in prev. Aggregation)", oe_prm[ii].oe);
        continue;
      }
 
      statist->oe_add++;
      statist->oe_ess++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s ADDED",oe_prm[ii].oe);
      msg_rs=CS_add_rs_msg (FUNC_ADDOE, &usr_prm, &oe_prm[ii], &ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (
          GET_FREE_HANDLE_OES, oe, MAX_GET,
          &actual_num, &have_more,
          &handle, MAX_GET, oe_prm_in, oe_prm,
          addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if((rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP))
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_oe_all */
																/* AGGR */
/****************************************************
 * Procedure Name: CS_dwnld_oe_all_aggr
 * Description   : dwnld ALL  containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      : For aggregation performance improvement, AD PM becomes slow if containers are not retrieved so calling get container but the data is not sent to IIQ.
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_oe_all_aggr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                        OE_typ                 dwnld_from_oe,
                        STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_oe_all_aggr";
  ESA_RC                rc= ESA_OK, /*rc_pst , */ rc_logout= ESA_OK;
  /* sasc int                   sw_upd= 0, sw_user= 0; */
  NUM_MSGS_typ   rs_msg_len= 0; /* sasc rs_umsg_len= 0,rs_amsg_len= 0;*/
  NUM_MSGS_typ   rs_num_msgs=0; /* sasc rs_num_umsgs=0,rs_num_amsgs=0;*/
  MSG_typ    *msg_rs_ptr=NULL; /* sasc *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;*/
  MSG_typ      * msg_rs=NULL;  /* sasc *umsg_rs=NULL, *amsg_rs=NULL;*/
  void                * handle= NULL; /* sasc * handle_for_evnt= NULL;*/
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  /* sasc  int                   ii= 0, */
  int                   num_inc_oes= 0;                     /* sasc   */
  short                 num_oes_in;
  /* sasc ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;             */
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  OE_typ                oe;
  /*UG_PARAMS_rec_typ     ug_prm; */
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETOES,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR_STRUCT (usr_prm);
  CLEAR (oe);
  CLEAR (oe_prm);
  CLEAR (oe_prm_in);
  CLEAR (obj_exist);
  CLEAR (addinfo);
  CLEAR_STRUCT (u2ug_data);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_oes = envir_ptr->num_oes;
  if (rc NE ESA_OK OR num_inc_oes EQ 0)
    goto cleanup;
  handle= NULL;
  memset ((char *)(&usr_prm), '\0', sizeof(USER_PARAMS_rec_typ));
  memset ((char *)(&u2ug_data), '\0', sizeof(U2UG_PARAMS_rec_typ));
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
               envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *       */
                (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added container */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
/*  Sync. all containers from RSS  */
  for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    num_oes_in = 0;
    CLEAR (oe_prm_in);
    CLEAR (oe_prm);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
    if (strlen (dwnld_from_oe) NE 0)
    {
       num_oes_in = 1;
       strcpy (oe_prm_in[0].oe, dwnld_from_oe);
    }
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_ALL_OES, oe,
				MAX_GET, num_oes_in, oe_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getoes_ptr (
        GET_ALL_OES, oe, MAX_GET,&actual_num,
        &have_more, &handle, num_oes_in,
        oe_prm_in, oe_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
/* AGGR
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
    } * END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
          "->getoes: Fail get containers with rc %d.", (int)rc);
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
/*
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->oe_rss++;
      statist->tmp_num++;
	  if (obj_exist[ii] EQ OBJ_NOT_EXIST)
	  {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "Oe %s Not Exist", oe_prm[ii].oe);
         statist->oe_not_exist++;
         continue;
	  }
      CARE_int_oe_find (oe_prm[ii].oe, &ess_cares);
      if (ess_cares NE ESS_DONT_CARE )
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Container %s SKIPPED (Downloaded in prev. download)", oe_prm[ii].oe);
        continue;
      }
 
      statist->oe_add++;
      statist->oe_ess++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s ADDED",oe_prm[ii].oe);
      msg_rs=CS_add_rs_msg (FUNC_ADDOE, &usr_prm, &oe_prm[ii], &ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }*/
  }
 /* if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
*/
  cleanup:
 
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (
          GET_FREE_HANDLE_OES, oe, MAX_GET,
          &actual_num, &have_more,
          &handle, MAX_GET, oe_prm_in, oe_prm,
          addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
/*  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if((rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP))
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn); */
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_oe_all_aggr */
 
/****************************************************
 * Procedure Name: CS_dwnld_oe_subtree
 * Description   : dwnld ALL  containers for every subtree
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
 
ESA_RC CS_dwnld_oe_subtree (RSS_MSG_HDR_rec_typ  * msg_hdr,
                            STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_oe_subtree";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs= 0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  int                   sw_upd= 0,sw_user= 0,ii= 0,from_num_oe= 0;
  short                 actual_num= 0,num_oes_in=0;
  HAVE_MORE_typ         have_more= NO_MORE;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  UG_PARAMS_rec_typ     ug_prm;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
                    FUNC_GETOES ,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
 
/*      Build addinfo for containers checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *    */
            (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added containers */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
     CARE_inc_get_next_oe (oe, from_num_oe);
     ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Container %s.", oe);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (oe_prm_in);
       CLEAR (oe_prm);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
       num_oes_in = 0;
 
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
       CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_SUBTREE_OES, oe,
				MAX_GET, num_oes_in, oe_prm_in, handle, addinfo);
       rc=envir_ptr->func_ptr.getoes_ptr (GET_SUBTREE_OES,oe,MAX_GET,
                                     &actual_num,
                                     &have_more, &handle, num_oes_in,
                                     oe_prm_in, oe_prm, addinfo,
                                     obj_exist,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
          CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
       if (apiprm.post EQ CS_YES)
         {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
       } /* END - PosstScript is required */
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
             "->getoes: Fail get containers");
          goto cleanup;
       }
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
       for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
          statist->oe_rss++;
          statist->tmp_num++;
          if (obj_exist[ii] EQ OBJ_NOT_EXIST)
          {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s NOT EXIST", oe_prm[ii].oe);
            statist->oe_not_exist++;
            continue;
          }
          CARE_int_oe_find (oe_prm[ii].oe, &ess_cares);
          if (ess_cares NE ESS_DONT_CARE)
          {
             ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "Container %s SKIPPED (Aggregated in prev. Aggregation)", oe_prm[ii].oe);
             continue;
          }
          statist->oe_add++;
          statist->oe_ess++;
          CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "oe=%s ADDED",oe_prm[ii].oe);
          msg_rs=CS_add_rs_msg(FUNC_ADDOE,&usr_prm,&oe_prm[ii],&ug_prm,
                                 &u2ug_data, addinfo[ii],
                                 &rs_msg_len, &rs_num_msgs,
                                 msg_rs, msg_rs_ptr,
                                 &rs_umsg_len, &rs_num_umsgs,
                                 umsg_rs, umsg_rs_ptr,
                                 &rs_amsg_len, &rs_num_amsgs,
                                 amsg_rs, amsg_rs_ptr,
                                 msg_hdr, &sw_user, &sw_upd,
                                 &rc);
         if (rc NE ESA_OK)
           goto cleanup;
 
         if (msg_rs EQ NULL)
         {
             rc = ESA_FATAL;
             goto cleanup;
         }
       }
     }
  }
 
  if (rs_num_msgs NE 0)
  {
        rc = CS_send_cd_msg (&rs_msg_len ,
                             &rs_num_msgs ,
                             msg_rs_ptr);
        if (rc NE ESA_OK)
        {
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
                 "->CS_send_cd_msg: Fail send msg");
           goto cleanup;
        }
  }
 
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (
        GET_FREE_HANDLE_OES, oe, MAX_GET,
        &actual_num, &have_more,
        &handle, MAX_GET, oe_prm_in, oe_prm,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if((rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc EQ ESA_NOT_SUPP))
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_oe_subtree */
															/* AGGR */
/****************************************************
 * Procedure Name: CS_dwnld_oe_subtree_aggr
 * Description   : dwnld ALL  containers for every subtree
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_oe_subtree_aggr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                            STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_oe_subtree_aggr";
  ESA_RC                rc= ESA_OK, /*rc_pst, */ rc_logout= ESA_OK;
  void                * handle= NULL; /* sasc * handle_for_evnt= NULL;*/
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ   rs_msg_len= 0; /* sasc rs_umsg_len= 0,rs_amsg_len= 0;*/
  NUM_MSGS_typ   rs_num_msgs=0; /* sasc rs_num_umsgs=0,rs_num_amsgs= 0;*/
  MSG_typ      * msg_rs_ptr=NULL; /* sasc *umsg_rs_ptr=NULL; */
  /* sasc MSG_typ             * amsg_rs_ptr=NULL; */
  MSG_typ      * msg_rs=NULL; /* sasc  *umsg_rs=NULL, *amsg_rs=NULL; */
  /* sasc int                   sw_upd= 0,sw_user= 0,ii= 0,  */
  int                   from_num_oe= 0;                    /* sasc   */
  short                 actual_num= 0,num_oes_in=0;
  HAVE_MORE_typ         have_more= NO_MORE;
  /* sasc ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;  */
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  UG_PARAMS_rec_typ     ug_prm;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
                    FUNC_GETOES ,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),    */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
 
/*      Build addinfo for containers checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *         */
            (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added containers */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
     CARE_inc_get_next_oe (oe, from_num_oe);
     ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Container %s.", oe);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (oe_prm_in);
       CLEAR (oe_prm);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
       num_oes_in = 0;
 
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
       CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_SUBTREE_OES, oe,
				MAX_GET, num_oes_in, oe_prm_in, handle, addinfo);
       rc=envir_ptr->func_ptr.getoes_ptr (GET_SUBTREE_OES,oe,MAX_GET,
                                     &actual_num,
                                     &have_more, &handle, num_oes_in,
                                     oe_prm_in, oe_prm, addinfo,
                                     obj_exist,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
          CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
/*
       if (apiprm.post EQ CS_YES)
         {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
       } * END - PosstScript is required */
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
             "->getoes: Fail get containers");
          goto cleanup;
       }
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
/*
       for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
          statist->oe_rss++;
          statist->tmp_num++;
          if (obj_exist[ii] EQ OBJ_NOT_EXIST)
          {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s NOT EXIST", oe_prm[ii].oe);
            statist->oe_not_exist++;
            continue;
          }
          CARE_int_oe_find (oe_prm[ii].oe, &ess_cares);
          if (ess_cares NE ESS_DONT_CARE)
          {
             ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "Container %s SKIPPED (Downloaded in prev. download)", oe_prm[ii].oe);
             continue;
          }
          statist->oe_add++;
          statist->oe_ess++;
          CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "oe=%s ADDED",oe_prm[ii].oe);
          msg_rs=CS_add_rs_msg(FUNC_ADDOE,&usr_prm,&oe_prm[ii],&ug_prm,
                                 &u2ug_data, addinfo[ii],
                                 &rs_msg_len, &rs_num_msgs,
                                 msg_rs, msg_rs_ptr,
                                 &rs_umsg_len, &rs_num_umsgs,
                                 umsg_rs, umsg_rs_ptr,
                                 &rs_amsg_len, &rs_num_amsgs,
                                 amsg_rs, amsg_rs_ptr,
                                 msg_hdr, &sw_user, &sw_upd,
                                 &rc);
         if (rc NE ESA_OK)
           goto cleanup;
 
         if (msg_rs EQ NULL)
         {
             rc = ESA_FATAL;
             goto cleanup;
         }
       } */
     }
  }
 
 /* if (rs_num_msgs NE 0)
  {
        rc = CS_send_cd_msg (&rs_msg_len ,
                             &rs_num_msgs ,
                             msg_rs_ptr);
        if (rc NE ESA_OK)
        {
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
                 "->CS_send_cd_msg: Fail send msg");
           goto cleanup;
        }
  }
*/
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (
        GET_FREE_HANDLE_OES, oe, MAX_GET,
        &actual_num, &have_more,
        &handle, MAX_GET, oe_prm_in, oe_prm,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
/*  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if((rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc EQ ESA_NOT_SUPP))
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn); */
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_oe_subtree_aggr */
 
/****************************************************
 * Procedure Name: CS_dwnld_oe
 * Description   : dwnld new increment list of intteresting
 *                        containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_oe (RSS_MSG_HDR_rec_typ  * msg_hdr,
                    STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_oe";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs= 0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  int                   sw_upd= 0,sw_user= 0,ii= 0,from_num_oe= 0;
  int                   num_inc_oes= 0;
  short                 actual_num= 0,filled_num_oes= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  UG_PARAMS_rec_typ     ug_prm;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR        (oe);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETOES,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),       */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_oes  = envir_ptr->num_oes;
 
/*      Build addinfo for containers */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K       sizeof(ADDINFO_rec_typ) *            */
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added containers */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT num_inc_oes AND rc EQ ESA_OK;
       from_num_oe +=MAX_GET) {
    CLEAR (oe_prm_in);
    CLEAR (oe_prm);
    CLEAR (oe);
    CLEAR (obj_exist);
    rc= CARE_inc_oes_fill (oe_prm_in, from_num_oe, &filled_num_oes);
 
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        (unsigned int)filled_num_oes,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_MANY_OES, oe,
				MAX_GET, filled_num_oes, oe_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getoes_ptr (
        GET_MANY_OES, oe,MAX_GET,&actual_num,
        &have_more, &handle, filled_num_oes,
        oe_prm_in, oe_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->getoes: Fail get containers");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "after getoes: actual_num=%d have_more=%d rc=%d",
                    actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s NOT EXIST", oe_prm[ii].oe);
        statist->oe_not_exist++;
        continue;
      }
      CARE_int_oe_find (oe_prm[ii].oe, &ess_cares);
      if (ess_cares NE ESS_DONT_CARE)
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Container %s SKIPPED (Aggregated in prev. Aggregation)", oe_prm[ii].oe);
        continue;
      }
      statist->oe_add++;
      statist->oe_ess++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s ADDED",oe_prm[ii].oe);
      msg_rs=CS_add_rs_msg (FUNC_ADDOE, &usr_prm, &oe_prm[ii], &ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
            "->CS_send_cd_msg: Fail send msg");
      goto cleanup;
    }
  }
 
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (
        GET_FREE_HANDLE_OES, oe, MAX_GET,
        &actual_num, &have_more,
        &handle, MAX_GET, oe_prm_in, oe_prm,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
/*  if (addinfo[0] NE NULL)
    free (addinfo[0]);*/
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if((rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc EQ ESA_NOT_SUPP))
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_oe */
																/* AGGR */
/****************************************************
 * Procedure Name: CS_dwnld_oe_aggr
 * Description   : dwnld new increment list of intteresting
 *                        containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :For aggregation performance improvement, AD PM becomes slow if containers are not retrieved so calling get container but the data is not sent to IIQ.
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_oe_aggr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                    STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_oe_aggr";
  ESA_RC                rc= ESA_OK, /*rc_pst, */ rc_logout= ESA_OK;
  void                * handle= NULL; /* sasc * handle_for_evnt= NULL;*/
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ   rs_msg_len= 0; /* sasc rs_umsg_len= 0,rs_amsg_len= 0;*/
  NUM_MSGS_typ   rs_num_msgs=0; /* sasv rs_num_umsgs=0,rs_num_amsgs= 0;*/
  MSG_typ             * msg_rs_ptr=NULL; /* sasc  *umsg_rs_ptr=NULL; */
  /* sasc MSG_typ             * amsg_rs_ptr=NULL; */
  MSG_typ      * msg_rs=NULL; /* sasc  *umsg_rs=NULL, *amsg_rs=NULL; */
  /* sasc int                   sw_upd= 0,sw_user= 0,ii= 0   */
  int                   from_num_oe= 0;               /* sasc    */
  int                   num_inc_oes= 0;
  short                 actual_num= 0,filled_num_oes= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  /* sasc ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;   */
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  UG_PARAMS_rec_typ     ug_prm;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR        (oe);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETOES,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  num_inc_oes  = envir_ptr->num_oes;
 
/*      Build addinfo for containers */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Oes keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDOE,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K       sizeof(ADDINFO_rec_typ) *         */
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added containers */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_OE_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT num_inc_oes AND rc EQ ESA_OK;
       from_num_oe +=MAX_GET) {
    CLEAR (oe_prm_in);
    CLEAR (oe_prm);
    CLEAR (oe);
    CLEAR (obj_exist);
    rc= CARE_inc_oes_fill (oe_prm_in, from_num_oe, &filled_num_oes);
 
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        (unsigned int)filled_num_oes,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_MANY_OES, oe,
				MAX_GET, filled_num_oes, oe_prm_in, handle, addinfo);
    rc=envir_ptr->func_ptr.getoes_ptr (
        GET_MANY_OES, oe,MAX_GET,&actual_num,
        &have_more, &handle, filled_num_oes,
        oe_prm_in, oe_prm, addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   oe_prm, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
/* - We just need to get containers, no need to send to ESS, so commenting below code
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_oe (SCRIPT_POST , actual_num, oe_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm->oe);
           }
        }
    } * END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->getoes: Fail get containers");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "after getoes: actual_num=%d have_more=%d rc=%d",
                    actual_num, have_more, (int)rc);
/*
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s NOT EXIST", oe_prm[ii].oe);
        statist->oe_not_exist++;
        continue;
      }
      CARE_int_oe_find (oe_prm[ii].oe, &ess_cares);
      if (ess_cares NE ESS_DONT_CARE)
      {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Container %s SKIPPED (Downloaded in prev. download)", oe_prm[ii].oe);
        continue;
      }
      statist->oe_add++;
      statist->oe_ess++;
      CS_dwnld_event (statist, STEP_OE, PROCESS_FN, rc);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "oe=%s ADDED",oe_prm[ii].oe);
      msg_rs=CS_add_rs_msg (FUNC_ADDOE, &usr_prm, &oe_prm[ii], &ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    } */
  }
  /*
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
            "->CS_send_cd_msg: Fail send msg");
      goto cleanup;
    }
  }
*/
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getoes_ptr.");
    CS_DIAG_OE_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_OES, oe,
				0, 0, oe_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getoes_ptr (
        GET_FREE_HANDLE_OES, oe, MAX_GET,
        &actual_num, &have_more,
        &handle, MAX_GET, oe_prm_in, oe_prm,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getoes_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
	   CS_DIAG_OE_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   oe_prm, obj_exist, handle, addinfo);
  }
/*  if (addinfo[0] NE NULL)
    free (addinfo[0]);*/
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  /*CS_dwnld_event (statist, STEP_OE, END_FN, rc);
  if((rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc EQ ESA_NOT_SUPP))
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn); */
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_oe_aggr */
 
/****************************************************
 * Procedure Name: CS_dwnld_ug_oe
 * Description   : dwnld user groups for "new "incremental
 *                 list of intteresting containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_ug_oe (RSS_MSG_HDR_rec_typ  * msg_hdr,
                       STATIST_rec_typ      * statist,
                       char                ** ug_typ_ptr,
                       int                  * ug_mem_num)
{
  char fn[]="CS_dwnld_ug_oe";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs= 0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  int                   sw_upd= 0,sw_user= 0,ii= 0,from_num_oe= 0;
  short                 actual_num= 0,num_ugs_in=0, real_num= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  ESS_INTRST_typ        ess_cares;
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_typ                ug_array   [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETUGS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),     */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
 
/*      Build addinfo for user-groups checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
            envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *            */
            (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added groups */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
     CARE_inc_get_next_oe (oe, from_num_oe);
     ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Container %s.", oe);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (ug_prm_in);
       CLEAR (ug_prm);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/  apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);*/
       num_ugs_in = 0;
 
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
       CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_SUBTREE_GROUPS, oe,
				MAX_GET, num_ugs_in, ug_prm_in, handle, addinfo);
       rc=envir_ptr->func_ptr.getugs_ptr (
           GET_SUBTREE_GROUPS, oe, MAX_GET,
           &actual_num,&have_more, &handle,
           num_ugs_in,
           ug_prm_in, ug_prm, addinfo,
           obj_exist,
           &envir_ptr->msg_admin_param,
           &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
	      CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
       if (apiprm.post EQ CS_YES)
       {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
         }
       } /* END - PosstScript is required */
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
             "->getugs: Fail get groups");
          goto cleanup;
       }
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
       for (ii= 0, real_num= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
          statist->ug_rss++;
          statist->tmp_num++;
          if (obj_exist[ii] EQ OBJ_NOT_EXIST)
          {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Group=%s NOT EXIST", ug_prm[ii].group);
            statist->ug_not_exist++;
            continue;
          }
          CARE_int_ug_find (ug_prm[ii].group, M_DWNLD_NAME_REGULAR,
                             &ess_cares);
          if (ess_cares NE ESS_DONT_CARE)
          {
             ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
                "Group %s SKIPPED (Aggregated in prev. Aggregation)", ug_prm[ii].group);
             continue;
          }
          statist->ug_add++;
          statist->ug_ess++;
          CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "Group=%s ADDED",ug_prm[ii].group);
 
          msg_rs= CS_add_rs_msg (FUNC_ADDUG, &usr_prm, &oe_prm,
                                 &ug_prm[ii], &u2ug_data, addinfo[ii],
                                 &rs_msg_len, &rs_num_msgs,
                                 msg_rs, msg_rs_ptr,
                                 &rs_umsg_len, &rs_num_umsgs,
                                 umsg_rs, umsg_rs_ptr,
                                 &rs_amsg_len, &rs_num_amsgs,
                                 amsg_rs, amsg_rs_ptr,
                                 msg_hdr, &sw_user, &sw_upd,
                                 &rc);
         if (rc NE ESA_OK)
           goto cleanup;
         strcpy (ug_array[real_num], ug_prm[ii].group);
		 real_num++;
         if (msg_rs EQ NULL)
         {
             rc = ESA_FATAL;
             goto cleanup;
         }
       }
       if (real_num GT 0)
          rc= CS_dwnld_ug_to_memory ((char *)ug_array, ug_typ_ptr,
                                    ug_mem_num, real_num);
     }
  }
  if (rs_num_msgs NE 0)
  {
        rc = CS_send_cd_msg (&rs_msg_len ,
                             &rs_num_msgs ,
                             msg_rs_ptr);
        if (rc NE ESA_OK)
        {
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
                 "->CS_send_cd_msg: Fail send msg");
           goto cleanup;
        }
  }
 
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
          GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
          &actual_num, &have_more,
          &handle, MAX_GET, ug_prm_in, ug_prm,
          addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_ug_oe */
																/* AGGR */
/****************************************************
 * Procedure Name: CS_dwnld_ug_oe_aggr
 * Description   : dwnld groups for "new "incremental
 *                 list of intteresting containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_ug_oe_aggr (RSS_MSG_HDR_rec_typ  * msg_hdr,
                       STATIST_rec_typ      * statist,
                       char                ** ug_typ_ptr,
                       int                  * ug_mem_num)
{
  char fn[]="CS_dwnld_ug_oe_aggr";
  ESA_RC                rc= ESA_OK, /*rc_pst, */ rc_logout= ESA_OK;
  void                * handle= NULL; /*sasc * handle_for_evnt= NULL; */
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  NUM_MSGS_typ    rs_msg_len= 0; /* sasc rs_umsg_len= 0,rs_amsg_len= 0;*/
  NUM_MSGS_typ    rs_num_msgs=0; /* sasc rs_num_umsgs=0,rs_num_amsgs= 0;*/
  MSG_typ             * msg_rs_ptr=NULL; /* sasc  *umsg_rs_ptr=NULL; */
  /* sasc MSG_typ             * amsg_rs_ptr=NULL; */
  MSG_typ       * msg_rs=NULL; /* sasc  *umsg_rs=NULL, *amsg_rs=NULL; */
  /* sasc int                   sw_upd= 0,sw_user= 0,ii= 0,*/
  int                   from_num_oe= 0;                 /* sasc   */
  short                 actual_num= 0,num_ugs_in=0; /* sasc  real_num= 0; */
  HAVE_MORE_typ         have_more= NO_MORE;
  /*ESS_INTRST_typ        ess_cares;*/
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  USER_PARAMS_rec_typ   usr_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  OE_typ                oe;
/*  OE_PARAMS_rec_typ     oe_prm;*/
/*  UG_typ                ug_array   [MAX_GET]; */
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR_STRUCT (usr_prm);
  CLEAR_STRUCT (u2ug_data);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETUGS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
 
/*      Build addinfo for user-groups checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
            envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *          */
            (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added groups */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
     CARE_inc_get_next_oe (oe, from_num_oe);
     ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Container %s.", oe);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (ug_prm_in);
       CLEAR (ug_prm);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/   apiprm.script_kwd_num);
/*WS10082K*  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds);*/
       num_ugs_in = 0;
 
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
       CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_SUBTREE_GROUPS, oe,
				MAX_GET, num_ugs_in, ug_prm_in, handle, addinfo);
       rc=envir_ptr->func_ptr.getugs_ptr (
           GET_SUBTREE_GROUPS, oe, MAX_GET,
           &actual_num,&have_more, &handle,
           num_ugs_in,
           ug_prm_in, ug_prm, addinfo,
           obj_exist,
           &envir_ptr->msg_admin_param,
           &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
	      CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
       /*
       if (apiprm.post EQ CS_YES)
       {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
         }
       } * END - PosstScript is required */
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
             "->getugs: Fail get groups");
          goto cleanup;
       }
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
/*
       for (ii= 0, real_num= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
          statist->ug_rss++;
          statist->tmp_num++;
          if (obj_exist[ii] EQ OBJ_NOT_EXIST)
          {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Group=%s NOT EXIST", ug_prm[ii].group);
            statist->ug_not_exist++;
            continue;
          }
          CARE_int_ug_find (ug_prm[ii].group, M_DWNLD_NAME_REGULAR,
                             &ess_cares);
          if (ess_cares NE ESS_DONT_CARE)
          {
             ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
                "Group %s SKIPPED (Downloaded in prev. download)", ug_prm[ii].group);
             continue;
          }
          statist->ug_add++;
          statist->ug_ess++;
          CS_dwnld_event (statist, STEP_UG, PROCESS_FN, rc);
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "Group=%s ADDED",ug_prm[ii].group);
 
          msg_rs= CS_add_rs_msg (FUNC_ADDUG, &usr_prm, &oe_prm,
                                 &ug_prm[ii], &u2ug_data, addinfo[ii],
                                 &rs_msg_len, &rs_num_msgs,
                                 msg_rs, msg_rs_ptr,
                                 &rs_umsg_len, &rs_num_umsgs,
                                 umsg_rs, umsg_rs_ptr,
                                 &rs_amsg_len, &rs_num_amsgs,
                                 amsg_rs, amsg_rs_ptr,
                                 msg_hdr, &sw_user, &sw_upd,
                                 &rc);
         if (rc NE ESA_OK)
           goto cleanup;
         strcpy (ug_array[real_num], ug_prm[ii].group);
		 real_num++;
         if (msg_rs EQ NULL)
         {
             rc = ESA_FATAL;
             goto cleanup;
         }
       }
       if (real_num GT 0)
          rc= CS_dwnld_ug_to_memory ((char *)ug_array, ug_typ_ptr,
                                    ug_mem_num, real_num); */
     }
  }
  /*if (rs_num_msgs NE 0)
  {
        rc = CS_send_cd_msg (&rs_msg_len ,
                             &rs_num_msgs ,
                             msg_rs_ptr);
        if (rc NE ESA_OK)
        {
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
                 "->CS_send_cd_msg: Fail send msg");
           goto cleanup;
        }
  }
*/
/*     Free handle from the memory */
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
          GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
          &actual_num, &have_more,
          &handle, MAX_GET, ug_prm_in, ug_prm,
          addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  /*CS_dwnld_event (statist, STEP_UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn); */
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
} /* End of CS_dwnld_ug_oe_aggr */
/****************************************************
 * Procedure Name: CS_dwnld_usr_oe
 * Description   : dwnld all users of list of interesting containers
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_usr_oe (RSS_MSG_HDR_rec_typ  * msg_hdr,
                        STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_usr_oe";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  OE_typ                oe;
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data;
  USER_PARAMS_rec_typ   usr_prm_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm    [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  void                * handle, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num, filled_num_users;
  HAVE_MORE_typ         have_more;
  int                   ii, from_num_oe ;
  int                   sw_upd, sw_user;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  ESS_INTRST_typ        ess_cares;
  ENVIRONMENT_rec_typ * envir_ptr;
  char get_conn = 'N'; /* AC001 - CIQ#6 */
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUSERS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),        */
                 envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
 
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (u2ug_data);
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Users keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUSER,
                          bufk)) NE ESA_OK)
    goto  cleanup;
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *      */
              (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_USER_ADD);
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
       from_num_oe LT envir_ptr->num_oes AND rc EQ ESA_OK;
       from_num_oe ++)
  {
     CARE_inc_get_next_oe (oe, from_num_oe);
     ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Container %s.", oe);
     for (have_more=HAVE_MORE;
         have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
        CLEAR (usr_prm);
        CLEAR (obj_exist);
        CLEAR (usr_prm_in);
        filled_num_users = 0 ;
        CS_addinfo_fill (
            info_ptr,
            addinfo,
            MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds);*/
 
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
           goto cleanup;
 
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
        CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_SUBTREE_USERS,
		   oe, MAX_GET, filled_num_users, usr_prm_in,
		   handle, addinfo);
        rc=envir_ptr->func_ptr.gtusers_ptr(
            GET_SUBTREE_USERS ,oe, MAX_GET,
            &actual_num, &have_more,
            &handle, filled_num_users,
            usr_prm_in, usr_prm,
            addinfo, obj_exist,
            &envir_ptr->msg_admin_param,
            &envir_ptr->msg_err,
            get_conn); /* AC001 - CIQ#6 */
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc EQ ESA_OK)
		   CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   usr_prm, obj_exist, handle, addinfo);
 
        rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
        if (apiprm.post EQ CS_YES)
        {
         rc_pst = CS_pre_post_users (SCRIPT_POST , actual_num, usr_prm,
                                     addinfo, NULL, &apiprm, rc,
									 ESA_RC_UNDEFINED, obj_exist);
         if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm->user);
           }
         }
        } /* END - PosstScript is required */
        if (rc NE ESA_OK)
        {
           ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
                           "->gtusers: Fail get users");
           goto cleanup;
        }
        ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                   "after gtusers: actual_num=%d have_more=%d rc=%d",
                   actual_num, have_more, (int)rc);
 
        for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
        {
            statist->tmp_num++;
            if (obj_exist[ii] EQ OBJ_NOT_EXIST)
            {
               ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
                  "usr=%s NOT EXIST",usr_prm[ii].user);
               statist->usr_not_exist++;
               continue;
            }
            CARE_int_usr_find (usr_prm[ii].user, usr_prm[ii].def_group,
                               M_DWNLD_NAME_REGULAR, &ess_cares);
            if (ess_cares NE ESS_DONT_CARE)
            {
               ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
                 "User %s def ug %s SKIPPED (Aggregated in prev. Aggregation)",
                 usr_prm[ii].user, usr_prm[ii].def_group);
               continue;
            }
            statist->usr_add++;
            statist->usr_ess++;
            CS_dwnld_event (statist, STEP_USR, PROCESS_FN,rc);
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
                 "User %s def ug %s ADDED", usr_prm[ii].user, usr_prm[ii].def_group);
            msg_rs= CS_add_rs_msg (FUNC_ADDUSER, &usr_prm[ii],
                             &oe_prm, &ug_prm,
                             &u2ug_data, addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
            if (rc NE ESA_OK)
               goto cleanup;
 
            if (msg_rs EQ NULL)
            {
               rc = ESA_FATAL;
               goto cleanup;
            }
        }
     }
  }
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> gtusers_ptr.");
    CS_DIAG_USER_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_USERS,
		oe, 0, 0, usr_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtusers_ptr(
          GET_FREE_HANDLE_USERS,oe,MAX_GET,
          &actual_num, &have_more, &handle, MAX_GET,
          usr_prm_in, usr_prm, addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err,
          get_conn); /* AC001 - CIQ#6 */
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- gtusers_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_USER_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   usr_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_USR, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_usr_oe */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_ug_to_memory
 * Description   : Add 'actual_num' groups to memory.
 * Return Value  :
 * Comments      :
 * Scope         :
 ***************************************************/
 
ESA_RC CS_dwnld_ug_to_memory (char           * ug_array,
                             char          ** ug_typ_ptr,
                             int            * ug_mem_num,
                             short            actual_num)
{
  char fn[]="CS_dwnld_ug_to_memory";
  ESA_RC                rc = ESA_OK;
  /*
    PROCESS when no group checksum resides in the memory yet:
  */
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  if (*ug_mem_num EQ 0)
    /*
      ALLOCATE memory segment for the number of input groups.
    */
    rc= CSA_alloc (ug_typ_ptr,
                   0,
                   sizeof(UG_typ),
                   actual_num,
                   fn,
                   "Groups");
  else
    /*
      REALLOCATE memory segment for the additional number of groups.
    */
    rc= CSA_realloc (ug_typ_ptr,
                     0,
                     sizeof (UG_typ),
                     (*ug_mem_num)+ actual_num);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY the input groups details to the "new" segment portion that
    was allocated.
  */
  memcpy ((char *)(*ug_typ_ptr+ ((sizeof (UG_typ))*(*ug_mem_num))),
          (char *)ug_array,
          sizeof (UG_typ)* actual_num);
  (*ug_mem_num) += actual_num;
 
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc );
  return rc;
} /* END - add_ug_checksum_to_memory function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CS_dwnld_ugs_fill
*                                                             *
* Description      : Fill UG_typ array with groups
*                      from list of groups
* Input            : from group number in list
* Output           : Array of UG_typ
*                  : Number filled groups
**************************************************************/
 
ESA_RC CS_dwnld_ugs_fill (UG_typ   ug_in[1],
                          int      from_num_ug,
                          short  * num_ugs_in,
                          char   * ug_typ_ptr,
                          int      ug_mem_num)
{
  char                  fn[]="ugs_fill";
  int                   ii;
  char                * ug_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  for (ii=   from_num_ug, *num_ugs_in= 0;
       ii LT ug_mem_num AND *num_ugs_in LT MAX_GET;
       ii++, (*num_ugs_in)++)
  {
    ug_ptr= ug_typ_ptr + (ii*sizeof(UG_typ));
    strcpy (ug_in[*num_ugs_in], ug_ptr);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
       "%s: %d ug - %s.", fn, ii, ug_ptr);
  }
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CS_dwnld_sync_inc
*                                                             *
* Description      : Fill increment OE,User,Group,Connection
*                      lists dependent of dwnld/sync method
* Input            : method
*                  : oe_list
*                  : group_list
*                  : user_list
*                  : conn_list
**************************************************************/
 
ESA_RC CS_dwnld_sync_inc (char   method,
                         char   user_list,
                         char   group_list,
                         char   conn_list,
                         char   oe_list)
{
   ESA_RC  rc= ESA_OK;
   char    fn[]="CS_dwnld_sync_inc";
 
   ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
       "method=%c user_list=%c group_list=%c conn_list=%c oe_list=%c.",
        method, user_list, group_list, conn_list, oe_list);
 
    if (
        (method       EQ M_DWNLD_SYNC_METHOD_ALL_RSS)
            OR
        (oe_list      EQ M_DWNLD_SYNC_LIST_ALL)
        )
       rc= CS_dwnld_inc_oe (NULL, NULL);
 
    if (rc EQ ESA_NOT_SUPP)
       rc = ESA_OK;
 
    if (rc NE ESA_OK)
       goto cleanup;
 
    if (
          (method        EQ M_DWNLD_SYNC_METHOD_ALL_RSS)
         OR
          (
             (group_list EQ M_DWNLD_SYNC_LIST_ALL)
            AND
             (method     EQ M_DWNLD_SYNC_METHOD_LIST)
          )
       )
       rc= CS_dwnld_inc_ug (NULL, NULL);
 
    if (rc NE ESA_OK)
       goto cleanup;
 
    if (
         (method        EQ M_DWNLD_SYNC_METHOD_ALL_RSS)
        OR
         (
            (conn_list  EQ M_DWNLD_SYNC_LIST_ALL)
          AND
            (method     EQ M_DWNLD_SYNC_METHOD_LIST)
         )
       )
       rc= CS_dwnld_inc_u2ug (NULL, NULL);
 
    if (rc NE ESA_OK)
       goto cleanup;
 
    if (
         (method EQ M_DWNLD_SYNC_METHOD_ALL_RSS)
        OR
         (
            (user_list  EQ M_DWNLD_SYNC_LIST_ALL)
          AND
            (method     EQ M_DWNLD_SYNC_METHOD_LIST)
         )
       )
       rc= CS_dwnld_inc_usr (NULL, NULL);
 
    if (rc NE ESA_OK)
       goto cleanup;
 
cleanup:
    ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
    return (rc);
}
 
 
/****************************************************
 * Procedure Name: CS_dwnld_usr_def_ug
 * Description   : Add to Ess & to memory of the interesting users
 *                     these users, that theirs default groups
 *                     in list of interesting groups
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_usr_def_ug (RSS_MSG_HDR_rec_typ  * msg_hdr,
						    char                ** user_memory,
                            int                  * users_in_memory,
                            int                  * user_memory_init,
                            STATIST_rec_typ      * statist)
 
{
  char fn[]="CS_dwnld_usr_def_ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  ESA_RC                rc_ug= ESA_OK, rc_usr= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  short                 actual_num= 0, filled_num_ugs= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0, from_num_ug= 0;
  unsigned int          usrmem_num= 0;
  ESS_INTRST_typ        ess_cares= ESS_DONT_CARE;
 
  RSSAPIPRM_rec_typ     apiprm;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  UG_typ                ug_in  [MAX_GET];
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
 
  NUM_MSGS_typ          rs_amsg_len= 0, rs_num_amsgs=0;
  MSG_typ             * amsg_rs_ptr=NULL, * amsg_rs=NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR (usr_in);
  CLEAR (ug_in);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
 
/* Build msg. header for add users */
 
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUG2UC,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),       */
           envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
 
  addinfo[0]= info_ptr;
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *          */
             (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/*  Get connection of every group from list of increment groups
    to ALL users */
  for (from_num_ug= 0, filled_num_ugs = 0;
       from_num_ug LT envir_ptr->num_ugs AND rc EQ ESA_OK;)
  {
 
   CLEAR (ug_in);
   rc= CARE_inc_only_ugs_fill (ug_in, &from_num_ug, &filled_num_ugs);
   for (have_more=HAVE_MORE;
       have_more EQ HAVE_MORE AND rc EQ ESA_OK;) {
    CLEAR (usr_in);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_GROUPS_CONNS, MAX_GET,
		filled_num_ugs, 0, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(
        GET_GROUPS_CONNS,MAX_GET,&actual_num,
        &have_more, &handle, filled_num_ugs,
        0, ug_in, usr_in, u2ug_data,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
           "after getug2uc: actual_num=%d have_more=%d rc=%d",
            actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "ug=%s usr=%s NOT EXIST ",u2ug_data[ii].group, u2ug_data[ii].user);
        continue;
      }
 
/*----       if user of the connection in list interesting users
             or user's default group in list interesting groups */
      CARE_int_usr_find (u2ug_data[ii].user, u2ug_data[ii].def_group,
                         M_DWNLD_NAME_REGULAR, &ess_cares);
 
/*----       if user of the connection in list
             increment users */
      rc_usr= CARE_inc_usr_find (u2ug_data[ii].user,
		                         M_DWNLD_NAME_REGULAR);
/*----       if this user had been getted in the program */
      usrmem_num= CS_dwnld_mem_usr_find (*user_memory,
		                                 *users_in_memory,
                                         u2ug_data[ii].user);
/*----       if user's default group of the connection in list
             increment groups */
	  if (strlen (u2ug_data[ii].def_group) EQ 0)
		  rc_ug= ESA_ERR;
	  else
          rc_ug= CARE_inc_ug_find (u2ug_data[ii].def_group);
 
	  if (
		    (ess_cares     NE  ESS_DONT_CARE)
           OR
		    (rc_usr EQ ESA_OK)
           OR
		    (usrmem_num LT (unsigned int)*users_in_memory)
           OR
		    (rc_ug NE ESA_OK)
	 	 )
	  {
    	  ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
           "Conn. ug=%s usr=%s def=%s SKIPPED (Aggregated in prev. Aggregation) or not interesting)",
              u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
          continue;
      }
/*    This user is new interesting user  */
 
	  rc= CS_dwnld_add_usr (msg_hdr,
							user_memory,
		                    users_in_memory,
                            user_memory_init,
							statist,
                            u2ug_data[ii].user,
                            &rs_amsg_len,
							&rs_num_amsgs,
                            amsg_rs_ptr,
							&amsg_rs);
  	  ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
             "Conn. ug=%s usr=%s def=%s ADDED.",
              u2ug_data[ii].group, u2ug_data[ii].user, u2ug_data[ii].def_group);
    }
   }
  }
 
  if (rs_num_amsgs NE 0) {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
          GET_FREE_HANDLE_CONNS,
          MAX_GET, &actual_num,
          &have_more, &handle, MAX_GET, MAX_GET,
          ug_in, usr_in, u2ug_data,
          addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_usr_def_ug */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_usr_u2ug
 * Description   : dwnld new interesting connections
 *                   of new increment list of interesting
 *                   users
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
ESA_RC CS_dwnld_usr_u2ug (RSS_MSG_HDR_rec_typ  * msg_hdr,
                          char                ** user_memory,
                          int                  * users_in_memory,
                          int                  * user_memory_init,
                          STATIST_rec_typ      * statist)
{
  char fn[]="CS_dwnld_usr_u2ug";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  ESA_RC                rc_ug= ESA_OK, rc_u2ug= ESA_OK;
  int                   sw_upd= 0, sw_user= 0;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ    *msg_rs_ptr=NULL, *umsg_rs_ptr=NULL, *amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0, filled_num_users= 0;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   from_num_user, ii= 0;
  ESS_INTRST_typ        ess_u2ugcares;
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  UG_typ                ug_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  OE_typ                oe;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
  CLEAR (usr_in);
  CLEAR (ug_in);
  CLEAR (oe);
  CLEAR_STRUCT (oe_prm);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GTUG2UC,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),      */
            envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
 
/*      Build addinfo for user connection to user-group checksum  */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *          */
               (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
 
 
/*  Get list of increment  users */
  for (from_num_user= 0;
       from_num_user LT (*users_in_memory) AND rc EQ ESA_OK;
	   from_num_user += filled_num_users)
  {
 
   CLEAR (ug_in);
   CLEAR (usr_in);
   CS_dwld_mem_users_fill (* user_memory,
                           * users_in_memory,
                           & from_num_user,
                           & filled_num_users,
	                       usr_in);
 
   for (have_more=HAVE_MORE;
          (have_more EQ HAVE_MORE)
         AND
          (rc EQ ESA_OK)
         AND
          (filled_num_users GT 0);
       )
   {
    CLEAR (ug_in);
    CLEAR (u2ug_data);
    CLEAR (obj_exist);
    CS_addinfo_fill (
        info_ptr,
        addinfo,
        MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K* envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
    rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (rc NE ESA_OK)
       goto cleanup;
 
 
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_USERS_CONNS, MAX_GET,
		0,filled_num_users, ug_in, usr_in, handle, addinfo);
    rc=envir_ptr->func_ptr.gtug2uc_ptr(
        GET_USERS_CONNS,MAX_GET,&actual_num,
        &have_more, &handle, 0, filled_num_users,
        ug_in, usr_in, u2ug_data,
        addinfo, obj_exist,
        &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rc EQ ESA_OK)
	   CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
    rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
    if (apiprm.post EQ CS_YES)
    {
        rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                   addinfo, NULL, &apiprm, rc,
								   ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
        }
    } /* END - PosstScript is required */
	
    if (rc NE ESA_OK) {
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
         "->gtug2uc: Fail get connections");
      goto cleanup;
    }
    ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
           "after getug2uc: actual_num=%d have_more=%d rc=%d",
            actual_num, have_more, (int)rc);
 
    for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++) {
      statist->tmp_num++;
      if (obj_exist[ii] EQ OBJ_NOT_EXIST) {
        ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
                         "ug=%s usr=%s NOT EXIST ",
                         u2ug_data[ii].group,
                         u2ug_data[ii].user);
        continue;
      }
/* CHECK if group is already included in increment connections. */
      rc_u2ug= CARE_inc_u2ug_find (u2ug_data[ii].group);
/* CHECK if group is already included in increment group names. */
      rc_ug= CARE_inc_ug_find (u2ug_data[ii].group);
/*----       if group of the connection in list interesting groups
              (ESS_U2UG_CARE) */
      CARE_int_ug_find (u2ug_data[ii].group,
                        M_DWNLD_NAME_REGULAR, &ess_u2ugcares);
/*           If NOT -> skip connection (not interesting) */
      if (
            (ess_u2ugcares EQ ESS_DONT_CARE)
           AND
            (rc_ug NE ESA_OK)
           AND
            (rc_u2ug NE ESA_OK)
         )
      {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
     "Conn. ug=%s to usr=%s def ug=%s SKIPPED (Aggregated in prev. Aggregation or not interesting)",
                          u2ug_data[ii].group, u2ug_data[ii].user,
                          u2ug_data[ii].def_group);
         continue;
      }
      statist->u2ug_add++;
      statist->u2ug_ess++;
      CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
      memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
              sizeof(USER_typ));
      memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
              sizeof(UG_typ));
      memcpy ((char *)usr_prm.def_group,
              (char *)u2ug_data[ii].def_group,
              sizeof(UG_typ));
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
                       u2ug_data[ii].group, u2ug_data[ii].user,
                       u2ug_data[ii].def_group);
      ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
                       ug_prm.group, usr_prm.user,
                       usr_prm.def_group);
      msg_rs= CS_add_rs_msg (FUNC_ADDU2UG, &usr_prm, &oe_prm, &ug_prm,
                             &u2ug_data[ii], addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
      if (rc NE ESA_OK)
        goto cleanup;
 
      if (msg_rs EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
      }
    }
   }
  }
  if (rs_num_msgs NE 0) {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK) {
      goto cleanup;
    }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
           GET_FREE_HANDLE_CONNS,
           MAX_GET, &actual_num,
           &have_more, &handle, MAX_GET, MAX_GET,
           ug_in, usr_in, u2ug_data,
           addinfo, obj_exist,
           &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_usr_u2ug*/
 
 
 
/****************************************************
 * Procedure Name: CS_dwnld_int_ug_oe
 * Description   : Get list of interesting groups of interesting oes
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
static ESA_RC CS_dwnld_int_ug_oe  (char ** ug_typ_ptr,
                                   int   * ug_mem_num)
{
  char fn[]="CS_dwnld_int_ug_oe";
  ESA_RC                rc= ESA_OK, rc_pst, rc_logout= ESA_OK;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  int                   ii= 0,from_num_oe= 0;
  short                 actual_num= 0,num_ugs_in=0;
  HAVE_MORE_typ         have_more= NO_MORE;
 
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  OE_typ                oe;
  UG_typ                ug_array   [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm_in  [MAX_GET];
  UG_PARAMS_rec_typ     ug_prm     [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ADDINFO_rec_typ     * info_ptr= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
  MEMBER_OE_rec_typ   * oe_rec;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
	                FUNC_GETUGS,
					&apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),        */
                 envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
 
/*      Build addinfo for user-groups checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
            envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Groups keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDUG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
              bufk,
              kwd_types,
              1,
              envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *           */
            (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/*  Get list of increment containers */
  for (from_num_oe= 0;
    (from_num_oe LT envir_ptr->interest[envir_ptr->rss_num].pre_num_oes)
   AND
    (rc EQ ESA_OK);
       from_num_oe ++)
  {
     oe_rec= envir_ptr->interest[envir_ptr->rss_num].pre_oes_ptr+
                     from_num_oe;
     strcpy (oe, oe_rec->oe);
     ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "Container %s.", oe);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (ug_prm_in);
       CLEAR (ug_prm);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K*  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds); */
       num_ugs_in = 0;
 
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
       CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_SUBTREE_GROUPS, oe,
				MAX_GET, num_ugs_in, ug_prm_in, handle, addinfo);
       rc=envir_ptr->func_ptr.getugs_ptr (
           GET_SUBTREE_GROUPS, oe, MAX_GET,
           &actual_num,&have_more, &handle,
           num_ugs_in,
           ug_prm_in, ug_prm, addinfo,
           obj_exist,
           &envir_ptr->msg_admin_param,
           &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
	      CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, actual_num, have_more,
			   ug_prm, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
       if (apiprm.post EQ CS_YES)
       {
        rc_pst = CS_pre_post_ug (SCRIPT_POST , actual_num, ug_prm,
                                 addinfo, NULL, &apiprm, rc,
								 ESA_RC_UNDEFINED, obj_exist);
        if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm->group);
           }
         }
       } /* END - PosstScript is required */
       if (rc NE ESA_OK)
       {
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
             "->getugs: Fail get groups");
          goto cleanup;
       }
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "actual_num=%d have_more=%d rc=%d",
                     actual_num, have_more, (int)rc);
 
       for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
          if (obj_exist[ii] EQ OBJ_NOT_EXIST)
          {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "ug=%s NOT EXIST", ug_prm[ii].group);
            continue;
          }
          ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
               "ug=%s ADDED",ug_prm[ii].group);
          strcpy (ug_array[ii], ug_prm[ii].group);
       }
       if (actual_num GT 0)
          rc= CS_dwnld_ug_to_memory ((char *)ug_array, ug_typ_ptr,
                                     ug_mem_num, actual_num);
     }
  }
 
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getugs_ptr.");
    CS_DIAG_UG_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_GROUPS, oe,
				0, 0, ug_prm_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.getugs_ptr (
          GET_FREE_HANDLE_GROUPS, oe, MAX_GET,
          &actual_num, &have_more,
          &handle, MAX_GET, ug_prm_in, ug_prm,
          addinfo, obj_exist,
          &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...<- getugs_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG_OUT (ESA_COMP_ACSPMPF, oe, 0, have_more,
			   ug_prm, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_ug_oe */
 
 
/****************************************************
 * Procedure Name: CS_dwnld_u2ug_oe_add
 * Description   : Additional user to user group connection dwnld
 *                 for every container from the interesting list
 * Input         :
 * Output        :
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************/
 
static ESA_RC CS_dwnld_u2ug_oe_add (RSS_MSG_HDR_rec_typ  * msg_hdr,
                             STATIST_rec_typ      * statist,
                             char                 * ug_typ_ptr,
                             int                    ug_mem_num)
{
  char fn[]="CS_dwnld_u2ug_oe_add";
  ESA_RC                rc_logout= ESA_OK, rc_usr= ESA_OK;
  ESA_RC                rc= ESA_OK, rc_pst;
  NUM_MSGS_typ          rs_msg_len= 0,rs_umsg_len= 0,rs_amsg_len= 0;
  NUM_MSGS_typ          rs_num_msgs=0,rs_num_umsgs=0,rs_num_amsgs=0;
  MSG_typ             * msg_rs_ptr=NULL, *umsg_rs_ptr=NULL;
  MSG_typ             * amsg_rs_ptr=NULL;
  MSG_typ             * msg_rs=NULL, *umsg_rs=NULL, *amsg_rs=NULL;
  void                * handle= NULL, * handle_for_evnt= NULL;
  KWD_typ kwd_types=    {KWD_FOR_ADDINFO_1A_CHECK,
	                 KWD_FOR_ADDINFO_1A,
                         KWD_FOR_ADDINFO_1B_CHECK,
			 KWD_FOR_ADDINFO_1B,
                         0,0,
                         KWD_FOR_ADDINFO_2A_CHECK,
	                 KWD_FOR_ADDINFO_2A,
                         KWD_FOR_ADDINFO_2B_CHECK,
			 KWD_FOR_ADDINFO_2B};
  short                 actual_num= 0;
  short                 num_users_in= 0;
  short                 num_ugs_in;
  HAVE_MORE_typ         have_more= NO_MORE;
  int                   ii= 0,sw_upd= 0,sw_user= 0,from_num_ug= 0;
  RSSAPIPRM_rec_typ     apiprm;
  RSSAPIKWD_rec_typ   * bufk= NULL;
  ADDINFO_rec_typ     * info_ptr= NULL;
  USER_typ              usr_in [MAX_GET];
  USER_PARAMS_rec_typ   usr_prm;
  UG_typ                ug_in  [MAX_GET];
  OE_PARAMS_rec_typ     oe_prm;
  UG_PARAMS_rec_typ     ug_prm;
  U2UG_PARAMS_rec_typ   u2ug_data  [MAX_GET];
  OBJ_EXISTS_typ        obj_exist  [MAX_GET];
  ADDINFO_rec_ptr       addinfo    [MAX_GET];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  addinfo[0]= NULL;
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSPMPF, DIAG_COMMON, fn);
 
  rc=CS_db_prm_get (envir_ptr->msg_admin_param.rss_name,
                    FUNC_GTUG2UC ,
                    &apiprm);
  if (rc NE ESA_OK)
     goto cleanup;
  rc= CSA_alloc ((char **)&info_ptr,
                 STRUC_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ),        */
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ,
/*WS10082K*/     1,
                 fn,
                 "info");
  if (rc NE ESA_OK)
    goto cleanup;
  CLEAR (ug_in);
  CLEAR (usr_in);
  CLEAR_STRUCT (ug_prm);
  CLEAR_STRUCT (usr_prm);
  CLEAR (u2ug_data);
  CLEAR (obj_exist);
  CLEAR (addinfo);
 
  rc= CSA_alloc ((char **)&msg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "msg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_alloc ((char **)&amsg_rs_ptr,
                 0,
                 envir_ptr->max_msg_size,
                 1,
                 fn,
                 "amsg_rs_ptr");
  if (rc NE ESA_OK)
    goto cleanup;
 
  handle= NULL;
/*      Build addinfo for user conn. to user-group checksum */
  rc= CSA_alloc ((char **)&bufk,
                 0,
                 (sizeof(KWD_rec_typ) *
              envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds) +
                    sizeof(RSSAPIKWD_rec_typ),
                 1,
                 fn,
                 "Connections keywords");
  if (rc NE ESA_OK)
      goto cleanup;
  if ((rc= CS_db_key_get (envir_ptr->msg_admin_param.rss_name,
                          FUNC_ADDU2UG,
                          bufk)) NE ESA_OK)
    goto  cleanup;
 
  addinfo[0]= info_ptr;
  CS_fill_key(addinfo,
             bufk,
             kwd_types,
             1,
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                       apiprm.script_kwd_num);
 
  rc= CSA_alloc ((char **)addinfo,
                 STRUC_RES_ADDINFO,
/*WS10082K*      sizeof(ADDINFO_rec_typ) *        */
              (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                 MAX_GET,
                 fn,
                 "addinfo");
  if (rc NE ESA_OK)
    goto cleanup;
 
/* Build msg. header for added users */
 
  msg_rs= CS_reset_rs_msg(&rs_msg_len ,
                          &rs_num_msgs ,
                          msg_rs ,
                          msg_rs_ptr ,
                          msg_hdr,
                          MSG_UG2UC_ADD);
/* Build msg. header for add users */
 
  amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                           &rs_num_amsgs ,
                           amsg_rs ,
                           amsg_rs_ptr ,
                           msg_hdr,
                           MSG_USER_ADD);
 
/*  Get list of increment containers */
  for (from_num_ug= 0;
       from_num_ug LT ug_mem_num AND rc EQ ESA_OK;
       from_num_ug +=MAX_GET)
  {
 
     CLEAR (ug_in);
     rc= CS_dwnld_ugs_fill (ug_in, from_num_ug, &num_ugs_in,
                           ug_typ_ptr, ug_mem_num);
     for (have_more=HAVE_MORE;
          have_more EQ HAVE_MORE AND rc EQ ESA_OK;)
     {
       CLEAR (usr_in);
       CLEAR_STRUCT (ug_prm);
       CLEAR_STRUCT (usr_prm);
       CLEAR (u2ug_data);
       CLEAR (obj_exist);
       CS_addinfo_fill (
           info_ptr,
           addinfo,
           MAX_GET,
/*WS10082K*/ envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
/*WS10082K*/ apiprm.script_kwd_num);
/*WS10082K*  envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds);*/
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          goto cleanup;
 
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
       CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_GROUPS_CONNS, MAX_GET,
		num_ugs_in,num_users_in, ug_in, usr_in, handle, addinfo);
       rc=envir_ptr->func_ptr.gtug2uc_ptr(
           GET_GROUPS_CONNS, MAX_GET,
           &actual_num,
           &have_more, &handle, num_ugs_in,
           num_users_in, ug_in, usr_in,
           u2ug_data, addinfo, obj_exist,
           &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
			   rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
       if (rc EQ ESA_OK)
	      CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, actual_num, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
 
       rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
       if (apiprm.post EQ CS_YES)
       {
         rc_pst = CS_pre_post_u2ug (SCRIPT_POST , actual_num, u2ug_data,
                                    addinfo, NULL, &apiprm, rc,
									ESA_RC_UNDEFINED, obj_exist);
         if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_SKIP) ) {
           if (rc_pst EQ ESA_WARN) {
              CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_for_evnt,
                       MSG_POSTSCRIPT_WARN);
           }
           else {
              CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
              CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_for_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_data->group,
						   u2ug_data->user);
           }
         }
       } /* END - PosstScript is required */
       if (rc NE ESA_OK)
       {
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 11,
            "->gtug2uc: Fail get connections");
         goto cleanup;
       }
 
       ESA_DIAG_printf(ESA_COMP_ACSPMPF, 15,
                    "%s: actual_num=%d have_more=%d rc=%d",
                    fn, actual_num, have_more, (int)rc);
 
       for (ii= 0; ii LT actual_num AND rc EQ ESA_OK; ii++)
       {
         statist->u2ug_rss++;
         statist->tmp_num++;
         if (obj_exist[ii] EQ OBJ_NOT_EXIST)
		 {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_DETAILES,
               "Conn,user %s to group %s Not Exist",
			    u2ug_data[ii].user, u2ug_data[ii].group);
            statist->u2ug_not_exist++;
            continue;
		 }
         memcpy ((char *)usr_prm.user, (char *)u2ug_data[ii].user,
                 sizeof(USER_typ));
         memcpy ((char *)ug_prm.group, (char *)u2ug_data[ii].group,
                 sizeof(UG_typ));
         usr_prm.def_group[0] = '\0';
 
      /* If user in list of increment users */
         rc_usr= CARE_inc_usr_find (u2ug_data[ii].user,
                                    M_DWNLD_NAME_REGULAR);
      /* IF NOT -> SKIP the connections */
         if (rc_usr      NE ESA_OK)
		 {
            ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
           "Connection ug=%s to usr=%s def=%s is not interesting.",
                         u2ug_data[ii].group, u2ug_data[ii].user,
                         u2ug_data[ii].def_group);
            continue;
		 }
         statist->u2ug_add++;
         statist->u2ug_ess++;
 
         CS_dwnld_event (statist, STEP_U2UG, PROCESS_FN, rc);
 
         ESA_DIAG_printf (ESA_COMP_ACSPMPF, 15,
            "Connection ug=%s to usr=%s def ug=%s ADDED",
                       u2ug_data[ii].group, u2ug_data[ii].user,
                       u2ug_data[ii].def_group);
 
         msg_rs= CS_add_rs_msg (FUNC_ADDU2UG,&usr_prm,&oe_prm,&ug_prm,
                             &u2ug_data[ii], addinfo[ii],
                             &rs_msg_len, &rs_num_msgs,
                             msg_rs, msg_rs_ptr,
                             &rs_umsg_len, &rs_num_umsgs,
                             umsg_rs, umsg_rs_ptr,
                             &rs_amsg_len, &rs_num_amsgs,
                             amsg_rs, amsg_rs_ptr,
                             msg_hdr, &sw_user, &sw_upd,
                             &rc);
         if (rc NE ESA_OK)
           goto cleanup;
 
         if (msg_rs EQ NULL)
         {
            rc = ESA_FATAL;
            goto cleanup;
         }
         if (sw_user NE 0)
           amsg_rs= CS_reset_rs_msg(&rs_amsg_len ,
                                 &rs_num_amsgs ,
                                 amsg_rs ,
                                 amsg_rs_ptr ,
                                 msg_hdr,
                                 MSG_USER_ADD);
       }
     }
  }
  if (rs_num_amsgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_amsg_len ,
                         &rs_num_amsgs ,
                         amsg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  if (rs_num_msgs NE 0)
  {
    rc = CS_send_cd_msg (&rs_msg_len ,
                         &rs_num_msgs ,
                         msg_rs_ptr);
    if (rc NE ESA_OK)
      goto cleanup;
  }
  cleanup:
  if (rc EQ ESA_OK)
      rc= rc_logout;
  if (handle NE NULL)
  {
    ESA_RC rcc;
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
    CS_DIAG_UG2UC_IN (ESA_COMP_ACSPMPF, GET_FREE_HANDLE_CONNS, 0,
		0, 0, ug_in, usr_in, handle, addinfo);
    rcc= envir_ptr->func_ptr.gtug2uc_ptr (
                 GET_FREE_HANDLE_CONNS, MAX_GET,
                 &actual_num, &have_more,
                 &handle, MAX_GET, MAX_GET,ug_in,
                 usr_in, u2ug_data, addinfo, obj_exist,
                 &envir_ptr->msg_admin_param, &envir_ptr->msg_err);
    ESA_DIAG_printf (ESA_COMP_ACSPMPF, DIAG_BASIC,
			   "...<- gtug2uc_ptr: rc=%d (%s).",
		    	rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
    if (rcc EQ ESA_OK)
       CS_DIAG_UG2UC_OUT (ESA_COMP_ACSPMPF, 0, have_more,
			   u2ug_data, obj_exist, handle, addinfo);
  }
  CSA_free ((char **)&msg_rs_ptr);
  CSA_free ((char **)&amsg_rs_ptr);
  CSA_free ((char **)addinfo);
  CSA_free ((char **)&info_ptr);
  CSA_free ((char **)&bufk);
  CS_dwnld_event (statist, STEP_U2UG, END_FN, rc);
  if ( (rc NE ESA_OK) AND (rc NE ESA_ABORT_REQ) AND (rc NE ESA_NOT_SUPP) )
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSPMPF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* End of CS_dwnld_u2ug_oe_add */
 
