/*
 * Version Information:
 * ====================
 * File name       : %name: acssetf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: leonid_s %
 * Created on      : %date_created: Thu May 05 08:55:15 2005 %
 * Current Version : %version: 7 %
 * Last Modified by: %derived_by: leonid_s %
 * Last Modified on: %date_modified: Wed Feb 11 11:20:38 2004 %
 */
 
/*************************************************************
 * Mod.ID  Who      When        Description
 * ===========================================================
 * IMH001   Ian H.  19-Nov-03   WSAN101342 Thread-safe code (ERRNO)
 * SAS2IBMA AvnerL  21-Dec-16   SAS/C to IBM C Conversion Project
 * AC001    ArunC   12-Apr-17   CIQ#6-MF acct aggr with conns
 * SAS2IBMN NuritY  04-May-17   SAS/C to IBM C Conversion Project
 * protect  AvnerL  11-Jun-17   Support empty password
 * IS10166  KailasP 13-Feb-18   send connections in hotpath
 * WS10070  KailasP 21-Mar-18   send connections in hotpath
 *                              also get connection attributes
 *                              by setting get_conn 'P'
 * BS10100  KailasP 28-May-19   No need to print CTS1095E
 * WS10075  KailasP 23-Oct-19   Dont retrieve permissions attributes
 *                              for pre/post scripts
 * WS10079K KailasP 04-Jan-21   Set TYPE for each transaction and
 *                              call GET_FREE_HANDLE_GROUPS to free
 *                              handle for Role and Source
 * WS10079K KailasP 16-Feb-21   Add messages for Role and Source
 * WS10080  KailasP 27-Aug-21   Support MSGSIZE Greater than 32K
 * WS10081  ThomaS  21-Sep-21   Support MFA
 * IS10184  NuritY  01-Sep-21   Improve scripts performance
 *                              (compile only - new short names)
 * WS10082K KailasP 24-Jan-23   Addinfo related changes
 * IS10188  NuritY  25-Nov-24   diags are printed when not requested.
 ************************************************************/
 
#include "globs.h"
 
#include ERRNO
#include ESA_MSG
#include ESA_CS_DBPKG
#include ESA_CS_SINFO
#include ESA_OS_OFLI
#include ESA_OS_EVENT
#include ESA_CS_OS
#include ESA_RSS
#include ESA_RSSF
#include ESA_PROC
#include ESA_ADMIN
#include ESA_OS_OFLI
#include ESA_ESAADI
 
/* for MVS */
#include ESA_ESAADI   /*ws2394*/
 /* MVS */
 
static ESA_RC CS_queue_intercept_data (void);
 
/******************************************************
 * Procedure Name: CS_upload_ess_definitions
 * Description   : user sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function handles both RSS "SET" ("T") service and interesting
 * "Keywords" service ("K"). The function enters a loop that reads
 * messages from mailbox hand handles them. the loop is terminated when
 * the services is terminated (either by "End Service" message, by any
 * other message with "Last" indication, by service/process cancel
 * CONTROL message or due to error in the service handling). The first
 * message to be read - should be sent from the ESS in response to the
 * "Confirmation" message (sent by the calling function).
 * Upon receiving a legal message - the function activates a handler
 * function - according to the RSS OBJECT that is handled - Users,
 * Groups,Connection,Aces,Resources,Rss parameters & Rss Keywords.
 * On service termination, if the activated service was "Interesting
 * Keywords" update - the function distribute the event to all other
 * CS/CD servers.
 *****************************************************************/
 
ESA_RC CS_upload_ess_definitions (MSG_typ             * msg_ptr,
                                  RSS_MSG_HDR_rec_typ * msg_hdr_cd)
    {
      char fn[]="CS_upload_ess_definitions";
      ESA_RC                    rc= ESA_OK, rc_tmp= ESA_OK;
      RSS_MSG_HDR_rec_typ       msg_hdr;
      RSS_MSG_HDR_rec_typ       msg_hdr_sav;
      CSFLAG                    current_srv;
      TRAN_rec_typ              tran;
      CTSAMSG_MSGID_typ         func_msg_code;
      int                       sw_update_keys, sw_update_admin;
      FILE                    * file_handle= NULL;
      unsigned short            kk= 0;
      OS_pid_str_typ            pid;
      DATE_STR_typ              date_buffer="";
      TIME_STR_typ              time_buffer="";
      LOGENT_typ                logevt_str;
      ENVIRONMENT_rec_typ     * envir_ptr;
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
      /*
        PRINT the allocatioin table - for diagnostics.
      */
      CSA_print_alloc_tbl (ESA_COMP_ACSSETF, fn, FALSE);
      /*
        SAVE message's header.
      */
      memcpy ((char *)(&msg_hdr_sav), (char *)msg_hdr_cd,
              sizeof( RSS_MSG_HDR_rec_typ));
 
      current_srv =CSON;
      rc = ESA_OK;
      sw_update_keys= 0;
      sw_update_admin= 0;
      /*
        PROCESS all current service's messages.
      */
      while (current_srv EQ CSON) {
 
        CLEAR(msg_ptr);
 
        /*
          READ next message from MAILBOX (It is CS!)
        */
        rc= CS_get_next_msg (msg_ptr, & msg_hdr);
 
        memcpy ((char *)(&msg_hdr_sav), (char *)(&msg_hdr),
                sizeof( RSS_MSG_HDR_rec_typ));
        memcpy (envir_ptr->siid, msg_hdr.mhsiid, sizeof (MH_siid));
        envir_ptr->siid[sizeof (MH_siid)]= '\0';
        if (rc NE ESA_OK )
          goto cleanup;
 
        /*
          PROCESS message according to the RSS OBJECT it handles:
        */
        /*
          PROCESS all USER requests - add,update,delete,revoke,
          restore,update-password.
        */
        else if (COND(MSG_USER_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add user transaction", MSG_USER_ADD);
          strcpy (func_msg_code, MSG_USR_ADD_RSLT);
          rc=CS_user_set(msg_ptr,
                         &msg_hdr,
                         &tran,
                         FUNC_ADDUSER,
                         func_msg_code);
        }
        else if (COND(MSG_USER_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update user transaction", MSG_USER_UPD);
          strcpy (func_msg_code, MSG_USR_UPD_RSLT);
          rc=CS_user_set(msg_ptr,
                         &msg_hdr,
                         &tran,
                         FUNC_UPDUSER,
                         func_msg_code);
        }
        else if (COND(MSG_USER_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete user transaction", MSG_USER_DEL);
          strcpy (func_msg_code, MSG_USR_DEL_RSLT);
          rc=CS_user_set(msg_ptr,
                         &msg_hdr,
                         &tran,
                         FUNC_DELUSER ,
                         func_msg_code);
        }
        else if (COND(MSG_USER_REVOKE)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Revoke user transaction", MSG_USER_REVOKE);
          strcpy (func_msg_code, MSG_USR_REV_RSLT);
          rc=CS_user_set(msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_REVUSER ,
                         func_msg_code);
        }
        else if (COND(MSG_PASSWRD_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Password Update transaction", MSG_PASSWRD_UPD);
          strcpy (func_msg_code, MSG_PSW_UPD_RSLT);
          rc=CS_user_set(msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_UPD_PASS ,
                         func_msg_code);
        }
 
        /*
          PROCESS all Container requests - add,update,delete.
        */
 
        else if (COND(MSG_OE_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add container transaction", MSG_OE_ADD);
          strcpy (func_msg_code, MSG_OE_ADD_RSLT);
          rc=CS_oe_set(msg_ptr ,
                       &msg_hdr ,
                       &tran ,
                       FUNC_ADDOE ,
                       func_msg_code);
        }
        else if (COND(MSG_OE_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update container transaction", MSG_OE_UPD);
          strcpy (func_msg_code, MSG_OE_UPD_RSLT);
          rc=CS_oe_set(msg_ptr ,
                       &msg_hdr ,
                       &tran ,
                       FUNC_UPDOE ,
                       func_msg_code);
        }
        else if (COND(MSG_OE_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete container transaction", MSG_OE_DEL);
          strcpy (func_msg_code, MSG_OE_DEL_RSLT);
          rc=CS_oe_set(msg_ptr ,
                       &msg_hdr ,
                       &tran ,
                       FUNC_DELOE ,
                       func_msg_code);
        }
 
 
        /*
          PROCESS all user GROUP requests - add,update,delete.
        */
 
        else if (COND(MSG_UG_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add user group transaction", MSG_UG_ADD);
          strcpy (func_msg_code, MSG_GRP_ADD_RSLT);
          rc=CS_ug_set(msg_ptr ,
                       &msg_hdr ,
                       &tran ,
                       FUNC_ADDUG ,
                       func_msg_code);
        }
        else if (COND(MSG_UG_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update user group transaction", MSG_UG_UPD);
          strcpy (func_msg_code, MSG_GRP_UPD_RSLT);
          rc=CS_ug_set(msg_ptr ,
                       &msg_hdr ,
                       &tran ,
                       FUNC_UPDUG ,
                       func_msg_code);
        }
        else if (COND(MSG_UG_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete user group transaction", MSG_UG_DEL);
          strcpy (func_msg_code, MSG_GRP_DEL_RSLT);
          rc=CS_ug_set(msg_ptr ,
                       &msg_hdr ,
                       &tran ,
                       FUNC_DELUG ,
                       func_msg_code);
        }
 
        /*
          PROCESS all USER to user GROUP requests - add,update,delete.
        */
 
        else if (COND(MSG_UG2UC_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add user to group connection transaction", MSG_UG2UC_ADD);
          strcpy (func_msg_code, MSG_U2UG_ADD_RSLT);
          rc=CS_u2ug_set(msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_ADDU2UG ,
                         func_msg_code);
        }
        else if (COND(MSG_UG2UC_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update user to group connection transaction", MSG_UG2UC_UPD);
          strcpy (func_msg_code, MSG_U2UG_UPD_RSLT);
          rc=CS_u2ug_set(msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_UPDU2UG ,
                         func_msg_code);
        }
        else if (COND(MSG_UG2UC_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete user to group connection transaction", MSG_UG2UC_DEL);
          strcpy (func_msg_code, MSG_U2UG_DEL_RSLT);
          rc=CS_u2ug_set(msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_DELU2UG ,
                         func_msg_code);
        }
        /*
          PROCESS all ACE requests - add,update,delete.
        */
 
        else if (COND(MSG_ACE_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add ACE transaction", MSG_ACE_ADD);
          strcpy (func_msg_code, MSG_ACE_ADD_RSLT);
           rc=CS_ace_set(msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_ADDACE ,
                         func_msg_code);
        }
        else if (COND(MSG_ACE_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update ACE transaction", MSG_ACE_UPD);
          strcpy (func_msg_code, MSG_ACE_UPD_RSLT);
          rc=CS_ace_set(msg_ptr ,
                        &msg_hdr ,
                        &tran ,
                        FUNC_UPDACE ,
                        func_msg_code);
        }
        else if (COND(MSG_ACE_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete ACE transaction", MSG_ACE_DEL);
          strcpy (func_msg_code, MSG_ACE_DEL_RSLT);
          rc=CS_ace_set(msg_ptr ,
                        &msg_hdr ,
                        &tran ,
                        FUNC_DELACE ,
                        func_msg_code);
        }
        /*
          PROCESS update RESOURCE requests.
        */
 
        else if (COND(MSG_RES_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add Resource transaction", MSG_RES_ADD);
          strcpy (func_msg_code, MSG_RES_ADD_RSLT);
          rc=CS_res_set(msg_ptr ,
                        &msg_hdr ,
                        &tran ,
                        FUNC_ADDRES ,
                        func_msg_code);
        }
        else if (COND(MSG_RES_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete Resource transaction", MSG_RES_DEL);
          strcpy (func_msg_code, MSG_RES_DEL_RSLT);
          rc=CS_res_set(msg_ptr ,
                        &msg_hdr ,
                        &tran ,
                        FUNC_DELRES ,
                        func_msg_code);
        }
        else if (COND(MSG_RES_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update Resource transaction", MSG_RES_UPD);
          strcpy (func_msg_code, MSG_RES_UPD_RSLT);
          rc=CS_res_set(msg_ptr ,
                        &msg_hdr ,
                        &tran ,
                        FUNC_UPDRES ,
                        func_msg_code);
        }
        /*
          PROCESS update RSS parameters requests.
        */
 
        else if (COND(MSG_RSPRM_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update RSS parameters transaction", MSG_RSPRM_UPD);
          strcpy (func_msg_code, MSG_UPD_RSS_PRM_RSLT);
          rc=CS_rssprm_set(msg_ptr ,
                           &msg_hdr ,
                           &tran ,
                           FUNC_STRSPRM,
                           func_msg_code);
        }
        /*
          PROCESS update ctrl/sa interesting KEYWORDS requests.
        */
 
        else if (COND(MSG_RSSAPIKWD_ADD))
        {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update RSS-API keywords transaction", MSG_RSSAPIKWD_ADD);
           if (sw_update_keys EQ 0)
           {
              for (kk= 0; kk LT envir_ptr->max_rss_num; kk++) {
                 envir_ptr->interest[kk].rc= CSA_lock (
	    			 envir_ptr->interest[kk].file_ofli_semaphore,
		    		 fn, SCOPE_LOCAL);
			  }
              rc= CSA_open (envir_ptr->file_rsskwds, fn,
                            FILE_CREAT, &file_handle, SCOPE_LOCAL);
              if (rc EQ ESA_OK)
                 if (fputs(FILE_NOTE_LINE, file_handle) EQ EOF)
                 {
                    CTSAMSG_print (ERR_FILE,
                      envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                      envir_ptr->msg_admin_param.ctsamsg_dest,
                      "write", fn,
                      envir_ptr->file_rsskwds, strerror(errno));
                    rc= ESA_ERR;
                 }
 
              CSA_close (envir_ptr->file_rsskwds, fn);
 
              if (rc EQ ESA_OK)
                 rc= rssapikwd_load ();
           }
           rc=CS_ctsa_keys (msg_ptr ,
                            &msg_hdr ,
                            &tran ,
                            FUNC_RSSKWD);
           if (rc EQ ESA_OK)
               sw_update_keys= 1;
 
		}
        /*
          PROCESS all Administrator requests - add,update,delete.
        */
        /*WS10082A RSSADM is not used in MF but Update Admin is */
        else if (COND(MSG_ADMIN_ADD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Add IIQ/IDN Administrator transaction", MSG_ADMIN_ADD);
          strcpy (func_msg_code, MSG_ADMIN_ADD_RSLT);
          rc=CS_adm_set (msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_ADDADMIN ,
                         func_msg_code);
          if (rc EQ ESA_OK)
             sw_update_admin= 1;
        }
        else if (COND(MSG_ADMIN_UPD)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Update IIQ/IDN Administrator transaction", MSG_ADMIN_UPD);
          strcpy (func_msg_code, MSG_ADMIN_UPD_RSLT);
          rc=CS_adm_set (msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_UPDADMIN ,
                         func_msg_code);
          if (rc EQ ESA_OK)
             sw_update_admin= 1;
        }
        /*WS10082A Delete Admin is not expected
        else if (COND(MSG_ADMIN_DEL)) {
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Delete IIQ/IDN Administrator transaction", MSG_ADMIN_DEL);
          strcpy (func_msg_code, MSG_ADMIN_DEL_RSLT);
          rc=CS_adm_set (msg_ptr ,
                         &msg_hdr ,
                         &tran ,
                         FUNC_DELADMIN ,
                         func_msg_code);
        }
        *** end of WS10082A ***/
        /*
          PROCESS "End of service" message.
        */
 
        else if (COND(END_OF_SERVICE)) {
          /*
            SET the service termination indicator.
          */
       	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... %s - Accepted end of transaction from IIQ/IDN", END_OF_SERVICE);
          current_srv = CSOFF;
 
        }
        /*
          PROCESS undefined service
        */
        else {
          CTSAMSG_print (ERR_CS_UNDEF_MSG_TYP,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn,
                         &msg_hdr.mhmtyp);
          rc = ESA_FATAL;
          goto cleanup;
        }
 
        /*
         PROCESS when the RSS object function returned - process
         termination request:
        */
        if (rc EQ ESA_TERM_CTSA)
          /*
            SET the service termination indicator.
          */
          current_srv = CSOFF;
 
        /*
          EXIT if error occurred in called function.
        */
        else if (rc NE ESA_OK) {
          goto cleanup;
        }
 
        /*
          PROCESS a last message indication (it is handled the same as
          end of service):
        */
        else if (msg_hdr.mhltl EQ MH_MESSAGE_LAST)
          /*
            SET the service termination indicator.
          */
          current_srv = CSOFF;
 
      }
 
      cleanup:
 
      /*
        PROCESS when interesting keywords were update:
      */
      if (sw_update_keys)
      {
          ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,"sw_update_keys.");
          rc= CS_broadcast (CS_BRDCT_EVNT_KWDS,
                            EVENT_KEYWORDS_CHANGED);
 
          for (kk= 0; kk LT envir_ptr->max_rss_num; kk++)
          {
              if (envir_ptr->interest[kk].UpdChecksumKwd GT 0)
              {
                 envir_ptr->interest[kk].UpdChecksumKwd= 0;
                 ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_OS,
                                  "...-> OS_PROC_get_pid: hndl=%p.",
                                  envir_ptr->os_proc_handle);
                 rc_tmp= OS_PROC_get_pid (pid, envir_ptr->os_proc_handle);
                 if (rc_tmp NE ESA_OK)
                    strcpy (pid , "????");
                 ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_OS,
                             "...<- OS_PROC_get_pid: rc_tmp=%d (%s) pid=%.*s.",
                             rc_tmp, (rc_tmp EQ ESA_OK) ? "OS==OK" : "OS##OK",
                             sizeof (OS_pid_str_typ), pid);
                 rc = CTSAMSG_print (MSG_KWD_GET_RSLT,
                                     envir_ptr->msg_admin_param.ctsamsg_handle,
                                     logevt_str , NULL ,
                                     envir_ptr->interest[kk].rss,
                                     envir_ptr->msg_admin_param.admin_uname,
                 envir_ptr->msg_admin_param.admin_gname,
                 envir_ptr->siid);
                 RSLogAlert (envir_ptr->interest[kk].rss_type,
                          envir_ptr->interest[kk].rss,
                          NULL,
                          &envir_ptr->msg_params,
                          date_buffer,
                          time_buffer,
                          envir_ptr->host_name,
                          pid,
                          CG_main_name (envir_ptr->p_main_name),
                          REGULARALERT,
                          OPT_TRUE,
                          logevt_str);
              }
              if (envir_ptr->interest[kk].rc EQ ESA_OK)
		      CSA_unlock (envir_ptr->interest[kk].file_ofli_semaphore,
			              fn);
              if (envir_ptr->interest[kk].rc EQ ESA_TERM_CTSA)
                  rc= ESA_TERM_CTSA;
              envir_ptr->interest[kk].rc= ESA_OK;  		
          }
 
      }     /* sw_update_keys */
 
      if (sw_update_admin)
      {
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,"sw_update_admin.");
        rc= CS_broadcast (CS_BRDCT_EVNT_ADMIN,
                          EVENT_ADMIN_CHANGED);
      }
 
      CSA_print_alloc_tbl (ESA_COMP_ACSSETF, fn, FALSE);
 
      if (rc EQ ESA_CANCEL_SERVICE)
        CTSAMSG_print (ERR_CS_SERVICE_CANCEL,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       fn);
      /*
        PROCESS when an error occured in service:
      */
      if ((rc NE ESA_OK) AND
          (rc NE ESA_TERM_CTSA)AND
          (rc NE ESA_CANCEL_SERVICE))
        CTSAMSG_print (ERR_CS_SERVICE,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       fn, envir_ptr->msg_ptr);
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
 
      return(rc);
 
    } /* END -  CS_upload_ess_definitions function */
 
/****************************************************
 * Procedure Name: CS_user_set
 * Description   : User sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function that takes care of all user SET
 * requestes that includes the following:
 * - Add new user
 * - Delete an existing user.
 * - Update user's details.
 * - Revoke/Restore user.
 * - Modify user's password.
 * The function receives a message with the "set" details that may
 * include several set user requests. It scans the input buffer after
 * all requests, analyses each request details - retrieving the user's
 * details into the user parameters structure, activate the PreScript
 * (if needed) the API (if needed) and PostScript (if needed),
 * Retrieves the new user's details - in case HOT PATH is required,
 * prepares and sends a respons message back to the ESS.
 *****************************************************************/
 
ESA_RC  CS_user_set (MSG_typ               *  msg_ptr ,
                     RSS_MSG_HDR_rec_typ   *  msg_hdr ,
                     TRAN_rec_typ          *  tran,
                     short                    func_name,
                     CTSAMSG_MSGID_typ        func_msg_code)
{
      char fn[]="CS_user_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ADDINFO_rec_typ     * addinfo1= NULL, *addinfo2= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
/*WS10082K* ESA_RC          rc, rc_find= ESA_OK;                 */
      ESA_RC                rc;                        /*WS10082K*/
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      OE_PARAMS_rec_typ     oe_prm;
      UG_PARAMS_rec_typ     ug_prm;
      USER_PARAMS_rec_typ   usr_prm, usr_pre_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIPRM_rec_typ     apiprm;
      RES_PARAMS_rec_typ    res_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      char                  exists[26];
      OBJ_EXISTS_typ        obj_exist;
      ENVIRONMENT_rec_typ * envir_ptr;
      ONE_FIELD_rec_ptr     cpair = NULL, cpair2= NULL;
      MEMBER_ADM_rec_typ    find_adm_rec;
	  int                   OldRenameMove= FALSE;
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
 
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      msg_cd      = NULL;
      addinfo1    = NULL;
      addinfo2    = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
        rc= ESA_ERR;
        goto cleanup;
      }
      /*
        RETRIEVE the current function pre/actual/post scripts
        parameters from RSSAPI parameters file.
      */
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name,
                          &apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ALLOCATE memory for additional info.
      */
      rc= CSA_alloc ((char **)&addinfo1, STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *      */
               (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo1");
      if (rc NE ESA_OK)
        goto cleanup;
 
      if ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES)) {
        rc= CSA_alloc ((char **)&addinfo2, STRUC_ADDINFO,
/*WS10082K*             sizeof(ADDINFO_rec_typ) *        */
                envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds,
                        1,
                        fn,
                        "addinfo2");
        if (rc NE ESA_OK)
           goto cleanup;
/*WS10082K - Start */
/*          memset((char *)addinfo2, NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds *
                   sizeof(ADDINFO_rec_typ));
        addinfo2->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds;  */
/*WS10082K - End */
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
 
      set_addinfo[0] = addinfo1;
      get_addinfo[0] = addinfo2;
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr ,
                             msg_hdr);
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
        /*
          INITIALIZE the pre/actual/post scripts statuses and error
          buffers.
        */
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(usr_prm);
        CLEAR_STRUCT(oe_prm);
        CLEAR_STRUCT(ug_prm);
        CLEAR_STRUCT(u2ug_prm);
 
/*WS10082K* memset((char *)addinfo1,
               NULL_CHAR ,
               (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                apiprm.script_kwd_num) *
                   sizeof(ADDINFO_rec_typ));   */
        /* WS10082N addinfo1->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                                  apiprm.script_kwd_num;   */
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg, tran , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          ANALYZE the "USER" structure from message.
        */
        msg_ptr = CS_get_user (&usr_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
     	ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
           "*****>... Set for user=%s", usr_prm.user);
        if (strcmp (func_msg_code, MSG_USR_REV_RSLT) == 0)
        {
		   if (usr_prm.rev_status EQ USER_STAT_ACTIVE)
			   strcpy (func_msg_code, MSG_USR_RES_RSLT);
		}
        CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       usr_prm.user,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        /*
          PREPARE - additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo1 ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          PROCESS when pre-script should be activated:
        */
        if ( apiprm.pre EQ CS_YES ) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set user.");
          if (func_name  NE FUNC_ADDUSER)
          {
              memcpy((char *)&usr_pre_prm,
                     (char *)&usr_prm,
                     sizeof (USER_PARAMS_rec_typ));
              rc= CS_pre_post_info_for_obj (
                     envir_ptr->msg_admin_param.rss_name,
                     FUNC_ADDUSER,
                     &usr_pre_prm,
                     get_addinfo,
                     NULL,
                     HOT_PATH_OFF);
 
          }
          ERROR_CLEAR(err_msg);
 
          rc_pre= CS_pre_post_users (SCRIPT_PRE ,1, &usr_prm,
			                         set_addinfo, get_addinfo, &apiprm,
									 rc_act, rc_pre, &obj_exist);
          if (rc_pre EQ ESA_OK)
             CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
          ERROR_COPY(&err_pre,err_msg);
          ERROR_CLEAR(err_msg);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
        */
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES)) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set user.");
          /*
            ACTIVATE the relevant ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF , 13 ,
              "User %s: pwd_life=%d.admin=%d.rev_st=%d.ug_act=%d.",
              usr_prm.user,
              (int)usr_prm.passwd_life,
              (int)usr_prm.user_admin,
              (int)usr_prm.rev_status,
              (int)usr_prm.def_ug_action);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
			"    -> Set for user %s.", usr_prm.user);
          CS_DIAG_USER (ESA_COMP_ACSSETF, 1,&usr_prm,
				            &addinfo1, NULL, 0, TRUE);
          /*WS10082A RSSADM file is not used in MF
          rc_find= ADM_find (envir_ptr->msg_admin_param.rss_name,
                             usr_prm.user, &find_adm_rec);
		  if (rc_find EQ ESA_OK)
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "User %s is an administrator.",
                usr_prm.user);
    end of WS10082A *********/
		  cpair= ADDINFO_search ("77NewName", (int)strlen ("77NewName"),
                                 addinfo1->pair, addinfo1->num_pairs);
          if ( (cpair) AND (strlen ((char *)cpair->value) GT 0) )
		  {
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "RENAME: User %s renamed to %s.",
                usr_prm.user, (char *)cpair->value);
		     OldRenameMove= TRUE;
		  }
		  cpair2= ADDINFO_search ("77NewOEName", (int)strlen ("77NewOEName"),
                                  addinfo1->pair, addinfo1->num_pairs);
          if ( (cpair2) AND (strlen ((char *)cpair2->value) GT 0) )
		  {
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "MOVE: User %s %s moved to %s %s.",
                usr_prm.user, usr_prm.parent_oe,
				(cpair) ? (char *)cpair->value : usr_prm.user, cpair2->value);
             OldRenameMove= TRUE;
		  }
          rc= ESA_OK;
          switch (func_name) {
            case FUNC_ADDUSER:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSAddUser USA-API.");
              rc_act = envir_ptr->func_ptr.adduser_ptr(
                                     &usr_prm,
                                     addinfo1,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
              break;
 
            case FUNC_UPDUSER:
/*WS10082K* if ( (rc_find EQ ESA_OK) AND (OldRenameMove EQ TRUE) ) */
/*WS10082K*/  if ((strcmp(envir_ptr->msg_admin_param.admin_uname,
/*WS10082K*/                 usr_prm.user) EQ 0)
/*WS10082K*/              AND (OldRenameMove EQ TRUE) )
			  {
                 /* SAS2IBMN - start */
                 /* MSG_printf (ERR_ADM_CHG_BY_ADM_TRAN,
                    usr_prm.user, envir_ptr->msg_admin_param.rss_name);
                 */
                 CTSAMSG_print (ERR_ADM_CHG_BY_ADM_TRAN,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           usr_prm.user,
                           envir_ptr->msg_admin_param.rss_name);
                 /* SAS2IBMN - end   */
                 rc= ESA_ERR;
                 goto cleanup;
			  }
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdUser USA-API.");
              rc_act = envir_ptr->func_ptr.upduser_ptr(
                                     &usr_prm,
                                     addinfo1,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
/* for MVS */
if (strcmp(envir_ptr->msg_admin_param.rss_type,RACF_RSS_TYPE) EQ 0)
cpair = ADDINFO_search ( "AUTHORITY", RCF_ADDINFO_KWD_LEN,
                          addinfo1->pair,
                          addinfo1->num_pairs );
if (cpair NE NULL)  envir_ptr->hot_path =  HOT_PATH_FULL;
 /* MVS */
              break;
 
             case FUNC_DELUSER:
/*WS10082K*   if (rc_find EQ ESA_OK)            */
/*WS10082K*/  if (strcmp(envir_ptr->msg_admin_param.admin_uname,
/*WS10082K*/                 usr_prm.user) EQ 0)
			  {
                 /* SAS2IBMN - start */
                 /* MSG_printf (ERR_ADM_CHG_BY_ADM_TRAN,
                    usr_prm.user, envir_ptr->msg_admin_param.rss_name);
                 */
                 CTSAMSG_print (ERR_ADM_CHG_BY_ADM_TRAN,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           usr_prm.user,
                           envir_ptr->msg_admin_param.rss_name);
                 /* SAS2IBMN - end   */
                 rc= ESA_ERR;
                 goto cleanup;
			  }
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSDelUser USA-API.");
              rc_act = envir_ptr->func_ptr.deluser_ptr(
                                     &usr_prm,
                                     addinfo1,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
              break;
 
            case FUNC_REVUSER:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSRevokeUser USA-API.");
              rc_act = envir_ptr->func_ptr.revuser_ptr(
                                     &usr_prm,
                                     addinfo1,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
              break;
 
             case FUNC_UPD_PASS:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdPassword USA-API.");
              rc_act = envir_ptr->func_ptr.updpass_ptr(
                                     &usr_prm,
                                     addinfo1,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
              break;
 
          }
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    <- SETuser completed with rc=%d (%s).",
		      rc_act,(rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          if (rc_act EQ ESA_OK)
             CS_DIAG_USER (ESA_COMP_ACSSETF, 1,&usr_prm,
				            &addinfo1, NULL, 0, TRUE);
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
          {
		     ESA_DIAG_printf (ESA_COMP_ACSSETF , 20 ,
				"API action failed, rc_act=%d",rc_act);
		     CTSAMSG_print (MSG_ACTUAL_FAIL,
				envir_ptr->msg_admin_param.ctsamsg_handle,
				NULL,
				envir_ptr->msg_admin_param.ctsamsg_dest,
				ESA_rc2str(rc_act));
		  }
          ERROR_COPY(&err_act,err_msg);
          ERROR_CLEAR(err_msg);
 
        } /* END - actual activation required */
 
        /*
          PROCESS when post-script activation is required:
        */
        if (apiprm.post EQ CS_YES) {
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set user.");
          memcpy((char *)&usr_pre_prm,
                  (char *)&usr_prm,
                  sizeof (USER_PARAMS_rec_typ));
          rc= CS_pre_post_info_for_obj (
                  envir_ptr->msg_admin_param.rss_name,
                  FUNC_ADDUSER,
                  &usr_pre_prm,
                  get_addinfo,
                  NULL,
                  HOT_PATH_OFF);
          rc_pst = CS_pre_post_users(SCRIPT_POST, 1,
                      &usr_prm, set_addinfo, get_addinfo,
                      &apiprm, rc_act, rc_pre, &obj_exist);
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst NE ESA_SKIP) {
             CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                            envir_ptr->msg_admin_param.ctsamsg_handle,
                            NULL,
                            envir_ptr->msg_admin_param.ctsamsg_dest,
                            fn, ESA_rc2str(rc_pst), usr_prm.user);
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                          envir_ptr->msg_admin_param.rss_name,
                          NULL,
                          MSG_USR_POSTSCRIPT_FAIL,
                          fn, ESA_rc2str(rc_pst), usr_prm.user);
		  }
          ERROR_COPY(&err_pst,err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
        } /* END - post-script activation required */
        /*WS10082A RSSADM file is not used in MF
        /* Add new password to RSSADM if or USA-API preformed successfully
		                                 or and Pre and Post script don't failed *@
        if (
			  (strlen (usr_prm.passwd) NE 0)
             AND
			  (usr_prm.passwd[0] NE BACKSLASH)
             AND
			  (
                 (rc_act EQ ESA_OK)
                OR
                 (
			         (apiprm.act NE CS_YES)
                    AND
                     ( (apiprm.post EQ CS_YES) OR (apiprm.pre EQ CS_YES) )
                    AND
                     ( (rc_pre EQ ESA_OK) OR (rc_pre EQ ESA_RC_UNDEFINED) )
                    AND
                     ( (rc_pst EQ ESA_OK) OR (rc_pst EQ ESA_RC_UNDEFINED) )
                 )
              )
		   )
		{
 
           rc= ADM_admin_data_sync  (usr_prm.user,
                                     usr_prm.passwd);
           if (rc EQ ESA_OK)
           {
               rc= CS_broadcast (CS_BRDCT_EVNT_ADMIN,
                                 EVENT_ADMIN_CHANGED);
               if (rc NE ESA_OK)
                  goto cleanup;
           }
           else
               rc= ESA_OK;
        }
        end of WS10082A ******************/
        /*
          PROCESS when HOST PATH is required:
        */
        if ((envir_ptr->hot_path EQ HOT_PATH_ON) OR
            (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
 
          ERROR_CLEAR(err_msg);
          /*
            ACTIVATE user's hot_path function (retrieve user details).
          */
          rc = CS_pre_post_info_for_obj (
                       envir_ptr->msg_admin_param.rss_name,
                       FUNC_ADDUSER,
                       &usr_prm,
                       set_addinfo,
                       NULL,
                       HOT_PATH_ON);
 
          if ((rc EQ ESA_OK) OR (rc EQ ESA_KEY_NOT_FOUND))
             envir_ptr->func_ptr.trnsevnt_ptr (
                              INTERCEPT_USER ,
                              envir_ptr->empty_oe ,
                              usr_prm.user,
                              envir_ptr->empty_ug,
                              (envir_ptr->hot_path EQ HOT_PATH_FULL) ?
                                    UPDCONN_YES
                                    :
                                    UPDCONN_NO,
                              &envir_ptr->msg_admin_param,
                              &envir_ptr->msg_err);
          CLEAR(exists);
          if (rc EQ ESA_KEY_NOT_FOUND)
             strcpy (exists,ENTITY_NOT_FOUND);
          else if (rc EQ ESA_SKIP)
             strcpy (exists,ENTITY_ERR);
          else
             strcpy (exists,ENTITY_FOUND);
        }
 
        else strcpy (exists,ENTITY_UNKNOWN);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          ADD current respond buffer to respond message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                addinfo1,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg_cd EQ NULL) {
          rc = ESA_FATAL;
          goto cleanup;
        }
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal message requests */
 
      if ((rc EQ ESA_OK)                      AND
          (num_msgs EQ 1)                     AND
          (strcmp (exists,ENTITY_FOUND) EQ 0) AND
          (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
        /*
         SET not last (and not temporary last) message type to respond.
        */
          CS_set_not_last_msg(msg_cd_ptr);
      }
      else
        /*
          SET "Temporary Last" message indicator in message header.
        */
          CS_set_tmp_last_msg(msg_cd_ptr);
 
      /*
        TRANSLATE function name to function code in respond message
        buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                       envir_ptr->msg_admin_param.ctsamsg_handle,
                       NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest, fn);
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo1);
      CSA_free ((char **)&addinfo2);
 
      if (((rc EQ ESA_OK) OR
           (rc EQ ESA_TERM_CTSA) OR
           (rc EQ ESA_CANCEL_SERVICE))        AND
          (num_msgs EQ 1)                     AND
          (strcmp (exists,ENTITY_FOUND) EQ 0) AND
          (envir_ptr->hot_path EQ HOT_PATH_FULL))  {
         char             ug[1] = {'\0'};
 
         CS_send_ug2uc_msg (msg_hdr,
                            tran,
                            ug,
                            (char *)usr_prm.user);
      }
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
    } /* END - CS_user_set function */
 
/****************************************************
 * Procedure Name: CS_ug_set
 * Description   : user group sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function the takes care of all group SET
 * requestes that includes the following:
 * - Add new user group
 * - Delete an existing user group.
 * - Update user group's details.
 * The function receives a message with the "set" details that may
 * include several set group requests. It scans the input buffer after
 * all requests, analyses each request details - retrieving the group's
 * details into the group parameters structure, activate the PreScript
 * (if needed) the API (if needed) and PostScript (if needed),
 * Retrieves the new group's details - in case HOT PATH is required,
 * prepares and sends a respons message back to the ESS.
 *****************************************************************/
 
ESA_RC  CS_ug_set (MSG_typ               *  msg_ptr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr,
                   TRAN_rec_typ          *  tran,
                   short                    func_name,
                   CTSAMSG_MSGID_typ        func_msg_code)
{
      char fn[]="CS_ug_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ADDINFO_rec_typ     * addinfo1= NULL, * addinfo2= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
      ESA_RC                rc;
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      OE_PARAMS_rec_typ     oe_prm;
      UG_PARAMS_rec_typ     ug_prm, ug_pre_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIPRM_rec_typ     apiprm;
      RES_PARAMS_rec_typ    res_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      char                  exists[26];
      OBJ_EXISTS_typ        obj_exist;
      ENVIRONMENT_rec_typ * envir_ptr;
      int                   num_kwds = 0;            /*WS10079K*/
      char                * ptr = NULL, msg[15];     /*WS10079K*/
      short                 func_name_internal;      /*WS10079K*/
 
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      addinfo1    = NULL;
      addinfo2    = NULL;
      msg_cd      = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
      }
      /* WS10079K - Start
      /* We do not want to call CS_db_prm_get for Role and Sources *
      /@
        RETRIEVE the current function pre/actual/post scripts
        parameters from RSSAPI parameters file.
      @/
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name,
                          &apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
 
      */
      /* Check if the message contains 1A04TYPE0004Role *
         or 1A04TYPE0006Source and set num_kwds and     *
         func_name_internal accordingly                 */
      func_name_internal = FUNC_ADDUG;
      /* WS10080 - Start */
      if(envir_ptr->addinfo_val_len EQ 5)
         ptr = strstr(msg_ptr,"1A04TYPE00004Role");
      else
         ptr = strstr(msg_ptr,"1A04TYPE0004Role"); /*Indentation*/
      /* WS10080 - End */
      if(ptr NE NULL)
      {
        /* The transaction is for Role */
        num_kwds =
            envir_ptr->interest[envir_ptr->rss_num].num_xrol_kwds;
        apiprm.script_kwd_num = 0;
        apiprm.pre = CS_NO;
        apiprm.post = CS_NO;
        apiprm.act  = CS_YES;
 
        func_name_internal = FUNC_ADDXROL;
        strcpy (func_msg_code, MSG_ENTY_OPR_RSLT);
        if( func_name EQ FUNC_ADDUG)
          strcpy(msg,"Add Role");
        else
        {
          if(func_name EQ FUNC_UPDUG)
            strcpy(msg, "Update Role");
          else
            strcpy(msg, "Delete Role");
        }
      }
      else
      {
         /* WS10080 - Start */
         if(envir_ptr->addinfo_val_len EQ 5)
            ptr = strstr(msg_ptr,"1A04TYPE00006Source");
         else
            ptr = strstr(msg_ptr,"1A04TYPE0006Source"); /*Indentation*/
         /* WS10080 - End */
         if(ptr NE NULL)
         {
            /* The transaction is for Source */
            num_kwds =
                envir_ptr->interest[envir_ptr->rss_num].num_xsgp_kwds;
            apiprm.script_kwd_num = 0;
            apiprm.pre = CS_NO;
            apiprm.post = CS_NO;
            apiprm.act  = CS_YES;
 
            func_name_internal = FUNC_ADDXSGP;
            strcpy(msg,"Source");
            strcpy (func_msg_code, MSG_ENTY_OPR_RSLT);
            if(func_name EQ FUNC_ADDUG)
              strcpy(msg,"Add Source");
            else
            {
              if(func_name EQ FUNC_UPDUG)
                strcpy(msg, "Update Source");
              else
                strcpy(msg, "Delete Source");
            }
         }
         else
         {
            /* The transaction is for Group. We dont want to check
               for Group entity for previous version of PE2        */
            num_kwds =
                envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds;
            /*
             RETRIEVE the current function pre/actual/post scripts
             parameters from RSSAPI parameters file.
            */
            rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                                func_name,
                                &apiprm);
            if (rc NE ESA_OK)
               goto cleanup;
 
         }
      }
      /* WS10079K - End */
      /*
        ALLOCATE memory for additional info.
      */
      rc= CSA_alloc ((char **)&addinfo1,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *          */
/* WS10079K *   (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+ */
/* WS10079K */       (num_kwds +
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo1");
      if (rc NE ESA_OK)
        goto cleanup;
 
 
     /* WS10079K - Start: We dont want to call pre/post script
                          for Role/Source entity.
      if ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES)) { */
      if ( ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES))
           AND (func_name_internal NE FUNC_ADDXROL)
           AND (func_name_internal NE FUNC_ADDXSGP) )
      {
     /* WS10079K - End */
        rc= CSA_alloc ((char **)&addinfo2,
                        STRUC_ADDINFO,
/*WS10082K*             sizeof(ADDINFO_rec_typ) *          */
 /* WS10079K */         num_kwds,
 /* WS10079K *   envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds,*/
                        1,
                        fn,
                        "addinfo2");
        if (rc NE ESA_OK)
           goto cleanup;
/*WS10082K - Start */
/*          memset((char *)addinfo2,
               NULL_CHAR ,
/@ WS10079K @  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds * @/
/@ WS10079K @/ num_kwds *
                     sizeof(ADDINFO_rec_typ));
        addinfo2->max_pairs=
/@ WS10079K @/             num_kwds;
/@ WS10079K  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds; @/  */
/*WS10082K - End */
 
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
 
      set_addinfo[0] = addinfo1;
      get_addinfo[0] = addinfo2;
 
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr ,
                             msg_hdr );
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
 
        /*
          INITIALIZE the pre/actual/post scripts statuses and error
          buffers.
        */
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(usr_prm);
        CLEAR_STRUCT(oe_prm);
        CLEAR_STRUCT(ug_prm);
        CLEAR_STRUCT(u2ug_prm);
 
/*WS10082K* memset((char *)addinfo1,
               NULL_CHAR ,
 /@ WS10079K @ (envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+ @/
 /@ WS10079K @/ (num_kwds +
                apiprm.script_kwd_num) *
                    sizeof(ADDINFO_rec_typ));
        addinfo1->max_pairs=
 /@ WS10079K *  envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds+ @/
 /@ WS10079K @/            num_kwds +
                                  apiprm.script_kwd_num;
 */
 
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          ANALYZE the "GROUP" structure from message.
        */
        msg_ptr = CS_get_ug (&ug_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /* WS10079K - start */
        if( (func_name_internal EQ FUNC_ADDXROL)
                            OR
             (func_name_internal EQ FUNC_ADDXSGP) )
        {
          CTSAMSG_print (func_msg_code,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL, envir_ptr->msg_admin_param.ctsamsg_dest,
                         msg, ug_prm.group,
                         envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->msg_admin_param.admin_uname,
                         envir_ptr->msg_admin_param.admin_gname,
                         envir_ptr->siid);
        }
        else
        {
          /* No code change. Changed indentation CTSAMSG_print.*/
          CTSAMSG_print (func_msg_code,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL, envir_ptr->msg_admin_param.ctsamsg_dest,
                         ug_prm.group,
                         envir_ptr->msg_admin_param.rss_name,
                         envir_ptr->msg_admin_param.admin_uname,
                         envir_ptr->msg_admin_param.admin_gname,
                         envir_ptr->siid);
        }
        /*WS10079K - End */
        /*
          PREPARE - additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo1 ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
 
 
        /* WS10079K - Start: We dont want to call pre script  *
                             for Role/Source entity.          */
        /*
          PROCESS when pre-script should be activated:
        */
 /*     if ( apiprm.pre EQ CS_YES ) {    */
        if ( (apiprm.pre EQ CS_YES)
             AND (func_name_internal NE FUNC_ADDXROL)
             AND (func_name_internal NE FUNC_ADDXSGP) ) {
        /* WS10079K - End */
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set user group.");
          if (func_name  NE FUNC_ADDUG)
          {
             memcpy((char *)&ug_pre_prm,
                  (char *)&ug_prm,
                  sizeof (UG_PARAMS_rec_typ));
             rc= CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDUG,
                    &ug_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
          }
          ERROR_CLEAR(err_msg);
 
          rc_pre = CS_pre_post_ug (SCRIPT_PRE , 1,
                      &ug_prm, set_addinfo, get_addinfo,
                      &apiprm, rc_act, rc_pre, &obj_exist);
 
          if (rc_pre EQ ESA_OK)
            CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
          ERROR_COPY(&err_pre, err_msg);
          ERROR_CLEAR(err_msg);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
 
 
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
        */
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES)) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set user group.");
          /*
            ACTIVATE the relevant ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
			"    -> Set for user group %s.", ug_prm.group);
          CS_DIAG_UG (ESA_COMP_ACSSETF, 1,&ug_prm,
				            &addinfo1, NULL, 0, TRUE);
          switch (func_name) {
            case FUNC_ADDUG:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSAddUG USA-API.");
             rc_act= envir_ptr->func_ptr.addug_ptr(&ug_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
            break;
 
            case FUNC_UPDUG:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdUG USA-API.");
             rc_act = envir_ptr->func_ptr.updug_ptr(&ug_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
            break;
 
            case FUNC_DELUG:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSDelUG USA-API.");
             rc_act = envir_ptr->func_ptr.delug_ptr(&ug_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
 
 
          }
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    <- SET for user group completed with rc=%d (%s).",
		      rc_act,(rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          if (rc_act EQ ESA_OK)
             CS_DIAG_UG (ESA_COMP_ACSSETF, 1,&ug_prm, &addinfo1, NULL, 0, TRUE);
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
 
          ERROR_COPY(&err_act,err_msg);
          ERROR_CLEAR(err_msg);
 
        } /* END - actual activation required */
 
        /*WS10079K - Start: We dont want to call post script  *
                            for Role/Source entity.           */
        /*
          PROCESS when post-script activation is required:
        */
 
     /* if (apiprm.post EQ CS_YES) {      */
        if ( (apiprm.post EQ CS_YES)
             AND (func_name_internal NE FUNC_ADDXROL)
             AND (func_name_internal NE FUNC_ADDXSGP) ) {
        /* WS10079K - End */
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set user group.");
           memcpy((char *)&ug_pre_prm,
                  (char *)&ug_prm,
                  sizeof (UG_PARAMS_rec_typ));
           rc= CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDUG,
                    &ug_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
             rc_pst = CS_pre_post_ug (SCRIPT_POST , 1,
                      &ug_prm, set_addinfo, get_addinfo,
                      &apiprm, rc_act, rc_pre, &obj_exist);
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst NE ESA_SKIP) {
             CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                            envir_ptr->msg_admin_param.ctsamsg_handle,
                            NULL,
                            envir_ptr->msg_admin_param.ctsamsg_dest,
                            fn, ESA_rc2str(rc_pst), ug_prm.group);
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                          envir_ptr->msg_admin_param.rss_name,
                          NULL,
                          MSG_UG_POSTSCRIPT_FAIL,
                          fn, ESA_rc2str(rc_pst), ug_prm.group);
		  }
          ERROR_COPY(&err_pst,err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
 
        } /* END - post-script activation required */
 
        /*
          PROCESS when HOST PATH is required:
        */
        if ((envir_ptr->hot_path EQ HOT_PATH_ON) OR
            (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
 
          ERROR_CLEAR(err_msg);
          /*
            ACTIVATE user's hot_path function (retrieve group details).
          */
 
 
          rc = CS_pre_post_info_for_obj (
                       envir_ptr->msg_admin_param.rss_name,
       /* WS10079K     FUNC_ADDUG, */
       /* WS10079K */  func_name_internal,
                       &ug_prm,
                       set_addinfo,
                       NULL,
                       HOT_PATH_ON);
 
 
          if ((rc EQ ESA_OK) OR (rc EQ ESA_KEY_NOT_FOUND))
             envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_GROUP ,
                                  envir_ptr->empty_oe ,
                                  envir_ptr->empty_user,
                                  ug_prm.group,
                                  UPDCONN_NO,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
          CLEAR(exists);
          if (rc EQ ESA_KEY_NOT_FOUND)
             strcpy (exists,ENTITY_NOT_FOUND);
          else if (rc EQ ESA_SKIP)
             strcpy (exists,ENTITY_ERR);
          else
             strcpy (exists,ENTITY_FOUND);
 
        }
 
        else strcpy (exists,ENTITY_UNKNOWN);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
          goto cleanup;
        /*
          ADD current respond buffer to respond message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                addinfo1,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
 
        if (msg_cd EQ NULL) {
          rc=ESA_FATAL;
          goto cleanup;
        }
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal message requests */
 
      if ((rc EQ ESA_OK)                      AND
          (num_msgs EQ 1)                     AND
          (strcmp (exists,ENTITY_FOUND) EQ 0) AND
          (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
        /*
         SET not last (and not temporary last) message type to respond.
        */
          CS_set_not_last_msg(msg_cd_ptr);
      }
      else
        /*
          SET "Temporary Last" message indicator in message header.
        */
          CS_set_tmp_last_msg(msg_cd_ptr);
 
      /*
        TRANSLATE function name to function code in respond message
        buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo1);
 
      if ( ((apiprm.pre EQ CS_YES )                   /* WS10079K */
             OR (apiprm.post EQ CS_YES))              /* WS10079K */
           AND (func_name_internal NE FUNC_ADDXROL)   /* WS10079K */
           AND (func_name_internal NE FUNC_ADDXSGP) ) /* WS10079K */
      {                                               /* WS10079K */
         CSA_free ((char **)&addinfo2);
      }                                               /* WS10079K */
      if (((rc EQ ESA_OK) OR
           (rc EQ ESA_TERM_CTSA) OR
           (rc EQ ESA_CANCEL_SERVICE))        AND
          (num_msgs EQ 1)                     AND
          (strcmp (exists,ENTITY_FOUND) EQ 0) AND
          (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
 
         char             usr[1]= {'\0'};
 
         CS_send_ug2uc_msg (msg_hdr,
                            tran,
                            (char *)ug_prm.group,
                            usr);
 
      }
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
} /* END - CS_ug_set function */
 
 
/****************************************************
 * Procedure Name: CS_oe_set
 * Description   : container sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function the takes care of all group SET
 * requestes that includes the following:
 * - Add new user group
 * - Delete an existing user group.
 * - Update user group's details.
 * The function receives a message with the "set" details that may
 * include several set group requests. It scans the input buffer after
 * all requests, analyses each request details - retrieving the group's
 * details into the group parameters structure, activate the PreScript
 * (if needed) the API (if needed) and PostScript (if needed),
 * Retrieves the new group's details - in case HOT PATH is required,
 * prepares and sends a respons message back to the ESS.
 *****************************************************************/
 
ESA_RC  CS_oe_set (MSG_typ               *  msg_ptr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr,
                   TRAN_rec_typ          *  tran,
                   short                    func_name,
                   CTSAMSG_MSGID_typ        func_msg_code)
{
      char fn[]="CS_oe_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ADDINFO_rec_typ     * addinfo1= NULL, * addinfo2= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
      ESA_RC                rc;
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      OE_PARAMS_rec_typ     oe_prm, oe_pre_prm;
      UG_PARAMS_rec_typ     ug_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIPRM_rec_typ     apiprm;
      RES_PARAMS_rec_typ    res_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      char                  exists[26];
      OBJ_EXISTS_typ        obj_exist;
      ENVIRONMENT_rec_typ * envir_ptr;
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      addinfo1    = NULL;
      addinfo2    = NULL;
      msg_cd      = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
      }
      /*
        RETRIEVE the current function pre/actual/post scripts
        parameters from RSSAPI parameters file.
      */
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name,
                          &apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
 
      /*
        ALLOCATE memory for additional info.
      */
      rc= CSA_alloc ((char **)&addinfo1,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *        */
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo1");
      if (rc NE ESA_OK)
        goto cleanup;
 
      if ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES)) {
        rc= CSA_alloc ((char **)&addinfo2,
                        STRUC_ADDINFO,
/*WS10082K*             sizeof(ADDINFO_rec_typ) *       */
                 envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds,
                        1,
                        fn,
                        "addinfo2");
        if (rc NE ESA_OK)
           goto cleanup;
/*WS10082K - Start */
/*          memset((char *)addinfo2,
               NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds *
                  sizeof(ADDINFO_rec_typ));
        addinfo2->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds;   */
/*WS10082K - End */
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
 
      get_addinfo[0] = addinfo2;
      set_addinfo[0] = addinfo1;
 
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr ,
                             msg_hdr );
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
 
        /*
          INITIALIZE the pre/actual/post scripts statuses and error
          buffers.
        */
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(usr_prm);
        CLEAR_STRUCT(oe_prm);
        CLEAR_STRUCT(ug_prm);
        CLEAR_STRUCT(u2ug_prm);
 
/*WS10082K* memset((char *)addinfo1,
               NULL_CHAR ,
               (envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                apiprm.script_kwd_num) *
                   sizeof(ADDINFO_rec_typ));
        addinfo1->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds+
                              apiprm.script_kwd_num;  */
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          ANALYZE the "CONTAINER" structure from message.
        */
        msg_ptr = CS_get_oe (&oe_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       oe_prm.oe,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        /*
          PREPARE - additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo1 ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
 
        /*
          PROCESS when pre-script should be activated:
        */
        if ( apiprm.pre EQ CS_YES ) {
 
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set container.");
           if (func_name  NE FUNC_ADDOE)
           {
              memcpy((char *)&oe_pre_prm,
                  (char *)&oe_prm,
                  sizeof (OE_PARAMS_rec_typ));
              rc= CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDOE,
                    &oe_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
          }
          ERROR_CLEAR(err_msg);
 
          rc_pre = CS_pre_post_oe (SCRIPT_PRE , 1,
                      &oe_prm, set_addinfo, get_addinfo,
                          &apiprm, rc_act, rc_pre, &obj_exist);
          if (rc_pre EQ ESA_OK)
            CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
          ERROR_COPY(&err_pre, err_msg);
          ERROR_CLEAR(err_msg);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
 
 
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
        */
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES)) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set container.");
          /*
            ACTIVATE the relevant ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    -> SET for container %s.", oe_prm.oe);
          CS_DIAG_OE (ESA_COMP_ACSSETF, 1,&oe_prm,
				            &addinfo1, NULL, 0, TRUE);
          switch (func_name) {
            case FUNC_ADDOE:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSAddOE USA-API.");
             rc_act = envir_ptr->func_ptr.addoe_ptr(&oe_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
            break;
 
            case FUNC_UPDOE:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdOE USA-API.");
             rc_act = envir_ptr->func_ptr.updoe_ptr(&oe_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
            break;
 
            case FUNC_DELOE:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSDelOE USA-API.");
             rc_act = envir_ptr->func_ptr.deloe_ptr(&oe_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
            break;
 
          }
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    <- SET for container completed with rc_act=%d (%s)",
		      rc_act,(rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          if (rc_act EQ ESA_OK)
             CS_DIAG_OE (ESA_COMP_ACSSETF, 1,&oe_prm, &addinfo1, NULL, 0, TRUE);
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
 
          ERROR_COPY(&err_act,err_msg);
          ERROR_CLEAR(err_msg);
 
        } /* END - actual activation required */
 
        /*
          PROCESS when post-script activation is required:
        */
 
        if (apiprm.post EQ CS_YES) {
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set container.");
           memcpy((char *)&oe_pre_prm,
                  (char *)&oe_prm,
                  sizeof (OE_PARAMS_rec_typ));
           rc= CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDOE,
                    &oe_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
             rc_pst = CS_pre_post_oe (SCRIPT_POST , 1,
                      &oe_prm, set_addinfo, get_addinfo,
                      &apiprm, rc_act, rc_pre, &obj_exist);
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else {
             CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                            envir_ptr->msg_admin_param.ctsamsg_handle,
                            NULL,
                            envir_ptr->msg_admin_param.ctsamsg_dest,
                            fn, ESA_rc2str(rc_pst), oe_prm.oe);
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                          envir_ptr->msg_admin_param.rss_name,
                          NULL,
                          MSG_OE_POSTSCRIPT_FAIL,
                          fn, ESA_rc2str(rc_pst), oe_prm.oe);
		  }
          ERROR_COPY(&err_pst,err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
        } /* END - post-script activation required */
 
        /*
          PROCESS when HOST PATH is required:
        */
        if ((envir_ptr->hot_path EQ HOT_PATH_ON) OR
            (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
 
          ERROR_CLEAR(err_msg);
          /*
            ACTIVATE user's hot_path function (retrieve group details).
          */
 
          rc = CS_pre_post_info_for_obj (
                       envir_ptr->msg_admin_param.rss_name,
                       FUNC_ADDOE,
                       &oe_prm,
                       set_addinfo,
                       NULL,
                       HOT_PATH_ON);
          if ((rc EQ ESA_OK) OR (rc EQ ESA_KEY_NOT_FOUND))
             envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_CONTAINER,
                                          oe_prm.oe,
                                          envir_ptr->empty_user,
                                          envir_ptr->empty_ug,
                                          UPDCONN_NO,
                                          &envir_ptr->msg_admin_param,
                                          &envir_ptr->msg_err);
          CLEAR(exists);
          if (rc EQ ESA_KEY_NOT_FOUND)
             strcpy (exists,ENTITY_NOT_FOUND);
          else if (rc EQ ESA_SKIP)
             strcpy (exists,ENTITY_ERR);
          else
             strcpy (exists,ENTITY_FOUND);
 
        }
 
        else strcpy (exists,ENTITY_UNKNOWN);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
          goto cleanup;
        /*
          ADD current respond buffer to respond message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                addinfo1,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
 
        if (msg_cd EQ NULL) {
          rc=ESA_FATAL;
          goto cleanup;
        }
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal message requests */
 
      if ((rc EQ ESA_OK)                      AND
          (num_msgs EQ 1)                     AND
          (strcmp (exists,ENTITY_FOUND) EQ 0) AND
          (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
        /*
         SET not last (and not temporary last) message type to respond.
        */
          CS_set_not_last_msg(msg_cd_ptr);
      }
      else
        /*
          SET "Temporary Last" message indicator in message header.
        */
          CS_set_tmp_last_msg(msg_cd_ptr);
 
      /*
        TRANSLATE function name to function code in respond message
        buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo1);
      CSA_free ((char **)&addinfo2);
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
} /* END - CS_oe_set function */
 
/****************************************************
 * Procedure Name: CS_u2ug_set
 * Description   : user group to user sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function the takes care of all connection
 * SET requestes that includes the following:
 * - Add new user to user group
 * - Delete a user from user group.
 * - Update user connection to group details.
 * The function receives a message with the "set" details that may
 * include several set connection requests. It scans the input buffer
 * after all requests, analyses each request details - retrieving the
 * connection's details into the connection parameters structure,
 * activate the PreScript (if needed) the API (if needed) and PostScript
 * (if needed), Retrieves the new connection's details - in case HOT
 * PATH is required, prepares and sends a respons message back to the
 * ESS.
 ****************************************************************/
 
ESA_RC  CS_u2ug_set (MSG_typ               *  msg_ptr ,
                     RSS_MSG_HDR_rec_typ   *  msg_hdr,
                     TRAN_rec_typ          *  tran,
                     short                    func_name,
                     CTSAMSG_MSGID_typ        func_msg_code)
{
      char fn[]="CS_u2ug_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ADDINFO_rec_typ     * addinfo1= NULL, * addinfo2= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
      ADDINFO_rec_typ     * addinfo3= NULL;                 /*WS10070*/
      ADDINFO_rec_typ     * u_set_addinfo[1];               /*WS10070*/
      ESA_RC                rc;
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      UG_PARAMS_rec_typ     ug_prm;
      OE_PARAMS_rec_typ     oe_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm, u2ug_pre_prm;
      RSSAPIPRM_rec_typ     apiprm;
      RES_PARAMS_rec_typ    res_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      char                  exists[26];
      OBJ_EXISTS_typ        obj_exist[1];
      ENVIRONMENT_rec_typ * envir_ptr;
      char                * ptr = NULL;          /* WS10079K */
      char                  opr[10], entity[15]; /* WS10079K */
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      addinfo1    = NULL;
      addinfo2    = NULL;
      addinfo3    = NULL;                                   /*WS10070*/
      msg_cd      = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
      }
 
      /* WS10079K - Check if the connection is for Role/Source */
      /* WS10080 - Start */
      if(envir_ptr->addinfo_val_len EQ 5)
         ptr = strstr(msg_ptr,"1A04TYPE00004Role");
      else
         ptr = strstr(msg_ptr,"1A04TYPE0004Role"); /*Indentation*/
      /* WS10080 - End */
      if(ptr NE NULL)
      {
         strcpy (func_msg_code,MSG_CONN_ENTY_OPR_RSLT);
         if(func_name EQ FUNC_ADDU2UG)
         {
            strcpy(opr,"Add");
            strcpy(entity,"to Role");
         }
         else
         {
            if(func_name EQ FUNC_UPDU2UG)
            {
               strcpy(opr,"Update");
               strcpy(entity,"conn to Role");
            }
            else
            {
               if(func_name EQ FUNC_DELU2UG)
               {
                  strcpy(opr,"Delete");
                  strcpy(entity,"from Role");
               }
            }
         }
      }
      else
      {
         /* WS10080 - Start */
         if(envir_ptr->addinfo_val_len EQ 5)
            ptr = strstr(msg_ptr,"1A04TYPE00006Source");
         else
            ptr = strstr(msg_ptr,"1A04TYPE0006Source"); /*Indentation*/
         /* WS10080 - End */
         if(ptr NE NULL)
         {
            strcpy (func_msg_code,MSG_CONN_ENTY_OPR_RSLT);
            strcpy(entity,"Source");
            if(func_name EQ FUNC_ADDU2UG)
            {
               strcpy(opr,"Add");
               strcpy(entity,"to Source");
            }
            else
            {
               if(func_name EQ FUNC_UPDU2UG)
               {
                  strcpy(opr,"Update");
                  strcpy(entity,"conn to Source");
               }
               else
               {
                  if(func_name EQ FUNC_DELU2UG)
                  {
                     strcpy(opr,"Delete");
                     strcpy(entity,"from Source");
                  }
               }
            }
         }
      }
      /* WS10079K */
      /*
        RETRIEVE the current function pre/actual/post scripts
        parameters from RSSAPI parameters file.
      */
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name,
                          &apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
 
      /*
        ALLOCATE memory for additional info.
      */
      rc= CSA_alloc ((char **)&addinfo1,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *    */
               (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo1");
      if (rc NE ESA_OK)
        goto cleanup;
 
      if ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES)) {
        rc= CSA_alloc ((char **)&addinfo2,
                        STRUC_ADDINFO,
/*WS10082K*             sizeof(ADDINFO_rec_typ) *      */
                envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds,
                        1,
                        fn,
                        "addinfo2");
        if (rc NE ESA_OK)
           goto cleanup;
/*WS10082K - Start */
/*          memset((char *)addinfo2,
            NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds *
                  sizeof(ADDINFO_rec_typ));
        addinfo2->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds;  */
/*WS10082K - End */
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
 
      get_addinfo[0] = addinfo2;
      set_addinfo[0] = addinfo1;
 
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr,
                             msg_hdr);
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
 
        /*
          INITIALIZE the pre/actual/post scripts statuses and
          error buffers.
        */
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(ug_prm);
        CLEAR_STRUCT(oe_prm);
        CLEAR_STRUCT(usr_prm);
        CLEAR_STRUCT(u2ug_prm);
 
/*WS10082K memset((char *)addinfo1,
               NULL_CHAR ,
               (envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                apiprm.script_kwd_num) *
                   sizeof(ADDINFO_rec_typ));    */
        /*WS10082A addinfo1->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds+
                              apiprm.script_kwd_num ;              */
        ADDINFO_empty(addinfo1);                         /*WS10082A*/
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          GET the group name field from message.
        */
        msg_ptr = CS_get_fld (u2ug_prm.group ,
                              msg_ptr,
                              envir_ptr->rss_limits.max_ug_len,
                              C_GROUP_ID);
        if (msg_ptr EQ NULL) {
          rc =ESA_ERR;
          goto cleanup;
        }
        ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_DETAILES+ 1,
	          "1: User Group connection=%s.", (int)u2ug_prm.group);
        /*
          GET the user name field from message.
        */
        msg_ptr = CS_get_fld (u2ug_prm.user ,
                              msg_ptr,
                              envir_ptr->rss_limits.max_user_len,
                              C_USER_ID);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_DETAILES+ 1,
	          "2: User connection=%s.", (int)u2ug_prm.user);
 
        /* WS10079K - Start */
        if(ptr NE NULL)
        {
           CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle,
                       NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       opr, u2ug_prm.user, entity,
                       u2ug_prm.group,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        }
        else
        {  /* Rearrange the parameters */
           CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle,
                       NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       u2ug_prm.user, u2ug_prm.group,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        }
        /* WS10079K - End */
        /*
          ANALYZE the "CONNECTION" structure from message.
        */
        msg_ptr = CS_get_u2ug (&u2ug_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          PREPARE - additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo1 ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
 
        /*
          PROCESS when pre-script should be activated:
        */
   /*   if ( apiprm.pre EQ CS_YES ) {                      WS10079K*/
        if ( (apiprm.pre EQ CS_YES) AND (ptr EQ NULL) ){ /*WS10079K*/
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set user to group connection.");
          if (func_name  NE FUNC_ADDU2UG)
          {
             memcpy((char *)&u2ug_pre_prm,
                  (char *)&u2ug_prm,
                  sizeof (U2UG_PARAMS_rec_typ));
             rc= CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDU2UG,
                    &u2ug_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
          }
          ERROR_CLEAR(err_msg);
 
          rc_pre = CS_pre_post_u2ug (SCRIPT_PRE , 1,
                          &u2ug_prm, set_addinfo, get_addinfo,
                          &apiprm, rc_act, rc_pre, obj_exist);
          if (rc_pre EQ ESA_OK)
            CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
          ERROR_COPY(&err_pre ,err_msg);
          ERROR_CLEAR(err_msg);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
 
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
        */
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES)) {
 
		  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set user to group connection.");
          /*
            ACTIVATE the relevant ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
     		"...-> SET for user %s to user group %s.",u2ug_prm.user, u2ug_prm.group);
          CS_DIAG_UG2UC (ESA_COMP_ACSSETF,0, 1, NULL, NULL,
			  &u2ug_prm, &addinfo1, NULL, 0, TRUE);
          switch (func_name) {
            case FUNC_ADDU2UG:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSAddUserToUG USA-API.");
             rc_act = envir_ptr->func_ptr.addu2ug_ptr(&u2ug_prm,
                                   addinfo1,
                                   &envir_ptr->msg_admin_param,
                                   err_msg);
            break;
 
            case FUNC_UPDU2UG:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdUserToUG USA-API.");
             rc_act = envir_ptr->func_ptr.updu2ug_ptr(&u2ug_prm,
                                    addinfo1,
                                    &envir_ptr->msg_admin_param,
                                    err_msg);
            break;
 
            case FUNC_DELU2UG:
             ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSDelUserToUG USA-API.");
             rc_act = envir_ptr->func_ptr.delu2ug_ptr(&u2ug_prm,
                                    addinfo1,
                                    &envir_ptr->msg_admin_param,
                                    err_msg);
            break;
 
          }
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    <- SET for user to group connection completed with rc_act=%d (%s)",
		      rc_act,(rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          if (rc_act EQ ESA_OK)
             CS_DIAG_UG2UC (ESA_COMP_ACSSETF,0, 1, NULL, NULL,
			  &u2ug_prm, &addinfo1, NULL, 0, TRUE);
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
 
          ERROR_COPY(&err_act , err_msg);
          ERROR_CLEAR(err_msg);
        } /* END - actual activation required */
 
        /*
          PROCESS when post-script activation is required:
        */
 
    /*  if (apiprm.post EQ CS_YES) {                        *WS10079K*/
        if ( (apiprm.post EQ CS_YES) AND (ptr EQ NULL) ) { /*WS10079K*/
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set user to group connection.");
             memcpy((char *)&u2ug_pre_prm,
                  (char *)&u2ug_prm,
                  sizeof (U2UG_PARAMS_rec_typ));
          rc= CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDU2UG,
                    &u2ug_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
 
          rc_pst = CS_pre_post_u2ug (SCRIPT_POST , 1,
                          &u2ug_prm, set_addinfo, get_addinfo,
                          &apiprm, rc_act, rc_pre, obj_exist);
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst NE ESA_SKIP) {
             CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                            envir_ptr->msg_admin_param.ctsamsg_handle,
                            NULL,
                            envir_ptr->msg_admin_param.ctsamsg_dest,
                            fn, ESA_rc2str(rc_pst), u2ug_prm.group,
	    					u2ug_prm.user);
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                          envir_ptr->msg_admin_param.rss_name,
                          NULL,
                          MSG_U2UG_POSTSCRIPT_FAIL,
                          fn, ESA_rc2str(rc_pst), u2ug_prm.group,
			      		  u2ug_prm.user);
		  }
          ERROR_COPY(&err_pst , err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
        }  /* END - post-script activation required */
 
        /*
          PROCESS when HOST PATH is required:
        */
        if ((envir_ptr->hot_path EQ HOT_PATH_ON) OR
            (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
 
          ERROR_CLEAR(err_msg);
          /* WS10070 - start */
          /* Stop calling hotpath for connections
          instead call it for user
          *
            ACTIVATE user's hot_path function (retrieve group details).
          *
          rc = CS_pre_post_info_for_obj (
                       envir_ptr->msg_admin_param.rss_name,
                       FUNC_ADDU2UG,
                       &u2ug_prm,
                       set_addinfo,
                       NULL,
	                   HOT_PATH_ON);
          */
          rc= CSA_alloc ((char **)&addinfo3,
                         STRUC_ADDINFO,
/*WS10082K*              sizeof(ADDINFO_rec_typ) *     */
                 (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                                apiprm.script_kwd_num) ,
                         1,
                         fn,
                         "addinfo3");
 
          if (rc NE ESA_OK)
            goto cleanup;
 
          u_set_addinfo[0] = addinfo3;
 
/*WS10082K - Start */
/*          memset((char *)addinfo3,
                 NULL_CHAR ,
                 (envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                  apiprm.script_kwd_num) *
                     sizeof(ADDINFO_rec_typ));
          addinfo3->max_pairs=
              envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds+
                                apiprm.script_kwd_num , */
/*WS10082K - End */
 
          strcpy ( usr_prm.user, u2ug_prm.user);
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_DETAILES+ 1,
             "perform get User =%s.", (int)usr_prm.user);
 
          rc = CS_pre_post_info_for_obj (
                       envir_ptr->msg_admin_param.rss_name,
                       FUNC_ADDUSER,
                       &usr_prm,
                       u_set_addinfo,
                       NULL,
                       HOT_PATH_ON);
 
 
 
          /* WS10070 - end */
          if ((rc EQ ESA_OK) OR (rc EQ ESA_KEY_NOT_FOUND))
             envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_CONNECTION ,
                                  envir_ptr->empty_oe ,
                                  u2ug_prm.user,
                                  u2ug_prm.group,
                                  UPDCONN_NO,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
          CLEAR(exists);
          if (rc EQ ESA_KEY_NOT_FOUND)
             strcpy (exists,ENTITY_NOT_FOUND);
          else if (rc EQ ESA_SKIP)
             strcpy (exists,ENTITY_ERR);
          else
             strcpy (exists,ENTITY_FOUND);
 
        }
 
        else strcpy (exists,ENTITY_UNKNOWN);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
          goto cleanup;
        /*
          ADD current respond buffer to respond message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                              /*func_name,                   WS10070 */
                                FUNC_UPDUSER,             /* WS10070 */
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                              /*addinfo1,                    WS10070 */
                                addinfo3,                 /* WS10070 */
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr ,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
 
        if (msg_cd EQ NULL){
          rc=ESA_FATAL;
          goto cleanup;
        }
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal message requests */
 
      /*
        SET "Temporary Last" message indicator in message header.
      */
      CS_set_tmp_last_msg(msg_cd_ptr);
      /*
        TRANSLATE function name to function code in respond
        message buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo1);
      CSA_free ((char **)&addinfo2);
      CSA_free ((char **)&addinfo3);          /*WS10070*/
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
} /* END - CS_u2ug_set function */
 
/****************************************************
 * Procedure Name: CS_ace_set
 * Description   : ace sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function the takes care of all ACE
 * SET requestes that includes the following:
 * - Add new ACE to ACL.
 * - Delete an ACE from ACL.
 * - Update ACE in ACL.
 * The function receives a message with the "set" details that may
 * include several set connection requests. It scans the input buffer
 * after all requests, analyses each request details - retrieving the
 * ACE's details into the ace parameters structure - for both the
 * actual and the relative(add)/old(update) ACEs, activate the
 * PreScript (if needed) the API (if needed) and PostScript (if
 * needed), Retrieves the new ACL's(!!!) details - in case HOT
 * PATH is required, prepares and sends a respons message back to the
 * ESS.
 **********************************************************************/
 
    ESA_RC  CS_ace_set (MSG_typ               *  msg_ptr ,
                        RSS_MSG_HDR_rec_typ   *  msg_hdr,
                        TRAN_rec_typ          *  tran,
                        short                    func_name,
                        CTSAMSG_MSGID_typ        func_msg_code)
    {
      char fn[]="CS_ace_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs, len_msg, cd_msg_len,
                            cd_num_msgs;
      ADDINFO_rec_typ     * addinfo_res= NULL,* addinfo_reg= NULL;
      ADDINFO_rec_typ     * addinfo_old= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
      ESA_RC                rc, rc_pre, rc_act, rc_pst;
      ERR_STRUCT_rec_typ    err_pre, err_act, err_pst, * err_msg;
      MSG_typ             * msg_cd, * msg_cd_ptr= NULL;
      ACE_rec_typ           new_ace, old_ace;
      ACE_POS_typ           ace_place;
      RES_PARAMS_rec_typ    res_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      OE_PARAMS_rec_typ     oe_prm;
      UG_PARAMS_rec_typ     ug_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIPRM_rec_typ     apiprm;
      char                  exists[26];
      RSS_MSG_HDR_rec_typ   msg_hdr_cd;
      OBJ_EXISTS_typ        obj_exist[MAX_GET];
      ENVIRONMENT_rec_typ * envir_ptr;
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      memcpy ((char *)(&msg_hdr_cd), (char *)msg_hdr,
              sizeof( RSS_MSG_HDR_rec_typ));
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
 
      msg_cd_ptr  = NULL;
      addinfo_reg = NULL;
      addinfo_old = NULL;
      addinfo_res = NULL;
      msg_cd      = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
      }
       /*
        RETRIEVE the current function pre/actual/post
        scripts parameters from RSSAPI parameters file.
      */
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name,
                          &apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ALLOCATE memory for additional info.
      */
      rc= CSA_alloc ((char **)&addinfo_reg,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *    */
              (envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds+
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo");
      if (rc NE ESA_OK)
        goto cleanup;
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
      rc= CSA_alloc ((char **)&addinfo_old,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *       */
                envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds,
                     1,
                     fn,
                     "addinfo ace");
      if (rc NE ESA_OK)
        goto cleanup;
      rc= CSA_alloc ((char **)&addinfo_res,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *      */
                envir_ptr->interest[envir_ptr->rss_num].num_res_kwds,
                     1,
                     fn,
                     "addinfo res");
      if (rc NE ESA_OK)
        goto cleanup;
      get_addinfo[0] = addinfo_old;
      set_addinfo[0] = addinfo_reg;
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
        /*
          INITIALIZE the pre/actual/post scripts statuses and
          error buffers.
        */
        msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                               &cd_num_msgs ,
                               msg_cd ,
                               msg_cd_ptr,
                               msg_hdr);
 
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(new_ace);
        CLEAR_STRUCT(old_ace);
        CLEAR_STRUCT(res_prm);
 
/* WS10082K - Start */
  /******   memset((char *)addinfo_reg,
               NULL_CHAR ,
               (envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds+
                apiprm.script_kwd_num) *
                   sizeof(ADDINFO_rec_typ));
        addinfo_reg->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds+
                   apiprm.script_kwd_num;
 
            memset((char *)addinfo_res,
               NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_res_kwds *
                  sizeof(ADDINFO_rec_typ));
        addinfo_res->max_pairs =
            envir_ptr->interest[envir_ptr->rss_num].num_res_kwds;
 
            memset((char *)addinfo_old,
               NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds *
                  sizeof(ADDINFO_rec_typ));
        addinfo_old->max_pairs =
            envir_ptr->interest[envir_ptr->rss_num].num_ace_kwds;  *****/
  /* WS10082K - End */
        ADDINFO_empty(addinfo_reg);                       /* WS10082N */
        ADDINFO_empty(addinfo_res);                       /* WS10082N */
        ADDINFO_empty(addinfo_old);                       /* WS10082N */
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          ANALYZE the ACE's resource details from message.
        */
        msg_ptr = CS_get_res (&res_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          ANALYZE the new ACE details from message.
        */
        msg_ptr = CS_get_ace (&new_ace , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          PROCESS according the required action:
        */
        switch (func_name) {
          /*
            PROCESS ADD ACE request:
          */
          case FUNC_ADDACE:
              /*
                ANALYZE the relative ACE details.
              */
              msg_ptr = CS_get_ace (&old_ace , msg_ptr);
              if (msg_ptr EQ NULL) {
                rc= ESA_ERR;
                goto cleanup;
              }
              /*
                GET the ACE location relative to the "relative ace".
              */
              msg_ptr = CS_get_ace_place (&ace_place , msg_ptr);
              if (msg_ptr EQ NULL) {
                rc= ESA_ERR;
                goto cleanup;
              }
             /*
               GET the ACE's resource addinfo.
             */
             msg_ptr = CS_get_addinfo (&addinfo_res ,
				                       msg_ptr);
             if (msg_ptr EQ NULL) {
                rc= ESA_ERR;
                goto cleanup;
             }
            /*
              GET the new ACE addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_reg ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            /*
              GET the relative ACE addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_old ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            break;
          /*
            PROCESS UPDATE ACE request:
          */
          case FUNC_UPDACE:
            /*
              ANALYZE the old ACE details (as it was before the update).
            */
            msg_ptr = CS_get_ace (&old_ace , msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            /*
              GET the ACE's resource addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_res ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            /*
              GET the new ACE addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_reg ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            /*
              GET the relative ACE addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_old ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            break;
          /*
            PROCESS DELETE ACE request:
          */
          case FUNC_DELACE:
            /*
              GET the ACE's resource addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_res ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            /*
              GET the new ACE addinfo.
            */
            msg_ptr = CS_get_addinfo (&addinfo_reg ,
				                      msg_ptr);
            if (msg_ptr EQ NULL) {
               rc= ESA_ERR;
               goto cleanup;
            }
            break;
        } /* END - case */
 
        /*
          PROCESS when pre-script should be activated:
        */
        if ( apiprm.pre EQ CS_YES ) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set resource acl.");
          ERROR_CLEAR(err_msg);
 
          rc= CS_addinfo2_add (STRUC_ACE_REC,
                               (func_name EQ FUNC_DELACE) ?
                                  &new_ace
                                  :
                                  &old_ace,
                               (func_name EQ FUNC_DELACE) ?
                                  addinfo_reg
                                  :
                                  addinfo_old);
          if (rc NE ESA_OK)
             goto cleanup;
          rc_pre = CS_pre_post_ace (SCRIPT_PRE ,1, func_name, &res_prm,
                     &new_ace, set_addinfo, get_addinfo, addinfo_res,
                     &ace_place, &apiprm, rc_act, rc_pre, obj_exist);
 
          if (rc_pre EQ ESA_OK)
            CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre NE ESA_SKIP) {
             CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
		  }
          ERROR_COPY(&err_pre , err_msg);
          ERROR_CLEAR(err_msg);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
 
        /* WS10082K - Start Use ADDINFO_dump instead of CS_addinfo_prt*
        CS_addinfo_prt(addinfo_reg,"Addinfo before actual");  */
 
        /* Print only if diag for ACFINFO is requested       IS10188
           Same as it was in CS_addinfo_prt.                 IS10188 */
        if(ESA_DIAG_get_debug_level(ESA_COMP_ACSINFO) GT 13) /*IS10188*/
        {                                                 /* IS10188 */
          ADDINFO_dump(addinfo_reg,1);
          /*WS10082K - End */
        }                                                 /* IS10188 */
 
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
         */
 
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES)) {
 
		  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set resource ace.");
          /*
            ACTIVATE the relevant ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    -> SET ace oe=%s ug=%s user=%s for resource %s %s.",
				new_ace.oe_name, new_ace.ug_name, new_ace.user_name,
				res_prm.resource, res_prm.restype);
          CS_DIAG_RESACL  (ESA_COMP_ACSSETF, 1, addinfo_old, &res_prm,
			 &new_ace, &addinfo_reg, NULL, TRUE, &old_ace, 0, ace_place);
          switch (func_name) {
            case FUNC_ADDACE:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSAddACE USA-API.");
              rc_act = envir_ptr->func_ptr.addace_ptr(&res_prm,
                                     &new_ace,
                                     addinfo_reg,
                                     ace_place,
                                     &old_ace,
                                     addinfo_old,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
            break;
 
            case FUNC_UPDACE:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdACE USA-API.");
              rc_act = envir_ptr->func_ptr.updace_ptr(&res_prm,
                                     &new_ace,
                                     addinfo_reg,
                                     &old_ace,
                                     addinfo_old,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
 
             break;
 
            case FUNC_DELACE:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSDelACE USA-API.");
              rc_act = envir_ptr->func_ptr.delace_ptr(&res_prm,
                                     &new_ace,
                                     addinfo_reg,
                                     &envir_ptr->msg_admin_param,
                                     err_msg);
            break;
 
          }
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    <- SET for ace  completed with rc_act=%d (%s)",
		      rc_act,(rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          if (rc_act EQ ESA_OK)
             CS_DIAG_RESACL  (ESA_COMP_ACSSETF, 1, addinfo_old, &res_prm,
		    	 &new_ace, &addinfo_reg, NULL, TRUE, &old_ace, 0, ace_place);
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
 
          ERROR_COPY(&err_act , err_msg);
          ERROR_CLEAR(err_msg);
 
        } /* END - actual activation required */
        /*
          PROCESS when post-script activation is required:
        */
        if (apiprm.post EQ CS_YES) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set resource acl.");
          rc_pst= CS_pre_post_ace (SCRIPT_POST ,1, func_name, &res_prm,
                     &new_ace, set_addinfo, NULL, addinfo_res,
                     &ace_place, &apiprm, rc_act, rc_pre, obj_exist);
 
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst NE ESA_SKIP) {
             CTSAMSG_print (MSG_ACE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pst),
                           (strlen (new_ace.user_name)) ?
						      new_ace.user_name
							  :
			                  (strlen (new_ace.ug_name)) ?
			                     new_ace.ug_name
								 :
							     new_ace.oe_name,
						   res_prm.resource, res_prm.restype);
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           NULL,
                           MSG_ACE_POSTSCRIPT_FAIL,
                           ESA_rc2str(rc_pst),
                           (strlen (new_ace.user_name)) ?
						      new_ace.user_name
							  :
			                  (strlen (new_ace.ug_name)) ?
			                     new_ace.ug_name
								 :
							     new_ace.oe_name,
						   res_prm.resource, res_prm.restype);
		  }
          ERROR_COPY(&err_pst , err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
        } /* END - post-script activation required */
 
        strcpy (exists,ENTITY_UNKNOWN);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
        /*
          ADD current action results to message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                addinfo_reg,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
 
        if (msg_cd EQ NULL) {
          rc=ESA_FATAL;
          goto cleanup;
        }
 
 
        if (
            (envir_ptr->hot_path EQ HOT_PATH_ON)
            OR
            (i LT (num_msgs -1)) /* The for loop did not terminate yet-
                                  The msg may not be Last/Tmp_last */
           )
          /*
            SET NOT last message in case a HOT PATH is required and the
            Resource ACL exists; or if this is not the last request
            (internal message).
          */
          CS_set_not_last_msg(msg_cd_ptr);
        else
          CS_set_tmp_last_msg(msg_cd_ptr);
      /*
        TRANSLATE function name to function code in respond
        message buffer.
      */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          SEND respond message to ESS.
        */
 
        rc = CS_send_cd_msg (&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd_ptr);
 
        if (rc NE ESA_OK)
          goto cleanup;
 
        /*
        PROCESS when HOT PATH was required and the resource ACL exists:
        PLEASE NOTE: In case of ACE SET function  - the HOT PATH details
        (= resource's ACL) do not join the retrune codes message
        buffer - They are ALWAYS sent in a separate message(s)!!!
        */
        if(envir_ptr->hot_path EQ HOT_PATH_ON) {
 
          ERROR_CLEAR(err_msg);
          /*
            RETRIEVE the current resource's ACL and send it to the ESS.
          */
          rc=CS_rsacl_get (&res_prm ,
                           addinfo_res ,
                           NULL,
                           msg_hdr,
                           &msg_hdr_cd,
                           tran,
                           1 ,
                           FUNC_GTRSACL);
 
          if (rc NE ESA_OK)
            goto cleanup;
        } /* Resource acl exists and HOT PATH requested */
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal requests */
 
      cleanup:
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo_reg);
      CSA_free ((char **)&addinfo_old);
      CSA_free ((char **)&addinfo_res);
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
    } /* END - CS_ace_set function */
 
/****************************************************
 * Procedure Name: CS_res_set
 * Description   : resource sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function the takes care of all resource
 * SET requestes that includes the following:
 * - Update resource details.
 * The function receives a message with the "set" details that may
 * include several set connection requests. It scans the input buffer
 * after all requests, analyses each request details - retrieving the
 * resource's details into the resource parameters structure,
 * activate the PreScript (if needed) the API (if needed) and PostScript
 * (if needed), Retrieves the new resource's details - in case HOT
 * PATH is required, prepares and sends a respons message back to the
 * ESS.
 *****************************************************************/
 
ESA_RC  CS_res_set (MSG_typ               *  msg_ptr ,
                    RSS_MSG_HDR_rec_typ   *  msg_hdr,
                    TRAN_rec_typ          *  tran,
                    short                    func_name,
                    CTSAMSG_MSGID_typ        func_msg_code)
{
      char fn[]="CS_res_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ADDINFO_rec_typ     * addinfo1= NULL, * addinfo2= NULL;
      ADDINFO_rec_typ     * addinfo_res= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
      ESA_RC                rc;
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      RES_PARAMS_rec_typ    res_prm, res_pre_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      OE_PARAMS_rec_typ     oe_prm;
      UG_PARAMS_rec_typ     ug_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIPRM_rec_typ     apiprm;
      char                  exists[26];
      RSS_MSG_HDR_rec_typ   msg_hdr_cd;
      OBJ_EXISTS_typ        obj_exist;
      ENVIRONMENT_rec_typ * envir_ptr;
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      memcpy ((char *)(&msg_hdr_cd), (char *)msg_hdr,
              sizeof( RSS_MSG_HDR_rec_typ));
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      addinfo1    = NULL;
      addinfo2    = NULL;
      addinfo_res = NULL;
      msg_cd      = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs,
                                msg_ptr);
      if (msg_ptr EQ NULL) {
        rc= ESA_ERR;
        goto cleanup;
      }
      /*
        RETRIEVE the current function pre/actual/post
        scripts parameters from RSSAPI parameters file.
      */
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name ,
                          &apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ALLOCATE memory for the ACTION additional info.
      */
      rc= CSA_alloc ((char **)&addinfo1,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *       */
                (envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo1");
      if (rc NE ESA_OK)
        goto cleanup;
 
      if ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES)) {
        rc= CSA_alloc ((char **)&addinfo2,
                        STRUC_ADDINFO,
/*WS10082K*             sizeof(ADDINFO_rec_typ) *   */
                envir_ptr->interest[envir_ptr->rss_num].num_res_kwds,
                        1,
                        fn,
                        "addinfo2");
        if (rc NE ESA_OK)
           goto cleanup;
/*WS10082K* memset((char *)addinfo2,
               NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_res_kwds *
                  sizeof(ADDINFO_rec_typ));  */
        /*WS10082A addinfo2->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_res_kwds; */
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
      rc= CSA_alloc ((char **)&addinfo_res,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *    */
                envir_ptr->interest[envir_ptr->rss_num].num_res_kwds,
                     1,
                     fn,
                     "addinfo_res");
      if (rc NE ESA_OK)
        goto cleanup;
 
      set_addinfo[0] = addinfo1;
      get_addinfo[0] = addinfo2;
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr,
                             msg_hdr);
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++)
      {
 
        /*
          INITIALIZE the pre/actual/post scripts statuses and
          error buffers.
        */
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(res_prm);
 
/*WS10082K* memset((char *)addinfo1,
               NULL_CHAR ,
               (envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                apiprm.script_kwd_num) *
                  sizeof(ADDINFO_rec_typ));   */
        /*WS10082A addinfo1->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_res_kwds+
                              apiprm.script_kwd_num;
        addinfo_res->max_pairs =
            envir_ptr->interest[envir_ptr->rss_num].num_res_kwds;  */
        ADDINFO_empty(addinfo1);                         /*WS10082A*/
        ADDINFO_empty(addinfo_res);                      /*WS10082A*/
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
        /*
          GET the resource details from message.
        */
        msg_ptr = CS_get_res (&res_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
        CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       res_prm.resource, res_prm.restype,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        /*
          PREPARE resource additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo_res ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
        /*
          PREPARE action additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo1 ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
 
        /*
          PROCESS when pre-script should be activated:
        */
        if ( apiprm.pre EQ CS_YES )
        {
 
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set resource.");
           if (func_name  NE FUNC_ADDRES)
           {
              memcpy((char *)&res_pre_prm,
                  (char *)&res_prm,
                  sizeof (RES_PARAMS_rec_typ));
               rc = CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDRES,
                    &res_pre_prm,
                    get_addinfo,
                    addinfo_res,
                    HOT_PATH_OFF);
           }
           ERROR_CLEAR(err_msg);
 
           rc_pre = CS_pre_post_res (SCRIPT_PRE , 1, &res_prm,
                       set_addinfo, get_addinfo, addinfo_res,
                       &apiprm, rc_act, rc_pre, &obj_exist);
           if (rc_pre EQ ESA_OK)
             CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
           else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
           else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
           else
            CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
           ERROR_COPY(&err_pre , err_msg);
           ERROR_CLEAR(err_msg);
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
 
 
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
        */
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES))
        {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set resource.");
        /*
            ACTIVATE the SET RESOURCE ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    -> SET for resource %s %s.",
				res_prm.resource, res_prm.restype);
          CS_DIAG_RESACL  (ESA_COMP_ACSSETF, 1, NULL, &res_prm,
			               NULL, &addinfo1, NULL, TRUE, NULL, 0, 0);
          switch (func_name)
          {
             case FUNC_ADDRES:
                ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSAddRes USA-API.");
                rc_act = envir_ptr->func_ptr.addres_ptr(&res_prm,
                                       addinfo1,
                                       &envir_ptr->msg_admin_param,
                                       err_msg);
                break;
             case FUNC_UPDRES:
                ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSUpdRes USA-API.");
                rc_act = envir_ptr->func_ptr.updres_ptr(&res_prm,
                                       addinfo1,
                                       &envir_ptr->msg_admin_param,
                                       err_msg);
                break;
             case FUNC_DELRES:
                ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"       Call to CTSDelRes USA-API.");
                rc_act = envir_ptr->func_ptr.delres_ptr(&res_prm,
                                       addinfo1,
                                       &envir_ptr->msg_admin_param,
                                       err_msg);
                break;
          }
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	     		"    <- SET for resource completed with rc_act=%d (%s)",
		      rc_act,(rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          if (rc_act EQ ESA_OK)
             CS_DIAG_RESACL  (ESA_COMP_ACSSETF, 1, NULL, &res_prm,
			               NULL, &addinfo1, NULL, TRUE, NULL, 0, 0);
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
 
          ERROR_COPY(&err_act , err_msg);
          ERROR_CLEAR(err_msg);
        } /* END - actual activation required */
        /*
          PROCESS when post-script activation is required:
        */
        if  (apiprm.post EQ CS_YES)
        {
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set resource.");
           memcpy((char *)&res_pre_prm,
                  (char *)&res_prm,
                  sizeof (RES_PARAMS_rec_typ));
           rc = CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_ADDRES,
                    &res_pre_prm,
                    get_addinfo,
                    addinfo_res,
                    HOT_PATH_OFF);
           rc_pst= CS_pre_post_res (SCRIPT_POST, 1, &res_prm,
			          set_addinfo, get_addinfo, addinfo_res,
                      &apiprm, rc_act, rc_pre, &obj_exist);
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst NE ESA_SKIP) {
             CTSAMSG_print (MSG_RES_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), res_prm.resource,
						   res_prm.restype);
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           NULL,
                           MSG_RES_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), res_prm.resource,
    					   res_prm.restype);
		  }
          ERROR_COPY(&err_pst , err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
        }  /* END - post-script activation required */
 
        /*
          PROCESS when HOST PATH is required:
        */
        if(
            envir_ptr->hot_path EQ HOT_PATH_ON
           OR
            envir_ptr->hot_path EQ HOT_PATH_FULL
            )
        {
              ERROR_CLEAR(err_msg);
              /*
                ACTIVATE resource's hot_path function.
              */
              rc= CS_pre_post_info_for_obj (
                         envir_ptr->msg_admin_param.rss_name,
                         FUNC_ADDRES,
                         &res_prm,
                         set_addinfo,
                         addinfo_res,
	                     HOT_PATH_ON);
 
              CLEAR(exists);
              if (rc EQ ESA_KEY_NOT_FOUND)
                 strcpy (exists,ENTITY_NOT_FOUND);
              else if (rc EQ ESA_SKIP)
                 strcpy (exists,ENTITY_ERR);
              else
                 strcpy (exists,ENTITY_FOUND);
 
        }
 
        else
            strcpy (exists ,ENTITY_UNKNOWN);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
            goto cleanup;
 
            /*
              ADD current respond buffer to respond message buffer.
            */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                set_addinfo[0],
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
           goto cleanup;
 
        if (msg_cd EQ NULL)
        {
           rc=ESA_FATAL;
           goto cleanup;
        }
 
        if ((rc EQ ESA_OK)                      AND
            (strcmp (exists,ENTITY_FOUND) EQ 0) AND
            (envir_ptr->hot_path EQ HOT_PATH_FULL)) {
          /*
            SET not last (and not temporary last) message type
            to respond.
          */
            CS_set_not_last_msg(msg_cd_ptr);
        }
        else
          /*
            SET "Temporary Last" message indicator in message header.
          */
            CS_set_tmp_last_msg(msg_cd_ptr);
 
        /*
          TRANSLATE function name to function code in respond
          message buffer.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
            goto cleanup;
        /*
          SEND respond message to ESS.
        */
        rc = CS_send_cd_msg (&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd_ptr);
 
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (
              (envir_ptr->hot_path EQ HOT_PATH_FULL)
             AND
              (rc EQ ESA_OK)
             AND
              (strcmp (exists,ENTITY_FOUND) EQ 0)
           )
        {
 
          /*
            REINITIALIZE the response buffer.
          */
           msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                                  &cd_num_msgs ,
                                  msg_cd ,
                                  msg_cd_ptr,
                                  msg_hdr);
 
           rc = CS_rsacl_get (&res_prm ,
                              set_addinfo[0] ,
                              NULL ,
                              msg_hdr ,
                              &msg_hdr_cd ,
                              tran ,
                              1 ,
                              FUNC_GTRSACL);
           if (rc NE ESA_OK)
              goto cleanup;
        } /* end if HOT_PATH_FULL*/
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal message requests */
 
      cleanup:
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo1);
      CSA_free ((char **)&addinfo2);
      CSA_free ((char **)&addinfo_res);
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
    } /* END - CS_res_set function */
 
/****************************************************
 * Procedure Name: CS_rssprm_set
 * Description   : RSS parameters sets function
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function that updates the RSS parameters.
 * The function receives a message with the "set" details that may
 * include several set RSSparams requests. It scans the input buffer
 * after all requests, analyses each request details - retrieving the
 * RSS details into the RSS parameters structure, activate the
 * PreScript (if needed) the API (if needed) and PostScript (if needed),
 * Retrieves the new RSS' details - in case HOT PATH is required,
 * prepares and sends a respons message back to the ESS.
 *********************************************************************/
 
    ESA_RC  CS_rssprm_set (MSG_typ               *  msg_ptr ,
                           RSS_MSG_HDR_rec_typ   *  msg_hdr,
                           TRAN_rec_typ          *  tran,
                           short                    func_name,
                           CTSAMSG_MSGID_typ        func_msg_code)
    {
      char fn[]="CS_rssprm_set";
      unsigned short        i;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ADDINFO_rec_typ     * addinfo1= NULL, *addinfo2= NULL;
      ADDINFO_rec_typ     * get_addinfo[1], * set_addinfo[1];
      ESA_RC                rc;
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      RSS_PARAMS_rec_typ    rss_prm, rss_pre_prm;
      OE_PARAMS_rec_typ     oe_prm;
      UG_PARAMS_rec_typ     ug_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIPRM_rec_typ     apiprm;
      RES_PARAMS_rec_typ    res_prm;
      char                  exists[26];
      ENVIRONMENT_rec_typ * envir_ptr;
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      addinfo1    = NULL;
      addinfo2    = NULL;
      msg_cd      = NULL;
 
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
      }
      /*
        RETRIEVE the current function pre/actual/post
        scripts parameters from RSSAPI parameters file.
      */
      rc = CS_db_prm_get (envir_ptr->msg_admin_param.rss_name ,
                          func_name,
                          &apiprm);
 
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        ALLOCATE memory for additional info.
      */
      rc= CSA_alloc ((char **)&addinfo1,
                     STRUC_ADDINFO,
/*WS10082K*          sizeof(ADDINFO_rec_typ) *    */
               (envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds+
                              apiprm.script_kwd_num) ,
                     1,
                     fn,
                     "addinfo1");
      if (rc NE ESA_OK)
        goto cleanup;
      if ((apiprm.pre EQ CS_YES ) OR (apiprm.post EQ CS_YES)) {
        rc= CSA_alloc ((char **)&addinfo2,
                        STRUC_ADDINFO,
/*WS10082K*             sizeof(ADDINFO_rec_typ) *    */
                envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds,
                        1,
                        fn,
                        "addinfo2");
        if (rc NE ESA_OK)
           goto cleanup;
/*WS10082K* memset((char *)addinfo2,
               NULL_CHAR ,
               envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds *
                  sizeof(ADDINFO_rec_typ));   */
        /*WS10082A addinfo2->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds;  */
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
      set_addinfo[0] = addinfo1;
      get_addinfo[0] = addinfo2;
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr,
                             msg_hdr);
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
 
        /*
          INITIALIZE the pre/actual/post scripts statuses and
          error buffers.
        */
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_RC_UNDEFINED;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        CLEAR_STRUCT(rss_prm);
/*WS10082K* memset((char *)addinfo1,
               NULL_CHAR ,
               (envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds+
                apiprm.script_kwd_num) *
                   sizeof(ADDINFO_rec_typ));   */
        /*WS10082A addinfo1->max_pairs=
            envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds+
                              apiprm.script_kwd_num;               */
        ADDINFO_empty(addinfo1);                         /*WS10082A*/
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
        /*
          ANALYZE the "RSS PARAMETERS" structure from message.
        */
        msg_ptr = CS_get_rss (&rss_prm , msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
        CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        /*
          PREPARE - additional information buffer.
        */
        msg_ptr = CS_get_addinfo (&addinfo1 ,
			                      msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
 
        /*
          PROCESS when pre-script should be activated:
        */
        if ( apiprm.pre EQ CS_YES ) {
 
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Pre script for set rss parameters.");
          memcpy((char *)&rss_pre_prm,
                  (char *)&rss_prm,
                  sizeof (RSS_PARAMS_rec_typ));
          rc = CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_GTRSPRM,
                    &rss_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
          ERROR_CLEAR(err_msg);
 
          rc_pre = CS_pre_post_rssprm (SCRIPT_PRE ,
                                             &rss_prm,
                                             set_addinfo,
                                             get_addinfo,
                                             &apiprm,
                                             rc_act,
                                             rc_pre);
           if (rc_pre EQ ESA_OK)
             CTSAMSG_print (MSG_PRESCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_SKIP)
             CTSAMSG_print (MSG_PRESCRIPT_SKIP,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pre EQ ESA_WARN)
             CTSAMSG_print (MSG_PRESCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
             CTSAMSG_print (MSG_PRESCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_pre));
           ERROR_COPY(&err_pre , err_msg);
           ERROR_CLEAR(err_msg);
           ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Pre script.");
        }
 
        /*
          PROCESS when actual activation required and the pre-script did
          not terminate with FATAL or SKIP result:
        */
        if ((rc_pre NE ESA_FATAL) AND
            (rc_pre NE ESA_SKIP ) AND
            (apiprm.act EQ CS_YES)) {
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Action for set rss parameters.");
          /*
            ACTIVATE the RSS SET PARAMS ESAAPI function.
          */
          rc= ADM_loginout (LOGIN_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
			"    -> Call to CTSSetRSSParams USA-API.");
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	        "     MinPwdLen=%d MaxExpire=%d MaxLogins=%d Err=%.*s.",
            rss_prm.min_pass_len, rss_prm.max_expire,
	        rss_prm.max_logins, err_msg->length, err_msg->err_msg_text);
          CS_DIAG_ADDINFO (ESA_COMP_ACSSETF, addinfo1, 0, TRUE);
          rc_act = envir_ptr->func_ptr.strsprm_ptr(&rss_prm,
                                         addinfo1,
                                         &envir_ptr->msg_admin_param,
                                         err_msg);
          CS_DIAG_ADDINFO (ESA_COMP_ACSSETF, addinfo1,0, TRUE);
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
			"    <- CTSSetRSSParams USA-API completed with rc_act=%d (%s)",
			rc_act, (rc_act EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
          rc= ADM_loginout (LOGOUT_MODE, LOGIN_ESS_ADMIN, fn);
          if (rc NE ESA_OK)
             goto cleanup;
          if (rc_act EQ ESA_OK)
            CTSAMSG_print (MSG_ACTUAL_OK,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
          ERROR_COPY(&err_act , err_msg);
          ERROR_CLEAR(err_msg);
 
        }/* END - actual activation required */
 
        /*
          PROCESS when post-script activation is required:
        */
        if (apiprm.post EQ CS_YES) {
          ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
             "*****>... Start Post script for set rss parameters.");
          memcpy((char *)&rss_pre_prm,
                  (char *)&rss_prm,
                  sizeof (RSS_PARAMS_rec_typ));
          rc = CS_pre_post_info_for_obj (
                    envir_ptr->msg_admin_param.rss_name,
                    FUNC_GTRSPRM,
                    &rss_pre_prm,
                    get_addinfo,
                    NULL,
                    HOT_PATH_OFF);
 
          rc_pst = CS_pre_post_rssprm (SCRIPT_POST ,
                                       &rss_prm,
                                       set_addinfo,
                                       get_addinfo,
                                       &apiprm,
                                       rc_act,
                                       rc_pre);
          if (rc_pst EQ ESA_OK)
            CTSAMSG_print (MSG_POSTSCRIPT_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else if (rc_pst EQ ESA_WARN)
             CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
          else {
             CTSAMSG_print (MSG_RSPRMPOSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn,rss_prm.min_pass_len,rss_prm.max_expire,
						   rss_prm.max_logins, ESA_rc2str(rc_pst));
             CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           NULL,
                           MSG_RSPRMPOSTSCRIPT_FAIL,
                           fn,rss_prm.min_pass_len,rss_prm.max_expire,
                           rss_prm.max_logins, ESA_rc2str(rc_pst));
		  }
          ERROR_COPY(&err_pst , err_msg);
          ERROR_CLEAR(err_msg);
      	  ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
        } /* END - post-script activation required */
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results pre:%d act:%d post%d",
                         rc_pre,
                         rc_act,
                         rc_pst);
 
 
        /*
          PROCESS when HOST PATH is required:
        */
        if(envir_ptr->hot_path EQ HOT_PATH_ON) {
 
          ERROR_CLEAR(err_msg);
 
          /*
            ACTIVATE resource's hot_path function (retrieve
            resource details).
          */
          rc= CS_pre_post_info_for_obj (
                     envir_ptr->msg_admin_param.rss_name,
                     FUNC_GTRSPRM,
                     &rss_prm,
                     set_addinfo,
                     NULL,
                     HOT_PATH_OFF);
 
          if ((rc EQ ESA_OK) OR (rc EQ ESA_KEY_NOT_FOUND))
             envir_ptr->func_ptr.trnsevnt_ptr (INTERCEPT_RSSPRM ,
                                  envir_ptr->empty_oe,
                                  envir_ptr->empty_user,
                                  envir_ptr->empty_ug,
                                  UPDCONN_NO,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
          CLEAR(exists);
          if (rc EQ ESA_WARN)
             strcpy (exists,ENTITY_ERR);
          else
             strcpy (exists,ENTITY_FOUND);
 
        }
 
        else strcpy (exists,ENTITY_UNKNOWN);
 
 
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
            goto cleanup;
 
        /*
          ADD current respond buffer to respond message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                addinfo1,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr ,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
 
        if (msg_cd EQ NULL) {
          rc=ESA_FATAL;
          goto cleanup;
        }
 
        rc= CS_queue_intercept_data ();
        if (rc NE ESA_OK)
          goto cleanup;
 
      } /* END - for loop on internal message requests */
 
      /*
        SET "Temporary Last" message indicator in message header.
      */
      CS_set_tmp_last_msg(msg_cd_ptr);
      /*
        TRANSLATE function name to function code in respond
        message buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
 
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo1);
      CSA_free ((char **)&addinfo2);
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
    } /* END - CS_rssprm_set function */
 
/****************************************************
 * Procedure Name: CS_ctsa_keys
 * Description   : control/sa load keys
 *
 * Input         :
 *
 * Input/Output  :
 *
 * Return Value  :
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is the actual function that updates the RSS
 * interesting keywords file.
 * The function receives a message with the "set" details that may
 * include several set keywords requests. It scans the input buffer
 * after all requests, analyses each request details - retrieving the
 * keyword's details into the keywords structure, activate the API,
 * prepares and sends a respons message back to the ESS.
 ******************************************************************/
 
    ESA_RC  CS_ctsa_keys  (MSG_typ               *  msg_ptr ,
                           RSS_MSG_HDR_rec_typ   *  msg_hdr,
                           TRAN_rec_typ          *  tran,
                           short                    func_name)
    {
      char fn[]="CS_ctsa_keys";
      ESA_RC                rc= ESA_OK;
      unsigned short        i;
      ADDINFO_rec_typ     * addinfo= NULL;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ESA_RC                rc_pre;
      ESA_RC                rc_act;
      ESA_RC                rc_pst;
      ERR_STRUCT_rec_typ    err_pre;
      ERR_STRUCT_rec_typ    err_act;
      ERR_STRUCT_rec_typ    err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      OE_PARAMS_rec_typ     oe_prm;
      UG_PARAMS_rec_typ     ug_prm;
      USER_PARAMS_rec_typ   usr_prm;
      U2UG_PARAMS_rec_typ   u2ug_prm;
      RSSAPIKWD_rec_typ   * apikey= NULL;
      RES_PARAMS_rec_typ    res_prm;
      RSS_PARAMS_rec_typ    rss_prm;
      char                  exists[26];
      ENVIRONMENT_rec_typ * envir_ptr;
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      rc = ESA_OK;
      msg_cd      = NULL;
 
      ERROR_CLEAR(&err_pre);
      ERROR_CLEAR(&err_pst);
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
      }
      /*
        ALLOCATE memory for the response message.
      */
      rc= CSA_alloc ((char **)&addinfo, STRUC_ADDINFO,
/*WS10082K*            sizeof(ADDINFO_rec_typ),      */
                     1,
/*WS10082K*/         1,
                     fn,
                     "addinfo");
      if (rc NE ESA_OK)
        goto cleanup;
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr,
                             msg_hdr);
 
 
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (i =0 ; i LT num_msgs; i++) {
 
        rc_pre = ESA_RC_UNDEFINED;
        rc_act = ESA_OK;
        rc_pst = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_pre);
        ERROR_CLEAR(&err_act);
        ERROR_CLEAR(&err_pst);
 
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
        /*
          ANALYZE the "INTERESTING KEYWORDS" structure from message.
        */
        msg_ptr= CS_get_cntrlsa_keys (&apikey, msg_ptr);
        if (msg_ptr EQ NULL) {
            rc= ESA_ERR;
            goto cleanup;
        }
      /*  strcpy(apikey.rss , envir_ptr->msg_admin_param.rss_name);*/
 
        ERROR_CLEAR(err_msg);
        /*
          UPDATE the interesting keywords file.
        */
        if ((apikey NE NULL) AND (apikey->num_keywords NE 0))
           rc_act = CS_db_key_put (apikey);
      /*
        ALLOCATE memory for additional info.
      */
        if (rc NE ESA_OK)
           goto cleanup;
 
        ERROR_COPY(&err_act , err_msg);
        ERROR_CLEAR(err_msg);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 30,
			"rc_act=%d.", (int)rc_act);
        if (rc_act EQ ESA_OK)
          CTSAMSG_print (MSG_ACTUAL_OK,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest);
        else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
        else
          CTSAMSG_print (MSG_ACTUAL_FAIL,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest,
                         ESA_rc2str(rc_act));
 
        if (rc_act NE ESA_OK)
          strcpy (exists,ENTITY_NOT_FOUND);
        else
          strcpy (exists,ENTITY_FOUND);
 
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
            goto cleanup;
 
        /*
          ADD current respond buffer to respond message buffer.
        */
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                envir_ptr->hot_path,
                                &oe_prm,
                                &ug_prm,
                                &usr_prm,
                                &u2ug_prm,
                                &res_prm,
                                &rss_prm,
                                exists,
                                addinfo,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr ,
                                rc_pre,
                                rc_act,
                                rc_pst,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
 
        if (rc NE ESA_OK)
          goto cleanup;
 
        if (msg_cd EQ NULL) {
          rc=ESA_FATAL;
          goto cleanup;
        }
      } /* END - for loop on internal message requests */
 
      /*
        SET "Temporary Last" message indicator in message header.
      */
      CS_set_tmp_last_msg(msg_cd_ptr);
      /*
        TRANSLATE function name to function code in respond
        message buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
 
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
      CSA_free ((char **)&addinfo);
      CSA_free ((char **)&apikey);
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
    } /* END - CS_ctsa_keys function */
 
/****************************************************
 * Procedure Name: CS_pre_post_info_for_obj
 * Description   : Retrieve USER/GROUP/CONNECTION/OE/RES/RSS
 *                  details
 * Return Value  : ESA_RC
 * Comments      :
 * Scope         :
 ****************************************************
 *
 * DETAILED DESCRIPTION
 * ====================
 *
 * This function is activated as part of HOT PATH for usrs,groups
 * and connections in order to retrieve the object details after an
 * ESS request was handled. The function prepares the specific
 * object's keywords according to the current RSS, login to the system,
 * retrievs the objewct's details for the SPECIFIC object, logouts and
 * exits.
 ****************************************************************/
 
ESA_RC CS_pre_post_info_for_obj (RSS_typ           rss,
                                 short             api,
                                 void            * account_str,
                                 ADDINFO_rec_ptr   addinfo[1],
                                 ADDINFO_rec_typ * res_addinfo,
                                 HOT_PATH_typ      hot_path)
    {
      char fn[]="CS_pre_post_info_for_obj";
      ESA_RC                rc,rc_logout=ESA_OK,rc_pst=ESA_OK;
      RSSAPIPRM_rec_typ     apiprm;
      RSSAPIKWD_rec_typ   * bufk= NULL;
 
      KWD_typ kwd_types_on= {KWD_FOR_ADDINFO_1A_CHECK,
                             KWD_FOR_ADDINFO_1A,
                             KWD_FOR_ADDINFO_1B_CHECK,
                             KWD_FOR_ADDINFO_1B,
                             0,0,
                             KWD_FOR_ADDINFO_2A_CHECK,
                             KWD_FOR_ADDINFO_2A,
                             KWD_FOR_ADDINFO_2B_CHECK,
                             KWD_FOR_ADDINFO_2B};
 
      KWD_typ kwd_types_off={KWD_FOR_ADDINFO_1A_CHECK,
                             KWD_FOR_ADDINFO_1A,
                             KWD_FOR_ADDINFO_1B_CHECK,
                             KWD_FOR_ADDINFO_1B,
                             KWD_FOR_ENTITY_CHECK,
                             KWD_FOR_ENTITY_INFO,
                             KWD_FOR_ADDINFO_2A_CHECK,
                             KWD_FOR_ADDINFO_2A,
                             KWD_FOR_ADDINFO_2B_CHECK,
                             KWD_FOR_ADDINFO_2B};
 
      void                * handle= NULL, * handle_log_evnt= NULL;
      OE_typ                oe;
      OE_PARAMS_rec_typ     oe_prm_out,  * oe_prm_in;
      UG_PARAMS_rec_typ     ug_prm_out,  * ug_prm_in;
      USER_PARAMS_rec_typ   usr_prm_out, * usr_prm_in;
      U2UG_PARAMS_rec_typ * u2ug_prm= NULL;
      RSS_PARAMS_rec_typ  * rss_prm= NULL;
      RES_PARAMS_rec_typ    res_prm_out[1], * res_prm_in;
      OBJ_EXISTS_typ        obj_exist;
      short                 structure_id= 0, func_name, actual_num= 0;
	  short                 actual_num_free= 0;
      USER_typ              usr[1];
      UG_typ                ug[1];
      HAVE_MORE_typ         have_more;
      int                   num_rss_api_kwds= 0;
      ENVIRONMENT_rec_typ * envir_ptr;
      char                  get_conn = 'N'; /* AC001 - CIQ#6 */
      /* WS10075 - Start */
      int                   no_of_attrs=0;
   /* char                  kwds_to_remove[3][30] = { WS10079K*/
   /* char                  kwds_to_remove[10][35] = {    *WS10082M*/
      char                  kwds_to_remove[12][35] = {   /*WS10082M*/
                                          "ACCOUNTDIRECTPERMISSIONS",
                                          "ACCOUNTINDIRECTPERMISSIONS",
                                          "GROUPDIRECTPERMISSIONS",
      /* WS10079K */                      "AccountRoleDirectPermissions",
      /* WS10079K */                      "AccountRoleIndirectPermissions",
      /* WS10081  */                      "MFA.ACTIVE",
      /* WS10081  */                      "MFA.TAGS",
      /* WS10079K */                      "RoleDirectPermissions",
      /* WS10079K */                      "Roles",
      /* WS10079K */                      "Sources",
      /* WS10079K */                      "RoleGroups",
      /* WS10079K */                      "SourceGroups"
                                                    };
      ONE_FIELD_rec_ptr     pair = NULL;
      /* WS10075 - Ends */
      CS_get_envir_address (&envir_ptr);
      /*IS10166*/
      if(envir_ptr->iiq_version GT 0)
      {
        get_conn = 'Y';
        /* WS10070 - start */
        if(envir_ptr->iiq_version GE 2)
           get_conn = 'P';
        /* WS10070 - end */
      }
      ESA_DIAG_printf(ESA_COMP_ACSSETF,DIAG_BASIC,
               "*****>... Get Connection=%c", get_conn);
      /*IS10166-End*/
      ESA_DIAG_enter  (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
      ESA_DIAG_printf (ESA_COMP_ACSSETF, 13,
                       "%s: rss %s,api %d", fn, rss, (int)api);
 
      CLEAR_STRUCT (obj_exist);
      CLEAR_STRUCT (oe_prm_out);
      CLEAR_STRUCT (ug_prm_out);
      CLEAR_STRUCT (usr_prm_out);
      CLEAR (oe);
      CLEAR (ug);
      CLEAR (usr);
 
      if      (api EQ FUNC_ADDUSER)
      {
         func_name= FUNC_GTUSERS;
         structure_id= STRUC_USER_REC;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_usr_kwds;
         usr_prm_in= (USER_PARAMS_rec_typ *)account_str;
      }
      else if (api EQ FUNC_ADDUG)
      {
         func_name= FUNC_GETUGS;
         structure_id= STRUC_UG_REC;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_ug_kwds;
         ug_prm_in= (UG_PARAMS_rec_typ *)account_str;
      }
      /* WS10079K - Start */
      else if (api EQ FUNC_ADDXROL)
      {
         func_name= FUNC_GETXROL;
         structure_id= STRUC_UG_REC;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_xrol_kwds;
         ug_prm_in= (UG_PARAMS_rec_typ *)account_str;
         apiprm.script_kwd_num = 0;
 
      }
      else if (api EQ FUNC_ADDXSGP)
      {
         func_name= FUNC_GETXSGP;
         structure_id= STRUC_UG_REC;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_xsgp_kwds;
         ug_prm_in= (UG_PARAMS_rec_typ *)account_str;
         apiprm.script_kwd_num = 0;
 
         ESA_DIAG_printf(ESA_COMP_ACSSETF, 9,
              "API is ADDXSGP: num_rss_api_kwds=%d,script_kwd_num=%d",
               num_rss_api_kwds, apiprm.script_kwd_num);
      }
      /* WS10079K - End */
      else if (api EQ FUNC_ADDOE)
      {
         func_name= FUNC_GETOES;
         structure_id= STRUC_OE_REC;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_oe_kwds;
         oe_prm_in= (OE_PARAMS_rec_typ *)account_str;
      }
      else if (api EQ FUNC_ADDU2UG)
      {
         func_name= FUNC_GTUG2UC;
         structure_id= STRUC_U2UG_REC;
         u2ug_prm= (U2UG_PARAMS_rec_typ *)account_str;
         strcpy (usr[0], u2ug_prm->user);
         strcpy (ug[0],  u2ug_prm->group);
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_u2ug_kwds;
      }
      else if (api EQ FUNC_GTRSPRM)
      {
         func_name= FUNC_GTRSPRM;
         structure_id= STRUC_RSS_REC;
         rss_prm= (RSS_PARAMS_rec_typ *)account_str;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_rss_kwds;
      }
      else if (api EQ FUNC_ADDRES)
      {
         func_name= FUNC_GETRES;
         structure_id= STRUC_RES_REC;
         num_rss_api_kwds=
             envir_ptr->interest[envir_ptr->rss_num].num_res_kwds;
         res_prm_in= (RES_PARAMS_rec_typ *)account_str;
      }
      else
      {
            rc= ESA_ERR;
            CTSAMSG_print (ERR_CS_NBR2STR,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       fn, C_API, (int)api);
            goto cleanup;
      }
 
      if((api NE FUNC_ADDXROL) AND (api NE FUNC_ADDXSGP)) /*WS10079K*/
      {                                                   /*WS10079K*/
       rc = CS_db_prm_get (rss, func_name ,&apiprm);
      if (rc NE ESA_OK)
        goto cleanup;
      }                                                   /*WS10079K*/
 
 
      rc= CSA_alloc ((char **)&bufk,
                     0,
                     (sizeof(KWD_rec_typ) * num_rss_api_kwds) +
                        sizeof(RSSAPIKWD_rec_typ),
                     1,
                     fn,
                     "Rss-Api accounts keywords");
      if (rc NE ESA_OK)
        goto cleanup;
      if ((rc= CS_db_key_get (rss, api, bufk)) NE ESA_OK)
        goto cleanup;
 
      CS_fill_key (addinfo,
             bufk,
             (hot_path EQ HOT_PATH_OFF) ?
                 kwd_types_off
                 :
                 kwd_types_on,
             1,
             (hot_path EQ HOT_PATH_OFF) ?
                 num_rss_api_kwds
                 :
                 num_rss_api_kwds+ apiprm.script_kwd_num);
 
      /* WS10075 - Dont send permission attributes if get is   *
       *           not for hotpath                             */
      if (hot_path EQ HOT_PATH_OFF)
      {
         ESA_DIAG_printf(ESA_COMP_ACSSETF, 9, "Hotpath is OFF");
 
         no_of_attrs = ( sizeof(kwds_to_remove) /
                                 sizeof(kwds_to_remove[0]) );
         ESA_DIAG_printf(ESA_COMP_ACSSETF, 9, "no_of_attrs (%i)",
                         no_of_attrs);
         no_of_attrs--;
         while(no_of_attrs GE 0)
         {
            ESA_DIAG_printf(ESA_COMP_ACSSETF, 15,
                            "Checking kwd %s (%i) in addinfo",
                            kwds_to_remove[no_of_attrs], no_of_attrs);
 
            pair=ADDINFO_search(kwds_to_remove[no_of_attrs],
                                ACF_ADDINFO_KWD_LEN,
                                addinfo[0]->pair,
                                addinfo[0]->num_pairs);
            if(pair NE NULL)
            {
               ESA_DIAG_printf(ESA_COMP_ACSSETF, 9,
                            "Deleting kwd %s (%i) in addinfo",
                            kwds_to_remove[no_of_attrs], no_of_attrs);
               rc = ADDINFO_delete(addinfo[0],
                                         kwds_to_remove[no_of_attrs]);
               if(rc NE ESA_OK)
               {
                  ESA_DIAG_printf(ESA_COMP_ACSSETF, 3,
                           "Failed to remove attribute %s from addinfo",
                           kwds_to_remove[no_of_attrs]);
               }
            }
            else
            {
                ESA_DIAG_printf(ESA_COMP_ACSSETF, 3,
                                "kwd %s not found in addinfo",
                                kwds_to_remove[no_of_attrs]);
            }
            no_of_attrs--;
         }
      }
      else
      {
          ESA_DIAG_printf(ESA_COMP_ACSSETF, 9,
                   "hotpath is ON ");
      }
      /* WS10075 - Ends */
      /*
        PROCESS according to the function activation motivation:
      */
      switch (api) {
        case FUNC_ADDUSER:
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               goto cleanup;
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	          "    -> Call to CTSGetUsers USA-API for user=%s.", usr_prm_in->user);
            CS_DIAG_USER_IN (ESA_COMP_ACSSETF, GET_MANY_USERS, oe,
				1, 1, (USER_PARAMS_rec_typ *)account_str,
				handle, addinfo);
            rc= envir_ptr->func_ptr.gtusers_ptr (GET_MANY_USERS,
                               oe,
                               1,
                               &actual_num,
                               &have_more,
                               &handle,
                               1,
                               (USER_PARAMS_rec_typ *)account_str,
                               &usr_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err,
                               get_conn); /* AC001 - CIQ#6 */
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	          "    <- CTSGetUsers USA-API completed with rc=%d (%s).",
			  rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
            if (rc EQ ESA_OK)
               CS_DIAG_USER_OUT (ESA_COMP_ACSSETF, oe, actual_num, have_more,
		    	   &usr_prm_out, &obj_exist, handle, addinfo);
 
            rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
            memcpy ((char *)account_str,
                    (char *)(&usr_prm_out),
                    sizeof (USER_PARAMS_rec_typ));
 
            if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                 "*****>... Start Post script for get user.");
               rc_pst = CS_pre_post_users(SCRIPT_POST, 1,
                            &usr_prm_out, addinfo, NULL,
                            &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
               if (
				     (rc_pst NE ESA_OK)
					AND
					 (rc_pst NE ESA_WARN)
					AND
					 (rc_pst NE ESA_SKIP)
			  	  )
			   {
                  CTSAMSG_print (MSG_USR_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), usr_prm_out.user);
                  CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_log_evnt,
                           MSG_USR_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), usr_prm_out.user);
			   }
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
			}
            if (handle NE NULL) {
               ESA_RC rcc;
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    -> Call to CTSGetUsers USA-API with GET_FREE_HANDLE_USERS mode.");
               CS_DIAG_USER_IN (ESA_COMP_ACSSETF,GET_FREE_HANDLE_USERS,
				   oe, 0, 0, (USER_PARAMS_rec_typ *)account_str,
		    		handle, addinfo);
               rcc= envir_ptr->func_ptr.gtusers_ptr (
                               GET_FREE_HANDLE_USERS,
                               oe,
                               1,
                               &actual_num_free,
                               &have_more,
                               &handle,
                               1,
                               (USER_PARAMS_rec_typ *)account_str,
                               &usr_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err,
                               get_conn); /* AC001 - CIQ#6 */
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetUsers USA-API completed with rc=%d (%s).",
			      rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
               if (rcc EQ ESA_OK)
                  CS_DIAG_USER_OUT (ESA_COMP_ACSSETF, oe, 0, have_more,
			         &usr_prm_out, &obj_exist, handle, addinfo);
			}
            break;
        case FUNC_ADDOE:
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               goto cleanup;
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	          "    -> Call to CTSGetOEs USA-API for container=%s.",oe_prm_in->oe);
            CS_DIAG_OE_IN (ESA_COMP_ACSSETF, GET_MANY_OES, oe,
			1, 1, (OE_PARAMS_rec_typ *)account_str, handle, addinfo);
            rc= envir_ptr->func_ptr.getoes_ptr (GET_MANY_OES,
                               oe,
                               1,
                               &actual_num,
                               &have_more,
                               &handle,
                               1,
                               (OE_PARAMS_rec_typ *)account_str,
                               &oe_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetOEs USA-API completed with rc=%d (%s).",
			      rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
            if (rc EQ ESA_OK)
               CS_DIAG_OE_OUT (ESA_COMP_ACSSETF, oe, actual_num, have_more,
		    	   &oe_prm_out, &obj_exist, handle, addinfo);
 
            rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
            memcpy ((char *)account_str,
                    (char *)(&oe_prm_out),
                    sizeof (OE_PARAMS_rec_typ));
 
            if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                 "*****>... Start Post script for get container.");
               rc_pst = CS_pre_post_oe(SCRIPT_POST, 1,
                            &oe_prm_out, addinfo, NULL,
                            &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
               if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_WARN) ) {
                  CTSAMSG_print (MSG_OE_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), oe_prm_out.oe);
                  CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_log_evnt,
                           MSG_OE_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), oe_prm_out.oe);
			   }
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
			}
			if (handle NE NULL)
			{
               ESA_RC rcc;
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    -> Call to CTSGetOEs USA-API with GET_FREE_HANDLE_OES mode.");
               CS_DIAG_OE_IN (ESA_COMP_ACSSETF, GET_FREE_HANDLE_OES,oe,
		    		0, 0, (OE_PARAMS_rec_typ *)account_str,
					handle, addinfo);
               rcc= envir_ptr->func_ptr.getoes_ptr( GET_FREE_HANDLE_OES,
                               oe,
                               1,
                               &actual_num_free,
                               &have_more,
                               &handle,
                               1,
                               (OE_PARAMS_rec_typ *)account_str,
                               &oe_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetOEs USA-API completed with rc=%d (%s).",
			      rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
               if (rcc EQ ESA_OK)
                  CS_DIAG_OE_OUT (ESA_COMP_ACSSETF, oe, 0, have_more,
		        	   &oe_prm_out, &obj_exist, handle, addinfo);
			}
            break;
        case FUNC_ADDUG:
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               goto cleanup;
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	          "    -> Call to CTSGetUGs USA-API for user group=%s.",ug_prm_in->group);
            CS_DIAG_UG_IN (ESA_COMP_ACSSETF, GET_MANY_GROUPS, oe,
				1, 1, (UG_PARAMS_rec_typ *)account_str,
				handle, addinfo);
            rc= envir_ptr->func_ptr.getugs_ptr (GET_MANY_GROUPS,
                               oe,
                               1,
                               &actual_num,
                               &have_more,
                               &handle,
                               1,
                               (UG_PARAMS_rec_typ *)account_str,
                               &ug_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetUGs USA-API completed with rc=%d (%s).",
			      rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
            if (rc EQ ESA_OK)
               CS_DIAG_UG_OUT (ESA_COMP_ACSSETF, oe, actual_num, have_more,
		    	   &ug_prm_out, &obj_exist, handle, addinfo);
 
            rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
            memcpy ((char *)account_str,
                    (char *)(&ug_prm_out),
                    sizeof (UG_PARAMS_rec_typ));
            if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                 "*****>... Start Post script for get user group.");
               rc_pst = CS_pre_post_ug(SCRIPT_POST, 1,
                            &ug_prm_out, addinfo, NULL,
                            &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
               if (
				     (rc_pst NE ESA_OK)
				    AND
					 (rc_pst NE ESA_WARN)
                    AND
					 (rc_pst NE ESA_SKIP)
			 	  )
			   {
                  CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), ug_prm_out.group);
                  CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_log_evnt,
                           MSG_UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), ug_prm_out.group);
			   }
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
			}
            if (handle NE NULL)
			{
               ESA_RC rcc;
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    -> Call to CTSGetUGs USA-API with GET_FREE_HANDLE_GROUPS mode.");
               CS_DIAG_UG_IN (ESA_COMP_ACSSETF, GET_FREE_HANDLE_GROUPS,
				   oe, 0, 0, (UG_PARAMS_rec_typ *)account_str,
			    	handle, addinfo);
               rcc= envir_ptr->func_ptr.getugs_ptr (
                               GET_FREE_HANDLE_GROUPS,
                               oe,
                               1,
                               &actual_num_free,
                               &have_more,
                               &handle,
                               1,
                               (UG_PARAMS_rec_typ *)account_str,
                               &ug_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetOEs USA-API completed with rc=%d (%s).",
			      rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
               if (rcc EQ ESA_OK)
                  CS_DIAG_UG_OUT (ESA_COMP_ACSSETF, oe, 0, have_more,
			         &ug_prm_out, &obj_exist, handle, addinfo);
			}
            break;
   /* WS10079K - Start */
   case FUNC_ADDXROL:
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	                        "-> Call to CTSGetUGs USA-API for Role=%s.",
	                        ug_prm_in->group);
        CS_DIAG_UG_IN (ESA_COMP_ACSSETF, GET_MANY_GROUPS, oe,
				                   1, 1, (UG_PARAMS_rec_typ *)account_str,
				                   handle, addinfo);
        rc= envir_ptr->func_ptr.getugs_ptr (GET_MANY_ROLES,
                                    oe,
                                    1,
                                    &actual_num,
                                    &have_more,
                                    &handle,
                                    1,
                                    (UG_PARAMS_rec_typ *)account_str,
                                    &ug_prm_out,
                                    addinfo,
                                    &obj_exist,
                                    &envir_ptr->msg_admin_param,
                                    &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	             "<- CTSGetUGs USA-API completed with rc=%d (%s).",
			               rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc EQ ESA_OK)
           CS_DIAG_UG_OUT (ESA_COMP_ACSSETF, oe, actual_num, have_more,
		    	                    &ug_prm_out, &obj_exist, handle, addinfo);
 
        rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
        memcpy ((char *)account_str,
                (char *)(&ug_prm_out),
                sizeof (UG_PARAMS_rec_typ));
   /* We dont want to call post script for Roles for now *
    * hence commenting following code. When we want to   *
    * support post script we can uncomment the code.     */
   /******
   if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                       "*****>... Start Post script for get Role.");
      rc_pst = CS_pre_post_ug(SCRIPT_POST, 1,
                           &ug_prm_out, addinfo, NULL,
                           &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
      if ( (rc_pst NE ESA_OK)
				      AND
					      (rc_pst NE ESA_WARN)
          AND
					      (rc_pst NE ESA_SKIP)
			 	    )
			   {
         CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                        envir_ptr->msg_admin_param.ctsamsg_handle,
                        NULL,
                        envir_ptr->msg_admin_param.ctsamsg_dest,
                        fn, ESA_rc2str(rc_pst), ug_prm_out.group);
         CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                      envir_ptr->msg_admin_param.rss_name,
                      handle_log_evnt,
                      MSG_UG_POSTSCRIPT_FAIL,
                      fn, ESA_rc2str(rc_pst), ug_prm_out.group);
			   }
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                    "<*****... End Post script.");
			}
   *********/
   if (handle NE NULL)
			{
      ESA_RC rcc;
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	 "-> Call CTSGetUGs USA-API with GET_FREE_HANDLE_GROUPS mode.");
      CS_DIAG_UG_IN (ESA_COMP_ACSSETF, GET_FREE_HANDLE_GROUPS,
				                 oe, 0, 0, (UG_PARAMS_rec_typ *)account_str,
			    	             handle, addinfo);
      rcc= envir_ptr->func_ptr.getugs_ptr (
                               GET_FREE_HANDLE_GROUPS,
                               oe,
                               1,
                               &actual_num_free,
                               &have_more,
                               &handle,
                               1,
                               (UG_PARAMS_rec_typ *)account_str,
                               &ug_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          " <- CTSGetOEs USA-API completed with rc=%d (%s).",
			            rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rcc EQ ESA_OK)
         CS_DIAG_UG_OUT (ESA_COMP_ACSSETF, oe, 0, have_more,
			                      &ug_prm_out, &obj_exist, handle, addinfo);
			}
   break;
 
   case FUNC_ADDXSGP:
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
            goto cleanup;
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	                        "-> Call to CTSGetUGs USA-API for Source=%s.",
	                        ug_prm_in->group);
        CS_DIAG_UG_IN (ESA_COMP_ACSSETF, GET_MANY_GROUPS, oe,
				                   1, 1, (UG_PARAMS_rec_typ *)account_str,
				                   handle, addinfo);
        rc= envir_ptr->func_ptr.getugs_ptr (GET_MANY_SOURCES,
                                    oe,
                                    1,
                                    &actual_num,
                                    &have_more,
                                    &handle,
                                    1,
                                    (UG_PARAMS_rec_typ *)account_str,
                                    &ug_prm_out,
                                    addinfo,
                                    &obj_exist,
                                    &envir_ptr->msg_admin_param,
                                    &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	             "<- CTSGetUGs USA-API completed with rc=%d (%s).",
			               rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
        if (rc EQ ESA_OK)
           CS_DIAG_UG_OUT (ESA_COMP_ACSSETF, oe, actual_num, have_more,
		    	                    &ug_prm_out, &obj_exist, handle, addinfo);
 
        rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
        memcpy ((char *)account_str,
                (char *)(&ug_prm_out),
                sizeof (UG_PARAMS_rec_typ));
   /* We dont want to call post script for Sources for   *
    * now hence commenting following code. When we want  *
    * to support post script we can uncomment the code.  */
   /******
   if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                       "*****>... Start Post script for get Role.");
      rc_pst = CS_pre_post_ug(SCRIPT_POST, 1,
                           &ug_prm_out, addinfo, NULL,
                           &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
      if ( (rc_pst NE ESA_OK)
				      AND
					      (rc_pst NE ESA_WARN)
          AND
					      (rc_pst NE ESA_SKIP)
			 	    )
			   {
         CTSAMSG_print (MSG_UG_POSTSCRIPT_FAIL,
                        envir_ptr->msg_admin_param.ctsamsg_handle,
                        NULL,
                        envir_ptr->msg_admin_param.ctsamsg_dest,
                        fn, ESA_rc2str(rc_pst), ug_prm_out.group);
         CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                      envir_ptr->msg_admin_param.rss_name,
                      handle_log_evnt,
                      MSG_UG_POSTSCRIPT_FAIL,
                      fn, ESA_rc2str(rc_pst), ug_prm_out.group);
			   }
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                    "<*****... End Post script.");
			}
   *********/
   if (handle NE NULL)
			{
      ESA_RC rcc;
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	 "-> Call CTSGetUGs USA-API with GET_FREE_HANDLE_GROUPS mode.");
      CS_DIAG_UG_IN (ESA_COMP_ACSSETF, GET_FREE_HANDLE_GROUPS,
				                 oe, 0, 0, (UG_PARAMS_rec_typ *)account_str,
			    	             handle, addinfo);
      rcc= envir_ptr->func_ptr.getugs_ptr (
                               GET_FREE_HANDLE_GROUPS,
                               oe,
                               1,
                               &actual_num_free,
                               &have_more,
                               &handle,
                               1,
                               (UG_PARAMS_rec_typ *)account_str,
                               &ug_prm_out,
                               addinfo,
                               &obj_exist,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
      ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          " <- CTSGetOEs USA-API completed with rc=%d (%s).",
			            rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
      if (rcc EQ ESA_OK)
         CS_DIAG_UG_OUT (ESA_COMP_ACSSETF, oe, 0, have_more,
			                      &ug_prm_out, &obj_exist, handle, addinfo);
			}
   break;
   /* WS10079K - End */
        case FUNC_ADDU2UG:
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               goto cleanup;
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	          "    -> Call to CTSGetConns USA-API for user=%s to group=%s connection.",
			  usr[0], ug[0]);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"...-> getug2uc_ptr.");
            CS_DIAG_UG2UC_IN (ESA_COMP_ACSSETF, GET_MANY_CONNS, 1, 1,
		    	1, ug, usr, handle, addinfo);
            rc= envir_ptr->func_ptr.gtug2uc_ptr (GET_MANY_CONNS,
                                       1,
                                       &actual_num,
                                       &have_more,
                                       &handle,
                                       1,
                                       1,
                                       ug,
                                       usr,
                                       u2ug_prm,
                                       addinfo,
                                       &obj_exist,
                                       &envir_ptr->msg_admin_param,
                                       &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetConns USA-API completed with rc=%d (%s).",
			      rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
            if (rc EQ ESA_OK)
               CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSETF, actual_num, have_more,
		    	   u2ug_prm, &obj_exist, handle, addinfo);
 
		    rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
            if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                 "*****>... Start Post script for get user to group connection.");
               rc_pst = CS_pre_post_u2ug(SCRIPT_POST,1,
                            u2ug_prm, addinfo, NULL,
                            &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
               if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_WARN) ) {
                  CTSAMSG_print (MSG_U2UG_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst), u2ug_prm->group,
						   u2ug_prm->user);
                  CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_log_evnt,
                           MSG_U2UG_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst), u2ug_prm->group,
						   u2ug_prm->user);
			   }
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
			}
            if (handle NE NULL)
			{
              ESA_RC rcc;
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	          "    -> Call to CTSGetConns USA-API with GET_FREE_HANDLE_CONNS mode.");
              CS_DIAG_UG2UC_IN (ESA_COMP_ACSSETF,GET_FREE_HANDLE_CONNS,
				  0, 0, 0, ug, usr, handle, addinfo);
              rcc=envir_ptr->func_ptr.gtug2uc_ptr(GET_FREE_HANDLE_CONNS,
                                       1,
                                       &actual_num_free,
                                       &have_more,
                                       &handle,
                                       1,
                                       1,
                                       ug,
                                       usr,
                                       u2ug_prm,
                                       addinfo,
                                       &obj_exist,
                                       &envir_ptr->msg_admin_param,
                                       &envir_ptr->msg_err);
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetConns USA-API completed with rc=%d (%s).",
			      rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
              if (rcc EQ ESA_OK)
                 CS_DIAG_UG2UC_OUT (ESA_COMP_ACSSETF, 0, have_more,
			        u2ug_prm, &obj_exist, handle, addinfo);
			}
            break;
        case FUNC_GTRSPRM:
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               goto cleanup;
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
		      "    -> Call to CTSGetRSSParams USA-API.");
            CS_DIAG_ADDINFO (ESA_COMP_ACSSETF, addinfo[0], 0, FALSE);
            rc= envir_ptr->func_ptr.gtrsprm_ptr (rss_prm,
                               addinfo[0],
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	           "     MinPwdLen=%d MaxExpire=%d MaxLogins=%d Err=%.*s.",
               rss_prm->min_pass_len, rss_prm->max_expire,
	           rss_prm->max_logins, envir_ptr->msg_err.length,
			   envir_ptr->msg_err.err_msg_text);
            if (rc EQ ESA_OK)
               CS_DIAG_ADDINFO (ESA_COMP_ACSSETF, addinfo[0], 0, TRUE);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
    	          "    <- CTSGetRSSParams USA-API completed with rc=%d (%s).",
			      rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
            if (rc EQ ESA_OK)
            {
              obj_exist= OBJ_EXIST;
              actual_num= 1;
            }
            rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
            if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                 "*****>... Start Post script for get rss parameter.");
               rc_pst = CS_pre_post_rssprm (SCRIPT_POST ,
                          rss_prm, addinfo, NULL,
                          &apiprm, rc, ESA_RC_UNDEFINED);
               if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_WARN) ) {
                  CTSAMSG_print (MSG_RSPRMPOSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           rss_prm->min_pass_len, rss_prm->max_expire,
                           rss_prm->max_logins, ESA_rc2str(rc_pst));
                  CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_log_evnt,
                           MSG_RSPRMPOSTSCRIPT_FAIL,
                           rss_prm->min_pass_len, rss_prm->max_expire,
                           rss_prm->max_logins, ESA_rc2str(rc_pst));
			   }
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
			}
            break;
        case FUNC_ADDRES:
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               goto cleanup;
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"    -> Call to CTSGetRes USA-API for resource=%s %s.",
		    	res_prm_in->resource, res_prm_in->restype);
            CS_DIAG_RESACL_IN (ESA_COMP_ACSSETF, GET_MANY_RESOURCES,
				oe, 1, (RES_PARAMS_rec_typ *)account_str, NULL,
				res_addinfo, handle, addinfo);
            rc= envir_ptr->func_ptr.getres_ptr (GET_MANY_RESOURCES,
                               oe,
                               1,
                               &actual_num,
                               &have_more,
                               &handle,
                               (RES_PARAMS_rec_typ *)account_str,
                               res_addinfo,
                               res_prm_out,
                               addinfo,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"    <- CTSGetRes USA-API completed with rc=%d (%s).",
    			rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
            if (rc EQ ESA_OK)
               CS_DIAG_RESACL_OUT (ESA_COMP_ACSSETF, oe, actual_num,
		    		have_more, res_prm_out, NULL, NULL, handle, addinfo);
 
            if (rc EQ ESA_OK)
              obj_exist= OBJ_EXIST;
            rc_logout=ADM_loginout(LOGOUT_MODE,LOGIN_DEFAULT_ADMIN,fn);
            memcpy ((char *)account_str,
                    (char *)(&res_prm_out[0]),
                    sizeof (RES_PARAMS_rec_typ));
            if ((apiprm.post EQ CS_YES) AND (hot_path EQ HOT_PATH_ON)) {
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                 "*****>... Start Post script for get resource.");
               rc_pst = CS_pre_post_res (SCRIPT_POST , 1,
                      res_prm_out, addinfo, NULL, res_addinfo,
                      &apiprm, rc, ESA_RC_UNDEFINED, &obj_exist);
               if ( (rc_pst NE ESA_OK) AND (rc_pst NE ESA_WARN) ) {
                  CTSAMSG_print (MSG_RES_POSTSCRIPT_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           fn, ESA_rc2str(rc_pst),
						   res_prm_out[0].resource,
						   res_prm_out[0].restype);
                  CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           handle_log_evnt,
                           MSG_RES_POSTSCRIPT_FAIL,
                           fn, ESA_rc2str(rc_pst),
						   res_prm_out[0].resource,
    					   res_prm_out[0].restype);
			   }
               ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC, "<*****... End Post script.");
			}
			if (handle NE NULL)
			{
              ESA_RC rcc;
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"    -> Call to CTSGetRes USA-API with GET_FREE_HANDLE_RESOURCES mode.");
              CS_DIAG_RESACL_IN (ESA_COMP_ACSSETF,
				  GET_FREE_HANDLE_RESOURCES,
			     oe, 0, (RES_PARAMS_rec_typ *)account_str, NULL,
				 res_addinfo, handle, addinfo);
              rcc= envir_ptr->func_ptr.getres_ptr(
                               GET_FREE_HANDLE_RESOURCES,
                               oe,
                               1,
                               &actual_num_free,
                               &have_more,
                               &handle,
                               (RES_PARAMS_rec_typ *)account_str,
                               res_addinfo,
                               res_prm_out,
                               addinfo,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"    <- CTSGetRes USA-API completed with rc=%d (%s).",
    			rcc, (rcc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK");
              if (rcc EQ ESA_OK)
                 CS_DIAG_RESACL_OUT (ESA_COMP_ACSSETF, oe, 0,
			    	have_more, res_prm_out, NULL, NULL, handle, addinfo);
			}
      }
      /*
        LOGOUT the RSS.
      */
      if (hot_path EQ HOT_PATH_OFF)
          CS_addinfo2_add (structure_id,
                           account_str,
                           addinfo[0]);
      if (rc_pst NE ESA_OK) {
         if (rc_pst EQ ESA_WARN) {
            CTSAMSG_print (MSG_POSTSCRIPT_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
            CTSLogEvent (envir_ptr->msg_admin_param.rss_type,
                       envir_ptr->msg_admin_param.rss_name,
                       handle_log_evnt,
                       MSG_POSTSCRIPT_WARN);
         }
      }
      if (rc EQ ESA_WARN)
            rc = ESA_OK;
      if (rc NE ESA_OK)
          rc = ESA_SKIP;
      else if (
                 (obj_exist EQ OBJ_NOT_EXIST)
                OR
                 (actual_num EQ 0)
              )
          rc= ESA_KEY_NOT_FOUND;
      if (rc NE ESA_OK)
          addinfo[0]->num_pairs= 0;
 
      cleanup:
      CSA_free ((char **)&bufk);
      if (rc EQ ESA_OK)
        rc= rc_logout;
      if (rc NE ESA_OK AND rc NE ESA_KEY_NOT_FOUND AND rc NE ESA_SKIP)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
      ESA_DIAG_exit  (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return (rc);
 
    } /* END - CS_pre_post_info_for_obj function */
 
 
    /*WS10082A RSSADM file is not used in MF but we need to support
        ADM_set to update admin with Test Connection transaction  */
    /****************************************************
     * Procedure Name: ADM_set
     * Description   : Administrator sets function
     *
     * Input         :
     *
     * Input/Output  :
     *
     * Return Value  :
     * Comments      :
     * Scope         :
     ****************************************************
     *
     * DETAILED DESCRIPTION
     * ====================
     *
     * This function is the actual function that takes care of all
     * administrators SET requestes that includes the following:
     * - Add new administrator
     * - Delete an existing administrator.
     * - Update administrator's details.
     * The function receives a message with the "set" details,
     * prepares and sends a respons message back to the ESS.
     *****************************************************************/
 
ESA_RC CS_adm_set (MSG_typ               *  msg_ptr ,
                   RSS_MSG_HDR_rec_typ   *  msg_hdr,
                   TRAN_rec_typ          *  tran,
                   short                    func_name,
                   CTSAMSG_MSGID_typ        func_msg_code)
{
      char fn[]="CS_adm_set";
      unsigned long int     ii, max_nmb;
      NUM_MSGS_typ          num_msgs;
      NUM_MSGS_typ          len_msg;
      NUM_MSGS_typ          cd_msg_len;
      NUM_MSGS_typ          cd_num_msgs;
      ESA_RC                rc;
      ESA_RC                rc_act;
      ERR_STRUCT_rec_typ    err_act, err_pre, err_pst;
      ERR_STRUCT_rec_typ  * err_msg;
      MSG_typ             * msg_cd;
      MSG_typ             * msg_cd_ptr= NULL;
      ADMINISTRATOR_rec_typ admin_prm;
      TIME_typ              change_interval;
      char                  exists[26], * msg_tmp_ptr;
      ENVIRONMENT_rec_typ * envir_ptr;
      char                  prm_value[2];
      int                   dummy_pswd = ADMIN_DUMMY_PSWD; /*protect*/
 
      CS_get_envir_address (&envir_ptr);
 
      ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
      err_msg = envir_ptr->ctsamsg_dest->dests[0].name;
 
      ERROR_CLEAR(&err_pre);
      ERROR_CLEAR(&err_pst);
      ERROR_CLEAR(err_msg);
      rc = ESA_OK;
      msg_cd_ptr  = NULL;
      msg_cd      = NULL;
      /*
        SKIP the GENERAL MESSAGE HEADER.
      */
      msg_ptr = CS_get_aplic_msg(msg_ptr);
      /*
        GET the number of RSS messages (requests within message).
      */
      msg_ptr = CS_get_rss_msg (&num_msgs, msg_ptr);
      if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
      }
      rc= CSA_alloc ((char **)&msg_cd_ptr,
                     0,
                     envir_ptr->max_msg_size,
                     1,
                     fn,
                     "Msg. space");
      if (rc NE ESA_OK)
        goto cleanup;
 
 
      /*
        INITIALIZE a response message buffer.
      */
      msg_cd=CS_reset_cd_msg(&cd_msg_len ,
                             &cd_num_msgs ,
                             msg_cd ,
                             msg_cd_ptr ,
                             msg_hdr );
 
      /*
        PROCESS all RSS MESSAGES (internal message requests):
      */
      for (ii =0 ; ii LT num_msgs; ii++) {
 
        /*
          INITIALIZE the pre/actual/post scripts statuses and
          error buffers.
        */
        rc_act = ESA_RC_UNDEFINED;
 
        ERROR_CLEAR(&err_act);
 
        CLEAR_STRUCT(admin_prm);
 
        /*
          GET the current (internal) request details (transaction &
          action id).
        */
        msg_ptr = CS_get_singl_msg( &len_msg , tran , msg_ptr);
        if (msg_ptr EQ NULL) {
          rc= ESA_ERR;
          goto cleanup;
        }
        /*
          Get fields from message.
        */
        /* RETRIEVE Administrator name.*/
        max_nmb= envir_ptr->rss_limits.max_user_len;
        msg_ptr= CS_get_fld (admin_prm.admin_name ,msg_ptr, max_nmb,
                    C_USER_ID);
     	ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
           "*****>... Set for administrator=%s", admin_prm.admin_name);
        if (
              (func_name NE FUNC_DELADMIN)
             AND
              (msg_ptr NE NULL)
           )
        {
           /* RETRIEVE User password. */
           max_nmb= envir_ptr->rss_limits.max_pwd_len;
           msg_tmp_ptr= msg_ptr+ 3;
           msg_ptr= CS_get_fld (admin_prm.admin_passwd ,
                                msg_ptr,
                                max_nmb,
                                C_USER_PASSWD);
           /* RETRIEVE if passwd auto_changed. */
           if (msg_ptr NE NULL)
           {
              memset (msg_tmp_ptr,
                      '*',
                      strlen(admin_prm.admin_passwd));
              max_nmb= 1;
              msg_ptr= CS_get_fld (&admin_prm.auto_pwd_change ,msg_ptr,
                                   max_nmb, C_ADM_AUTO_CHANGE);
              if (msg_ptr NE NULL)
              {
                 if (
                       (admin_prm.auto_pwd_change EQ ' ')
                      OR
                       (admin_prm.auto_pwd_change EQ '\0')
                    )
                 {
                    if (func_name EQ FUNC_ADDADMIN)
                        admin_prm.auto_pwd_change = ESS_NOT_SIGN;
                    else
                        admin_prm.auto_pwd_change = BACKSLASH;
                 }
                 if (
                       (admin_prm.auto_pwd_change NE ESS_YES_SIGN)
                      AND
                       (admin_prm.auto_pwd_change NE ESS_NOT_SIGN)
                      AND
                       (admin_prm.auto_pwd_change NE BACKSLASH)
                    )
                 {
                    CTSAMSG_print (ERR_CS_MSG_GET_FLD ,
                          envir_ptr->msg_admin_param.ctsamsg_handle,
                          NULL,
                          envir_ptr->msg_admin_param.ctsamsg_dest,
                          fn , C_ADM_AUTO_CHANGE);
                    msg_ptr = NULL;
                 }
              }
           }
           /* RETRIEVE interval for password changes. */
           if (msg_ptr NE NULL)
           {
              max_nmb= TIME_LEN;
              msg_ptr= CS_get_fld (change_interval ,msg_ptr,
                                   max_nmb, C_ADM_INTERVAL);
              if (msg_ptr NE NULL)
              {
                 if (change_interval[0] EQ '\\')
                 {
                    if (func_name EQ FUNC_ADDADMIN)
                    {
                        change_interval[0] = '\0';
                          sprintf (admin_prm.change_interval,
                                 "%06d",
                                 atoi( change_interval));
                    }
                 }
                 else
                    sprintf (admin_prm.change_interval,
                             "%06d",
                             atoi( change_interval));
              }
           }
        }
        if (msg_ptr EQ NULL) {
            CTSAMSG_print (ERR_CS_MSG_GET_STRUCT,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn);
            rc= ESA_ERR;
            goto cleanup;
        }
        CTSAMSG_print (func_msg_code,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest,
                       admin_prm.admin_name,
                       envir_ptr->msg_admin_param.rss_name,
                       envir_ptr->msg_admin_param.admin_uname,
                       envir_ptr->msg_admin_param.admin_gname,
                       envir_ptr->siid);
        if (
              (func_name EQ FUNC_ADDADMIN)
             OR
              (
                 (func_name EQ FUNC_UPDADMIN)
                AND
                 (admin_prm.admin_passwd[0] NE BACKSLASH)
              )
           )
        {
         /******* protect start *******/
         if (strlen(admin_prm.admin_passwd) EQ 0) {
          ESA_DIAG_printf(ESA_COMP_ACSSETF,6,"empty password");
          memcpy(admin_prm.admin_passwd,&dummy_pswd,4);
          admin_prm.admin_passwd[4] = NULL_CHAR;
          ESA_DIAG_printf(ESA_COMP_ACSSETF,6,
                          "pswd passed as:<%2X%2X%2X%2X>",
                          admin_prm.admin_passwd[0],
                          admin_prm.admin_passwd[1],
                          admin_prm.admin_passwd[2],
                          admin_prm.admin_passwd[3]);
         }
         /******* protect end *******/
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	        	"    -> Call to CTSRSSLogin USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
    			envir_ptr->msg_admin_param.rss_name, admin_prm.admin_name,
	    		"", "LOGIN_MODE_FIRST", LOGIN_MODE_FIRST);
			/*do not expose password
            ESA_DIAG_printf (ESA_COMP_ACSSETF, 99, "pwd=%s",
                         admin_prm.admin_passwd);*/
            rc= envir_ptr->func_ptr.rss_login_ptr (
                               envir_ptr->msg_admin_param.rss_name,
                               admin_prm.admin_name,
                               "",
                               admin_prm.admin_passwd,
                               LOGIN_MODE_FIRST,
                               &envir_ptr->handle_login,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"    <- CTSRSSLogin USA-API completed with rc=%d (%s) hndl=%p.",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			     envir_ptr->handle_login);
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                             "Login first rc=%d.", (int)rc);
            if (rc NE ESA_OK)
            {
               CTSAMSG_print (ERR_RSSLOGIN,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   C_LOGIN_FIRST);
 /*  BS10100   CTSAMSG_print (ERR_USER_BEFORE_ADMIN,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest); */
               goto cleanup;
            }
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	        	"    -> Call to CTSRSSLogout USA-API for rss=%s adm=%s ug=%s mode=%s(%d).",
		    	envir_ptr->msg_admin_param.rss_name, admin_prm.admin_name, "",
		    	"LOGOUT_MODE_LAST", LOGOUT_MODE_LAST);
            rc= envir_ptr->func_ptr.rss_logout_ptr(
                               envir_ptr->msg_admin_param.rss_name,
                               admin_prm.admin_name,
                               "",
                               LOGOUT_MODE_LAST,
                               &envir_ptr->handle_login,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
            ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
	    		"    <- CTSRSSLogout USA-API completed with rc=%d (%s) hndl=%p.",
		    	rc, (rc EQ ESA_OK) ? "UsaApi==OK" : "UsaApi##OK",
			    envir_ptr->handle_login);
 
            ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                            "Logout last rc=%d.", (int)rc);
            if (rc NE ESA_OK)
            {
               CTSAMSG_print (ERR_RSSLOGOUT,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest,
                   C_LOGOUT_LAST);
               goto cleanup;
            }
        }
        /* WS10082A --- RSSADM file is not supported in MF - drop it
        rc= rssprm_get_opt (envir_ptr->msg_admin_param.rss_name,
                            ADMIN_FILE_REQUEST, 1, prm_value, OPT_TRUE, OPT_TRUE);
        if (
              (rc NE ESA_OK)
             OR
              (prm_value[0] NE ESS_YES_SIGN)
           )
		{
           ESA_DIAG_printf (ESA_COMP_ACSADM, DIAG_BASIC+ 1,
               "Change in RSSADM files skipped. (ADMIN_FILE_REQUEST=%s).", prm_value);
           rc_act= ESA_OK;
           rc    = ESA_OK;
        }
        else {
           switch (func_name)
           {
             case FUNC_ADDADMIN:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                "         Add administrator.");
              rc_act = ADM_add(envir_ptr->msg_admin_param.rss_name,
                               admin_prm.admin_name,
                               admin_prm.auto_pwd_change,
                               admin_prm.change_interval,
                               admin_prm.admin_passwd);
              break;
             case FUNC_UPDADMIN:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                "         Update administrator.");
              rc_act = ADM_upd(envir_ptr->msg_admin_param.rss_name,
                               admin_prm.admin_name,
                               admin_prm.auto_pwd_change,
                               admin_prm.change_interval,
                               admin_prm.admin_passwd);
              break;
             case FUNC_DELADMIN:
              ESA_DIAG_printf (ESA_COMP_ACSSETF, DIAG_BASIC,
                "         Delete administrator.");
              rc= ADM_admin_is_def_admin (
                      envir_ptr->msg_admin_param.rss_name,
					  admin_prm.admin_name);
              if (rc EQ ESA_OK)
              {
                 CTSAMSG_print (ERR_DEF_ADMIN_DELETE,
                    envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                    envir_ptr->msg_admin_param.ctsamsg_dest,
                    admin_prm.admin_name,
					envir_ptr->msg_admin_param.rss_name);
                 rc_act= ESA_ERR;
              }
              else
              {  rc=     ESA_OK;
                 rc_act= ADM_del(envir_ptr->msg_admin_param.rss_name,
                                 admin_prm.admin_name);
              }
              break;
           }
		}
        if (rc_act EQ ESA_OK)
        *** end of WS10082A --- drop of RSSADM file handling */
            CTSAMSG_print (MSG_ACTUAL_OK,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
        /*** WS10082A no call to update RSSADM ***
        else if (rc_act EQ ESA_WARN)
             CTSAMSG_print (MSG_ACTUAL_WARN,
                       envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                       envir_ptr->msg_admin_param.ctsamsg_dest);
        else
            CTSAMSG_print (MSG_ACTUAL_FAIL,
                           envir_ptr->msg_admin_param.ctsamsg_handle,
                           NULL,
                           envir_ptr->msg_admin_param.ctsamsg_dest,
                           ESA_rc2str(rc_act));
        *** end of WS10082A ***/
        ERROR_COPY(&err_act,err_msg);
        ERROR_CLEAR(err_msg);
 
        ESA_DIAG_printf (ESA_COMP_ACSSETF, 15,
                         "API run results act:%d.",
                         rc_act);
        /*
          SET not last (and not temporary last) message type to respond.
        */
        CS_set_not_last_msg(msg_cd_ptr);
        /*
          TRANSLATE function name to function code in message.
        */
        rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
        if (rc NE ESA_OK)
          goto cleanup;
        /*
          ADD current respond buffer to respond message buffer.
        */
        CLEAR(exists);
        if (rc_act EQ ESA_KEY_NOT_FOUND)
             strcpy (exists,ENTITY_NOT_FOUND);
        else if (rc_act EQ ESA_OK)
             strcpy (exists,ENTITY_FOUND);
        else
             strcpy (exists,ENTITY_ERR);
        msg_cd = CS_add_cd_msg (&cd_msg_len,
                                &cd_num_msgs,
                                func_name,
                                HOT_PATH_OFF,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                exists,
                                NULL,
                                msg_cd,
                                msg_cd_ptr,
                                msg_hdr,
                                ESA_RC_UNDEFINED,
                                rc_act,
                                ESA_RC_UNDEFINED,
                                &err_pre,
                                &err_act,
                                &err_pst,
                                tran,
                                &rc);
        if (rc NE ESA_OK)
          goto cleanup;
 
 
        if (msg_cd EQ NULL) {
          rc=ESA_FATAL;
          goto cleanup;
        }
      } /* END - for loop on internal message requests */
 
        /*
          SET "Temporary Last" message indicator in message header.
        */
          CS_set_tmp_last_msg(msg_cd_ptr);
 
      /*
        TRANSLATE function name to function code in respond
        message buffer.
      */
      rc= CS_api_to_capi_id (func_name , msg_cd_ptr);
      if (rc NE ESA_OK)
          goto cleanup;
      /*
        SEND respond message to ESS.
      */
      rc = CS_send_cd_msg (&cd_msg_len ,
                           &cd_num_msgs ,
                           msg_cd_ptr);
 
      if (rc NE ESA_OK)
        goto cleanup;
 
      cleanup:
 
      if (rc NE ESA_OK)
        CTSAMSG_print (ERR_CS_FUNCTION,
                         envir_ptr->msg_admin_param.ctsamsg_handle,
                         NULL,
                         envir_ptr->msg_admin_param.ctsamsg_dest, fn);
 
      /*
        FREE all allocated segments.
      */
      CSA_free ((char **)&msg_cd_ptr);
 
 
      ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON, fn, rc);
      return(rc);
 
} /* END - ADM_set function */
/*****************************************************************
* Procedure Name: CS_queue_intercept_data
* Description   :
* Input/Output  :
*****************************************************************/
 
static ESA_RC CS_queue_intercept_data (void)
{
   ESA_RC                rc= ESA_OK;
   int                   ii;
   INTERCEPT_rec_typ   * intercept_rec;
   char                  fn[]= "CS_queue_intercept_data";
   ENVIRONMENT_rec_typ * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
 
   ESA_DIAG_enter (ESA_COMP_ACSSETF, DIAG_COMMON, fn);
 
   ESA_DIAG_printf (ESA_COMP_ACSSETF,
                    13,
                    "num_intercept_rec %d.",
                    envir_ptr->num_intercept_rec);
 
   for (ii= 0;
        ii LT envir_ptr->num_intercept_rec;
        ii++)
   {
      intercept_rec= envir_ptr->intercept_rec+ ii;
 
      ESA_DIAG_printf(ESA_COMP_ACSSETF,
                      13,
                      "%d: type %d obj.type %d oe %s ug %s user %s.",
                      ii,
                      (int)intercept_rec->type,
                      (int)intercept_rec->obj_type,
                      intercept_rec->oe,
                      intercept_rec->ug,
                      intercept_rec->user);
 
      if (intercept_rec->type EQ INTERCEPT_SUBTREE)
      {
         rc= ESA_NOT_SUPP;
      }
 
      if (intercept_rec->type EQ INTERCEPT_SPECIFIC)
      {
         if (intercept_rec->obj_type EQ INTERCEPT_USER)
         {
            rc= CTSUserEvent(envir_ptr->msg_admin_param.rss_type,
                             envir_ptr->msg_admin_param.rss_name,
                             NULL,
                             intercept_rec->user,
                             ACT_UNKNOWN,
                             &envir_ptr->msg_admin_param);
            if (
                (rc EQ ESA_OK)
                    OR
                (rc EQ ESA_KEY_NOT_FOUND)
            )
               envir_ptr->func_ptr.trnsevnt_ptr (
                                     INTERCEPT_USER,
                                     envir_ptr->empty_oe,
                                     intercept_rec->user,
                                     envir_ptr->empty_ug,
                                     UPDCONN_NO,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
         }
         else if (intercept_rec->obj_type EQ INTERCEPT_GROUP)
         {
            rc= CTSUGEvent(envir_ptr->msg_admin_param.rss_type,
                           envir_ptr->msg_admin_param.rss_name,
                           NULL,
                           intercept_rec->ug,
                           ACT_UNKNOWN,
                           &envir_ptr->msg_admin_param);
            if (
                (rc EQ ESA_OK)
                    OR
                (rc EQ ESA_KEY_NOT_FOUND)
            )
               envir_ptr->func_ptr.trnsevnt_ptr (
                                      INTERCEPT_GROUP,
                                      envir_ptr->empty_oe,
                                      envir_ptr->empty_user,
                                      intercept_rec->ug,
                                      UPDCONN_NO,
                                      &envir_ptr->msg_admin_param,
                                      &envir_ptr->msg_err);
         }
         else if (intercept_rec->obj_type EQ INTERCEPT_CONNECTION)
         {
            rc= CTSConnEvent (envir_ptr->msg_admin_param.rss_type,
                              envir_ptr->msg_admin_param.rss_name,
                              NULL,
                              intercept_rec->ug,
                              intercept_rec->user,
                              ACT_UNKNOWN,
                              &envir_ptr->msg_admin_param);
            if (
                (rc EQ ESA_OK)
                    OR
                (rc EQ ESA_KEY_NOT_FOUND)
                )
               envir_ptr->func_ptr.trnsevnt_ptr (
                                      INTERCEPT_CONNECTION,
                                      envir_ptr->empty_oe,
                                      intercept_rec->user,
                                      intercept_rec->ug,
                                      UPDCONN_NO,
                                      &envir_ptr->msg_admin_param,
                                      &envir_ptr->msg_err);
         }
         else if (intercept_rec->obj_type EQ INTERCEPT_CONTAINER)
         {
            rc= CTSOEEvent (envir_ptr->msg_admin_param.rss_type,
                            envir_ptr->msg_admin_param.rss_name,
                            NULL,
                            intercept_rec->oe,
                            ACT_UNKNOWN,
                            &envir_ptr->msg_admin_param);
            if (
                (rc EQ ESA_OK)
                    OR
                (rc EQ ESA_KEY_NOT_FOUND)
                )
               envir_ptr->func_ptr.trnsevnt_ptr (
                                      INTERCEPT_CONTAINER,
                                      intercept_rec->oe,
                                      envir_ptr->empty_user,
                                      envir_ptr->empty_ug,
                                      UPDCONN_NO,
                                      &envir_ptr->msg_admin_param,
                                      &envir_ptr->msg_err);
         }
         else if (intercept_rec->obj_type EQ INTERCEPT_RSSPRM)
         {
            rc= CTSParamsModEvent(envir_ptr->msg_admin_param.rss_type,
				                  envir_ptr->msg_admin_param.rss_name,
                                  NULL,
                                  &envir_ptr->msg_admin_param);
            if (
                (rc EQ ESA_OK)
                    OR
                (rc EQ ESA_KEY_NOT_FOUND)
               )
               envir_ptr->func_ptr.trnsevnt_ptr (
                                      INTERCEPT_RSSPRM,
                                      envir_ptr->empty_oe,
                                      envir_ptr->empty_user,
                                      envir_ptr->empty_ug,
                                      UPDCONN_NO,
                                      &envir_ptr->msg_admin_param,
                                      &envir_ptr->msg_err);
         }
      }
 
      if (intercept_rec->type EQ INTERCEPT_FULL)
      {
         rc= ESA_NOT_SUPP;
      }
   }
 
   envir_ptr->num_intercept_rec= 0;
 
   ESA_DIAG_exit (ESA_COMP_ACSSETF, DIAG_COMMON,fn, rc);
   return (rc);
 
} /* CS_queue_intercept_data */
