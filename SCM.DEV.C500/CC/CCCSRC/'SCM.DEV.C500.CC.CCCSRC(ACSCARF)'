/*
 * Version Information:
 * ====================
 * File name       : %name: acscarf.c %
 * Instance        : %instance: 1 %
 * Created by      : %created_by: ihoffma %
 * Created on      : %date_created: Wed Nov 19 19:01:45 2003 %
 * Current Version : %version: 2 %
 * Last Modified by: %derived_by: ihoffma %
 * Last Modified on: %date_modified: Wed Nov 19 19:01:45 2003 %
 */
 
/***********************************************
 * Mod.ID  Who      When        Description
 * =============================================
 * 1805    Leonid   12/04/01    Move SCCSID (for Unix)
 * IMH001  Ian H.   19-Nov-03   WSAN101342 Thread-safe code (ERRNO)
 * SAS2IBMA AvnerL  21-Dec-16   SAS/C to IBM C Conversion Project
 * BS10129  AvnerL  28-Dec-23    Recompile due to WS10078 ESAINIT
 **********************************************/
 
#include   "globs.h"
/*
 *   Standard include files
 */
 
#include   ERRNO
#include   STDARG
#include   STDIO
#include   STDLIB
#include   STRING
#include   TIME
#include   CTYPE
#include   ESA_ADMIN
#include   ESA_CAREUSR
#include   ESA_DIAG
#include   ESA_CTSAMSG
 
/*
 *   CONTROL-SA include files
 */
 
#define    CARE_owner
 
void CARE_obj_type (unsigned int      comp,
			    	char            * AcntName,
				    OBJECT_TYPE_typ   ObjType);
void CARE_interest (unsigned int     comp,
					char           * func,
					ESS_INTRST_typ   InterestType);
void CARE_type (unsigned int   comp,
				char         * func,
				char         * AcntName,
				char         * Acnt,
				char           AcntType);
 
/**************************************************************
 *                                                             *
 * Procedure Name   : CARE_int_u2ug_find                       *
 *                                                             *
 * Description      : determine if group is in list of         *
 *                    interesting group for connections        *
 * Input            : group                                    *
 * Output           : ESS_U2UG_CARE or ESS_DONT_CARE           *
 * Return Value     : ESA_OK                                   *
 **************************************************************/
 
ESA_RC CARE_int_u2ug_find (UG_typ                   group,
                           char                     group_type,
                           ESS_INTRST_typ         * interest)
{
  ESA_RC                rc= ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  int                   i= 0, jj= 0;
  MEMBER_UG_rec_typ   * next_ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_u2ug_find";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  CARE_type (ESA_COMP_ACSCARF, fn,  "GROUP", (char *)group, group_type);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
     "Group=%s method %c  prev_method %c.", group,
     envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method,
     envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method);
  /*
    SEARCH user-group in the list of 'interesting groups for
    connections'
  */
  *interest= ESS_DONT_CARE;
  if (envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method EQ
         M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_int_object_in_oe ((char *)group, TYPE_GROUP);
     if (rc EQ ESA_OK)
        *interest= ESS_U2UG_CARE;
     goto cleanup;
  }
  rc= ESA_KEY_NOT_FOUND;
  for(i= 0;
      i LT envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs;
      i++)
  {
     next_ug_rec =
         envir_ptr->interest[envir_ptr->rss_num].pre_u2ugs_ptr + i;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "Next %d: Group=%s type %c.",
                      i, next_ug_rec->ug, next_ug_rec->member_type);
     if (next_ug_rec->member_type EQ M_DWNLD_NAME_ALL)
        rc = ESA_OK;
     else if (strlen (group) EQ 0)
		 continue;
     else
	 {
        if (jj EQ 0)
		{
           rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
           if (rc NE ESA_OK)
              break;
		   jj++;
		}
		ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)group, "TYPE_GROUP",
            (char *)next_ug_rec->ug, "MASK_REGULAR");
        rc = envir_ptr->func_ptr.ismaskmatch_ptr  (group,
                                 next_ug_rec->ug ,
                                 TYPE_GROUP,
                                 MASK_REGULAR,
                                 &envir_ptr->msg_admin_param,
                                 &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
	 }
     if (rc EQ ESA_OK)
     {
        /*
          To ignore this group from this list.
          Instead equal group will be added to list of def.groups.
          */
        if (
            (next_ug_rec->member_type NE M_DWNLD_NAME_ALL)
                AND
            (group_type               EQ M_DWNLD_NAME_IGNORE)
            )
           next_ug_rec->member_type = M_DWNLD_NAME_IGNORE;
        else
           break;
     }
  }
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
  if (i LT envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs)
    *interest= ESS_U2UG_CARE;
 
cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
     "Group=%s Interest=%d.",group, (int)*interest);
  if (rc EQ ESA_OK)
     rc= rc_logout;
  CARE_interest (ESA_COMP_ACSCARF, fn, *interest);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
 
} /* END - CARE_int_u2ug_find  function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_oe_find                         *
*                                                             *
* Description      : determine if container is in list of     *
*                    interesting containers                   *
* Input            : oe                                       *
* Output           : ESS_OE_CARE or ESS_DONT_CARE             *
* Return Value     : ESA_OK                                   *
**************************************************************/
 
ESA_RC CARE_int_oe_find (OE_typ                   oe,
                         ESS_INTRST_typ         * interest)
{
  char                  fn[]="CARE_int_oe_find";
  ESA_RC                rc= ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  int                   ii = 0, jj= 0;
  MEMBER_OE_rec_typ   * oe_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "CONTAINER %s.",
	  (oe[0] EQ '\0') ? "ALL" : oe);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
     "OE=%s method %c  prev_method %c.", oe,
     envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method,
     envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method);
 
  /*
    SEARCH the container in list of the 'interesting containers'
  */
  *interest= ESS_DONT_CARE;
  if (envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method EQ
      M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_int_object_in_oe ((char *)oe, TYPE_CONTAINER);
     if (rc EQ ESA_OK)
        *interest= ESS_OE_CARE;
     goto cleanup;
  }
 
  rc= ESA_KEY_NOT_FOUND;
 
  for(ii = 0;
      ii LT envir_ptr->interest[envir_ptr->rss_num].pre_num_oes;
      ii++)
  {
      oe_rec= envir_ptr->interest[envir_ptr->rss_num].pre_oes_ptr+ ii;
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                       "Next %d: OE=%s type %c.",
                       ii, oe_rec->oe, oe_rec->member_type);
 
      if (oe_rec->member_type EQ M_DWNLD_NAME_ALL)
         rc = ESA_OK;
	  else if (strlen (oe) EQ 0)
         continue;
      else
	  {
         if (jj EQ 0)
		 {
            rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
            if (rc NE ESA_OK)
               break;
		    jj++;
		 }
         ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)oe, "TYPE_CONTAINER",
            (char *)oe_rec->oe, "MASK_REGULAR");
         rc = envir_ptr->func_ptr.ismaskmatch_ptr  (oe,
                                   oe_rec->oe ,
                                   TYPE_CONTAINER,
                                   MASK_REGULAR,
                                   &envir_ptr->msg_admin_param,
                                   &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
	  }
      if (rc EQ ESA_OK)
         break;
  } /* END - loop over interesting DEFAULT containers. */
 
  if (ii LT envir_ptr->interest[envir_ptr->rss_num].pre_num_oes)
    *interest= ESS_OE_CARE;
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
cleanup:
 
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
                   "Container=%s Interest=%d.",
                   oe,
                   (int)*interest);
  if (rc EQ ESA_OK)
     rc= rc_logout;
 
  CARE_interest (ESA_COMP_ACSCARF, fn, *interest);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
 
} /* END - CARE_int_oe_find function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_ug_find                         *
*                                                             *
* Description      : determine if group is in list of         *
*                    interesting groups or in list of         *
*                    interesting groups for connections       *
* Input            : group                                    *
* Output           : ESS_GROUP_CARE or ESS_U2UG_CARE or       *
*                            ESS_DONT_CARE                    *
* Return Value     : ESA_OK                                   *
**************************************************************/
 
ESA_RC CARE_int_ug_find (UG_typ                   group,
                         char                     group_type,
                         ESS_INTRST_typ         * interest)
{
  char                  fn[]="CARE_int_ug_find";
  ESA_RC                rc= ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  int                   i= 0, jj= 0;
  MEMBER_UG_rec_typ   * next_ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CARE_type (ESA_COMP_ACSCARF, fn, "GROUP", (char *)group, group_type);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
     "Group=%s method %c  prev_method %c.", group,
     envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method,
     envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method);
 
  /*
    SEARCH the user-group in list of the 'interesting user-groups'
  */
  *interest= ESS_DONT_CARE;
  if (envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method EQ
      M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_int_object_in_oe ((char *)group, TYPE_GROUP);
     if (rc EQ ESA_OK)
        *interest= ESS_GROUP_CARE;
     goto cleanup;
  }
 
  rc= ESA_KEY_NOT_FOUND;
 
  for(i= 0;
      i LT envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs;
      i++)
  {
     next_ug_rec =
         envir_ptr->interest[envir_ptr->rss_num].pre_ugs_ptr + i;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "Next %d: Group=%s type %c.",
                      i, next_ug_rec->ug, next_ug_rec->member_type);
 
     if (next_ug_rec->member_type EQ M_DWNLD_NAME_ALL)
        rc = ESA_OK;
     else if (strlen (group) EQ 0)
		 continue;
     else
	 {
        if (jj EQ 0)
		{
           rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
           if (rc NE ESA_OK)
              break;
		   jj++;
		}
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
    		"...-> ismaskmatch_ptr: Obj=%s (%s)  Mask=%s (%s)",
			(char *)group, "TYPE_GROUP",
            (char *)next_ug_rec->ug, "MASK_REGULAR");
        rc = envir_ptr->func_ptr.ismaskmatch_ptr  (group,
                                  next_ug_rec->ug ,
                                  TYPE_GROUP,
                                  MASK_REGULAR,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
	 }
     if (rc EQ ESA_OK)
        break;
  } /* END - loop over interesting DEFAULT user groups. */
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
  if (i LT envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs)
    *interest= ESS_GROUP_CARE;
  /*
    IF user-group is not found in the list of 'interesting groups'
   search the user-group in the list of 'interesting groups for
   connections'
  */
  else
     CARE_int_u2ug_find (group, group_type, interest);
 
cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
       "Group=%s Interest=%d.", group, (int)*interest);
 
  if (rc EQ ESA_OK)
     rc= rc_logout;
  CARE_interest (ESA_COMP_ACSCARF, fn, *interest);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
 
} /* END - CARE_int_ug_find function */
 
/**************************************************************
*                                                             *
* Procedure Name   :  CARE_int_usr_find                       *
*                                                             *
* Description      :  determine if user is in list of         *
*                     interesting users or group of the user  *
*                     is in list of groups.                   *
* Input            :  user and                                *
*                     default group of the user               *
* Output           :  ESS_USER_CARE or ESS_GROUP_CARE or      *
*                             ESS_DONT_CARE                   *
* Return Value     :  ESA_OK                                  *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function is used in order to check if a specific user is
* an interestingt user. an interesting user is a user that:
*   - Specifically appears in the list of interesting users
* OR
*   - There is a WILD-CARD user in the interesting userrs list with
*     the same leading string.
* OR
*   - The user's defgualt group appears in the list of interesting
*     DEFAULT GROUPS.
*
**********************************************************************/
 
ESA_RC CARE_int_usr_find (USER_typ         user,
                          UG_typ           def_group,
                          char             user_type,
                          ESS_INTRST_typ * interest)
{
  char                  fn[]="CARE_int_usr_find";
  int                   i= 0, ignored= 0, jj= 0;
  MEMBER_USER_rec_typ * next_user_rec;
  ESA_RC                rc = ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CARE_type (ESA_COMP_ACSCARF, fn, "USER", (char *)user, user_type);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
     "User=%s def_group %s user_type %c method %c  prev_method %c.",
     user,
     def_group,
     user_type,
     envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method,
     envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method);
  *interest= ESS_DONT_CARE;
 
  /*
    SEARCH if user belong to list of interesting containers
  */
  if (envir_ptr->interest[envir_ptr->rss_num].prev_dwnld_sync_method EQ
      M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_int_object_in_oe ((char *)user, TYPE_USER);
     if (rc EQ ESA_OK)
        *interest= ESS_USER_CARE;
     else
        *interest= ESS_DONT_CARE;
     goto cleanup;
  }
 
  /*
    SEARCH if user is belong to list of interesting users
  */
  rc= ESA_KEY_NOT_FOUND;
  for(i= 0;
      i LT envir_ptr->interest[envir_ptr->rss_num].pre_num_users;
      i++)
  {
     next_user_rec =
         envir_ptr->interest[envir_ptr->rss_num].pre_users_ptr + i;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Next %d: User=%s type %c.",
                   i, next_user_rec->user, next_user_rec->member_type);
 
     if (next_user_rec->member_type EQ M_DWNLD_NAME_ALL)
        rc = ESA_OK;
     else if (strlen (user) EQ 0)
        continue;
     else
     {
        if (jj EQ 0)
		{
           rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
           if (rc NE ESA_OK)
              break;
		   jj++;
		}
 
		if (user_type EQ M_DWNLD_NAME_WILD)
        {
           if (next_user_rec->member_type NE M_DWNLD_NAME_WILD)
              continue;
           ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)next_user_rec->user, "TYPE_USER",
            (char *)user, "MASK_WILD");
           rc = envir_ptr->func_ptr.ismaskmatch_ptr  (
                                     user ,
                                     next_user_rec->user,
                                     TYPE_USER,
                                     MASK_WILD,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
           ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
           if (rc EQ ESA_OK)
           {
              next_user_rec->member_type = M_DWNLD_NAME_IGNORE;
              ignored++;
              continue;
           }
        }
 
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)user, "TYPE_USER",
            (char *)next_user_rec->user,
            (next_user_rec->member_type EQ M_DWNLD_NAME_REGULAR) ?
                                     "MASK_REGULAR" : "MASK_WILD");
        rc=envir_ptr->func_ptr.ismaskmatch_ptr(user,
                                          next_user_rec->user ,
                                          TYPE_USER,
             (next_user_rec->member_type EQ M_DWNLD_NAME_REGULAR) ?
                                          MASK_REGULAR : MASK_WILD,
                                          &envir_ptr->msg_admin_param,
                                          &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
     }
     if (rc EQ ESA_OK)
        break;
  }
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
  if (
        (i LT envir_ptr->interest[envir_ptr->rss_num].pre_num_users)
       OR
        (ignored NE 0)
     )
  {
     *interest= ESS_USER_CARE;
     goto cleanup;
  }
 
  if (strlen (def_group) EQ 0)
     goto cleanup;
  /*
      IF user is not found in list of 'interesting users'
      Search def.user group of the user in list of interesting groups
  */
  CARE_int_ug_find (def_group, M_DWNLD_NAME_REGULAR, interest);
  if (*interest EQ ESS_U2UG_CARE)
    /*
      The user is interesting if it is found in list of
      interesting users or in list of interesting user-groups but
      not list of groups for connections.
    */
    *interest= ESS_DONT_CARE;
 
cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
     "User=%s Def_ug=%s Int=%d.",user, def_group, (int)*interest);
  if (rc EQ ESA_OK)
     rc= rc_logout;
  CARE_interest (ESA_COMP_ACSCARF, fn, *interest);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
 
  return (ESA_OK);
 
} /* END - CARE_int_usr_find function */
 
/****************************************************
 * Procedure Name: CARE_inc_u2ug_free
 * Description   : free memory from  list of increment
 *                 groups for connections
 ****************************************************/
 
void CARE_inc_u2ug_free (void)
{
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_inc_u2ug_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  CSA_free ((char **)&envir_ptr->u2ugs_ptr);
  envir_ptr->num_u2ugs= 0;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_inc_u2ug_free function */
 
/****************************************************
 * Procedure Name: CARE_int_u2ug_free
 * Description   : free memory from list of interesting
 *                 groups for connections
 ****************************************************/
void CARE_int_u2ug_free (void)
{
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_u2ug_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  for (ii= 0;
       (ii LT envir_ptr->max_rss_num) AND (envir_ptr->interest);
	   ii++)
  {
    CSA_free ((char **)&envir_ptr->interest[ii].pre_u2ugs_ptr);
    envir_ptr->interest[ii].pre_num_u2ugs= 0;
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_int_u2ug_free function */
 
/****************************************************
 * Procedure Name: CARE_inc_usr_free
 * Description   : free memory from list of increment
 *                  users
 ****************************************************/
 
void CARE_inc_usr_free (void)
{
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_inc_usr_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  CSA_free ((char **)&envir_ptr->users_ptr);
  envir_ptr->num_users= 0;
 
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_int_usr_free function */
 
/****************************************************
 * Procedure Name: CARE_int_usr_free
 * Description   : free memory from list of interesting
 *                 users
 ****************************************************/
 
void CARE_int_usr_free (void)
{
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_usr_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  for (ii= 0;
       (ii LT envir_ptr->max_rss_num) AND (envir_ptr->interest);
	   ii++)
  {
    CSA_free ((char **)&envir_ptr->interest[ii].pre_users_ptr);
    envir_ptr->interest[ii].pre_num_users= 0;
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_int_usr_free function */
 
/****************************************************
 * Procedure Name: CARE_inc_oe_free
 * Description   : free memory from list of increment
 *                 containers
 ****************************************************/
 
void CARE_inc_oe_free (void)
{
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_inc_oe_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
  CSA_free ((char **)&envir_ptr->oes_ptr);
  envir_ptr->num_oes= 0;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_inc_oe_free function */
 
/****************************************************
 * Procedure Name: CARE_inc_ug_free
 * Description   : free memory from list of increment
 *                 groups
 ****************************************************/
 
void CARE_inc_ug_free (void)
{
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_inc_ug_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
  CSA_free ((char **)&envir_ptr->ugs_ptr);
  envir_ptr->num_ugs= 0;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_inc_ug_free function */
 
/****************************************************
 * Procedure Name: CARE_int_oe_free
 * Description   : free memory from list of interesting
 *                 containers - for ALL RSS types.
 ****************************************************/
 
void CARE_int_oe_free (void)
{
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_oe_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  for (ii= 0;
       (ii LT envir_ptr->max_rss_num) AND (envir_ptr->interest);
	   ii++)
  {
    CSA_free ((char **)&envir_ptr->interest[ii].pre_oes_ptr);
    envir_ptr->interest[ii].pre_num_oes= 0;
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_int_oe_free */
 
/****************************************************
 * Procedure Name: CARE_int_ug_free
 * Description   : free memory from list of interesting
 *                 groups - for ALL RSS types.
 ****************************************************/
 
void CARE_int_ug_free (void)
{
  int                   ii;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_ug_free";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  for (ii= 0;
       (ii LT envir_ptr->max_rss_num) AND (envir_ptr->interest);
	   ii++)
  {
    CSA_free ((char **)&envir_ptr->interest[ii].pre_ugs_ptr);
    envir_ptr->interest[ii].pre_num_ugs= 0;
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_int_ug_free */
 
/****************************************************
 * Procedure Name: CARE_int_users_add
 * Description   : Add list of increment users to
 *                     list of interesting users
 * Input         : rss
 * Return Value  : rc
 ****************************************************/
 
ESA_RC CARE_int_users_add (RSS_typ rss, char type)
{
   char fn[]="CARE_int_users_add";
   INTEREST_USER_rec_typ * all_users_ptr= NULL, * intusr_ptr, int_usr;
   ESA_RC                  rc = ESA_OK;
   FILE                  * file_handle= NULL;
   int                     ii= 0, i= 0, j= 0;
   long int                all_num_users= 0;
   MEMBER_USER_rec_typ   * user_rec;
   ENVIRONMENT_rec_typ   * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
                    "Rss=%s type %c File of interesting users=%s",
                    rss, type, envir_ptr->file_intuser);
 
   envir_ptr->interest[envir_ptr->rss_num].pre_num_users = 0;
 
   if (
         (envir_ptr->dwnld_sync_type EQ DWNLD_INITIAL)
        OR
         (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
      )
     rc= CARE_int_usr_load_without_rss(rss, NULL,
                                       &all_num_users,
                                       &all_users_ptr);
   else
     rc= CARE_int_usr_load_without_rss(NULL,
                                       NULL,
                                       &all_num_users,&all_users_ptr);
   if (rc NE ESA_OK)
    goto cleanup;
 
   rc= CSA_open (envir_ptr->file_intuser, fn,
                 FILE_CREAT, &file_handle, SCOPE_LOCAL);
   if (rc NE ESA_OK)
     goto cleanup;
 
   rc= CSA_fputs (envir_ptr->file_intuser,
                  FILE_NOTE_LINE,
                  file_handle);
 
   if (rc NE ESA_OK)
      goto cleanup;
 
   for (i= 0; i LT all_num_users; i++)
   {
     intusr_ptr = all_users_ptr+ i;
     intusr_ptr->blank1= ' ';
     intusr_ptr->rss[strlen(intusr_ptr->rss)]= ' ';
     j = strlen(intusr_ptr->user);
     intusr_ptr->user[j]= '\n';
     intusr_ptr->user[j+1]= '\0';
 
     rc= CSA_fputs (envir_ptr->file_intuser,
                    (char *)intusr_ptr,
                    file_handle);
     if (rc NE ESA_OK)
        goto cleanup;
 
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
               "record %d is %s.", i+ 1, intusr_ptr->rss);
  }
  /*
   *   Add rows  into the file
   */
  ii= i;
  memset ((char *)(&int_usr), ' ', sizeof (INTEREST_USER_rec_typ));
  memcpy ((char *)int_usr.rss, (char *)rss, MIN(strlen(rss),
                                                RSS_NAME_LEN));
  for (i= 0; i LT envir_ptr->num_users; i++)
  {
     user_rec = envir_ptr->users_ptr + i;
     int_usr.member_type = user_rec->member_type;
     int_usr.blank1 = ' ';
     strcpy (int_usr.user, user_rec->user);
     j = strlen(int_usr.user);
     int_usr.user[j]= '\n';
     int_usr.user[j+1]= '\0';
     rc= CSA_fputs (envir_ptr->file_intuser,
                    (char *)&int_usr,
                    file_handle);
     if (rc NE ESA_OK)
        goto cleanup;
 
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
               "record %d is %s.", i+ ii+ 1, int_usr.rss);
  }
 
  if(i+ ii EQ 0)
    rc= CSA_fputs (envir_ptr->file_intuser,
                   " ",
                   file_handle);
 
  cleanup:
 
   CSA_close (envir_ptr->file_intuser, fn);
   CSA_free ((char **)&all_users_ptr);
   all_num_users= 0;
   if (rc NE ESA_OK)
     CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
   ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
   return(rc);
}
 
/****************************************************
 * Procedure Name: CARE_int_oes_add
 * Description   : Add list of increment containers to
 *                     list of interesting containers
 * Input         : rss
 * Return Value  : rc
 ****************************************************/
 
ESA_RC CARE_int_oes_add (RSS_typ rss, char type)
{
  char fn[]="CARE_int_oes_add";
  INTEREST_OE_rec_typ * all_oes_ptr= NULL, int_oe, * intoe_ptr;
  ESA_RC                rc = ESA_OK;
  FILE                * file_handle= NULL;
  int                   ii= 0, i= 0, j= 0;
  long int              all_num_oes= 0;
  MEMBER_OE_rec_typ   * oe_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
                   "Rss=%s File of interesting containers=%s",
                   rss, envir_ptr->file_intoe);
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_oes = 0;
 
  if (
        (envir_ptr->dwnld_sync_type EQ DWNLD_INITIAL)
       OR
        (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
     )
    rc= CARE_int_oe_load_without_rss (rss,
                                      &all_num_oes,
                                      &all_oes_ptr);
  else
     rc= CARE_int_oe_load_without_rss (NULL,
                                       &all_num_oes,
                                       &all_oes_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CSA_open (envir_ptr->file_intoe, fn,
                FILE_CREAT, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CSA_fputs (envir_ptr->file_intoe,
                 FILE_NOTE_LINE,
                 file_handle);
 
  for (i= 0; i LT all_num_oes; i++)
  {
    intoe_ptr = all_oes_ptr+ i;
    intoe_ptr->blank1= ' ';
    intoe_ptr->rss[strlen(intoe_ptr->rss)] = ' ';
    j = strlen(intoe_ptr->oe);
    intoe_ptr->oe[j]= '\n';           /* AJK: possible overflow? ...*/
    intoe_ptr->oe[j+1]= '\0';         /* ...should be checked       */
 
    rc= CSA_fputs (envir_ptr->file_intoe,
                   (char *)intoe_ptr,
                   file_handle);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "record %d is %s.", i+ 1, intoe_ptr->rss);
  }
  ii= i;
  /*
   *   Add rows  into the file
   */
 
  memset ((char *)(&int_oe), ' ', sizeof (INTEREST_OE_rec_typ));
  memcpy ((char *)int_oe.rss, (char *)rss,
          MIN(strlen(rss), RSS_NAME_LEN));
  for (i= 0; i LT envir_ptr->num_oes; i++)
  {
     oe_rec = envir_ptr->oes_ptr+ i;
     int_oe.member_type = oe_rec->member_type;
     int_oe.blank1 = ' ';
     strcpy (int_oe.oe, oe_rec->oe);
     j = strlen(int_oe.oe);
     int_oe.oe[j]= '\n';
     int_oe.oe[j+1]= '\0';
     rc= CSA_fputs (envir_ptr->file_intoe,
                    (char *)&int_oe,
                    file_handle);
     if (rc NE ESA_OK)
        goto cleanup;
 
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "record %d is %s.", ii+ i+ 1, int_oe.rss);
  }
 
  if(ii+ i EQ 0)
    rc= CSA_fputs (envir_ptr->file_intoe,
                   " ",
                   file_handle);
 
  cleanup:
  CSA_close (envir_ptr->file_intoe, fn);
  CSA_free ((char **)&all_oes_ptr);
  all_num_oes= 0;
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return(rc);
 
}
 
/****************************************************
 * Procedure Name: CARE_int_ugs_add
 * Description   : Add list of increment groups to
 *                     list of interesting groups
 * Input         : rss
 * Return Value  : rc
 ****************************************************/
 
ESA_RC CARE_int_ugs_add (RSS_typ rss, char type)
{
  char fn[]="CARE_int_ugs_add";
  INTEREST_UG_rec_typ * all_ugs_ptr= NULL, int_ug, * intug_ptr;
  ESA_RC                rc = ESA_OK;
  FILE                * file_handle= NULL;
  int                   ii= 0, i= 0, j= 0;
  long int              all_num_ugs= 0;
  MEMBER_UG_rec_typ   * ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
                   "Rss=%s type %c File of interesting groups=%s",
                   rss, type, envir_ptr->file_intug);
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs = 0;
 
  if (
        (envir_ptr->dwnld_sync_type EQ DWNLD_INITIAL)
       OR
        (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
     )
    rc= CARE_int_ug_load_without_rss(rss,
                                     &all_num_ugs,
                                     &all_ugs_ptr);
  else
     rc= CARE_int_ug_load_without_rss(NULL,
                                      &all_num_ugs,
                                      &all_ugs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CSA_open (envir_ptr->file_intug, fn,
                FILE_CREAT, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
    goto cleanup;
 
  rc= CSA_fputs (envir_ptr->file_intug,
                  FILE_NOTE_LINE,
                  file_handle);
  if (rc NE ESA_OK)
    goto cleanup;
 
  for (i= 0; i LT all_num_ugs; i++)
  {
    intug_ptr = all_ugs_ptr+ i;
    intug_ptr->blank1= ' ';
    intug_ptr->rss[strlen(intug_ptr->rss)] = ' ';
    j = strlen(intug_ptr->ug);
    intug_ptr->ug[j]= '\n';
    intug_ptr->ug[j+1]= '\0';
 
    rc= CSA_fputs (envir_ptr->file_intug,
                   (char *)intug_ptr,
                   file_handle);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "record %d is %s.", i+ 1, intug_ptr->rss);
  }
  ii= i;
  /*
   *   Add rows  into the file
   */
 
  memset ((char *)(&int_ug), ' ', sizeof (INTEREST_UG_rec_typ));
  memcpy ((char *)int_ug.rss, (char *)rss, MIN(strlen(rss),
                                               RSS_NAME_LEN));
  for (i= 0; i LT envir_ptr->num_ugs; i++)
  {
    ug_rec = envir_ptr->ugs_ptr + i;
    int_ug.member_type = ug_rec->member_type;
    int_ug.blank1 = ' ';
    strcpy (int_ug.ug, ug_rec->ug);
    j = strlen(int_ug.ug);
    int_ug.ug[j]= '\n';
    int_ug.ug[j+1]= '\0';
 
    rc= CSA_fputs (envir_ptr->file_intug,
                   (char *)&int_ug,
                   file_handle);
    if (rc NE ESA_OK)
       goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "record %d is %s.", ii+ i+ 1, int_ug.rss);
  }
 
  if(ii+ i EQ 0)
    rc= CSA_fputs (envir_ptr->file_intug,
                   " ",
                   file_handle);
 
  cleanup:
  CSA_close (envir_ptr->file_intug, fn);
  CSA_free ((char **)&all_ugs_ptr);
  all_num_ugs= 0;
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return(rc);
 
}
 
/****************************************************
 * Procedure Name: CARE_int_u2ugs_add
 * Description   : Add list of increment groups for connections to
 *                     list of interesting groups for connections
 * Input         : rss
 * Return Value  : rc
 ****************************************************/
 
ESA_RC CARE_int_u2ugs_add (RSS_typ rss, char type)
{
   char fn[]="CARE_int_u2ugs_add";
   INTEREST_UG_rec_typ * all_u2ugs_ptr= NULL, * intug_ptr, int_ug;
   ESA_RC                rc = ESA_OK;
   FILE                * file_handle= NULL;
   int                   ii= 0, i= 0, j= 0;
   long int              all_num_u2ugs= 0;
   MEMBER_UG_rec_typ   * ug_rec;
   ENVIRONMENT_rec_typ * envir_ptr;
 
   CS_get_envir_address (&envir_ptr);
 
   ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
   ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
            "Rss=%s type %c File of interesting connections=%s",
            rss, type, envir_ptr->file_intu2ug);
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs = 0;
 
  if (
        (envir_ptr->dwnld_sync_type EQ DWNLD_INITIAL)
       OR
        (envir_ptr->dwnld_sync_type EQ SYNC_FULL)
     )
     rc= CARE_int_u2ug_load_without_rss (rss,
                                         NULL,
                                         &all_num_u2ugs,
                                         &all_u2ugs_ptr);
  else
     rc= CARE_int_u2ug_load_without_rss(NULL,
                                        NULL,
                                        &all_num_u2ugs,
                                        &all_u2ugs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_open (envir_ptr->file_intu2ug, fn,
                FILE_CREAT, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
    goto cleanup;
  rc= CSA_fputs (envir_ptr->file_intu2ug,
                  FILE_NOTE_LINE,
                  file_handle);
  if (rc NE ESA_OK)
    goto cleanup;
 
  for (i= 0; i LT all_num_u2ugs; i++)
  {
    intug_ptr = all_u2ugs_ptr+ i;
    intug_ptr->blank1= ' ';
    intug_ptr->rss[strlen(intug_ptr->rss)] = ' ';
    j = strlen(intug_ptr->ug);
    intug_ptr->ug[j]= '\n';
    intug_ptr->ug[j+1]= '\0';
 
    rc= CSA_fputs (envir_ptr->file_intu2ug,
                   (char *)intug_ptr,
                   file_handle);
    if (rc NE ESA_OK)
        goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "record %d is %s.", i+ 1, intug_ptr->rss);
  }
 
  ii= i;
   /*
    *   Add rows  into the file
    */
 
  memset ((char *)(&int_ug), ' ', sizeof (INTEREST_UG_rec_typ));
  memcpy ((char *)int_ug.rss, (char *)rss,
          MIN(strlen(rss), RSS_NAME_LEN));
  for (i= 0; i LT envir_ptr->num_u2ugs; i++)
  {
     ug_rec = envir_ptr->u2ugs_ptr + i;
     int_ug.member_type = ug_rec->member_type;
     int_ug.blank1 = ' ';
     strcpy (int_ug.ug, ug_rec->ug);
     j = strlen(int_ug.ug);
     int_ug.ug[j]= '\n';
     int_ug.ug[j+1]= '\0';
     rc= CSA_fputs (envir_ptr->file_intu2ug,
                    (char *)&int_ug,
                    file_handle);
     if (rc NE ESA_OK)
        goto cleanup;
 
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "record %d is %s.", ii+ i+ 1, int_ug.rss);
  }
 
  if(ii+ i EQ 0)
    rc= CSA_fputs (envir_ptr->file_intu2ug,
                   " ",
                   file_handle);
 
  cleanup:
  CSA_close (envir_ptr->file_intu2ug, fn);
  CSA_free ((char **)&all_u2ugs_ptr);
  all_num_u2ugs= 0;
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return(rc);
 
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_usr_load                        *
*                                                             *
* Description      : Load from file to memory                 *
*                    list of interesting users                *
* Return Value     : rc                                       *
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function loads the list of interesting (default) users from
* the "Interesting Users file" to the memory. The user are loaded to
* the envir_ptr->int.static data - that is an array with an entry per
* possible RSS on current platform. In each entry (= RSS) - there are
* two data items (among otherS):
* pre_num_users - The number of interesting users in list.
* pre_users_ptr - A pointer to an array of interesting user names
*               (each name in full length of user name string).
* The function first clears all details of interesting users (for
* ALL RSS types) - then reads the interesting users into a single
* allocated buffer - than according to the amount of interesting
* users for each RSS (that was determinded wile first load) - the
* function allocates a memory segment for the interesting users
* of each RSS and fills in the user names.
**********************************************************************/
 
ESA_RC CARE_int_usr_load (void)
{
  char fn[]="CARE_int_usr_load";
  ESA_RC                  rc = ESA_OK;
  int                     ii, jj, * nn;
  INTEREST_USER_rec_typ * all_users_ptr= NULL, * int_user;
  long int                all_num_users= 0;
  MEMBER_USER_rec_typ     user_rec;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  /*
    CLEAR all RSS all INTEGRESTING GROUP details.
  */
  rc= CSA_alloc ((char **)&nn,
                 0,
                 4,
                 envir_ptr->max_rss_num,
                 fn,
                 "work nn");
  CARE_int_usr_free();
  /*
    LOAD all users in interesting users file - into a single
    memory segment - check each user validity and count number of
    users for each RSS.
  */
  rc= CARE_int_usr_load_without_rss(NULL, NULL,
                          &all_num_users,&all_users_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SCAN all different RSS in platform.
  */
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "Interesting users=%d in rss %s",
                     envir_ptr->interest[ii].pre_num_users,
                     envir_ptr->interest[ii].rss);
    /*
       CLEAR the number of interesting users that already filled
       for current RSS.
    */
    nn[ii]= 0;
    /*
      PROCESS when the current RSS has interesting users:
    */
    if (envir_ptr->interest[ii].pre_num_users GT 0)
    {
       /*
         ALLOCATE a global memory segment for current RSS users -
         according to the number of users to current RSS.
       */
       rc= CSA_alloc ((char **)&envir_ptr->interest[ii].pre_users_ptr,
                      0, sizeof (MEMBER_USER_rec_typ),
                      envir_ptr->interest[ii].pre_num_users,
                      fn, "Intersting users");
       if (rc NE ESA_OK)
          goto cleanup;
 
    } /* END - There are users in current RSS */
 
  } /* END - FOR loop on ALL RSS */
 
  /*
    ROCESS all users that were loaded from file:
  */
  for (jj= 0; jj LT all_num_users; jj++)
  {
    /*
      COPY the user details into temporary user details buffer.
    */
    int_user = all_users_ptr+ jj;
    /*
      LOCATE current user's RSS entry in array.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      if (My_stricmp (envir_ptr->interest[ii].rss, int_user->rss) EQ 0)
      {
         strcpy ((char *)envir_ptr->interest[ii].ess_rss,
                 (char *)int_user->rss);
         break;
      }
    }
    /*
      COPY the current user name to the next entry of user names in the
      relevant RSS.
    */
    user_rec.member_type = int_user->member_type;
    strcpy (user_rec.user, int_user->user);
    strcpy ((char *)(envir_ptr->interest[ii].pre_users_ptr+ nn[ii]),
            (char *)&user_rec);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
             "rss %s: user number %d type %c name &s ess_rss=%s.",
             envir_ptr->interest[ii].rss, nn[ii],
             user_rec.member_type, user_rec.user,
             envir_ptr->interest[ii].ess_rss);
    /*
      INCREASE by 1 the actual number of users in current RSS entry.
    */
    nn[ii]++;
  }
 
  cleanup:
  /*
    FREE the temporary allocated segment of all users from file.
  */
  CSA_free ((char **)&all_users_ptr);
  CSA_free ((char **)&nn);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    "*****>... Aggregation Scope from %s with %d users loaded.",
		  envir_ptr->file_intuser, all_num_users);
    CARE_int_list_usr();
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_usr_load  function */
 
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_oe_load                         *
*                                                             *
* Description      : Load list of inter. containers from file *
* Return Value     : rc                                       *
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function loads the list of interesting (default) containers from
* the "Interesting Container file" to the memory. The containers are
* loaded to the envir_ptr->int. static data - that is an array with an
* entry per possible RSS on current platform.
* In each entry (= RSS) - there are two data items (among others):
* pre_num_oes - The number of interesting containers in list.
* pre_oes_ptr - A pointer to an array of interesting container names
*               (each name in full length of oe name string).
* The function first clears all details of interesting container (for
* ALL RSS types) - then reads the interesting containers into a single
* allocated buffer - than according to the amount of interesting
* containers for each RSS (that was determinded wile first load) - the
* function allocates a memory segment for the interesting containers
* of each RSS and fills in the container names.
**********************************************************************/
 
ESA_RC CARE_int_oe_load (void)
{
  char fn[]="CARE_int_oe_load";
  ESA_RC                  rc = ESA_OK;
  int                     ii, jj, * nn;
  INTEREST_OE_rec_typ   * all_oes_ptr= NULL, * int_oe;
  long int                all_num_oes= 0;
  MEMBER_OE_rec_typ       oe_rec;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  /*
    CLEAR all RSS all INTEGRESTING Container details.
  */
  rc= CSA_alloc ((char **)&nn,
                 0,
                 4,
                 envir_ptr->max_rss_num,
                 fn,
                 "work nn");
  if (rc NE ESA_OK)
      goto cleanup;
  CARE_int_oe_free();
  /*
    LOAD all containers in interesting container file - into a single
    memory segment - check each container validity and count number of
    containers for each RSS.
  */
  rc= CARE_int_oe_load_without_rss(NULL, &all_num_oes, &all_oes_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SCAN all different RSS in platform.
  */
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1, "Interesting oes=%d in rss %s",
                     envir_ptr->interest[ii].pre_num_oes, envir_ptr->interest[ii].rss);
    /*
       CLEAR the number of interesting containers that already filled
       for current RSS.
    */
    nn[ii]= 0;
    /*
      PROCESS when the current RSS has interesting containers:
    */
    if (envir_ptr->interest[ii].pre_num_oes GT 0)
    {
       /*
         ALLOCATE a global memory segment for current RSS containers -
         according to the number of containers to current RSS.
       */
       rc= CSA_alloc ((char **)&envir_ptr->interest[ii].pre_oes_ptr,
                      0, sizeof (MEMBER_OE_rec_typ),
                      envir_ptr->interest[ii].pre_num_oes,
                      fn, "Intersting containers");
       if (rc NE ESA_OK)
          goto cleanup;
    } /* END - There are containers in current RSS */
 
  } /* END - FOR loop on ALL RSS */
 
  /*
    ROCESS all containers that were loaded from file:
  */
  for (jj= 0; jj LT all_num_oes; jj++)
  {
    /*
     * copy the container details into temporary container details
     * buffer.
    */
    int_oe = all_oes_ptr+ jj;
    /*
      LOCATE current oe's RSS entry in array.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      if (My_stricmp (envir_ptr->interest[ii].rss, int_oe->rss) EQ 0)
      {
         strcpy ((char *)envir_ptr->interest[ii].ess_rss,
                 (char *)int_oe->rss);
         break;
      }
    }
    /*
      COPY the current oe name to the next entry of oe names in the
      relevant RSS.
    */
    oe_rec.member_type = int_oe->member_type;
    strcpy (oe_rec.oe, int_oe->oe);
    strcpy ((char *)(envir_ptr->interest[ii].pre_oes_ptr + nn[ii]),
            (char *)&oe_rec);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
             "    rss %s: oe number %d type %c name %s ess_rss=%s.",
             envir_ptr->interest[ii].rss, nn[ii], oe_rec.member_type, oe_rec.oe,
             envir_ptr->interest[ii].ess_rss);
    /*
      INCREASE by 1 the actual number of oes in current RSS entry.
    */
    nn[ii]++;
  }
 
  cleanup:
  /*
    FREE the temporary allocated segment of all oes from file.
  */
  CSA_free ((char **)&all_oes_ptr);
  CSA_free ((char **)&nn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    "*****>... Aggregation Scope from %s with %d containers loaded.",
		  envir_ptr->file_intoe, all_num_oes);
    CARE_int_list_oe();
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_oe_load  function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_ug_load                         *
*                                                             *
* Description      : Load list of interesting groups from file*
* Return Value     : rc                                       *
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function loads the list of interesting (default) groups from
* the "Interesting Group file" to the memory. The groups are loaded to
* the envir_ptr->int. static data - that is an array with an entry per
* possible RSS on current platform. In each entry (= RSS) - there are
* two data items (among otherS):
* pre_num_ugs - The number of interesting groups in list.
* pre_ugs_ptr - A pointer to an array of interesting group names
*               (each name in full length of ug name string).
* The function first clears all details of interesting groups (for
* ALL RSS types) - then reads the interesting groups into a single
* allocated buffer - than according to the amount of interesting
* groups for each RSS (that was determinded wile first load) - the
* function allocates a memory segment for the interesting groups
* of each RSS and fills in the group names.
**********************************************************************/
 
ESA_RC CARE_int_ug_load (void)
{
  char fn[]="CARE_int_ug_load";
  ESA_RC                  rc = ESA_OK;
  int                     ii, jj, * nn;
  INTEREST_UG_rec_typ   * all_ugs_ptr = NULL, * int_ug;
  long int                all_num_ugs= 0;
  MEMBER_UG_rec_typ       ug_rec;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  /*
    CLEAR all RSS all INTEGRESTING GROUP details.
  */
  rc= CSA_alloc ((char **)&nn,
                 0,
                 4,
                 envir_ptr->max_rss_num,
                 fn,
                 "work nn");
  if (rc NE ESA_OK)
      goto cleanup;
  CARE_int_ug_free();
  /*
    LOAD all groups in interesting groups file - into a single
    memory segment - check each group validity and count number of
    groups for each RSS.
  */
  rc= CARE_int_ug_load_without_rss(NULL,&all_num_ugs,&all_ugs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SCAN all different RSS in platform.
  */
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1, "Interesting ugs=%d in rss %s",
                     envir_ptr->interest[ii].pre_num_ugs, envir_ptr->interest[ii].rss);
    /*
       CLEAR the number of interesting groups that already filled
       for current RSS.
    */
    nn[ii]= 0;
    /*
      PROCESS when the current RSS has interesting groups:
    */
    if (envir_ptr->interest[ii].pre_num_ugs GT 0)
    {
      /*
        ALLOCATE a global memory segment for current RSS groups -
        according to the number of groups to current RSS.
      */
      rc= CSA_alloc ((char **)&envir_ptr->interest[ii].pre_ugs_ptr,
                     0, sizeof (MEMBER_UG_rec_typ),
                     envir_ptr->interest[ii].pre_num_ugs,
                     fn, "Intersting groups");
      if (rc NE ESA_OK)
        goto cleanup;
    } /* END - There are groups in current RSS */
 
  } /* END - FOR loop on ALL RSS */
 
  /*
    ROCESS all groups that were loaded from file:
  */
  for (jj= 0; jj LT all_num_ugs; jj++)
  {
    /*
      COPY the group details into temporary group details buffer.
    */
    int_ug = all_ugs_ptr+ jj;
    /*
      LOCATE current ug's RSS entry in array.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      if (My_stricmp (envir_ptr->interest[ii].rss, int_ug->rss) EQ 0)
      {
         strcpy ((char *)envir_ptr->interest[ii].ess_rss,
                 (char *)int_ug->rss);
         break;
      }
    }
    /*
      COPY the current ug name to the next entry of ug names in the
      relevant RSS.
    */
    ug_rec.member_type = int_ug->member_type;
    strcpy (ug_rec.ug, int_ug->ug);
    strcpy ((char *)(envir_ptr->interest[ii].pre_ugs_ptr + nn[ii]),
            (char *)&ug_rec);
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
             "   rss %s: group number %d type %c name %s ess_rss=%s.",
             envir_ptr->interest[ii].rss, nn[ii], ug_rec.member_type, ug_rec.ug,
             envir_ptr->interest[ii].ess_rss);
    /*
      INCREASE by 1 the actual number of ugs in current RSS entry.
    */
    nn[ii]++;
  }
 
  cleanup:
  /*
    FREE the temporary allocated segment of all ugs from file.
  */
  CSA_free ((char **)&all_ugs_ptr);
  CSA_free ((char **)&nn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
   "*****>... Aggregation Scope from %s with %d default groups loaded.",
		  envir_ptr->file_intug, all_num_ugs);
     CARE_int_list_ug();
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_ug_load function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_u2ug_load                       *
*                                                             *
* Description      : Load interesting groups for connections  *
*                    from file to memory.                     *
* Return Value     : rc                                       *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function loads the list of interesting groups, that will be
* used to identify interesting USER <-> GROUP connections, from the
* "Interesting Group (for connections) file" to the memory. The groups
* are loaded to the envir_ptr->int. static data - that is an array with
* an entry per possible RSS on current platform. In each entry (= RSS)
* - there are two data items (among otherS):
* pre_num_u2ugs - The number of interesting groups (for connections) in
*                 list.
* pre_u2ugs_ptr - A pointer to an array of interesting group names
*                 (each name in full length of ug name string).
* The function first clears all details of interesting groups (for
* ALL RSS types) - then reads the interesting groups into a single
* allocated buffer - than according to the amount of interesting
* groups for each RSS (that was determinded wile first load) - the
* function allocates a memory segment for the interesting groups
* of each RSS and fills in the group names.
**********************************************************************/
 
ESA_RC CARE_int_u2ug_load (void)
{
  char fn[]="CARE_int_u2ug_load";
  ESA_RC                  rc = ESA_OK;
  int                     ii, jj, * nn;
  INTEREST_UG_rec_typ   * all_u2ugs_ptr= NULL, * int_u2ug;
  long int                all_num_u2ugs= 0;
  MEMBER_UG_rec_typ       ug_rec;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  /*
    CLEAR all RSS all INTEGRESTING CONNECTION details.
  */
  rc= CSA_alloc ((char **)&nn,
                 0,
                 4,
                 envir_ptr->max_rss_num,
                 fn,
                 "work nn");
  if (rc NE ESA_OK)
      goto cleanup;
  CARE_int_u2ug_free();
  /*
    LOAD all connections in interesting groups file - into a single
    memory segment - check each group validity and count number
    of groups for each RSS.
  */
  rc= CARE_int_u2ug_load_without_rss(NULL, NULL,
                             &all_num_u2ugs, &all_u2ugs_ptr);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    SCAN all different RSS in platform.
  */
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1, "Interesting u2ugs=%d in rss %s",
                     envir_ptr->interest[ii].pre_num_u2ugs, envir_ptr->interest[ii].rss);
    /*
       CLEAR the number of interesting connections that already filled
       for current RSS.
    */
    nn[ii]= 0;
    /*
      PROCESS when the current RSS has interesting connection groups:
    */
    if (envir_ptr->interest[ii].pre_num_u2ugs GT 0)
    {
      /*
        ALLOCATE a global memory segment for current RSS groups -
        according to the number of groups for connections in current
        RSS.
      */
      rc= CSA_alloc ((char **)&envir_ptr->interest[ii].pre_u2ugs_ptr,
                     0, sizeof (MEMBER_UG_rec_typ),
                     envir_ptr->interest[ii].pre_num_u2ugs,
                     fn, "Intersting connections");
      if (rc NE ESA_OK)
        goto cleanup;
    } /* END - There are groups in current RSS */
 
  } /* END - FOR loop on ALL RSS */
  /*
    ROCESS all groups that were loaded from file:
  */
  for (jj= 0; jj LT all_num_u2ugs; jj++)
  {
    /*
      COPY the group details into temporary group details buffer.
    */
    int_u2ug = all_u2ugs_ptr+ jj;
    /*
      LOCATE current group's RSS entry in array.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
       if (My_stricmp(envir_ptr->interest[ii].rss,int_u2ug->rss) EQ 0)
          break;
    }
    /*
     * Copy the current group name to the next entry of group names
     * in the relevant RSS.
    */
    ug_rec.member_type = int_u2ug->member_type;
    strcpy (ug_rec.ug, int_u2ug->ug);
    strcpy ((char *)(envir_ptr->interest[ii].pre_u2ugs_ptr+ nn[ii]),
            (char *)&ug_rec);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
		"   rss %s: group number %d type %c name %s.",
        envir_ptr->interest[ii].rss, nn[ii], ug_rec.member_type, ug_rec.ug);
    /*
      INCREASE by 1 the actual number of groups in current RSS entry.
    */
    nn[ii]++;
  }
 
  cleanup:
  /*
    FREE the temporary allocated segment of all connections from file.
  */
  CSA_free ((char **)&all_u2ugs_ptr);
  CSA_free ((char **)&nn);
 
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  else {
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    "*****>... Aggregation Scope from %s with %d user groups loaded.",
		  envir_ptr->file_intu2ug, all_num_u2ugs);
    CARE_int_list_u2ug();
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_u2ug_load function */
 
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_oe_to_memory                    *
* Description      : Add number of increment containers       *
*                    to the memory                            *
* Input            : Pointer to array of containers to add    *
*                    Number of containers                     *
* Return Value     : rc                                       *
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function adds container names to the memory segment that holds
* INCREMENT ContainerS received as part of download process or global
* sync. Upon first activation - a memory segment is allocated and
* upon reactivation - the allocated memory segment is expanded
* (reallocated) to include the additional containers. The input
* container names are copied into the new space allocated and the
* number of containers is updated.
**********************************************************************/
 
ESA_RC CARE_inc_oe_to_memory (MEMBER_OE_rec_typ oe[1],
                              int    j)
{
  char                    fn[]="CARE_inc_oe_to_memory";
  ESA_RC                  rc = ESA_OK;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
      "%d oe-s for add to %d memory oe-s",j, envir_ptr->num_oes);
  /*
    PROCESS when no oes were filled up to now:
  */
  if (envir_ptr->num_oes EQ 0)
    /*
      ALLOCATE memory for the number of input containers names.
    */
    rc= CSA_alloc ((char **)&envir_ptr->oes_ptr, 0,
                   sizeof (MEMBER_OE_rec_typ),
                   j, fn, "Increment containers");
  else
    /*
      REALLOCATE a memory segment for container names to include the
      additional containers received now.
    */
    rc= CSA_realloc ((char **)&envir_ptr->oes_ptr, 0,
                     sizeof (MEMBER_OE_rec_typ),
                     envir_ptr->num_oes+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY new added containers to the allocated/additional buffer.
  */
  memcpy ((char *)(envir_ptr->oes_ptr + envir_ptr->num_oes),
          (char *)oe,
          sizeof (MEMBER_OE_rec_typ)* j);
  /*
    ADD number of input containers to the total number of containers.
  */
  envir_ptr->num_oes += j;
 
  cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
       "in memory %d oe-s", envir_ptr->num_oes);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
 
  return rc;
 
} /* END - CARE_inc_oe_to_memory function */
 
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_ug_to_memory                    *
* Description      : Add number of increment groups           *
*                    to the memory                            *
* Input            : Pointer to array of groups to add        *
*                    Number of groups                         *
* Return Value     : rc                                       *
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function adds group names to the memory segment that holds
* INCREMENT GROUPS received as part of download process or global
* sync. Upon first activation - a memory segment is allocated and
* upon reactivation - the allocated memory segment is expanded
* (reallocated) to include the additional groups. The input group
* names are copied into the new space allocated and the number of
* groups is updated.
**********************************************************************/
 
ESA_RC CARE_inc_ug_to_memory (MEMBER_UG_rec_typ ug[1],
                              int    j)
{
  char                    fn[]="CARE_inc_ug_to_memory";
  ESA_RC                  rc = ESA_OK;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
      "%d ug-s for add to %d memory ug-s",j, envir_ptr->num_ugs);
  /*
    PROCESS when no ugs were filled up to now:
  */
  if (envir_ptr->num_ugs EQ 0)
    /*
      ALLOCATE memory for the number of input groups names.
    */
    rc= CSA_alloc ((char **)&envir_ptr->ugs_ptr, 0,
                   sizeof (MEMBER_UG_rec_typ),
                   j, fn, "Increment groups");
  else
    /*
      REALLOCATE a memory segment for group names to include the
      additional groups received now.
    */
    rc= CSA_realloc ((char **)&envir_ptr->ugs_ptr, 0,
                     sizeof (MEMBER_UG_rec_typ),
                     envir_ptr->num_ugs+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY new added groups to the allocated/additional buffer.
  */
  memcpy ((char *)(envir_ptr->ugs_ptr + envir_ptr->num_ugs),
          (char *)ug,
          sizeof (MEMBER_UG_rec_typ)* j);
  /*
    ADD number of input groups to the total number of groups.
  */
  envir_ptr->num_ugs += j;
 
  cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
       "in memory %d ug-s", envir_ptr->num_ugs);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
 
  return rc;
 
} /* END - CARE_inc_ug_to_memory function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_u2ug_to_memory                  *
*                                                             *
* Description      : Add number of increment groups for connections
*                        to the memory
* Input            : Pointer to array of groups for conn. to add
*                    Number of groups for conn.
* Return Value     : rc
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function adds group names to the memory segment that holds
* INCREMENT GROUPS FOR CONNECTIONS received as part of download
* process or global sync.
* Upon first activation - a memory segment is allocated and
* upon reactivation - the allocated memory segment is expanded
* (reallocated) to include the additional groups. The input group
* names are copied into the new space allocated and the number of
* groups is updated.
**********************************************************************/
 
ESA_RC CARE_inc_u2ug_to_memory (MEMBER_UG_rec_typ ug[1],
                                int    j)
{
  char                  fn[]="CARE_inc_u2ug_to_memory";
  ESA_RC                rc = ESA_OK;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
                   "%d u2ug-s for add to %d memory u2ug-s",
                    j, envir_ptr->num_u2ugs);
  /*
    PROCESS when no ugs were filled up to now:
  */
  if (envir_ptr->num_u2ugs EQ 0)
    /*
      ALLOCATE memory for the number of input groups names.
    */
    rc= CSA_alloc ((char **)&envir_ptr->u2ugs_ptr, 0,
                   sizeof (MEMBER_UG_rec_typ),
                   j, fn, "Increment connections");
  else
    /*
      REALLOCATE a memory segment for group names to include the
      additional groups received now.
    */
    rc= CSA_realloc ((char **)&envir_ptr->u2ugs_ptr, 0,
                     sizeof (MEMBER_UG_rec_typ),
                     envir_ptr->num_u2ugs+ j);
  if (rc NE ESA_OK)
    goto cleanup;
  /*
    COPY new added groups to the allocated/additional buffer.
  */
  memcpy ((char *)(envir_ptr->u2ugs_ptr + envir_ptr->num_u2ugs),
          (char *)ug,
          sizeof (MEMBER_UG_rec_typ)* j);
  /*
    ADD number of input groups to the total number of groups.
  */
  envir_ptr->num_u2ugs += j;
 
  cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
       "in memory %d u2ug-s", envir_ptr->num_u2ugs);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
 
  return rc;
 
} /* END - CARE_inc_u2ug_to_memory function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_usr_to_memory                   *
*                                                             *
* Description      : Add number of increment users
*                        to the memory
* Input            : Pointer to array of users to add
*                    Number of users
* Return Value     : rc
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function adds user names to the memory segment that holds
* INCREMENT USERS received as part of download process or global
* sync. Upon first activation - a memory segment is allocated and
* upon reactivation - the allocated memory segment is expanded
* (reallocated) to include the additional users. The input user
* names are copied into the new space allocated and the number of
* users is updated.
**********************************************************************/
 
ESA_RC CARE_inc_usr_to_memory (MEMBER_USER_rec_typ user[1],
                               int      j)
{
  char                    fn[]="CARE_inc_usr_to_memory";
  ESA_RC                  rc = ESA_OK;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
      "%d users for add to %d memory users", j,envir_ptr->num_users);
  /*
    PROCESS when no users were filled up to now:
  */
  if (envir_ptr->num_users EQ 0)
    /*
      ALLOCATE memory for the number of input users names.
    */
    rc= CSA_alloc ((char **)&envir_ptr->users_ptr, 0,
                   sizeof (MEMBER_USER_rec_typ),
                   j, fn, "Increment users");
  else
    /*
      REALLOCATE a memory segment for user names to include the
      additional users received now.
    */
    rc= CSA_realloc ((char **)&envir_ptr->users_ptr, 0,
                     sizeof (MEMBER_USER_rec_typ),
                     envir_ptr->num_users+ j);
  if (rc NE ESA_OK)
    goto cleanup;
 
  /*
    COPY new added users to the allocated/additional buffer.
  */
  memcpy((char *)(envir_ptr->users_ptr+ envir_ptr->num_users),
         (char *)user,
         sizeof (MEMBER_USER_rec_typ)* j);
  /*
    ADD number of input users to the total number of users.
  */
  envir_ptr->num_users += j;
 
  cleanup:
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
       "in memory %d users", envir_ptr->num_users);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
 
  return rc;
 
} /* END - CARE_inc_usr_to_memory function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_oes_fill
*                                                             *
* Description      : Fill OE_PARAMS array with containers
*                      from list of increment containers
* Input            : from container number in these lists
* Output           : Array of OE_PARAMS
*                  : Number filled containers
**************************************************************/
 
ESA_RC CARE_inc_oes_fill (OE_PARAMS_rec_typ   oe_prm_in[1],
                          int                 from_num_oe,
                          short             * filled_num_oes)
{
  char                  fn[]="CARE_inc_oes_fill";
  int                   i;
  MEMBER_OE_rec_typ   * oe_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  *filled_num_oes= 0;
  for (i=   from_num_oe;
       i LT envir_ptr->num_oes AND *filled_num_oes LT MAX_GET;
       i++, (*filled_num_oes)++)
  {
    oe_rec = envir_ptr->oes_ptr+ i;
    strcpy (oe_prm_in[*filled_num_oes].oe, oe_rec->oe);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "%s: %d oe - %s (type %c)",
                     fn, i, oe_rec->oe, oe_rec->member_type);
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_only_ugs_fill                   *
* Description      : Fill UG_PARAMS array with groups
*                      from list of increment groups
* Input            : from group number in these lists
* Output           : Array of UG_PARAMS
*                  : Number filled groups
**************************************************************/
 
ESA_RC CARE_inc_only_ugs_fill (UG_typ            * ug_in,
                               int               * from_num_ug,
                               short             * filled_num_ugs)
{
  char                  fn[]="CARE_inc_only_ugs_fill";
  int                   i;
  MEMBER_UG_rec_typ   * ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  *filled_num_ugs= 0;
  for (i= (*from_num_ug);
       i LT envir_ptr->num_ugs AND *filled_num_ugs LT MAX_GET;
       i++, (*filled_num_ugs)++)
  {
     ug_rec = envir_ptr->ugs_ptr+ i;
     strcpy (ug_in[*filled_num_ugs], ug_rec->ug);
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d ug - %s (type %c)",
                      fn, i, ug_rec->ug, ug_rec->member_type);
  }
  (*from_num_ug) = i;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_ugs_fill
*                                                             *
* Description      : Fill UG_PARAMS array with groups
*                      from list of increment groups and/or
*                      from list of increment groups for connections
* Input            : from group number in these lists
* Output           : Array of UG_PARAMS
*                  : Number filled groups
**************************************************************/
 
ESA_RC CARE_inc_ugs_fill (UG_PARAMS_rec_typ   ug_prm_in[1],
                          int               * from_num_ug,
                          short             * filled_num_ugs)
{
  char                  fn[]="CARE_inc_ugs_fill";
  int                   i;
  MEMBER_UG_rec_typ   * ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  *filled_num_ugs= 0;
  for (i= (*from_num_ug);
       i LT envir_ptr->num_ugs AND *filled_num_ugs LT MAX_GET;
       i++, (*filled_num_ugs)++)
  {
     ug_rec = envir_ptr->ugs_ptr+ i;
     strcpy (ug_prm_in[*filled_num_ugs].group, ug_rec->ug);
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d ug - %s (type %c)",
                      fn, i, ug_rec->ug, ug_rec->member_type);
  }
  if (((*from_num_ug)+ (*filled_num_ugs)) GE envir_ptr->num_ugs)
  {
     for (i= (*from_num_ug)+ (*filled_num_ugs);
          i LT envir_ptr->num_ugs+ envir_ptr->num_u2ugs
              AND *filled_num_ugs LT MAX_GET;
          i++)
     {
        ug_rec = envir_ptr->u2ugs_ptr+ (i- envir_ptr->num_ugs);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                         "%s: %d(%d) u2ug - %s (type %c) -> %s",
                         fn, i, i- envir_ptr->num_ugs,
                         ug_rec->ug, ug_rec->member_type,
                         (ug_rec->member_type EQ M_DWNLD_NAME_IGNORE) ?
                         "SKIPPED"
                         :
                         "FILLED");
        if (ug_rec->member_type EQ M_DWNLD_NAME_IGNORE)
           continue;
        strcpy (ug_prm_in[*filled_num_ugs].group, ug_rec->ug);
        (*filled_num_ugs)++;
     }
  }
  (*from_num_ug) = i;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_u2ugs_fill
*                                                             *
* Description      : Fill UG_PARAMS array with groups
*                      from list of increment groups and/or
*                      from list of increment groups for connections
* Input            : from group number in these lists
* Output           : Array of UG_PARAMS
*                  : Number filled groups
**************************************************************/
 
ESA_RC CARE_inc_u2ugs_fill (UG_typ              ug_in[1],
                            int               * from_num_ug,
                            short             * filled_num_ugs)
{
  char                  fn[]="CARE_inc_u2ugs_fill";
  int                   i;
  MEMBER_UG_rec_typ   * ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  *filled_num_ugs= 0;
  for (i= (*from_num_ug);
       i LT envir_ptr->num_ugs AND *filled_num_ugs LT MAX_GET;
       i++, (*filled_num_ugs)++)
  {
     ug_rec = envir_ptr->ugs_ptr+ i;
     strcpy (ug_in[*filled_num_ugs], ug_rec->ug);
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d ug - %s (type %c)",
                      fn, i, ug_rec->ug, ug_rec->member_type);
  }
 
  if (((*from_num_ug)+ (*filled_num_ugs)) GE envir_ptr->num_ugs)
  {
     for (i= (*from_num_ug)+ (*filled_num_ugs);
          i LT envir_ptr->num_ugs+ envir_ptr->num_u2ugs
              AND *filled_num_ugs LT MAX_GET;
          i++)
     {
        ug_rec = envir_ptr->u2ugs_ptr+ (i- envir_ptr->num_ugs);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                         "%s: %d(%d) u2ug - %s (type %c) -> %s",
                         fn, i, i- envir_ptr->num_ugs,
                         ug_rec->ug, ug_rec->member_type,
                         (ug_rec->member_type EQ M_DWNLD_NAME_IGNORE) ?
                         "SKIPPED"
                         :
                         "FILLED");
        if (ug_rec->member_type EQ M_DWNLD_NAME_IGNORE)
           continue;
        strcpy (ug_in[*filled_num_ugs], ug_rec->ug);
        (*filled_num_ugs)++;
     }
  }
 
  (*from_num_ug) =i;
 
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_users_fill
*                                                             *
* Description      : Fill USER_PARAMS array with users
*                      from list of increment users
* Input            : from user number in list
* Output           : Array of USER_PARAMS
*                  : Number filled users
**************************************************************/
 
ESA_RC CARE_inc_users_fill (USER_PARAMS_rec_typ   user_prm_in[1],
                            int                 * from_num_user,
                            char                  user_type,
                            short               * filled_num_users)
{
  char                  fn[]="CARE_inc_users_fill";
  MEMBER_USER_rec_typ * user_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  *filled_num_users= 0;
  for (;
          ((*from_num_user)    LT envir_ptr->num_users)
           AND
           ((*filled_num_users) LT MAX_GET);
       (*from_num_user)++)
  {
     user_rec = envir_ptr->users_ptr+ (*from_num_user);
     if (user_rec->member_type EQ user_type)
     {
        strcpy (user_prm_in[*filled_num_users].user, user_rec->user);
        (*filled_num_users)++;
     }
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d ug - %s (type %c) - %s",
                      fn, (*from_num_user), user_rec->user,
                      user_rec->member_type,
                      (user_rec->member_type EQ user_type) ?
                      "FILLED"
                      :
                      "SKIPED");
  }
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_u2ugs_fill
*                                                             *
* Description      : Fill UG_typ array with groups
*                      from list of intersting groups and/or
*                      from list of interesting groups for conn.
* Input            : from group number in these lists
* Output           : Array of UG_typ
*                  : Number filled groups
**************************************************************/
 
ESA_RC CARE_int_u2ugs_fill (UG_typ   ug[1],
                            int    * from_num_ug,
                            short  * filled_num_ugs)
{
  char                  fn[]="CARE_int_u2ugs_fill";
  int                   ii, jj = 0;
  MEMBER_UG_rec_typ   * ug_ptr;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  ii = (*from_num_ug);
  *filled_num_ugs= 0;
  for (;
         (ii LT envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs)
           AND
         ((*filled_num_ugs) LT MAX_GET);
       ii++, jj++)
  {
     ug_ptr= envir_ptr->interest[envir_ptr->rss_num].pre_u2ugs_ptr+ ii;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d ug - %s (type %c) -> %s",
                      fn, ii, ug_ptr->ug, ug_ptr->member_type,
                      (ug_ptr->member_type EQ M_DWNLD_NAME_IGNORE) ?
                      "SKIPPED"
                      :
                      "FILLED");
     if (ug_ptr->member_type EQ M_DWNLD_NAME_IGNORE)
        continue;
     (*filled_num_ugs)++;
     strcpy (ug[*filled_num_ugs], ug_ptr->ug);
  }
  if (((*from_num_ug)+ jj) GE
      envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs)
  {
     for (ii=(*from_num_ug)+ jj;
          ii LT envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs+
              envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs AND
              *filled_num_ugs LT MAX_GET;
          ii++, (*filled_num_ugs)++)
     {
        ug_ptr= envir_ptr->interest[envir_ptr->rss_num].pre_ugs_ptr+
          (ii- envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs);
        strcpy (ug[*filled_num_ugs], ug_ptr->ug);
 
        ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
           "%s: %d(%d) u2ug - %s (type %c)",
           fn, ii,
           ii- envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs,
           ug_ptr->ug, ug_ptr->member_type);
    }
  }
 
  (*from_num_ug) = ii;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_oe_find
*                                                             *
* Description      : determine if container is in list of
*                      intcrement containers
* Return Value     : ESA_OK or ESA_KEY_NOT_FOUND (exist or not)
*                                                             *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* This function scans, the list of interesting default containers,
* that were already filled in the increment default containers
* memory segment, after a WILD_STR container name or after the
* input container name.
* If such container name is found - the function returns ESA_OK,
* otherwise it returns ESA_KEY_NOT_FOUND.
*********************************************************************/
 
ESA_RC CARE_inc_oe_find (OE_typ   oe)
{
  ESA_RC                rc = ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  int                   ii = 0, jj= 0;
  MEMBER_OE_rec_typ   * oe_ptr;
  char                  fn[]="CARE_inc_oe_find";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "CONTAINER %s.",
	  (oe[0] EQ '\0') ? "ALL" : oe);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
      "%s: oe - %s  dwnld_sync_method %c.",
      fn,
      oe,
      envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method);
 
  if (envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method
      EQ M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_inc_object_in_oe ((char *)oe, TYPE_CONTAINER);
     goto cleanup;
  }
 
  rc= ESA_KEY_NOT_FOUND;
  for (ii= 0;
       ii LT envir_ptr->num_oes;
       ii++)
  {
     oe_ptr = envir_ptr->oes_ptr + ii;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d oe - %s (type %c).",
                      fn, ii, oe_ptr->oe, oe_ptr->member_type);
     if (oe_ptr->member_type EQ M_DWNLD_NAME_ALL)
        rc = ESA_OK;
     else if (strlen (oe) EQ 0)
		 continue;
     else
	 {
        if (jj EQ 0)
		{
           rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
           if (rc NE ESA_OK)
              break;
		   jj++;
		}
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)oe, "TYPE_CONTAINER",
            (char *)oe_ptr->oe, "MASK_REGULAR");
        rc = envir_ptr->func_ptr.ismaskmatch_ptr (oe,
                                  (char *)oe_ptr->oe,
                                  TYPE_CONTAINER,
                                  MASK_REGULAR,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
	 }
     if (rc EQ ESA_OK)
        break;
  }
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
 cleanup:
   ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "     The account %s.",
	   (rc EQ ESA_OK) ? "in current scope" : "not in current scope");
  if (rc EQ ESA_OK)
     rc= rc_logout;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return(rc);
 
} /* END - CARE_inc_oe_find function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_ug_find
*                                                             *
* Description      : determine if group is in list of
*                      intcrement groups
* Return Value     : ESA_OK or ESA_KEY_NOT_FOUND (exist or not)
*                                                             *
**************************************************************/
 
ESA_RC CARE_inc_ug_find (UG_typ  ug)
{
  char                  fn[]="CARE_inc_ug_find";
  int                   ii, jj= 0;
  ESA_RC                rc = ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  MEMBER_UG_rec_typ   * ug_ptr;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "GROUP %s.",
	  (ug[0] EQ '\0') ? "ALL" : ug);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
     "ug - %s dwnld_sync_method %c.",
     ug,
     envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method);
 
  if (envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method EQ
      M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_inc_object_in_oe ((char *)ug, TYPE_GROUP);
     goto cleanup;
  }
 
  rc= ESA_KEY_NOT_FOUND;
  for (ii= 0;
       ii LT envir_ptr->num_ugs;
       ii++)
  {
     ug_ptr = envir_ptr->ugs_ptr + ii;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%d ug - %s (type %c).",
                      ii,
                      ug_ptr->ug,
                      ug_ptr->member_type);
     if (ug_ptr->member_type EQ M_DWNLD_NAME_ALL)
        rc = ESA_OK;
     else if (strlen (ug) EQ 0)
		 continue;
     else
     {
        if (jj EQ 0)
		{
           rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
           if (rc NE ESA_OK)
              break;
		   jj++;
		}
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)ug, "TYPE_GROUP",
            (char *)ug_ptr->ug, "MASK_REGULAR");
        rc = envir_ptr->func_ptr.ismaskmatch_ptr (ug,
                                  (char *)ug_ptr->ug,
                                  TYPE_GROUP,
                                  MASK_REGULAR,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
     }
     if (rc EQ ESA_OK)
        break;
  }
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
cleanup:
   ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "     The account %s.",
	   (rc EQ ESA_OK) ? "in current scope" : "not in current scope");
  if (rc EQ ESA_OK)
     rc= rc_logout;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CARE_inc_ug_find function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_u2ug_find                       *
*                                                             *
* Description      : determine if group is in list of         *
*                    intcrement groups for connections        *
* Return Value     : ESA_OK or ESA_KEY_NOT_FOUND (exist or not)         *
**************************************************************/
 
ESA_RC CARE_inc_u2ug_find (UG_typ  ug)
{
  char                  fn[]="CARE_inc_u2ug_find";
  int                   ii, jj= 0;
  ESA_RC                rc = ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  MEMBER_UG_rec_typ   * ug_ptr;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "GROUP %s.",
	  (ug[0] EQ '\0') ? "ALL" : ug);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
     "ug - %s dwnld_sync_method %c.",
     ug,
     envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method);
 
  if (envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method EQ
      M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_inc_object_in_oe ((char *)ug, TYPE_GROUP);
     goto cleanup;
  }
 
  rc= ESA_KEY_NOT_FOUND;
  for (ii= 0;
       ii LT envir_ptr->num_u2ugs;
       ii++)
  {
     ug_ptr = envir_ptr->u2ugs_ptr + ii;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%d ug - %s (type %c).",
                      ii,
                      ug_ptr->ug,
                      ug_ptr->member_type);
     if (ug_ptr->member_type EQ M_DWNLD_NAME_IGNORE)
        continue;
     if (ug_ptr->member_type EQ M_DWNLD_NAME_ALL)
        rc = ESA_OK;
     else if (strlen (ug) EQ 0)
		 continue;
     else
	 {
        if (jj EQ 0)
		{
           rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
           if (rc NE ESA_OK)
              break;
		   jj++;
		}
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)ug, "TYPE_GROUP",
            (char *)ug_ptr->ug, "MASK_REGULAR");
        rc = envir_ptr->func_ptr.ismaskmatch_ptr (ug,
                                  (char *)ug_ptr->ug,
                                  TYPE_GROUP,
                                  MASK_REGULAR,
                                  &envir_ptr->msg_admin_param,
                                  &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
	 }
     if (rc EQ ESA_OK)
        break;
  }
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
cleanup:
   ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "     The account %s.",
	   (rc EQ ESA_OK) ? "in current scope" : "not in current scope");
  if (rc EQ ESA_OK)
     rc= rc_logout;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END CARE_inc_u2ug_find - function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_usr_find
*                                                             *
* Description      : determine if user is in list of
*                      intcrement users
* Return Value     : ESA_OK or ESA_KEY_NOT_FOUND (exist or not)
**************************************************************/
 
ESA_RC CARE_inc_usr_find (USER_typ  user,
                          char      member_type)
{
  char                  fn[]="CARE_inc_usr_find";
  int                   ii= 0, jj= 0;
  ESA_RC                rc = ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  MEMBER_USER_rec_typ * user_ptr;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CARE_type (ESA_COMP_ACSCARF, fn, "USER", (char *)user, member_type);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
       "user - %s (type %c), dwnld_sync_method %c num_users=%d.",
       user,
       member_type,
       envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method,
       (int)envir_ptr->num_users);
  /*
    SEARCH if user is in the wilcard list of interesting users
  */
  if (envir_ptr->interest[envir_ptr->rss_num].dwnld_sync_method EQ
      M_DWNLD_SYNC_METHOD_SUBTREE)
  {
     rc = CARE_inc_object_in_oe ((char *)user, TYPE_USER);
     goto cleanup;
  }
 
  rc= ESA_KEY_NOT_FOUND;
  for(ii= 0;
      ii LT envir_ptr->num_users;
      ii++)
  {
     user_ptr = envir_ptr->users_ptr + ii;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%d user - %s (type %c).",
                      ii,
                      user_ptr->user,
                      user_ptr->member_type);
     if (user_ptr->member_type EQ M_DWNLD_NAME_IGNORE)
        continue;
     if (user_ptr->member_type EQ M_DWNLD_NAME_ALL)
     {
        rc = ESA_OK;
        break;
     }
     if (strlen (user) EQ 0)
		 continue;
     if (jj EQ 0)
	 {
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
           break;
	    jj++;
	 }
     ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)user, "TYPE_USER",
            (char *)user_ptr->user,
            (user_ptr->member_type EQ M_DWNLD_NAME_WILD) ?
                                     "MASK_WILD" : "MASK_REGULAR");
     rc = envir_ptr->func_ptr.ismaskmatch_ptr (user,
                               (char *)user_ptr->user,
                               TYPE_USER,
                         (user_ptr->member_type EQ M_DWNLD_NAME_WILD) ?
                               MASK_WILD
                               :
                               MASK_REGULAR,
                               &envir_ptr->msg_admin_param,
                               &envir_ptr->msg_err);
     ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
     if (rc EQ ESA_OK)
        break;
 
     if (member_type EQ M_DWNLD_NAME_WILD)
     {
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsMaskMatch USA-API for Obj=%s (%s)  Mask=%s (%s)",
			(char *)user_ptr->user, "TYPE_USER",
            (char *)user, "MASK_WILD");
        rc= envir_ptr->func_ptr.ismaskmatch_ptr (user_ptr->user,
                                 (char *)user,
                                 TYPE_USER,
                                 MASK_WILD,
                                 &envir_ptr->msg_admin_param,
                                 &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsMaskMatch USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
        if (rc EQ ESA_OK)
        {
           /*
             Ignore (delete) this user
             AND
             instead of the ignored user ADD NEW user
           */
           user_ptr->member_type = M_DWNLD_NAME_IGNORE;
           rc = ESA_KEY_NOT_FOUND;
        }
     }
  }
 
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
cleanup:
   ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES, "     The account %s.",
	   (rc EQ ESA_OK) ? "in current scope" : "not in current scope");
  if (rc EQ ESA_OK)
     rc= rc_logout;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CARE_inc_usr_find function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_to_int_copy
*                                                             *
* Description      : Set pointers of interesting users,
*                         groups, default groups and conatiners
*                  : to  pointers of increment users
*                        groups, default groups and containers
**************************************************************/
 
void CARE_inc_to_int_copy (void)
{
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_inc_to_int_copy";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_users=
      envir_ptr->num_users;
  envir_ptr->interest[envir_ptr->rss_num].pre_users_ptr=
      envir_ptr->users_ptr;
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs=
      envir_ptr->num_ugs;
  envir_ptr->interest[envir_ptr->rss_num].pre_ugs_ptr=
      envir_ptr->ugs_ptr;
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs=
      envir_ptr->num_u2ugs;
  envir_ptr->interest[envir_ptr->rss_num].pre_u2ugs_ptr=
      envir_ptr->u2ugs_ptr;
 
  envir_ptr->interest[envir_ptr->rss_num].pre_num_oes=
      envir_ptr->num_oes;
  envir_ptr->interest[envir_ptr->rss_num].pre_oes_ptr=
      envir_ptr->oes_ptr;
 
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
} /* END - CARE_inc_to_int_copy function */
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_list_oe (MEMBER_OE_rec_typ * oes_ptr,
                   long int            num_oes)
 
{
  int                   ii;
  char                * oe = NULL;    /* AJK001 */
  char                  oe_typ  [MAX_RSS_OE_NAME_LEN+4];
  char                  log_msg [ERR_MSG_TEXT_LEN - MAX_RSS_OE_NAME_LEN - 4];
  char                  row_msg [MAX_RSS_OE_NAME_LEN+4];
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_list_oe";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
 
  if (num_oes EQ 0)
     goto cleanup;
 
  CLEAR (log_msg);
  CLEAR (row_msg);
 
  for (ii= 0; ii LE num_oes; ii++)
  {
 
     if (ii LT num_oes)
        oe= (char *)(oes_ptr + ii);
     else
        strcat (log_msg, row_msg);
 
     if ((strlen (log_msg) GT
          (sizeof(log_msg) - strlen(row_msg) - strlen(oe) - 6)) OR
         (ii EQ num_oes))
     {
 
        if (strlen(log_msg) GT 2)
           log_msg[strlen(log_msg)-2] = '\0';
 
        CTSAMSG_print (MSG_LIST_CONTAINERS,
                       envir_ptr->msg_params.ctsamsg_handle, NULL,
                       envir_ptr->msg_params.ctsamsg_dest,
                       log_msg);
 
        CLEAR (log_msg);
     }
 
     if (ii EQ num_oes)
        break;
 
     if (strlen (row_msg) GT (MAX_RSS_OE_NAME_LEN+ 4 - strlen(oe) - 6))
     {
        strcat (log_msg, row_msg);
        strcat (log_msg, "\n");
        CLEAR (row_msg);
     }
 
     if (*oe EQ M_DWNLD_NAME_IGNORE)
         continue;
     if (*oe EQ M_DWNLD_NAME_ALL)
        strcpy (oe_typ, "ALL");
     else
        sprintf (oe_typ,"%s",oe+1);
     strcat (row_msg, oe_typ);
     strcat (row_msg, " , ");
 
  }
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_list_ug (MEMBER_UG_rec_typ * ugs_ptr,
                   long int            num_ugs)
{
  int                   ii;
  char                * ug= NULL;
  char                  ug_typ[MAX_RSS_UG_NAME_LEN+4];
  char                  log_msg[ERR_MSG_TEXT_LEN - MAX_RSS_UG_NAME_LEN- 4];
  char                  row_msg[MAX_RSS_UG_NAME_LEN+4];
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_list_ug";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (num_ugs EQ 0)
     goto cleanup;
 
  CLEAR (log_msg);
  CLEAR (row_msg);
 
  for (ii= 0; ii LE num_ugs; ii++)
  {
 
     if (ii LT num_ugs)
        ug= (char *)(ugs_ptr+ ii);
     else
        strcat (log_msg, row_msg);
 
     if ((strlen (log_msg) GT
          (sizeof(log_msg) - strlen(row_msg) - strlen(ug) - 6)) OR
         (ii EQ num_ugs))
     {
 
        if (strlen(log_msg) GT 2)
           log_msg[strlen(log_msg)-2] = '\0';
 
        CTSAMSG_print (MSG_LIST_DEF_GROUPS,
                       envir_ptr->msg_params.ctsamsg_handle, NULL,
                       envir_ptr->msg_params.ctsamsg_dest,
                       log_msg);
 
        CLEAR (log_msg);
     }
 
     if (ii EQ num_ugs)
        break;
 
     if (strlen (row_msg) GT (MAX_RSS_UG_NAME_LEN+ 4 - strlen(ug) - 6))
     {
        strcat (log_msg, row_msg);
        strcat (log_msg, "\n");
        CLEAR (row_msg);
     }
 
     if (*ug EQ M_DWNLD_NAME_IGNORE)
         continue;
     if (*ug EQ M_DWNLD_NAME_ALL)
        strcpy (ug_typ, "ALL");
     else
        sprintf (ug_typ,"%s",ug+1);
     strcat (row_msg, ug_typ);
     strcat (row_msg, " , ");
 
  }
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_list_u2ug (MEMBER_UG_rec_typ * u2ugs_ptr,
                     long int            num_u2ugs)
{
  int                   ii;
  char                * ug= NULL;
  char                  ug_typ[MAX_RSS_UG_NAME_LEN+4];
  char                  log_msg[ERR_MSG_TEXT_LEN - MAX_RSS_UG_NAME_LEN- 4];
  char                  row_msg[MAX_RSS_UG_NAME_LEN+4];
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_list_u2ug";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (num_u2ugs EQ 0)
     goto cleanup;
 
  CLEAR (log_msg);
  CLEAR (row_msg);
 
  for (ii= 0; ii LE num_u2ugs; ii++)
  {
 
     if (ii LT num_u2ugs)
        ug= (char *)(u2ugs_ptr+ ii);
     else
        strcat (log_msg, row_msg);
 
 
     if ((strlen (log_msg) GT
          (sizeof(log_msg) - strlen(row_msg) - strlen(ug) - 6)) OR
         (ii EQ num_u2ugs))
     {
 
        if (strlen(log_msg) GT 2)
           log_msg[strlen(log_msg)-2] = '\0';
 
        CTSAMSG_print (MSG_LIST_GROUPS,
                       envir_ptr->msg_params.ctsamsg_handle, NULL,
                       envir_ptr->msg_params.ctsamsg_dest,
                       log_msg);
 
        CLEAR (log_msg);
     }
 
     if (ii EQ num_u2ugs)
        break;
 
     if (strlen (row_msg) GT (MAX_RSS_UG_NAME_LEN+ 4 - strlen(ug) - 6))
     {
        strcat (log_msg, row_msg);
        strcat (log_msg, "\n");
        CLEAR (row_msg);
     }
 
     if (*ug EQ M_DWNLD_NAME_IGNORE)
         continue;
     if (*ug EQ M_DWNLD_NAME_ALL)
        strcpy (ug_typ, "ALL");
     else
        sprintf (ug_typ,"%s", ug+1);
     strcat (row_msg, ug_typ);
     strcat (row_msg, " , ");
 
  }
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_list_usr (MEMBER_USER_rec_typ * users_ptr,
                    long int              num_users)
{
  int                   ii;
  char                * ug= NULL;
  char                  ug_typ[MAX_RSS_USER_NAME_LEN+4];
  char                  log_msg[ERR_MSG_TEXT_LEN - MAX_RSS_USER_NAME_LEN- 4];
  char                  row_msg[MAX_RSS_USER_NAME_LEN+ 4];
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_list_usr";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (num_users EQ 0)
     goto cleanup;
 
  CLEAR (log_msg);
  CLEAR (row_msg);
 
  for (ii= 0; ii LE num_users; ii++)
  {
 
     if (ii LT num_users)
       ug= (char *)(users_ptr+ ii);
     else
        strcat (log_msg, row_msg);
 
     if ((strlen (log_msg) GT
          (sizeof(log_msg) - strlen(row_msg) - strlen(ug) - 9)) OR
         (ii EQ num_users))
     {
 
        if (strlen(log_msg) GT 2)
           log_msg[strlen(log_msg)-2] = '\0';
 
        CTSAMSG_print (MSG_LIST_USERS,
                       envir_ptr->msg_params.ctsamsg_handle, NULL,
                       envir_ptr->msg_params.ctsamsg_dest,
                       log_msg);
 
        CLEAR (log_msg);
     }
 
     if (ii EQ num_users)
        break;
 
     if (strlen (row_msg) GT (MAX_RSS_USER_NAME_LEN+ 4 - strlen(ug) - 9))
     {
        strcat (log_msg, row_msg);
        strcat (log_msg, "\n");
        CLEAR (row_msg);
     }
 
     if (*ug EQ M_DWNLD_NAME_IGNORE)
         continue;
     if (*ug EQ M_DWNLD_NAME_ALL)
        strcpy (ug_typ, "ALL");
     else if (*ug EQ M_DWNLD_NAME_WILD)
        sprintf (ug_typ,"PREFIX %s", ug+1);
     else
        sprintf (ug_typ,"%s", ug+1);
     strcat (row_msg, ug_typ);
     strcat (row_msg, " , ");
 
  }
  cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_int_list_oe (void)
{
  int                   ii, jj;
  char                * ug;
  char                  type[7]="";
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_list_oe";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSCB) LE DIAG_BASIC)
     goto cleanup;
  ESA_DIAG_printf(ESA_COMP_ACSCB, 0, "List of interest.containers\n");
 
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "   For rss %s:", envir_ptr->interest[ii].rss);
     for (jj= 0; jj LT envir_ptr->interest[ii].pre_num_oes; jj++)
	 {
        ug= (char *)(envir_ptr->interest[ii].pre_oes_ptr+ jj);
        if (*ug EQ M_DWNLD_NAME_IGNORE)
           continue;
        if (*ug EQ M_DWNLD_NAME_ALL)
           strcpy (type, "ALL");
        else if (*ug EQ M_DWNLD_NAME_WILD)
           strcpy (type, "PREFIX");
        else
           strcpy (type, "");
        ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "      %d) %s %s)",jj+ 1,type,ug+1);
	 }
  }
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "_____________________\n");
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
 
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_int_list_ug (void)
{
  int                   ii, jj;
  char                * ug;
  char                  type[7]="";
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_list_ug";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSCB) LE DIAG_BASIC)
		goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "List of interest. default groups\n");
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "   For rss %s:", envir_ptr->interest[ii].rss);
     for (jj= 0; jj LT envir_ptr->interest[ii].pre_num_ugs; jj++)
	 {
        ug= (char *)(envir_ptr->interest[ii].pre_ugs_ptr+ jj);
        if (*ug EQ M_DWNLD_NAME_IGNORE)
           continue;
        if (*ug EQ M_DWNLD_NAME_ALL)
           strcpy (type, "ALL");
        else if (*ug EQ M_DWNLD_NAME_WILD)
           strcpy (type, "PREFIX");
        else
           strcpy (type, "");
        ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "      %d) %s %s)",jj+1,type,ug+1);
	 }
  }
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "_____________________\n");
cleanup:
 
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_int_list_u2ug (void)
{
  int                   ii, jj;
  char                * ug;
  char                  type[7]="";
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_list_u2ug";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSCB) LE DIAG_BASIC)
		goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "List of interest. groups.\n");
 
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "   For rss %s:", envir_ptr->interest[ii].rss);
     for (jj= 0; jj LT envir_ptr->interest[ii].pre_num_u2ugs; jj++)
	 {
        ug= (char *)(envir_ptr->interest[ii].pre_u2ugs_ptr+ jj);
        if (*ug EQ M_DWNLD_NAME_IGNORE)
           continue;
        if (*ug EQ M_DWNLD_NAME_ALL)
           strcpy (type, "ALL");
        else if (*ug EQ M_DWNLD_NAME_WILD)
           strcpy (type, "PREFIX");
        else
           strcpy (type, "");
        ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "      %d) %s %s)",jj+1,type, ug+1);
	 }
  }
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "_____________________\n");
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
 *
 *
 *************************************************************/
 
void CARE_int_list_usr (void)
{
  int                   ii, jj;
  char                * ug;
  char                  type[7]="";
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_int_list_usr";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
 
  if (ESA_DIAG_get_debug_level(ESA_COMP_ACSCB) LE DIAG_BASIC)
		goto cleanup;
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "List of interest. users\n");
  for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
  {
     ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "   For rss %s:", envir_ptr->interest[ii].rss);
     for (jj= 0; jj LT envir_ptr->interest[ii].pre_num_users; jj++)
	 {
        ug= (char *)(envir_ptr->interest[ii].pre_users_ptr+ jj);
        if (*ug EQ M_DWNLD_NAME_IGNORE)
           continue;
        if (*ug EQ M_DWNLD_NAME_ALL)
           strcpy (type, "ALL");
        else if (*ug EQ M_DWNLD_NAME_WILD)
           strcpy (type, "PREFIX");
        else
           strcpy (type, "");
        ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "      %d) %s %s.", jj+1,type,ug+1);
	 }
  }
  ESA_DIAG_printf (ESA_COMP_ACSCB, 0, "_____________________\n");
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_usr_load_without_rss            *
*                                                             *
* Description      : Load data from the file to the memory    *
*                         without rss records                 *
* Input            : rss                                      *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* The function is activated in order to scan the "Interesting Users"
* - and to load it to a global memory segment. The segment
* is arranged in array format where every entry contains: RSS name &
* User name. In addition - the function fills in all RSS entries, in
* the RSS array of the envir external data, with the number of users
* that resides, in the segment, for them.
* The function scans all records from the file, checks the RSS
* existance the User-name validity and inserts it to a temporary array
* (that contains fixed number of entries). Whenever the temporary array
* is filled - the memory segment allocated for users is expanded by
* it's size - it's content is copied to the memory allocated, the
* number of output users is updated and the temporary array is cleared
* - and so on.
**********************************************************************/
 
ESA_RC CARE_int_usr_load_without_rss(char             * rss,
                               MEMBER_USER_rec_typ    * pre_users_ptr,
                               long int               * all_num_users,
                               INTEREST_USER_rec_typ ** all_users_ptr)
{
  char fn[]="CARE_int_usr_load_without_rss";
  ESA_RC                  rc = ESA_OK;
  INTEREST_USER_rec_typ   tmp_user [TMP_USERS_NUM];
  int                     i= 0, j= 0, ii= 0;
  char                    line [sizeof (INTEREST_USER_rec_typ)];
  FILE                  * file_handle= NULL;
  char                  * user_in= NULL, *rss_in= NULL, * newline=NULL;
  char                  * endline, empty_str = '\0';
  char                  * member_type_in= NULL;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
      "Rss=%s File=%s",
      (rss EQ NULL) ? "NULL" : rss, envir_ptr->file_intuser);
  pre_users_ptr= NULL; /*???*/
  CLEAR (tmp_user);
  /*
    OPEN "Interesting Users" file.
  */
  rc= CSA_open (envir_ptr->file_intuser, fn,
                FILE_OPEN_FOR_UPDATE, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
   goto cleanup;
  /*
     SCAN all file record's.
  */
  for (i= 1,j= 0; rc EQ ESA_OK ; i++)
  {
    rss_in= NULL;
    member_type_in= NULL;
    user_in= NULL;
    endline = NULL;
    /*
      READ next file's line (record).
    */
    rc= CSA_fgets (envir_ptr->file_intuser,
                   line,
                   sizeof(INTEREST_USER_rec_typ),
                   file_handle);
    if (rc EQ ESA_EOF)
    {
        rc= ESA_OK;
        break;
    }
    if (rc NE ESA_OK)
        goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
               "record %d is %s.", i+ 1, line);
    /*
      COPY the user details to NEXT entry in temporary groups details
      arry.
    */
    memcpy ((char *)(&tmp_user [j]), (char *)line,
            sizeof(INTEREST_USER_rec_typ));
    newline = strchr(line,'\n');
    if (newline NE NULL)
      strcpy (newline,"\0");
    rss_in=  strtok (line, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"rss_in=%p/%s.",
		rss_in, (rss_in) ? rss_in : "NULL");
    member_type_in= strtok (NULL, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"member_type_in=%p/%s.",
		member_type_in, (member_type_in) ? member_type_in : "NULL");
    user_in= strtok (NULL, " ");
	endline= strtok (NULL, " ");
    if (user_in EQ 0)
       user_in = &empty_str;
	else
    {
       while (endline NE NULL)
	   {
          user_in [strlen(user_in)] = ' ';
          ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"while user_in=%s.", user_in);
          endline           = strtok (NULL, " ");
	   }
	}
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"user_in=%p/%s.", user_in, user_in);
 
    /*
      SKIP current user (do not set array index up by 1) if the line
      is empty or the RSS name is empty.
    */
    if(line[0] EQ NULL_CHAR OR line[0] EQ SKIP_LINE OR rss_in EQ NULL)
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Skipped ->%d<- record" , i);
      continue;
    }
    /*
      EXIT, returning fatal error if the RSS name or the User name is
      invalid.
    */
    if (member_type_in EQ NULL)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               C_MEMBER_TYPE, "", envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
        (strlen(member_type_in)       GT 1)
            OR
            (
                (*member_type_in NE M_DWNLD_NAME_WILD)
                    AND
                (*member_type_in NE M_DWNLD_NAME_REGULAR)
                    AND
            (*member_type_in NE M_DWNLD_NAME_ALL)
                    AND
        (*member_type_in NE M_DWNLD_NAME_IGNORE)
                )
        )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_MEMBER_TYPE, member_type_in ,
                     envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
        (user_in EQ NULL)
            AND
        (*member_type_in NE M_DWNLD_NAME_ALL)
        )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_USER_ID, "", envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (strlen(rss_in)       GT RSS_NAME_LEN)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_RSS_NAME , rss_in ,
                     envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (MAX_RSS_USER_NAME_LEN LT strlen(user_in))
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_USER_ID, user_in,
                     envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (rss NE NULL AND strncmp (rss, rss_in, RSS_NAME_LEN) EQ 0)
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
          "Skipped %d record (need another rss)" , i);
      continue;
    }
    /*
      LOCATE the user's RSS among the RSSs known in current platform.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      /*
        PROCESS when RSS name - found:
      */
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
          "%d rss=%s rss_in=%s.", ii, envir_ptr->interest[ii].rss, rss_in);
      if (My_stricmp (rss_in, envir_ptr->interest[ii].rss) EQ 0)
      {
        /*
          SET number of users in found RSS entry - up by 1
        */
        envir_ptr->interest[ii].pre_num_users++;
        ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
          "%d rss=%s rss_in=%s pre_num_users=%d.",ii, envir_ptr->interest[ii].rss, rss_in,
		  envir_ptr->interest[ii].pre_num_users);
        break;
      }
    } /* END - FOR loop on known RSSs */
    /*
      EXIT returning fatal error - if RSS is unknown.
    */
    if (ii GE envir_ptr->max_rss_num)
    {
      CTSAMSG_print (ERR_CS_RSS_ENTITY,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     rss_in, envir_ptr->file_intuser, fn);
      continue;
    }
    if (envir_ptr->interest[ii].rss[0] EQ '\0')
    {
      CTSAMSG_print (ERR_CS_RSS_INVALID_NAME,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, rss_in, envir_ptr->file_rssparm);
      rc= ESA_FATAL;
      goto cleanup;
    }
    /*
      SET the temporary user's array index up by 1.
    */
    strcpy (tmp_user [j].rss, rss_in);
    tmp_user[j].member_type = *member_type_in;
    tmp_user[j].blank1 = ' ';
    strcpy (tmp_user [j].user, user_in);
    j++;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Next %d user_rec %s.", j, &tmp_user[j]);
    /*
      PROCESS when the temporary users array is full:
    */
    if (j GE TMP_USERS_NUM)
    {
      /*
        PROCESS if no users memory segment were allocated yet:
      */
      if (*all_num_users EQ 0)
        /*
          ALLOCATE memory segment for filled temporary users array.
        */
        rc= CSA_alloc ((char **)all_users_ptr, STRUC_INT_USR_REC,
                       sizeof (INTEREST_USER_rec_typ),
                       j, fn, "All Intersting users");
      else
        /*
          REALOCATE the memory segment - expand it to contain another
          set of temporary users array.
        */
        rc= CSA_realloc ((char **)all_users_ptr, STRUC_INT_USR_REC,
                         sizeof (INTEREST_USER_rec_typ),
                         (*all_num_users)+ j);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        COPY all users in temporary array to the new
        allocated/extended memory segment.
      */
      memcpy ((char *)((*all_users_ptr)+(*all_num_users)),
              (char *)tmp_user,
              sizeof(INTEREST_USER_rec_typ)* j);
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
         "Added Next %d users to memory %d users", j, *all_num_users);
      /*
        INCREASE the output number of users in allocated segment - by
        the amount of users from temporary array.
      */
      (*all_num_users) += j;
      /*
        CLEAR the temporary array of users.
      */
      CLEAR (tmp_user);
      j= 0;
    }
 
  } /* FOR - loop on all file records */
 
  /*
    EXIT if no (more) users were added to the temporary users array
    since it was created/last copied to the memory segment.
  */
  if (j EQ 0)
    goto cleanup;
  /*
    PROCESS when loop terminated ok.
  */
  if (rc EQ ESA_OK)
      /*
        PROCESS if no users memory segment were allocated yet:
      */
      if ((*all_num_users) EQ 0)
        /*
          ALLOCATE memory segment for the filled users in temporary
          users array.
        */
        rc= CSA_alloc ((char **)all_users_ptr, STRUC_INT_USR_REC,
                       sizeof (INTEREST_USER_rec_typ),
                       j, fn, "All Intersting users");
      else
        /*
          REALOCATE the memory segment - expand it to contain the
          details of users that were filled in the temporary array.
        */
        rc= CSA_realloc ((char **)all_users_ptr, STRUC_INT_USR_REC,
                         sizeof (INTEREST_USER_rec_typ),
                         (*all_num_users)+ j);
  if (rc EQ ESA_OK)
  {
    /*
      COPY the filled users in temporary array to the new
      allocated/extended memory segment.
    */
    memcpy ((char *)((*all_users_ptr)+ (*all_num_users)),
            (char *)tmp_user,
            sizeof (INTEREST_USER_rec_typ)* j);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
       "Added Next %d users to memory %d users", j, *all_num_users);
    /*
      INCREASE the output number of users in allocated segment - by
      the number of users filled in temporary array.
    */
    (*all_num_users) += j;
  }
 
  cleanup:
  /*
    CLOSE "Interesting Users" file.
  */
  CSA_close (envir_ptr->file_intuser, fn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
                   "Interesting users=%d", *all_num_users);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_usr_load_without_rss function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_ug_load_without_rss             *
*                                                             *
* Description      : Load data from the file to the memory    *
*                    without rss records                      *
* Input            : rss                                      *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* The function is activated in order to scan the "Interesting Default
* Groups" file - and to load it to a global memory segment. The segment
* is arranged in array format where every entry contains: RSS name &
* Group name. In addition - the function fills in all RSS entries, in
* the RSS array of the envir external data, with the number of groups
* that resides, in the segment, for them.
* The function scans all records from the file, checks the RSS
* existance the Group-name validity and inserts it to a temporary array
* (that contains fixed number of entries). Whenever the temporary array
* is filled - the memory segment allocated for groups is expanded by
* it's size - it's content is copied to the memory allocated, the
* number of output groups is updated and the temporary array is cleared
* - and so on.
**********************************************************************/
 
ESA_RC CARE_int_ug_load_without_rss (
                                 char                 * rss,
                                 long int             * all_num_ugs,
                                 INTEREST_UG_rec_typ ** all_ugs_ptr)
{
  char fn[]="CARE_int_ug_load_without_rss";
  ESA_RC                  rc = ESA_OK;
  INTEREST_UG_rec_typ     tmp_ug [TMP_UGS_NUM];
  int                     i= 0, j= 0, ii= 0;
  char                    line [sizeof (INTEREST_UG_rec_typ)];
  char                  * ug_in= NULL, *rss_in= NULL, * newline= NULL;
  FILE                  * file_handle= NULL;
  char                  * endline, empty_str = '\0';
  char                  * member_type_in= NULL;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
      "Rss=%s File=%s",
      (rss EQ NULL) ? "NULL" : rss, envir_ptr->file_intug);
 
  CLEAR (tmp_ug);
  /*
    OPEN "Interesting Defalt Groups" file.
  */
  rc= CSA_open (envir_ptr->file_intug, fn,
                FILE_OPEN_FOR_UPDATE, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
   goto cleanup;
  /*
     SCAN all file record's.
  */
 
  for (i= 1,j= 0; rc EQ ESA_OK ; i++)
  {
    rss_in            = NULL;
    member_type_in    = NULL;
    ug_in             = NULL;
    endline           = NULL;
    /*
      READ next file's line (record).
    */
    rc= CSA_fgets (envir_ptr->file_intug,
                   line,
                   sizeof(INTEREST_UG_rec_typ),
                   file_handle);
    if (rc EQ ESA_EOF)
    {
        rc= ESA_OK;
        break;
    }
    if (rc NE ESA_OK)
        goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
               "record %d is %s.", i+ 1, line);
    /*
      COPY the group details to NEXT entry in temporary groups details
      arry.
    */
    memcpy ((char *)(&tmp_ug [j]), (char *)line,
            sizeof(INTEREST_UG_rec_typ));
    newline = strchr(line,'\n');
    if (newline NE NULL)
      strcpy (newline,"\0");
    rss_in=  strtok (line, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"rss_in=%p/%s.",
		rss_in, (rss_in) ? rss_in : "NULL");
    member_type_in= strtok (NULL, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"member_type_in=%p/%s.",
		member_type_in, (member_type_in) ? member_type_in : "NULL");
    ug_in= strtok (NULL, " ");
	endline= strtok (NULL, " ");
    if (ug_in EQ 0)
       ug_in = &empty_str;
	else
    {
       while (endline NE NULL)
	   {
          ug_in [strlen(ug_in)] = ' ';
          ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"while ug_in=%s.", ug_in);
          endline           = strtok (NULL, " ");
	   }
	}
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"ug_in=%p/%s.", ug_in, ug_in);
 
    /*
      SKIP current group (do not set array index up by 1) if the line
      is empty or the RSS name is empty.
    */
    if (
          (line[0] EQ NULL_CHAR)
         OR
          (line[0] EQ SKIP_LINE)
         OR
          (rss_in EQ NULL)
       )
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Skipped %d record" , i);
      continue;
    }
    /*
      EXIT, returning fatal error if the RSS name or the Group name is
      invalid.
    */
    if (member_type_in EQ NULL)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               C_MEMBER_TYPE, "", envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
          (strlen(member_type_in)       GT 1)
         OR
          (
            (*member_type_in NE M_DWNLD_NAME_WILD)
           AND
            (*member_type_in NE M_DWNLD_NAME_REGULAR)
           AND
            (*member_type_in NE M_DWNLD_NAME_ALL)
          )
       )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_MEMBER_TYPE, member_type_in ,
                     envir_ptr->file_intuser, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
          (strlen (ug_in) EQ 0)
         AND
          (*member_type_in NE M_DWNLD_NAME_ALL)
       )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_GROUP_ID , ug_in ,
                     envir_ptr->file_intug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (MAX_RSS_UG_NAME_LEN LT strlen(ug_in))
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_GROUP_ID, tmp_ug[j].ug,
                     envir_ptr->file_intug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
 
    if (strlen(rss_in)       GT RSS_NAME_LEN)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_RSS_NAME, rss_in,
                     envir_ptr->file_intug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (rss NE NULL AND strncmp (rss, rss_in, RSS_NAME_LEN) EQ 0)
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
          "Skipped %d record (need another rss)" , i);
      continue;
    }
    /*
      LOCATE the group's RSS among the RSSs known in current platform.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      /*
        PROCESS when RSS name - found:
      */
      if (My_stricmp (rss_in, envir_ptr->interest[ii].rss) EQ 0)
      {
        /*
          SET number of groups in found RSS entry - up by 1
        */
        envir_ptr->interest[ii].pre_num_ugs++;
        break;
      }
    }  /* END - FOR loop on known RSSs */
    /*
      EXIT returning fatal error - if RSS is unknown.
    */
    if (ii GE envir_ptr->max_rss_num)
    {
      CTSAMSG_print (ERR_CS_RSS_ENTITY,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     rss_in, envir_ptr->file_intug, fn);
      continue;
    }
    if (envir_ptr->interest[ii].rss[0] EQ '\0')
    {
      CTSAMSG_print (ERR_CS_RSS_INVALID_NAME,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, rss_in, envir_ptr->file_rssparm);
      rc= ESA_FATAL;
      goto cleanup;
    }
    /*
      SET the temporary group's array index up by 1.
    */
    strcpy (tmp_ug [j].rss, rss_in);
    tmp_ug[j].member_type = *member_type_in;
    tmp_ug[j].blank1 = ' ';
    strcpy (tmp_ug [j].ug, ug_in);
    j++;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Next %d ug_rec %s.", j, &tmp_ug[j]);
    /*
      PROCESS when the temporary groups array is full:
    */
    if (j GE TMP_UGS_NUM)
    {
      /*
        PROCESS if no groups memory segment were allocated yet:
      */
      if ((*all_num_ugs) EQ 0)
        /*
          ALLOCATE memory segment for filled temporary groups array.
        */
        rc= CSA_alloc ((char **)all_ugs_ptr, STRUC_INT_UG_REC,
                       sizeof (INTEREST_UG_rec_typ),
                       j, fn, "All Intersting groups");
      else
        /*
          REALOCATE the memory segment - expand it to contain another
          set of temporary groups array.
        */
        rc= CSA_realloc ((char **)all_ugs_ptr, STRUC_INT_UG_REC,
                         sizeof (INTEREST_UG_rec_typ),
                         (*all_num_ugs)+ j);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        COPY all groups in temporary array to the new
        allocated/extended memory segment.
      */
      memcpy ((char *)((*all_ugs_ptr)+ (*all_num_ugs)),
              (char *)tmp_ug,
          sizeof (INTEREST_UG_rec_typ)* j);
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
         "Added Next %d groups to memory %d groups", j, *all_num_ugs);
      /*
        INCREASE the output number of groups in allocated segment - by
        the amount of groups from temporary array.
      */
      (*all_num_ugs) += j;
      /*
        CLEAR the temporary array of groups.
      */
      CLEAR (tmp_ug);
      j= 0;
    }
 
  } /* FOR - loop on all file records */
  /*
    EXIT if no (more) groups were added to the temporary groups array
    since it was created/last copied to the memory segment.
  */
  if (j EQ 0)
    goto cleanup;
  /*
    PROCESS when loop terminated ok.
  */
  if (rc EQ ESA_OK)
      /*
        PROCESS if no groups memory segment were allocated yet:
      */
      if ((*all_num_ugs) EQ 0)
        /*
          ALLOCATE memory segment for the filled groups in temporary
          groups array.
        */
        rc= CSA_alloc ((char **)all_ugs_ptr, STRUC_INT_UG_REC,
                       sizeof (INTEREST_UG_rec_typ),
                       j, fn, "All Intersting groups");
      else
        /*
          REALOCATE the memory segment - expand it to contain the
          details of groups that were filled in the temporary array.
        */
        rc= CSA_realloc ((char **)all_ugs_ptr, STRUC_INT_UG_REC,
                         sizeof (INTEREST_UG_rec_typ),
                         (*all_num_ugs)+ j);
  if (rc EQ ESA_OK)
  {
    /*
      COPY the filled groups in temporary array to the new
      allocated/extended memory segment.
    */
    memcpy ((char *)((*all_ugs_ptr) + (*all_num_ugs)),
            (char *)tmp_ug,
        sizeof (INTEREST_UG_rec_typ)* j);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
         "Added Next %d groups to memory %d groups", j, *all_num_ugs);
    /*
      INCREASE the output number of groups in allocated segment - by
      the number of groups filled in temporary array.
    */
    (*all_num_ugs) += j;
  }
 
  cleanup:
  /*
    CLOSE "Interesting Default Groups" file.
  */
  CSA_close (envir_ptr->file_intug, fn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
                   "Interesting ugs=%d", *all_num_ugs);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_ug_load_without_rss function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_u2ug_load_without_rss           *
*                                                             *
* Description      : Load data from the file to the memory    *
*                      without rss records                    *
* Input            : rss                                      *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* The function is activated in order to scan the "Interesting Groups
* for connections" file - and to load it to a global memory segment.
* The segment is arranged in array format where every entry contains:
* RSS name & Group name. In addition - the function fills in all RSS
* entries, in the RSS array of the envir external data, with the number
* of groups that resides, in the segment, for them.
* The function scans all records from the file, checks the RSS
* existance the Group-name validity and inserts it to a temporary array
* (that contains fixed number of entries). Whenever the temporary array
* is filled - the memory segment allocated for groups is expanded by
* it's size - it's content is copied to the memory allocated, the
* number of output groups is updated and the temporary array is cleared
* - and so on.
**********************************************************************/
 
ESA_RC CARE_int_u2ug_load_without_rss (char       * rss,
                             MEMBER_UG_rec_typ    * pre_u2ugs_ptr,
                             long int             * all_num_u2ugs,
                             INTEREST_UG_rec_typ ** all_u2ugs_ptr)
{
  static char           fn[]="CARE_int_u2ug_load_without_rss";
  ESA_RC                rc = ESA_OK;
  INTEREST_UG_rec_typ   tmp_ug [TMP_UGS_NUM];
  int                   i= 0, j= 0, ii= 0;
  char                  line [sizeof (INTEREST_UG_rec_typ)];
  FILE                * file_handle= NULL;
  char                * ug_in= NULL, *rss_in= NULL, * newline= NULL;
  char                * endline, empty_str = '\0';
  char                * member_type_in= NULL;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
                   "Rss=%s File=%s",
                     (rss EQ NULL) ? "NULL" : rss,
                      envir_ptr->file_intu2ug);
  pre_u2ugs_ptr= NULL; /*???*/
  CLEAR (tmp_ug);
  /*
    OPEN "Interesting Groups" file.
  */
  rc= CSA_open (envir_ptr->file_intu2ug, fn,
                FILE_OPEN_FOR_UPDATE, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
   goto cleanup;
  /*
     SCAN all file record's.
  */
  for (i= 1,j= 0; rc EQ ESA_OK ; i++)
  {
    rss_in            = NULL;
    member_type_in    = NULL;
    ug_in             = NULL;
    endline           = NULL;
    /*
      READ next file's line (record).
    */
    rc= CSA_fgets (envir_ptr->file_intu2ug,
                   line,
                   sizeof(INTEREST_UG_rec_typ),
                   file_handle);
    if (rc EQ ESA_EOF)
    {
        rc= ESA_OK;
        break;
    }
    if (rc NE ESA_OK)
        goto cleanup;
 
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
               "record %d is %s.", i+ 1, line);
    /*
      COPY the group details to NEXT entry in temporary groups details
      arry.
    */
    memcpy ((char *)(&tmp_ug [j]), (char *)line,
            sizeof(INTEREST_UG_rec_typ));
 
    newline = strchr(line,'\n');
    if (newline NE NULL)
      strcpy (newline,"\0");
    rss_in=  strtok (line, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"rss_in=%p/%s.",
		rss_in, (rss_in) ? rss_in : "NULL");
    member_type_in= strtok (NULL, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"member_type_in=%p/%s.",
		member_type_in, (member_type_in) ? member_type_in : "NULL");
    ug_in= strtok (NULL, " ");
	endline= strtok (NULL, " ");
    if (ug_in EQ 0)
       ug_in = &empty_str;
	else
    {
       while (endline NE NULL)
	   {
          ug_in [strlen(ug_in)] = ' ';
          ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"while ug_in=%s.", ug_in);
          endline           = strtok (NULL, " ");
	   }
	}
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"ug_in=%p/%s.", ug_in, ug_in);
 
    /*
      SKIP current group (do not set array index up by 1) if the line
      is empty or the RSS name is empty.
    */
    if (
          (line[0] EQ NULL_CHAR)
         OR
          (line[0] EQ SKIP_LINE)
         OR
          (rss_in EQ NULL)
       )
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Skipped %d record" , i);
      continue;
    }
    if (member_type_in EQ NULL)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               C_MEMBER_TYPE, "", envir_ptr->file_intu2ug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
          (strlen(member_type_in)       GT 1)
         OR
          (
            (*member_type_in NE M_DWNLD_NAME_WILD)
           AND
            (*member_type_in NE M_DWNLD_NAME_REGULAR)
           AND
            (*member_type_in NE M_DWNLD_NAME_ALL)
           AND
            (*member_type_in NE M_DWNLD_NAME_IGNORE)
          )
       )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_MEMBER_TYPE, member_type_in ,
                     envir_ptr->file_intu2ug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
          (strlen (ug_in) EQ 0)
         AND
          (*member_type_in NE M_DWNLD_NAME_ALL)
       )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_GROUP_ID , ug_in,
                     envir_ptr->file_intu2ug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (strlen(rss_in)       GT RSS_NAME_LEN)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_RSS_NAME, rss_in,
                     envir_ptr->file_intu2ug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (MAX_RSS_UG_NAME_LEN LT strlen(ug_in))
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_GROUP_ID, ug_in,
                     envir_ptr->file_intu2ug, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (rss NE NULL AND strncmp (rss, rss_in, RSS_NAME_LEN) EQ 0)
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
          "Skipped %d record (need another rss)" , i);
      continue;
    }
    /*
      LOCATE the group's RSS among the RSSs known in current platform.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      /*
        PROCESS when RSS name - found:
      */
      if (My_stricmp (rss_in, envir_ptr->interest[ii].rss) EQ 0) {
        /*
          SET number of groups in found RSS entry - up by 1
        */
        envir_ptr->interest[ii].pre_num_u2ugs++;
        break;
      }
    } /* END - FOR loop on known RSSs */
    /*
      EXIT returning fatal error - if RSS is unknown.
    */
    if (ii GE envir_ptr->max_rss_num)
    {
      CTSAMSG_print (ERR_CS_RSS_ENTITY,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     rss_in, envir_ptr->file_intu2ug, fn);
      continue;
    }
    if (envir_ptr->interest[ii].rss[0] EQ '\0')
    {
      CTSAMSG_print (ERR_CS_RSS_INVALID_NAME,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, rss_in, envir_ptr->file_rssparm);
      rc= ESA_FATAL;
      goto cleanup;
    }
 
    strcpy (tmp_ug [j].rss, rss_in);
    tmp_ug[j].member_type = *member_type_in;
    tmp_ug[j].blank1 = ' ';
    strcpy (tmp_ug [j].ug, ug_in);
    j++;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Next %d u2ug_rec %s.", j, &tmp_ug[j]);
    /*
      SET the temporary group's array index up by 1.
    */
    if (j GE TMP_UGS_NUM)
    {
      /*
        PROCESS if no groups memory segment were allocated yet:
      */
      if ((*all_num_u2ugs) EQ 0)
        /*
          ALLOCATE memory segment for filled temporary groups array.
        */
        rc= CSA_alloc ((char **)all_u2ugs_ptr, STRUC_INT_UG_REC,
                       sizeof (INTEREST_UG_rec_typ),
                       j, fn, "All Intersting connections");
      else
        /*
          REALOCATE the memory segment - expand it to contain another
          set of temporary groups array.
        */
        rc= CSA_realloc ((char **)all_u2ugs_ptr, STRUC_INT_UG_REC,
                         sizeof (INTEREST_UG_rec_typ),
                         (*all_num_u2ugs)+ j);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        COPY all groups in temporary array to the new
        allocated/extended memory segment.
      */
      memcpy ((char *)((*all_u2ugs_ptr)+ (*all_num_u2ugs)),
              (char *)tmp_ug,
              sizeof (INTEREST_UG_rec_typ)* j);
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
         "Added Next %d u2ugs to memory %d u2ugs", j, *all_num_u2ugs);
      /*
        INCREASE the output number of groups in allocated segment - by
        the amount of groups from temporary array.
      */
      (*all_num_u2ugs) += j;
      /*
        CLEAR the temporary array of groups.
      */
      CLEAR (tmp_ug);
      j= 0;
    }
 
  } /* FOR - loop on all file records */
  /*
    EXIT if no (more) groups were added to the temporary groups array
    since it was created/last copied to the memory segment.
  */
  if (j EQ 0)
    goto cleanup;
  /*
    PROCESS when loop terminated ok.
  */
  if (rc EQ ESA_OK)
      /*
        PROCESS if no groups memory segment were allocated yet:
      */
      if ((*all_num_u2ugs) EQ 0)
        /*
          ALLOCATE memory segment for the filled groups in temporary
          groups array.
        */
        rc= CSA_alloc ((char **)all_u2ugs_ptr, STRUC_INT_UG_REC,
                       sizeof (INTEREST_UG_rec_typ),
                       j, fn, "All Intersting connections");
      else
        /*
          REALOCATE the memory segment - expand it to contain the
          details of groups that were filled in the temporary array.
        */
        rc= CSA_realloc ((char **)all_u2ugs_ptr, STRUC_INT_UG_REC,
                         sizeof (INTEREST_UG_rec_typ),
                         (*all_num_u2ugs)+ j);
  if (rc EQ ESA_OK)
  {
    /*
      COPY the filled groups in temporary array to the new
      allocated/extended memory segment.
    */
    memcpy ((char *)((*all_u2ugs_ptr)+(*all_num_u2ugs)),
            (char *)tmp_ug,
            sizeof (INTEREST_UG_rec_typ)* j);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
       "Added Next %d u2ugs to memory %d u2ugs", j, *all_num_u2ugs);
    /*
      INCREASE the output number of groups in allocated segment - by
      the number of groups filled in temporary array.
    */
    (*all_num_u2ugs) += j;
  }
 
  cleanup:
  /*
    CLOSE "Interesting Default Groups" file.
  */
  CSA_close (envir_ptr->file_intu2ug, fn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
                   "Interesting u2ugs=%d", *all_num_u2ugs);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_u2ug_load_without_rss function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_oe_load_without_rss             *
*                                                             *
* Description      : Load data from the file to the memory    *
*                    without rss records                      *
* Input            : rss                                      *
***************************************************************
*
* DETAILED DESCRIPTION
* ====================
*
* The function is activated in order to scan the "Interesting Default
* Containers" file - and to load it to a global memory segment.
* The segment is arranged in array format where every entry contains:
* RSS name & Container name. In addition - the function fills in all RSS
* entries, in the RSS array of the envir external data, with the number
* of containers that resides, in the segment, for them.
* The function scans all records from the file, checks the RSS
* existance the container-name validity and inserts it to a temporary
* array (that contains fixed number of entries). Whenever the temporary
* array is filled - the memory segment allocated for containers is
* expanded by its size - its contents is copied to the memory allocated,
* the number of output containers is updated and the temporary array is
* cleared - and so on.
**********************************************************************/
 
ESA_RC CARE_int_oe_load_without_rss (
        char                 * rss,
        long int             * all_num_oes,
        INTEREST_OE_rec_typ ** all_oes_ptr)
{
  char fn[]="CARE_int_oe_load_without_rss";
  ESA_RC                  rc = ESA_OK;
  INTEREST_OE_rec_typ     tmp_oe [TMP_OES_NUM];
  int                     i= 0, j= 0, ii= 0;
  char                    line [sizeof (INTEREST_OE_rec_typ)];
  FILE                  * file_handle= NULL;
  char                  * oe_in= NULL, *rss_in= NULL, * newline= NULL;
  char                  * endline, empty_str = '\0';
  char                  * member_type_in= NULL;
  ENVIRONMENT_rec_typ   * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 13,
                   "Rss=%s File=%s",
                   (rss EQ NULL) ? "NULL" : rss,
                   envir_ptr->file_intoe);
 
  CLEAR (tmp_oe);
  /*
    OPEN "Interesting Container" file.
  */
  rc= CSA_open (envir_ptr->file_intoe, fn,
                FILE_OPEN_FOR_UPDATE, &file_handle, SCOPE_LOCAL);
  if (rc NE ESA_OK)
   goto cleanup;
  /*
     SCAN all file record's.
  */
 
  for (i= 1,j= 0; rc EQ ESA_OK ; i++)
  {
    rss_in            = NULL;
    member_type_in    = NULL;
    oe_in             = NULL;
    endline           = NULL;
    /*
      READ next file's line (record).
    */
    rc= CSA_fgets (envir_ptr->file_intoe,
                   line,
                   sizeof(INTEREST_OE_rec_typ),
                   file_handle);
    if (rc EQ ESA_EOF)
    {
        rc= ESA_OK;
        break;
    }
    if (rc NE ESA_OK)
        goto cleanup;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
               "record %d is %s.", i+ 1, line);
    /*
     * Copy the container details to NEXT entry in temporary
     * containers details array.
    */
    memcpy ((char *)(&tmp_oe [j]), (char *)line,
            sizeof(INTEREST_OE_rec_typ));
    newline = strchr(line,'\n');
    if (newline NE NULL)
      strcpy (newline,"\0");
    rss_in=  strtok (line, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"rss_in=%p/%s.",
		rss_in, (rss_in) ? rss_in : "NULL");
    member_type_in= strtok (NULL, " ");
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"member_type_in=%p/%s.",
		member_type_in, (member_type_in) ? member_type_in : "NULL");
    oe_in= strtok (NULL, " ");
	endline= strtok (NULL, " ");
    if (oe_in EQ 0)
       oe_in = &empty_str;
	else
    {
       while (endline NE NULL)
	   {
          oe_in [strlen(oe_in)] = ' ';
          ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"while oe_in=%s.", oe_in);
          endline           = strtok (NULL, " ");
	   }
	}
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,"oe_in=%p/%s.", oe_in, oe_in);
 
    /*
      Skip current container (do not set array index up by 1) if the
      line is empty or the RSS name is empty.
    */
    if (
          (line[0] EQ NULL_CHAR)
         OR
          (line[0] EQ SKIP_LINE)
         OR
          (rss_in EQ NULL)
       )
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Skipped %d record" , i);
      continue;
    }
    /*
      EXIT, returning fatal error if the RSS name or the container
      name is invalid.
    */
    if (member_type_in EQ NULL)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
               envir_ptr->msg_params.ctsamsg_handle, NULL,
               envir_ptr->msg_params.ctsamsg_dest,
               C_MEMBER_TYPE, "", envir_ptr->file_intoe, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
          (strlen(member_type_in)       GT 1)
         OR
          (
            (*member_type_in NE M_DWNLD_NAME_WILD)
           AND
            (*member_type_in NE M_DWNLD_NAME_REGULAR)
           AND
            (*member_type_in NE M_DWNLD_NAME_ALL)
          )
       )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_MEMBER_TYPE, member_type_in ,
                     envir_ptr->file_intoe, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (
          (oe_in EQ NULL)
         AND
          (*member_type_in NE M_DWNLD_NAME_ALL)
       )
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_OE_ID , oe_in ,
                     envir_ptr->file_intoe, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
 
    if (strlen(rss_in)       GT RSS_NAME_LEN)
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_RSS_NAME, rss_in,
                     envir_ptr->file_intoe, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (MAX_RSS_OE_NAME_LEN LT strlen(oe_in))
    {
      CTSAMSG_print (ERR_CS_PRM_LEN,
                     envir_ptr->msg_params.ctsamsg_handle, NULL,
                     envir_ptr->msg_params.ctsamsg_dest,
                     C_OE_ID, oe_in,
                     envir_ptr->file_intoe, i);
      rc= ESA_FATAL;
      goto cleanup;
    }
    if (rss NE NULL AND strncmp (rss, rss_in, RSS_NAME_LEN) EQ 0)
    {
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
          "Skipped %d record (need another rss)" , i);
      continue;
    }
    /*
      LOCATE the container's RSS among the RSSs known in current
      platform.
    */
    for (ii= 0; ii LT envir_ptr->max_rss_num; ii++)
    {
      /*
        PROCESS when RSS name - found:
      */
      if (My_stricmp (rss_in, envir_ptr->interest[ii].rss) EQ 0)
      {
        /*
          SET number of containers in found RSS entry - up by 1
        */
        envir_ptr->interest[ii].pre_num_oes++;
        break;
      }
    }  /* END - FOR loop on known RSSs */
    /*
      EXIT returning fatal error - if RSS is unknown.
    */
    if (ii GE envir_ptr->max_rss_num)
    {
      CTSAMSG_print (ERR_CS_RSS_ENTITY,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     rss_in, envir_ptr->file_intoe, fn);
      continue;
    }
    if (envir_ptr->interest[ii].rss[0] EQ '\0')
    {
      CTSAMSG_print (ERR_CS_RSS_INVALID_NAME,
                     envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                     envir_ptr->msg_admin_param.ctsamsg_dest,
                     fn, rss_in, envir_ptr->file_rssparm);
      rc= ESA_FATAL;
      goto cleanup;
    }
    /*
      SET the temporary container's array index up by 1.
    */
    strcpy (tmp_oe [j].rss, rss_in);
    tmp_oe[j].member_type = *member_type_in;
    tmp_oe[j].blank1 = ' ';
    strcpy (tmp_oe [j].oe, oe_in);
    j++;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                   "Next %d oe_rec %s.", j, &tmp_oe[j]);
    /*
      PROCESS when the temporary containers array is full:
    */
    if (j GE TMP_OES_NUM)
    {
      /*
        PROCESS if no containers memory segment were allocated yet:
      */
      if ((*all_num_oes) EQ 0)
        /*
          ALLOCATE memory segment for filled temporary containers array.
        */
        rc= CSA_alloc ((char **)all_oes_ptr, STRUC_INT_OE_REC,
                       sizeof (INTEREST_OE_rec_typ),
                       j, fn, "All Intersting containers");
      else
        /*
          REALOCATE the memory segment - expand it to contain another
          set of temporary containers array.
        */
        rc= CSA_realloc ((char **)all_oes_ptr, STRUC_INT_OE_REC,
                         sizeof (INTEREST_OE_rec_typ),
                         (*all_num_oes)+ j);
      if (rc NE ESA_OK)
        goto cleanup;
      /*
        COPY all container in temporary array to the new
        allocated/extended memory segment.
      */
      memcpy ((char *)((*all_oes_ptr)+(*all_num_oes)),
              (char *)tmp_oe,
           sizeof (INTEREST_OE_rec_typ)* j);
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
         "Added Next %d oes to memory %d oes", j, *all_num_oes);
      /*
        INCREASE the output number of containers in allocated segment -
        by the amount of containers from temporary array.
      */
      (*all_num_oes) += j;
      /*
        CLEAR the temporary array of containers.
      */
      CLEAR (tmp_oe);
      j= 0;
    }
 
  } /* FOR - loop on all file records */
  /*
    EXIT if no (more) containers were added to the temporary containers
    array since it was created/last copied to the memory segment.
  */
  if (j EQ 0)
    goto cleanup;
  /*
    PROCESS when loop terminated ok.
  */
  if (rc EQ ESA_OK)
      /*
        PROCESS if no containers memory segment were allocated yet:
      */
      if ((*all_num_oes) EQ 0)
        /*
          ALLOCATE memory segment for the filled containers in temporary
          containers array.
        */
        rc= CSA_alloc ((char **)all_oes_ptr, STRUC_INT_OE_REC,
                       sizeof (INTEREST_OE_rec_typ),
                       j, fn, "All Intersting containers");
      else
        /*
          REALOCATE the memory segment - expand it to contain the
          details of containers that were filled in the temporary array.
        */
        rc= CSA_realloc ((char **)all_oes_ptr, STRUC_INT_OE_REC,
                         sizeof (INTEREST_OE_rec_typ),
                         (*all_num_oes)+ j);
  if (rc EQ ESA_OK)
  {
    /*
      COPY the filled containers in temporary array to the new
      allocated/extended memory segment.
    */
    memcpy ((char *)((*all_oes_ptr) + (*all_num_oes)),
            (char *)tmp_oe,
        sizeof (INTEREST_OE_rec_typ)* j);
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
       "Added Next %d oes to memory %d oes", j, *all_num_oes);
    /*
      INCREASE the output number of containers in allocated segment - by
      the number of containers filled in temporary array.
    */
    (*all_num_oes) += j;
  }
 
  cleanup:
  /*
    CLOSE "Interesting Default containers" file.
  */
  CSA_close (envir_ptr->file_intoe, fn);
  if (rc NE ESA_OK)
    CTSAMSG_print (ERR_CS_FUNCTION,
                   envir_ptr->msg_admin_param.ctsamsg_handle, NULL,
                   envir_ptr->msg_admin_param.ctsamsg_dest, fn);
  ESA_DIAG_printf (ESA_COMP_ACSCARF, 14,
                   "Interesting oes=%d", *all_num_oes);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return rc;
 
} /* END - CARE_int_oe_load_without_rss function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_get_next_oe
*                                                             *
* Description      : Get next container
*                      from list of increment containers
* Input            : from container number in these lists
* Output           : OE_typ
*                  : Number filled containers
**************************************************************/
 
void CARE_inc_get_next_oe (OE_typ oe,
                           int    from_num_oe)
{
  MEMBER_OE_rec_typ   * oe_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
  char                  fn[]="CARE_inc_get_next_oe";
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CS_get_envir_address (&envir_ptr);
  oe_rec = envir_ptr->oes_ptr+ from_num_oe;
  strcpy (oe, oe_rec->oe);
  ESA_DIAG_printf(ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
                  "Next %d Container %s.", from_num_oe, oe);
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_object_in_oe
*                                                             *
* Description      : determine if group is in list of
*                      intcrement containers
* Return Value     : ESA_OK or ESA_KEY_NOT_FOUND (exist or not)
*                                                             *
***************************************************************/
 
ESA_RC CARE_inc_object_in_oe (char            * object,
                              OBJECT_TYPE_typ   object_type)
{
  ESA_RC                rc = ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  int                   ii, jj= 0;
  MEMBER_OE_rec_typ   * oe_ptr;
  char                  fn[]="CARE_inc_object_in_oe";
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CARE_obj_type (ESA_COMP_ACSCARF, object , object_type);
 
  rc= ESA_KEY_NOT_FOUND;
  for (ii= 0;
       ii LT envir_ptr->num_oes;
       ii++)
  {
     oe_ptr = envir_ptr->oes_ptr + ii;
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "%s: %d) - Container=%s type %c.",
                      fn, ii, oe_ptr->oe, oe_ptr->member_type);
     if (oe_ptr->member_type EQ M_DWNLD_NAME_ALL)
     {
        rc = ESA_OK;
        break;
     }
 
     if (jj EQ 0)
	 {
        rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
        if (rc NE ESA_OK)
           break;
	    jj++;
	 }
     if (object_type EQ TYPE_GROUP)
     {
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsUGInOE USA-API for UG=%s OE=%s.", object, oe_ptr->oe);
        rc= envir_ptr->func_ptr.isuginoe_ptr (object,
                                         oe_ptr->oe,
                                         &envir_ptr->msg_admin_param,
                                         &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsUGInOE USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
     }
     else if (object_type EQ TYPE_USER)
     {
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsUserInOE USA-API for USER=%s OE=%s.", object, oe_ptr->oe);
        rc= envir_ptr->func_ptr.isuserinoe_ptr (object,
                                           oe_ptr->oe,
                                           &envir_ptr->msg_admin_param,
                                           &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsUserInOE USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
     }
     else if (object_type EQ TYPE_CONTAINER)
     {
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsOEInOE USA-API for OE=%s OE=%s.", object, oe_ptr->oe);
        rc= envir_ptr->func_ptr.isoeinoe_ptr (object,
                                         oe_ptr->oe,
                                         &envir_ptr->msg_admin_param,
                                         &envir_ptr->msg_err);
        ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsOEInOE USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
     }
 
     if (rc EQ ESA_OK)
        break;
  }
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
  if (rc EQ ESA_OK)
     rc= rc_logout;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CARE_inc_object_in_oe function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_int_object_in_oe                    *
*                                                             *
* Description      : determine if group is in list of         *
*                    interesting containers                   *
* Input            : ug                                       *
* Return Value     : ESA_OK                                   *
**************************************************************/
 
ESA_RC CARE_int_object_in_oe (char            * object,
                              OBJECT_TYPE_typ   object_type)
{
  char                  fn[]="CARE_int_object_in_oe";
  ESA_RC                rc= ESA_KEY_NOT_FOUND, rc_logout= ESA_OK;
  int                   ii= 0, jj= 0;
  MEMBER_OE_rec_typ   * oe_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
  CARE_obj_type (ESA_COMP_ACSCARF, object , object_type);
 
  /*
    SEARCH the container in list of the 'interesting containers'
  */
  rc= ESA_KEY_NOT_FOUND;
  for(ii= 0;
      ii LT envir_ptr->interest[envir_ptr->rss_num].pre_num_oes;
      ii++)
  {
    oe_rec = envir_ptr->interest[envir_ptr->rss_num].pre_oes_ptr + ii;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
       "%s: %d) - Container=%s type %c.",
       fn, ii, oe_rec->oe, oe_rec->member_type);
    if (oe_rec->member_type EQ M_DWNLD_NAME_ALL)
    {
       rc = ESA_OK;
          break;
    }
 
    if (jj EQ 0)
	{
       rc= ADM_loginout (LOGIN_MODE, LOGIN_DEFAULT_ADMIN, fn);
       if (rc NE ESA_OK)
          break;
       jj++;
	}
    if (object_type EQ TYPE_GROUP)
	{
       ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsUGInOE USA-API for UG=%s OE=%s.", object, oe_rec->oe);
       rc= envir_ptr->func_ptr.isuginoe_ptr (object, oe_rec->oe,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsUGInOE USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
    }
    else if (object_type EQ TYPE_USER)
	{
       ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsUserInOE USA-API for USER=%s OE=%s.", object, oe_rec->oe);
       rc= envir_ptr->func_ptr.isuserinoe_ptr (object, oe_rec->oe,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsUserInOE USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
    }
    else if (object_type EQ TYPE_CONTAINER)
	{
       ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
    		"    -> Call to CTSIsOEInOE USA-API for OE=%s OE=%s.", object, oe_rec->oe);
       rc= envir_ptr->func_ptr.isoeinoe_ptr (object, oe_rec->oe,
                                     &envir_ptr->msg_admin_param,
                                     &envir_ptr->msg_err);
       ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC,
	    		"    <- CTSIsOEInOE USA-API completed with rc=%d (%s).",
		    	rc, (rc EQ ESA_OK) ? "YES" : "NO");
	}
    if (rc EQ ESA_OK)
        break;
  } /* END - loop over interesting containers. */
  if (jj)
     rc_logout= ADM_loginout (LOGOUT_MODE, LOGIN_DEFAULT_ADMIN, fn);
 
  if (rc EQ ESA_OK)
     rc= rc_logout;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return (rc);
 
} /* END - CARE_int_object_in_oe function */
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_inc_def_ugs_fill
*                                                             *
* Description      : Fill UG_PARAMS array with groups
*                      from list of increment (default) groups
* Input            : from group number in these lists
* Output           : Array of UG_PARAMS
*                  : Number filled groups
**************************************************************/
 
ESA_RC CARE_inc_def_ugs_fill (UG_typ   ug_in[1],
                              int    * from_num_ug,
                              short  * filled_num_ugs)
{
  char                  fn[]="CARE_inc_def_ugs_fill";
  int                   i;
  MEMBER_UG_rec_typ   * ug_rec;
  ENVIRONMENT_rec_typ * envir_ptr;
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  CS_get_envir_address (&envir_ptr);
 
  *filled_num_ugs= 0;
  for (i= (*from_num_ug);
       i LT envir_ptr->num_ugs AND *filled_num_ugs LT MAX_GET;
       i++, (*filled_num_ugs)++)
  {
     ug_rec = envir_ptr->ugs_ptr+ i;
     strcpy (ug_in[*filled_num_ugs], ug_rec->ug);
     ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
       "%s: %d ug - %s (type %c)",
       fn, i, ug_rec->ug, ug_rec->member_type);
  }
 
  (*from_num_ug) =i;
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_OK);
  return (ESA_OK);
}
 
/**************************************************************
*                                                             *
* Procedure Name   : CARE_interesting_list_check              *
*                                                             *
* Description      : Check differences between current        *
*                    AND previos interesting lists            *
* Input            :                                          *
* Return Value     : ESA_OK                                   *
**************************************************************/
 
ESA_RC CARE_interesting_list_check (void)
{
  char                  fn[]="CARE_interesting_list_check";
  ESA_RC                rc= ESA_OK, rc_cmp= ESA_OK;
  int                   ii= 0, jj= 0, inc_num, int_num, count;
  MEMBER_USER_rec_typ * int_user_rec,* int_user_ptr;
  MEMBER_USER_rec_typ * inc_user_rec,* inc_user_ptr;
  MEMBER_UG_rec_typ   * int_ug_rec, * int_ug_ptr;
  MEMBER_UG_rec_typ   * inc_ug_rec, * inc_ug_ptr;
  MEMBER_OE_rec_typ   * int_oe_rec, * int_oe_ptr;
  MEMBER_OE_rec_typ   * inc_oe_rec, * inc_oe_ptr;
  OBJECT_TYPE_typ       obj_type= TYPE_IGNORE;
  char                  int_member_type, inc_member_type;
  char                  int_account[MAX (MAX_RSS_USER_NAME_LEN,
                                         MAX (MAX_RSS_OE_NAME_LEN,
                                              MAX_RSS_UG_NAME_LEN))];
  char                  inc_account[MAX (MAX_RSS_USER_NAME_LEN,
                                         MAX (MAX_RSS_OE_NAME_LEN,
                                              MAX_RSS_UG_NAME_LEN))];
  char                  text_type[11];
  int                   sw_continue, sw_end;
  int                   sw_group, sw_user, sw_connection, sw_container;
  char                  case_sensitive[RSSPRM_VALUE_LEN+ 1], SkipScopeCheck[2];
  ENVIRONMENT_rec_typ * envir_ptr;
 
  CS_get_envir_address (&envir_ptr);
 
  ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
  rc= rssprm_get_opt (envir_ptr->msg_admin_param.rss_name,
                      "SKIP_SCOPE_CHECK", 1, SkipScopeCheck, OPT_TRUE, OPT_TRUE);
  if (rc NE ESA_OK)
  {
     SkipScopeCheck[0]= ESS_YES_SIGN;
     rc= ESA_OK;
  }
  if (SkipScopeCheck[0] NE ESS_NOT_SIGN)
  {
     ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_BASIC+ 1, "Scope check is skiped.");
     goto cleanup;
  }
 
  rc= rssprm_get_opt (envir_ptr->msg_admin_param.rss_name,
                      ADMIN_CASE_SENSITIVE,
                      1,
                      case_sensitive,
                      OPT_TRUE,
                      OPT_TRUE);
  if (rc NE ESA_OK)
  {
     case_sensitive[0]= ESS_YES_SIGN;
     rc= ESA_OK;
  }
 
  for (obj_type     = TYPE_IGNORE,
       sw_end       = FALSE,
       sw_group     = FALSE,
       sw_user      = FALSE,
       sw_connection= FALSE,
       sw_container = FALSE;
       ;
       obj_type++, sw_continue= FALSE)
  {
    switch (obj_type)
    {
      case TYPE_GROUP:
        int_num= envir_ptr->interest[envir_ptr->rss_num].pre_num_ugs;
        inc_num= envir_ptr->num_ugs;
        int_ug_ptr=
            envir_ptr->interest[envir_ptr->rss_num].pre_ugs_ptr;
        inc_ug_ptr = envir_ptr->ugs_ptr;
        strcpy (text_type, "GROUP");
        sw_group= TRUE;
        break;
      case TYPE_CONNECTION:
        int_num= envir_ptr->interest[envir_ptr->rss_num].pre_num_u2ugs;
        inc_num= envir_ptr->num_u2ugs;
        int_ug_ptr =
            envir_ptr->interest[envir_ptr->rss_num].pre_u2ugs_ptr;
        inc_ug_ptr = envir_ptr->u2ugs_ptr;
        strcpy (text_type, "CONNECTION");
        sw_connection= TRUE;
        break;
      case TYPE_CONTAINER:
        int_num= envir_ptr->interest[envir_ptr->rss_num].pre_num_oes;
        inc_num= envir_ptr->num_oes;
        int_oe_ptr =
            envir_ptr->interest[envir_ptr->rss_num].pre_oes_ptr;
        inc_oe_ptr = envir_ptr->oes_ptr;
        strcpy (text_type, "CONTAINER");
        sw_container= TRUE;
        break;
      case TYPE_USER:
        int_num= envir_ptr->interest[envir_ptr->rss_num].pre_num_users;
        inc_num= envir_ptr->num_users;
        int_user_ptr =
            envir_ptr->interest[envir_ptr->rss_num].pre_users_ptr;
        inc_user_ptr = envir_ptr->users_ptr;
        strcpy (text_type, "USER");
        sw_user= TRUE;
        break;
      default:
        if (
              (sw_group      EQ TRUE)
             AND
              (sw_user       EQ TRUE)
             AND
              (sw_connection EQ TRUE)
             AND
              (sw_container  EQ TRUE)
           )
           sw_end=   TRUE;
        sw_continue= TRUE;
        break;
    }
    if (sw_end EQ TRUE)
       break;
    if (sw_continue EQ TRUE)
       continue;
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "Type %s: inc_num=%d int_num=%d.",
                      text_type, (int)inc_num, (int)int_num);
    if (int_num NE inc_num)
    {
       rc= ESA_KEY_NOT_FOUND;
       goto cleanup;
    }
    for (ii= 0, count= 0; ii LT int_num; ii++)
    {
      switch (obj_type) {
        case TYPE_GROUP:
          int_ug_rec= int_ug_ptr+ ii;
          int_member_type= int_ug_rec->member_type;
          strcpy (int_account, int_ug_rec->ug);
          break;
        case TYPE_CONNECTION:
          int_ug_rec= int_ug_ptr+ ii;
          int_member_type= int_ug_rec->member_type;
          strcpy (int_account, int_ug_rec->ug);
          break;
        case TYPE_CONTAINER:
          int_oe_rec= int_oe_ptr+ ii;
          int_member_type= int_oe_rec->member_type;
          strcpy (int_account, int_oe_rec->oe);
          break;
        case TYPE_USER:
          int_user_rec= int_user_ptr+ ii;
          int_member_type= int_user_rec->member_type;
          strcpy (int_account, int_user_rec->user);
          break;
        default:
          ESA_DIAG_printf (ESA_COMP_ACSCARF, DIAG_DETAILES+ 1,
			  "ii=%d Obj.Type=%c.",ii, obj_type);
          break;
      }
      ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                      "INT %d: %s=%s type=%c.",
                       ii, text_type, int_account, int_member_type);
 
      for (jj= 0; jj LT inc_num; jj++)
      {
        switch (obj_type) {
          case TYPE_GROUP:
            inc_ug_rec= inc_ug_ptr+ jj;
            inc_member_type= inc_ug_rec->member_type;
            strcpy (inc_account, inc_ug_rec->ug);
            break;
          case TYPE_CONNECTION:
            inc_ug_rec= inc_ug_ptr+ jj;
            inc_member_type= inc_ug_rec->member_type;
            strcpy (inc_account, inc_ug_rec->ug);
            break;
          case TYPE_CONTAINER:
            inc_oe_rec= inc_oe_ptr+ jj;
            inc_member_type= inc_oe_rec->member_type;
            strcpy (inc_account, inc_oe_rec->oe);
            break;
          case TYPE_USER:
            inc_user_rec= inc_user_ptr+ jj;
            inc_member_type= inc_user_rec->member_type;
            strcpy (inc_account, inc_user_rec->user);
            break;
          default:
            ESA_DIAG_printf (ESA_COMP_ACSCARF,DIAG_DETAILES+ 1,
			  "jj=%d Obj.Type=%c.",jj, obj_type);
            break;
        }
        ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "INC %d: %s=%s type=%c.",
                      jj, text_type, inc_account, inc_member_type);
 
        if (case_sensitive[0] EQ ESS_YES_SIGN)
           rc_cmp= (long int)strcmp (int_account, inc_account);
        else
           rc_cmp= My_stricmp (int_account, inc_account);
 
        if (
              (int_member_type EQ inc_member_type)
             AND
              (rc_cmp EQ ESA_OK)
           )
           break;
      }
      if (jj LT inc_num)
         count++;
      else
      {
         rc= ESA_KEY_NOT_FOUND;
         goto cleanup;
      }
 
    }
    ESA_DIAG_printf (ESA_COMP_ACSCARF, 16,
                     "Type %s: count=%d int_num=%d.",
                      text_type, (int)count, (int)int_num);
    if (count NE int_num)
    {
       rc= ESA_KEY_NOT_FOUND;
       goto cleanup;
    }
  }
 
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, rc);
  return (rc);
}
 
void CARE_type (unsigned int   comp,
				char         * func,
				char         * AcntName,
				char         * Acnt,
				char           AcntType)
{
   char MaskName[30];
   char                  fn[]="CARE_type";
 
   ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
   if (ESA_DIAG_get_debug_level(comp) LT (int)DIAG_DETAILES)
		goto cleanup;
   switch (AcntType)
   {
      case M_DWNLD_NAME_REGULAR:
         strcpy (MaskName, "REGULAR");
         break;
      case M_DWNLD_NAME_WILD:
         strcpy (MaskName, "WILD");
         break;
      case M_DWNLD_NAME_ALL:
         strcpy (MaskName, "ALL");
         break;
      case M_DWNLD_NAME_IGNORE:
         strcpy (MaskName, "IGNORE");
         break;
	  default :
         strcpy (MaskName, "UNDEFINED!!!");
         break;
   }
 
   ESA_DIAG_printf (comp, DIAG_DETAILES,
     "     %s: Check scope for %s=%s MaskType=%s.",func, AcntName,
	 (*Acnt EQ '\0') ? "ALL" : Acnt, MaskName);
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
void CARE_interest (unsigned int     comp,
					char           * func,
					ESS_INTRST_typ   InterestType)
{
   char InterestName[30];
   int  scope= FALSE;
   char                  fn[]="CARE_interest";
 
   ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
   if (ESA_DIAG_get_debug_level(comp) LT (int)DIAG_DETAILES)
		goto cleanup;
   switch (InterestType)
   {
      case ESS_DONT_CARE:
         strcpy (InterestName, "ESS_DONT_CARE");
         break;
      case ESS_USER_CARE:
         strcpy (InterestName, "ESS_USER_CARE");
		 scope= TRUE;
         break;
      case ESS_GROUP_CARE:
         strcpy (InterestName, "ESS_GROUP_CARE");
		 scope= TRUE;
         break;
      case ESS_U2UG_CARE:
         strcpy (InterestName, "ESS_U2UG_CARE");
		 scope= TRUE;
         break;
      case ESS_OE_CARE:
         strcpy (InterestName, "ESS_OE_CARE");
		 scope= TRUE;
         break;
	  default :
         strcpy (InterestName, "UNDEFINED!!!");
         break;
   }
 
   ESA_DIAG_printf (comp, DIAG_DETAILES, "     %s: The account %s (%s)",
	   func, (scope EQ TRUE) ? "in previous scope" : "not in previous scope", InterestName);
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
 
void CARE_obj_type (unsigned int      comp,
			    	char            * AcntName,
				    OBJECT_TYPE_typ   ObjType)
{
   char ObjTypeName[30];
   char                  fn[]="CARE_obj_type";
 
   ESA_DIAG_enter (ESA_COMP_ACSCARF, DIAG_COMMON, fn);
 
   if (ESA_DIAG_get_debug_level(comp) LT (int)DIAG_DETAILES)
		goto cleanup;
   switch (ObjType)
   {
      case TYPE_IGNORE:
         strcpy (ObjTypeName, "TYPE_IGNORE");
         break;
      case TYPE_USER:
         strcpy (ObjTypeName, "TYPE_USER");
         break;
      case TYPE_GROUP:
         strcpy (ObjTypeName, "TYPE_GROUP");
         break;
      case TYPE_CONTAINER:
         strcpy (ObjTypeName, "TYPE_CONTAINER");
         break;
      case TYPE_CONNECTION:
         strcpy (ObjTypeName, "TYPE_CONNECTION");
         break;
      case TYPE_ACL:
         strcpy (ObjTypeName, "TYPE_ACL");
         break;
      case TYPE_RSS:
         strcpy (ObjTypeName, "TYPE_RSS");
         break;
      case TYPE_END:
         strcpy (ObjTypeName, "TYPE_END");
         break;
	  default :
         strcpy (ObjTypeName, "UNDEFINED!!!");
         break;
   }
 
   ESA_DIAG_printf (comp, DIAG_DETAILES,
     "Object=%s with %s object type", AcntName, ObjTypeName);
cleanup:
  ESA_DIAG_exit (ESA_COMP_ACSCARF, DIAG_COMMON, fn, ESA_RC_VOID);
  return;
}
